<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="bluebird">
    <body>
      <group id="bluebird">
        <trans-unit id="f76b9571c2fa26f1c9c053453e48baf3102b175e" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;api/reflect&quot;&gt;&lt;code&gt;.reflect()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de27db7a173e23bc1b1a951c986b9e75189651d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutineaddyieldhandlerfunction-handler---void&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debaea1257108cf0777761addbfa5ec8ad866a63" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#tapfunction-handler---promise&quot;&gt;&lt;code&gt;Promise.prototype.tap()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1c43a24101780f93b51137f52374d22e70596b" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.bind&lt;/code&gt; and &lt;code&gt;Promise.bind&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f380a273aee2d6cf970a6fe45244632c5d9b4cc" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.return()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c72d943e49cf756fcbd5f12144b514c9e719f9" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.throw()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae49e6671f17e74abdd91283eaaa890a378ca81b" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;Promise.method()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d181fb40191fdf3fe9541cbc7a61c14dc076b35" translate="yes" xml:space="preserve">
          <source>Implement RejectionError wrapping and &lt;code&gt;.error()&lt;/code&gt; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1c32750ed475d16c2e3d6ee2570476a4351b7a" translate="yes" xml:space="preserve">
          <source>Implemented &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#global-rejection-events&quot;&gt;global rejection events&lt;/a&gt; (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/428&quot;&gt;#428&lt;/a&gt;, &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/357&quot;&gt;#357&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6677e178a6bc2ac6cc38cee7e51212de4486b2b2" translate="yes" xml:space="preserve">
          <source>Implementing general progress interfaces like in C#:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733eea0f9f3a4d9f23332caa166015a4f890c124" translate="yes" xml:space="preserve">
          <source>Implementing the example from &lt;a href=&quot;https://github.com/caolan/async#waterfalltasks-callback&quot;&gt;async homepage&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ecdd3f427cfc303e767bb0913667606529c860" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;Promise.all()&lt;/code&gt; when yielding an array from generators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd411a1bd6013312e12e897a0c51cd4f4318ca0" translate="yes" xml:space="preserve">
          <source>Improve &lt;code&gt;promisifyAll&lt;/code&gt; detection of functions that are class constructors. Fixes mongodb 2.x promisification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213e96bdfb4a128bc3bd87f532efaf90f14c5e6a" translate="yes" xml:space="preserve">
          <source>Improve output of reporting unhandled non-errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21437ff0b7933ce8b58f0d38d668c7b9602b5664" translate="yes" xml:space="preserve">
          <source>Improve overall performance when not using &lt;code&gt;.bind()&lt;/code&gt; or cancellation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cd986d15205ea786fe95cf148b685b17a4a66b" translate="yes" xml:space="preserve">
          <source>Improve overall performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91321dac872eb3a4ecd05762060d481636fa793" translate="yes" xml:space="preserve">
          <source>Improve overall performance. Be able to sustain infinite recursion when using promises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23dc55298841549083703a0dc975bff9f3e5d5fc" translate="yes" xml:space="preserve">
          <source>Improve performance of .finally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5cef6dcb86b0975f111f8f1d79bf5d753600cad" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.props()&lt;/code&gt; and collection methods when used with immediate values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6533fb39d2c4b52d57bf0b0080357de93b567761" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.reduce()&lt;/code&gt; when &lt;code&gt;initialValue&lt;/code&gt; can be synchronously cast to a value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79e5ce64b3cc6df23f96da6189a55cda2f3a24b" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.some()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6605838414ae4861872117f11458f4f7c032e53b" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.method&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1801c2ab62399342798816e151c62d526a208232" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.race&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47c1066dd0e09e1dc6291709e049b1a62126113" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.try&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0221a27976575e573ab343e0c7bf4e30199750e" translate="yes" xml:space="preserve">
          <source>Improve performance of all collection methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bc40cef74e6b8ed6de0d57bc11088841731b08" translate="yes" xml:space="preserve">
          <source>Improve performance of catch filters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493b04565b586c443227bda9dba7b5733786d595" translate="yes" xml:space="preserve">
          <source>Improve performance of collection methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e709b44915764f7a5d40fc9df801ca2e482471" translate="yes" xml:space="preserve">
          <source>Improve performance of generators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f07a6efaf7192742177f90f38e34f5cffb946a" translate="yes" xml:space="preserve">
          <source>Improve performance of promise chains</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab32070153659d73fbda42374c3ef4d00f9c1281" translate="yes" xml:space="preserve">
          <source>Improve performance of promisified functions on V8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c964cafe501b6c71e57bfaecc51d7213a1f33ad" translate="yes" xml:space="preserve">
          <source>Improve performance of promisified functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0964ce694308926e6cce53db966d728b2dd5ab4" translate="yes" xml:space="preserve">
          <source>Improved performance and readability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e80457a02f473b417d800f6ebe8e2a3e15d72c" translate="yes" xml:space="preserve">
          <source>In 2.x, promise cancellation looked very differently. Promise cancellation received a major overhaul for version 3 in order to create a sound variant of cancellable promises. You can still use 2.x cancellation with bluebird 2.x (which is still supported - but not recommended). See &lt;a href=&quot;http://bluebirdjs.com/cancellation.html&quot;&gt;Cancellation&lt;/a&gt; for more details. The 2.x docs are &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/2.x/API.md&quot;&gt;still accessible under the 2.x branch&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fc7d5be5578254c3c3ba0dde3ab83e463051fa" translate="yes" xml:space="preserve">
          <source>In Node.js you may configure warnings and long stack traces for the entire process using environment variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361446f42424e75edad97d144b32a1e290e72cc3" translate="yes" xml:space="preserve">
          <source>In Node/io.js most APIs follow a convention of &lt;a href=&quot;https://gist.github.com/CrabDude/10907185&quot;&gt;'error-first, single-parameter'&lt;/a&gt; as such:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a81f38445f0a6f17f84f7b1c945721cfb38a3e" translate="yes" xml:space="preserve">
          <source>In Web Workers you may use &lt;code&gt;self.addEventListener&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b759cd2431b6c3f52be7951a07c24cc5f5b3b96" translate="yes" xml:space="preserve">
          <source>In addition promises are always unwrapped. A promise implicitly has &lt;code&gt;Task.Unwrap&lt;/code&gt; called on it - that is, promises perform recursive assimilation of promises within them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da70284ad0b5f811fe8223b6b3d83e713568a28f" translate="yes" xml:space="preserve">
          <source>In addition promises are always unwrapped. That is, promises perform recursive assimilation of promises within them. You can't have a &lt;code&gt;Promise&amp;lt;Promise&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; where a &lt;code&gt;Future[Future[T]]&lt;/code&gt; is valid in Scala.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3db467e4305c26c33d91d438b39bab7913a7d8d" translate="yes" xml:space="preserve">
          <source>In all of the above cases the library made its classes available in one way or another. If this is not the case, you can still promisify by creating a throwaway instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37bb782f65c2292150ec12a9ec0ac667bbafa9d" translate="yes" xml:space="preserve">
          <source>In bluebird we've chosen to do the latter because resources are typically scarce. For example, if a database connection cannot be disposed of and Bluebird ignores that, the connection pool will be quickly depleted and the process will become unusable (all requests that query the database will wait forever). Since Bluebird doesn't know how to handle that, the only sensible default is to crash the process. That way, rather than getting a useless process that cannot fulfill more requests, we can swap the faulty worker with a new one letting the OS clean up the resources for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0b3dbad60939fa3e3338aec5bf46570e2d8a1a" translate="yes" xml:space="preserve">
          <source>In conjunction with &lt;a href=&quot;disposer&quot;&gt;&lt;code&gt;.disposer&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;using&lt;/code&gt; will make sure that no matter what, the specified disposer will be called when the promise returned by the callback passed to &lt;code&gt;using&lt;/code&gt; has settled. The disposer is necessary because there is no standard interface in node for disposing resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879b1a8e6173fcc0fe684d08d132ce1871ae3253" translate="yes" xml:space="preserve">
          <source>In general, the usage of &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; is along the lines of &lt;code&gt;var fs = Promise.promisifyAll(require(&quot;fs&quot;))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efb8cf18cab76bf61b065fcc2def10c9ed9fac9" translate="yes" xml:space="preserve">
          <source>In our dialog example perhaps we want to differentiate between a rejected promise because of some problem (bad AJAX, programming error, etc.) or because the user pressed the cancel button.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bbd69af3538cceaf0f293038d0f3eaed462ca8" translate="yes" xml:space="preserve">
          <source>In practice:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b9f4a2f2ffcaff8935b98b291fdfb43db81e8c" translate="yes" xml:space="preserve">
          <source>In recent versions generator libraries started abandoning old ideas of special tokens passed to callbacks and started using promises for what's being yielded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90361caad2f10101ee0f756a8ebd2978182891e3" translate="yes" xml:space="preserve">
          <source>In the above example, the connection returned by &lt;code&gt;getConnection&lt;/code&gt; can only be used via &lt;code&gt;Promise.using&lt;/code&gt;, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb64939e278ff57bb52a7c44ea2a2cbd428cb81a" translate="yes" xml:space="preserve">
          <source>In the explicit construction anti-pattern, promise objects are created for no reason, complicating code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0070e87ecff77ecb23ce611e38aac089e617332" translate="yes" xml:space="preserve">
          <source>In the following example you might want to handle just the &lt;code&gt;SyntaxError&lt;/code&gt; from JSON.parse and Filesystem errors from &lt;code&gt;fs&lt;/code&gt; but let programmer errors bubble as unhandled rejections:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d3bed94715ad4383569042f35e985547cd7283" translate="yes" xml:space="preserve">
          <source>In the latter the indentation stays flat no matter how many previous variables you need, whereas with the former each additional previous value would require an additional nesting level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6afd7e774c8e6fdacd9e8f55a35e835be8f939" translate="yes" xml:space="preserve">
          <source>In this case, the promise resolves with itself which was is not intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b4d4283864d46d2836b690ac2cbfeafa74746b" translate="yes" xml:space="preserve">
          <source>Individual promisifcation uses current &lt;code&gt;this&lt;/code&gt; if no explicit receiver is given</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c8caa0f2f33563e5d4c95632e8edaafba86244" translate="yes" xml:space="preserve">
          <source>Initially the Dialog class sets the two callbacks to &lt;em&gt;noop&lt;/em&gt; functions. It is up to the child class to call them when necessary. We break down the promise creation to one function &lt;code&gt;waitForUser()&lt;/code&gt; that sets the callbacks and returns a promise. At this level the &lt;code&gt;show()&lt;/code&gt; and &lt;code&gt;hide()&lt;/code&gt; are just &lt;em&gt;noop&lt;/em&gt; functions as well and will be implemented by the child classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="d84677d86357a2c0115e2ed2adb5f6ec133b7f26" translate="yes" xml:space="preserve">
          <source>Instead of using the Deferred anti-pattern, the code should simply return the promise it already has and propagate values using &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aed780a746f68d28a85c473dd835c234712b990" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659525747c675f26d0d0761f93182ab5228cbc26" translate="yes" xml:space="preserve">
          <source>Into this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66cb4039287c802cdc27ed98f34dc1c2d5d9411" translate="yes" xml:space="preserve">
          <source>It also works on singletons or specific instances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5d95eeedfe49016755274286b46a188fd09776" translate="yes" xml:space="preserve">
          <source>It comes in two variants. - A tapCatch-all variant similar to &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; block. This variant is compatible with native promises. - A filtered variant (like other non-JS languages typically have) that lets you only handle specific errors. &lt;strong&gt;This variant is usually preferable&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a3866a72ba04bc9a62fa718c486091a65f59f8" translate="yes" xml:space="preserve">
          <source>It is equivalent to the following &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0ded67bc5c7c35daa1f171d80dccf1a33e74e4" translate="yes" xml:space="preserve">
          <source>It is essentially an efficient shortcut for doing a &lt;a href=&quot;map&quot;&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;&lt;code&gt;Array#filter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ad0cadb6c3a5671744781f608f9a02e1c5a392" translate="yes" xml:space="preserve">
          <source>It is more likely that you would write this instead in the sync world:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a01add8c2bcb3ae05a334c130487578987c686" translate="yes" xml:space="preserve">
          <source>It is often said that promises cannot be cancellable because they can have multiple consumers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0e7d44695db980a8f0ed40ee055bb11d90c7f7" translate="yes" xml:space="preserve">
          <source>It is very subtle but over time this code will exhaust the entire connection pool and the server needs to be restarted. This is because reading the file may fail and then of course &lt;code&gt;.spread&lt;/code&gt; is not called at all and thus the connection is not closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e4aad38b66ae4f579919e5442c2f87282d298e" translate="yes" xml:space="preserve">
          <source>It might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3201aa0565e8be1e1547bcb52a2f64c00b2bc44" translate="yes" xml:space="preserve">
          <source>It should be noted that there is no real need to attach the handlers asynchronously. Exactly the same effect can be achieved with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25d9aa71a1aef724d7f8d933c376e203e6ccfd0" translate="yes" xml:space="preserve">
          <source>It's also possible to use a disposer pattern (but not actual disposers) for transaction management:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b38a83ae257f40976a60195f877e73b38d539c" translate="yes" xml:space="preserve">
          <source>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given &lt;code&gt;iterator&lt;/code&gt; function with the signature &lt;code&gt;(value, index, length)&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the resolved value of a respective promise in the input array. &lt;strong&gt;Iteration happens serially&lt;/strong&gt;. If the iterator function returns a promise or a thenable, then the result of the promise is awaited before continuing with next iteration. If any promise in the input array is rejected, then the returned promise is rejected as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d889900760cbb5576feda8db1d4c5015016f6e85" translate="yes" xml:space="preserve">
          <source>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given &lt;code&gt;iterator&lt;/code&gt; function with the signature &lt;code&gt;(value, index, length)&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the resolved value of a respective promise in the input array. Iteration happens serially. If any promise in the input array is rejected the returned promise is rejected as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e027e57610f85225767aafbbf23fed7457e55828" translate="yes" xml:space="preserve">
          <source>Java</source>
          <target state="translated">Java</target>
        </trans-unit>
        <trans-unit id="769460330d98abc38d4f157088d641889b8e080c" translate="yes" xml:space="preserve">
          <source>Just like a future, a promise represents a value over time. The value can resolve to either a fulfilled (ok completion) or rejected (error completion) state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b04d056ad9ef4e9bfb796dceb8c12c3d2724b7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;all&quot;&gt;&lt;code&gt;.all&lt;/code&gt;&lt;/a&gt; but for object properties or &lt;code&gt;Map&lt;/code&gt;s* entries instead of iterated values. Returns a promise that is fulfilled when all the properties of the object or the &lt;code&gt;Map&lt;/code&gt;'s' values** are fulfilled. The promise's fulfillment value is an object or a &lt;code&gt;Map&lt;/code&gt; with fulfillment values at respective keys to the original object or a &lt;code&gt;Map&lt;/code&gt;. If any promise in the object or &lt;code&gt;Map&lt;/code&gt; rejects, the returned promise is rejected with the rejection reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0868022eae9754566ebce8819ba10c34f00156c4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; but instead of catching all types of exceptions, it only catches operational errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7724ecb2f95d5397a59e0da7c44a35554300566" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; that is not called for fulfillments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b705bae03f08f49a3c59a2a4c3c23676360ce32" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;promise.some&quot;&gt;&lt;code&gt;Promise.some&lt;/code&gt;&lt;/a&gt;, with 1 as &lt;code&gt;count&lt;/code&gt;. However, if the promise fulfills, the fulfillment value is not an array of 1 but the value directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0572842c5b510f6b6c6d450ffa47af7bfa19546" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt;, but any unhandled rejection that ends up here will crash the process (in node) or be thrown as an error (in browsers). The use of this method is heavily discouraged and it only exists for historical reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d64e920d46f5914cb7b3fc3949b2df8768d761d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.map&lt;/code&gt; and &lt;code&gt;.filter&lt;/code&gt;, &lt;code&gt;.reduce&lt;/code&gt; now allows returning promises and thenables from the iteration function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b88079f4caa0345add2b49d7a0be51ed016806" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.then()&lt;/code&gt;, but any unhandled rejection that ends up here will be thrown as an error. Again, only the variant with the progression handler is deprecated here. &lt;code&gt;.done&lt;/code&gt; is still fully supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaab59843408be17f1182d2a7ba7d498c9751120" translate="yes" xml:space="preserve">
          <source>Like calling &lt;code&gt;.then&lt;/code&gt;, but the fulfillment value &lt;em&gt;must be&lt;/em&gt; an array, which is flattened to the formal parameters of the fulfillment handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d46fec21cdff120fbce1d5c81043ed187891e17" translate="yes" xml:space="preserve">
          <source>Local rejection events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="25c9bdc07ce0dfdf61f61c6ce40dbedeb1c6dd8e" translate="yes" xml:space="preserve">
          <source>Logging after the promise became GCd (requires a native node.js module)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44413342754143aa1961f15d95ef6db04a6b6098" translate="yes" xml:space="preserve">
          <source>Long stack traces</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0119ac596cae5eba4e7c9ece07c3d282260f3e" translate="yes" xml:space="preserve">
          <source>Long stack traces are enabled by default in the debug build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5585738e86f015af086921d0b41e009a6fb65e3d" translate="yes" xml:space="preserve">
          <source>Long stack traces are only supported in Chrome, recent Firefoxes and Internet Explorer 10+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aba1e438bce5b03f5ff76a06150c5afd0f112d5" translate="yes" xml:space="preserve">
          <source>Long stack traces are supported now in IE10+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4e72958bdd71df94bdc91c2471299f772d9de9" translate="yes" xml:space="preserve">
          <source>Long stack traces have been re-designed. They are now much more readable, succint, relevant and consistent across bluebird features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d32bb2f1ca24d68c701d853a17b879746200c1e" translate="yes" xml:space="preserve">
          <source>Major debuggability improvements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7cd8e3e2364f713fb55eb6da548439b6487c93" translate="yes" xml:space="preserve">
          <source>Major internal refactoring related to testing code and source code file layout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d05db1f390d07e6c3780eb841599459e0bc86db" translate="yes" xml:space="preserve">
          <source>Make .race() and Promise.race() forever pending on empty collections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f545f488c8e51d1bcb95f6e96e06f76a78762db7" translate="yes" xml:space="preserve">
          <source>Make build script's output work without TTY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de105dd31451a68ffa7b10edcdad659c72911a0" translate="yes" xml:space="preserve">
          <source>Make progress a core feature. Fixes &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/535&quot;&gt;&lt;code&gt;#535&lt;/code&gt;&lt;/a&gt; Note that progress has been removed in 3.x - this is only a fix necessary for 2.x custom builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25de34f144aaa815f7ee100219c0875ec327f00" translate="yes" xml:space="preserve">
          <source>Make tests pass Internet Explorer 8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae67022300ef1cd200bf479b96deb439531bc00" translate="yes" xml:space="preserve">
          <source>Managing resources properly without leaks can be challenging. Simply using &lt;code&gt;.finally&lt;/code&gt; is not enough as the following example demonstrates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107b1032597492e8483d652c4a4ce608f171eba8" translate="yes" xml:space="preserve">
          <source>Map Option: concurrency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50a46e16b741d58429e4aa0f944bc0391ee46f8" translate="yes" xml:space="preserve">
          <source>Methods of &lt;code&gt;Promise&lt;/code&gt; instances and core static methods of the Promise class to deal with collections of promises or mixed promises and values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae38184c5e1cc02a77f22646c0e9e6fb64bf94fd" translate="yes" xml:space="preserve">
          <source>Methods on &lt;code&gt;Function.prototype&lt;/code&gt; are no longer promisified (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/680&quot;&gt;&lt;code&gt;#680&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7ee6528f585594a5d8dbab3c9c2ad5078d7461" translate="yes" xml:space="preserve">
          <source>Minified source file meant to be used in production. Warnings and long straces are disabled. The gzipped size is 17.76KB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cddf33528c938c1495240e1ee5dc6ea07a8ea077" translate="yes" xml:space="preserve">
          <source>Misc:</source>
          <target state="translated">Misc:</target>
        </trans-unit>
        <trans-unit id="cbb2eaaf602b7e2cec410e3a49e5f52907359976" translate="yes" xml:space="preserve">
          <source>Mongoose works with persistent connections and the driver takes care of reconnections/disposals. For this reason using &lt;code&gt;using&lt;/code&gt; with it isn't required - instead connect on server startup and use promisification to expose promises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8341442a59c4454f469778737b7b06e02ad229" translate="yes" xml:space="preserve">
          <source>Mongoose/MongoDB</source>
          <target state="translated">Mongoose/MongoDB</target>
        </trans-unit>
        <trans-unit id="331f3f9f6d3697a3169ac32b4263f8b1778c3e97" translate="yes" xml:space="preserve">
          <source>More Common Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5623f76074955ea9ab1db3ab04c9bff15d87a6c2" translate="yes" xml:space="preserve">
          <source>More common examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb77d4b0690c471c302bf76046f4c7afa76f3db6" translate="yes" xml:space="preserve">
          <source>More performance improvements when long stack traces are enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7a86c3c7bb6f061ed4b7dd4612a07ea2e55494" translate="yes" xml:space="preserve">
          <source>More reading:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="63cd8ad40499d81ac4cfa72cb023f0f0e2a46fc4" translate="yes" xml:space="preserve">
          <source>New in bluebird 3.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c06116ec441fcbe51fa98c044bc02e5a87998c7" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promiseonunhandledrejectionhandledfunction-handler---undefined&quot;&gt;&lt;code&gt;Promise.onUnhandledRejectionHandled()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ef7df279344d4e364f9fc4312d95513017e539" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#reason---dynamic&quot;&gt;&lt;code&gt;.reason()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7244a976bd562fa5bdab260bfa92ffb53b2f75df" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#value---dynamic&quot;&gt;&lt;code&gt;.value()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e97753de8b2fb704fe13fb56eee1b6956901e28" translate="yes" xml:space="preserve">
          <source>Node environment detection can no longer be fooled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f139c394850c9c9489f54e55411c65c03b1e5e" translate="yes" xml:space="preserve">
          <source>Node installation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="973a79d67e462fcd740058903de5ac75c5e42ed4" translate="yes" xml:space="preserve">
          <source>Node.js performance: promisified functions try to check amount of passed arguments in most optimal order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d569f35ecd5c10a6a6f1ab8aec8e1753640885" translate="yes" xml:space="preserve">
          <source>Node.js promisified functions will have same &lt;code&gt;.length&lt;/code&gt; as the original function minus one (for the callback parameter)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8c6cfa65668d483f7a4b264c38fc353e937af3" translate="yes" xml:space="preserve">
          <source>Nodeify doesn't pass second argument to the callback if the promise is fulfilled with &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5673141cf57847c5379b8f84249704a24a566a4" translate="yes" xml:space="preserve">
          <source>None of the collection methods modify the original input. Holes in arrays are treated as if they were defined with the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e35ac0a9b7c71da68e4e0db0a51a9c2cf39da4d" translate="yes" xml:space="preserve">
          <source>Normal callbacks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7e35c7b10d9ccf8a2e395ca44cbdd4ab1c9fb3" translate="yes" xml:space="preserve">
          <source>Normally stack traces don't go beyond asynchronous boundaries so their utility is greatly reduced in asynchronous code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bbef690c10dd98cdafb9fad511260630850d165" translate="yes" xml:space="preserve">
          <source>Not only is the code shorter but more importantly, if there is any error it will propagate properly to the final consumer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601e20ca34667b0a121fe532f625d50ac9e32a89" translate="yes" xml:space="preserve">
          <source>Note - in order to get full stack traces with warnings in Node 6.x+ you need to enable to &lt;code&gt;--trace-warnings&lt;/code&gt; flag which will give you a full stack trace of where the warning is coming from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f4f32d734d4dde2357de9c28aa2e9db4f442b8" translate="yes" xml:space="preserve">
          <source>Note about disposers in node</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628368b01a8c147d7adbe65259137f54770d74df" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;spread&quot;&gt;&lt;code&gt;.spread()&lt;/code&gt;&lt;/a&gt; implicitly does &lt;a href=&quot;all&quot;&gt;&lt;code&gt;.all()&lt;/code&gt;&lt;/a&gt; but the ES6 destructuring syntax doesn't, hence the manual &lt;code&gt;.all()&lt;/code&gt; call in the above code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4cc52a9da922cd3c5be1d218aeb2480ead589e" translate="yes" xml:space="preserve">
          <source>Note that Mongoose already ships with promise support but the promises it offers are significantly slower and don't report unhandled rejections so it is recommended to use automatic promisification with it anyway:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e8a3550207f0693fbe258a0b408370b65284bd" translate="yes" xml:space="preserve">
          <source>Note that bind is only propagated with promise transformation. If you create new promise chains inside a handler, those chains are not bound to the &quot;upper&quot; &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18ae6fc287a535de54a7ef47226f40baba44a5f" translate="yes" xml:space="preserve">
          <source>Note that if the node function is a method of some object, you can pass the object as the second argument like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049b2f103da24d1cdf9b651db0f13464d2a62368" translate="yes" xml:space="preserve">
          <source>Note that if using ES6, the above can be replaced with &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; and destructuring:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a368b621b24c61956a2d40d7353ec38ebe9f4e" translate="yes" xml:space="preserve">
          <source>Note that if you have no use for the result object other than retrieving the properties, it is more convenient to use &lt;a href=&quot;promise.join&quot;&gt;&lt;code&gt;Promise.join&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de0bd0db4f60bc1b355d5d97bda28262272a5e5" translate="yes" xml:space="preserve">
          <source>Note that it is an error to consume an already cancelled promise, doing such a thing will give you a promise that is rejected with &lt;code&gt;new CancellationError(&quot;late cancellation observer&quot;)&lt;/code&gt; as the rejection reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fba6dfbb297631502284b27e815e4abd333271d" translate="yes" xml:space="preserve">
          <source>Note that promises model a &lt;em&gt;single value through time&lt;/em&gt;, they only resolve &lt;em&gt;once&lt;/em&gt; - so while they're a good fit for a single event, they are not recommended for multiple event APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0a18493f92a9cdbebf344b13ce97703f7982f1" translate="yes" xml:space="preserve">
          <source>Note that the 3.0.1 update is strictly speaking backward-incompatible with 3.0.0. Version 3.0.0 changed the previous behavior of the &lt;code&gt;.each&lt;/code&gt; method and made it work more same as the new &lt;code&gt;.mapSeries&lt;/code&gt; - 3.0.1 unrolls this change by reverting to the &lt;code&gt;.tap&lt;/code&gt;-like behavior found in 2.x However, this would only affect users who updated to 3.0.0 during the short time that it wasn't deprecated and started relying on the new &lt;code&gt;.each&lt;/code&gt; behavior. This seems unlikely, and therefore the major version was not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb0ec4c290533d8d13b5512c50f3aff8444246e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;onCancel&lt;/code&gt; hook is really an optional disconnected optimization, there is no real requirement to register any cancellation hooks for cancellation to work. As such, any errors that may occur while inside the &lt;code&gt;onCancel&lt;/code&gt; callback are not caught and turned into rejections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1635db28b0639fbcd8af0cf2d7a5c771bbc04b90" translate="yes" xml:space="preserve">
          <source>Note that the above is an exceptional case because &lt;code&gt;fs&lt;/code&gt; is a singleton instance. Most libraries can be promisified by requiring the library's classes (constructor functions) and calling promisifyAll on the &lt;code&gt;.prototype&lt;/code&gt;. This only needs to be done once in the entire application's lifetime and after that you may use the library's methods exactly as they are documented, except by appending the &lt;code&gt;&quot;Async&quot;&lt;/code&gt;-suffix to method calls and using the promise interface instead of the callback interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684fbd25281e8e786735f4d9605ff396ce6c04e1" translate="yes" xml:space="preserve">
          <source>Note that the original methods on the object are not overwritten but new methods are created with the &lt;code&gt;Async&lt;/code&gt;-suffix. For example, if you &lt;code&gt;promisifyAll&lt;/code&gt; the node.js &lt;code&gt;fs&lt;/code&gt; object use &lt;code&gt;fs.statAsync&lt;/code&gt; to call the promisified &lt;code&gt;stat&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8918cb785368659b0f7041103fcbbc46ea52e50b" translate="yes" xml:space="preserve">
          <source>Note that you can mix promises and disposers, so that you can acquire all the things you need in parallel instead of sequentially</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2203e249f5db0b7bf8e8cc90b06047ef5edc44d9" translate="yes" xml:space="preserve">
          <source>Note the new method is suffixed with &lt;code&gt;Async&lt;/code&gt;, as in &lt;code&gt;fs.readFileAsync&lt;/code&gt;. It did not replace the &lt;code&gt;fs.readFile&lt;/code&gt; function. Single functions can also be promisified for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1642a8259cf0bac4672e4af1533d8b457f9d5a0" translate="yes" xml:space="preserve">
          <source>Notice that use of &lt;code&gt;return this;&lt;/code&gt; in most of the functions? That pattern will allow method chaining as you'll see shortly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b7a468a3970ae2784b6d1486ec7ed0a21533b5" translate="yes" xml:space="preserve">
          <source>Now if someone uses this function, they will catch all errors in their Promise &lt;code&gt;.catch&lt;/code&gt; handlers instead of having to handle both synchronous and asynchronous exception flows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7be4be424720d6a240c42d8e70d90f0de37f8e" translate="yes" xml:space="preserve">
          <source>Now the animation is hidden but, unless it throws an exception, the function has no effect on the fulfilled or rejected value of the returned promise. This is similar to how the synchronous &lt;code&gt;finally&lt;/code&gt; keyword behaves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdea957426d725edc153e2fdbdd6516cd7a9e40a" translate="yes" xml:space="preserve">
          <source>Now to the fun part. For this tutorial we will &lt;em&gt;fake&lt;/em&gt; a lengthy file upload by using &lt;code&gt;setTimeout&lt;/code&gt;. The intent is to provide a promise and to allow a progress to be periodically ticked away. We will expect a function to be passed which is called whenever the progress needs updating. And it returns a promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f511b5b4eefa1fbd39717d9bca91d08c89eb55c8" translate="yes" xml:space="preserve">
          <source>Now we can add a &lt;code&gt;cancel()&lt;/code&gt; reject with this in our event listener:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd58dca3cb5c00590780331e30aa954b4d6ecb97" translate="yes" xml:space="preserve">
          <source>Now when the user presses the &lt;strong&gt;Set Name&lt;/strong&gt; button the clock continues to update while the dialog is visible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c4edbd07c221b59e680f6880827ab56a3c246a" translate="yes" xml:space="preserve">
          <source>Now, because there is no catch-all handler, if you typed &lt;code&gt;console.lag&lt;/code&gt; (causes an error you don't expect), you will see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="d1d56bab874d88dafd718a2b7e212040a9f0e45f" translate="yes" xml:space="preserve">
          <source>Of course you could use hacks like monkey patching or domains but these break down when something can't be monkey patched or new apis are introduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9466283542f875b75d8d6a69434fd428fb07f65" translate="yes" xml:space="preserve">
          <source>Often browser APIs are nonstandard and automatic promisification will fail for them. If you're running into an API that you can't promisify with &lt;a href=&quot;api/promisify&quot;&gt;&lt;code&gt;promisify&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/promisifyall&quot;&gt;&lt;code&gt;promisifyAll&lt;/code&gt;&lt;/a&gt; - please consult the &lt;a href=&quot;#working-with-any-other-apis&quot;&gt;working with other APIs section&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c49c4361b267a50eb7359cfbbb3c119709f70d" translate="yes" xml:space="preserve">
          <source>Often it is known in certain code paths that a promise is guaranteed to be fulfilled at that point - it would then be extremely inconvenient to use &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt; to get at the promise's value as the callback is always called asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba70c55cb182e14f7aec5abbfd219d10161351d3" translate="yes" xml:space="preserve">
          <source>Often it is known in certain code paths that a promise is guaranteed to be fulfilled at that point - it would then be extremely inconvenient to use &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt; to get at the promise's value as the callback is always called asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb455bed4997b8d29dbd05a23ac828990139aad3" translate="yes" xml:space="preserve">
          <source>Old Promise Cancellation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2882dbf534ae9b61f7574e530dc35a635e26a00" translate="yes" xml:space="preserve">
          <source>On client side, long stack traces currently only work in recent Firefoxes, Chrome and Internet Explorer 10+.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5a14a36dfaaeaed4f8ef85cfc8efef0579501d" translate="yes" xml:space="preserve">
          <source>One could solve this by either reading the file first or connecting first, and only proceeding if the first step succeeds. However, this would lose a lot of the benefits of using asynchronity and we might almost as well go back to using simple synchronous code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2c6e796751446bf03d009641c4f94308285962" translate="yes" xml:space="preserve">
          <source>One possible cause is using &lt;code&gt;.indexOf&lt;/code&gt; which returns &lt;code&gt;-1&lt;/code&gt; when it doesn't find the value being searched for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bebf09d62dbf5ff3d0ee7b594d24983d9fecce2" translate="yes" xml:space="preserve">
          <source>OperationalError</source>
          <target state="translated">OperationalError</target>
        </trans-unit>
        <trans-unit id="5b01979a9cdca6e73817895c6a9c23e60230c14d" translate="yes" xml:space="preserve">
          <source>OperationalError()</source>
          <target state="translated">OperationalError()</target>
        </trans-unit>
        <trans-unit id="104370c5891b8b4ba98b88fdedf6b3dd37566a91" translate="yes" xml:space="preserve">
          <source>Option: filter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4d82f7dc12888a6113e02d99a1cd1ae6480faa" translate="yes" xml:space="preserve">
          <source>Option: multiArgs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7fb7b92da5e81c452b72cf73b9e7e606a4be8c6" translate="yes" xml:space="preserve">
          <source>Option: promisifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739bd13df9b75cbacc926456c2659db41a7a2e16" translate="yes" xml:space="preserve">
          <source>Option: spread</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86f01917e960f8cf0838c6de23ce3408a649b20" translate="yes" xml:space="preserve">
          <source>Option: suffix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad34d2a8ce003a253f94ae6e4eb935a9468f0f43" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom filter through the options object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8110acd1b3d0f8ca4e9e279edf4604f42dc6b48b" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom promisifier, so you could promisifyAll e.g. the chrome APIs used in Chrome extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889a0e5ec1b3411c0cd35c6e73319943162df789" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom suffix through the options object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d850b7adaa397dfa33c1141f5bb572b4b4cee8d2" translate="yes" xml:space="preserve">
          <source>Or to use &lt;a href=&quot;api/promise.coroutine.addyieldhandler&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler`&lt;/code&gt;&lt;/a&gt; to teach &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt; to accept these sort of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ea190190a1068b342fd38d88b87afd5b7878ff" translate="yes" xml:space="preserve">
          <source>Or you could take advantage of the fact that if we reach password validation, then the user promise must be fulfilled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b17d6ff961144643224165079cbd11a9c6bc25a" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;PromptDialog&lt;/code&gt; class is responsible for inheriting from &lt;code&gt;Dialog&lt;/code&gt; and setting up the required DOM scaffolding and eventually call &lt;code&gt;this._okCallback&lt;/code&gt; or &lt;code&gt;this._cancelCallback&lt;/code&gt; as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cb5629649d7407a80d8544726571004c96c657" translate="yes" xml:space="preserve">
          <source>PascalCase the suffix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feee47953c269413e18b8e3f8b2d28f42be54e4a" translate="yes" xml:space="preserve">
          <source>Pass a handler that will be called regardless of this promise's fate. Returns a new promise chained from this promise. There are special semantics for &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; in that the final value cannot be modified from the handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4b02b67bed0ffe4b0b1b17a183e58f6d178ecc" translate="yes" xml:space="preserve">
          <source>Pass it a constructor that inherits from &lt;code&gt;Error&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef62afb0d13c7501004b9f7402ac0fe34f1df36d" translate="yes" xml:space="preserve">
          <source>Passing no value or a non-function will have the effect of removing any kind of handling for possibly unhandled rejections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a1550a1e49d7c4df7b61809151dec155b9464f" translate="yes" xml:space="preserve">
          <source>Performance improvements when long stack traces are enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d83e264c56100a2c68d859c185e245cdf12d6c" translate="yes" xml:space="preserve">
          <source>Perhaps the greatest thing about promises is that it unifies all error handling into one mechanism where errors propagate automatically and have to be explicitly ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bc9fc907ba93237d886bb7661f405dca851032" translate="yes" xml:space="preserve">
          <source>Playing with the first example with and without limits, and seeing how it affects the duration when reading 20 files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e982889494e481131cdc4a0b26924bfa22d7d53" translate="yes" xml:space="preserve">
          <source>Please consider reading about &lt;a href=&quot;api/new-promise&quot;&gt;&lt;code&gt;new Promise&lt;/code&gt;&lt;/a&gt; and also consider checking out automatic &lt;a href=&quot;api/promisification&quot;&gt;&lt;code&gt;promisification&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;api/promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b51c4c13d41d7852eb369e20c236af48cef84cc" translate="yes" xml:space="preserve">
          <source>Please consider reading more about &lt;a href=&quot;api/synchronous-inspection&quot;&gt;&lt;code&gt;synchronous inspection&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e14f1308fe5c8dea2b2ef541f7aee826d27d5e0" translate="yes" xml:space="preserve">
          <source>Please consider reading the API docs for &lt;a href=&quot;api/some&quot;&gt;&lt;code&gt;.some&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ef6b96fc3e88fc35fff339fde30327dde1a698" translate="yes" xml:space="preserve">
          <source>Please refer to the relevant section in the documentation about &lt;a href=&quot;api/generators&quot;&gt;&lt;code&gt;Generators&lt;/code&gt;&lt;/a&gt; in order to get usage instructions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad1bb14fb0bdc68c8977349fd048e917d0e042c" translate="yes" xml:space="preserve">
          <source>Please see the API docs of &lt;a href=&quot;api/catch&quot;&gt;&lt;code&gt;.catch()&lt;/code&gt;&lt;/a&gt; on how to use predicate catches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7ed98d6ff8cb1bb3beee177d5536fda218b9d6" translate="yes" xml:space="preserve">
          <source>Possibly unhandled rejection handler will always get a stack trace, even if the rejection or thrown error was not an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="642cccd7308199d6f0935637f8e1d6bddc7a7f5d" translate="yes" xml:space="preserve">
          <source>Predicate functions that only check properties have a handy shorthand. In place of a predicate function, you can pass an object, and its properties will be checked against the error object for a match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef29f5e7937f710796c69d5f2e8ef62b93259503" translate="yes" xml:space="preserve">
          <source>Predicates should allow for very fine grained control over caught errors: pattern matching, error-type sets with set operations and many other techniques can be implemented on top of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966e683ff73ac6a6ff53e83d6497f2f1ad6da22d" translate="yes" xml:space="preserve">
          <source>Preserve bound-with-promise promises across the entire chain (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/702&quot;&gt;&lt;code&gt;#702&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d7cb674f49e0b746c342035d00a2302db4c737" translate="yes" xml:space="preserve">
          <source>Progress bar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51674123623b6ab6e8ea7ca7250debfd7286bf63" translate="yes" xml:space="preserve">
          <source>Progress the underlying promise with &lt;code&gt;value&lt;/code&gt; as the progression value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685e262241d88a216ab9353d6e8f0939b5803641" translate="yes" xml:space="preserve">
          <source>Progression</source>
          <target state="translated">Progression</target>
        </trans-unit>
        <trans-unit id="25eee37f31e0eba9807d8e531ecf239e4d0cd542" translate="yes" xml:space="preserve">
          <source>Progression has been removed as there are composability and chaining issues with APIs that use promise progression handlers. Implementing the common use case of progress bars can be accomplished using a pattern similar to &lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx&quot;&gt;IProgress&lt;/a&gt; in C#.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3248b463906e068e9fcc220b46e1a5d372a78fb1" translate="yes" xml:space="preserve">
          <source>Progression migration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be45959fa7407eeadb36fe64732e21bc44a21868" translate="yes" xml:space="preserve">
          <source>Promise config returns reference to Bluebird library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6113ea309f0d5b9bec49fc1796cd040f492643" translate="yes" xml:space="preserve">
          <source>Promise exception handling mirrors native exception handling in JavaScript. A synchronous function &lt;code&gt;throw&lt;/code&gt;ing is similar to a promise rejecting. Here is an example to illustrate it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8782a387409c7a9a87576a85d07c1e64505c1544" translate="yes" xml:space="preserve">
          <source>Promise monitoring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbc67ef437634d86ab184513509ef1b7aec9846" translate="yes" xml:space="preserve">
          <source>Promise nuggets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4139a3b1a43d871cf4ddb3e7a6d5193448c48c" translate="yes" xml:space="preserve">
          <source>Promise progression has been completely removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7726aabf1843e710a9f37fd6b562d6f56faa7e88" translate="yes" xml:space="preserve">
          <source>Promise resolution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f81fcc4877a1e4dd84dd9b0c2863d1631025a9" translate="yes" xml:space="preserve">
          <source>Promise returning functions &lt;em&gt;should never throw&lt;/em&gt;, they should always successfully return a promise which is rejected in the case of an error. Throwing from a promise returning function will force you to use both a &lt;code&gt;} catch {&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; a &lt;code&gt;.catch&lt;/code&gt;. People using promisified APIs do not expect promises to throw. If you're not sure how async APIs work in JS - please &lt;a href=&quot;http://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;see this answer&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c88e7c01a53d5b288b9de6a6aab20cb547871d" translate="yes" xml:space="preserve">
          <source>Promise.all</source>
          <target state="translated">Promise.all</target>
        </trans-unit>
        <trans-unit id="a6755a6ad2728b869d475dc11ace6f3bf5ea4871" translate="yes" xml:space="preserve">
          <source>Promise.all()</source>
          <target state="translated">Promise.all()</target>
        </trans-unit>
        <trans-unit id="8a9f46eacb22a3bbe6409bdb49b4254651eff678" translate="yes" xml:space="preserve">
          <source>Promise.any</source>
          <target state="translated">Promise.any</target>
        </trans-unit>
        <trans-unit id="59a3e9eecb28443ad28e7c96175567acc96c62f3" translate="yes" xml:space="preserve">
          <source>Promise.any()</source>
          <target state="translated">Promise.any()</target>
        </trans-unit>
        <trans-unit id="380ddbb670a463da41bcb2f09102155dde8e708e" translate="yes" xml:space="preserve">
          <source>Promise.bind</source>
          <target state="translated">Promise.bind</target>
        </trans-unit>
        <trans-unit id="c504dbf7b03cd885ada0adc0180bde1c542f6ff6" translate="yes" xml:space="preserve">
          <source>Promise.bind()</source>
          <target state="translated">Promise.bind()</target>
        </trans-unit>
        <trans-unit id="94cffff23a1082b260d53b460f0199319830c332" translate="yes" xml:space="preserve">
          <source>Promise.config</source>
          <target state="translated">Promise.config</target>
        </trans-unit>
        <trans-unit id="14cca1b3fd91fce3c7d78898b9b8ab87641cd45f" translate="yes" xml:space="preserve">
          <source>Promise.config()</source>
          <target state="translated">Promise.config()</target>
        </trans-unit>
        <trans-unit id="0281c083d21b56d693df7c85bdc8760d5a153cb3" translate="yes" xml:space="preserve">
          <source>Promise.coroutine</source>
          <target state="translated">Promise.coroutine</target>
        </trans-unit>
        <trans-unit id="417c8a52e78b52649cc8c0d1a4a5c72e470fba46" translate="yes" xml:space="preserve">
          <source>Promise.coroutine()</source>
          <target state="translated">Promise.coroutine()</target>
        </trans-unit>
        <trans-unit id="1c7ffab7487989ed4fab5bf27ffc68d6a9e83f84" translate="yes" xml:space="preserve">
          <source>Promise.coroutine.addYieldHandler</source>
          <target state="translated">Promise.coroutine.addYieldHandler</target>
        </trans-unit>
        <trans-unit id="b32e1c4e626c99ffd6f0e20eaa5f3f6e5768bfd5" translate="yes" xml:space="preserve">
          <source>Promise.coroutine.addYieldHandler()</source>
          <target state="translated">Promise.coroutine.addYieldHandler()</target>
        </trans-unit>
        <trans-unit id="0eaf3c7722c589dfef45cece747a91a4f63eb1c4" translate="yes" xml:space="preserve">
          <source>Promise.delay</source>
          <target state="translated">Promise.delay</target>
        </trans-unit>
        <trans-unit id="b0fcfeaf123206f651b32c45d020a06c0161b597" translate="yes" xml:space="preserve">
          <source>Promise.delay()</source>
          <target state="translated">Promise.delay()</target>
        </trans-unit>
        <trans-unit id="58c05c22c80b95286ff97a890b8a711ca2bc4455" translate="yes" xml:space="preserve">
          <source>Promise.each</source>
          <target state="translated">Promise.each</target>
        </trans-unit>
        <trans-unit id="a620ec9f632f36f8a08e631069c08191868f6916" translate="yes" xml:space="preserve">
          <source>Promise.each()</source>
          <target state="translated">Promise.each()</target>
        </trans-unit>
        <trans-unit id="36ed6ee5c85807e4301bf69d782f38ceb4470326" translate="yes" xml:space="preserve">
          <source>Promise.filter</source>
          <target state="translated">Promise.filter</target>
        </trans-unit>
        <trans-unit id="86054f183176a3f69e770d2c34d2bdeae915a41e" translate="yes" xml:space="preserve">
          <source>Promise.filter()</source>
          <target state="translated">Promise.filter()</target>
        </trans-unit>
        <trans-unit id="98d41166fbaafb718942a7d54eb7a52ea584c71b" translate="yes" xml:space="preserve">
          <source>Promise.fromCallback</source>
          <target state="translated">Promise.fromCallback</target>
        </trans-unit>
        <trans-unit id="3f0b67925c3695da1eb2886d38a30665c003a3b1" translate="yes" xml:space="preserve">
          <source>Promise.fromCallback()</source>
          <target state="translated">Promise.fromCallback()</target>
        </trans-unit>
        <trans-unit id="fd3f3e356627367a0a1deb529a31724afae6adf2" translate="yes" xml:space="preserve">
          <source>Promise.getNewLibraryCopy</source>
          <target state="translated">Promise.getNewLibraryCopy</target>
        </trans-unit>
        <trans-unit id="89fb5dda745c6bafe6968a6f413760af47aceae1" translate="yes" xml:space="preserve">
          <source>Promise.getNewLibraryCopy()</source>
          <target state="translated">Promise.getNewLibraryCopy()</target>
        </trans-unit>
        <trans-unit id="40fdb4632aedb0a1797f0c8a54579a1fde171242" translate="yes" xml:space="preserve">
          <source>Promise.join</source>
          <target state="translated">Promise.join</target>
        </trans-unit>
        <trans-unit id="23d8f43c5ac526250cf76c302ad4119a7b1ab47b" translate="yes" xml:space="preserve">
          <source>Promise.join()</source>
          <target state="translated">Promise.join()</target>
        </trans-unit>
        <trans-unit id="7978c060e1559749beb237c1e2cd848a0c8c4d0d" translate="yes" xml:space="preserve">
          <source>Promise.map</source>
          <target state="translated">Promise.map</target>
        </trans-unit>
        <trans-unit id="ca13a4d72f15f0ca07d5d50979466ec8d5754e56" translate="yes" xml:space="preserve">
          <source>Promise.map()</source>
          <target state="translated">Promise.map()</target>
        </trans-unit>
        <trans-unit id="4228fbfb6f0c4ca7c03f7f3fe02a32213a675bb6" translate="yes" xml:space="preserve">
          <source>Promise.mapSeries</source>
          <target state="translated">Promise.mapSeries</target>
        </trans-unit>
        <trans-unit id="e726d78ebf8fa9e8d4dd4170765a788187160409" translate="yes" xml:space="preserve">
          <source>Promise.mapSeries()</source>
          <target state="translated">Promise.mapSeries()</target>
        </trans-unit>
        <trans-unit id="02c686952be30df3ceda356456842c51ca54d6b6" translate="yes" xml:space="preserve">
          <source>Promise.method</source>
          <target state="translated">Promise.method</target>
        </trans-unit>
        <trans-unit id="745df198c177406843ab6f0aef1a0ee5dfc83def" translate="yes" xml:space="preserve">
          <source>Promise.method()</source>
          <target state="translated">Promise.method()</target>
        </trans-unit>
        <trans-unit id="84f80dd435e5e59f09d00da45ff238df86a37a40" translate="yes" xml:space="preserve">
          <source>Promise.noConflict</source>
          <target state="translated">Promise.noConflict</target>
        </trans-unit>
        <trans-unit id="7531a2c2c6b7c98ad21e08d5e3ae1c19a0b22683" translate="yes" xml:space="preserve">
          <source>Promise.noConflict()</source>
          <target state="translated">Promise.noConflict()</target>
        </trans-unit>
        <trans-unit id="71c980a14f65b0a2704a085acb674ac28a814685" translate="yes" xml:space="preserve">
          <source>Promise.onPossiblyUnhandledRejection</source>
          <target state="translated">Promise.onPossiblyUnhandledRejection</target>
        </trans-unit>
        <trans-unit id="c371d88740f13aaaca5694582d4b3f1c2be33ab4" translate="yes" xml:space="preserve">
          <source>Promise.onPossiblyUnhandledRejection()</source>
          <target state="translated">Promise.onPossiblyUnhandledRejection()</target>
        </trans-unit>
        <trans-unit id="829674402143cb4c85191f62c464c46f218abca2" translate="yes" xml:space="preserve">
          <source>Promise.onUnhandledRejectionHandled</source>
          <target state="translated">Promise.onUnhandledRejectionHandled</target>
        </trans-unit>
        <trans-unit id="9c2cbfa68db14a1011a8bf225d1d930825635838" translate="yes" xml:space="preserve">
          <source>Promise.onUnhandledRejectionHandled()</source>
          <target state="translated">Promise.onUnhandledRejectionHandled()</target>
        </trans-unit>
        <trans-unit id="1bd4c78395725232fde1b79374d6efc9908e559c" translate="yes" xml:space="preserve">
          <source>Promise.promisify</source>
          <target state="translated">Promise.promisify</target>
        </trans-unit>
        <trans-unit id="1713f0d05877ab5fe29b2ac17f3c75196afacdff" translate="yes" xml:space="preserve">
          <source>Promise.promisify()</source>
          <target state="translated">Promise.promisify()</target>
        </trans-unit>
        <trans-unit id="97bebc26a4bce522904a06ed52ef00804ef373fc" translate="yes" xml:space="preserve">
          <source>Promise.promisifyAll</source>
          <target state="translated">Promise.promisifyAll</target>
        </trans-unit>
        <trans-unit id="582205a63795dfa2ded431e29909f2b0510003b9" translate="yes" xml:space="preserve">
          <source>Promise.promisifyAll()</source>
          <target state="translated">Promise.promisifyAll()</target>
        </trans-unit>
        <trans-unit id="27847ed541d9e1eeb76f5dbeb0044fcdbf775d18" translate="yes" xml:space="preserve">
          <source>Promise.props</source>
          <target state="translated">Promise.props</target>
        </trans-unit>
        <trans-unit id="4f38df349b880a0f534b640b3a8136437dece180" translate="yes" xml:space="preserve">
          <source>Promise.props now takes a &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/f41edac61b7c421608ff439bb5a09b7cffeadcf9/test/mocha/props.js#L197-L217&quot;&gt;thenable-for-collection&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db0fa212e5a187e62cb941c0f3eb586f29ed38d" translate="yes" xml:space="preserve">
          <source>Promise.props()</source>
          <target state="translated">Promise.props()</target>
        </trans-unit>
        <trans-unit id="6196396df0252ad4dc6749ba58e4f523ddc5109d" translate="yes" xml:space="preserve">
          <source>Promise.race</source>
          <target state="translated">Promise.race</target>
        </trans-unit>
        <trans-unit id="c805ba00efdcb8c7baa42fe61c954261ddd4c775" translate="yes" xml:space="preserve">
          <source>Promise.race()</source>
          <target state="translated">Promise.race()</target>
        </trans-unit>
        <trans-unit id="09422a77b11ac9569156f52e83edb0002c26642c" translate="yes" xml:space="preserve">
          <source>Promise.reduce</source>
          <target state="translated">Promise.reduce</target>
        </trans-unit>
        <trans-unit id="3036bc3d125176ce64d7f9e3b21c3e0d47ea6b85" translate="yes" xml:space="preserve">
          <source>Promise.reduce()</source>
          <target state="translated">Promise.reduce()</target>
        </trans-unit>
        <trans-unit id="783910d23dd1b1558a9b16d71c0ed4b397115fd3" translate="yes" xml:space="preserve">
          <source>Promise.reject</source>
          <target state="translated">Promise.reject</target>
        </trans-unit>
        <trans-unit id="8a2f2af4e6e3d7ca0c77296866bcfff0749f0dd9" translate="yes" xml:space="preserve">
          <source>Promise.reject()</source>
          <target state="translated">Promise.reject()</target>
        </trans-unit>
        <trans-unit id="0a3c75bb1d9e15c9996579992a0721a69da28c55" translate="yes" xml:space="preserve">
          <source>Promise.resolve</source>
          <target state="translated">Promise.resolve</target>
        </trans-unit>
        <trans-unit id="3cf132f388e7330298717bcc33a49e9f948aa7e5" translate="yes" xml:space="preserve">
          <source>Promise.resolve and PromiseResolver.resolve follow thenables too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b038849d964f2910c38df87756eeab2c33c845" translate="yes" xml:space="preserve">
          <source>Promise.resolve()</source>
          <target state="translated">Promise.resolve()</target>
        </trans-unit>
        <trans-unit id="2bd5fccacac7e4b32307e5e90275cc00e52adab2" translate="yes" xml:space="preserve">
          <source>Promise.setScheduler</source>
          <target state="translated">Promise.setScheduler</target>
        </trans-unit>
        <trans-unit id="4f357c9ea9b4ced021695eb3da83abef0f53a5bc" translate="yes" xml:space="preserve">
          <source>Promise.setScheduler()</source>
          <target state="translated">Promise.setScheduler()</target>
        </trans-unit>
        <trans-unit id="b2b14953357fd6fd7061ee19d3a46165592f8187" translate="yes" xml:space="preserve">
          <source>Promise.some</source>
          <target state="translated">Promise.some</target>
        </trans-unit>
        <trans-unit id="a7f83b619aac204250fe4b4b48cffc16048afd2a" translate="yes" xml:space="preserve">
          <source>Promise.some()</source>
          <target state="translated">Promise.some()</target>
        </trans-unit>
        <trans-unit id="bcaec27b9cbb2228f24361eaa259b8fadc6e76b0" translate="yes" xml:space="preserve">
          <source>Promise.try</source>
          <target state="translated">Promise.try</target>
        </trans-unit>
        <trans-unit id="285c74e7f15b5592587b905c39313a8c4c3631cd" translate="yes" xml:space="preserve">
          <source>Promise.try()</source>
          <target state="translated">Promise.try()</target>
        </trans-unit>
        <trans-unit id="54ae20ee3d30d8a4d9a8c3f51ddc74ab08078bce" translate="yes" xml:space="preserve">
          <source>Promise.using</source>
          <target state="translated">Promise.using</target>
        </trans-unit>
        <trans-unit id="d12fa97fde3870925fdf7d6a0ac552e0c8c9b94a" translate="yes" xml:space="preserve">
          <source>Promise.using()</source>
          <target state="translated">Promise.using()</target>
        </trans-unit>
        <trans-unit id="1a5d11d2f1ddb5249c87ef7bd69381bb0b693272" translate="yes" xml:space="preserve">
          <source>PromiseInspection</source>
          <target state="translated">PromiseInspection</target>
        </trans-unit>
        <trans-unit id="868dfb6858e3ed48b9b873232bb97b0244d9d0bf" translate="yes" xml:space="preserve">
          <source>Promises are a concurrency primitive with a proven track record and language integration in most modern programming languages. They have been extensively studied since the 80s and will make your life much easier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4979e5d38a5edf382533cb2038c51eb19a4dee6f" translate="yes" xml:space="preserve">
          <source>Promises are now not cancellable by default. This is backwards incompatible change - see &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#cancellable---promise&quot;&gt;&lt;code&gt;.cancellable()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5dd788dfd2194a43ab6fd8c2d1b84eb1ecc96e" translate="yes" xml:space="preserve">
          <source>Promises can be rejected with falsy values (or no value at all, equal to rejecting with &lt;code&gt;undefined&lt;/code&gt;), however &lt;code&gt;.asCallback&lt;/code&gt; will call the callback with an &lt;code&gt;Error&lt;/code&gt; object if the promise's rejection reason is a falsy value. You can retrieve the original falsy value from the error's &lt;code&gt;.cause&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f657ce6a52627dea6e94af335b6ca122d8163b" translate="yes" xml:space="preserve">
          <source>Promises can have a steep learning curve and it doesn't help that promise standards go out of their way to make it even harder. Bluebird works around the limitations by providing warnings where the standards disallow throwing errors when incorrect usage is detected. See &lt;a href=&quot;warning-explanations&quot;&gt;Warning Explanations&lt;/a&gt; for the possible warnings that bluebird covers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be96f5495c2d83069fb9e4fe84ca585a4ab5539" translate="yes" xml:space="preserve">
          <source>Promises do not aim to solve such live updating problems directly. One option would be to use an intermediate promise - for example a &lt;code&gt;.loaded&lt;/code&gt; property on the model that fulfills with nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63104f36ddfde5f398242d3c9a325847a623a94b" translate="yes" xml:space="preserve">
          <source>Promises have state, they start as pending and can settle to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc07d53901ac77bfe4d99f439fd922d98f514777" translate="yes" xml:space="preserve">
          <source>Promises now clean up all references (to handlers, child promises etc) as soon as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7e995a45e8a7aa84e5616f32bd9b6d2f616aeb" translate="yes" xml:space="preserve">
          <source>Promises now delete references to handlers attached to them as soon as possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f84a547296b83c2cd9be954bf35fa432933967" translate="yes" xml:space="preserve">
          <source>Promises perform a role similar to &lt;code&gt;IO&lt;/code&gt; in that they allow for easy chaining of asynchronous non-blocking operations. &lt;code&gt;Promise.coroutine&lt;/code&gt; can be seen as similar to &lt;code&gt;do&lt;/code&gt; notation although in practice it's not an accurate comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8ddebed649b44e7a85d5ae2af303397fa7ea81" translate="yes" xml:space="preserve">
          <source>Promises provide a lot of really cool and powerful guarantees like throw safety which are hard to provide when manually converting APIs to use promises. Thus, whenever it is possible to use the &lt;code&gt;Promise.promisify&lt;/code&gt; and &lt;code&gt;Promise.promisifyAll&lt;/code&gt; methods - we recommend you use them. Not only are they the safest form of conversion - they also use techniques of dynamic recompilation to introduce very little overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fe5ca98fd7d2bd4d25dbf8138ba708e64fdca4" translate="yes" xml:space="preserve">
          <source>Promises returned by the &lt;code&gt;mapper&lt;/code&gt; function are awaited for and the returned promise doesn't fulfill until all mapped promises have fulfilled as well. If any promise in the array is rejected, or any promise returned by the &lt;code&gt;mapper&lt;/code&gt; function is rejected, the returned promise is rejected as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e30cdf817cbb4a8901ddafd58155a4d7d146650" translate="yes" xml:space="preserve">
          <source>Promises:</source>
          <target state="translated">Promises:</target>
        </trans-unit>
        <trans-unit id="7bdd89f28407b699d8b7e554f8c4f6ce47ea6c46" translate="yes" xml:space="preserve">
          <source>Promisification</source>
          <target state="translated">Promisification</target>
        </trans-unit>
        <trans-unit id="590f705f9b259c4f0eb3b51eea47cea46ae9c547" translate="yes" xml:space="preserve">
          <source>Promisification API changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a75c237f8187352ba7d075c4badc17c24ae0667" translate="yes" xml:space="preserve">
          <source>Promisification means converting an existing promise-unaware API to a promise-returning API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53b14543d28697f9e7972521e017a85547d2532" translate="yes" xml:space="preserve">
          <source>Promisification now consider all functions on the object and its prototype chain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0968c7924c5fa044c0bc32de590809b8b7a0237f" translate="yes" xml:space="preserve">
          <source>Promisification on steroids</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fa280902593381c17c8ba3cc647f71fd36f85f" translate="yes" xml:space="preserve">
          <source>Promisified methods from promisifyAll no longer call the original method when it is overriden</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852dd44380a8f2d2fa9332abfb43753326f8154b" translate="yes" xml:space="preserve">
          <source>Promisifier APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ec2af376bac24219fefb48cbd2c962d80ace5d" translate="yes" xml:space="preserve">
          <source>Promisifies the entire object by going through the object's properties and creating an async equivalent of each function on the object and its prototype chain. The promisified method name will be the original method name suffixed with &lt;code&gt;suffix&lt;/code&gt; (default is &lt;code&gt;&quot;Async&quot;&lt;/code&gt;). Any class properties of the object (which is the case for the main export of many modules) are also promisified, both static and instance methods. Class property is a property with a function value that has a non-empty &lt;code&gt;.prototype&lt;/code&gt; object. Returns the input object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adb5806d2a6c639cdca0db8fdac9403bca0bc03" translate="yes" xml:space="preserve">
          <source>Promisifying multiple classes in one go</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="4177920eedb2d8d91fca3384f4b40aec4d20dcd2" translate="yes" xml:space="preserve">
          <source>Q and bluebird share a lot of common methods that nevertheless have different names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f05aa2c47c6bff64cd5f9cf0a523af4429924d" translate="yes" xml:space="preserve">
          <source>Rate Limiting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161ffbbe54e77d4760152fa5b4074a0a6142966a" translate="yes" xml:space="preserve">
          <source>Read given files sequentially while summing their contents as an integer. Each file contains just the text &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26bb4a571dec15958b5bf88436f13b472b9923db" translate="yes" xml:space="preserve">
          <source>Real example 2:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7056b7cac2c0b2ad06995c1808b40114dc8624" translate="yes" xml:space="preserve">
          <source>Real example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede0567a2a6e0fddab65269f6559f8f6dd06aeb3" translate="yes" xml:space="preserve">
          <source>Rebinding can also be abused to do something gratuitous like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf87a9a8812fbf363e857266207b8e2473838eca" translate="yes" xml:space="preserve">
          <source>Reduce minified full browser build file size by not including unused code generation functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef1e9eebf3f426cee92bf8ff691ff6719cedbd1" translate="yes" xml:space="preserve">
          <source>Register a node-style callback on this promise. When this promise is either fulfilled or rejected, the node callback will be called back with the node.js convention where error reason is the first argument and success value is the second argument. The error argument will be &lt;code&gt;null&lt;/code&gt; in case of success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d6efc26ea6904bda20ba7769db8ea12c079f56" translate="yes" xml:space="preserve">
          <source>Reject the underlying promise with &lt;code&gt;reason&lt;/code&gt; as the rejection reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3368ac8416e6d7cbc9d06211f6a676de253db2de" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;Promise.reject&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b0dba4404c73e60c9ff9e9453523c35331ea038" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;PromiseResolver&lt;/code&gt; where &lt;code&gt;.reject()&lt;/code&gt; method is called explicitly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41142268db768fb66fa944cf61f77fd9b9826e36" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;new Promise&lt;/code&gt; constructor where the &lt;code&gt;reject&lt;/code&gt; callback is called explicitly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe2d523f67748538641074127a1db6157d74f6a" translate="yes" xml:space="preserve">
          <source>Rejections originating from promisified callbacks which use the &lt;code&gt;errback&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eec88d2942215a1433216bd7c1c773ddcf67d09" translate="yes" xml:space="preserve">
          <source>Rejections originating from thenables using the &lt;code&gt;reject&lt;/code&gt; callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198141ba7b56bcf3bec5a18ddd355c8adf68088b" translate="yes" xml:space="preserve">
          <source>Release control of the &lt;code&gt;Promise&lt;/code&gt; namespace to whatever it was before this library was loaded. Returns a reference to the library namespace so you can attach it to something else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0181ee2fe3f8479b72a162b35eb3977b69562275" translate="yes" xml:space="preserve">
          <source>Remove dependency of es5-shim and es5-sham when using ES3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e444431ea8965e36418e87f29f232d6f066fbe6e" translate="yes" xml:space="preserve">
          <source>Remove kew from benchmarks due to bugs in the library breaking the benchmark</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4dd4da1213db0bc986ba8e811f9173d4dfd37c" translate="yes" xml:space="preserve">
          <source>Remove memoization of thenables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="851f4336d464dd91890330239ecdcbcd3eede50c" translate="yes" xml:space="preserve">
          <source>Remove uses of dynamic evaluation (&lt;code&gt;new Function&lt;/code&gt;, &lt;code&gt;eval&lt;/code&gt; etc) when strictly not necessary. Use feature detection to use static evaluation to avoid errors when dynamic evaluation is prohibited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="963bc143de16fd9c36ff8020e48785b4de1b5fa2" translate="yes" xml:space="preserve">
          <source>Removed the &lt;code&gt;.inspect()&lt;/code&gt; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c105dee9adb30dced75f9d53b912f789492799" translate="yes" xml:space="preserve">
          <source>Rename PromiseResolver#asCallback to PromiseResolver#callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93b7a7d13386c2b9229d1b2d9f532763ef7e300" translate="yes" xml:space="preserve">
          <source>Report unhandled rejections even when long stack traces are disabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212187c4ba067f96c7eec7538c40788ae9024465" translate="yes" xml:space="preserve">
          <source>Represents an error is an explicit promise rejection as opposed to a thrown error. For example, if an error is errbacked by a callback API promisified through &lt;a href=&quot;promise.promisify&quot;&gt;&lt;code&gt;Promise.promisify&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; and is not a typed error, it will be converted to a &lt;code&gt;OperationalError&lt;/code&gt; which has the original error in the &lt;code&gt;.cause&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f957ddaaf86217c5ba862399d723b49b7e0b15cb" translate="yes" xml:space="preserve">
          <source>Requires a statement so cannot be used in an expression context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c076f55ca621ae470e8e6540a2f2547c25d4dbe" translate="yes" xml:space="preserve">
          <source>Resolve the underlying promise with &lt;code&gt;value&lt;/code&gt; as the resolution value. If &lt;code&gt;value&lt;/code&gt; is a thenable or a promise, the underlying promise will assume its state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78389e9ab495397e98445c046d321313be7d1269" translate="yes" xml:space="preserve">
          <source>Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator function returns a promise or a thenable, then the result of the promise is awaited, before continuing with next iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce09507134e744cff09a805076e969ccb76e51c1" translate="yes" xml:space="preserve">
          <source>Resolves to the original array unmodified. This method is meant to be used for side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e392aa0bd224f1b62eea587068fd172df50f2e7" translate="yes" xml:space="preserve">
          <source>Resource management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5055e26e1fb07ecf2ddfcb210895ed4ebe7ce8" translate="yes" xml:space="preserve">
          <source>Rethink already uses Bluebird promises internally and has promise returning APIs. Use those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ddb5cfb70d8bad46dda602a6ccbd88515a58d8" translate="yes" xml:space="preserve">
          <source>RethinkDB</source>
          <target state="translated">RethinkDB</target>
        </trans-unit>
        <trans-unit id="48ceb22a9c112e78b0de9c59218daa18a395591e" translate="yes" xml:space="preserve">
          <source>Returns a Disposer object which encapsulates both the resource as well as the method to clean it up. The user can pass this object to &lt;code&gt;Promise.using&lt;/code&gt; to get access to the resource when it becomes available, as well as to ensure it's automatically cleaned up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6f3eb0a331057a9ce7728d16275ef0f0403798" translate="yes" xml:space="preserve">
          <source>Returns a function that can use &lt;code&gt;yield&lt;/code&gt; to yield promises. Control is returned back to the generator when the yielded promise settles. This can lead to less verbose code when doing lots of sequential async calls with minimal processing in between. Requires node.js 0.12+, io.js 1.0+ or Google Chrome 40+.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8e633d273655fa3f1e81f2818120962168742f" translate="yes" xml:space="preserve">
          <source>Returns a function that will wrap the given &lt;code&gt;nodeFunction&lt;/code&gt;. Instead of taking a callback, the returned function will return a promise whose fate is decided by the callback behavior of the given node function. The node function should conform to node.js convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77302444e8cc66fc3523da337688a121188e8a8c" translate="yes" xml:space="preserve">
          <source>Returns a new function that wraps the given function &lt;code&gt;fn&lt;/code&gt;. The new function will always return a promise that is fulfilled with the original functions return values or rejected with thrown exceptions from the original function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0084f22c144f601402343afe0d33d4fb7f3e903" translate="yes" xml:space="preserve">
          <source>Returns a new independent copy of the Bluebird library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b966690c369fe4ac468c8b47b2a688522f4806f" translate="yes" xml:space="preserve">
          <source>Returns a promise for an array that contains the values returned by the &lt;code&gt;iterator&lt;/code&gt; function in their respective positions. The iterator won't be called for an item until its previous item, and the promise returned by the iterator for that item are fulfilled. This results in a &lt;code&gt;mapSeries&lt;/code&gt; kind of utility but it can also be used simply as a side effect iterator similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array#forEach&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa83662ab7e1494742b674953702f77f5f38fa1" translate="yes" xml:space="preserve">
          <source>Returns a promise that is resolved by a node style callback function. This is the most fitting way to do on the fly promisification when libraries don't expose classes for automatic promisification by undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da867e8cf20d6ea986a5fd922cf7a1fb8f17c8a" translate="yes" xml:space="preserve">
          <source>Returns a promise that will be fulfilled with this promise's fulfillment value or rejection reason. However, if this promise is not fulfilled or rejected within &lt;code&gt;ms&lt;/code&gt; milliseconds, the returned promise is rejected with a &lt;a href=&quot;timeouterror&quot;&gt;&lt;code&gt;TimeoutError&lt;/code&gt;&lt;/a&gt; or the &lt;code&gt;error&lt;/code&gt; as the reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6aed551657efa53d35002ee36b6a3e0c3755d8" translate="yes" xml:space="preserve">
          <source>Returns a promise that will be resolved with &lt;code&gt;value&lt;/code&gt; (or &lt;code&gt;undefined&lt;/code&gt;) after given &lt;code&gt;ms&lt;/code&gt; milliseconds. If &lt;code&gt;value&lt;/code&gt; is a promise, the delay will start counting down when it is fulfilled and the returned promise will be fulfilled with the fulfillment value of the &lt;code&gt;value&lt;/code&gt; promise. If &lt;code&gt;value&lt;/code&gt; is a rejected promise, the resulting promise will be rejected immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0baaeaec06f70621397f1ef99fcbfb8ddf084acc" translate="yes" xml:space="preserve">
          <source>Returns back this promise instead of creating a new one. If the &lt;code&gt;callback&lt;/code&gt; argument is not a function, this method does not do anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7778ce7c8366fce862636b34420e6d9618d48dd" translate="yes" xml:space="preserve">
          <source>Revert monitoring feature due to crash in browser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48334a9d7741c7c5b6ebf7eef29195609c38e705" translate="yes" xml:space="preserve">
          <source>Rollback non-working multiple fresh copies feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2379a3b3b95738bc09586b8c9af459a812b070" translate="yes" xml:space="preserve">
          <source>Run example on JSBin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080508f70cca7834ce2ef4eef4f37dd98ffff2b4" translate="yes" xml:space="preserve">
          <source>Running the example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fa217fe73b363a41e739397cee0e3ca1933591" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.all&quot;&gt;&lt;code&gt;Promise.all(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b23caad0148511b77a2cf241f932d7c6709a7d3" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.any&quot;&gt;&lt;code&gt;Promise.any(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580ea88db97d01930313a97fceee680b30d45b7d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.filter&quot;&gt;&lt;code&gt;Promise.filter(this, filterer, options)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975ef8a2ddc0a473b966c6a5cf58d6b15ce60290" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.map&quot;&gt;&lt;code&gt;Promise.map(this, mapper, options)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6801edeea7902bcdcddad94e4e019a39b6cf35a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries(this, iterator)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c55e09fe61d7950e9b369ac035513826c1d2a6" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.props&quot;&gt;&lt;code&gt;Promise.props(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a380c08b4944e2caae2cd146735f961151b5e6e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.reduce&quot;&gt;&lt;code&gt;Promise.reduce(this, reducer, initialValue)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a356dad7c25106bdfd17533e6d57d965a40a5a84" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.some&quot;&gt;&lt;code&gt;Promise.some(this, count)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cc344c16a1e8b60323a0d888ae481c9928a8ab" translate="yes" xml:space="preserve">
          <source>Same as calling &lt;a href=&quot;promise.bind&quot;&gt;&lt;code&gt;Promise.bind(thisArg, thisPromise)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e458385af15b3281d6aad96024285a33aab42f7e" translate="yes" xml:space="preserve">
          <source>Same as calling &lt;a href=&quot;promise.delay&quot;&gt;&lt;code&gt;Promise.delay(ms, this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c078b3023463c3ffc03ea245f314b93b9997db" translate="yes" xml:space="preserve">
          <source>Same limitations regarding to the binding time of &lt;code&gt;reason&lt;/code&gt; to apply as with &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f6c90a1ad0cebcb9beb15aafa1cb6735ec4a6f" translate="yes" xml:space="preserve">
          <source>Same limitations regarding to the binding time of &lt;code&gt;value&lt;/code&gt; to apply as with &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7e70bcf209a5323526033a9cbf768a3ae70c2c" translate="yes" xml:space="preserve">
          <source>Scala</source>
          <target state="translated">Scala</target>
        </trans-unit>
        <trans-unit id="4c8d353832617594b0903e9beaf0a3bc9414fd0a" translate="yes" xml:space="preserve">
          <source>Scheduler should be a function that asynchronously schedules the calling of the passed in function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e22d4f13d0bc08ae5171b4f3faa591b3854aba" translate="yes" xml:space="preserve">
          <source>Scoped prototypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4c2c805f8ac17da444424c8f8bf077911b3260" translate="yes" xml:space="preserve">
          <source>Second example is creating a function that does nothing but manually wrap a callback API and doing a poor job at that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c651da6b87ea51d587627a0d63283b28e42fd9e4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#map-option-concurrency&quot;&gt;Map Option: concurrency&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc2fab79463362dbab8dbab63714a6f37b5961f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#promisification&quot;&gt;promisification&lt;/a&gt; for more examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a68335a77ae0704a80f59d32facaab6ffbdba9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/cancellation&quot;&gt;&lt;code&gt;Cancellation&lt;/code&gt;&lt;/a&gt; for how to use cancellation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f52e149e8a0803d7f7b841c33681f919e936364" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/environment-variables&quot;&gt;&lt;code&gt;Environment Variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab38b0ca0dbd1886ea0aa3b5d41ba2fd2e703bb5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/error-management-configuration#global-rejection-events&quot;&gt;global rejection events&lt;/a&gt; to learn more about the hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06395aee9e31cf27b400d0aac841e6752959ba6e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/progression-migration&quot;&gt;Progression Migration&lt;/a&gt; for migration assistance and examples of how to convert APIs that use progression to ones that do not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ba78b1d14da78646ebff542d287d69dbc5a960" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/a/17891099/227176&quot;&gt;this StackOverflow answer&lt;/a&gt; for a more detailed and feature complete way to make custom errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06706fc1eca556ceadf36cdc2fed09eb5719e880" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala&quot;&gt;this question on StackOverflow&lt;/a&gt; for more differences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f924e288cbca74d9deadff4feb3964dc20a0cb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/questions/26136389/how-can-i-realize-pattern-promise-deffered&quot;&gt;this question on StackOverflow&lt;/a&gt; for more differences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b47ded2bd3e84b6a1d18b1f7005536f6c95a4c4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to enable long stack traces in your environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40938884818bf7e771e25611b0ecc72ecf13d826" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to enable warnings in your environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd18968e9220ec2edbcb69219a62b308e07af8ca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;new-in-bluebird-3&quot;&gt;New in 3.0&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a128fef004cd14934d7a35ae580447b292348acd" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c964d6768cfba0357dc178ad5c1c5b834096887" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec633a7c6034c365e8ffcaf57fd91b71d7eba69d" translate="yes" xml:space="preserve">
          <source>See if this &lt;code&gt;promise&lt;/code&gt; has been cancelled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ba106a736de3c98da11dcab4e39f4c475860bf" translate="yes" xml:space="preserve">
          <source>See if this &lt;code&gt;promise&lt;/code&gt; is pending (not fulfilled or rejected or cancelled).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f5e31f9196af8cf21954e2abe72267402aeb61" translate="yes" xml:space="preserve">
          <source>See if this promise has been fulfilled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4923f987cce26c1b5f0647eecfad58c0130790b" translate="yes" xml:space="preserve">
          <source>See if this promise has been rejected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00853e3a835e9b91810aba99eb34ee3eaa60c4cf" translate="yes" xml:space="preserve">
          <source>See the API on &lt;a href=&quot;api/synchronous-inspection&quot;&gt;&lt;code&gt;synchronous inspection&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d3dd68401ad34ac91e21bd296d96dcc691d3a3" translate="yes" xml:space="preserve">
          <source>See the API page about &lt;a href=&quot;api/promise.longstacktraces&quot;&gt;&lt;code&gt;Promise.longStackTraces&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32248b4544c4dacee860f46416e5a89b6310bc5c" translate="yes" xml:space="preserve">
          <source>Sequelize</source>
          <target state="translated">Sequelize</target>
        </trans-unit>
        <trans-unit id="0353c268d6003a0b1d6e372faa2ae4914cf1ab42" translate="yes" xml:space="preserve">
          <source>Sequelize already uses Bluebird promises internally and has promise returning APIs. Use those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0477fce5eb6ea953b269e6b50843ad48931e59dd" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;multiArgs&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; means the resulting promise will always fulfill with an array of the callback's success value(s). This is needed because promises only support a single success value while some callback API's have multiple success value. The default is to ignore all but the first success value of a callback function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d87c38ef9cdbe40b70787a797d9e70b16e2a6cd" translate="yes" xml:space="preserve">
          <source>Setting a custom scheduler could be necessary when you need a faster way to schedule functions than bluebird does by default. It also makes bluebird possible to use in platforms where normal timing constructs like &lt;code&gt;setTimeout&lt;/code&gt; and &lt;code&gt;process.nextTick&lt;/code&gt; are not available (like Nashhorn).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3932ebbf539f8a931c6f13cf255530da552644ed" translate="yes" xml:space="preserve">
          <source>Setting the environment variable &lt;code&gt;NODE_ENV&lt;/code&gt; to &lt;code&gt;&quot;development&quot;&lt;/code&gt; also automatically enables long stack traces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4742ee0d05bf00094d42512b9006ce355572faaf" translate="yes" xml:space="preserve">
          <source>Several examples of databases follow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e704260c9c34a30c1e1c6e9cc96dcbaba23b9e4" translate="yes" xml:space="preserve">
          <source>Several popular Android libraries use promises - for example the Parse Java API returns &lt;code&gt;Task&lt;/code&gt;s which are similar to JavaScript promises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79948cec8617f2b258642406e788e89df84d104b" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;.then(null, null, handler);&lt;/code&gt;. Attach a progress handler that will be called if this promise is progressed. Returns a new promise chained from this promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d63e7d6731c58944766cb081aef40963e6cb50" translate="yes" xml:space="preserve">
          <source>Showing a live list of rejected promises</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbe005c943c12fa6ff0d2f8cafd5ad98bc70211" translate="yes" xml:space="preserve">
          <source>Signals that an operation has been aborted or cancelled. The default reason used by &lt;a href=&quot;cancel&quot;&gt;&lt;code&gt;.cancel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299f23dc5dcc08c7bfee7c8ae781aacf85c196cb" translate="yes" xml:space="preserve">
          <source>Signals that an operation has timed out. Used as a custom cancellation reason in &lt;a href=&quot;timeout&quot;&gt;&lt;code&gt;.timeout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bf40da88360ad7bbfcf32d9dd42056cd2f6ff3" translate="yes" xml:space="preserve">
          <source>Significantly improve parallel promise performance and memory usage (+50% faster, -50% less memory)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63c65ce4045c196a80e2036ef184d1e29767129" translate="yes" xml:space="preserve">
          <source>Significantly improve performance of foreign bluebird thenables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730519283954b4569cc72648083ced3012f2475e" translate="yes" xml:space="preserve">
          <source>Similarly, with promises:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16c84188a248cb435f2ade69bfef7f54bb36e8f" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;api/promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; takes promises, it must also take jQuery deferreds, so the above can be shortened to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d62301257a57ffc03da0d5c42ed2549e221316" translate="yes" xml:space="preserve">
          <source>Since all objects support having properties you might still wonder why exactly does it have to be an error object and not just any object. In addition to supporting properties, an equally important feature necessary for values that are automatically propagated is the stack trace property (&lt;code&gt;.stack&lt;/code&gt;). A stack trace allows you easily find where an error originated from as it gives the code's call stack - along with line numbers for reference in code files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d019d6c6f872eca710a5e9fe46091f1e234c2c" translate="yes" xml:space="preserve">
          <source>Since in bluebird &lt;a href=&quot;api/promisification&quot;&gt;&lt;code&gt;promisification&lt;/code&gt;&lt;/a&gt; is made trivial, you can get long stack traces all the time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd8d850f23fc1a81c14cb9cdd8a5e00431fefc26" translate="yes" xml:space="preserve">
          <source>Since the array passed to waterfall is static (always the same 3 functions) a plain old promise chain is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead75c8725f0a9530a5abc673013177ab974cfdf" translate="yes" xml:space="preserve">
          <source>Small performance improvements for all collection methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc101ed1f69471502ee81d7871e2413721d60887" translate="yes" xml:space="preserve">
          <source>So how then could we represent a progress bar like dialog? Well the answer is to manage the progress through callbacks outside the promise API. Bluebird has since &lt;a href=&quot;deprecated-apis#progression&quot;&gt;deprecated the progression feature&lt;/a&gt; and offers an alternative which I hope to illustrate here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ae1ffa70bbe4990a8964de54d99ecd7b5fd6b5" translate="yes" xml:space="preserve">
          <source>So please write the same when using promises too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e6caa4611dfebbc5e6e21fabaf9c486084de89" translate="yes" xml:space="preserve">
          <source>Some examples of the above practice applied to some popular libraries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328f2682f2d41aa9dcab87997132944918cfc2f4" translate="yes" xml:space="preserve">
          <source>Some nodebacks expect more than 1 success value but there is no mapping for this in the promise world. You may specify the option &lt;code&gt;spread&lt;/code&gt; to call the nodeback with multiple values when the fulfillment value is an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38c75cc8957e65c44573a2e27f3885375d06448" translate="yes" xml:space="preserve">
          <source>Something missing from the above example is proper error handling. When it comes to promises it is a best practise to always &lt;em&gt;reject a promise with an Error&lt;/em&gt; and not with plain data such as an object, string, number, or null/undefined. The reasoning for this is promises are best used as a way to regain some of the syntax you have with the standard &lt;code&gt;try {} catch() {}&lt;/code&gt; blocks with asynchronous code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5366b89baa9bf31993646740e57cd8f67859925" translate="yes" xml:space="preserve">
          <source>Sometimes we want to find out when a single one time event has finished. For example - a stream is done. For this we can use &lt;a href=&quot;api/new-promise&quot;&gt;&lt;code&gt;new Promise&lt;/code&gt;&lt;/a&gt;. Note that this option should be considered only if &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;automatic conversion&lt;/a&gt; isn't possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b9d85f33b2e758641f19550f5a9be3023ea242" translate="yes" xml:space="preserve">
          <source>Sometimes you have to work with APIs that are inconsistent and do not follow a common convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f7595fc4eaf9c4327785c6f28cc0a3cb93f37a" translate="yes" xml:space="preserve">
          <source>Sparse array holes are not skipped by collection methods but treated as existing elements with &lt;code&gt;undefined&lt;/code&gt; value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334f0f329646de4898c801e89bc81110c62b9723" translate="yes" xml:space="preserve">
          <source>Start the chain of promises with &lt;code&gt;Promise.try&lt;/code&gt;. Any synchronous exceptions will be turned into rejections on the returned promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7544908a62ca43e11724d7886c37028c419b528e" translate="yes" xml:space="preserve">
          <source>Starting from 2.7.0 all bluebird instances also fire rejection events globally so that applications can register one universal hook for them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3603ca6749bcc3136f65ac99d1a525e581f1708b" translate="yes" xml:space="preserve">
          <source>Stream libraries tend to serve a different purpose than promise libraries. Unlike promise libraries streams can represent multiple values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8475ec2272fa6b1c6b05f2bd678210b89009cf" translate="yes" xml:space="preserve">
          <source>Such a constructor can be minimally created like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58681e9c8fb0c509a2cfc71f3a1d6ba692e9b25" translate="yes" xml:space="preserve">
          <source>Such policies could include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1919f0096a6b3087e18c842a5097f047b54d80" translate="yes" xml:space="preserve">
          <source>Such wrappers should be rare, if they're common for the reason that the promise library cannot generically promisify them, you should file an issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0158596539b88e3d14cfe51fe82aba75fca71681" translate="yes" xml:space="preserve">
          <source>Summary of breaking changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e51f0164b5bdc44f9880dc21c2988e1430f473" translate="yes" xml:space="preserve">
          <source>Support primitives in catch filters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c6c2ddc426343eed559ce47d4c777df69eba0c" translate="yes" xml:space="preserve">
          <source>Supported platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02259e275f481a7fdda40736a24df99f0cd3a67" translate="yes" xml:space="preserve">
          <source>Surfacing unhandled errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f9e4820c3b2f7bbea724b622595d004feda9b4" translate="yes" xml:space="preserve">
          <source>Swallowing all errors (challenge your debugging skills)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4e83066087dd1079c656c148313dafa0d0a48a" translate="yes" xml:space="preserve">
          <source>Synchronous inspection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560cd166df807614aa93c9f2544b674451945594" translate="yes" xml:space="preserve">
          <source>Synchronous inspection allows you to retrieve the fulfillment value of an already fulfilled promise or the rejection reason of an already rejected promise synchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f22a0a957f0468c0084e1e9ae07dd450cc45ad2" translate="yes" xml:space="preserve">
          <source>That is, you can return either a promise &lt;em&gt;or a plain value&lt;/em&gt; from a &lt;code&gt;then&lt;/code&gt; without wrapping it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bb1fab188a923aeae77d6108a07ce0c4ce134b" translate="yes" xml:space="preserve">
          <source>That means &lt;code&gt;value&lt;/code&gt; is bound at the time of calling &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt; so this will not work as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5c6863d3d57d6db5e4a2e948905db8b10466ee" translate="yes" xml:space="preserve">
          <source>That means when you have a problem there probably isn't an existing function tailored exactly to that problem but instead you can just combine the existing utilities to arrive at a solution. The upside of this is that you don't need to come up with all these different functions to solve problems that are not that different from each other. The most important thing to do when migrating from async to bluebird is this profound shift in philosophy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31fbbf769a579d258b6c345c7359a66afd6aa22" translate="yes" xml:space="preserve">
          <source>That said, if you have code written using jQuery deferred methods, such as &lt;code&gt;.then&lt;/code&gt;, &lt;code&gt;.done&lt;/code&gt; and so on, you cannot drop-in replace the jQuery deferred with a bluebird promise in that code. Despite having the same names, jQuery deferred methods have different semantics than bluebird promise methods. These differences are due to the completely different goals of the implementations. Bluebird is &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;an internal DSL&lt;/a&gt; for the domain of asynchronous control flow while jQuery deferreds are a callback aggregator utility (&quot;glorified event emitters&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9576ae41ed6c2fc691cc3233977df2602674a9e5" translate="yes" xml:space="preserve">
          <source>The &quot;a promise was created in a handler but not returned from it&quot; warning now adds the bluebird API method used to create the non-returned promise at the top of the warning stack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2387bf8a5eec038b8dc1d6a136dd30eb885c69f6" translate="yes" xml:space="preserve">
          <source>The &quot;a promise was created in a handler but not returned from it&quot; warning now highlights the file, line and column where the return statement is missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9172632794382321ca96b52eb375dcf229573bb4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reflect&quot;&gt;&lt;code&gt;.reflect&lt;/code&gt;&lt;/a&gt; method returns a promise that is always successful when this promise is settled. Its fulfillment value is an object that implements the &lt;a href=&quot;promiseinspection&quot;&gt;&lt;code&gt;PromiseInspection&lt;/code&gt;&lt;/a&gt; interface and reflects the resolution of this promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc5097b492ec34ac1dac37541df7fa6d5523657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.props&lt;/code&gt; method expects to receive an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0eb698af924dfb32cf54d281b02888c506ead09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.then(success, fail)&lt;/code&gt; anti-pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fcdb3492bd1cc7aa9ff1b548b88ce52afafa5d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.then&lt;/code&gt; signature is mostly about interop, there is &lt;em&gt;almost&lt;/em&gt; never a reason to use &lt;code&gt;.then(success, fail)&lt;/code&gt; in application code. It is even awkward to express it in the sync parallel:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e944db85ee16051290ad72f2026b7a41fb2a4813" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map&lt;/code&gt; operation is expecting an array here (or a promise on one) and instead gets the number &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f752091c174b33d9da17500cd7d1d3ae7eb2bd9" translate="yes" xml:space="preserve">
          <source>The Explicit Construction Anti-Pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae99b6910e577d7be696210c2dbfc212e81ffa5" translate="yes" xml:space="preserve">
          <source>The JavaScript is the same as the &lt;code&gt;PromptDialog&lt;/code&gt; only we will add a &lt;code&gt;setProgress()&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987db8ad0cd3c6e2880ebfda0417324d809a8643" translate="yes" xml:space="preserve">
          <source>The above calls the function &lt;code&gt;processImage()&lt;/code&gt;&lt;em&gt;immediately&lt;/em&gt; and passes the result to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; (which is most likely &lt;code&gt;undefined&lt;/code&gt; - the default return value when a function doesn't return anything).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5b45d618d205b79bdd2339e1eb511e0597ceee" translate="yes" xml:space="preserve">
          <source>The above can also be written as (with a caveat, see below)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d96d94c20e29d7be811aad09d5f2fc69d847ac" translate="yes" xml:space="preserve">
          <source>The above does a &lt;code&gt;console.log&lt;/code&gt; of &lt;code&gt;my-element&lt;/code&gt;. Doing it this way is necessary because neither of the methods (&lt;code&gt;getElementById&lt;/code&gt;, &lt;code&gt;console.log&lt;/code&gt;) can be called as stand-alone methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff51746636ecc3655cfcaa3b14edb8e79b82038" translate="yes" xml:space="preserve">
          <source>The above ensures &lt;code&gt;getConnection&lt;/code&gt; fulfills the contract of a promise-returning function of never throwing a synchronous exception. Also see &lt;a href=&quot;promise.try&quot;&gt;&lt;code&gt;Promise.try&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec563887821c925f0b9a15bbaeb4d94ba4967bb9" translate="yes" xml:space="preserve">
          <source>The above function can then make everyone happy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5a0fcd51c35945773869b7451e685e33fe2b5b" translate="yes" xml:space="preserve">
          <source>The above has a direct translation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3a5d7ac08554519f84fa1292d020a1294faf0a" translate="yes" xml:space="preserve">
          <source>The above without &lt;a href=&quot;bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; could be achieved with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6770726e6458fe58ea6b5f4fd62bd9042424df5" translate="yes" xml:space="preserve">
          <source>The actual subscription API depends on the environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16cc25950a83115317503e4adef79079d08a456" translate="yes" xml:space="preserve">
          <source>The advantage of using &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; over &lt;code&gt;.catch(function(){})&lt;/code&gt; is that it doesn't increment the branch count of the promise. Branch counts matter when using cancellation because a promise will only be cancelled if all of its branches want to cancel it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c56f54fb10413e626d1f27ae289fc09dbb6d933" translate="yes" xml:space="preserve">
          <source>The advantages of the new cancellation compared to the old cancellation are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38af64a279ce9559ab9430fe352d1985725b5b6" translate="yes" xml:space="preserve">
          <source>The cancellation feature is &lt;strong&gt;by default turned off&lt;/strong&gt;, you can enable it using &lt;a href=&quot;promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6200a8a72cc85fe3cd189630a2f941b849b20c71" translate="yes" xml:space="preserve">
          <source>The concurrency limit applies to Promises returned by the mapper function and it basically limits the number of Promises created. For example, if &lt;code&gt;concurrency&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; and the mapper callback has been called enough so that there are three returned Promises currently pending, no further callbacks are called until one of the pending Promises resolves. So the mapper function will be called three times and it will be called again only after at least one of the Promises resolves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ab830fa32b91594137493c8717fb7b7a2afbf7" translate="yes" xml:space="preserve">
          <source>The default approach of bluebird is to immediately log the stack trace when there is an unhandled rejection. This is similar to how uncaught exceptions cause the stack trace to be logged so that you have something to work with when something is not working as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79301b912f99cabfc6b1d506271ff79825a49941" translate="yes" xml:space="preserve">
          <source>The default filter function will ignore properties that start with a leading underscore, properties that are not valid JavaScript identifiers and constructor functions (function which have enumerable properties in their &lt;code&gt;.prototype&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7c7d829660ad1b607e4ff44a0e6cb994eacdf1" translate="yes" xml:space="preserve">
          <source>The dialog interface might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec7326b7197ff7aa9ec6904e534048cbee04708" translate="yes" xml:space="preserve">
          <source>The difference between a &lt;code&gt;Task&lt;/code&gt; and a promise are that a task might not be started and might require a &lt;code&gt;.Start&lt;/code&gt; call where a promise always represents an already started operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801933290ac764cce3fee90e0b881f138a330a0e" translate="yes" xml:space="preserve">
          <source>The entire prototype chain of the object is promisified on the object. Only enumerable are considered. If the object already has a promisified version of the method, it will be skipped. The target methods are assumed to conform to node.js callback convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument. If the node method calls its callback with multiple success values, the fulfillment value will be an array of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6be4df893a1137d6b3ab84348ff99be431c883e" translate="yes" xml:space="preserve">
          <source>The explicit construction anti-pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e45891046aa649e068bb199da2efeaca661dda" translate="yes" xml:space="preserve">
          <source>The following lifecycle events are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55e86c0fc753c356970890234eaa0b0ce6daee6" translate="yes" xml:space="preserve">
          <source>The function being called expects a Promise, but is given something different. There are two main reasons why this may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa7caae49fcd453bbf69746e24b32d9fbb6ba35" translate="yes" xml:space="preserve">
          <source>The generic promisification is likely to be faster because it can use internals directly but also handles edge cases like &lt;code&gt;libraryFunction&lt;/code&gt; throwing synchronously or using multiple success values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2748080c6d9715db0ad2710e45478c0f7c5d34" translate="yes" xml:space="preserve">
          <source>The global events are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6f6a9e8f68d43e290c78abcefdf4dfcc31bc80" translate="yes" xml:space="preserve">
          <source>The handler functions are now closures, thus less efficient and not reusable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578ba1114aa6fcded1f091d1702ddf63eaf4722c" translate="yes" xml:space="preserve">
          <source>The implementations for this benchmark are found in &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/doxbee-sequential&quot;&gt;&lt;code&gt;benchmark/doxbee-sequential&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2beec3e3018a687405477c67e8972c8a6a40dae3" translate="yes" xml:space="preserve">
          <source>The implementations for this benchmark are found in &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/madeup-parallel&quot;&gt;&lt;code&gt;benchmark/madeup-parallel&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9448500cacb1ff64a30efd5b0e2bea57a588d796" translate="yes" xml:space="preserve">
          <source>The mapper function for a given item is called as soon as possible, that is, when the promise for that item's index in the input array is fulfilled. This doesn't mean that the result array has items in random order, it means that &lt;code&gt;.map&lt;/code&gt; can be used for concurrency coordination unlike &lt;code&gt;.all&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6416948697e16aeabbf92ec68782960804a2782d" translate="yes" xml:space="preserve">
          <source>The methods of a &lt;code&gt;PromiseResolver&lt;/code&gt; have no effect if the fate of the underlying promise is already decided (follow, reject, fulfill).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666da53e9ba5fafe397413f91312c555ed1b2845" translate="yes" xml:space="preserve">
          <source>The mortals that can handle it may now release Zalgo by &lt;code&gt;require(&quot;bluebird/zalgo&quot;);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788c3f097a42e7ff06bdab38fdaf7df400494dfe" translate="yes" xml:space="preserve">
          <source>The new cancellation has &quot;don't care&quot; semantics while the old cancellation had abort semantics. Cancelling a promise simply means that its handler callbacks will not be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a98aedc50b84c7ebb0badc2de651f3ecf8937b9" translate="yes" xml:space="preserve">
          <source>The object predicate passed to &lt;code&gt;.catch&lt;/code&gt; in the above code (&lt;code&gt;{code: 'ENOENT'}&lt;/code&gt;) is shorthand for a predicate function &lt;code&gt;function predicate(e) { return isObject(e) &amp;amp;&amp;amp; e.code == 'ENOENT' }&lt;/code&gt;, I.E. loose equality is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c421b7ad33c6aa4c4ac1a5b06c22ec76d37875" translate="yes" xml:space="preserve">
          <source>The old progression API was meant to be used for tracking the progress of promise resolution. In retrospect, it did not work or compose very well. We understand that problem better now and the use case could be better solved without it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090f1f6fbdfbd7a3e0db64396e47bb24d64eb73a" translate="yes" xml:space="preserve">
          <source>The order &lt;code&gt;map&lt;/code&gt; calls the mapper function on the array elements is not specified, there is no guarantee on the order in which it'll execute the &lt;code&gt;map&lt;/code&gt;er on the elements. For order guarantee in sequential execution - see &lt;a href=&quot;promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22323bb03a1bb54a462c5535aaf1a55e597ca564" translate="yes" xml:space="preserve">
          <source>The problem with the above is that &lt;code&gt;getConnection&lt;/code&gt; itself might throw for some reason and if it does we'll get a synchronous rejection. An asynchronous operation should always be asynchronous to prevent double guarding and race conditions so it's best to always put the sync parts inside the promise constructor as such:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b81307bb00a714d49523b7e191e0b6160f8ce58" translate="yes" xml:space="preserve">
          <source>The promisifier gets a reference to the original method and should return a function which returns a promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a87fc5ef703ad3003e186be301223055a0f1187" translate="yes" xml:space="preserve">
          <source>The resolver function is passed a callback that expects to be called back according to error-first node conventions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5aac58e5c09043c491849101f61a81a5b4d12d" translate="yes" xml:space="preserve">
          <source>The resolver is called synchronously (the following is for documentation purposes and not idiomatic code):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4bfc9835f1db3d068610dc3f23387d9b6dbcae" translate="yes" xml:space="preserve">
          <source>The same can also be written more concisely with &lt;code&gt;Function.prototype.bind&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d032a40184c01ff45a4fcd6a47f5f6ed12cc2d" translate="yes" xml:space="preserve">
          <source>The same thing can be done with less code using jQuery's &lt;a href=&quot;https://api.jquery.com/on/#event-names&quot;&gt;event namespacing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2a20abb7e468fc73f206d7f17b3365726ea73c" translate="yes" xml:space="preserve">
          <source>The second argument passed to a disposer is the result promise of the using block, which you can inspect synchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1062ee61728ebe80f9bce80f90c97c30f5a642" translate="yes" xml:space="preserve">
          <source>The situation can be fixed with &lt;code&gt;.finally&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cfd5d14e8e321897ce3ab8e2b61c1f01768a60" translate="yes" xml:space="preserve">
          <source>The solution is to either convert it to a promise by calling &lt;code&gt;Promise.resolve&lt;/code&gt; on it or &lt;code&gt;Promise.promisify&lt;/code&gt; if it's a callback:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a959d4cee575b4382df36392cd8df64e24184dbc" translate="yes" xml:space="preserve">
          <source>The stack trace for &lt;a href=&quot;warning-explanations#warning-a-promise-was-created-in-a-handler-but-none-were-returned-from-it&quot;&gt;forgotten return warnings&lt;/a&gt; is more useful now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7cfeae4442044317b39c717825ad07af88a84b2" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot;&gt;Promises/A+ &lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; is still supported by Bluebird and support for it will continue indefinitely . However, the variant accepting a third &lt;code&gt;progressHandler&lt;/code&gt; argument is no longer supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0578afb0e805324fd3d6ef6661225daacb79ec32" translate="yes" xml:space="preserve">
          <source>The suffix must be a valid JavaScript identifier using ASCII letters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e5ddd442738d3ba0fcf36bd1580ce1e7b6558a" translate="yes" xml:space="preserve">
          <source>The usage pattern is similar to the PostgreSQL example above. You can also use a disposer pattern (but not an actual .disposer). See the PostgreSQL example above for instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28bb7fa145553052b5508efe6d9bb705def39d86" translate="yes" xml:space="preserve">
          <source>The usual way to use promises in node is to &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; some API and start exclusively calling promise returning versions of the APIs methods. E.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0826c3236c309fa1a8bb247d52444104239f26" translate="yes" xml:space="preserve">
          <source>The usual way to use promises in node is to &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; some API and start exclusively calling promise returning versions of the APIs methods. E.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="12dfbb41929f3ee02dc34311b3347fac9dec5515" translate="yes" xml:space="preserve">
          <source>There are many third party promise libraries available for JavaScript and even the standard library contains a promise implementation in newer versions of browsers and node/io.js. This page will explore why one might use bluebird promises over other third party or the standard library implementations. For reasons why to use promises in general, see the &lt;a href=&quot;why-promises&quot;&gt;Why Promises?&lt;/a&gt; article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0016f6e7c65d90d1ef2d07a4adbd7695a74d6216" translate="yes" xml:space="preserve">
          <source>There are many ways to use bluebird in browsers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfa8f7a74926d5b3e71d319fe2e3737e67b4a45" translate="yes" xml:space="preserve">
          <source>There are still a few problems with the earlier code example. It feels like it is doing too much. A &lt;em&gt;squint&lt;/em&gt; test reveals behavior for showing the dialog, set the dialog's message, attach two DOM events, construct a promise, event delegation, hide the dialog, and finally detach DOM events. That is a lot for one little function. A refactoring can help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d9fdb7b10a480524179ca553be134c2cab93bd" translate="yes" xml:space="preserve">
          <source>There are two primary methods of converting callback based APIs into promise based ones. You can either manually map the API calls to promise returning functions or you can let the bluebird do it for you. We &lt;strong&gt;strongly&lt;/strong&gt; recommend the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f594978f8f4cce365338daa917338cba030de34d" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;this more general StackOverflow question&lt;/a&gt; about conversion of callback APIs to promises. If you find anything missing in this guide however, please do open an issue or pull request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ffbfbc41fe53312b41cce044330748666500e8" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://www.promisejs.org/generators/&quot;&gt;excellent article&lt;/a&gt; on promisejs.org detailing how to combine promises with generators to achieve much cleaner code. Instead of the &lt;code&gt;async&lt;/code&gt; function the article proposes, you can use &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd6b50860623f70756069f499d23f01b6d13e5c" translate="yes" xml:space="preserve">
          <source>There is no effect on performance if the user doesn't actually pass a node-style callback function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a899a39eea077d35fbd555f33e92cdecfa97e0f3" translate="yes" xml:space="preserve">
          <source>There is no need to convert timeouts/delays to a bluebird API, bluebird already ships with the &lt;a href=&quot;api/promise.delay&quot;&gt;&lt;code&gt;Promise.delay&lt;/code&gt;&lt;/a&gt; function for this use case. Please consult the &lt;a href=&quot;api/timers&quot;&gt;&lt;code&gt;timers&lt;/code&gt;&lt;/a&gt; section of the docs on usage and examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816256e371a68e0a4e42cc5d7e31e59e968b1550" translate="yes" xml:space="preserve">
          <source>This APIs are what most core modules in Node/io use and bluebird comes with a fast and efficient way to convert them to promise based APIs through the &lt;code&gt;Promise.promisify&lt;/code&gt; and &lt;code&gt;Promise.promisifyAll&lt;/code&gt; function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d88bc0890f9955d9aafd69e5e422f7404df8670" translate="yes" xml:space="preserve">
          <source>This abstraction can be expanded on in other ways. For example a notification dialog:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef92d2a854bbe01523868d53a897ee9b600001a" translate="yes" xml:space="preserve">
          <source>This also happens when implementing live-updating models with a &lt;code&gt;.then&lt;/code&gt; method that indicates when the model is &quot;ready&quot;. A promise is a process, it starts and it ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9ddcdc77c9d4a96e7a508b17988600ecaa73fc" translate="yes" xml:space="preserve">
          <source>This also means that disposers should not contain code that does anything other than resource disposal. For example, you cannot write code inside a disposer to commit or rollback a transaction, because there is no mechanism for the disposer to signal a failure of the commit or rollback action without crashing the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b2c8b4731b0f7ba7e6bf98e67448082824c523" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/api/promise.each.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b70a0a7654e551108da4764c9f005aab32644aa" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/async-dialogs.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c525d7a299f5e8e85d4de9a717c3aacb38e9c7" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/beginners-guide.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52f9c032871178393d4fecda1b976e39b1a06b1" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/deprecated-apis.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f8fae1cd767c72257bf951d6fae38ca4750167" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/features.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b80a141eb9286b1bcd67d018003d3e43d4ca6b1" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/getting-started.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d9ce5a1a1cedf3cd3c1bf2b642c4920ce3d476" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/warning-explanations.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01153e43a1c1cb6db13e7e38cfc4a7ca277baf87" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/what-about-generators.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2b6fdf4dc9492f2c92f1362815d504f5b44c1e" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/why-performance.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a69f82bc8c73af862fe6ee2765641d403ac8822" translate="yes" xml:space="preserve">
          <source>This can be used to create APIs that both accept node-style callbacks and return promises:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af698572346d77b6e2820e63d397c65adf61bf3" translate="yes" xml:space="preserve">
          <source>This can be useful if a function returns a promise (say into a chain) but can optionally return a static value. Say, for a lazy-loaded value. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01154032238ce0a62f38ce2edfeea44425f1609e" translate="yes" xml:space="preserve">
          <source>This can happen when you are calling &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; on a function and invoking it instead of passing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e20e128e0a8a57b67f7c7c358d05477f3c5d61" translate="yes" xml:space="preserve">
          <source>This can happen when you tried to do something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caac030e0f988203bfd2f85f66f13be073b83988" translate="yes" xml:space="preserve">
          <source>This doesn't add much much using &lt;code&gt;window.prompt&lt;/code&gt;; however, one advantage is the API that promises provide. In the case where we call &lt;code&gt;promptPromise(&amp;hellip;)&lt;/code&gt; we can easily react to the result of the dialog without having to worry about how it is implemented. In our example we've implemented the &lt;code&gt;window.prompt&lt;/code&gt; but our call to &lt;code&gt;promptPromise()&lt;/code&gt; doesn't care. This makes a change to an &lt;em&gt;asynchronous&lt;/em&gt; dialog a little more future proof.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b6120513a7366580cee8aba7b9480ac2cf93a2" translate="yes" xml:space="preserve">
          <source>This error indicates you have tried to call &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; on an object that already has a property with the &lt;code&gt;Async&lt;/code&gt; suffix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a572d9a56addbf0b78e49d060a13678d16002f76" translate="yes" xml:space="preserve">
          <source>This example doesn't work as intended because the &lt;code&gt;then&lt;/code&gt; handler actually swallows the exception and returns &lt;code&gt;undefined&lt;/code&gt; for any further chainers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c54ec4bcf6b3320c0e8ec781b0cb320bbd68320" translate="yes" xml:space="preserve">
          <source>This example pings 4 nameservers, and logs the fastest 2 on console:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b07ce3ee1a174adcf4f487506a3c9e336575eaf" translate="yes" xml:space="preserve">
          <source>This feature enables subscription to promise lifecycle events via standard global events mechanisms in browsers and Node.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876ee350821244d6855a5b5648beee14fb439673" translate="yes" xml:space="preserve">
          <source>This feature has to be explicitly enabled by calling &lt;a href=&quot;api/promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;monitoring: true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7179462cda9a709541b309d7c01bbb585212a4" translate="yes" xml:space="preserve">
          <source>This file contains documentation for APIs that are no longer supported by Bluebird. These APIs still work in Bluebird but will be removed at a future version of the library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1d1e209b1192c78f57f02dae0b2d4bf136ca53" translate="yes" xml:space="preserve">
          <source>This happens when a non object value or a promise that resolves with something that is not an object is being passed instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3b4bfaeb441a21b0068d6c2bb1331473c59ffc" translate="yes" xml:space="preserve">
          <source>This happens when you call &lt;code&gt;.some&lt;/code&gt; passing it a negative value or a non-integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361cf2ec170969184f8f35c3d2c58d91c88e0978" translate="yes" xml:space="preserve">
          <source>This inherits from &lt;code&gt;Dialog&lt;/code&gt; and stores references to the required DOM elements that this dialog uses. It then attaches the require DOM events (&lt;code&gt;attachDomEvents()&lt;/code&gt;) which eventually call the callbacks. Then it implements the &lt;code&gt;show()&lt;/code&gt; and &lt;code&gt;hide()&lt;/code&gt; methods. Its usage is more flexible and verbose:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c40c501429304b951f3e9a1e618216d7da3fae9" translate="yes" xml:space="preserve">
          <source>This interface is implemented by &lt;code&gt;Promise&lt;/code&gt; instances as well as the &lt;code&gt;PromiseInspection&lt;/code&gt; result given by &lt;a href=&quot;reflect&quot;&gt;&lt;code&gt;.reflect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1625642eae18357d2f9d1a1405e4d5fa15c5195c" translate="yes" xml:space="preserve">
          <source>This is Gorki Kosev's benchmark used in the article &lt;a href=&quot;http://spion.github.io/posts/analysis-generators-and-other-async-patterns-node.html&quot;&gt;Analysis of generators and other async patterns in node&lt;/a&gt;. The benchmark emulates a situation where N=10000 requests are being made concurrently to execute some mixed async/sync action with fast I/O response times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49dfefe9b869fa007a2d85f8deb59c16587b42f" translate="yes" xml:space="preserve">
          <source>This is a catch-all exception handler, shortcut for calling &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then(null, handler)&lt;/code&gt;&lt;/a&gt; on this promise. Any exception happening in a &lt;code&gt;.then&lt;/code&gt;-chain will propagate to nearest &lt;code&gt;.catch&lt;/code&gt; handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cc0d7fb9773615b0a72dbe0951bb7f568b688b" translate="yes" xml:space="preserve">
          <source>This is a convenience method for doing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab45ed2cecaf14b1bbcc736ecc5d3c6da77d3562" translate="yes" xml:space="preserve">
          <source>This is a throughput benchmark.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb50cb46856cf19733b9b720a91a5dbcedf8961" translate="yes" xml:space="preserve">
          <source>This is an extension to &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; to work more like catch-clauses in languages like Java or C#. Instead of manually checking &lt;code&gt;instanceof&lt;/code&gt; or &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt;, you may specify a number of error constructors which are eligible for this catch handler. The catch handler that is first met that has eligible constructors specified, is the one that will be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6f1e1654fff47bb7489453d9f0b688afc82574" translate="yes" xml:space="preserve">
          <source>This is an extension to &lt;a href=&quot;tapcatch&quot;&gt;&lt;code&gt;.tapCatch&lt;/code&gt;&lt;/a&gt; to filter exceptions similarly to languages like Java or C#. Instead of manually checking &lt;code&gt;instanceof&lt;/code&gt; or &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt;, you may specify a number of error constructors which are eligible for this tapCatch handler. The tapCatch handler that is first met that has eligible constructors specified, is the one that will be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9b1d19482e049c5d2755c5328d90634cf4cf49" translate="yes" xml:space="preserve">
          <source>This is because Bluebird adds the &lt;code&gt;Async&lt;/code&gt; suffix to distinguish the original method from the promisified one, so &lt;code&gt;fooAsync&lt;/code&gt; would have been overridden. In order to avoid this - either rename &lt;code&gt;fooAsync&lt;/code&gt; before promisifying the API, or call &lt;a href=&quot;api/promise.promisify&quot;&gt;&lt;code&gt;Promise.promisify&lt;/code&gt;&lt;/a&gt; manually on select properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb04140a6d6f4216a6dfa405bfd92da440efbba0" translate="yes" xml:space="preserve">
          <source>This is exactly like the synchronous code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb76de6040fe50d520474f7810629da738b7706" translate="yes" xml:space="preserve">
          <source>This is far more readable when done with promises:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618293c3c21f06bb90993a614c9db3abe676ad93" translate="yes" xml:space="preserve">
          <source>This is reinventing the square wheel because any callback API wrapping can and should be done immediately using the promise library's promisification methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278f2f5f91e65aca9cba986cd298d5b80d084994" translate="yes" xml:space="preserve">
          <source>This is relevant to browser environments with no module loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72dacc01b0328b9bb5e5b49e4a3b2f09a68d5835" translate="yes" xml:space="preserve">
          <source>This is the most common anti-pattern. It is easy to fall into this when you don't really understand promises and think of them as glorified event emitters or callback utility. It's also sometimes called the promise constructor anti-pattern. Let's recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel. This pattern is also called the deferred anti-pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83310ff097e8beff42467f80b6885cac44a4a774" translate="yes" xml:space="preserve">
          <source>This is the point&amp;mdash;to have something that works like &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; in synchronous code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="158db758d5ef9e5d2ebee4458ff60d03b8698f8f" translate="yes" xml:space="preserve">
          <source>This is to enable better stack trace support and to have more consistent and logical code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2cd71a05d06d1a123d046c307b240be60c02ec" translate="yes" xml:space="preserve">
          <source>This made-up scenario runs 25 shimmed queries in parallel per each request (N=10000) with fast I/O response times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0de91929a03e3312c7e239b95e998f29ef038e" translate="yes" xml:space="preserve">
          <source>This method also supports predicate-based filters. If you pass a predicate function instead of an error constructor, the predicate will receive the error as an argument. The return result of the predicate will be used determine whether the error handler should be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9befc4f3f3a5debf1bc48e96cdc0758b3d6448b" translate="yes" xml:space="preserve">
          <source>This method is compatible with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; from native promises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0481512ec7eb9822880d2eb57c4e1770159cdaa" translate="yes" xml:space="preserve">
          <source>This method is convenient when a function can sometimes return synchronously or throw synchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05db19a6c7c0e842cae324b6edc66273dd337537" translate="yes" xml:space="preserve">
          <source>This method is deprecated. Use &lt;a href=&quot;promise.config&quot;&gt;Promise.config&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63178b611e277d3437aa6cb79a370492a0a4d4d" translate="yes" xml:space="preserve">
          <source>This method is only implemented because it's in the ES6 standard. If you want to race promises to fulfillment the &lt;a href=&quot;any&quot;&gt;&lt;code&gt;.any&lt;/code&gt;&lt;/a&gt; method is more appropriate as it doesn't qualify a rejected promise as the winner. It also has less surprises: &lt;code&gt;.race&lt;/code&gt; must become infinitely pending if an empty array is passed but passing an empty array to &lt;a href=&quot;any&quot;&gt;&lt;code&gt;.any&lt;/code&gt;&lt;/a&gt; is more usefully a &lt;code&gt;RangeError&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f763d4342a3b00b5440e744954545f7480822a" translate="yes" xml:space="preserve">
          <source>This method is useful for when you want to wait for more than one promise to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13b547a51d6973b8e8ea8229673f31834f1a93d" translate="yes" xml:space="preserve">
          <source>This method should be used before you use any of the methods which would otherwise alter the global &lt;code&gt;Bluebird&lt;/code&gt; object - to avoid polluting global state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb88a06a14951217dbf7da64e1c214d581435513" translate="yes" xml:space="preserve">
          <source>This page describes parallels of using promises in other languages. Promises as a pattern are very common in other languages and knowing what they map to in other languages might help you with grasping them conceptually</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8caafd4bd28c25bbaa9e7e7281f27609e085879" translate="yes" xml:space="preserve">
          <source>This page explains how to interface your code with existing callback APIs and libraries you're using. We'll see that making bluebird work with callback APIs is not only easy - it's also fast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31362f3d4d915353baa5045a042087f3f740de15" translate="yes" xml:space="preserve">
          <source>This page is a reference for migrating to bluebird from other flow control or promise libraries. See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to use bluebird in your environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9a982268e14e003930e216d5e26566cf85c426" translate="yes" xml:space="preserve">
          <source>This page will contain common promise anti-patterns that are exercised in the wild.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9be090a3976e3bdcf5c7d5ffe1e9f09746eddc" translate="yes" xml:space="preserve">
          <source>This section lists the most common async module replacements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbbc8fd10030426b3463e06d9b5b51c19c29316d" translate="yes" xml:space="preserve">
          <source>This section only applies to node.js or io.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde97755fad5f67be03bd6d1c4049a9360dedd37" translate="yes" xml:space="preserve">
          <source>This superfluous wrapping is also dangerous, any kind of errors and rejections are swallowed and not propagated to the caller of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12297c68c5f136df52d6d18d4a5ba1ec592d81f8" translate="yes" xml:space="preserve">
          <source>This usually happens when you have a promise that resolves or rejects with itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c09fd50a68a2d3dd2ca54a203b3e20039f8ff5" translate="yes" xml:space="preserve">
          <source>This usually means that you simply forgot a &lt;code&gt;return&lt;/code&gt; statement somewhere, which will cause a runaway promise that is not connected to any promise chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641aada61fdf6b191fac4681998d3181bd3d099f" translate="yes" xml:space="preserve">
          <source>This will ensure that &lt;code&gt;connection.close()&lt;/code&gt; will be called once the promise returned from the &lt;code&gt;Promise.using&lt;/code&gt; closure is resolved or if an exception was thrown in the closure body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1caca18b80550e74fc714f5129356a12216a1b3" translate="yes" xml:space="preserve">
          <source>This works because the array acts as a &quot;module&quot; where the indices are the &quot;module&quot;'s properties for classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642f5108aa274866c1da99279aa0b6d98b1fdf21" translate="yes" xml:space="preserve">
          <source>Through the use of &lt;a href=&quot;api/each&quot;&gt;&lt;code&gt;.each&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/map&quot;&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/a&gt; doing things just at the right concurrency level becomes a breeze.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a4ad2c60d9b1a4a4ab47810c732e12faec00b0" translate="yes" xml:space="preserve">
          <source>TimeoutError</source>
          <target state="translated">TimeoutError</target>
        </trans-unit>
        <trans-unit id="ae5a9ed10e48f39a8b693714bce92b1291ca1c8b" translate="yes" xml:space="preserve">
          <source>TimeoutError()</source>
          <target state="translated">TimeoutError()</target>
        </trans-unit>
        <trans-unit id="841cd03a97cd854590864d79ae48ee749c5e902e" translate="yes" xml:space="preserve">
          <source>Timers</source>
          <target state="translated">Timers</target>
        </trans-unit>
        <trans-unit id="23658960168be8cdbfbe275f17c4c761b8a8f3e9" translate="yes" xml:space="preserve">
          <source>To do this we will have two &lt;code&gt;catch()&lt;/code&gt; functions one for &lt;code&gt;UserCanceledError&lt;/code&gt; and one for any other &lt;code&gt;Error&lt;/code&gt;. We can make a custom error like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a3ce42d2f42f9c24273b4cda598b33af25fce3" translate="yes" xml:space="preserve">
          <source>To drive home the synchronous nature of the &lt;code&gt;window.prompt&lt;/code&gt; notice that the time stops ticking when the prompt dialog is displayed. Let's fix that by making our own prompt. Since our dialog is just DOM manipulation the page won't be blocked while waiting for user input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7035efe5121276c8995557c4e8d8404d5096469" translate="yes" xml:space="preserve">
          <source>To enable long stack traces and warnings in node development:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e38679fea7f9ddcf16ac2341ac48ffb3d6a13cd" translate="yes" xml:space="preserve">
          <source>To enable long stack traces and warnings in node production:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302b55ad14f02d86e137c0363366e824866304b7" translate="yes" xml:space="preserve">
          <source>To enable them in all instances of bluebird in node.js, use the environment variable &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a347bd13a256b214fb6fa7d0dff43a0c457c811" translate="yes" xml:space="preserve">
          <source>To fix it, simply pass the function reference to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; as is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab4b669048933cdcafeed010c60563bc2fd72dd" translate="yes" xml:space="preserve">
          <source>To fix it, you need to &lt;code&gt;return&lt;/code&gt; the promise:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67cb18d088b9f1e447cdd241d432d091a17f83ef" translate="yes" xml:space="preserve">
          <source>To fix, simply remember to add &lt;code&gt;return&lt;/code&gt; in front of your promise-complying function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfea82804728489558d139da2f0b772571e485c" translate="yes" xml:space="preserve">
          <source>To make sure a function that returns a promise is following the implicit but critically important contract of promises, you can start a function with &lt;code&gt;new Promise&lt;/code&gt; if you cannot start a chain immediately:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f45ac1d08d953780ed4fe1af6ee2f1aafa55655" translate="yes" xml:space="preserve">
          <source>Together with &lt;code&gt;onPossiblyUnhandledRejection&lt;/code&gt; these hooks can be used to implement a debugger that will show a list of unhandled promise rejections updated in real time as promises become handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffb3821e2781468cd3c381c1dd88d7da75f44e5" translate="yes" xml:space="preserve">
          <source>Typically &lt;em&gt;promises&lt;/em&gt; are used in conjunction with asynchronous tasks such as a network request or a &lt;code&gt;setTimeout&lt;/code&gt;; a lesser explored use is dealing with user input. Since a program has to wait for a user to continue some actions it makes sense to consider it an asynchronous event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e39893849d27ccdda4985a773f9d1a23141d52" translate="yes" xml:space="preserve">
          <source>Unhandled errors are not silently swallowed by default but reported along with helpful stack traces where applicable. All of this is of course configurable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a34c30705919f5365483a84e6ffe973cf51a891" translate="yes" xml:space="preserve">
          <source>Unhandled rejections are tracked per promise, not per error. So if you create multiple branches from a single ancestor and that ancestor gets rejected, each branch with no error handler with the end will cause a possibly unhandled rejection handler invocation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c350ad9142ecaab016e03c764abcb7074c45e90" translate="yes" xml:space="preserve">
          <source>Unless an AMD loader is installed, the script tag installation exposes the library in the &lt;code&gt;Promise&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; namespaces. If you want to restore the &lt;code&gt;Promise&lt;/code&gt; namespace, use &lt;code&gt;var Bluebird = Promise.noConflict()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e42a41d2a20532fa9a5c2908e1e8626e2a7e8e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; this is not called for rejections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8371d8f357f54bfda7d7c8677986ada6f8fa2ae9" translate="yes" xml:space="preserve">
          <source>Unminified source file meant to be used in development. Warnings and long stack traces are enabled which are taxing on performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a8536e189c405379021d94a1e8532ff836496d" translate="yes" xml:space="preserve">
          <source>Updated logo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b6f1fdb58d25854a37bb391362fd81dc049478" translate="yes" xml:space="preserve">
          <source>Usage examples include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb4421a3da2485be27f4aababc58c8de5da2c8d7" translate="yes" xml:space="preserve">
          <source>Use setImmediate if available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289a45d725e898c1ca06ab7fa01837771482ed99" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#parallel&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d609f610f666b772e57874290c0b6739f1e46b91" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.each&quot;&gt;&lt;code&gt;Promise.each&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b37cc52da759eea0a61e35010724d1f98be048a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.map&quot;&gt;&lt;code&gt;Promise.map&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87872433fa3fca67fb5bcea17254b8b45dc74c5d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#seriestasks-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a34d8c3d20da73e7fdd61d0a9cd7e9a530150eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.reflect()&lt;/code&gt; to implement &lt;code&gt;settleAll&lt;/code&gt; (wait until all promises in an array are either rejected or fulfilled) functionality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a030f13931277422b23a2b7aa92804eba9dbfca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.reflect()&lt;/code&gt; to implement &lt;code&gt;settleProps&lt;/code&gt; (like settleAll for an object's properties) functionality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510bd1d1748aa6be73d0b3f164f968144ae8f326" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;defaultPromisifier&lt;/code&gt; parameter to add enhancements on top of normal node promisification:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f32ad8c97706d5425fc98083d499e4e2b0f38a" translate="yes" xml:space="preserve">
          <source>Using CoffeeScript's &lt;code&gt;class&lt;/code&gt; for the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b2fb1fa487e5be55b2254cc478460136f04a5f" translate="yes" xml:space="preserve">
          <source>Using DOM3 &lt;code&gt;addEventListener&lt;/code&gt; APIs (support starting from IE9+):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0031ac8ff26e8b6b8c4fa9f5d7c7a8c5ff06fc8d" translate="yes" xml:space="preserve">
          <source>Using ECMAScript6 generators feature to implement C# 5.0 &lt;code&gt;async/await&lt;/code&gt; like syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acac6fbc07a16dd7002db7cd3b214125856ce811" translate="yes" xml:space="preserve">
          <source>Using an abstraction like this the &lt;code&gt;promisePrompt&lt;/code&gt; no longer needs to know anything about the DOM and concentrates on just providing a promise. This will also make things easier to create a promised version of a progress bar or confirmation dialog or any other type of UI that we want to have a value for. All we will need to do is write a class for that dialog type with the same interface and just pass that class into our promise making method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e2993e6dea235a7dcb1db5bb36202c8485dbc9" translate="yes" xml:space="preserve">
          <source>Using it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d829b44477e34c8358b0978984bdca898183bed9" translate="yes" xml:space="preserve">
          <source>Using jQuery after:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c991e6de4c7c9ecea657f843e9921caf549f2112" translate="yes" xml:space="preserve">
          <source>Using jQuery before:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee10eda3c3f21aee43203ae597d2c13cd07e6eea" translate="yes" xml:space="preserve">
          <source>Using legacy APIs (support starting from IE6+):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f995a28f75764b72a6c79dc89d54dd724921f6" translate="yes" xml:space="preserve">
          <source>Using manual resolver:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99578b7705756deffc2aa58f6ae34fb2dbdb0c2" translate="yes" xml:space="preserve">
          <source>Using multiple resources:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f65738b0a1c42c2a41e0b59a0029999f986703" translate="yes" xml:space="preserve">
          <source>Using no hooks and using &lt;a href=&quot;api/done&quot;&gt;&lt;code&gt;.done&lt;/code&gt;&lt;/a&gt; to manually to mark end points where rejections will not be handled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678ad3a7449dc9211f664a6a26c9f4eeb83dd91e" translate="yes" xml:space="preserve">
          <source>Using no hooks and using &lt;a href=&quot;done&quot;&gt;&lt;code&gt;.done&lt;/code&gt;&lt;/a&gt; to manually to mark end points where rejections will not be handled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7de8d54140fb8771440fc81fb18f3d53f9f6bb4f" translate="yes" xml:space="preserve">
          <source>Using recursion to implement the example from &lt;a href=&quot;https://github.com/caolan/async#whilsttest-fn-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c7e148244964ef32867f708db116db37aa2e23" translate="yes" xml:space="preserve">
          <source>Using the same function &lt;code&gt;Promise.method&lt;/code&gt;, there is no need to manually wrap direct return or throw values into a promise:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf3b6cb551f8ba0a6b556e915881b1d2f0aa867" translate="yes" xml:space="preserve">
          <source>Using the value &lt;code&gt;0&lt;/code&gt; will explicitly disable a feature despite debug environment otherwise activating it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="02024b434dc6bfc227f2288a4656819d24c77710" translate="yes" xml:space="preserve">
          <source>Warn when &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; is passed non-functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76bc85fbac802c9c28a4f34074f76273aa28dba3" translate="yes" xml:space="preserve">
          <source>Warning Explanations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e326d603e8ef33a0ace61e8bd45d1476027c27c7" translate="yes" xml:space="preserve">
          <source>Warning: .then() only accepts functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f253a4ff30df6ead65cd95ca2db9916033eb9d8" translate="yes" xml:space="preserve">
          <source>Warning: a promise was created in a handler but was not returned from it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f19b7cfb75065744f09c3f3dbd1dd8602fb5742" translate="yes" xml:space="preserve">
          <source>Warning: a promise was rejected with a non-error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="f9b093958e9b93291eee426980c6f76c2af8380b" translate="yes" xml:space="preserve">
          <source>Warnings about created promises that are not returned are no longer given if the handler promise has not been chained. This should reduce the amount of false positives with this warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987519cc8247ea08d785b3bed0d0edba12ab4768" translate="yes" xml:space="preserve">
          <source>Warnings have been added to report usages which are very likely to be programmer errors. See &lt;a href=&quot;api/promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt; for how to enable warnings. See &lt;a href=&quot;warning-explanations&quot;&gt;Warning Explanations&lt;/a&gt; for list of the warnings and their explanations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2346b64bd2ceb68b2dd0fe9b356367b311b6a6a1" translate="yes" xml:space="preserve">
          <source>We can do better, retaining concurrency and not leaking resources, by using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d449d2a1898fdf6171ab397563a248fe80459a1d" translate="yes" xml:space="preserve">
          <source>We can use the promise constructor to convert it to a promise returning function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0998ac30de0c1580642c82716276399b1c613149" translate="yes" xml:space="preserve">
          <source>We will want to keep the same API so our change will be only to the &lt;code&gt;promisePrompt&lt;/code&gt;. It will find the dialog DOM elements, attach events to the elements, show the dialog box, return a promise that is resolved based on the attached events, and finally detaches the events and cleans up after itself (hiding the dialog box for another use later).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86974e9cfd94347a9d8035a721441882b61e40c8" translate="yes" xml:space="preserve">
          <source>We'll cover several subjects. If you want to get the tl;dr what you need is likely the &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;Working with callback APIs using the Node convention&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b24863fa5a051446f6f2ae3860594cb7d071eb" translate="yes" xml:space="preserve">
          <source>Well simply, when you have to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c4fdd7823278887156d018b49c43e024631c27" translate="yes" xml:space="preserve">
          <source>What About Generators?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a484e5211183ba2cee4378c92b44d3105eeaf7" translate="yes" xml:space="preserve">
          <source>What about promises that have multiple consumers?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7c4ebe4c5f3bfe7fb62f4c2a84779817b88487" translate="yes" xml:space="preserve">
          <source>What actually happens is that &lt;code&gt;result&lt;/code&gt; keeps track of how many consumers it has, in this case 2, and only if all the consumers signal cancel will the request be aborted. However, as far as &lt;code&gt;firstConsumer&lt;/code&gt; can tell, the promise was successfully cancelled and its handlers will not be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c519ceae2b771a7ddeac59daf39ed209a19525" translate="yes" xml:space="preserve">
          <source>What is the the point of promises</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56aab8af41c28bb5f9c760d67856cb60689f1c68" translate="yes" xml:space="preserve">
          <source>What's new in 2.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2223542269901e7186ce7f97c69174f8009c3e4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NODE_ENV&lt;/code&gt; environment variable is &lt;code&gt;&quot;development&quot;&lt;/code&gt; setting &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; environment variable to &lt;code&gt;0&lt;/code&gt; can now be used to disable debug mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268de3a5addf552f9cb9505acf541fb1a6c7d1c4" translate="yes" xml:space="preserve">
          <source>When called, the coroutine function will start an instance of the generator and returns a promise for its final value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abcda78ef2264e69cff0163a190c8f4b357591ac" translate="yes" xml:space="preserve">
          <source>When chaining &lt;code&gt;.spread&lt;/code&gt;, returning an array of promises also works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c0e36e057ee58c2317285366278f58808242b8" translate="yes" xml:space="preserve">
          <source>When debugging or performing a one-time operation on a variable before passing it to a function, a return variable is forgotten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d8621b03578f1c94ccc629a4cc7c4de3a568ed" translate="yes" xml:space="preserve">
          <source>When there are asynchronous tasks that have the ability to notify progress as they complete it can be tempting to want that in the promise that represents that task. Unfortunately this is a bit of an anti-pattern. That is because the point of promises is to represent a value as if it was natural (like it is in normal synchronous code) and not to be over glorified callback management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f5f46aab39a3a9a507394c2c440bab65f0ea48" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;longStackTraces&lt;/code&gt; the first line in your code after requiring Bluebird should be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9be79b81b6d65c3ed9b6fe0e6688b7fd74367ea" translate="yes" xml:space="preserve">
          <source>When using script tags the global variables &lt;code&gt;Promise&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; (alias for &lt;code&gt;Promise&lt;/code&gt;) become available. Bluebird runs on a wide variety of browsers including older versions. We'd like to thank BrowserStack for giving us a free account which helps us test that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2fe4cb42752a52e254b8a6bf3ceb42b7e1ac55" translate="yes" xml:space="preserve">
          <source>When using the first signature, you may specify a custom error message with the &lt;code&gt;message&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f41737292fcc0beb27bde5ba12d4c02e4d5a28" translate="yes" xml:space="preserve">
          <source>When we construct our &lt;code&gt;ProgressDialog&lt;/code&gt; we use the &lt;code&gt;waitForUser()&lt;/code&gt; method to capture the user interaction promise and then use &lt;code&gt;delayedPromise()&lt;/code&gt; to capture the fake network promise and finally &lt;code&gt;Promise.reace()&lt;/code&gt; to manage the two simultaneously and end with a single promise as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294f81c22475eef4fbaab8c79a52c780d37a7f28" translate="yes" xml:space="preserve">
          <source>When working with promises the philosophy is basically a complete opposite than when using &lt;code&gt;async&lt;/code&gt;. Async provides a huge bag of uncomposable helper functions that work at a very low level of abstraction. When using promises you can get the utility otherwise provided by uncountable amount of inflexible helper functions by just combining and composing a few existing functions and concepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0d63ddeca860f4dd0ee04e6e6dfb59036ec440" translate="yes" xml:space="preserve">
          <source>Where blocking on a Future in scala is discouraged, in JavaScript it's downright impossible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04b5cdd0c9e7373883bf0306180ab9eff2c21cc" translate="yes" xml:space="preserve">
          <source>Which is needed in case error handlers are attached asynchronously to the promise later, which would otherwise result in premature unhandled rejection reporting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee12cfe2d4a58cb2a6fc803d3775440ef97f722" translate="yes" xml:space="preserve">
          <source>Which would allow you to use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d4fe62a5e87bc7beed2b0eec9121835e2b2243" translate="yes" xml:space="preserve">
          <source>Which would let you do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048203462f9f2ccf893052bbc1b4ea9379b53188" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;cancel().&lt;/code&gt; is synchronous - &lt;code&gt;onCancel()&lt;/code&gt; is called asynchronously (in the next turn) just like &lt;code&gt;then&lt;/code&gt; handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50051d4da0ca7d94943f9fa9969394e5949e12c1" translate="yes" xml:space="preserve">
          <source>While with long stack traces disabled, you would get:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a448f3eb7ee54eee8b460fbecc359153bf18d65f" translate="yes" xml:space="preserve">
          <source>Why I am switching to promises</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1472dbb2e195b22057a90d66f7a65b38461e79ba" translate="yes" xml:space="preserve">
          <source>Why Performance?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103997b340ba267b74ce431e1b85c8fb216b7d7d" translate="yes" xml:space="preserve">
          <source>Why Promises?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eed14a899fe9a4d5bf8f80b6404d95efa7b1db8" translate="yes" xml:space="preserve">
          <source>Why bluebird?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f975858c19a385aa9526530dd08a5074375be2f" translate="yes" xml:space="preserve">
          <source>With the use of abstract classes can the similarities between &lt;code&gt;PromptDialog&lt;/code&gt; and &lt;code&gt;NotifyDialog&lt;/code&gt; be abstracted? Make a sub class of &lt;code&gt;Dialog&lt;/code&gt; that abstracts the common DOM code (&lt;code&gt;DOMDialog&lt;/code&gt;). Then refactor the &lt;code&gt;PromptDialog&lt;/code&gt; and &lt;code&gt;NotifyDialog&lt;/code&gt; to inherate from &lt;code&gt;DOMDialog&lt;/code&gt; but references the correct DOM selectors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b389c6872f328b7947b20ae5c017fe2c10bb9526" translate="yes" xml:space="preserve">
          <source>Without arrow functions that provide lexical &lt;code&gt;this&lt;/code&gt;, the correspondence between async and sync code breaks down when writing object-oriented code. &lt;a href=&quot;bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; alleviates this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673b91ef144006953b2d0d3e1f31a66ba0a792bd" translate="yes" xml:space="preserve">
          <source>Working with Callbacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4814f16d83ce4c03a7697dffe837dd35ff625c3c" translate="yes" xml:space="preserve">
          <source>Working with any other APIs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5431ac75df408d5c9ffc310217a12d8d9dcbf00" translate="yes" xml:space="preserve">
          <source>Working with browser APIs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c2aac0738162450c1ba5ec6b637d0caf73d2e1" translate="yes" xml:space="preserve">
          <source>Working with callback APIs using the Node convention</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37dd709d1ccc2e12457cf6c183d0dbd315ee98c2" translate="yes" xml:space="preserve">
          <source>Working with databases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06f929d4baa5a3ecf78b00957e3722d031a73c3" translate="yes" xml:space="preserve">
          <source>Working with delays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5122dff991374514454140bce7e200af64069d8d" translate="yes" xml:space="preserve">
          <source>Working with delays/setTimeout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c7659f3ee1ffff84437f6bd7a29c13e55a9375" translate="yes" xml:space="preserve">
          <source>Working with one time events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37316c9a58ae41ce75652d0e2a54b3a2feb756f2" translate="yes" xml:space="preserve">
          <source>Working with one time events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b04f9b661548e262a9e539e7d756bac07782fea" translate="yes" xml:space="preserve">
          <source>Write a function that takes a &lt;code&gt;Dialog&lt;/code&gt; instance and a default value. Have it return a promise that resolves to the default value if the user clicks cancel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf07d9d6990a0b3a8a806a431339f0ecf271176" translate="yes" xml:space="preserve">
          <source>Yield handlers are called when you yield something that is not supported by default. The first yield handler to return a promise or a thenable will be used. If no yield handler returns a promise or a thenable then an error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb668cd94f8eca0b469371342b38d09219dbd2d0" translate="yes" xml:space="preserve">
          <source>Yielding an array from a coroutine is not supported by default. You can use &lt;a href=&quot;api/coroutine.addyieldhandler&quot;&gt;&lt;code&gt;coroutine.addYieldHandler()&lt;/code&gt;&lt;/a&gt; to configure the old behavior (or any behavior you want).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43584c4df9052974185d0f13b0565b92e014095" translate="yes" xml:space="preserve">
          <source>You are able to yield non-promise values by adding your own yield handler using &lt;a href=&quot;promise.coroutine.addyieldhandler&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler&lt;/code&gt;&lt;/a&gt; or calling &lt;code&gt;Promise.coroutine()&lt;/code&gt; with a yield handler function as &lt;code&gt;options.yieldHandler&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e127999f42b63c2eddd476b0efc6c0cd617fe5c2" translate="yes" xml:space="preserve">
          <source>You are getting this error because you are enabling long stack traces after a promise has already been created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf62350a61d792a4742ad486033ffd83aaf0f56d" translate="yes" xml:space="preserve">
          <source>You are getting this error because you have tried to &lt;code&gt;yield&lt;/code&gt; something in a coroutine without a yield handler, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ca93bb6eb46f59e659c6e2ebfd242ff1f0e6ac" translate="yes" xml:space="preserve">
          <source>You are getting this error when trying to use &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt; and not passing it a generator function as a parameter. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91785a774efe083e20f0a926f490793891f37e71" translate="yes" xml:space="preserve">
          <source>You can also pass the resources in an array in the first argument. In this case the handler function will only be called with one argument that is the array containing the resolved resources in respective positions in the array. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e28c9edbfac1286ca67380518a1038c18f9339" translate="yes" xml:space="preserve">
          <source>You can also refactor some looping patterns to a more natural form that would &lt;a href=&quot;https://github.com/promises-aplus/promises-spec/issues/179&quot;&gt;leak memory when using native promises&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437864fc7461809f33ab9ef10e2c5d258352b129" translate="yes" xml:space="preserve">
          <source>You can also use it as a hook:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5b397ce7d92f145be04aede9a7905dd3a775cc" translate="yes" xml:space="preserve">
          <source>You can also use promises to improve code that was written with callbacks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283713c3baaf7fbedb1d299415d2545b4024ca50" translate="yes" xml:space="preserve">
          <source>You can change bluebird behavior globally with various environment variables. These global variables affect all instances of bluebird that are running in your environment, rather than just the one you have &lt;code&gt;require&lt;/code&gt;d in your application. The effect an environment variable has depends on the bluebird version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b2e22d4bf3505ebf9bddb84ee0510239a546e0" translate="yes" xml:space="preserve">
          <source>You can configure the warning for checking forgotten return statements with &lt;code&gt;wForgottenReturn&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a9baad84a48a76541ea70044c4acc58a16ccf2" translate="yes" xml:space="preserve">
          <source>You can correct this by doing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81293703b0f372c4f1dd8c1c5f5f64e0b6876c85" translate="yes" xml:space="preserve">
          <source>You can get a reference to &lt;a href=&quot;aggregateerror&quot;&gt;&lt;code&gt;AggregateError&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Promise.AggregateError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa9ba97c4236ec4af4790e170f1a3227c61dec4" translate="yes" xml:space="preserve">
          <source>You can get this error for several reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef442967cec8981710fc742773b5611ef039af93" translate="yes" xml:space="preserve">
          <source>You can get this error when you're trying to call &lt;code&gt;.value&lt;/code&gt; or &lt;code&gt;.error&lt;/code&gt; when inspecting a promise where the promise has not been fulfilled or rejected yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5a4a44a59a1f96bff1bedb0c04a482fd574dd1" translate="yes" xml:space="preserve">
          <source>You can promisify multiple classes in one go by constructing an array out of the classes and passing it to &lt;code&gt;promisifyAll&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fb5d736e0ab6fce975e6a9b34a4fef475d7bc7" translate="yes" xml:space="preserve">
          <source>You got this error because you used &lt;code&gt;new Promise()&lt;/code&gt; or &lt;code&gt;new Promise(something)&lt;/code&gt; without passing a function as the parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d97ed3b9b528f072b3b9ef916af019f8c658c3" translate="yes" xml:space="preserve">
          <source>You got this this error because you've used &lt;code&gt;Promise.promisify&lt;/code&gt; on an object, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca3543e4c8b58e9db66720a46ab1377349e2f9b" translate="yes" xml:space="preserve">
          <source>You may also add multiple filters for a catch handler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83847d072bb765ac14ac4e083fdf4b485ddcd196" translate="yes" xml:space="preserve">
          <source>You may also use the custom suffix option to choose another suffix that doesn't result in conflicts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6624c3c603bb59caba6a82386be7841487cbe7f2" translate="yes" xml:space="preserve">
          <source>You may now return promises and thenables from the filterer function used in &lt;code&gt;Promise.filter&lt;/code&gt; and &lt;code&gt;Promise.prototype.filter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e60416b3790827596a6ef7f2cab94aae07bff3" translate="yes" xml:space="preserve">
          <source>You may optionally prepend one predicate function or ErrorClass to pattern match the error (the generic &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; methods accepts multiple)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dea303545fcf8fcdea34efebeca4ef1c0a6fbdc" translate="yes" xml:space="preserve">
          <source>You may optionally specify a concurrency limit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f96ba6d073dbbb822c6dc38156f5d2c778c3e34" translate="yes" xml:space="preserve">
          <source>You may register an optional cancellation hook at a root promise by using the &lt;code&gt;onCancel&lt;/code&gt; argument that is passed to the executor function when cancellation is enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7c4c4ceabe5cd66746addf080121cd0177cb25" translate="yes" xml:space="preserve">
          <source>You may use &lt;a href=&quot;api/promise.setscheduler&quot;&gt;&lt;code&gt;Promise.setScheduler&lt;/code&gt;&lt;/a&gt; to pass a custom scheduler that your environment supports. For example in DukTape:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d529e0be153c472000cf98a0b7d4552852d11f" translate="yes" xml:space="preserve">
          <source>You may use browserify on the main export</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5178ce348175a2d6a2e16b69f6aa6c59ef943a40" translate="yes" xml:space="preserve">
          <source>You may use the &lt;a href=&quot;http://bower.io&quot;&gt;bower&lt;/a&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79662f72fb448baebdf8a6c7d0131a375dff4095" translate="yes" xml:space="preserve">
          <source>You might have to use a deferred object when wrapping a callback API that doesn't follow the standard convention. Like &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ac050d03d9c2bd58543cfcee398d79f07ec7bc" translate="yes" xml:space="preserve">
          <source>You might notice that the promise approach looks very similar to using synchronous I/O:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07914b7b08162442f33327417b0ff4a50f4409e" translate="yes" xml:space="preserve">
          <source>You passed a non-function where a function was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc81677e43359861a52ce63568e3d792c6bcee22" translate="yes" xml:space="preserve">
          <source>You should check if this promise is &lt;a href=&quot;isfulfilled&quot;&gt;&lt;code&gt;.isFulfilled()&lt;/code&gt;&lt;/a&gt; in code paths where it's not guaranteed that this promise is fulfilled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88143ae7a4624ccb7145716c9f902897a88d096d" translate="yes" xml:space="preserve">
          <source>You should check if this promise is &lt;a href=&quot;isrejected&quot;&gt;&lt;code&gt;.isRejected()&lt;/code&gt;&lt;/a&gt; in code paths where it's guaranteed that this promise is rejected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5bc1b292604f8a755bedb0d6bdc5baa78c79e97" translate="yes" xml:space="preserve">
          <source>You should enabled long stack traces if you want better debugging experience. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9389a4bd5323ad51b671d2380af345d329495a0f" translate="yes" xml:space="preserve">
          <source>You should heed this warning because rejecting a promise with a non-error makes debugging extremely hard and costly. Additionally, if you reject with simple primitives such as &lt;code&gt;undefined&lt;/code&gt; (commonly caused by simply calling &lt;code&gt;reject()&lt;/code&gt;) you cannot handle errors at all because it's impossible to tell from &lt;code&gt;undefined&lt;/code&gt; what exactly went wrong. All you can tell the user is that &quot;something went wrong&quot; and lose them forever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7d769e258faced0824e928a0c2037e1a245676" translate="yes" xml:space="preserve">
          <source>You should use promises to turn this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3801444ae548127f53972d4de9db926d35147429" translate="yes" xml:space="preserve">
          <source>Your library can then use &lt;code&gt;var Promise = require(&quot;bluebird-extended&quot;);&lt;/code&gt; and do whatever it wants with it. Then if the application or other library uses their own bluebird promises they will all play well together because of Promises/A+ thenable assimilation magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea5d7794d32ab52b93c85c9e6c21b1aea324d24" translate="yes" xml:space="preserve">
          <source>because &lt;code&gt;data&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; at the time &lt;code&gt;.return&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c304689dc11138fde5d03ea645ecb41953e1334" translate="yes" xml:space="preserve">
          <source>bugfix</source>
          <target state="translated">bugfix</target>
        </trans-unit>
        <trans-unit id="321ef65dd8e0fe725eb1aefadf1bd87479757769" translate="yes" xml:space="preserve">
          <source>composes with other bluebird features, like &lt;a href=&quot;promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7615dce52c4c05ce4e1d374e9c61a13717ac7c" translate="yes" xml:space="preserve">
          <source>feature</source>
          <target state="translated">feature</target>
        </trans-unit>
        <trans-unit id="03e02ad7e48448605c30956ca4071a16aaf4bf8b" translate="yes" xml:space="preserve">
          <source>in the case where &lt;code&gt;value&lt;/code&gt; doesn't change its value because its binding time is different than when using a closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb19623519a22b9149620557f13925f7b42fd29" translate="yes" xml:space="preserve">
          <source>new Promise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afbedb8dbf47bdab5c49c2b9d92015b7b3581a43" translate="yes" xml:space="preserve">
          <source>new Promise()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558916e0aef77e0a7a2bbe15ca31648114109299" translate="yes" xml:space="preserve">
          <source>no setup code required to make cancellation work</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4397a4d17f5c537ce4e705bcaf7b0efdd50c51d6" translate="yes" xml:space="preserve">
          <source>reasonable semantics for multiple consumer cancellation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748bc7560ff57854e11d5ab937864f0ff100bb12" translate="yes" xml:space="preserve">
          <source>resolving it with itself tells it &quot;it is done when it is done&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9379d4b4f4ef9775cb3c71402acd9e3e7970ea7f" translate="yes" xml:space="preserve">
          <source>throw TypeError when thenable resolves with itself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44176cf9434e38d37133324ac3fb90ae6fc35afd" translate="yes" xml:space="preserve">
          <source>~~Promise.longStackTraces~~</source>
          <target state="translated">~~Promise.longStackTraces~~</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
