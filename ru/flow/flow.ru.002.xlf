<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="flow">
    <body>
      <group id="flow">
        <trans-unit id="c35c47e5290b31d5376f35f006e7cd6e182798e4" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to indicate that Flow should interpret object types as exact by default. When this flag is &lt;code&gt;false&lt;/code&gt;, Flow has the following behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b6026d788e6990fc2b88f5d97a8a7e72d548d84" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;warn&lt;/code&gt; to indicate that Flow should give a warning on use of instance &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;class fields&lt;/a&gt; per the pending spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a95e4b769085b845d2cd025dba547c259b83a10" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;warn&lt;/code&gt; to indicate that Flow should give a warning on use of static &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;class fields&lt;/a&gt; per the pending spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3723576f1e23f9a6be80dfc2da353444ecba4fa5" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;lazy_mode&lt;/code&gt; in the &lt;code&gt;.flowconfig&lt;/code&gt; will cause new Flow servers for that root to use that lazy mode (or no lazy mode if set to &lt;code&gt;none&lt;/code&gt;). This option can be overridden from the CLI using the &lt;code&gt;--lazy-mode&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8742e5ede9ca0ab99281256cb0a8da2b2abf5c7" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;sketchy-null&lt;/code&gt; sets the level for all sketchy null checks, but there are more granular rules for particular types. These are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbac04babde4f94fd1324574fc30f6647291c38" translate="yes" xml:space="preserve">
          <source>Setting this option to X means the table will support up to 2^X elements, which is 16*2^X bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8b6166467119123c34cb8d2a8307f8f72ae96e" translate="yes" xml:space="preserve">
          <source>Setting this to 1 will cause Flow to output some stats about the data that is serialized into and deserialized out of shared memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3907024420fe6565a297982966b2459dd6dc6639" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;true&lt;/code&gt; makes Flow commands include warnings in the error output. Warnings are hidden by default in the CLI to avoid console spew. (An IDE is a much better interface to show warnings.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78591e430fc75d428e63794ccb099ae8c20961b" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;true&lt;/code&gt; makes Flow treat all function parameters as const bindings. Reassigning a param is an error which lets Flow be less conservative with refinements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2da3d4ed1af623cc4e8b8d52d8edb981c85d346" translate="yes" xml:space="preserve">
          <source>Setting up &amp;ldquo;boundaries&amp;rdquo; with your types means you can tell Flow your intent on top of the inference it already does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="7133d91a35c40bcb71979c3896fc1deb038a8a20" translate="yes" xml:space="preserve">
          <source>Setup Flow with React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7330bdb6aab9d47b6f4302ca23a0b1d1a997ea7d" translate="yes" xml:space="preserve">
          <source>Severity Levels and Meanings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef912b88879662392f8c53fad059d3c74586282" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#toc-react-componenttype&quot;&gt;&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt;&lt;/a&gt; except it also includes JSX intrinsics (strings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9df7675219090b45a68675090f8c88c2996d47" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../utilities#toc-readonly&quot;&gt;&lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, it is the supertype of all arrays and all tuples and represents a read-only view of an array. It does not contain any methods that will allow an object of this type to be mutated (no &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e25832c7fbfc04c711346a40af98680a99ba4e4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../variables#toc-reassigning-variables&quot;&gt;&lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; variables&lt;/a&gt; if you reassign a property of an unsealed object, by default Flow will give it the type of all possible assignments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccc6ec56ed0f7579fe7c1219285baf1e414f25d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;const&lt;/code&gt;, Flow can either infer the type from the value you are assigning to it or you can provide it with a type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cdc6274e2048217641f19c7436522e7c83902e" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;mixed&lt;/code&gt;, generics have an &amp;ldquo;unknown&amp;rdquo; type. You&amp;rsquo;re not allowed to use a generic as if it were a specific type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f53a1bfd2499be63c34f7067d2986e44abdec95" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; can be re-assigned, there&amp;rsquo;s a few more rules you&amp;rsquo;ll need to know about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="339082925233909f355d06179fa3b6b26ccf7865" translate="yes" xml:space="preserve">
          <source>Since Flow does not know the length of an array, an &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; type cannot be passed into a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decf7e18c6fe06fc86a8a5bc89a669829d507c85" translate="yes" xml:space="preserve">
          <source>Since a &lt;code&gt;const&lt;/code&gt; variable cannot be re-assigned at a later time it is fairly simple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c614b00ece097ea225988eb96c38c1dc27bdcf2" translate="yes" xml:space="preserve">
          <source>Since the parameter &lt;code&gt;arr&lt;/code&gt; of the &lt;code&gt;someOperation&lt;/code&gt; function is typed as a mutable &lt;code&gt;Array&lt;/code&gt;, pushing a string into it would be possible inside that scope, which would then break the type contract of the outside &lt;code&gt;array&lt;/code&gt; variable. By annotating the parameter as &lt;code&gt;$ReadOnlyArray&lt;/code&gt; instead in this case, Flow can be sure this won&amp;rsquo;t happen and no errors will occur:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1785a5e0b243285a1963526da42f273c5dc42f7" translate="yes" xml:space="preserve">
          <source>So a single array child is left alone, but what happens if we have multiple children that are arrays?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70bd7a3ca7dbd388181ff69fc1a9d9059244ca3" translate="yes" xml:space="preserve">
          <source>So far, we support the following ways to specify supported versions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c91e3d58f11315a8f98d01485d70281a6c3678" translate="yes" xml:space="preserve">
          <source>So if Flow sees this in the &lt;code&gt;.flowconfig&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb921ba09ace5711e414821fe52adee56f0c3ff" translate="yes" xml:space="preserve">
          <source>So if I write a function that expects the numbers 1 through 5, any subtype of that set will be acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8b161db695089b318d824534a1f60ea4c81045" translate="yes" xml:space="preserve">
          <source>So if you have the following in your &lt;code&gt;.flowconfig&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f50aa3f8aa1b205c54f2530dfd25375a26cc15" translate="yes" xml:space="preserve">
          <source>So in the following example, &lt;code&gt;obj2&lt;/code&gt; is a &lt;em&gt;subtype&lt;/em&gt; of &lt;code&gt;obj1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd21dd92e8bb38520c7aed585ce5c138a49e1e9e" translate="yes" xml:space="preserve">
          <source>So, for example, if you want to know more about how the autocomplete works, you can use this command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5040bb6c58acac2d87c681ffa0099ee5ad8294" translate="yes" xml:space="preserve">
          <source>Sometimes Flow is able to figure out (with certainty) the type of a property after reassignment. In that case, Flow will give it the known type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cbd2e30f0fd2935872139edbe248c42b74f633b" translate="yes" xml:space="preserve">
          <source>Sometimes Flow is able to figure out (with certainty) the type of a variable after re-assignment. In that case, Flow will give it the known type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="190aedcaebf30683452cc18021384bd29eb893ec" translate="yes" xml:space="preserve">
          <source>Sometimes Flow&amp;rsquo;s inference will create types that are more permissive than you want them to be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2bc69b7d682ca6d088a661a2cccdb41226e95b" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to assert a type without using something like a function or a variable to do so. For this Flow supports an inline type cast expression syntax which can be used in a number of different ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05acde073f433e3ebdb05840c280af6194f4f161" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to create a type which is &lt;strong&gt;&lt;em&gt;all of&lt;/em&gt;&lt;/strong&gt; a set of other types. For example, you might want to write a function which accepts an object which is the combination of other object types. For this, Flow supports &lt;strong&gt;intersection types&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="508d0f1b6949c54ce48ed8515843765f74b1ff2c" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to disable this behavior and only allow a specific set of properties. For this, Flow supports &amp;ldquo;exact&amp;rdquo; object types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e197db0c5e7c34ea4bc888687f7a0d82f7f2217" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to make declarations inline, as part of the source of an implementation file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7f2e42ec427dfe19e7546bbfa4cb1df144aec0" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to write types that accept arbitrary functions, for those you should write &lt;code&gt;() =&amp;gt; mixed&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d699df94c70d270a74922c6dd7a75522ca1022c" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to write types that accept arbitrary objects, for those you should write &lt;code&gt;{}&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c4be69fd7d7e116bfe9fff8287e72150b14b65" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful to create a type which is &lt;strong&gt;&lt;em&gt;one of&lt;/em&gt;&lt;/strong&gt; a set of other types. For example, you might want to write a function which accepts a set of primitive value types. For this Flow supports &lt;strong&gt;union types&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079287524f7de17d8166e352d620ee09cbcee756" translate="yes" xml:space="preserve">
          <source>Sometimes you only want a specific component as the children to your React component. This often happens when you are building a table component which needs specific column children components, or a tab bar which needs specific configuration for each tab. One such tab bar component that uses this pattern is React Native&amp;rsquo;s &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca3345128fc09227a3fc76aff4497f80cecc7db" translate="yes" xml:space="preserve">
          <source>Sometimes you want to enforce that your component will &lt;em&gt;only&lt;/em&gt; receive a single child. You could use &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt;&lt;code&gt;React.Children.only()&lt;/code&gt; function&lt;/a&gt; to enforce this constraint, but you could also enforce this in Flow. To do this you would not wrap the type for your children in &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0204e6779dafad940b69a188f3ba177a640b8f57" translate="yes" xml:space="preserve">
          <source>Sometimes you will want to move the condition from an &lt;code&gt;if&lt;/code&gt; statement into a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54a11047f43ee69df389e7749159027d890696d" translate="yes" xml:space="preserve">
          <source>Soundness and Completeness</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746df4e9e7a562d767f5e24a05664f4a720c7f81" translate="yes" xml:space="preserve">
          <source>Soundness is fine as long as Flow isn&amp;rsquo;t being too noisy and preventing you from being productive. Sometimes when soundness would get in your way too much, Flow will favor completeness instead. There&amp;rsquo;s only a handful of cases where Flow does this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0490059ec84f1bbf6b567a4e9c26b3a680460a91" translate="yes" xml:space="preserve">
          <source>Specify a file extension to match, and a replacement module name, separated by a &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23f789b3f6c7eff8cfdc73ee793e9e6cd434ab2" translate="yes" xml:space="preserve">
          <source>Specify a regular expression to match against module names, and a replacement pattern, separated by a &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="3b2886d5473db8f2728b89b52d94f9b866760285" translate="yes" xml:space="preserve">
          <source>Start the &lt;a href=&quot;#toc-run-the-flow-background-process&quot;&gt;Flow background process&lt;/a&gt; with &lt;code&gt;flow&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33040dda5793f74572e67f14abdfb073ecb04f28" translate="yes" xml:space="preserve">
          <source>Starting with Flow v0.23.0, you may use the &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; placeholder in your regular expressions. At runtime, Flow will treat the placeholder as if it were the absolute path to the project&amp;rsquo;s root directory. This is useful for writing regular expressions that are relative rather than absolute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="62b1fce124c3fa807ff7f42885010e1fc39fe39d" translate="yes" xml:space="preserve">
          <source>Stateless Functional Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab6b0ce50387fe5c38a665805e317164318c6cd" translate="yes" xml:space="preserve">
          <source>Strict Local</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984e1a2ea44698c9bc621d3cc2a46a2ebbfcffdb" translate="yes" xml:space="preserve">
          <source>Strictly enforced tuple length (arity)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="b5c84f808b85754e46cef96360cc97ceca30a211" translate="yes" xml:space="preserve">
          <source>Strings are &lt;code&gt;&quot;foo&quot;&lt;/code&gt; values in JavaScript. The &lt;code&gt;string&lt;/code&gt; type in Flow accepts these values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371de9693f4209b3d6baabc8cf5aa9bd9123f714" translate="yes" xml:space="preserve">
          <source>Strings: like &lt;code&gt;&quot;foo&quot;&lt;/code&gt; or &lt;code&gt;&quot;bar&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad0aefa729b2e3f757e7d3a4090cd9f7990d889" translate="yes" xml:space="preserve">
          <source>Structural typing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14ac23dd85e9a8386862e11638c030009ce4084" translate="yes" xml:space="preserve">
          <source>SublimeLinter-flow</source>
          <target state="translated">SublimeLinter-flow</target>
        </trans-unit>
        <trans-unit id="3f018ae5c81afd7ff03157c258e75546aee33dc2" translate="yes" xml:space="preserve">
          <source>Subsets &amp;amp; Subtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cdd77a39c406add3dd649d12b90f08405e31a63" translate="yes" xml:space="preserve">
          <source>Subtypes of complex types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d06116efdf07868027a1561d8d0339ecc6e6c45" translate="yes" xml:space="preserve">
          <source>Subtypes of functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476bb4d588f74c233bb6c1ee03fd986be62e7cea" translate="yes" xml:space="preserve">
          <source>Subtypes of objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be5fa8c6c74f697319a9589425f3a2612939e3d" translate="yes" xml:space="preserve">
          <source>Subtyping Constraints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17dd2152e8dc1f949523edeb4f3e8b48630834f" translate="yes" xml:space="preserve">
          <source>Subtyping rules for functions are more complicated. So far, we&amp;rsquo;ve seen that &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;code&gt;B&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt; contains all possible values for &lt;code&gt;A&lt;/code&gt;. For functions, it&amp;rsquo;s not clear how this relationship would apply. To simplify things, you can think of a function type &lt;code&gt;A&lt;/code&gt; as being a subtype of a function type &lt;code&gt;B&lt;/code&gt; if functions of type &lt;code&gt;A&lt;/code&gt; can be used wherever a function of type &lt;code&gt;B&lt;/code&gt; is expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78102c720eccd1810b8e560681ce6685d79fff31" translate="yes" xml:space="preserve">
          <source>Suports vim 8 and neovim</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea46343abafb30794aea626700e565b309f371e" translate="yes" xml:space="preserve">
          <source>Supplying Type Arguments to Callables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4426aae8665ecf03f0c5957ef62701c977ed33b" translate="yes" xml:space="preserve">
          <source>Suppose for example that you want to associate a value to each suit of the previous example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4045032ea32b290b2df4209d32c0f98371142465" translate="yes" xml:space="preserve">
          <source>Suppressing one type of sketchy null check only suppresses that type, so, for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="5388b4e54e46d7ce88e2e324bb0464dd484b2048" translate="yes" xml:space="preserve">
          <source>Symbols (new in ECMAScript 2015)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6410af0c2d3799d510fea0f3019deaa0a7626b1" translate="yes" xml:space="preserve">
          <source>Symbols are created with &lt;code&gt;Symbol()&lt;/code&gt; in JavaScript. Flow has basic support for symbols, using the &lt;code&gt;symbol&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6251b774c7c6606be961a6810aa903791863a16" translate="yes" xml:space="preserve">
          <source>Syntax of functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f70f0698cfc1eb1310e93dc39ca20595f7e95e" translate="yes" xml:space="preserve">
          <source>Syntax of generics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae14ee1fff7b2a05299ec56ecdba3f6a62d2c5f" translate="yes" xml:space="preserve">
          <source>Table of contents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b04edd80b66ddca98050f09adbdab0598b38a9" translate="yes" xml:space="preserve">
          <source>Take note of the &lt;code&gt;typeof&lt;/code&gt;, it is required! &lt;code&gt;Foo&lt;/code&gt; without &lt;code&gt;typeof&lt;/code&gt; would be the type of an instance of &lt;code&gt;Foo&lt;/code&gt;. So: &lt;code&gt;(new Foo(): Foo)&lt;/code&gt;. We want the type &lt;em&gt;of&lt;/em&gt;&lt;code&gt;Foo&lt;/code&gt; not the type of an instance of &lt;code&gt;Foo&lt;/code&gt;. So: &lt;code&gt;(Foo: typeof Foo)&lt;/code&gt;. &lt;code&gt;Class&amp;lt;Foo&amp;gt;&lt;/code&gt; would also work here, but we prefer &lt;code&gt;typeof&lt;/code&gt; for consistency with stateless functional components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143158f8e0d23bcab4c6519c800370955610ba03" translate="yes" xml:space="preserve">
          <source>Tell Flow which directory to use as a temp directory. Can be overridden with the command line flag &lt;code&gt;--temp-dir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5ea6782ec2acdb66109615aa3170a3b9e5c7b0" translate="yes" xml:space="preserve">
          <source>The 3 largest parts of the shared memory are a dependency table, a hash table, and a heap. While the heap grows and shrinks, the two tables are allocated in full. This option lets you change the size of the hash table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0934dcae4f0cd7ddb495aeab8057d00242e3e126" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.flowconfig&lt;/code&gt; consists of 7 sections:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e7419e93c6bb39d11632417b0da8c56509fd33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.flowconfig&lt;/code&gt; uses a custom format that vaguely resembles INI files. We are not proud of our custom format and plan to support a better format in the future. &lt;a href=&quot;https://github.com/facebook/flow/issues/153&quot;&gt;GitHub issue #153&lt;/a&gt; tracks this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa5025da02d927676c9cd482376361a167bd517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; in &lt;code&gt;?HTMLButtonElement&lt;/code&gt; is important. In the example above the first argument to &lt;code&gt;ref&lt;/code&gt; will be &lt;code&gt;HTMLButtonElement | null&lt;/code&gt; as React will &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;call your &lt;code&gt;ref&lt;/code&gt; callback with null&lt;/a&gt; when the component unmounts. Also, the &lt;code&gt;button&lt;/code&gt; property on &lt;code&gt;MyComponent&lt;/code&gt; will not be set until React has finished rendering. Until then your &lt;code&gt;button&lt;/code&gt; ref will be undefined. Protect yourself against these cases and use a &lt;code&gt;?&lt;/code&gt; (like in &lt;code&gt;?HTMLButtonElement&lt;/code&gt;) to protect yourself from bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719a6a4c0e07c1dc9a47466bbab725e9662338ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types that React provides and the DOM events they are related to are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653be0e1cd193d42d4fa78964cd56de69b5da2cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[declarations]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to parse files matching the specified regular expressions in &lt;em&gt;declaration mode&lt;/em&gt;. In declaration mode the code is not typechecked. However, the signatures of functions, classes, etc are extracted and used by the typechecker when checking other code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df21474ae6954ba751628a9d46d6c9512fa40f07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[ignore]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to ignore files matching the specified regular expressions when type checking your code. By default, nothing is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a1fffc651c11cf6e66838e0172e44593fd9d49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[include]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to include the specified files or directories. Including a directory recursively includes all the files under that directory. Symlinks are followed as long as they lead to a file or directory that is also included. Each line in the include section is a path to include. These paths can be relative to the root directory or absolute, and support both single and double star wildcards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33fef6875ad046a3f7a76b86437d56196d9c414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[libs]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to include the specified &lt;a href=&quot;https://flow.org/en/libdefs/&quot;&gt;library definitions&lt;/a&gt; when type checking your code. Multiple libraries can be specified. By default, the &lt;code&gt;flow-typed&lt;/code&gt; folder in your project root directory is included as a library directory. This default allows you to use &lt;a href=&quot;https://github.com/flowtype/flow-typed&quot;&gt;&lt;code&gt;flow-typed&lt;/code&gt;&lt;/a&gt; to install library definitions without additional configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93975a8a26491b29c7786a7d20f47e387cfa3514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[lints]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file can contain several key-value pairs of the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263df81c3f42c9c4c0096bb79a58e2dee22d2326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[options]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file can contain several key-value pairs of the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ba04249ba83fffa732ce0d0760f8ad3472a183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[untyped]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to not typecheck files matching the specified regular expressions and instead throw away types and treat modules as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924f7192ca7f7c407e938ed0acd12668b4d33fbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; operator returns the Flow type of a given value to be used as a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67966e36f904c5d8958d761e6cb9127537aff7ef" translate="yes" xml:space="preserve">
          <source>The Asynchronous Lint Engine (ALE) plugin for Vim 8+ and NeoVim, &lt;a href=&quot;https://github.com/w0rp/ale&quot;&gt;vim-ale&lt;/a&gt;, is a generalized linting engine with support for Flow and many other tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5183c3b41bf0492de80698dc738a05d76568f6ad" translate="yes" xml:space="preserve">
          <source>The CLI tool also provides several other options and commands that allow you to control the server and build tools that integrate with Flow. For example, this is how the &lt;a href=&quot;https://nuclide.io/&quot;&gt;Nuclide&lt;/a&gt; editor integrates with Flow to provide autocompletion, type errors, etc. in its UI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b12391516f21ae19dfcef64eb8647ae6924887e" translate="yes" xml:space="preserve">
          <source>The Flow background process monitors all Flow files. However, how does it know which files are Flow files and, thus, should be checked? Placing the following &lt;strong&gt;before any code&lt;/strong&gt; in a JavaScript file is the flag the process uses to answer that question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea8fcfb745f317d30dab0afe405550d9490a0f7" translate="yes" xml:space="preserve">
          <source>The Flow root must be within a &lt;a href=&quot;https://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt; repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9d9e2a123153d996537b64730290848876d71f" translate="yes" xml:space="preserve">
          <source>The IDE needs to integrate with &lt;code&gt;flow lsp&lt;/code&gt; to tell Flow which files are open.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36e3ea40dbe1430b59533dc1b80fc6036bba9ee" translate="yes" xml:space="preserve">
          <source>The JavaScript language is a bunch of object-oriented ideas and functional ideas mixed together. Developer&amp;rsquo;s usage of JavaScript tends to be mixed as well. Classes (or constructor functions) being the more object-oriented side and functions (as lambdas) and objects tend to be more on the functional side, developers use both simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd394e3f7c77eaabbe75ef337cf434e120de82b" translate="yes" xml:space="preserve">
          <source>The Trivial HOC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025b59ea409d457aec020e335d2f4bc894d68ede" translate="yes" xml:space="preserve">
          <source>The ability for a static type checker to be able to tell that the value inside the if statement must be &lt;code&gt;&quot;A&quot;&lt;/code&gt; is known as a refinement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec021ecaeba3a8ee38ad356d77c56a0bb6f13a4" translate="yes" xml:space="preserve">
          <source>The above code has a type error because Flow would also allow the call expression &lt;code&gt;method({ foo: 1, bar: 2 })&lt;/code&gt;, because &lt;code&gt;{foo:number,bar:number}&lt;/code&gt; is a subtype of &lt;code&gt;{bar:number}&lt;/code&gt;, one of the members of the parameter&amp;rsquo;s union type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2ac4fdbea23fe269b2df48740a8fe5b6447c33" translate="yes" xml:space="preserve">
          <source>The advantage of the &lt;code&gt;$Exports&lt;/code&gt; syntax is that you can &lt;code&gt;export&lt;/code&gt; the type on the same line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba2348e4056127995e90c22bf6c18e156a3d1c5" translate="yes" xml:space="preserve">
          <source>The base type for Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html&quot;&gt;actions&lt;/a&gt; is an object with a &lt;code&gt;type&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af3b40968bb4f75f70768133b814cdf17d5d2ec" translate="yes" xml:space="preserve">
          <source>The basic &lt;code&gt;flowlint&lt;/code&gt; comment takes a comma-delimited list of &lt;code&gt;rule:severity&lt;/code&gt; pairs and applies those settings for the rest of the source file until overridden. This has three primary purposes: applying settings over a block, applying settings over a file, and applying settings over part of a line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f167409d5ec197b4871f95c5db2fcf7f6bbd5cd2" translate="yes" xml:space="preserve">
          <source>The body of these predicate functions need to be expressions (i.e. local variable declarations are not supported). But it&amp;rsquo;s possible to call other predicate functions inside a predicate function. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="182510f68d230df9a3e633ed8ee2db47f5bc405d" translate="yes" xml:space="preserve">
          <source>The core benefit to Flow is its ability to quickly check your code for errors. Once you have enabled your project for Flow, you can start the process that allows Flow to check your code incrementally and with great speed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7197940d208092be8c8d13b858faffa50044428" translate="yes" xml:space="preserve">
          <source>The decision of which direction to apply the subtyping rule on inputs and outputs is governed by variance, which is the topic of the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff505957015ad603cc74c9be6c56afdb90f26dc" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684bf3ea595241d58aa0cbec92715b88590f0f96" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc51d57d4a016ea1192824513bdb37f918f5d3a" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;babel_loose_array_spread&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3320966c1ed05d8e92be8263eb0872986cd5b9d" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;emoji&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b4c401e7d77aa94ed0f3d78556a2ab12605661" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;/tmp/flow&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1dcc6b3a394539acf783a764b41f856bcb2ec9" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a6f3086f6053ea99056f8787ec9e3c7714223a" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385f9197e267dca024cc7c5ee266ab77c07dd86b" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;max_header_tokens&lt;/code&gt; is 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4afe27211cbc9af6d345271f3bd53dcd4c074b64" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;enable&lt;/code&gt;, which allows use of this proposed syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a26010ceb723197e0f6ed4ccf098b594327ee9" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;warn&lt;/code&gt;, which gives a warning on use since this proposal is still very early-stage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4804a2b774fe8e16ad5ee7fbc61053dc05f70f20" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3087bc731ef3517a427cf5c4e5203623cadca99" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.ElementType&lt;/code&gt; is roughly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e617c1ee84ca2ef49a14a0c500b7bf9f6b27172" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c72eeedacf538eae7405dbd87fe7965700eed1" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67931b95c973afece9e67ea2abaeb942c4811eaf" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;React.Node&lt;/code&gt; can be roughly approximated with a &lt;a href=&quot;#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65be16845f607fa6de2868121655dbf19d303167" translate="yes" xml:space="preserve">
          <source>The design decision in Flow around mixing nominal and structural typing was chosen based on how objects, functions, and classes are already used in JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d2d625710fa5cd0abd9e50046510b51fb847f2" translate="yes" xml:space="preserve">
          <source>The example above could not be accomplished without the &lt;code&gt;+&lt;/code&gt; variance sigil:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569e13c9d22dc97266745256891834efe9cb254b" translate="yes" xml:space="preserve">
          <source>The first time this is run, the &lt;a href=&quot;#toc-run-flow-background-process&quot;&gt;Flow background process&lt;/a&gt; will be spawned and all of your Flow files will be checked. Then, as you continue to iterate on your project, the background process will continuously monitor your code such that when you run &lt;code&gt;flow&lt;/code&gt; again, the updated result will be near instantaneous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48e199f3e1c2873fac5e329e515e0affa5734d6" translate="yes" xml:space="preserve">
          <source>The fix here is to add types to the parameters of &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decaa6f4bcdc1dd98facfb522a07ee0290e90e6a" translate="yes" xml:space="preserve">
          <source>The flow command line tool is made to be easy-to-use for simple cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568d41ac14b4b2796ccd853ff99f7c7a730490f8" translate="yes" xml:space="preserve">
          <source>The following are functionally equivalent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e5012640308970d1812cdfc15f495ee3f6ea82" translate="yes" xml:space="preserve">
          <source>The function argument allows &lt;code&gt;string&lt;/code&gt; values in its field, but in this case Flow prevents the original object from having a &lt;code&gt;number&lt;/code&gt; written to it. Within the body of the function you would be able to mutate the object so that the property &lt;code&gt;a&lt;/code&gt; would receive a &lt;code&gt;number&lt;/code&gt;, causing the type of the original object to no longer be accurate. You can fix this error by making the property covariant (read-only): &lt;code&gt;{+a:string|&amp;nbsp;number}&lt;/code&gt;. This prevents the function body from writing to the property, making it safe to pass more restricted types to the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2155dfc51f926d913a644cc3de06c804ab01b2ad" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s argument allows &lt;code&gt;string&lt;/code&gt; values in its array, but in this case Flow prevents the original array from receiving a &lt;code&gt;number&lt;/code&gt;. Inside the function, you would be able to push a &lt;code&gt;number&lt;/code&gt; to the argument array, causing the type of the original array to no longer be accurate. You can fix this error by changing the type of the argument to &lt;code&gt;$ReadOnlyArray&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;. This prevents the function body from pushing anything to the array, allowing it to accept narrower types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f89c1777909f20b429c72e0ff7ec4f5852765d" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s purpose is to run all the thunks and return an object made of values. What&amp;rsquo;s the return type of this function?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c023f83d766bac37fd8c93749ac0588a01c18d3d" translate="yes" xml:space="preserve">
          <source>The great thing about Flow is that you can get near real-time feedback on the state of your code. At any point that you want to check for errors, just run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3a896ebf3c8fbb9102531fb367809a43a70216" translate="yes" xml:space="preserve">
          <source>The idea of using types to manage code evolution and growth in JavaScript (and related languages) is not new. In fact, several useful type systems have been built for JavaScript in recent years. However, type systems differ in their goals. On one end of the spectrum are permissive type systems that provide some degree of linting against likely errors, without regard for correctness. On the other end of the spectrum are restrictive type systems that can guarantee the correctness of static code optimizations, at the cost of interoperability. Another area that has not seen a lot of focus is the performance of type checking itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895222166e3067cff8bd88b8a774d6ab00fde9e2" translate="yes" xml:space="preserve">
          <source>The inferred type of the property becomes what you set it to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e551fea41cfe91f78e0d3bfde3174c0c4fa76ec7" translate="yes" xml:space="preserve">
          <source>The key to Flow&amp;rsquo;s speed is modularity: the ability to break the analysis into file-sized chunks that can be assembled later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6ba2b0cdf8e98a8b5dce1cdbd0afc335063144" translate="yes" xml:space="preserve">
          <source>The keys are the same, but the values have a different type, namely the return type of each function. At a value level (the implementation of the function) we&amp;rsquo;re essentially mapping over the object to produce new values for the keys. How to express this at a type level?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ccbfce1a4e920f5d1758fbdebfc31032b257d4" translate="yes" xml:space="preserve">
          <source>The length of the tuple is known as the &amp;ldquo;arity&amp;rdquo;. The length of a tuple is strictly enforced in Flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647cfb5d0aaa8b82192bbb83417ad5b3177c198f" translate="yes" xml:space="preserve">
          <source>The lint settings parser is fairly intelligent and will stop you if you write a redundant rule, a rule that gets completely overwritten, or an unused suppression. This should prevent most accidental misconfigurations of lint rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02d9fd7d48002b88a676cb504a249985d85238a" translate="yes" xml:space="preserve">
          <source>The location of the &lt;code&gt;.flowconfig&lt;/code&gt; is significant. Flow treats the directory that contains the &lt;code&gt;.flowconfig&lt;/code&gt; as the &lt;em&gt;project root&lt;/em&gt;. By default Flow includes all the source code under the project root. The paths in the &lt;a href=&quot;include&quot;&gt;[include] section&lt;/a&gt; are relative to the project root. Some other configuration also lets you reference the project root via the macro &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b94dfde96af7809cecaa352baf181b5eb93f8e" translate="yes" xml:space="preserve">
          <source>The main advantage to using &lt;code&gt;$ReadOnlyArray&lt;/code&gt; instead of &lt;code&gt;Array&lt;/code&gt; is that &lt;code&gt;$ReadOnlyArray&lt;/code&gt;&amp;rsquo;s type parameter is &lt;em&gt;covariant&lt;/em&gt; while &lt;code&gt;Array&lt;/code&gt;&amp;rsquo;s type parameter is &lt;em&gt;invariant&lt;/em&gt;. That means that &lt;code&gt;$ReadOnlyArray&amp;lt;number&amp;gt;&lt;/code&gt; is a subtype of &lt;code&gt;$ReadOnlyArray&amp;lt;number | string&amp;gt;&lt;/code&gt; while &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; is NOT a subtype of &lt;code&gt;Array&amp;lt;number | string&amp;gt;&lt;/code&gt;. So it&amp;rsquo;s often useful to use &lt;code&gt;$ReadOnlyArray&lt;/code&gt; in type annotations for arrays of various types of elements. Take, for instance, the following scenario:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641f626a5da92cffb82099b03123b4b7495ce303" translate="yes" xml:space="preserve">
          <source>The main difference with &lt;a href=&quot;#toc-diff&quot;&gt;&lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt;&lt;/a&gt;, is that &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; aims to represent the true runtime rest operation, which implies that exact object types are treated differently in &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt;. For example, &lt;code&gt;$Rest&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; will result in &lt;code&gt;{|n?:number|}&lt;/code&gt; because an in-exact empty object may have an &lt;code&gt;n&lt;/code&gt; property, while &lt;code&gt;$Diff&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; will result in &lt;code&gt;{|n:number|}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bbdc2ea29d0148a224653e3dc437fe724818563" translate="yes" xml:space="preserve">
          <source>The maximum number of workers the Flow server can start. By default, the server will use all available cores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2288b72b1f95feec127ed704e5e991f5ea4c03bb" translate="yes" xml:space="preserve">
          <source>The module system to use to resolve &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt;. &lt;a href=&quot;https://github.com/facebook/node-haste&quot;&gt;Haste&lt;/a&gt; is used in React Native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ccdab5f7410661918848aa1e2e6bf4bba7ef93d" translate="yes" xml:space="preserve">
          <source>The most common case you&amp;rsquo;ll encounter is when exporting a function or React component. Flow requires you to annotate inputs. For instance, in this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKOXQHwOgDUoAjANxA&quot;&gt;example&lt;/a&gt;, flow will complain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d256527f1fd7c67fd36002480923ad5cedc2e90" translate="yes" xml:space="preserve">
          <source>The name specified in quotes after &lt;code&gt;declare module&lt;/code&gt; can be any string, but it should correspond to the same string you&amp;rsquo;d use to &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; the third-party module into your project. For defining modules that are accessed via a relative &lt;code&gt;require&lt;/code&gt;/&lt;code&gt;import&lt;/code&gt; path, please see the docs on the &lt;a href=&quot;https://flow.org/en/declarations&quot;&gt;&lt;code&gt;.flow&lt;/code&gt; files&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee97a1aa5d0e2a829b605bdbaea327f2fcfbd4f" translate="yes" xml:space="preserve">
          <source>The path to the log file (defaults to &lt;code&gt;/tmp/flow/&amp;lt;escaped root path&amp;gt;.log&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6028aa8c33369bd6d14f531cdbe045d2ca494cce" translate="yes" xml:space="preserve">
          <source>The plus sign indicates that the &lt;code&gt;who&lt;/code&gt; property is &amp;ldquo;covariant.&amp;rdquo; Using a covariant property allows us to use objects which have subtype-compatible values for that property. By default, object properties are invariant, which allow both reads and writes, but are more restrictive in the values they accept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6e43a14a66d8e57ad3388723dad2315e2002cc" translate="yes" xml:space="preserve">
          <source>The primitive types appear in the language as either literal values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcdf34cda6e03181b88966618eea724fde6c716" translate="yes" xml:space="preserve">
          <source>The project root directory (where your &lt;code&gt;.flowconfig&lt;/code&gt; lives) is automatically included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28bebee27e53966722fe139f706cf86a64136098" translate="yes" xml:space="preserve">
          <source>The reason for this is that we don&amp;rsquo;t know that &lt;code&gt;otherMethod()&lt;/code&gt; hasn&amp;rsquo;t done something to our value. Imagine the following scenario:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdaec4a5e807c4478cc1b0eb9fd497d6c728c78" translate="yes" xml:space="preserve">
          <source>The ref function will take one and only argument which will be the element instance which is retrieved using &lt;a href=&quot;#toc-react-elementref&quot;&gt;&lt;code&gt;React.ElementRef&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt; or null since &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;React will pass null into a ref function when unmounting&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec9470d19e8edaa8b9faed31b8b1054cafb7447" translate="yes" xml:space="preserve">
          <source>The rule to remember with React children is that if you have no children then &lt;code&gt;props.children&lt;/code&gt; will not be set, if you have one single child then &lt;code&gt;props.children&lt;/code&gt; will be set to exactly that value, and if you have two or more children then &lt;code&gt;props.children&lt;/code&gt; will be a new array of those values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6cae9d717814c0ee942c2f77703ca8ec47aca7" translate="yes" xml:space="preserve">
          <source>The second is when the left-hand-side could be nullish, but the short-circuiting behavior of &lt;code&gt;?.&lt;/code&gt; is sufficient to handle it anyway:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5b733400ddf864761d4b603d7eedbf4fe23de9" translate="yes" xml:space="preserve">
          <source>The solution here is to move the if check in the &lt;code&gt;forEach&lt;/code&gt;, or to assign the &lt;code&gt;age&lt;/code&gt; to an intermediate variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793214c4162efec809460a089d3515988a580153" translate="yes" xml:space="preserve">
          <source>The syntax of the block matches the syntax of object types and has all of the same features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cfb3fe3a8ca2679172f7460529c617ce30b2448" translate="yes" xml:space="preserve">
          <source>The type for &lt;code&gt;children&lt;/code&gt; is a function that takes in some object type and returns a &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; which is the type for any value that can be rendered by React. A &lt;code&gt;children&lt;/code&gt; function does not need to return &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt;. It could return any type, but in this case &lt;code&gt;react-router&lt;/code&gt; wants to render the result returned by the &lt;code&gt;children&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26f0c3b68e62adaf93121b472c68d0c8f76d159" translate="yes" xml:space="preserve">
          <source>The type of the &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;ref prop on React elements&lt;/a&gt;. &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; could be a string or a ref function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4218f62d2ad5c72e63a98ec879dc92c04a46ac00" translate="yes" xml:space="preserve">
          <source>The type of the key prop on React elements. It is a union of strings and numbers defined as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3cd96ca03492da9df4ce4513f536c1b74f86f6" translate="yes" xml:space="preserve">
          <source>The type-specific variants are useful for specifying that some types of sketchy null checks are acceptable while others should be errors/warnings. For example, if you want to allow boolean sketchy null checks (for the pattern of treating undefined optional booleans as false) but forbid other types of sketchy null checks, you can do so with this &lt;code&gt;.flowconfig&lt;/code&gt;&lt;code&gt;[lints]&lt;/code&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e42194738022b79f11b671ad7ae0139eab4cfde" translate="yes" xml:space="preserve">
          <source>The value itself can also be an expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9386266d754633b2348817655aa4135672d2a80" translate="yes" xml:space="preserve">
          <source>The workaround here might be to turn your object into an &lt;em&gt;unsealed object&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba1aa455c617f9487799c55083af5aee022c88f" translate="yes" xml:space="preserve">
          <source>Then Flow will instead look for the file extensions &lt;code&gt;.foo&lt;/code&gt; and &lt;code&gt;.bar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16315533799a2def071bace787cce1d7a9a11029" translate="yes" xml:space="preserve">
          <source>Then Flow will look in directories named &lt;code&gt;node_modules&lt;/code&gt; or &lt;code&gt;custom_node_modules&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a695f40c07e9301bce62dd550ff93b6b48cf54b" translate="yes" xml:space="preserve">
          <source>Then add &lt;code&gt;flow&lt;/code&gt; to your Babel presets config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfbb8a4c24c2122ec36dde61b7e1b8b853e31ea" translate="yes" xml:space="preserve">
          <source>Then to type a thunk action creator, add a return type of a &lt;code&gt;ThunkAction&lt;/code&gt; to your action creator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d95f939b9b75dc6ef39e9b74bf9e89365c8618f" translate="yes" xml:space="preserve">
          <source>Then to type the action creator, just add a return type of the appropriate action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0d1639f463f57d4ca23faf1c9cada63360b1c0" translate="yes" xml:space="preserve">
          <source>Then when Flow checks the project in &lt;code&gt;/path/to/root&lt;/code&gt;, it will read and watch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4c41383342278b4baf1bc8936c93b77b60516b" translate="yes" xml:space="preserve">
          <source>There are a number of different places where generic types appear in syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416eb69d14d7c0984bf388d12cfb15f4c4cb73f0" translate="yes" xml:space="preserve">
          <source>There are also more specific synthetic event types like &lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types all take a single type argument. The type of the HTML element the event handler was placed on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1787b085e796793d008332b01f6a6da8bb5275b0" translate="yes" xml:space="preserve">
          <source>There are many different types in Flow, some of these types behave differently than others. These differences make sense for that particular type but not for others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf3db35b680beed72ddb758d9747774831b6fb79" translate="yes" xml:space="preserve">
          <source>There are only a couple of scenarios where you might consider using &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aaa00344637c45d30679cf3abd801a1db746b96" translate="yes" xml:space="preserve">
          <source>There are other cases where this happens, and they might be harder to understand. You&amp;rsquo;ll get an error like &lt;code&gt;Missing type annotation for U&lt;/code&gt; For instance, you wrote this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiDGsB2BnALqAhgE4F4CeoAvKANoDkeNANKDQEY0C6iApgB4AOsArjRZcAcy7ouBAJYoAgkVIV8SkgDoAtnj4AKPBQB8+AJRA&quot;&gt;code&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e04cbaf68e5bad49ef31cbab0ae229a010af35" translate="yes" xml:space="preserve">
          <source>There are some Babel plugins which will generate &lt;code&gt;PropTypes&lt;/code&gt; from Flow types such as &lt;a href=&quot;https://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types&quot;&gt;&lt;code&gt;babel-plugin-react-flow-props-to-prop-types&lt;/code&gt;&lt;/a&gt; if you want both static and runtime checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f1bf8a574169e2b0cbcee1bdb8f70d3d1115e5" translate="yes" xml:space="preserve">
          <source>There are three forms of functions that each have their own slightly different syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2987ad3c65445a4b5f525f040f6b2d00300b6c" translate="yes" xml:space="preserve">
          <source>There are two possible use cases, depending on whether an implementation file exists or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6225a3f37590ec533fb885e85a5169bfedf04f" translate="yes" xml:space="preserve">
          <source>There are two potential reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc65a65476288080ee29ba1be6fd72bb6d6711c0" translate="yes" xml:space="preserve">
          <source>There are two primary pieces of the syntax: type includes and type annotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd202d61a19f5fccfdf0c23e9bd5cbafd620669" translate="yes" xml:space="preserve">
          <source>There are two ways which Flow can use to tell which files the user cares about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5471e40283f41215cba92d35f5766a72606428" translate="yes" xml:space="preserve">
          <source>There is a little bit more to the definition of &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; for context and props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1108b33f08694a9173b9d3961f8db88797e3f6" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special type of union in Flow known as a &amp;ldquo;disjoint union&amp;rdquo; which can be used in &lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;refinements&lt;/a&gt;. These disjoint unions are made up of any number of object types which are each tagged by a single property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b519d9ef0909b18ff9e1aa56c6579a08789cbdf3" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a straightforward way to get around this. Store the value before calling another method and use the stored value instead. This way you can prevent the refinement from invalidating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5932b1e94eef91ff83b30936f3c0165f2887a0a9" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also a slightly shorter form of this syntax: &lt;code&gt;Type[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33c60a371f4bbf35c4a6734c388e9cc2e847eac" translate="yes" xml:space="preserve">
          <source>These are &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml regular expressions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1350e4fbb26ae0f7f95072f456f487f37767ce" translate="yes" xml:space="preserve">
          <source>These are &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml regular expressions&lt;/a&gt;. Use &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt; (slashes required!) to create a capturing group, which you can refer to in the replacement pattern as &lt;code&gt;\1&lt;/code&gt; (up to &lt;code&gt;\9&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973bfa9d37cd36bbc104342639ed6decfd34c64c" translate="yes" xml:space="preserve">
          <source>These comments allow Flow to work in plain JavaScript files without any additional work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93265fc7d47ba2359b8e8723579e2877162a149" translate="yes" xml:space="preserve">
          <source>These regular expressions match against absolute paths. They probably should start with &lt;code&gt;.*&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82167070fabc30781330eea12f26f96e5cc3459" translate="yes" xml:space="preserve">
          <source>These special files use the same &lt;code&gt;.js&lt;/code&gt; extension as normal JS code, but they are placed in a directory called &lt;code&gt;flow-typed&lt;/code&gt; in the root directory of your project. Placement in this directory tells Flow to interpret them as libdefs rather than normal JS files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420387e05d0ef5c191c2b528df67882573697852" translate="yes" xml:space="preserve">
          <source>These three are the most common categories of types. They will make up the majority of the types you&amp;rsquo;ll be writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521ca96243c563b5695a0817345b1aaac530fbea" translate="yes" xml:space="preserve">
          <source>These type aliases can be used anywhere a type can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c735f166579e7b6a2b1df8b0b57996603576f1" translate="yes" xml:space="preserve">
          <source>These types are all exported as named type exports from the &lt;code&gt;react&lt;/code&gt; module. If you want to access them as members on the &lt;code&gt;React&lt;/code&gt; object (e.g. &lt;a href=&quot;#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#toc-react-statelessfunctionalcomponent&quot;&gt;&lt;code&gt;React.StatelessFunctionalComponent&lt;/code&gt;&lt;/a&gt;) and you are importing React as an ES module then you should import &lt;code&gt;React&lt;/code&gt; as a namespace:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38dbce068fe67847b4312ef7a49844b1a3730edb" translate="yes" xml:space="preserve">
          <source>These unknown types are less common, but are still useful at times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630fbbe3db84f8cd1f22f033444bd46fd4f788d9" translate="yes" xml:space="preserve">
          <source>These values can be used in many different ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acee363f8ecdca8ebcbfe3c36617f3a858f460fa" translate="yes" xml:space="preserve">
          <source>These wrapper objects are rarely used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ecb01f38d4891f3ba605fe10abbc133a33eebcb" translate="yes" xml:space="preserve">
          <source>Things to keep in mind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25df2f7528015bf66ff8cb5856b46ca9f89a989e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[declarations]&lt;/code&gt; section will parse in declaration mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633b00a02de45953dce9e17ff82080b18f32ddce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[ignore]&lt;/code&gt; section will ignore:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881b9060a283396b0ef0fc92c8d4d847c624170a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[untyped]&lt;/code&gt; section will parse:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6523434d73a5cea939dbb47f88e915c46aa3c5df" translate="yes" xml:space="preserve">
          <source>This affects Linux only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543aa46e91339d316364681d2b7a939cdad920b8" translate="yes" xml:space="preserve">
          <source>This allows you to pass a less specific type in place of that property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1766dd7d0a89406504a02b5ace1d77e4b69c5963" translate="yes" xml:space="preserve">
          <source>This allows you to pass a more specific type in place of that property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd174f439abda4ebf248fb0e156219e91c6b759" translate="yes" xml:space="preserve">
          <source>This can be especially useful for referring to the type of React props, or, even the entire &lt;code&gt;props&lt;/code&gt; type itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5bf94cd27d17a08f16ee047fe0e258d2090c51" translate="yes" xml:space="preserve">
          <source>This case happens often when you use &lt;code&gt;array.map()&lt;/code&gt; such as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b87f03b6d241cb8b45f84bd4bf0506c5abe6b1" translate="yes" xml:space="preserve">
          <source>This command first starts a background process that will check all &lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;Flow files&lt;/a&gt; for errors. The background process continues running, monitoring changes to your code and checking those changes incrementally for errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d875274c3b689e4f7ad033af88961c28bd2f54a" translate="yes" xml:space="preserve">
          <source>This compiles to: &lt;code&gt;React.createElement(MyComponent, {}, '// some comment...', 42)&lt;/code&gt;. See how the comment is included in the element&amp;rsquo;s children? In this case &lt;code&gt;props.children&lt;/code&gt; would be &lt;code&gt;['// some comment...', 42]&lt;/code&gt; which includes the comment. To write comments in JSX use the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1981415185918a76b00cd452a5e0eb6fd87253c8" translate="yes" xml:space="preserve">
          <source>This compiles to: &lt;code&gt;React.createElement(MyComponent, {}, 42, '  ')&lt;/code&gt;. (With the spaces!) See how the spaces show up as part of the children? In this case &lt;code&gt;props.children&lt;/code&gt; would be &lt;code&gt;[42, '  ']&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt; the number 42. However, the following is fine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734dbfe930904c1dff5464c3868a3c58b214bbf9" translate="yes" xml:space="preserve">
          <source>This flag is in the form of a normal JavaScript comment annotated with &lt;code&gt;@flow&lt;/code&gt;. The Flow background process gathers all the files with this flag and uses the type information available from all of these files to ensure consistency and error free programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8107dcd86e50a45fb0aff78e434d3e405ffe634" translate="yes" xml:space="preserve">
          <source>This follows the same rule that when you pass in a single child then &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that value. Even though &lt;code&gt;[1, 2]&lt;/code&gt; is an array it is a single value and so &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that value. That is to say &lt;code&gt;props.children&lt;/code&gt; will be the array &lt;code&gt;[1, 2]&lt;/code&gt; and not an array of arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ef0baedb6b23a6e6c0bc9c81182d27e5e3dc1d" translate="yes" xml:space="preserve">
          <source>This guide will teach you the syntax and semantics of all the different types you can have in Flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096c3c9fc415cf70866aa9adcd243f084dfc276d" translate="yes" xml:space="preserve">
          <source>This includes the code into the syntax that Flow sees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fb28a17538a9106a3ad6a6bed152242ff6e4d8" translate="yes" xml:space="preserve">
          <source>This is Flow&amp;rsquo;s most abstract representation of a React component, and is most useful for writing HOCs and library definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af90c0ecae6766788f603b8275d9514e3979ca9" translate="yes" xml:space="preserve">
          <source>This is a basic template for what your HOCs might look like. At runtime, this HOC doesn&amp;rsquo;t do anything at all. Let&amp;rsquo;s take a look at some more complex examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c365f2918438c7a6e1888b46e0b930bd53745fff" translate="yes" xml:space="preserve">
          <source>This is a kind of subtyping commonly referred to as &amp;ldquo;width subtyping&amp;rdquo; because a type that is &amp;ldquo;wider&amp;rdquo; (i.e., has more properties) is a subtype of a narrower type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b065150ca9eda7d9b645bb02ec9b648bf937bd" translate="yes" xml:space="preserve">
          <source>This is a union of a class component or a stateless functional component. This is the type you want to use for functions that receive or return React components such as higher-order components or other utilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb111ed813f5032a53f03d0b631da3f19b265167" translate="yes" xml:space="preserve">
          <source>This is also okay because if something is using &lt;code&gt;SubClass&lt;/code&gt; as if it were a &lt;code&gt;BaseClass&lt;/code&gt; they would still have access to the same interface as before because &lt;code&gt;SanFrancisco&lt;/code&gt; is just a &lt;code&gt;City&lt;/code&gt; with a little more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed9084ae2d3a6d3909814247a0a9d2fe5955a81d" translate="yes" xml:space="preserve">
          <source>This is an error because objects are mutable. The value referenced by the &lt;code&gt;employee&lt;/code&gt; variable is the same as the value referenced by the &lt;code&gt;person&lt;/code&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9e89f0566afa9b997d9c3c388578a1bf739bfd" translate="yes" xml:space="preserve">
          <source>This is an error in Flow because if you are expecting a &lt;code&gt;SanFrancisco&lt;/code&gt; and you get a &lt;code&gt;City&lt;/code&gt; you could be using something that only exists on &lt;code&gt;SanFrancisco&lt;/code&gt; which would cause an error at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56976d17f40e185b38c5c6efa84d2af088f0b974" translate="yes" xml:space="preserve">
          <source>This is because classes in Flow are &lt;a href=&quot;https://flow.org/en/lang/nominal-structural&quot;&gt;nominally typed&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127badd88c854dba7d3f79ae45c90e45e0bab65a" translate="yes" xml:space="preserve">
          <source>This is because in Flow it is okay to pass an object value with more properties than the object type expects (because of width subtyping).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a696e7fa8715b1a73c06f5c45c3a6a89c88aadac" translate="yes" xml:space="preserve">
          <source>This is different from the &lt;code&gt;[ignore]&lt;/code&gt; config section that causes matching files to be ignored by the module resolver, which inherently makes them un-typechecked, and also unresolvable by &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;. When ignored &lt;code&gt;[libs]&lt;/code&gt; must then be specified for each &lt;code&gt;import&lt;/code&gt; using &lt;code&gt;flow-typed&lt;/code&gt;, which may not always be desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3e3b48d7024605ecf73a60b4a059e305833ff81" translate="yes" xml:space="preserve">
          <source>This is extremely useful for expressing the return type of functions that manipulate objects values. You could use a similar approach (for instance) to provide the return type of bluebird&amp;rsquo;s &lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.props.html&quot;&gt;&lt;code&gt;Promise.props&lt;/code&gt;&lt;/a&gt; function, which is like &lt;code&gt;Promise.all&lt;/code&gt; but takes an object as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60dfb0118bc43aa84388f7d66bc4c2be8af7089f" translate="yes" xml:space="preserve">
          <source>This is okay because if something else in your program is using &lt;code&gt;SubClass&lt;/code&gt; as if it were a &lt;code&gt;BaseClass&lt;/code&gt;, it would still be using a &lt;code&gt;City&lt;/code&gt; and wouldn&amp;rsquo;t cause any issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def5148d9c559d37a047e98dc2513022553f61be" translate="yes" xml:space="preserve">
          <source>This is perfectly fine because if we pass in a more specific type we&amp;rsquo;ll still have all the information we need to be compatible with &lt;code&gt;Noun&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424b976babef7901da66b2db61ee539c2a0be62a" translate="yes" xml:space="preserve">
          <source>This is the type of a React stateless functional component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b862b3fcdd9450bc624dc8b8cf55e1f701d1ad" translate="yes" xml:space="preserve">
          <source>This is unsafe and not recommended. But it&amp;rsquo;s sometimes useful when you are doing something with a value which is very difficult or impossible to type and want to make sure that the result has the desired type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35aa78e533f2578f7e162a36de338a1f47f6c0b2" translate="yes" xml:space="preserve">
          <source>This is useful when you need to use a read-only version of an object type you&amp;rsquo;ve already defined, without manually having to re-define and annotate each key as read-only. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4cb01bc5bdd818c1407e6cedc026d2b0b09c1ad" translate="yes" xml:space="preserve">
          <source>This is very handy, but sometimes you need to access the enum definition at runtime (i.e. at a value level).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f3db6a2015884e8473b3172c31c08a869daab0" translate="yes" xml:space="preserve">
          <source>This is where &lt;a href=&quot;../types#toc-react-config&quot;&gt;&lt;code&gt;React.Config&amp;lt;Props, DefaultProps&amp;gt;&lt;/code&gt;&lt;/a&gt; comes in handy! We can use the type for Props and DefaultProps to calculate the &lt;code&gt;Config&lt;/code&gt; type for our component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ae5e6ce6468f7ff3f32ccfa0dd3f8fb2f7bcea" translate="yes" xml:space="preserve">
          <source>This is where &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; comes in handy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee856278c549261688abdbd19d4ddec7e5efdc46" translate="yes" xml:space="preserve">
          <source>This lint setting is ignored when &lt;code&gt;exact_by_default&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70889c6b7d22baa7cf64ab4c9b4c3c93d6d9191" translate="yes" xml:space="preserve">
          <source>This makes Flow treat &lt;code&gt;require('image!foo.jpg')&lt;/code&gt; as if it were &lt;code&gt;require('ImageStub')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23feb9278c999088a311838ae5b7031bb5b5bf1" translate="yes" xml:space="preserve">
          <source>This makes it clear to the reader that &lt;code&gt;bar&lt;/code&gt; is not a potentially nullish property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76437fdbf44079b1c571bd4124ab2ff68199ec3a" translate="yes" xml:space="preserve">
          <source>This means that a shorter tuple can&amp;rsquo;t be used in place of a longer one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebff5f8c600e3fd9834aa943d918c1bfbd8d2dbe" translate="yes" xml:space="preserve">
          <source>This means that reads from unsealed objects with no matching writes are never checked. This is an unsafe behavior of Flow which may be improved in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf9058b929ae73030823387d719318f0032a9fd" translate="yes" xml:space="preserve">
          <source>This means that the following 2 types are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6784af09c850d7330fc9ffa9c72f9fa8a86cc84a" translate="yes" xml:space="preserve">
          <source>This often means figuring out if the value you are passing in is a subtype of the value you are expecting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd8bc2873ab259581a052bdf16376541801c36c" translate="yes" xml:space="preserve">
          <source>This option configures the maximum possible size for the shared heap. You should most likely not need to configure this, as it doesn&amp;rsquo;t really affect how much RSS Flow uses. However, if you are working on a massive codebase you might see the following error after init: &amp;ldquo;Heap init size is too close to max heap size; GC will never get triggered!&amp;rdquo; In this case, you may need to increase the size of the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9586cb7b0444ddcbaf378ece59924e71eed799e4" translate="yes" xml:space="preserve">
          <source>This option lets you alias &lt;code&gt;any&lt;/code&gt; with a given string. This is useful for explaining why you&amp;rsquo;re using &lt;code&gt;any&lt;/code&gt;. For example, let&amp;rsquo;s say you sometimes want to sometimes use &lt;code&gt;any&lt;/code&gt; to suppress an error and sometimes to mark a TODO. Your code might look like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36407b4a8671f76cf48e67ecd38443356cf43c1d" translate="yes" xml:space="preserve">
          <source>This pattern is also not limited to function children. You could also pass in arbitrary object or class types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8daebbe8ae6fc42b982d8e4fe22459a7a10cd94c" translate="yes" xml:space="preserve">
          <source>This represents any node that can be rendered in a React application. &lt;code&gt;React.Node&lt;/code&gt; can be null, a boolean, a number, a string, a React element, or an array of any of those types recursively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752249d3acac833c3c21ce430f38863e1937ed27" translate="yes" xml:space="preserve">
          <source>This syntax is also available in a &lt;code&gt;flow-include&lt;/code&gt; form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b31f92efc0a4da4dd28fb6304800cf7cd7fbb9c" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;PI&lt;/code&gt; global variable &amp;ndash; which, in this case, is a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f16bca30984be4eadbc92268c71095b6f69d5a4" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;URL&lt;/code&gt; global class. Note that this class definition does not have any implementation details &amp;ndash; it exclusively defines the interface of the class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe10f9e40b8844cde008f22e6f7e27a41dd5807d" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;UserID&lt;/code&gt; global type &amp;ndash; which, in this case, is just an alias for &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06e9eb45a05735715e1d1b65c57610ee02c78b2" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;foo&lt;/code&gt; global function, and that the function takes one argument (a &lt;code&gt;number&lt;/code&gt;) and it returns a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bab6dcb6b25f93bc93c3ef139cb0898176b837" translate="yes" xml:space="preserve">
          <source>This utility has been deprecated and should be avoided. See &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-type&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74c252b0eeaacbb897eb419ddf06e190d869384" translate="yes" xml:space="preserve">
          <source>This utility has been deprecated and should be avoided. See &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-utility&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabd9148684b1aa762ff2b690b8f720e71dd5acb" translate="yes" xml:space="preserve">
          <source>This way you avoid duplicating the properties that happen to have a default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22fe37b0969c2ab3810a8157bfb87e3e61565f27" translate="yes" xml:space="preserve">
          <source>This way you can keep the behavior of generics while only allowing certain types to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06c742de148aa21dfa2ce9950e849bcb9ab4c64" translate="yes" xml:space="preserve">
          <source>This will give you information about everything that flow can do. Running this command should print something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5358194d5e312667901904699178d180ad0d876" translate="yes" xml:space="preserve">
          <source>This would be the same as including a type annotation inside an include comment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80babb7d0ff0eda4573ad401ec556fbf50e83b89" translate="yes" xml:space="preserve">
          <source>To add a type for state to your React class component then create a new object type, in the example below we name it &lt;code&gt;State&lt;/code&gt;, and pass it as the second type argument to &lt;code&gt;React.Component&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46cc112d13261a13154b6cfac4e2d48bf5063881" translate="yes" xml:space="preserve">
          <source>To create an array type you can use &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; type where &lt;code&gt;Type&lt;/code&gt; is the type of elements in the array. For example, to create a type for an array of numbers you use &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd0d93865b9bfacde3e4affb1eb92fd379b6bf0" translate="yes" xml:space="preserve">
          <source>To declare a global class that should be accessible throughout your project, use the &lt;code&gt;declare class&lt;/code&gt; syntax in a libdef file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c05553bc81af5c0b4f02184bd805aba0fa865c0" translate="yes" xml:space="preserve">
          <source>To declare a global function that should be accessible throughout your project, use the &lt;code&gt;declare function&lt;/code&gt; syntax in a libdef file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8d4cb10458061c2bc75c04590a96a2ed068bd5" translate="yes" xml:space="preserve">
          <source>To declare a global type that should be accessible throughout your project, use the &lt;code&gt;declare type&lt;/code&gt; syntax in a libdef file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38d878e01cad40728f252774b0c25def7d4cb78" translate="yes" xml:space="preserve">
          <source>To declare a global variable that should be accessible throughout your project, use the &lt;code&gt;declare var&lt;/code&gt; syntax in a libdef file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1875d662019d803a3d158d296ddb77c1752c55d" translate="yes" xml:space="preserve">
          <source>To explicitly specify the type of a context value, pass a type parameter to &lt;code&gt;createContext&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc65e5d43387ac143a42fd49169c9f382ad9e6e7" translate="yes" xml:space="preserve">
          <source>To find out more about the CLI just type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d062574c0bbb40aba96339ff0dbe5323fbfe73f8" translate="yes" xml:space="preserve">
          <source>To get a sense of when and why the different kinds of variance matters, let&amp;rsquo;s talk about methods of subclasses and how they get type checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ca9700f4d5ea2116113c0a357e597df59a1d6a" translate="yes" xml:space="preserve">
          <source>To remove a prop from the config, we can take a component that includes the prop and return a component that does not. It&amp;rsquo;s best to construct these types using object type spread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da5a47f9a8fbbb9d2efd234b56f09b304fb7f98" translate="yes" xml:space="preserve">
          <source>To see how you can annotate exported React components, check out our docs on &lt;a href=&quot;https://flow.org/en/react/hoc/#toc-exporting-wrapped-components&quot;&gt;HOCs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d849d799ad5dab7240320680d5c36bc5f7e6a7" translate="yes" xml:space="preserve">
          <source>To start a Flow server in Filesystem lazy mode, you run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf8bbf7b6d19d0001e46d5b57c96b778d96ae37" translate="yes" xml:space="preserve">
          <source>To start a Flow server in IDE lazy mode, you run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9bdac3d6d4ba3e13640e1b5c7a6fd976aa5a44" translate="yes" xml:space="preserve">
          <source>To start a Flow server in Watchman lazy mode, you run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3978fe345012186156eab3faa3a6473c8b81612a" translate="yes" xml:space="preserve">
          <source>To start, we can define a SubClass that extends our BaseClass. Here you can see that the value and the return type are both City just like in BaseClass:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cfed2a3a8f7e86b967cf2cb173010c65146aff8" translate="yes" xml:space="preserve">
          <source>To stop the background process, run &lt;code&gt;flow stop&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338950985d59d6b6ee99128178aad62509b70476" translate="yes" xml:space="preserve">
          <source>To type event handlers you may use the &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="624f97de4950b92b803c5cac29be65a9f2a26ac4" translate="yes" xml:space="preserve">
          <source>Triggers when a &lt;code&gt;number&lt;/code&gt; is used in a manner which may lead to unexpected results if the value is falsy. Currently, this lint triggers if a &lt;code&gt;number&lt;/code&gt; appears in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8244aa53a1217dc629b3a687638e12f7a3825a89" translate="yes" xml:space="preserve">
          <source>Triggers when a dynamic type (usually &lt;code&gt;any&lt;/code&gt;) appears in a position exported from a file. Note that this is a very noisy lint, and can be triggered even when exporting types that are defined in our library definitions to include &lt;code&gt;any&lt;/code&gt; types. For this reason we recommend turning it on on a per-file or even per-line basis using &lt;a href=&quot;../flowlint-comments#toc-flowlint&quot;&gt;flowlint comments&lt;/a&gt; rather than for your whole repository in the &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47ddc8ed6cfa00004f5b18730edf70132171135b" translate="yes" xml:space="preserve">
          <source>Triggers when you do an existence check on a value that can be either null/undefined or falsey.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce10e302a6e69d26761a0ef32f11a1014584bb6" translate="yes" xml:space="preserve">
          <source>Triggers when you import a type from an untyped file. Importing a type from an untyped file results in an &lt;code&gt;any&lt;/code&gt; alias, which is typically not the intended behavior. Enabling this lint brings extra attention to this case and can help improve Flow coverage of typed files by limiting the spread of implicit &lt;code&gt;any&lt;/code&gt; types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e312343bc5d66e00ad8f9190f3b8d256cb21f3" translate="yes" xml:space="preserve">
          <source>Triggers when you import from an untyped file. Importing from an untyped file results in those imports being typed as &lt;code&gt;any&lt;/code&gt;, which is unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39095841a2d5b46ef9de672a2165376705e39be2" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;?.&lt;/code&gt; where it isn&amp;rsquo;t needed. This comes in two main flavors. The first is when the left-hand-side cannot be nullish:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a041463679a6c0a8cd599df21a504646bc4568e" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, or &lt;code&gt;Function&lt;/code&gt; as type annotations. These types are unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e0b14f57c0eae8e32ecfbe46dbafa0b69613db" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;invariant&lt;/code&gt; to check a condition which we know must be truthy based on the available type information. This is quite conservative: for example, if all we know about the condition is that it is a &lt;code&gt;boolean&lt;/code&gt;, then the lint will not fire even if the condition must be &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f0c0e34ae8ddb6395ee1c9617fdf1fcbad8760" translate="yes" xml:space="preserve">
          <source>Triggers when you use getters or setters. Getters and setters can have side effects and are unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffe944ad5706f41a9277209e96a262e3b635f27d" translate="yes" xml:space="preserve">
          <source>Triggers when you use object type syntax without explicitly specifying exactness or inexactness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53aef4ae56fa920050fd71a2e06d45055d43a802" translate="yes" xml:space="preserve">
          <source>Triggers when you use the &lt;code&gt;$Supertype&lt;/code&gt; or &lt;code&gt;$Subtype&lt;/code&gt; utility types, as these types are unsafe and equivalent to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d53a0bb8e4d9ee63e0c2e172befa01db4dc5e57" translate="yes" xml:space="preserve">
          <source>Triggers when you use the &lt;code&gt;*&lt;/code&gt; (existential) type, as this type is unsafe and usually just equivalent to &lt;code&gt;any&lt;/code&gt;. The effect of &lt;code&gt;*&lt;/code&gt; can generally be achieved by simply not providing a type annotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cddc0a96f7b4bc576c5197edc188b6a0fc13138" translate="yes" xml:space="preserve">
          <source>Trying to access an index that does not exist results in an index-out-of-bounds error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cded0e3b203109683ae6b9ee54b86c57e5dee4ad" translate="yes" xml:space="preserve">
          <source>Trying to combine these two separate types into a single one will only cause us trouble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2a5e4b9220f04b1f591d617289494ede815765" translate="yes" xml:space="preserve">
          <source>Tuple Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61fc0a89e720d49271749ab98f1e68ad73b11567" translate="yes" xml:space="preserve">
          <source>Tuples are a sort of list but with a limited set of items. In JavaScript, tuples are created using arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e71c95d22953ac62aab7556972e23a84de8572" translate="yes" xml:space="preserve">
          <source>Tuples don&amp;rsquo;t match array types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8228214d660934e2f3e63e0eebd31592280771e2" translate="yes" xml:space="preserve">
          <source>Tuples only match tuples with same length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd8267f01d325be2d1360510829d925406c4930" translate="yes" xml:space="preserve">
          <source>Type &amp;lsquo;Flow&amp;rsquo; to find &amp;lsquo;Flow for Sublime Text 2 and 3&amp;rsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="706d45898c47974656ad0920b31f4684a46f295c" translate="yes" xml:space="preserve">
          <source>Type Alias Generics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967c606ccee3e18535dabb6a9b4bb749abac062f" translate="yes" xml:space="preserve">
          <source>Type Alias Syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d158ab75d63715d420bc5e58daab5d8357398c" translate="yes" xml:space="preserve">
          <source>Type Annotations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77177e460aea3473402f5aaa44a506ee91144641" translate="yes" xml:space="preserve">
          <source>Type Assertions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679d10a7debbdc2089b71c9b81e4e219e305c114" translate="yes" xml:space="preserve">
          <source>Type Cast Expression Syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7ae61fc4d52305e688b8380ee480f65e186212" translate="yes" xml:space="preserve">
          <source>Type Casting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622cca8db4f4ef9c127d2e4b8f7ee4a1c6c56924" translate="yes" xml:space="preserve">
          <source>Type Casting Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242837be86dac228098509d8b1d22d367cdf4559" translate="yes" xml:space="preserve">
          <source>Type Casting through any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad392a89ee608a47c6212c75337d50433a48220" translate="yes" xml:space="preserve">
          <source>Type Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce57a9b5c9b93e38d173ed05c80dc328e2cdfdfc" translate="yes" xml:space="preserve">
          <source>Type Refinements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7433446286e8e2d16c8a5d667b180309a3d0c3b1" translate="yes" xml:space="preserve">
          <source>Type System</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472d5c5df27f757dd28ba1d382ee583d4a9c6081" translate="yes" xml:space="preserve">
          <source>Type Variance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7081fc7a1f2c1115eff37592f8d91d2655e0035b" translate="yes" xml:space="preserve">
          <source>Type alias generics are &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;parameterized&lt;/a&gt;. When you use a type alias you need to pass parameters for each of its generics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6584609a640d5af10378fda6649aaa9963a745" translate="yes" xml:space="preserve">
          <source>Type aliases are created using the keyword &lt;code&gt;type&lt;/code&gt; followed by its name, an equals sign &lt;code&gt;=&lt;/code&gt;, and a type definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e43ef93cfc8bf99af97c7220813d7732015c36" translate="yes" xml:space="preserve">
          <source>Type aliases can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094f893f7105ba5dce34064ff2a962e9a5dea0a2" translate="yes" xml:space="preserve">
          <source>Type aliases with generics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="856da198c41cb55e6e7b7e17d220f7f074929070" translate="yes" xml:space="preserve">
          <source>Type cast expressions can appear anywhere an expression can appear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a7383784e25f833d11d59af803f7d6f5fb1c80" translate="yes" xml:space="preserve">
          <source>Type checking through type assertions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b25b95faf957cfa80952cbe05fe4b40c3ff732" translate="yes" xml:space="preserve">
          <source>Typeof Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96900534c313f15c2044eb007fe55d438980bfc" translate="yes" xml:space="preserve">
          <source>Types &amp;amp; Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c71bc629994455a4ae2c2c56b3468d4335892413" translate="yes" xml:space="preserve">
          <source>Types for literal values are lowercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580c5ee4989e8d41e98c7cbde35a3b6779ea36bd" translate="yes" xml:space="preserve">
          <source>Types for the wrapper objects are capitalized (the same as their constructor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4e1425babb83699dcc06797b8fc4bf14a2ecce" translate="yes" xml:space="preserve">
          <source>Typing Redux action creators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfff1352be5ea6c7148bf3b4ca1615b03fabc81" translate="yes" xml:space="preserve">
          <source>Typing Redux actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac33fe488507408b1948fb67be46790295ab295" translate="yes" xml:space="preserve">
          <source>Typing Redux reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1133cd18fcd897fc2f5bb525485b9229e6071672" translate="yes" xml:space="preserve">
          <source>Typing Redux state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0640a2bc7ae817374f47547199fbe5f3a1a3b619" translate="yes" xml:space="preserve">
          <source>Typing Redux state immutability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5122ba530622fd5f4a0332eb09fb6325c4305df1" translate="yes" xml:space="preserve">
          <source>Typing Redux thunk actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f00b09a4880f70aa5139aa250a7d8b335930e96" translate="yes" xml:space="preserve">
          <source>Typing function children or other exotic children types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1f5ee4decdbb0b21342950c2b6f1f39fa45f3a" translate="yes" xml:space="preserve">
          <source>Typing your &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#single-source-of-truth&quot;&gt;state&lt;/a&gt; object, works the same as typing any other object in Flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaeff57d46868fd923495803e50c88004276ec83" translate="yes" xml:space="preserve">
          <source>Typings HOCs can be complicated. While you can follow the &lt;a href=&quot;react/hoc&quot;&gt;docs about it&lt;/a&gt;, sometimes it can be easier to type the returned component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e0451237256965294e54fd3ed734d927e133c0" translate="yes" xml:space="preserve">
          <source>Under the hood, Flow relies on a high-throughput low-latency systems infrastructure that enables distribution of tasks among parallel workers, and communication of results in parallel via shared memory. Combined with an architecture where the analysis of a codebase is updated automatically in the background on file system changes, Flow delivers near-instantaneous feedback as the developer edits and rebases code, even in a large repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667d6f69fc6e6557c1fd07a997502ffbb6fea4b6" translate="yes" xml:space="preserve">
          <source>Understanding the logic behind generics might be useful, but what you really need to know to make your typings valid is that you need to help Flow to understand the type of &lt;code&gt;genericArray&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468ccd5bcf72e4958742b43ae3e09374a05c2b83" translate="yes" xml:space="preserve">
          <source>Union Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5997dfe0e231fc3d5039a0ce77e27fc997c50e93" translate="yes" xml:space="preserve">
          <source>Union type syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5772a5be68b2acc1748e16bd31117c9dcf779b80" translate="yes" xml:space="preserve">
          <source>Union types are any number of types which are joined by a vertical bar &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fcae8ac4735463f8391bdf76cd83a6272aa90b" translate="yes" xml:space="preserve">
          <source>Union types requires one in, but all out</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ebabc3d3f621503bd72ccc4402a11bbf25a8ef" translate="yes" xml:space="preserve">
          <source>Unions &amp;amp; Refinements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ed70ea0b1d89e63badbd5bea1ce73346a2e36d" translate="yes" xml:space="preserve">
          <source>Unknown property lookup on unsealed objects is unsafe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703d1ae54d78dc2791b520eb4ed986a6d9a34e11" translate="yes" xml:space="preserve">
          <source>Unless the objects somehow conflict with one another there is no way to distinguish them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3248cdccf6c3a032dec37be3fbfe52ccc8052c" translate="yes" xml:space="preserve">
          <source>Unlike many other languages, JavaScript only has one type of number. These values may appear as &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt;. JavaScript also considers &lt;code&gt;Infinity&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; to be numbers. The &lt;code&gt;number&lt;/code&gt; type captures everything JavaScript considers a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af13bbea775e8595b01bcfbe26e08a735507b74" translate="yes" xml:space="preserve">
          <source>Unlike regular object types, it is not valid to pass an object with &amp;ldquo;extra&amp;rdquo; properties to an exact object type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ef2b2dcd96f0dd48fe2da326d94f53363ed4ce" translate="yes" xml:space="preserve">
          <source>Unsealed objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c6b6f53e08c0606a31166d8b9a877dcfc420f6" translate="yes" xml:space="preserve">
          <source>Unsealed objects allow new properties to be written at any time. Flow ensures that reads are compatible with writes, but does not ensure that writes happen before reads (in the order of execution).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="a37aa700a25d2f5c26f5844b90cdc3158398c792" translate="yes" xml:space="preserve">
          <source>Used in conjuction with &lt;a href=&quot;https://flow.org/en/strict/&quot;&gt;Flow Strict&lt;/a&gt;. Triggers when importing a non &lt;code&gt;@flow strict&lt;/code&gt; module. When enabled, dependencies of a &lt;code&gt;@flow strict&lt;/code&gt; module must also be &lt;code&gt;@flow strict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37435b49f34aed7ea4a10106bbcc3330cbcab593" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;React.Node&lt;/code&gt; but without some primitive types like strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55e66a75946c4c072cc420e4c3ed94f6780a7c2" translate="yes" xml:space="preserve">
          <source>Using Default Props</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b120d1bbe1cac9b101fd75ecc8814d5b08ec58" translate="yes" xml:space="preserve">
          <source>Using Default Props for Functional Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c58620d569e6a2825f19e911cd8c7f8b356ab31" translate="yes" xml:space="preserve">
          <source>Using Filesystem Lazy Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eca84f8818d70549fd226298ab6a5af63ae5ddc" translate="yes" xml:space="preserve">
          <source>Using Flow you can use Maybe types for these values. Maybe types work with any other type by simply prefixing it with a question mark &lt;code&gt;?&lt;/code&gt; such as &lt;code&gt;?number&lt;/code&gt; as a sort of modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7902faac97670dd0cee466cfc7b1872b6191c6" translate="yes" xml:space="preserve">
          <source>Using IDE Lazy Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb8b5c22a81a676bc4f6e0097672681d67ad964" translate="yes" xml:space="preserve">
          <source>Using Watchman Lazy Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4acbbdc6b766f0f60a0b004c91a169d2b83a940e" translate="yes" xml:space="preserve">
          <source>Using disjoint unions, Flow will be able to understand your reducers much better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ba24474eb6d1b00633e337c8dace730b98eb30" translate="yes" xml:space="preserve">
          <source>Using exact object types lets Flow know that no extra properties will exist at runtime, which allows &lt;a href=&quot;../refinements&quot;&gt;refinements&lt;/a&gt; to get more specific.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ade4f79788cce4dea297a9d609f90e95de4261" translate="yes" xml:space="preserve">
          <source>Using inference, these types are often optional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638d500275968b8c62e284497de3a8262dc86007" translate="yes" xml:space="preserve">
          <source>Using intersection types, it is possible to create types which are impossible to create at runtime. Intersection types will allow you to combine any set of types, even ones that conflict with one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86509a1d00de10c9136938cbdfb1d9850e246f6e" translate="yes" xml:space="preserve">
          <source>Using the command &lt;code&gt;flow&lt;/code&gt; will type-check your current directory if the &lt;code&gt;.flowconfig&lt;/code&gt; file is present. A flow server will automatically be started if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4fce26a90d1ee7b21142442ea9f330e4afede8c" translate="yes" xml:space="preserve">
          <source>Using these with &lt;a href=&quot;../unions&quot;&gt;union types&lt;/a&gt; is powerful:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f37430c61b5ea396ac215dd6bf35547ff8b510" translate="yes" xml:space="preserve">
          <source>Using type cast expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e74c3c3dbc90177ee7906987795cb4e37db9635" translate="yes" xml:space="preserve">
          <source>Using type cast expressions you can assert that values are certain types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba045b792a727f53d493f5cc2d4bbe68e26bbc6" translate="yes" xml:space="preserve">
          <source>Utility Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d981987c61afbbc64d7655e2b4cdb6bf5b85cbce" translate="yes" xml:space="preserve">
          <source>Variable Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c555fe12c9dd11facd9128e236d5c42157a806e" translate="yes" xml:space="preserve">
          <source>Variance Sigils</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e8ee8b0b460ae1489f8fa70aa448077ad5be60" translate="yes" xml:space="preserve">
          <source>Variance in Classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661548cc8ae30e106f079ae71da4e22fdee3f0a3" translate="yes" xml:space="preserve">
          <source>Variance is a topic that comes up fairly often in type systems and can be a bit confusing the first time you hear it. Let&amp;rsquo;s walk through each form of variance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f27c48fa3564f7410e0121a7646d154ac051a32" translate="yes" xml:space="preserve">
          <source>Variance sigils allow you to be more specific about how you intend to use your generics, giving Flow the power to do more precise type checking. For example, you may want this relationship to hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78ad277616170813560c5fab7aabae8ac9cfb23" translate="yes" xml:space="preserve">
          <source>Vim</source>
          <target state="translated">Vim</target>
        </trans-unit>
        <trans-unit id="afbd00670e2a500077ed926aedfb070c71244c15" translate="yes" xml:space="preserve">
          <source>VimPlug</source>
          <target state="translated">VimPlug</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8fd2f3a8255adad646ca5327eba0b8786744dbe" translate="yes" xml:space="preserve">
          <source>Warnings aren&amp;rsquo;t shown on the CLI by default, to avoid spew. CLI warnings can be enabled by passing the &amp;ndash;include-warnings flag to the Flow server or the Flow client, or by setting &amp;ldquo;include_warnings=true&amp;rdquo; in the &lt;code&gt;.flowconfig&lt;/code&gt;. This is good for smaller projects that want to see all project warnings at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe8d40071f5a559a669afec325304551bb16aba4" translate="yes" xml:space="preserve">
          <source>Warnings don&amp;rsquo;t affect the exit code of Flow. If Flow finds warnings but no errors, it still returns 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f9219fd8a874b03e97d8fac13dedd6210a919b" translate="yes" xml:space="preserve">
          <source>Warnings have special &lt;a href=&quot;ide-integration&quot;&gt;IDE Integration&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2debe559facf651a601f9c7527b8296d8b9624" translate="yes" xml:space="preserve">
          <source>Watchman lazy mode has a few additional requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78080fc13eb28909de716d744a8a47810b22cd61" translate="yes" xml:space="preserve">
          <source>We also need &lt;code&gt;typeof&lt;/code&gt; for &lt;code&gt;Bar&lt;/code&gt; because &lt;code&gt;Bar&lt;/code&gt; is a value. So we want to get the type &lt;em&gt;of&lt;/em&gt; the value &lt;code&gt;Bar&lt;/code&gt;. &lt;code&gt;(Bar: Bar)&lt;/code&gt; is an error because &lt;code&gt;Bar&lt;/code&gt; cannot be used as a type, so the following is correct: &lt;code&gt;(Bar: typeof Bar)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565a855b54dc5d4e5feb1c24229c3c37a0aa82ca" translate="yes" xml:space="preserve">
          <source>We can try to express both of these objects in a single object type. However, we&amp;rsquo;ll quickly run into issues where we know a property exists based on the success property but Flow does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb681ad5a4120e328dc7b7df6b9ecb5757df66ef" translate="yes" xml:space="preserve">
          <source>We can use this type alias to make sure reducers work correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb5411b6ed2d064b0d0e833606639f58a6b2b5f" translate="yes" xml:space="preserve">
          <source>We get this error message because &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t set the &lt;code&gt;Instance&lt;/code&gt; type parameter, so it is automatically set to &lt;code&gt;mixed&lt;/code&gt;. If we wanted to preserve the instance type of the component, we can use &lt;a href=&quot;https://reactjs.org/docs/forwarding-refs.html&quot;&gt;&lt;code&gt;React.forwardRef&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c408c67aca29a7fa863fd2f5d381f5c8273e88" translate="yes" xml:space="preserve">
          <source>We recommend you enable all your desired rules from the beginning, then adopt Flow Strict file-by-file. This works better than enabling a single rule, adding &lt;code&gt;@flow strict&lt;/code&gt; to many files, and then adding more rules to the config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34abdcf44b0093985cf9e1d46481109cab9f85f9" translate="yes" xml:space="preserve">
          <source>We removed our dependency on &lt;code&gt;prop-types&lt;/code&gt; and added a Flow object type named &lt;code&gt;Props&lt;/code&gt; with the same shape as the prop types but using Flow&amp;rsquo;s static type syntax. Then we passed our new &lt;code&gt;Props&lt;/code&gt; type into &lt;code&gt;React.Component&lt;/code&gt; as a type argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdbcb95f6a23f42e50318e1968770b634c1e41d0" translate="yes" xml:space="preserve">
          <source>We set the type of props to &lt;code&gt;React.ChildrenArray&amp;lt;React.Element&amp;lt;typeof TabBarIOSItem&amp;gt;&amp;gt;&lt;/code&gt; which will guarantee that &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; must only have children that are &lt;code&gt;TabBarIOS.Item&lt;/code&gt; React elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fdfa76ed94bd3897d04cec5f4134f4e7bc035e" translate="yes" xml:space="preserve">
          <source>We will refer to all the types in the following reference as if we imported them with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0deed72cfe69559a9e7c7724e402ecb7a9ed446" translate="yes" xml:space="preserve">
          <source>We would have a lot of trouble trying to write specific types for this function since it could be anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c34be58b1366378d47ad4ba8a861a9a07fe8d5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll quickly set up our &lt;code&gt;BaseClass&lt;/code&gt; which will define just one method that accepts an input value with the type &lt;code&gt;City&lt;/code&gt; and an returned output also with the type &lt;code&gt;City&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20c7e2164e3a5acb3717c0236d43d3267a9c8ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use these classes to write a method that has each kind of variance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c0bd1c623d23997ff99f3caa7042e13039a782" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve demonstrated both nominal and structure typing of classes, but there are also other complex types like objects and functions which can also be either nominal or structural. Even further, they can be different within the same type system (most of the languages listed before has features of both).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b6d6d89517eff4ce180cea4ab387ae48e094cb" translate="yes" xml:space="preserve">
          <source>WebStorm</source>
          <target state="translated">WebStorm</target>
        </trans-unit>
        <trans-unit id="d40a79cfe25e4cc102f0a57e8b44e1c01d37bcbb" translate="yes" xml:space="preserve">
          <source>WebStorm 2016.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3e64366f1d6fbef0a5c75ba4449cc79038d05d" translate="yes" xml:space="preserve">
          <source>WebStorm 2017.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f14c5dae174ee34d208589e220dbdb169f943d4" translate="yes" xml:space="preserve">
          <source>Webstorm installation instructions can be found here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f3ba4fbbef59c08df191dcbed16fa19c8defe9" translate="yes" xml:space="preserve">
          <source>What do you think will happen?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5eba71e139ed73ff2a0e9b6ced493bb2e4087c" translate="yes" xml:space="preserve">
          <source>What happens when you have a single child?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6966f9bf72c264264a3efaf8dc5ecfa61beb1bb2" translate="yes" xml:space="preserve">
          <source>What happens when you have multiple children?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b550ae1d285f33798a42afbb386fd6afdc67f5" translate="yes" xml:space="preserve">
          <source>What is a subtype?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4ecfb3127c03f684e91c1f130988581c874a06" translate="yes" xml:space="preserve">
          <source>What makes Flow fast?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db33814c5657c00a949fba0af9d59dbafa3fcb1a" translate="yes" xml:space="preserve">
          <source>What makes Flow precise?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd65380fb716403292b7d92faef2766c527f8ab" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s Ahead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e189be8dd7a5933934ab2b958e415933a6e5ad" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a &amp;ldquo;Library Definition&amp;rdquo;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40731c621de61ed4b398992215b3e1a3b5986f84" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a Declaration File?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9efc85fa229daf00790235bc1d272e8bf51c10c" translate="yes" xml:space="preserve">
          <source>When an object type has an indexer property, property accesses are assumed to have the annotated type, even if the object does not have a value in that slot at runtime. It is the programmer&amp;rsquo;s responsibility to ensure the access is safe, as with arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b96e1aead97a6dccb4198de5ff7a26c459a398" translate="yes" xml:space="preserve">
          <source>When are subtypes used?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4a3bdc8dfbb9e08a8423a54448b12d02bbd84f" translate="yes" xml:space="preserve">
          <source>When calling our function that accepts a union type we must pass in &lt;strong&gt;&lt;em&gt;one of those types&lt;/em&gt;&lt;/strong&gt;. But inside of our function we are required to handle &lt;strong&gt;&lt;em&gt;all of the possible types&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302b36e230abf6c143e3b19fe2499d796c35aef9" translate="yes" xml:space="preserve">
          <source>When comparing a function type with a function it must have the same structure in order to be considered valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ef3ae0ab9bcb0e4ab1d4e8a1404fcbb0a3607c" translate="yes" xml:space="preserve">
          <source>When comparing an object type with an object it must have the same structure in order to be considered valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8396399d85dff5129d383218ce52eac55a623a9e" translate="yes" xml:space="preserve">
          <source>When importing an opaque type alias, it behaves like a &lt;a href=&quot;https://flow.org/en/lang/nominal-structural/#toc-nominal-typing&quot;&gt;nominal type&lt;/a&gt;, hiding its underlying type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2485de3e0573347cabc863911d04dfca31e158c" translate="yes" xml:space="preserve">
          <source>When in the same file the alias is defined, opaque type aliases behave exactly as regular &lt;a href=&quot;../aliases&quot;&gt;type aliases&lt;/a&gt; do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb175c445847655877f1db30e472a996195f098" translate="yes" xml:space="preserve">
          <source>When setting a new value inside a tuple, the new value must match the type at that index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7517a9e192b4a198ec7b3f51067f670add7135eb" translate="yes" xml:space="preserve">
          <source>When someone writes a class, they are declaring a &lt;em&gt;thing&lt;/em&gt;. This thing might have the same structure as something else but they still serve different purposes. Imagine two component classes that both have &lt;code&gt;render()&lt;/code&gt; methods, these components could still have totally different purposes, but in a structural type system they&amp;rsquo;d be considered exactly the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d1e8cda45984711f6710361a85006d8bcb3ff6" translate="yes" xml:space="preserve">
          <source>When the request fails, we&amp;rsquo;ll get back an object with &lt;code&gt;success&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and an &lt;code&gt;error&lt;/code&gt; property describing the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94abdda8ce69397406ef44dd82ee02693dedecd" translate="yes" xml:space="preserve">
          <source>When this flag is &lt;code&gt;true&lt;/code&gt;, Flow has the following behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be3aebbba7f2ab96d8a1da1d160dd3a2c2cfa21" translate="yes" xml:space="preserve">
          <source>When using a generic type for a value, Flow will track the value and make sure that you aren&amp;rsquo;t replacing it with something else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967200160ca1f6e61c2f31daca12d9063b3bdc5b" translate="yes" xml:space="preserve">
          <source>When using this syntax, you are not required to give it a type annotation. But you still can if you need to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5028ae04135e00456a2a9a3d217b11e267ea9467" translate="yes" xml:space="preserve">
          <source>When you add a subtyping constraint to an opaque type alias, we allow the opaque type to be used as the super type when outside of the defining file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4548b3e8ef7180dc3aa259a4fafbe13e9785c6" translate="yes" xml:space="preserve">
          <source>When you are certain your code works and for some reason Flow is unable to type check it correctly. There are a (decreasing) number of idioms in JavaScript that Flow is unable to statically type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0640e9c67a5446e2d096da264d95ec5c0854ffcf" translate="yes" xml:space="preserve">
          <source>When you are declaring a new variable, you may optionally declare its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4a50c3c1cd36ed94156b1a9f3ca046b8801870" translate="yes" xml:space="preserve">
          <source>When you are getting a value from a tuple at a specific index, it will return the type at that index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a3af0d6ce8b90608026581625e6d89d89308d5" translate="yes" xml:space="preserve">
          <source>When you are in the process of converting existing code to using Flow types and you are currently blocked on having the code type checked (maybe other code needs to be converted first).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e90957894730cc07cfd478f29c1f4e5b53f0ac" translate="yes" xml:space="preserve">
          <source>When you create an intersection of object types, you merge all of their properties together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b45384d6cd9faea2b667285789acfc51eefb58" translate="yes" xml:space="preserve">
          <source>When you create an object with its properties, you create a &lt;em&gt;sealed&lt;/em&gt; object type in Flow. These sealed objects will know all of the properties you declared them with and the types of their values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41115243f1e2d1d0a4ea4f2efbfe55245e33a0c" translate="yes" xml:space="preserve">
          <source>When you create an object without any properties, you create an &lt;em&gt;unsealed&lt;/em&gt; object type in Flow. These unsealed objects will not know all of their properties and will allow you to add new ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2796a6c82e1741b853aad01a67eda238fc96c9eb" translate="yes" xml:space="preserve">
          <source>When you create an opaque type alias with a subtyping constraint, the type in the type position must be a subtype of the type in the super type position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49218e622c26dc57b5c913ea8900e0123789162a" translate="yes" xml:space="preserve">
          <source>When you do not provide a type, the inferred type will do one of two things if you re-assign it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad7818449b82b15d065d9c37e04d1727c40f683" translate="yes" xml:space="preserve">
          <source>When you have a value which is a union type it&amp;rsquo;s often useful to break it apart and handle each individual type separately. With union types in Flow you can &amp;ldquo;refine&amp;rdquo; the value down to a single type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb229dc9cf4f41267624f023e36cd675a57c24d6" translate="yes" xml:space="preserve">
          <source>When you have a value with the type &lt;code&gt;any&lt;/code&gt;, you can cause Flow to infer &lt;code&gt;any&lt;/code&gt; for the results of all of the operations you perform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eeac5c8af6e744b935a9344a38a377561163682" translate="yes" xml:space="preserve">
          <source>When you have complicated types that you want to reuse in multiple places, you can alias them in Flow using a &lt;strong&gt;type alias&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca6b3bbee47f3932b78bb3624b2a8e13ee5660b" translate="yes" xml:space="preserve">
          <source>When you have two classes with the same structure, they still are not considered equivalent because Flow uses nominal typing for classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b1b571956caaa58b630e76dcdcbd496c248766" translate="yes" xml:space="preserve">
          <source>When you provide a type, you will be able to re-assign the value, but it must always be of a compatible type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cb2287de1c6f15cf8167e43a3d3d87043228a3" translate="yes" xml:space="preserve">
          <source>When you retrieve an element from an array there is always a possibility that it is &lt;code&gt;undefined&lt;/code&gt;. You could have either accessed an index which is out of the bounds of the array, or the element could not exist because it is a &amp;ldquo;sparse array&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996a2595f6a66f040b899960922e9f1e015492aa" translate="yes" xml:space="preserve">
          <source>When you run your code, a single expression will only be run with a limited set of values. But still Flow checks &lt;em&gt;every&lt;/em&gt; possible value. In this way Flow is checking too many things or &lt;em&gt;over-approximating&lt;/em&gt; what will be valid code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfdf2c27394909eba3b1ac9709368e9e60c92c6c" translate="yes" xml:space="preserve">
          <source>When you strip the types all that is left is the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16d02930754982f643818365c9eb65e4b4b501a2" translate="yes" xml:space="preserve">
          <source>When you try to use a value of a &lt;code&gt;mixed&lt;/code&gt; type you must first figure out what the actual type is or you&amp;rsquo;ll end up with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a280997d975deface44a674ffdcce743182e95b" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;typeof&lt;/code&gt;, you&amp;rsquo;re inserting another type with all of its behaviors. This can make &lt;code&gt;typeof&lt;/code&gt; seem inconsistent where it is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a3b2f1c8635c3489f18114c859485b4887b6c9" translate="yes" xml:space="preserve">
          <source>When you use this function, Flow knows exactly what is going on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b433fb4be7e2c12ca3f57f9ed0a23cad0b0d75ad" translate="yes" xml:space="preserve">
          <source>When you write a type cast expression, the result of that expression is the value with the provided type. If you hold onto the resulting value, it will have the new type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f053b01bbe2e5493eb03b59a33406b2934f8f5" translate="yes" xml:space="preserve">
          <source>Whenever you want to use a class field in Flow you must first give it an annotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007c9142c650370d910eaa325adeac0c9f34bd33" translate="yes" xml:space="preserve">
          <source>Where to put the &lt;code&gt;.flowconfig&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9cd9b92722317ed472575adad6561c4aaa8a0c9" translate="yes" xml:space="preserve">
          <source>Which also applies to nested types within objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d77dcbc51b2f3900b8512f7fcc4c2e9f1910a53" translate="yes" xml:space="preserve">
          <source>Which then gets used as its own type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a80fced10ab4b19389a445b9f4af05de4c583bb" translate="yes" xml:space="preserve">
          <source>Which would ignore any file or directory under the directory named &lt;code&gt;__tests__/&lt;/code&gt; within the project root. However, unlike the previous example&amp;rsquo;s &lt;code&gt;.*/__tests__/.*&lt;/code&gt;, it would NOT ignore files or directories under other directories named &lt;code&gt;__tests__/&lt;/code&gt;, like &lt;code&gt;src/__tests__/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59a762c09f756bb3fe009f558e38099bc0a51a6" translate="yes" xml:space="preserve">
          <source>Which would parse in declaration mode any file or directory under the directory named &lt;code&gt;third_party/&lt;/code&gt; within the project root. However, unlike the previous example&amp;rsquo;s &lt;code&gt;.*/third_party/.*&lt;/code&gt;, it would NOT parse files or directories under directories named &lt;code&gt;third_party/&lt;/code&gt;, like &lt;code&gt;src/third_party/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbea4304dd73554152ad23aedd562115dbd9129" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;all&lt;/code&gt; isn&amp;rsquo;t technically a lint rule, it&amp;rsquo;s worth mentioning here. &lt;code&gt;all&lt;/code&gt; sets the default level for lint rules that don&amp;rsquo;t have a level set explicitly. &lt;code&gt;all&lt;/code&gt; can only occur as the first entry in a &lt;code&gt;.flowconfig&lt;/code&gt; or as the first rule in a &lt;code&gt;--lints&lt;/code&gt; flag. It&amp;rsquo;s not allowed in comments at all because it would have different semantics than would be expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ea1ea47df53d1cf736a6d4890e67395ca8b9c4" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I pass &lt;code&gt;{a:string}&lt;/code&gt; to a function that takes &lt;code&gt;{a:string|&amp;nbsp;number}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6cefc353f86770ed15c2136f41c2eff2427e68" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I pass an &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt; to a function that takes an &lt;code&gt;Array&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c5c443e0f5b7e99e95365f6c4edd88369864cd" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I refine a union of objects?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3de66a2c90224644ba944e2aa7479606459060" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I use a function in my if-clause to check the type of a property?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ff0da03e55358af58809fea89afe7aa72356c6" translate="yes" xml:space="preserve">
          <source>Width Subtyping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a257d9d182ebc37abf03c9319df6d8959cf5db" translate="yes" xml:space="preserve">
          <source>With Flow build step, using flow-bin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2995c53166bcc91b45280d17fe04fd71848fc06d" translate="yes" xml:space="preserve">
          <source>With exact object types, we cannot have additional properties, so the objects conflict with one another and we are able to distinguish which is which.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6943265cff3d8a72357d6db4963743033fc9d4b" translate="yes" xml:space="preserve">
          <source>With modularity, we can aggressively parallelize our analysis. Furthermore, when files change, we can incrementally analyze only those files that depend on the changed files. Together, these choices have helped scale the analysis to millions of lines of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3574433dfccbc2cdc3e7d09b6a827e56cbb69b39" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;method&lt;/code&gt;, we know that &lt;code&gt;obj&lt;/code&gt; has at least a property &lt;code&gt;foo&lt;/code&gt; and the property access expression &lt;code&gt;obj.foo&lt;/code&gt; will have type &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4fbc91308a94a65821208a1c024c9c0775a04d" translate="yes" xml:space="preserve">
          <source>Within the -lints flag and the flowconfig, rules lower down override rules higher up, allowing you to write things like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c37d919a96ee4ea89b463c060f82bc0a6e402a8f" translate="yes" xml:space="preserve">
          <source>Within the Defining File</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68dc31f474400f6b50bf4dad60cd35f6668b0b3" translate="yes" xml:space="preserve">
          <source>Within the body of a &lt;code&gt;declare module&lt;/code&gt; block, you can specify the set of exports for that module. However, before we start talking about exports we have to talk about the two kinds of modules that Flow supports: CommonJS and ES modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3933bb581c579641e65e780ba1a7fc018cbb1e5" translate="yes" xml:space="preserve">
          <source>Write Flow Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d42dc7f273412358b6af025e21835f6b2b59f3c" translate="yes" xml:space="preserve">
          <source>You are destructuring the object. When destructuring, Flow loses track of object properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1fd67e5d3bc9809749035f19782f6067817cf6" translate="yes" xml:space="preserve">
          <source>You are not allowed to do the following when using &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb97175b80248d75078c2d56240c55e682afdb8b" translate="yes" xml:space="preserve">
          <source>You are using inexact objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545f113ee57613cf761d4e16a9296f0dddf18ea1" translate="yes" xml:space="preserve">
          <source>You can add methods to interfaces following the same syntax as object methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13b654915322571d79f9d2209ebb3f541cb4c01" translate="yes" xml:space="preserve">
          <source>You can add properties to interfaces following the same syntax as object properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff142ce9ee3fec9b4cc52b1ba40b05d9245d3f7" translate="yes" xml:space="preserve">
          <source>You can add support for Flow in Emacs by using &lt;a href=&quot;https://github.com/flowtype/flow-for-emacs&quot;&gt;flow-for-emacs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60bece6a43fa1f4f89bb550305ddcf7599cfe4f" translate="yes" xml:space="preserve">
          <source>You can add this to your &lt;code&gt;package.json&lt;/code&gt; scripts easily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c722675694802907c5488d3f01827234fdbd4367" translate="yes" xml:space="preserve">
          <source>You can also add type annotations for rest parameters using the same syntax but with an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71d63fcbe7402ef7a02851894adf81dac971541" translate="yes" xml:space="preserve">
          <source>You can also adopt Flow incrementally and easily remove it at anytime, so you can try Flow out on any codebase and see how you like it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699187814f44354c9d5904df70d1d9ddacb546d5" translate="yes" xml:space="preserve">
          <source>You can also create arrays and add values to them later on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c646f56329a9cb5b56e87a03fe5b8a2719eb6c74" translate="yes" xml:space="preserve">
          <source>You can also declare opaque type aliases in &lt;a href=&quot;../libdefs&quot;&gt;libdefs&lt;/a&gt;. There, you omit the underlying type, but may still optionally include a super type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd17629705a4d950906c4a4641c7cec10003dd5" translate="yes" xml:space="preserve">
          <source>You can also give generic classes type arguments directly in the &lt;code&gt;new&lt;/code&gt; expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0940d878e3d44c8bd9c7d98cbd45fecf2f71a13" translate="yes" xml:space="preserve">
          <source>You can also have optional parameters by adding a question mark &lt;code&gt;?&lt;/code&gt; after the name of the parameter and before the colon &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cbe3e05438e8030d576dbde48b1eceb1121d9a3" translate="yes" xml:space="preserve">
          <source>You can also nest calls to &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt;, which is useful when you need to access the types inside nested structures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="815ff0c60624ac9094cf1c49f665f71a3473e58d" translate="yes" xml:space="preserve">
          <source>You can also provide defaults for parameterized generics just like parameters of a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719a9a50e459a2a6ce7e2c56e63ed6b525dc0279" translate="yes" xml:space="preserve">
          <source>You can also specify the subtyping behavior of a generic via variance sigils. By default, generics behave invariantly, but you may add a &lt;code&gt;+&lt;/code&gt; to their declaration to make them behave covariantly, or a &lt;code&gt;-&lt;/code&gt; to their declaration to make them behave contravariantly. See &lt;a href=&quot;https://flow.org/en/lang/variance&quot;&gt;our docs on variance&lt;/a&gt; for a more information on variance in Flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9363b7818b6e43e3422f3ad1d7ee6efa7ab8e46" translate="yes" xml:space="preserve">
          <source>You can also type &lt;code&gt;flow&lt;/code&gt; to accomplish the same effect as &lt;code&gt;status&lt;/code&gt; is the default flag to the &lt;code&gt;flow&lt;/code&gt; binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b68e51da33b5e539af5dbf6e3dcc5a59c33fe6c7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;implements&lt;/code&gt; to tell Flow that you want the class to match an interface. This prevents you from making incompatible changes when editing the class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a1292b81cf7cdb77a98439b57cf0147e0f8f3b" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;implements&lt;/code&gt; with multiple interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48dd13ac8774ad647e286bd9947352ec269d5800" translate="yes" xml:space="preserve">
          <source>You can also use named type imports in either an ES module environment or a CommonJS environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a88daebe91d272da9a7e038c3583dda16175e43" translate="yes" xml:space="preserve">
          <source>You can also use the form &lt;code&gt;/* @flow */&lt;/code&gt; for the flag as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c4697a441a0d2aa3c1b9f07e0ceb2ffc32acec" translate="yes" xml:space="preserve">
          <source>You can also validate that you have handled every single type of action by using the &lt;code&gt;empty&lt;/code&gt; type in your &lt;code&gt;default&lt;/code&gt; case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d608633d54b23080262b0d07f6cb7d3dc534564" translate="yes" xml:space="preserve">
          <source>You can benefit from having Flow run as you develop by integrating into your editor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dcc931397145e4c230e84b33d5d8a5720c03798" translate="yes" xml:space="preserve">
          <source>You can create &lt;a href=&quot;../objects#toc-objects-as-maps&quot;&gt;&amp;ldquo;indexer properties&amp;rdquo;&lt;/a&gt; the same way as with objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7946b65fbac98e9648cd5f68e306b48534b1a74" translate="yes" xml:space="preserve">
          <source>You can do that by adding an explicit type argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7fff0a703433e91168cd9bf5a21b4d5e3872e70" translate="yes" xml:space="preserve">
          <source>You can enable stronger safety guarantees in Flow (such as banning &lt;code&gt;any&lt;/code&gt;/&lt;code&gt;Object&lt;/code&gt;/&lt;code&gt;Function&lt;/code&gt; types and requiring all dependencies to be typed) by adding &lt;strong&gt;&lt;code&gt;@flow strict&lt;/code&gt;&lt;/strong&gt; to your files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa5fe932d239a06fd9575f03866b957b8981092" translate="yes" xml:space="preserve">
          <source>You can enforce this in Flow by making every property effectively &amp;ldquo;read-only&amp;rdquo; using &amp;ldquo;covariant&amp;rdquo; properties throughout your state object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba6431d84c3e47b98b215406e4d6e813fefabd22" translate="yes" xml:space="preserve">
          <source>You can even nest lookups:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ccb58e74c71e2de2b124e20c360c5995e2ecd92" translate="yes" xml:space="preserve">
          <source>You can expand this even further and keep refining possibilities away:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2afe0e2209309fcca1d0d4c82e4b42131180ea4" translate="yes" xml:space="preserve">
          <source>You can fix this by making &lt;code&gt;truthy&lt;/code&gt; a &lt;em&gt;predicate function&lt;/em&gt;, by using the &lt;code&gt;%checks&lt;/code&gt; annotation like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1300bdbd711a74807a169ed243bc8221cc1ddb60" translate="yes" xml:space="preserve">
          <source>You can force Flow to treat one or more files as focused from the CLI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="235ba8a2cc1e9c6fd298a395322859ee23a447be" translate="yes" xml:space="preserve">
          <source>You can get around this by storing your checked values in local variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fd44f437add0d9e133a8562afc12f273306434" translate="yes" xml:space="preserve">
          <source>You can give callable entities type arguments for their generics directly in the call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ade9cad1bbc6b49fbea6fdd6de913340f01abe2" translate="yes" xml:space="preserve">
          <source>You can have as many of these generics as you need in the type parameter list, naming them whatever you want:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf2172f11dbbcc47d7a009c576faeb7aa356654" translate="yes" xml:space="preserve">
          <source>You can make a property contravariant by adding a minus symbol - in front of the property name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bdca1788706e2fc8e4a9c9a6e2d01cd32f92dcf" translate="yes" xml:space="preserve">
          <source>You can make a property covariant by adding a plus symbol &lt;code&gt;+&lt;/code&gt; in front of the property name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b010851670e4ca7a130bea951f459af8dca6a36b" translate="yes" xml:space="preserve">
          <source>You can optionally add a subtyping constraint to an opaque type alias by adding a colon &lt;code&gt;:&lt;/code&gt; and a type after the name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2496b164e62d7e0f41690b9f5e9552b1b451b8" translate="yes" xml:space="preserve">
          <source>You can pass as many arguments as you want into a rest parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bd5c0ce38f5afd67d2acbbfbe61b90c3c48db4" translate="yes" xml:space="preserve">
          <source>You can put any type within &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="732207deaac1dc0f323e2c9b02fc147f8f812da1" translate="yes" xml:space="preserve">
          <source>You can simplify the two checks against &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; using a single &lt;code&gt;!= null&lt;/code&gt; check which will do both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afabef0657e245fef1b9b2930123308edd5afac" translate="yes" xml:space="preserve">
          <source>You can specify in the &lt;code&gt;.flowconfig&lt;/code&gt; which version of Flow you expect to use. You do this with the &lt;code&gt;[version]&lt;/code&gt; section. If this section is omitted or left blank, then any version is allowed. If a version is specified and not matched, then Flow will immediately error and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03b894ceec87547a288939cd8aaf30ae007c81b" translate="yes" xml:space="preserve">
          <source>You can start to compare two objects by their keys. If one object contains all the keys of another object, then it may be a subtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28e07b9c51e5ffadf873da6f7a3f54bbf76f2f9" translate="yes" xml:space="preserve">
          <source>You can then, further dig into particular COMMANDs by adding the &lt;code&gt;--help&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1e8c4360056b71335ea367a6b3e679639d25f3" translate="yes" xml:space="preserve">
          <source>You can think of this like passing arguments to a function, only the return value is a type that you can use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a6915e052949d36dbc7c36f8a0ffc2fd6eea09" translate="yes" xml:space="preserve">
          <source>You can update your code to the more readable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd1cddf8c517151cd84a6cfd9b8b49383f2e6c4" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;typeof x === &quot;symbol&quot;&lt;/code&gt; to refine to a symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81520be069e0fa0c9db8cbcabf710cfccf37e42" translate="yes" xml:space="preserve">
          <source>You can use any value with &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb1e9ebfd9c95be03ab9be04d025560b3074e1c" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a class (property types and method parameter/return types).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4aa0e86d6f17a2f8d19918819c102cbd6c3820e" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a function (parameter or return types).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de2ccca92b2b43ac3dc44c63b7e55c6b432c76a" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a function type (parameter or return types).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d107b2ef0635398f316220ce167c042b23a92d8" translate="yes" xml:space="preserve">
          <source>You can use primitive values for these types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1997334cf38d8070cc18855e7eb4a51b9f7aa599" translate="yes" xml:space="preserve">
          <source>You can use this in combination with &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; to get static props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38b57891c6a590d35857959678efd3a7cbc9edf" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;Array.prototype&lt;/code&gt; methods that mutate the tuple, only ones that do not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34cdb6dbd42effcc5eee6814751e14333d7ad7b4" translate="yes" xml:space="preserve">
          <source>You could also flip it around, and check to make sure that the value has a type of &lt;code&gt;number&lt;/code&gt; before using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54fcc4baacde621798558cd944fe72a2272653e" translate="yes" xml:space="preserve">
          <source>You could continue this process until &lt;code&gt;any&lt;/code&gt; has leaked all over your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ccb2330f2aef610502456380da1cc91e063a81" translate="yes" xml:space="preserve">
          <source>You could do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96c3e789576bc7f92cd0b34129750d6ad259391" translate="yes" xml:space="preserve">
          <source>You could refine the type, but the generic will still allow any type to be passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce625c160012e98036189d91961fd70764c6f12" translate="yes" xml:space="preserve">
          <source>You could then use the resulting value in another operation, such as adding it as if it were a number and the result will also be &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d0c0f6b4e6d2338d922e76b590f2d36d1904032" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to annotate the return type of either your &lt;code&gt;render()&lt;/code&gt; method or a stateless functional component. However, if you want to annotate the return type then &lt;code&gt;React.Node&lt;/code&gt; is the generic to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9c2c80449347f7166dc305529f30c45a9e9eed" translate="yes" xml:space="preserve">
          <source>You may also add a leading ampersand which is useful when breaking intersection types onto multiple lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa909f29db190474cf723005ff4008d9b7598e9" translate="yes" xml:space="preserve">
          <source>You may also add a leading vertical bar which is useful when breaking union types onto multiple lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9fdbe0651aa0dcc77f656e366ff86ea773ba26" translate="yes" xml:space="preserve">
          <source>You may also optionally leave out the parameter names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8369235f7cc951c26ca572a5f0d1089b25b9b0f4" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a property on instances of the class).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12abc47c0cac769438a2a10d53130bb5088f3b42" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a static property on the class).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbbefdd992a4649126e811e71f05644039bb6d5" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a0ac12f9014a2da637bcb44bcbb4fbf90a6924" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax. The default value of this option is &lt;code&gt;warn&lt;/code&gt;, which gives a warning on use since this proposal is still very early-stage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa76b5b2c71934a0d36af87656f7165b00582a43" translate="yes" xml:space="preserve">
          <source>You may also wish to install a popular SublimeLinter plugin for Flow like &lt;a href=&quot;https://packagecontrol.io/packages/SublimeLinter-flow&quot;&gt;SublimeLinter-flow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd52a5c29c3e64a83bb0f62e994bfb74ab453fe3" translate="yes" xml:space="preserve">
          <source>You might use these functions types for something like a callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed4bf60715e28afa28e2fa5a72f5002c15618be" translate="yes" xml:space="preserve">
          <source>You must always include the brackets &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; when using the type (just like parentheses for a function call).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f73949e10ba9c21b14d2d45c52b596aa157461" translate="yes" xml:space="preserve">
          <source>You must be explicit and convert other types into strings. You can do this by using the String method or using another method for stringifying values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b16b93eebbf6cd3d2d130c4da4b067de2c5876" translate="yes" xml:space="preserve">
          <source>You should represent these values with &lt;code&gt;mixed&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73e4c01718490bcf4d4cc882d49967190833cfe" translate="yes" xml:space="preserve">
          <source>You will have access to all of the values that React exports, but you will &lt;strong&gt;not&lt;/strong&gt; have access to the types documented below! This is because Flow will not add types to a default export since the default export could be any value (like a number). Flow will add exported named types to an ES namespace object which you can get with &lt;code&gt;import * as React from 'react'&lt;/code&gt; since Flow knows if you export a value with the same name as an exported type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c23f9cce0d3c2c8df25b9ff8cf278ae227f7bad" translate="yes" xml:space="preserve">
          <source>You write classes the same way you would without Flow, but then you can use the name of the class as a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654c5e74e5e546451d0e1429c2931cddd203538d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if we do not handle each possible type of our value, Flow will give us an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e6e89e1f9c5b889605448ec75232836809ed76" translate="yes" xml:space="preserve">
          <source>[declarations]</source>
          <target state="translated">[declarations]</target>
        </trans-unit>
        <trans-unit id="8efeedea6584d5d0f6aa150fe286ea3d383ef4a5" translate="yes" xml:space="preserve">
          <source>[ignore]</source>
          <target state="translated">[ignore]</target>
        </trans-unit>
        <trans-unit id="6c51495394c6e6372e62ee5ec85bb9eaef21cce5" translate="yes" xml:space="preserve">
          <source>[include]</source>
          <target state="translated">[include]</target>
        </trans-unit>
        <trans-unit id="7afbe53dfddbe7c93f7de3dd43aba3228ee7b934" translate="yes" xml:space="preserve">
          <source>[libs]</source>
          <target state="translated">[libs]</target>
        </trans-unit>
        <trans-unit id="0a5387e3c9cf9ab97fc0bf23e3269594e185c36d" translate="yes" xml:space="preserve">
          <source>[lints]</source>
          <target state="translated">[lints]</target>
        </trans-unit>
        <trans-unit id="83f3a6281fb9adf03bf77c91402ae0e931ccb966" translate="yes" xml:space="preserve">
          <source>[options]</source>
          <target state="translated">[options]</target>
        </trans-unit>
        <trans-unit id="5342d8199f9eb9d08f90a284e8dd1dc7804a74f9" translate="yes" xml:space="preserve">
          <source>[untyped]</source>
          <target state="translated">[untyped]</target>
        </trans-unit>
        <trans-unit id="82269fe5787de6e7ec27fcc12d83c2cbb09336c3" translate="yes" xml:space="preserve">
          <source>[version]</source>
          <target state="translated">[version]</target>
        </trans-unit>
        <trans-unit id="a1024232bfedfebb6aacd740ffd636d6f41a840a" translate="yes" xml:space="preserve">
          <source>and now</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e7db6313c704fbd26e0ba32bef954b2e977a24" translate="yes" xml:space="preserve">
          <source>and spread that into the &lt;code&gt;Props&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc9aa7176523739af8846ebf98bde04cafdfc07" translate="yes" xml:space="preserve">
          <source>and suppose that &lt;code&gt;src/Misc.js&lt;/code&gt; has an incompatible implementation of &lt;code&gt;isLeapYear&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2d7bdbbbacb178e39b0b7c79bfc355baf6b95f" translate="yes" xml:space="preserve">
          <source>and suppress the error. If there is no error on the next line (the suppression is unnecessary), an &amp;ldquo;Unused suppression&amp;rdquo; warning will be shown instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9745abbdcf92eab56732a7d35f17f430c1336bf" translate="yes" xml:space="preserve">
          <source>and then it comes across a &lt;code&gt;package.json&lt;/code&gt; with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0768098259f562a18299b5c17e4ddd6a8b9d9b5b" translate="yes" xml:space="preserve">
          <source>and you try to use Flow v0.21.0, then Flow will immediately error with the message</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca2dbc7b2ac4e20f39f9f3ef522d55252c79cbb" translate="yes" xml:space="preserve">
          <source>broken: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAb2IAuUADsRqMZSwAaUGPVade0AF8A3D36DRYgEwzYc0IpVF1JHFmQaAc0Mab19-AMsbRBpYDR9hcQl3UAAKdFkSdQdpDIBKdwA+UAAeABNkADdQYAKbGLi8B0dktIys8Wc8wpLyqpqo+viAYSYWpURQUBJKaEo6bH0J0AA6VfTXEkQLdRVp2fmsdV8RSkNV5eyXNwtQAB9lKZm5nGx1SCJoabPVpquyC3y8gKSz2z2woAA-CVsspzus5DcaqB1MUmrC1hlEbUgA&quot;&gt;https://flow.org/try&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774e51ee6ebca6e8cb9d7f4d3fe9750f2b9256ae" translate="yes" xml:space="preserve">
          <source>but this doesn&amp;rsquo;t feel very DRY, as we had to explicitly define the suit names twice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e45777a3dd462c6a840e9e356a7099b6982bc19" translate="yes" xml:space="preserve">
          <source>but with &lt;code&gt;$ReadOnlyArray&lt;/code&gt; you can achieve what you were looking for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46438caefd12a0fd432aedcd449aa37d123fa4c1" translate="yes" xml:space="preserve">
          <source>but with a covariant property you can achieve what you were looking for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd55bda6574570ee546195840fdf67842826f24" translate="yes" xml:space="preserve">
          <source>coc.nvim-neovim</source>
          <target state="translated">coc.nvim-neovim</target>
        </trans-unit>
        <trans-unit id="eca0bd3451749c34200b52876c4df81d84e1e7cd" translate="yes" xml:space="preserve">
          <source>doesn&amp;rsquo;t report a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb70bca541e08251da88aa6114a01ea186dc721" translate="yes" xml:space="preserve">
          <source>fixed: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAbwA+xAFygAdiNRjKWADSgxmnXoOgVAXwDcPfoNFiATDNhzQi1RtAkcWMhaAObGNJr+gSFWdtw0sFr+wuISXqAAFOiyJJrO0tkAlF4AfKAAPAAmyABuoMDF9vGJeM4uaZnZueJuhSXlVbX19ohNSQDCTO1ZHjnKaiSU0JR02JoBIpTGAHQ7ee6eNlZzfovLOKugkETQC9u73ftkNkXypUqIoKDIkBnTclsLJYrLBFd6fT5LPBKQFnbB3LbsfzWNJ-Ej2cGgdg4ERYLTlPLKHYIyhIuoND6gZGLBbKCkQyhQmHA+GInDIxSo9HgrE4vFlVqEnas5FDCnWRDWIA&quot;&gt;https://flow.org/try&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406a50ab8f418267ad4cb79f7ec8af3c757e5d1a" translate="yes" xml:space="preserve">
          <source>flow-for-emacs</source>
          <target state="translated">flow-for-emacs</target>
        </trans-unit>
        <trans-unit id="b31ed27db0f3f06537ccbd7e0612af0839145d27" translate="yes" xml:space="preserve">
          <source>flow-remove-types</source>
          <target state="translated">flow-remove-types</target>
        </trans-unit>
        <trans-unit id="bb6bd705fa5bbecd686c0aa80112ee7f1ec636a5" translate="yes" xml:space="preserve">
          <source>flowlint</source>
          <target state="translated">flowlint</target>
        </trans-unit>
        <trans-unit id="1ae5604c6b19edcfc16e8a0c46ddf12d0f3961dd" translate="yes" xml:space="preserve">
          <source>flowlint-line</source>
          <target state="translated">flowlint-line</target>
        </trans-unit>
        <trans-unit id="d424129af5ff1e8c17f038e5baf6afdeaa7378ab" translate="yes" xml:space="preserve">
          <source>flowlint-next-line</source>
          <target state="translated">flowlint-next-line</target>
        </trans-unit>
        <trans-unit id="9523c342f10c383dc3724202de645481a80652c5" translate="yes" xml:space="preserve">
          <source>if you want control at an even finer level than you get from the line-based comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec606816757167e05f48d162279dba3e8be72530" translate="yes" xml:space="preserve">
          <source>is an alias for React.AbstractComponent&amp;lt;Config, any&amp;gt;, which represents a component with config type Config and any instance type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56b448d5548cfe9ad70cc70da30a02c7890ea87" translate="yes" xml:space="preserve">
          <source>or by annotating the exported constant (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBjWA7AzgF1AQwE764CeoAvKANoDku1ANKNQEbUC6iApgB4AOs+HKkw4A5pzSd8AS2QBBQiQBcoBUWIAebDLSiAfOTyLiAOgC2uXgApc5A7gCUQA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="7a4bfa85ec41023a2a32b1cdf3f48b7562fdb4a7" translate="yes" xml:space="preserve">
          <source>ref functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="293bf85b0e8555f44772dd43c5b8cdf5ff5c89b9" translate="yes" xml:space="preserve">
          <source>the left-hand side of an &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1470003cc6f898cdf238607c6ab34328b293da93" translate="yes" xml:space="preserve">
          <source>vim-flow</source>
          <target state="translated">vim-flow</target>
        </trans-unit>
        <trans-unit id="2ad74a5e0937034a00b7730362af6b184bbbc385" translate="yes" xml:space="preserve">
          <source>vscode-flow-ide</source>
          <target state="translated">vscode-flow-ide</target>
        </trans-unit>
        <trans-unit id="0cbdfb85ff349a0802c41f318988e156dfbc0529" translate="yes" xml:space="preserve">
          <source>where as you would otherwise need to export an alias in the &lt;code&gt;import typeof&lt;/code&gt; case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd186b6002ab463466be199db517792bf8202dbe" translate="yes" xml:space="preserve">
          <source>will match a comment like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba826f3eaa4834a5baad670fcedb5ee1f1e012b" translate="yes" xml:space="preserve">
          <source>would still have a sketchy-null-number warning on line 3.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
