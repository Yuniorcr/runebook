<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d651b987b0a7139ea05af6dee8d526234f2fc5bb" translate="yes" xml:space="preserve">
          <source>Type &quot;2 + 5.&quot; in the shell and then press Enter (carriage return). Notice that you tell the shell you are done entering code by finishing with a full stop &quot;.&quot; and a carriage return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58364f896fc728f993e560667ecfb60de4f30fa0" translate="yes" xml:space="preserve">
          <source>Type &quot;a&quot; to leave the Erlang system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5acf833432a1b10201899b4168eeb24706098c" translate="yes" xml:space="preserve">
          <source>Type ::= &lt;code&gt;Fun&lt;/code&gt; | &lt;code&gt;Mod&lt;/code&gt; | &lt;code&gt;App&lt;/code&gt; | &lt;code&gt;Rel&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca7274bab6669941602b10cce52d6006cb9d4c5" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;&quot;GET&quot; | &quot;POST&quot; | &quot;HEAD&quot; | &quot;TRACE&quot;&lt;/code&gt;, that is, the HTTP method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b17bb0639b15e0f667e2fd419629250d1fac8bc" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;[{HeaderKey,HeaderValue}]&lt;/code&gt;. &lt;code&gt;parsed_header&lt;/code&gt; contains all HTTP header fields from the HTTP request stored in a list as key-value tuples. See &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; for a listing of all header fields. For example, the date field is stored as &lt;code&gt;{&quot;date&quot;,&quot;Wed, 15 Oct 1997 14:35:17 GMT&quot;}&lt;/code&gt;. RFC 2616 defines that HTTP is a case-insensitive protocol and the header fields can be in lower case or upper case. &lt;code&gt;httpd&lt;/code&gt; ensures that all header field names are in lower case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ea934d5b010cb0dc7ac9b9cf16bdd13e544370" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;[{InteractionKey,InteractionValue}]&lt;/code&gt; is used to propagate data between modules. Depicted &lt;code&gt;interaction_data()&lt;/code&gt; in function type declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1f7e9e5b0f8e672e72370d1ca9a97b0c0c8e01" translate="yes" xml:space="preserve">
          <source>Type UTF8String is represented as a UTF-8 encoded binary in Erlang. Such binaries can be created directly using the binary syntax or by converting from a list of Unicode code points using function &lt;code&gt;unicode:characters_to_binary/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b347ce4e1bb3f750a45e84a0eec8e47bcbc5d1c" translate="yes" xml:space="preserve">
          <source>Type declarations can also be parameterized by including type variables between the parentheses. The syntax of type variables is the same as Erlang variables, that is, starts with an upper-case letter. Naturally, these variables can - and is to - appear on the RHS of the definition. A concrete example follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6300b103de258ff822aa6629b9e4238dd2a5ce7d" translate="yes" xml:space="preserve">
          <source>Type definitions related to HTTP:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833b41c81d15ae09af14347e83ccba5147adbd10" translate="yes" xml:space="preserve">
          <source>Type definitions that are related to URI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b644ccc50476a72e86f7c39296fad76704713706" translate="yes" xml:space="preserve">
          <source>Type definitions that are used more than once in this module, or abstractions to indicate the intended use of the data type, or both:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cf34335496de985396b3065117c3a7c2a8fa2b" translate="yes" xml:space="preserve">
          <source>Type definitions that are used more than once in this module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb0b5d119973a2ca756d65efb3094aa7a2749aa" translate="yes" xml:space="preserve">
          <source>Type information can be used for the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebeb58712dc090b9f1c0c555b88300efc0c9f1b" translate="yes" xml:space="preserve">
          <source>Type makensis at the bash prompt and you should get a list of options if everything is OK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d444f8eae5fc410e04ffff9e480446db812725" translate="yes" xml:space="preserve">
          <source>Type of lock: &lt;code&gt;rw_mutex&lt;/code&gt;, &lt;code&gt;mutex&lt;/code&gt;, &lt;code&gt;spinlock&lt;/code&gt;, &lt;code&gt;rw_spinlock&lt;/code&gt; or &lt;code&gt;proclock&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1c2b1113b129c21326cea282b309a413da68f9" translate="yes" xml:space="preserve">
          <source>Type tests: &lt;code&gt;is_atom&lt;/code&gt;, &lt;code&gt;is_float&lt;/code&gt;, &lt;code&gt;is_integer&lt;/code&gt;, &lt;code&gt;is_list&lt;/code&gt;, &lt;code&gt;is_number&lt;/code&gt;, &lt;code&gt;is_pid&lt;/code&gt;, &lt;code&gt;is_port&lt;/code&gt;, &lt;code&gt;is_reference&lt;/code&gt;, &lt;code&gt;is_tuple&lt;/code&gt;, &lt;code&gt;is_binary&lt;/code&gt;, &lt;code&gt;is_function&lt;/code&gt;, &lt;code&gt;is_record&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8a72020b7154672a01a7e0906d7d4fb8f5305d" translate="yes" xml:space="preserve">
          <source>Type variables can be used in specifications to specify relations for the input and output arguments of a function. For example, the following specification defines the type of a polymorphic identity function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cf88052e09b9cf4919f33ab2053b176aa31518" translate="yes" xml:space="preserve">
          <source>Types corresponding to RFC 6733 AVP Data Formats. Defined in &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b63cf79ea9c163682784b133c791343ee64d2c" translate="yes" xml:space="preserve">
          <source>Types declared as &lt;code&gt;opaque&lt;/code&gt; represent sets of terms whose structure is not supposed to be visible from outside of their defining module. That is, only the module defining them is allowed to depend on their term structure. Consequently, such types do not make much sense as module local - module local types are not accessible by other modules anyway - and is always to be exported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535782a993effddbcbcaf96e815b800bf2866b08" translate="yes" xml:space="preserve">
          <source>Types describe sets of Erlang terms. Types consist of, and are built from, a set of predefined types, for example, &lt;code&gt;integer()&lt;/code&gt;, &lt;code&gt;atom()&lt;/code&gt;, and &lt;code&gt;pid()&lt;/code&gt;. Predefined types represent a typically infinite set of Erlang terms that belong to this type. For example, the type &lt;code&gt;atom()&lt;/code&gt; denotes the set of all Erlang atoms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4826f9f1cd21548c629153b4f8bdd98bd55b49d6" translate="yes" xml:space="preserve">
          <source>Types that refer to themselves are called recursive types. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c02047b4473ab1d57fc7225f4164216e6bcfaf2" translate="yes" xml:space="preserve">
          <source>Types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f711f90b7022e079d8d5f49cef08ad4c28d080c" translate="yes" xml:space="preserve">
          <source>Typical &lt;code&gt;Reasons&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c8d97f0dcec5fe713e0be3b64521ea6acf59de" translate="yes" xml:space="preserve">
          <source>Typical error reasons are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f629170b36b9e9384cae62822a95fe4136c915d" translate="yes" xml:space="preserve">
          <source>Typical error reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a875996fe6fd67197a25c652eb601e185ed5cc23" translate="yes" xml:space="preserve">
          <source>Typical error reasons: as for &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; if a file had to be opened, and as for &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc74151b7056fe15fd99a84d554133408c7c5852" translate="yes" xml:space="preserve">
          <source>Typical usage when writing to a file descriptor looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0583dc7b5aaef5f34ea3fa51cd6e026a525fd0" translate="yes" xml:space="preserve">
          <source>Typically high &lt;code&gt;time&lt;/code&gt; values are bad and this is often the thing to look for. However, one should also look for high lock acquisition frequencies (#tries) since locks generate overhead and because high frequency could become problematic if they begin to have conflicts even if it is not shown in a particular test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c47ac130c9d90117072288c85fcf5d65c5fe895" translate="yes" xml:space="preserve">
          <source>Typically the operator, possibly running hundreds or thousands of test cases, does not want to fill the console with details about, or printouts from, specific test cases. By default, the operator only sees the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e9960729125226aaee305f3d87924465b5abf5" translate="yes" xml:space="preserve">
          <source>Typically you want to substitute negations first, then aliases, then perform one or more expansions (sometimes you want to pre-expand particular entries before doing the main expansion). You might want to substitute negations and/or aliases repeatedly, to allow such forms in the right-hand side of aliases and expansion lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4535970fd788996603de7fcae8b5b1132c50cf1f" translate="yes" xml:space="preserve">
          <source>Typically, OpenSSL engines provide a hardware implementation of specific cryptographic operations. The hardware implementation usually offers improved performance over its software-based counterpart, which is known as cryptographic acceleration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81772f74c1a9d8da4ff099d810781ce160aacf0" translate="yes" xml:space="preserve">
          <source>Typographic conventions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3d0996d3543e832deef4b0344dd80b1d22ba4d" translate="yes" xml:space="preserve">
          <source>UDP packets from the network</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50aa3ec0f92e35711e8ffb982901d2c7f9850924" translate="yes" xml:space="preserve">
          <source>UDP queries are used unless resolver option &lt;code&gt;usevc&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which forces TCP queries. If the query is too large for UDP, TCP is used instead. For regular DNS queries, 512 bytes is the size limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486c66a0286294375958525f91cdfdb3f82c9cb3" translate="yes" xml:space="preserve">
          <source>URI processing functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d057bddb70164b040386e82de4c64661e29e8f2" translate="yes" xml:space="preserve">
          <source>URI to filename translation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c3521da24366089045fe93222bbbea327aa8ee" translate="yes" xml:space="preserve">
          <source>URI utility module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2497da8c1e8f3017cb461e9ead3580ed94a9004a" translate="yes" xml:space="preserve">
          <source>URL Aliasing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09d741a3ad78a10aeac235b7eda60b472c1c7ea" translate="yes" xml:space="preserve">
          <source>URL aliasing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284501aa026d810fca5e30ec3e6fbb8b907a7d92" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://java.sun.com&quot;&gt;http://java.sun.com&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2390079739ca194b6adba26faaa714759aa93368" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://nsis.sourceforge.net/download&quot;&gt;http://nsis.sourceforge.net/download&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d52349cc271c6019348a86ea4c491c0478f8cdd3" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://openssl.org/community/binaries.html&quot;&gt;http://openssl.org/community/binaries.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0133be96d80a337735afdf94d4b6d5617e90e15" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&quot;&gt;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a52ac449904e56f2f8f4257d980b456503a1c2" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&quot;&gt;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b683663e96daabab32de2bda24157392f5a1dc1c" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://www.cygwin.com&quot;&gt;http://www.cygwin.com&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276871ba1190025d3a896ad5f2648a68709c0037" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&quot;&gt;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f076fb21dd236ea02ee81db09d3c6d1a9c2d70" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;https://msys2.github.io/&quot;&gt;https://msys2.github.io/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c130e8186817488b08e47f250bc88b4918c57145" translate="yes" xml:space="preserve">
          <source>URL:&lt;code&gt;&lt;a href=&quot;http://code.google.com/p/msysgit/&quot;&gt;http://code.google.com/p/msysgit/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0cd56da21e982f4424f294a92af6cffab886e5" translate="yes" xml:space="preserve">
          <source>UTF-8 is designed so that ISO Latin-1 characters with numbers beyond the 7-bit ASCII range are seldom considered valid when decoded as UTF-8. Therefore one can usually use heuristics to determine if a file is in UTF-8 or if it is encoded in ISO Latin-1 (one byte per character). The &lt;code&gt;unicode&lt;/code&gt; module can be used to determine if data can be interpreted as UTF-8:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6328bc9f36f37764a79ddabe4b86ab6e97f09add" translate="yes" xml:space="preserve">
          <source>Ugaritic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2f970d37032e17cb13a44bc956fa4e60bba4ed" translate="yes" xml:space="preserve">
          <source>Unary +</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898ecd6a265af9abef6adb306b4c0c9c0e00c767" translate="yes" xml:space="preserve">
          <source>Unary + - bnot not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684c6ddd5eb8c278f83bc5399212042f5f7e16e9" translate="yes" xml:space="preserve">
          <source>Unary -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637d4f607a8fd2105b314306ae4c76ef4925ad36" translate="yes" xml:space="preserve">
          <source>Unary bitwise NOT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d35054fa41b42db47e25b9d91e662cc93e9f89" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;FormatFun&lt;/code&gt; is used by &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; for displaying the call that created the query handle of the table. Defaults to &lt;code&gt;undefined&lt;/code&gt;, which means that &lt;code&gt;info/1,2&lt;/code&gt; displays a call to &lt;code&gt;'$MOD':'$FUN'/0&lt;/code&gt;. It is up to &lt;code&gt;FormatFun&lt;/code&gt; to present the selected objects of the table in a suitable way. However, if a character list is chosen for presentation, it must be an Erlang expression that can be scanned and parsed (a trailing dot is added by &lt;code&gt;info/1,2&lt;/code&gt; though).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8cf6ea70815c5c8dc6febb5bc34ace0255c96a" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;InfoFun&lt;/code&gt; is to return information about the table. &lt;code&gt;undefined&lt;/code&gt; is to be returned if the value of some tag is unknown:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1442c4ded70572e00f428d9108e7ae55df7a65b5" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;PreFun&lt;/code&gt; is called once before the table is read for the first time. If the call fails, the query evaluation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a92175579f60db68a9c361cc251147f8debf6b0" translate="yes" xml:space="preserve">
          <source>Unary logical NOT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bb4c7fe8d37999952aa5b0af1c3595bd259bdb" translate="yes" xml:space="preserve">
          <source>UnaryGraphOp ::= &lt;code&gt;components&lt;/code&gt; | &lt;code&gt;condensation&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01c0a17c153449bd9a04099f8971f3292a601fb" translate="yes" xml:space="preserve">
          <source>UnarySetOp ::= &lt;code&gt;domain&lt;/code&gt; | &lt;code&gt;range&lt;/code&gt; | &lt;code&gt;strict&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57016edceec7e7b4449fe027bb35d1ba319eb9f" translate="yes" xml:space="preserve">
          <source>Unassigned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8707e2ffeef5fa8b41de5e679969a877cb9db6f0" translate="yes" xml:space="preserve">
          <source>Unblocks a log. A log can only be unblocked by the blocking process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe39591d424d43f7cc9d6d4ca1303c1c24c48eab" translate="yes" xml:space="preserve">
          <source>Unbound and unsafe variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13fe86cfdf1fdbc7031b4349a4b6f2fc354ab38" translate="yes" xml:space="preserve">
          <source>Uncompressed Size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4c7b6c3e87ff86f41e836e792f67b6c2bdf902" translate="yes" xml:space="preserve">
          <source>Uncompressed size (unsigned 32-bit integer in big-endian byte order) is the size of the data before it was compressed. The compressed data has the following format when it has been expanded:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848b92d8de0252bd79df355552090abc0668ced9" translate="yes" xml:space="preserve">
          <source>Uncompresses data with gz headers and checksum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79897564d08477a4d49effa829f40061f9569280" translate="yes" xml:space="preserve">
          <source>Uncompresses data with zlib headers and checksum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad0694c3152ef1643cde8ba2d996a0323a6b4d2" translate="yes" xml:space="preserve">
          <source>Uncompresses data without zlib headers and checksum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c0570481ff7f3e6ed039d51cc86442ea076a33" translate="yes" xml:space="preserve">
          <source>Undefined thread that is not a scheduler thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7aa71224a65884ef564916a9d0da2f89835d7d4" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;$ROOT/releases&lt;/code&gt;, a new directory &lt;code&gt;B&lt;/code&gt; is created, containing &lt;code&gt;ch_rel-2.rel&lt;/code&gt;, &lt;code&gt;start.boot&lt;/code&gt;, &lt;code&gt;sys.config&lt;/code&gt;, and &lt;code&gt;relup&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db2e4f4f838b5c44fe9cf387c90abe7108283e8" translate="yes" xml:space="preserve">
          <source>Under Windows, batch file &lt;code&gt;etop.bat&lt;/code&gt; can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3264cd9d9eb75df44ac7458f032202c1c187eb3e" translate="yes" xml:space="preserve">
          <source>Under Windows, the batch file &lt;code&gt;cdv.bat&lt;/code&gt; can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c9e5a121880663dee4769e1af65faa7b494736" translate="yes" xml:space="preserve">
          <source>Under a key, any number of named values can be stored. They have names, types, and data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8f3b0e81b0f054de52ff314e53658c55941c1a" translate="yes" xml:space="preserve">
          <source>Under certain circumstances incompatible changes might be introduced even in parts of the system that should be compatible between releases. Things that might trigger incompatible changes like this are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572aa08aba747d5d8b7a4a50d789147e2afaec76" translate="yes" xml:space="preserve">
          <source>Under the &lt;strong&gt;Warnings&lt;/strong&gt; pull-down menu, there are buttons that control which discrepancies are reported to the user in the &lt;strong&gt;Warnings&lt;/strong&gt; window. By clicking these buttons, you can enable/disable a whole class of warnings. Information about the classes of warnings is found on the &quot;Warnings&quot; item under the &lt;strong&gt;Help&lt;/strong&gt; menu (in the rightmost top corner).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6ad23ca12e3d31111c9342b18cb40e19aa690d" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocated_areas&lt;/strong&gt; is shown information similar to what can be obtained on a living node with &lt;code&gt;erlang:system_info(allocated_areas)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c5641fd04e324ff84f71ed58f45687d78170d8" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocator:&amp;lt;A&amp;gt;&lt;/strong&gt; is shown various information about allocator &amp;lt;A&amp;gt;. The information is similar to what can be obtained on a living node with &lt;code&gt;erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt;. For more information, see also &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d37cd225e87fcc610bec30b5a05911619436d89" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=memory&lt;/strong&gt; is shown information similar to what can be obtainted on a living node with &lt;code&gt;erlang:memory()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ce4685b2bc584945411c035f09d36043b054a2" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=scheduler&lt;/strong&gt; is shown information about the current state and statistics of the schedulers in the runtime system. On operating systems that allow suspension of other threads, the data within this section reflects what the runtime system looks like when a crash occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4dc6bd20baf250db6e40693e866b1962ff4e8bc" translate="yes" xml:space="preserve">
          <source>Under the tags &lt;strong&gt;=hash_table:&amp;lt;table_name&amp;gt;&lt;/strong&gt; and &lt;strong&gt;=index_table:&amp;lt;table_name&amp;gt;&lt;/strong&gt; is shown internal tables. These are mostly of interest for runtime system developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc501eac2fcb3163225e3af20fdf997e537c7a6" translate="yes" xml:space="preserve">
          <source>Undocumented (old) algorithms are deprecated but still implemented so old code relying on them will produce the same pseudo random sequences as before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87e34279dd28e6f111c12cefa204d1bbe4761338" translate="yes" xml:space="preserve">
          <source>Undocumented functions in this module are not to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196d8f0f66ad490a457b6fb5d6806ec3993a5c10" translate="yes" xml:space="preserve">
          <source>Unfolds all occurrences of atoms in &lt;code&gt;ListIn&lt;/code&gt; to tuples &lt;code&gt;{Atom, true}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab34ddc2bf3b987c39e2558abfd1de510704f88" translate="yes" xml:space="preserve">
          <source>Unicode binary encoded as UTF16 little endian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9476616408be8ddee79977abc7989cebfe910910" translate="yes" xml:space="preserve">
          <source>Unicode filename translation is turned on with switch &lt;code&gt;+fnu&lt;/code&gt;. On Linux, a VM started without explicitly stating the filename translation mode defaults to &lt;code&gt;latin1&lt;/code&gt; as the native filename encoding. On Windows and MacOS X, the default behavior is that of Unicode filename translation. Therefore &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; by default returns &lt;code&gt;utf8&lt;/code&gt; on those systems (Windows does not use UTF-8 on the file system level, but this can safely be ignored by the Erlang programmer). The default behavior can, as stated earlier, be changed using option &lt;code&gt;+fnu&lt;/code&gt; or &lt;code&gt;+fnl&lt;/code&gt; to the VM, see the &lt;code&gt;erl&lt;/code&gt; program. If the VM is started in Unicode filename translation mode, &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns atom &lt;code&gt;utf8&lt;/code&gt;. Switch &lt;code&gt;+fnu&lt;/code&gt; can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; to control how wrongly encoded filenames are to be reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988784de449d7b8cbc0704eff09bcd0c69371d5a" translate="yes" xml:space="preserve">
          <source>Unicode is a standard defining code points (numbers) for all known, living or dead, scripts. In principle, every symbol used in any language has a Unicode code point. Unicode code points are defined and published by the Unicode Consortium, which is a non-profit organization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753a9fc18dc38abc9e40310e1511762a587d6d68" translate="yes" xml:space="preserve">
          <source>Unicode metadata stored in PAX headers is preserved</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717d423333854e072ef433389e96fff5bd03e76d" translate="yes" xml:space="preserve">
          <source>Unicode support is basically UTF-8 based. To use Unicode characters, you either call &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; with option &lt;code&gt;unicode&lt;/code&gt;, or the pattern must start with one of these special sequences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9619f5cd0ede72c7dc62df2d3b5ff34d2c75b610" translate="yes" xml:space="preserve">
          <source>Uniform floats had a non-uniform density so small values i.e less than 0.5 had got smaller intervals decreasing as the generated value approached 0.0 although still uniformly distributed for sufficiently large subranges. The new algorithms produces uniformly distributed floats on the form N * 2.0^(-53) hence equally spaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4488ef1f56a2d01fb6e741f79e8378c71279a1d3" translate="yes" xml:space="preserve">
          <source>Uniform integer ranges had a skew in the probability distribution that was not noticable for small ranges but for large ranges less than the generator's precision the probability to produce a low number could be twice the probability for a high.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adabbdf2f0cec9c6d0d246d5a204f96b7e74b355" translate="yes" xml:space="preserve">
          <source>Uniform integer ranges larger than or equal to the generator's precision used a floating point fallback that only calculated with 52 bits which is smaller than the requested range and therefore were not all numbers in the requested range even possible to produce.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e839dc7592fa37041cd55253f794215f4f6c06" translate="yes" xml:space="preserve">
          <source>Union of &lt;code&gt;rsa_digest_type()&lt;/code&gt;, &lt;code&gt;dss_digest_type()&lt;/code&gt;, and &lt;code&gt;ecdsa_digest_type()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a878275b775589505d998070ad22ad6d0081609" translate="yes" xml:space="preserve">
          <source>Unique Integers on a Runtime System Instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2cc5144e25dba2fec68e539fbd788a730b7301a" translate="yes" xml:space="preserve">
          <source>Unique References on a Runtime System Instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a306f316fd3f985303c362b8053185a26f2e0d45" translate="yes" xml:space="preserve">
          <source>Unique identifier for the application in the scope of the service. Defaults to the value of the &lt;code&gt;dictionary&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5724b00a081ae3e8a4cc6f50314a3e776bc6f0d2" translate="yes" xml:space="preserve">
          <source>Unit Testing is testing of individual program &quot;units&quot; in relative isolation. There is no particular size requirement: a unit can be a function, a module, a process, or even a whole application, but the most typical testing units are individual functions or modules. In order to test a unit, you specify a set of individual tests, set up the smallest necessary environment for being able to run those tests (often, you don't need to do any setup at all), you run the tests and collect the results, and finally you do any necessary cleanup so that the test can be run again later. A Unit Testing Framework tries to help you in each stage of this process, so that it is easy to write tests, easy to run them, and easy to see which tests failed (so you can fix the bugs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9caddb3cd5b7265345df4fab350e48f214540b46" translate="yes" xml:space="preserve">
          <source>Universal Time. UT1 is based on the rotation of the earth and conceptually means solar time at 0&amp;deg; longitude.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fdab77a1c02655cb90e9076adda573749aee76" translate="yes" xml:space="preserve">
          <source>Universaltime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fd69818de3f9565ba68951c5c09c08312d1123" translate="yes" xml:space="preserve">
          <source>Unix 'tar' utility for reading and writing tar archives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c497be34c3d12775e6c6e249a2bb96e5096e4688" translate="yes" xml:space="preserve">
          <source>Unix example: &lt;code&gt;/usr/local/bin&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52db1f36f26e76a3a2c634008d80678e33f56bbd" translate="yes" xml:space="preserve">
          <source>Unknown Functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20270332ab7fc1d7887105b864abda119f91200" translate="yes" xml:space="preserve">
          <source>Unknown Modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c65364e9fb4489250a3ae7948a13788521c35e" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a traversal can fail if concurrent updates are made to the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function returns a list containing object &lt;code&gt;I&lt;/code&gt; in Erlang term order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdfb6336f1dc28fe44fc86849dcd9997db099f2" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a traversal can fail if concurrent updates are made to the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function returns the next key in order, even if the object does no longer exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743984ff40a29e25f3a91777282531a480bea68e" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified by the options, all modules are assumed to be at least &quot;static&quot;, and all except the target module are assumed to be &quot;safe&quot;. See the &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;safe&lt;/code&gt; options for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd12a82bf92d67e237725f9648f0226fb3bb44f" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified the return value type and encoding are the same as the input type and encoding. That is, binary input returns binary output, list input returns a list output but mixed input returns list output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2452df07cb8ca79cfe0600811352c2e7e3686be8" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified the return value type is the same as the input type. That is, binary input returns binary output, list input returns a list output, and mixed input can return a mixed output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3df395f5cdf2fa36eee4743206fa60a6a1a66c2" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, leading whitespace is ignored for all control sequences. An input field cannot be more than one line wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1cc2b0ee63b4df93cb4cef8c16bee9110c56a5" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, the order of the registered filters will be the order in which they are registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="336e16f5b15c1bb3924a2d4ee1f281da2f5d2f39" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions assume that position numbering starts at 1. That is, the first element of a list is at position 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5744f08804fbcbd546e4dfc2b0e6fcafee559f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified &lt;code&gt;gen_server&lt;/code&gt; process does not exist or if bad arguments are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f0b9bf676eb2bfd97e1ca14eb9192d3876198f" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified &lt;code&gt;gen_statem&lt;/code&gt; does not exist or if bad arguments are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2130ed65fd03b5efa6f9266bb204f3dc0f269a98" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified event manager does not exist or if bad arguments are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ecf2431ac506145df210d3f762df7ef9ac568e" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified supervisor bridge does not exist or if bad arguments are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6e960d5712a50515c10d0e5588263e19e9ce6b" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified supervisor does not exist or if bad arguments are specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c7ee08644b98d18eca27766dd86d186eaca4f73" translate="yes" xml:space="preserve">
          <source>Unless specified by the user when the array is created, the default value is the atom &lt;code&gt;undefined&lt;/code&gt;. There is no difference between an unset entry and an entry that has been explicitly set to the same value as the default one (compare &lt;code&gt;&lt;a href=&quot;#reset-2&quot;&gt;reset/2&lt;/a&gt;&lt;/code&gt;). If you need to differentiate between unset and set entries, ensure that the default value cannot be confused with the values of set entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd13caf6027b189cef2a36a20e0fd13e56485aad" translate="yes" xml:space="preserve">
          <source>Unless the file name is absolute, the file is first searched for relative to the current directory, and then using the normal search path (&lt;code&gt;code:get_path()&lt;/code&gt;). This means that the names of typical &quot;app&quot; files can be used directly, without a path, e.g., &lt;code&gt;&quot;mnesia.app&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a837b10265d2be2c9f800bf253594222b1cdf6" translate="yes" xml:space="preserve">
          <source>Unless the table is protected using &lt;code&gt;safe_fixtable/2&lt;/code&gt;, calls to &lt;code&gt;bchunk/2&lt;/code&gt; do possibly not work as expected if concurrent updates are made to the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec243991d25d3f676894294544e13f5bc4cfeae2" translate="yes" xml:space="preserve">
          <source>Unless the table is protected using &lt;code&gt;safe_fixtable/2&lt;/code&gt;, subsequent calls to &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; do possibly not work as expected if concurrent updates are made to the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c55317241e5b2c59b25e3b0df5f88453b5f333" translate="yes" xml:space="preserve">
          <source>Unless the value is &lt;code&gt;none&lt;/code&gt;, the given function is called for each node whose list of annotations is not empty; see below for details. The default value is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdff867eb339963be03bd21021856778c904302c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0&lt;/a&gt;&lt;/code&gt;, Ifname is encoded a binary. In the unlikely case that a system is using non-7-bit-ASCII characters in network device names, special care has to be taken when encoding this argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5c0bd0a60e997d1705e91f30f45cde14782afc" translate="yes" xml:space="preserve">
          <source>Unlike data tables, information in schema tables can only be accessed and modified by using the schema-related functions described in this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315fbdc2014934db1db457f44c68e1cf848dbeb6" translate="yes" xml:space="preserve">
          <source>Unlike in &quot;plain Erlang&quot;, &lt;code&gt;proc_lib&lt;/code&gt; processes will not generate &lt;strong&gt;error reports&lt;/strong&gt;, which are written to the terminal by the emulator. All exceptions are converted to &lt;strong&gt;exits&lt;/strong&gt; which are ignored by the default &lt;code&gt;logger&lt;/code&gt; handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0b46a073145149fc17e2f042255d68220cd4a4" translate="yes" xml:space="preserve">
          <source>Unload &lt;code&gt;Mibs&lt;/code&gt; from an agent. If it cannot unload all MIBs (the default value of the &lt;code&gt;Force&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;), it will indicate where unloading was aborted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b2dca21a4f55d7d0fa16561ba72c0a5a938d9c" translate="yes" xml:space="preserve">
          <source>Unload a &lt;code&gt;Mib&lt;/code&gt; from the manager. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318d9f4d5f03a67d10200c73fcad432663d2f29b" translate="yes" xml:space="preserve">
          <source>Unload a single &lt;code&gt;Mib&lt;/code&gt; from an agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769b903ce1d90a72efda3ccafb33dcd1f3d777a4" translate="yes" xml:space="preserve">
          <source>Unload the mib specified by the &lt;code&gt;Filename&lt;/code&gt; argument from the mib-server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd4c00f912e6ef2189a832da23d9650d2872c8c" translate="yes" xml:space="preserve">
          <source>Unloading can be described as the process of telling the emulator that this particular part of the code in this particular process (that is, this &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;) no longer needs the driver. That can, if there are no other users, trigger unloading of the driver, in which case the driver name disappears from the system and (if possible) the memory occupied by the driver executable code is reclaimed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7779518675ffce53110af3008d7744e065e1a5f3" translate="yes" xml:space="preserve">
          <source>Unloads the MIBs from agent &lt;code&gt;snmp_master_agent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a3d6a062d2d5ee9eda88a5ecd1085fce084994" translate="yes" xml:space="preserve">
          <source>Unloads the OTP-MIB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48f8e606621c6fa11b525d4c336815899ff648e" translate="yes" xml:space="preserve">
          <source>Unloads the OTP-OS-MON-MIB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ed8242b3b1b71902fb9d376310f5c95786abfe" translate="yes" xml:space="preserve">
          <source>Unloads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt;. An error tuple is returned if the engine can't be unloaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cff9e0ced01393a829b38eaa7e0451df21ea9d5" translate="yes" xml:space="preserve">
          <source>Unloads the application specification for &lt;code&gt;Application&lt;/code&gt; from the application controller. It also unloads the application specifications for any included applications. Notice that the function does not purge the Erlang object code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351a6f889a5ded537e77bca6799737838e6f4f76" translate="yes" xml:space="preserve">
          <source>Unloads, or at least dereferences the driver named &lt;code&gt;Name&lt;/code&gt;. If the caller is the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, all remaining open ports using the driver are killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt; and the driver eventually gets unloaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2061febf2aa265ba0d12f05d42293814e13d57b8" translate="yes" xml:space="preserve">
          <source>Unloads, or at least dereferences the driver named &lt;code&gt;Name&lt;/code&gt;. If the caller is the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, and no more open ports use the driver, the driver gets unloaded. Otherwise, unloading is delayed until all ports are closed and no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; remain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ad66e7caef87bb85f8df32ab5caabf7bf35995" translate="yes" xml:space="preserve">
          <source>Unlocks a mutex. The mutex currently must be locked by the calling thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9b1fba9416c1278f7484dce6e469b9ce20199f" translate="yes" xml:space="preserve">
          <source>Unlocks the configuration target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19786a83cc46632e0d13d564e393de3e1de085fe" translate="yes" xml:space="preserve">
          <source>Unlocks the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e529736ebba8b22ec528fcbede64fa669b39cc8" translate="yes" xml:space="preserve">
          <source>Unordered sending is configurable in &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp(3)&lt;/a&gt;&lt;/code&gt;. There is no special handling of DPR/DPA: since a user that cares about pending answers should wait for them before initiating DPR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdfeac47c5892b6d5954da0f63cd683192cebcee" translate="yes" xml:space="preserve">
          <source>Unordered sets and ordered sets are orthogonal, again in this module; there is no unordered set equal to any ordered set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0315bcb1361b2c68fa29fded47a0e3b15d0b5028" translate="yes" xml:space="preserve">
          <source>Unpacking and Installation of Release Packages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b45b03b4626e1a53bac859dec0524861ec0a57e" translate="yes" xml:space="preserve">
          <source>Unpacks a release package &lt;code&gt;Name.tar.gz&lt;/code&gt; located in the &lt;code&gt;releases&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a99a056cf6ecaf575d784978bf9746e5f0db64d" translate="yes" xml:space="preserve">
          <source>Unrecognized options are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e8f759a055d6a9097dc478f2320ca3772d6837" translate="yes" xml:space="preserve">
          <source>Unrecognized options are silently ignored but are returned unmodified by &lt;code&gt;&lt;a href=&quot;#service_info-2&quot;&gt;service_info/2&lt;/a&gt;&lt;/code&gt; and can be referred to in predicate functions passed to &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf136da00ab173645906b6446844bfeeb401e42" translate="yes" xml:space="preserve">
          <source>Unrecognized options are silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0b20da3e0471bc484aaa9c62ebfd991d58e416" translate="yes" xml:space="preserve">
          <source>Unregister a notification filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e280e10a8485894674391e4d6645db6545aff52" translate="yes" xml:space="preserve">
          <source>Unregister a sub-agent. If the second argument is a pid, then that sub-agent will be unregistered from all trees in &lt;code&gt;Agent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03ca80c8e4fbe50cea94aadfa5356b1cefa6ea2" translate="yes" xml:space="preserve">
          <source>Unregister the agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f3dba02392fc14b01a49c5237fb9ba133abd12" translate="yes" xml:space="preserve">
          <source>Unregister the subagent, handling part of the mib-tree, as specified by the &lt;code&gt;oid()&lt;/code&gt; or &lt;code&gt;pid()&lt;/code&gt; (&lt;code&gt;PidOrOid&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8277a7a1c1b3585ee2c7d6442d480190db4efc" translate="yes" xml:space="preserve">
          <source>Unregister the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a27c51fcd7b00626a6adb2154cd8c213ef4ec1" translate="yes" xml:space="preserve">
          <source>Unregister this USM user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d7b4bee0a41ee99a7b5f42eb631d46c2797262" translate="yes" xml:space="preserve">
          <source>Unregisters a name from &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778ebac023e85b1f0510378d21c9e5c1fcf345ea" translate="yes" xml:space="preserve">
          <source>Unregisters all USM users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c58e843a4c38141952ae3478058bdba2218974e" translate="yes" xml:space="preserve">
          <source>Unregisters all managed agents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246367dd21663f20ce31444da8332f55bea35d97" translate="yes" xml:space="preserve">
          <source>Unregisters all users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c40ce96fa1e83b3bd9616363397a86b832aa70" translate="yes" xml:space="preserve">
          <source>Unregisters the crypto key fun and terminates the process holding it, started by &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5ba8d70542c76fd25b8d56f14442cbc2255390" translate="yes" xml:space="preserve">
          <source>Unregisters the specified USM users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d1e628f578a9203fd5dd6ce46d237fc06cee37" translate="yes" xml:space="preserve">
          <source>Unregisters the specified managed agents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35f5d367e4318dedf6e9eecba89fb487eb5ab44" translate="yes" xml:space="preserve">
          <source>Unregisters the specified users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39827e01c383c5bfbd3766c32b34efde1bf35451" translate="yes" xml:space="preserve">
          <source>Unresolved Calls. Empty in &lt;code&gt;modules&lt;/code&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f30d44760477c48d3263ea185339929d64ed8c" translate="yes" xml:space="preserve">
          <source>Unresolved calls make module data incomplete, which implies that the results of analyses may be invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d813c57ac643b33b15704ddfaac2f69f436d7ab" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c196c4cb59b173e8333c1a8a5df703d2addbca5b" translate="yes" xml:space="preserve">
          <source>Unspecified connection shutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ba21b928bd868bd499fdc4e16f1fbae6b293bf" translate="yes" xml:space="preserve">
          <source>Unsticks a directory that is marked as sticky.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2277446510c2f9009fdeac95bbe80a1168ba956b" translate="yes" xml:space="preserve">
          <source>Unsubscribe to event messages from a service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf5dcc3da0cf64b87e972ea01a22a51c15d8495" translate="yes" xml:space="preserve">
          <source>Unused Functions (*). All local and exported functions of analyzed modules that have not been used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48532263f2300b60babe28fff5fbbc91ed7d708c" translate="yes" xml:space="preserve">
          <source>Unused functions and imports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b3d935e2fe5c05c6efefdff41786dcbb306041" translate="yes" xml:space="preserve">
          <source>Unused variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7745c954ca016fa895b408f407a03e565617f6b" translate="yes" xml:space="preserve">
          <source>Up to five log files at maximum 100 KB each with the content of the standard streams from and to the command. (Both the number of logs and sizes can be changed by environment variables, see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd274c7d6098a1a4d8932d92e9e158a8e9dd4b8" translate="yes" xml:space="preserve">
          <source>Up to now, examples of a number of functions that can be used inside a transaction have been shown. The following list shows the &lt;strong&gt;simplest&lt;/strong&gt;&lt;code&gt;Mnesia&lt;/code&gt; functions that work with transactions. Notice that these functions must be embedded in a transaction. If no enclosing transaction (or other enclosing &lt;code&gt;Mnesia&lt;/code&gt; activity) exists, they all fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b4c751d26980e5035738b359c986debcfcf4b4" translate="yes" xml:space="preserve">
          <source>Up until ERTS version 8.*, the check process code operation checks for all types of references to the old code. That is, direct references (e.g. return addresses on the process stack), indirect references (&lt;code&gt;fun&lt;/code&gt;s in process context), and references to literals in the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2624bab6b3cfd68919c56a6d5e5cfd349d334b" translate="yes" xml:space="preserve">
          <source>Update a value in a &lt;code&gt;Map1&lt;/code&gt; associated with &lt;code&gt;Key&lt;/code&gt; by calling &lt;code&gt;Fun&lt;/code&gt; on the old value to get a new value. An exception &lt;code&gt;{badkey,Key}&lt;/code&gt; is generated if &lt;code&gt;Key&lt;/code&gt; is not present in the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9b1268f0c338627a3b15658c74da637dde057f" translate="yes" xml:space="preserve">
          <source>Update a value in a &lt;code&gt;Map1&lt;/code&gt; associated with &lt;code&gt;Key&lt;/code&gt; by calling &lt;code&gt;Fun&lt;/code&gt; on the old value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in &lt;code&gt;Map1&lt;/code&gt; then &lt;code&gt;Init&lt;/code&gt; will be associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2fca097e563aa25bfd5fb033663686a751ded2" translate="yes" xml:space="preserve">
          <source>Update agent config. The function &lt;code&gt;update_agent_info/3&lt;/code&gt; should be used when several values needs to be updated atomically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65320d77653af5410845622a9ee939279e72f69" translate="yes" xml:space="preserve">
          <source>Update an MD5 &lt;code&gt;Context&lt;/code&gt; with &lt;code&gt;Data&lt;/code&gt; and returns a &lt;code&gt;NewContext&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c23ed960405748d119e2cf48c12e3dfbd628b3" translate="yes" xml:space="preserve">
          <source>Update configuration data for the specified handler. This function behaves as if it was implemented as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe58a4200c84c77e18dad55e69d7d322faa4c745" translate="yes" xml:space="preserve">
          <source>Update information about a user</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312c6091d8eac0e5b07d6cd16487ac2bd404f20a" translate="yes" xml:space="preserve">
          <source>Update information about an active connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe0611d972ddd201356bf6556896ed52b2f48ec" translate="yes" xml:space="preserve">
          <source>Update primary configuration data for Logger. This function behaves as if it was implemented as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764a554dd6a058f4ee8b2a49aff080d148edb108" translate="yes" xml:space="preserve">
          <source>Update the application version number in the &lt;code&gt;.app&lt;/code&gt; file and write an &lt;code&gt;.appup&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2e0eab67dde01477b9adecadae6f860b5f68c2" translate="yes" xml:space="preserve">
          <source>Update the connection info protocol_version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae0552d56ac843dfab3a0e0e90394739c437be4" translate="yes" xml:space="preserve">
          <source>Update the formatter configuration for the specified handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12a74739554e4908ca08a51e98ff68b92ec211d" translate="yes" xml:space="preserve">
          <source>Update the receive handle of the control process (e.g. after having changed protocol version).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff8cf55883e7040256c251d18a9776b47973fa6" translate="yes" xml:space="preserve">
          <source>Update the receive handle with the encoding-config (the &lt;code&gt;encoding_config&lt;/code&gt; field).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e75d0ad461333a3e5a1fa13055100c26a0e7bc" translate="yes" xml:space="preserve">
          <source>Update usm user config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff39bab1bf1708cca0909e3396800e9779cd838" translate="yes" xml:space="preserve">
          <source>Updates &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is present in the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce52fdc3093dff8fef11813ce4ce3d448b0c6f2e" translate="yes" xml:space="preserve">
          <source>Updates a running Adler-32 checksum for &lt;code&gt;Data&lt;/code&gt;. If &lt;code&gt;Data&lt;/code&gt; is the empty binary or the empty iolist, this function returns the required initial value for the checksum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a616ffbea893cd0d7caf81f5c475e558b40da3" translate="yes" xml:space="preserve">
          <source>Updates a running CRC checksum for &lt;code&gt;Data&lt;/code&gt;. If &lt;code&gt;Data&lt;/code&gt; is the empty binary or the empty iolist, this function returns the required initial value for the CRC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d39f7d480179f5db485862d26b6c6e7aed7b81" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. An exception is generated if &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab59d74f46080461c39369f0019171f2f23af955" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Initial&lt;/code&gt; is stored as the first value. For example, &lt;code&gt;append/3&lt;/code&gt; can be defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6a761f1dc7fcd9496ff0fc00ba409b036ce20c" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Initial&lt;/code&gt; is stored as the first value. For example, &lt;code&gt;append/3&lt;/code&gt; can be defined as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c90a4670b3f9486158db598e8de0114e5577be" translate="yes" xml:space="preserve">
          <source>Updates an accumulator by applying &lt;code&gt;Fun&lt;/code&gt; on each collection of annotations of the &lt;code&gt;erl_parse&lt;/code&gt; tree &lt;code&gt;Abstr&lt;/code&gt;. The first call to &lt;code&gt;Fun&lt;/code&gt; has &lt;code&gt;AccIn&lt;/code&gt; as argument, the returned accumulator &lt;code&gt;AccOut&lt;/code&gt; is passed to the next call, and so on. The final value of the accumulator is returned. The &lt;code&gt;erl_parse&lt;/code&gt; tree is traversed in a depth-first, left-to-right fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ebcf826afc7224f3463dd215eb5352561a6434" translate="yes" xml:space="preserve">
          <source>Updates information about debugged processes. Information about all terminated processes are removed from the window. All Attach Process windows for terminated processes are closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4db32f627e995a84c52631b1bbbde821d611764" translate="yes" xml:space="preserve">
          <source>Updates the HMAC represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt; must have been generated using an HMAC init function (such as &lt;code&gt;&lt;a href=&quot;#hmac_init-2&quot;&gt;hmac_init&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt; must be passed into the next call to &lt;code&gt;hmac_update&lt;/code&gt; or to one of the functions &lt;code&gt;&lt;a href=&quot;#hmac_final-1&quot;&gt;hmac_final&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#hmac_final_n-2&quot;&gt;hmac_final_n&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc7f14f3a3fed19f2f8c9a020605209d8a12c68" translate="yes" xml:space="preserve">
          <source>Updates the digest represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt; must have been generated using &lt;code&gt;&lt;a href=&quot;#hash_init-1&quot;&gt;hash_init&lt;/a&gt;&lt;/code&gt; or a previous call to this function. &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt; must be passed into the next call to &lt;code&gt;hash_update&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#hash_final-1&quot;&gt;hash_final&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a37f581698786fafdf7275742d9f7c793868104" translate="yes" xml:space="preserve">
          <source>Updates the hook function field of the prettyprinter context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e71d06680882c2ec32b2dc6bea400636a79824" translate="yes" xml:space="preserve">
          <source>Updates the line widh field of the prettyprinter context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a0436ed02af4ad242287fe8c27e31aafc0067b" translate="yes" xml:space="preserve">
          <source>Updates the object with key &lt;code&gt;Key&lt;/code&gt; stored in table &lt;code&gt;Name&lt;/code&gt; of type &lt;code&gt;set&lt;/code&gt; by adding &lt;code&gt;Incr&lt;/code&gt; to the element at the &lt;code&gt;Pos&lt;/code&gt;:th position. The new counter value is returned. If no position is specified, the element directly following the key is updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b81e579810979a583fac3a15071ea6d7e0648e" translate="yes" xml:space="preserve">
          <source>Updates the operator precedence field of the prettyprinter context. See the &lt;code&gt;erl_parse(3)&lt;/code&gt; module for operator precedences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d2d102522483d5460d1744c9d5282ecfc3df2b" translate="yes" xml:space="preserve">
          <source>Updates the paper widh field of the prettyprinter context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9326e8e858c536ca9e794bc54c6e439dd4f44b" translate="yes" xml:space="preserve">
          <source>Updates the user data field of the prettyprinter context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb57e471df554364292c825fe5e79967d1cd792b" translate="yes" xml:space="preserve">
          <source>Updating a map has a similar syntax as constructing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ccacf954181a7d1504665a82641050052eb900" translate="yes" xml:space="preserve">
          <source>Upgrade the connection associated with &lt;code&gt;Handle&lt;/code&gt; to a tls connection if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4651bcfd7cc66e9b643622e9b6fa5cf9be97fb" translate="yes" xml:space="preserve">
          <source>Upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, connected socket to an TLS socket, that is, performs the client-side TLS handshake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0885a1400bd730b033aa9a97c94e31cdcc2976c9" translate="yes" xml:space="preserve">
          <source>Upgrades an application &lt;code&gt;App&lt;/code&gt; from the current version to a new version located in &lt;code&gt;Dir&lt;/code&gt; according to the &lt;code&gt;.appup&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe465284017475712d39dd7e9e97f804a2375abf" translate="yes" xml:space="preserve">
          <source>Upon failure to reopen the log, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Error},[{disk_log,Fun,Arity}]}&lt;/code&gt;. Other processes having requests queued receive the message &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313cdf1a747cf13f7fb3ba0b75e218a96c2914cd" translate="yes" xml:space="preserve">
          <source>Uppercase letter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655dc371ef84593d2a9260f8648168e35e59595a" translate="yes" xml:space="preserve">
          <source>Uppercase letters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42df97f2f6a736b6736486799c452f7ab2ae5c74" translate="yes" xml:space="preserve">
          <source>Uppercase letters signify real identifiers and lowercase letters signify fake identifiers only used for description of the topology. Identifiers passed as real identifiers can be used by the runtime system when trying to access specific hardware; if they are incorrect the behavior is undefined. Faked logical CPU identifiers are not accepted, as there is no point in defining the CPU topology without real logical CPU identifiers. Thread, core, processor, and node identifiers can be omitted. If omitted, the thread ID defaults to &lt;code&gt;t0&lt;/code&gt;, the core ID defaults to &lt;code&gt;c0&lt;/code&gt;, the processor ID defaults to &lt;code&gt;p0&lt;/code&gt;, and the node ID is left undefined. Either each logical processor must belong to only one NUMA node, or no logical processors must belong to any NUMA nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19370c86dcca239b2f891f36eb2a0c4f475f930f" translate="yes" xml:space="preserve">
          <source>Uri data types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9af3bf645c9bf6cb6b56eedb88807aad3f66ae" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#change_key-2&quot;&gt;change_key/2&lt;/a&gt;&lt;/code&gt; with an absolute path after &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47962432a46afd10354bf7faf78b77ebd176482" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; together with &lt;code&gt;enif_select&lt;/code&gt; to detect failing Erlang processes and prevent them from causing permanent leakage of resources and their contained OS event objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81221a29d13782207a78cbfa816c0cbf3c464d7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; to signal that no more data is to be sent and wait for the read side of the socket to be closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71bd29e8e106825432b11d0f4aa2b931f6f8bf79" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt;erlang:system_time/1&lt;/a&gt;&lt;/code&gt; to retrieve the current Erlang system time on the &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; of your choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6d38128136d372de87b2cca11fa0fc14d3b6dd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;net_adm#ping-1&quot;&gt;net_adm:ping(Node)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="611de99bd7fd476bf937c72c0e0fd5671d5f5338" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;ttb#list_history-0&quot;&gt;ttb:list_history/0&lt;/a&gt;&lt;/code&gt; to see the content of the history buffer and &lt;code&gt;&lt;a href=&quot;ttb#run_history-1&quot;&gt;ttb:run_history/1&lt;/a&gt;&lt;/code&gt; to re-execute one of the entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a0a6dcdb4bb774d1d742179139e2e450523f30" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; as &lt;code&gt;mode&lt;/code&gt; in order to safely close an event object that has been passed to &lt;code&gt;enif_select&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback of the resource &lt;code&gt;obj&lt;/code&gt; will be called when it is safe to close the event object. This safe way of closing event objects must be used even if all notifications have been received and no further calls to &lt;code&gt;enif_select&lt;/code&gt; have been made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbf19e8e181869d7824e230cc259b4296e049dd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;M-x compile&lt;/code&gt; to compile an MIB from inside Emacs, and enter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43487582b9c31bb61fd048104c15adf5df0fcbcf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;cover:is_compiled/1&lt;/code&gt; or &lt;code&gt;code:which/1&lt;/code&gt; to see if a module is Cover compiled (and still loaded) or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f85d8a08505e2b0a869a54c5dd45740db5b3406" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;cover:start/1&lt;/code&gt; and &lt;code&gt;cover:stop/1&lt;/code&gt; to add or remove nodes. The same Cover compiled code will be loaded on each node, and analysis will collect and sum up coverage data results from all nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b51e4203eb742f5eb4fc26e38e7eb765f543077" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;driver_alloc_binary()&lt;/code&gt; to allocate a binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95131c00c47173f141a21936f6eef73f82cca9f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:get_cookie()&lt;/code&gt; in ERTS instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c041275bff1db161bb6bcf06b8c664a175f0746" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:now/0&lt;/code&gt; to retrieve the current Erlang system time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de069253a09bf6a9eebbd010c198840f5e87a703" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:set_cookie(node(),Cookie)in ERTS&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4290f2a7a214d1f9ba5e3a266d300f53024ef971" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;hipe:help_options/0&lt;/code&gt; to print out the available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0a3e8fb6ea6a46c1431393956ad0cdb131d016" translate="yes" xml:space="preserve">
          <source>Use Compiler option &lt;code&gt;{debug_info_key,Key}&lt;/code&gt;, see &lt;code&gt;compile(3)&lt;/code&gt; and function &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; to register a fun that returns the key whenever &lt;code&gt;beam_lib&lt;/code&gt; must decrypt the debug information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf76996b770b568aba2d669a4a4c375802561542" translate="yes" xml:space="preserve">
          <source>Use Dialyzer from the command line to detect defects in the specified files or directories containing &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.beam&lt;/code&gt; files, depending on the type of the analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ecd59359aa11823ae3489c4b92ca323d2f8686" translate="yes" xml:space="preserve">
          <source>Use Mnesia with the following types of applications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0851048c67fb91d296c17c79d984235168aa8a" translate="yes" xml:space="preserve">
          <source>Use STDLIB application variable &lt;code&gt;restricted_shell&lt;/code&gt; and specify, as its value, the name of the callback module. Example (with callback functions implemented in &lt;code&gt;callback_mod.erl&lt;/code&gt;): &lt;code&gt;$ erl -stdlib restricted_shell callback_mod&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9de9466c5fd84c1497ee031330a8bf3182295b3" translate="yes" xml:space="preserve">
          <source>Use a parameterized query to insert many rows in one go.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4246bdbd0514a46c24c66d6a824bf38823f49b83" translate="yes" xml:space="preserve">
          <source>Use a specified algorithm with a constant seed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d7bed7136a80ee2a1f391e37af7b4e25791949" translate="yes" xml:space="preserve">
          <source>Use a specified algorithm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef43eef2287dfb39d5045b73777b94383dd1809" translate="yes" xml:space="preserve">
          <source>Use active mode only if your high-level protocol provides its own flow control (for example, acknowledging received messages) or the amount of data exchanged is small. &lt;code&gt;{active, false}&lt;/code&gt; mode, use of the &lt;code&gt;{active, once}&lt;/code&gt; mode, or &lt;code&gt;{active, N}&lt;/code&gt; mode with values of &lt;code&gt;N&lt;/code&gt; appropriate for the application provides flow control. The other side cannot send faster than the receiver can read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb9f5afdf0431967f44f8bc5907c7bc9106a55e" translate="yes" xml:space="preserve">
          <source>Use batch file &lt;code&gt;etop.bat&lt;/code&gt;, for example, &lt;code&gt;etop -node tiger@durin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804cbb37615425c1f58bef26b23df4ccbb998e2d" translate="yes" xml:space="preserve">
          <source>Use bitwise AND to test for specific bits in the return value. New significant bits may be added in future releases to give more detailed information for both failed and successful calls. Do NOT use equality tests like &lt;code&gt;==&lt;/code&gt;, as that may cause your application to stop working.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d05d6e3c0c6496475b27e170aa3c9890b934a6" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, wild_pattern)&lt;/a&gt;&lt;/code&gt; to obtain a basic pattern, which matches all records in a table, or use the default value in record creation. Do not make the pattern hard-coded, as this makes the code more vulnerable to future changes of the record definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36fef5f536ab55188b5441adeba6150367c3ff02" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#list-0&quot;&gt;rb:list()&lt;/a&gt;&lt;/code&gt; to list all loaded reports:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28b25ff39058f6138bbe1ff3ebce8f3b6ccb94a" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#show-1&quot;&gt;rb:show(Number)&lt;/a&gt;&lt;/code&gt; to show details of a specific report:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0eac0e99e0695efffadbf6a76c731707faeeeea" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#stop-0&quot;&gt;rb:stop()&lt;/a&gt;&lt;/code&gt; to stop the &lt;code&gt;rb_server&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012887c588a915c59771e087bcd639512c6a8489" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; to get all flags for features that require strict order delivery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f83ae95c5e5857514f24ca4885f3294c1f168dd" translate="yes" xml:space="preserve">
          <source>Use its graphical interface to investigate the state of the current test case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66df33ce491bfcd444a606b910f4cb9ff07688b9" translate="yes" xml:space="preserve">
          <source>Use maps instead of records to represent the &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; types. No &lt;code&gt;.hrl&lt;/code&gt; files will be generated. See the Section &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e7a5bbaac2fe1d22a38124df53d79bef29a950" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;killproc&lt;/code&gt; procedure in the above script can be combined with a call to &lt;code&gt;erl_call&lt;/code&gt;, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ca6ef9bc0eb0fd175268e16b224fb66ca6f3fe" translate="yes" xml:space="preserve">
          <source>Use one of the following two functions to receive messages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889a7015472f4f91d80360afa19301c38e311202" translate="yes" xml:space="preserve">
          <source>Use one of the following two functions to send messages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4154e7c45ed1c09b28a8e036ce840111c118baa6" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;-I&lt;/code&gt; to name directories to be searched for application files (equivalent to the &lt;code&gt;path&lt;/code&gt; in the option list for &lt;code&gt;systools:make_script/2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5e91c4910f51c44ca054a05924c3387fce83e6" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;-I&lt;/code&gt; with the name of a file to use that file as a customized prologue file (option &lt;code&gt;includefile&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55bb82b3630e22429844da6211b0339bba98ea8" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;strong_validation&lt;/code&gt; to generate all warnings that the compiler would generate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7937b3339663cb4514ac276573d7e2c9e0dfd606" translate="yes" xml:space="preserve">
          <source>Use relaxed command checking only on systems with very limited interactive usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8be1e3581d1297371b0474f66ebe7774bd9957" translate="yes" xml:space="preserve">
          <source>Use script &lt;code&gt;etop&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecdd13a57f7a43ae5c5be43fc2ede21e975f620a" translate="yes" xml:space="preserve">
          <source>Use selective decode instead of exclusive decode if you are interested in only a single subvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc8ad2b93f84080dbc37116f7108a665d7b55ac" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SEND_SENDER&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; instead of the &lt;code&gt;SEND&lt;/code&gt; control message and use the &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; control message instead of the &lt;code&gt;SEND_TT&lt;/code&gt; control message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb13f68ed22ba4a08751c4363250d2b2b3fba90" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;bin_opt_info&lt;/code&gt; option to have the compiler print a lot of information about binary optimizations. It can be given either to the compiler or &lt;code&gt;erlc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c30d8bd130bb93833dc88f2efb2369af2066111" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;file&lt;/code&gt; module for files opened for bytewise access (&lt;code&gt;{encoding,latin1}&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec2d14858ca56aa4886d5cb596e4d1c4389bb5d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;io&lt;/code&gt; module when accessing files with any other encoding (for example &lt;code&gt;{encoding,uf8}&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e21bc6d17c5f3138b318feb1664293ef1335717" translate="yes" xml:space="preserve">
          <source>Use the GUI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3f1aa1f6c936dd4bbcc665fff827922973d80d2" translate="yes" xml:space="preserve">
          <source>Use the following command to generate a .hrl file from an MIB:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285645e77ad81adce8bdc1256d83d49b2f715165" translate="yes" xml:space="preserve">
          <source>Use the following include directive to get access to the records and constant macros described here and in the User's Guide:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26340e5bfdecd44f5d627a8bf499337d449c9b39" translate="yes" xml:space="preserve">
          <source>Use the following include directive to get access to the records and constant macros described in the following sections:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf38e520f81f823bc5c2944fc89ede2ea27b2c7" translate="yes" xml:space="preserve">
          <source>Use the function &lt;code&gt;mnesia:change_table_frag/2&lt;/code&gt; to add new fragments and apply the usual schema manipulation functions (such as &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt;) on each fragment to perform the actual redistribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d58859492a0e6cf67a695fecde344397df4fa0" translate="yes" xml:space="preserve">
          <source>Use the function describe_table/[2,3] to find out which ODBC data type that is expected for each column of that table. If a column has a data type that is described with capital letters, alas it is not currently supported by the param_query function. Too know which Erlang data type corresponds to an ODBC data type see the Erlang to ODBC data type &lt;code&gt;&lt;a href=&quot;databases#type&quot;&gt;mapping&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e938f8eaaf7a2fb5db93a5741c75b6c3d2b1e56" translate="yes" xml:space="preserve">
          <source>Use the functional API with a non-constant seed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541ddc36dcd95bdf4f3b7b106057bafcf839da79" translate="yes" xml:space="preserve">
          <source>Use the map in the ssl key option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bedd4105b0c918e36403c94a86cea217070bfac" translate="yes" xml:space="preserve">
          <source>Use the same Erlang types to represent &lt;code&gt;BIT STRING&lt;/code&gt; and &lt;code&gt;OCTET STRING&lt;/code&gt; as in OTP R16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="203bf7370538dd892cf94b38b1e17b25aedb4cc9" translate="yes" xml:space="preserve">
          <source>Use the socket option &lt;code&gt;&lt;a href=&quot;inet#packet&quot;&gt;{packet, N}&lt;/a&gt;&lt;/code&gt; (or something similar) to make it possible for the receiver to close the connection when it knowns it has received all the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d720aadc70a1b56241025a699cc74ef9ea249d" translate="yes" xml:space="preserve">
          <source>Use the specified PLT as the initial PLT. If the PLT was built during setup, the files are checked for consistency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad77542229ec1d771e4e02b6524ee184d641040" translate="yes" xml:space="preserve">
          <source>Use the value returned from &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-0&quot;&gt;erlang:unique_integer/0&lt;/a&gt;&lt;/code&gt; to create a name unique on the current runtime system instance. If you only want positive integers, you can use &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer([positive])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e36f8f2cb8b647a47cca517ff03d541469491a2" translate="yes" xml:space="preserve">
          <source>Use the values returned from &lt;code&gt;erlang:now/0&lt;/code&gt; to create a name unique on the current runtime system instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1a3d93db801fcbd6f501d39eac8cc569d5150c" translate="yes" xml:space="preserve">
          <source>Use this function after a failed system call. The message provided by the caller is printed followed by a string describing the reason for failure, and the process terminates with exit value &lt;code&gt;1&lt;/code&gt;. This function does not return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60cd4eee7b91477f96873aee8f0c08a0e1659942" translate="yes" xml:space="preserve">
          <source>Use this function after a failed system call. The message provided by the caller is printed followed by a string describing the reason for failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3be946393c47f35eede2756d19558abc69e73e" translate="yes" xml:space="preserve">
          <source>Use this function only if you know what you are doing, that is, on your own applications. It is very application-dependent and configuration parameter-dependent when and how often the value is read by the application. Careless use of this function can put the application in a weird, inconsistent, and malfunctioning state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1a6a43cff399c18914850f099af42f99ff52a6" translate="yes" xml:space="preserve">
          <source>Use this function to &quot;forget&quot; a specific match specification saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bca535e578b8f96edf192f36e88f0568555ba6" translate="yes" xml:space="preserve">
          <source>Use this function to &quot;forget&quot; all match specifications saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. This is useful when one wants to restore other match specifications from a file with &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#dtp-1&quot;&gt;dtp/1&lt;/a&gt;&lt;/code&gt; to delete specific saved match specifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d051de59e60744864ad96b5d4970120ccdf3ce13" translate="yes" xml:space="preserve">
          <source>Use this function to recall all match specifications previously used in the session (i. e. previously saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;, and built-in match specifications. This is very useful, as a complicated match_spec can be quite awkward to write. Note that the match specifications are lost if &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c941b9c92bccb005e3755850980e1a4c93df1aed" translate="yes" xml:space="preserve">
          <source>Use this function to set, or modify, the verbosity level for a logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to set the general verbosity level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4f981450d616f53002b2dbe1a22bf77c775fe2" translate="yes" xml:space="preserve">
          <source>Use this function when a fatal error has occurred that is not because of a system call. The message provided by the caller is printed and the process terminates with exit value &lt;code&gt;1&lt;/code&gt;. This function does not return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927c6ba6b883da5a944bc17195e2455b95cac07d" translate="yes" xml:space="preserve">
          <source>Use this function with extreme caution, as it makes existing persistent data obsolete. Think twice before using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f95d87f375280efaeeb6fe8cafb649410d718d" translate="yes" xml:space="preserve">
          <source>Use this module to set up Telnet connections, send commands, and perform string matching on the result. For information about how to use &lt;code&gt;ct_telnet&lt;/code&gt; and configure connections, specifically for UNIX hosts, see the &lt;code&gt;&lt;a href=&quot;unix_telnet&quot;&gt;unix_telnet&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d50bad282c0804f9a7e02550f10159ee185809" translate="yes" xml:space="preserve">
          <source>Use this option when receiving binaries from an untrusted source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f5382feca2bb4947c345ec5297001b4439de6e" translate="yes" xml:space="preserve">
          <source>Use with extreme care.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926a25ba00ec3f71fce83c4ae2a582227ec44542" translate="yes" xml:space="preserve">
          <source>Used BIFs. &lt;code&gt;B&lt;/code&gt; is empty if &lt;code&gt;builtins&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all analyzed modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11ee9255f50f3fa3a1ac060817b8601274af33d" translate="yes" xml:space="preserve">
          <source>Used Library Modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaea96d1f0adade7428605a5b6a71a977e21c17f" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt;enif_system_info&lt;/a&gt;&lt;/code&gt; to return information about the runtime system. Contains the same content as &lt;code&gt;&lt;a href=&quot;erl_driver#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d74dbb12b0fb1f6ea1d95300289917f6910dc7" translate="yes" xml:space="preserve">
          <source>Used by a process to redefine the error handler for undefined function calls and undefined registered processes. Inexperienced users are not to use this flag, as code auto-loading depends on the correct operation of the error handling module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021e8894d4cd8efeb3800e902cce4283561eaa59" translate="yes" xml:space="preserve">
          <source>Used by a server process to accept a connection from a client process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c49623f58e59d8735fea69dd29c4f20e63decdd" translate="yes" xml:space="preserve">
          <source>Used by a server process to register with the local name server EPMD, thereby allowing other processes to send messages by using the registered name. Before calling either of these functions, the process should have called &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt; on an open socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5237d3789fea5df1f7ffca0fba9777e1547c1e" translate="yes" xml:space="preserve">
          <source>Used in a bit string construction, &lt;code&gt;Size&lt;/code&gt; is an expression that is to evaluate to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7cde552a3551769508a6d34af2b5b84e289881d" translate="yes" xml:space="preserve">
          <source>Used in a bit string construction, &lt;code&gt;Value&lt;/code&gt; is an expression that is to evaluate to an integer, float, or bit string. If the expression is not a single literal or variable, it is to be enclosed in parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fa51f6619aef90e556b2317c4e8c8b56b58094" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Size&lt;/code&gt; must be an integer, or a variable bound to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ea25edea36db50d30cde55ba8333dc776429fb" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Value&lt;/code&gt; must be a variable, or an integer, float, or string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b8635528024d62633ce26ebc8ade8bf9cf1f13" translate="yes" xml:space="preserve">
          <source>Used in socket close message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37771a4a8b87640f401b1b514090e62c25bfd4a6" translate="yes" xml:space="preserve">
          <source>Used in socket data message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94de0e417f3f0b14c77f33a57c9b9d9d4a4e16c3" translate="yes" xml:space="preserve">
          <source>Used to perform codec measurements. That is, to see what kind of performance can be expected by the different codecs provided by the megaco application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea4aa7eefddb763ba10cb9daaf61feb433c13d7" translate="yes" xml:space="preserve">
          <source>Used to set tracing on the distribution. The levels are different verbosity levels. A higher level means more information. See also section &lt;code&gt;&lt;a href=&quot;#debug_information&quot;&gt;Debug Information&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0558fbc4bfc3f98f9c0aff78f8bf8c889c7ae8" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; to uniquely identify a HTTP server. This can be useful in a virtualized environment, where there can be more that one server that has the same bind_address and port. If this property is not explicitly set, it is assumed that the &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt;uniquely identifies the HTTP server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="770e0b9f1dc73dcbf183dcbbbc53e3cf5e4375d4" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; to uniquely identify a ssh daemon. This can be useful in a virtualized environment, where there can be more that one server that has the same &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;. If this property is not explicitly set, it is assumed that the the &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; uniquely identifies the SSH daemon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adce6622f9543e73767624ada8f13763e382d86b" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;send_timeout&lt;/code&gt; to specify whether the socket is to be automatically closed when the send operation returns &lt;code&gt;{error,timeout}&lt;/code&gt;. The recommended setting is &lt;code&gt;true&lt;/code&gt;, which automatically closes the socket. Defaults to &lt;code&gt;false&lt;/code&gt; because of backward compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07eb868bef5aa368e19bb894ec05dbc37d91a59f" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;{verify, verify_peer}&lt;/code&gt; by an TLS/DTLS server. If set to &lt;code&gt;true&lt;/code&gt;, the server fails if the client does not have a certificate to send, that is, sends an empty certificate. If set to &lt;code&gt;false&lt;/code&gt;, it fails only if the client sends an invalid certificate (an empty certificate is considered valid). Defaults to false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec279a6fe9dd1161f2aa08b6ed9eb431c51ce40" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; has called &lt;code&gt;seq_trace:print(Label, TraceInfo)&lt;/code&gt; and has a trace token with flag &lt;code&gt;print&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; set to &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8ed9ea4c0a02770b19230ee831fc7eabc65212" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; with its trace token flag &lt;code&gt;print&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; has sent a message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f532ecd45390412a4c37f8eaaaf1dd3a2bc7a9e4" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;To&lt;/code&gt; receives a message with a trace token that has flag &lt;code&gt;'receive'&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed866b317195673cc57f0bfced4e8f18f9deb039" translate="yes" xml:space="preserve">
          <source>Used when a restart of the emulator is required after all other upgrade instructions are executed. For more information about this instruction, see restart_emulator (Low-Level) in &lt;code&gt;&lt;a href=&quot;release_handling#restart_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51ce444943f18b5b406c12d5de312dd469de6a1" translate="yes" xml:space="preserve">
          <source>Used when connection is up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f3f0d6b5fe552d6fdd9e8a1ac4b1dbc95a1e0a" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. &lt;code&gt;{M, F, Arity}&lt;/code&gt; is specified instead of &lt;code&gt;{M, F, Args}&lt;/code&gt; in call trace messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c8c1e7148c094e7f1037898138a703736b5c71" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. The &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;return_from&lt;/code&gt;, and &lt;code&gt;return_to&lt;/code&gt; trace messages are inhibited if this flag is set, but they are executed as normal if there are match specifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f97b1230868a1d952f070b44e014ae71c9b348" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. Traces the return from a traced function back to its caller. Only works for functions traced with option &lt;code&gt;local&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0771df2c0469ced91bfba340e5621231c3eb3f97" translate="yes" xml:space="preserve">
          <source>Useful for debugging. Prints the arguments sent to the emulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda40ec80a6280d040ae6cb2132464ae8868382d" translate="yes" xml:space="preserve">
          <source>Useful only for performance tuning. Do not use this option unless you know that there is problem with execution times or memory consumption, and ensure that the option improves matters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5232bbae53583af327fbf580fd761e961eb1ae" translate="yes" xml:space="preserve">
          <source>Useful options for the ASN.1 compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108800af422d061f509679723cbd223daa96eb6e" translate="yes" xml:space="preserve">
          <source>User Authentication (using Mnesia, Dets or plain text database)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d7d2ae9aeff0edfea9298508c33c3156394dee" translate="yes" xml:space="preserve">
          <source>User authentication using text files, Dets, or Mnesia database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf44c259444d43d89a931e2c5f009d59f5246ec" translate="yes" xml:space="preserve">
          <source>User does not have privileges to create symbolic links (&lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; on Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa1d0c7af0339d4d928dbeac41cc561fc954a37" translate="yes" xml:space="preserve">
          <source>User info - Information related to megaco users. Read/Write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5943eb1d1f04ded83e3e46ef3224b51f634ef059" translate="yes" xml:space="preserve">
          <source>User is not logged in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad777a4590258aa35737d9328314ce537d2c9cb8" translate="yes" xml:space="preserve">
          <source>User login information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb1ac68e43ee6fa885af993d59c13a42fa4cd33" translate="yes" xml:space="preserve">
          <source>User owning the public key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba07b0c96db1af8dcefb2d9162e61ba1cb1cc53b" translate="yes" xml:space="preserve">
          <source>User's private key(s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f9f489aed30f7126e13ae2a6c8aa3e1dfb69c4" translate="yes" xml:space="preserve">
          <source>User's public key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a1ad1d15fcc5f9e499bc1732d0978996617997" translate="yes" xml:space="preserve">
          <source>User-Name AVP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d9701932fd2b8fbf1ff963e66877b3fb9d5041" translate="yes" xml:space="preserve">
          <source>User-defined entries can also be written to a configuration file by calling function &lt;code&gt;ttb:write_config(ConfigFile,ConfigList)&lt;/code&gt;, where &lt;code&gt;ConfigList&lt;/code&gt; is a list of &lt;code&gt;{Module,Function,Args}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ea86a7fa1494da2715a81abce4cab0c8f4eb29" translate="yes" xml:space="preserve">
          <source>User-defined event handlers can be added to handle application-specific events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d44e29b83c2f61db1703ca0d31d257ddfa7ed010" translate="yes" xml:space="preserve">
          <source>User-specific data for use in hook functions. The default value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e7327216976d6005c52f79eedee5271cbeaf73" translate="yes" xml:space="preserve">
          <source>User-specific event handlers can be plugged into a &lt;code&gt;Common Test&lt;/code&gt; event manager, either by telling &lt;code&gt;Common Test&lt;/code&gt; to install them before the test run (described later), or by adding the handlers dynamically during the test run using &lt;code&gt;gen_event:add_handler/3&lt;/code&gt; or &lt;code&gt;gen_event:add_sup_handler/3&lt;/code&gt;. In the latter scenario, the reference of the &lt;code&gt;Common Test&lt;/code&gt; event manager is required. To get it, call &lt;code&gt;&lt;a href=&quot;ct#get_event_mgr_ref-0&quot;&gt;ct:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; or (on the &lt;code&gt;Common Test&lt;/code&gt; Master node) &lt;code&gt;&lt;a href=&quot;ct_master#get_event_mgr_ref-0&quot;&gt;ct_master:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dca5c1acac21d9a3b6102ae9dadcfac83499ca32" translate="yes" xml:space="preserve">
          <source>UserMod:handle_connect/2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d3fd03fc3def42c8da5fe622ad791ccaa1a0ea" translate="yes" xml:space="preserve">
          <source>UserMod:handle_message_error/3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bdb9436158799687b4418588b8647662e27155" translate="yes" xml:space="preserve">
          <source>UserMod:handle_syntax_error/3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0a148d93ed9e16bd5599754876deca380f643d" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_ack/4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d345f713a7834aaf56186658aec2115bcc13351b" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_reply/4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3884319e28f9e311d120dba2fbc454b53cead5a4" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_request/3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6d997ef0e4d563bff3ecdcaff66971fd6b9762" translate="yes" xml:space="preserve">
          <source>Users are advised not to unregister system processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d7d513ec1d0fa107e592cfc1c6289d5e8f86f88" translate="yes" xml:space="preserve">
          <source>Users are not allowed to define types with the same names as the predefined or built-in ones. This is checked by the compiler and its violation results in a compilation error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259b250e47199fdb387584511bbacec343b879b8" translate="yes" xml:space="preserve">
          <source>Users may either explicitly be registered with megaco:start_user/2 and/or be statically configured by setting the application environment variable 'users' to a list of {UserMid, Config} tuples. See the function megaco:start_user/2 for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944ad3a48b1f08bbcf2fb59d662131185d4fa39c" translate="yes" xml:space="preserve">
          <source>Uses a separate log file for every invocation of the service (&amp;lt;servicename&amp;gt;&lt;code&gt;.debug.&lt;/code&gt;&amp;lt;N&amp;gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ba2c7044af64caa2e9580c9ae81af796b430d1" translate="yes" xml:space="preserve">
          <source>Uses a sequence of wrap log files of limited size. As a wrap log file is filled up, further items are logged on to the next file in the sequence, starting all over with the first file when the last file is filled up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63cc551f28fdc9de0a6c288edb557951e593faa7" translate="yes" xml:space="preserve">
          <source>Uses a specific or customised prologue file instead of default &lt;code&gt;lib/parsetools/include/leexinc.hrl&lt;/code&gt; which is otherwise included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb35a958a3524ef916a2dee520c654de0d97728" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a deep list of characters that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure (described in section &lt;code&gt;&lt;a href=&quot;#error_information&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;) is processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4139194e768c251d84b03abf5cd321d1df4d02c" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error or warning. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93cef9ab961b13c52c3ee1286af209a4ef5d08b" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e240ed0f46a0e7052bee5a3dec802b98fe462d1" translate="yes" xml:space="preserve">
          <source>Uses test specification as input (described later).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="713999a06cadf66964b72d923b13701c303aa173" translate="yes" xml:space="preserve">
          <source>Uses the Pseudo-Random Function (PRF) of a TLS session to generate extra key material. It either takes user-generated values for &lt;code&gt;Secret&lt;/code&gt; and &lt;code&gt;Seed&lt;/code&gt; or atoms directing it to use a specific value from the session security parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fb0bd5ac8937f75326b05d56a7b9c426068b8d" translate="yes" xml:space="preserve">
          <source>Uses the following Erlang Web Server API interaction data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6542021570e55732848d7c4ecf584a9f1fce4a50" translate="yes" xml:space="preserve">
          <source>Uses the following Erlang web server API interaction data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c87b085bc59aac65ced245c43dfb66c0a327d57" translate="yes" xml:space="preserve">
          <source>Uses the return value of command &lt;code&gt;N&lt;/code&gt; in the current command, if &lt;code&gt;N&lt;/code&gt; is positive. If it is negative, the return value of the &lt;code&gt;N&lt;/code&gt;th previous command is used (that is, &lt;code&gt;v(-1)&lt;/code&gt; uses the value of the previous command).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7825c5becf2a7bc58af7be09180ec50f46648e4" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current directory. It is prepended to filenames when extracting them from the zip archive. (Acting like &lt;code&gt;file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f356880e1a29c6875ae88d729105f2618d77c27f" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current work directory (&lt;code&gt;cwd&lt;/code&gt;). This is prepended to filenames when adding them, although not in the zip archive (acting like &lt;code&gt;file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b24dbe95482357a59b64bc1da6d8ac53437250c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-group top1 top2&lt;/code&gt;, or &lt;code&gt;{group,[top1,top2]}&lt;/code&gt; gives the same result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f4f21380171a61e0164a29d94211d35a1afc8d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-include_lib(&quot;syntax_tools/include/merl.hrl&quot;).&lt;/code&gt; enables this transform, unless the macro &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; is defined first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20e26276eb3aeb9f802837228801c44d2e93f19" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ets#select-2&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; and a match specification, one can filter out rows of a table and construct a list of tuples containing relevant parts of the data in these rows. One can use &lt;code&gt;&lt;a href=&quot;ets#foldl-3&quot;&gt;ets:foldl/3&lt;/a&gt;&lt;/code&gt; instead, but the &lt;code&gt;ets:select/2&lt;/code&gt; call is far more efficient. Without the translation provided by &lt;code&gt;ms_transform&lt;/code&gt;, one must struggle with writing match specifications terms to accommodate this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82c027de482fad19a39ea9d254bbafa02b405e5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;cprof:analyse()&lt;/code&gt; in this example also shows approximately the same background work as in the first example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0e8375352b28a80765ea773ca843308851404f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ct_run -step [opts]&lt;/code&gt;, or by passing option &lt;code&gt;{step,Opts}&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, the following is possible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f64a2837eaf7b8603ee4f3b40320c612c90d80f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;erl_drv_output_term()&lt;/code&gt; or &lt;code&gt;erl_drv_send_term()&lt;/code&gt;, a binary can be included in an Erlang term.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c339dd691e6a37b987bcf7700c90e985445f81" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ets:fun2ms/1&lt;/code&gt;, we can combine the ease of use of the &lt;code&gt;ets:foldr/3&lt;/code&gt; and the efficiency of the pure &lt;code&gt;ets:select/2&lt;/code&gt; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d06eaee0affa1e9d7ed35b71b0a99a0f3c00b54" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;list_to_atom/1&lt;/code&gt; to construct an atom that is passed to &lt;code&gt;apply/3&lt;/code&gt; as follows, is quite expensive and not recommended in time-critical code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81394dd93922176e47458d5f3c15c2b0804bd134" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;scheduler_wall_time&lt;/code&gt; to calculate scheduler utilization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862378469cf87dc0f0b44de7c775b81caef36dd4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;skip_suites&lt;/code&gt; and &lt;code&gt;skip_cases&lt;/code&gt; terms in &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;test specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf508ced4ee281be2348cd08d12f83a3f75cac1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{beast_mitigation, disabled}&lt;/code&gt; makes SSL or TLS vulnerable to the BEAST attack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8a3b96a977f8581a203f0cc7479a4fa622cf64" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{padding_check, boolean()}&lt;/code&gt; makes TLS vulnerable to the Poodle attack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c74ea67a8bf514e98bacaa08d939dc388ff2c9" translate="yes" xml:space="preserve">
          <source>Using HiPE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787b8b2ecfeeac0dc6c8b30eb4f29ae6e32df930" translate="yes" xml:space="preserve">
          <source>Using Mnesia Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b70d7925c3d595457eb50569e18e9253b0f84e" translate="yes" xml:space="preserve">
          <source>Using Mnesia tables as SNMP tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4556d3a05908d3a2fd5b120b9264ae977bdd001" translate="yes" xml:space="preserve">
          <source>Using QLC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb75491192cbec18ddc3193ff609070567e4f298" translate="yes" xml:space="preserve">
          <source>Using QLC can be more expensive than using &lt;code&gt;Mnesia&lt;/code&gt; functions directly but offers a nice syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b888e7581a06a39525c04389ba7f49f831878208" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;msg_env&lt;/code&gt; of &lt;code&gt;NULL&lt;/code&gt; is an optimization, which groups together calls to &lt;code&gt;enif_alloc_env&lt;/code&gt;, &lt;code&gt;enif_make_copy&lt;/code&gt;, &lt;code&gt;enif_port_command&lt;/code&gt;, and &lt;code&gt;enif_free_env&lt;/code&gt; into one call. This optimization is only useful when a majority of the terms are to be copied from &lt;code&gt;env&lt;/code&gt; to &lt;code&gt;msg_env&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e05aace796b827cc7de5108dc65985d67668971" translate="yes" xml:space="preserve">
          <source>Using a bridge that maps control messages in a proprietary protocol to a standardized management protocol and conversely</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f87dc632b3b3a497eda26d1e0fd7f024ede833" translate="yes" xml:space="preserve">
          <source>Using a configuration target name (an alias) as reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd7819b4238a75d18eacbc298988f60839565ee" translate="yes" xml:space="preserve">
          <source>Using a driver binary instead of a normal buffer is often faster, as the emulator needs not to copy the data, only the pointer is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4f00d83853b9a89087a2b4d34b93f85e90b8b4" translate="yes" xml:space="preserve">
          <source>Using a proprietary control protocol</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e93a7f8043acf2f93881fdb114964f55246a652" translate="yes" xml:space="preserve">
          <source>Using a pure password-based authentication scheme. Here, the plain text password is encrypted before sent over the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61ea81dc7d1d41a9c00c2e18e56e9bb004eb512" translate="yes" xml:space="preserve">
          <source>Using a trace port significantly lowers the overhead imposed by using tracing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1a11e39ee5139ba5f2dcc235a18443f44a0583" translate="yes" xml:space="preserve">
          <source>Using a value of &lt;code&gt;Timeout&lt;/code&gt; less than the maximum time taken by the OS to establish an association (around 4.5 minutes if the default values from &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4960&quot;&gt;RFC 4960&lt;/a&gt;&lt;/code&gt; are used), can result in inconsistent or incorrect return values. This is especially relevant for associations sharing the same &lt;code&gt;Socket&lt;/code&gt; (that is, source address and port), as the controlling process blocks until &lt;code&gt;connect/*&lt;/code&gt; returns. &lt;code&gt;&lt;a href=&quot;#connect_init-4&quot;&gt;connect_init/*&lt;/a&gt;&lt;/code&gt; provides an alternative without this limitation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba9ca7df52061ff3c5b19d7603144639874aa7f" translate="yes" xml:space="preserve">
          <source>Using behaviours also makes it easier to read and understand code written by other programmers. Improvised programming structures, while possibly more efficient, are always more difficult to understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be49034820244435a044e90d7061836773df04c0" translate="yes" xml:space="preserve">
          <source>Using binaries is faster if more than a few bytes are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c27bef1bf11875cf4524858dc2b5b6d1f57e8f" translate="yes" xml:space="preserve">
          <source>Using global names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83523a7442b26b6b81628c22227c3e6adc4deb1a" translate="yes" xml:space="preserve">
          <source>Using keyboard-interactive authentication. This is suitable for interactive authentication methods that do not need any special software support on the client side. Instead, all authentication data is entered from the keyboard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a390fb32c6eae4e12e20eb0d4d9a4b34d640e2f" translate="yes" xml:space="preserve">
          <source>Using one of the latter three requires good knowledge about the protocol and is not covered by this tutorial. See the SNMP, Inets, and Orber applications, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5809e3cc4f955b265b3823ad9d7e5a15c18140e7" translate="yes" xml:space="preserve">
          <source>Using public key technology. RSA and DSA, X509-certificates are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f94a2e35a5586c99778544bf1babebc9b68874" translate="yes" xml:space="preserve">
          <source>Using raw socket options requires detailed knowledge about the current operating system and TCP stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43bcf358f1478cc031c03e30ad078b80a07cfdf" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed, it causes the function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f019fb91f46510f8e2ab9ec3e19f04bc02403c" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed, it causes this function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a580b4208da4e796317767a96b5a26cf22e6b99" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed. It causes the function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a9c674a9710324d1b88cb77d06f6cc4e6cfec2" translate="yes" xml:space="preserve">
          <source>Using state functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a2d079afcf63d89e623e699169fa524219390a" translate="yes" xml:space="preserve">
          <source>Using the &quot;&lt;code&gt;--&lt;/code&gt;&quot; operator to delete an element from a list is not a performance problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4f7382590545933da8c1a5ca844a0b2dbf266e" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; BIF, the size of the deep list can be calculated if sharing is ignored. It becomes the size of the list when it has been sent to another process or stored in an Ets table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45d11e06ad9c8b5b97c2a1d3733d7810b2b6a1d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;erts_debug:size/1&lt;/code&gt; BIF, it can be seen that the deep list only requires 22 words of heap space:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d1d8837258e11d9f37b8093e934034d0224323" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;match_object&lt;/code&gt; functions for traversing all table objects is more efficient than calling &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; or &lt;code&gt;slot/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88489091684544e2ce31ba031314c433818b9650" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;select&lt;/code&gt; functions for traversing all objects of a table is more efficient than calling &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; or &lt;code&gt;slot/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a624a4dabba21043f9ab83195b8048f47a13d2" translate="yes" xml:space="preserve">
          <source>Using the &lt;strong&gt;Options&lt;/strong&gt; menu, you can set which areas to be displayed. By default, all areas except the Trace area are displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deaaf3fd831f16ebe5c78cc725732bfa850f0ae7" translate="yes" xml:space="preserve">
          <source>Using the BIFs &lt;code&gt;tuple_size/1&lt;/code&gt; and &lt;code&gt;byte_size/1&lt;/code&gt; gives the compiler and the runtime system more opportunities for optimization. Another advantage is that the BIFs give Dialyzer more type information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffd8340dfb4e279ea5e33db1e4fc34776f3431f" translate="yes" xml:space="preserve">
          <source>Using the Erlang Port Mapper Daemon (EPMD)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a23b01b4aba69b50c3d95e7b04c3987e9060d6" translate="yes" xml:space="preserve">
          <source>Using the Kernel configuration parameters above, one can set default options for all TCP sockets on a node, but use this with care. Options such as &lt;code&gt;{delay_send,true}&lt;/code&gt; can be specified in this way. The following is an example of starting an Erlang node with all sockets using delayed send:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13013135bcccdcdbbd4af4075c0fbd41fe4a1df" translate="yes" xml:space="preserve">
          <source>Using the configuration variable as reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6387e670864aedf383cf907c6d29480da77d049e" translate="yes" xml:space="preserve">
          <source>Using the erlc program, write like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fe6335c37dc35de5485bc852958929b084eb85" translate="yes" xml:space="preserve">
          <source>Using the function &lt;code&gt;foreach&lt;/code&gt;, the function &lt;code&gt;broadcast&lt;/code&gt; becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd90c46e2dfc7b2e3d344d9519f155f341267df" translate="yes" xml:space="preserve">
          <source>Using the function &lt;code&gt;foreach&lt;/code&gt;, the function &lt;code&gt;print_list&lt;/code&gt; becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09520015307c351db8684a091c45386c6ce9fb4" translate="yes" xml:space="preserve">
          <source>Using the monitor triggers in the call to &lt;code&gt;try_unload&lt;/code&gt; ensures that the monitor is added before the unloading is executed, meaning that the monitor is always properly triggered, which is not the case if &lt;code&gt;monitor/2&lt;/code&gt; is called separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fa3b27587f43d236bfc06bb5036ddb2f4e6201" translate="yes" xml:space="preserve">
          <source>Using the registry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb1c5489112873955c3175cf9ad9aba4db225d6" translate="yes" xml:space="preserve">
          <source>Using the same snapshots to calculate a total scheduler utilization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20644602b05608c2ad01e03c87f70e3ffe5b61d" translate="yes" xml:space="preserve">
          <source>Using the single time warp mode, the time offset is handled in two phases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eee4ea386e884fcda7fe99030e661fbbf1aa947" translate="yes" xml:space="preserve">
          <source>Using the specific path &lt;code&gt;-group [sub121]&lt;/code&gt; or &lt;code&gt;{group,[[sub121]]}&lt;/code&gt; gives the same result in this example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c52f9666d83bbf64ddaeeafc9ca31c5700aca1b" translate="yes" xml:space="preserve">
          <source>Using these facts, the two small circles in the picture below can be combined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86aadd39c7dc4683cf62fc0ed24ee58375d7f5d3" translate="yes" xml:space="preserve">
          <source>Using transactions is a way to guarantee that the distributed Mnesia database remains consistent, even when many different processes update it in parallel. However, if you have real-time requirements it is recommended to use &lt;code&gt;dirty&lt;/code&gt; operations instead of transactions. When using &lt;code&gt;dirty&lt;/code&gt; operations, you lose the consistency guarantee; this is usually solved by only letting one process update the table. Other processes must send update requests to that process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb7bee577205f37d65f9821375accf63f59b42f" translate="yes" xml:space="preserve">
          <source>Usually a few managers communicate with many agents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdaebc21aedbdaa85649f3457b904bb990d3b2ea" translate="yes" xml:space="preserve">
          <source>Usually a line is added that is to state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c9ebf9950b5eb0782b3cd23c9a753ea0c5e533" translate="yes" xml:space="preserve">
          <source>Usually it suffices to detect time-outs on receive, as most protocols include some sort of acknowledgment from the server, but if the protocol is strictly one way, option &lt;code&gt;send_timeout&lt;/code&gt; comes in handy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f960a27f294ee8a3a2af0d51fbe8531fe5bf1b" translate="yes" xml:space="preserve">
          <source>Usually one of &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;Application&quot;&lt;/code&gt; or &lt;code&gt;&quot;Security&quot;&lt;/code&gt;. Note that the NT eventlog viewer has another notion of category, which in most cases is totally meaningless and therefore not imported into Erlang. What is called a category here is one of the main three types of events occurring in a normal NT system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa3a8b7b3a6f1f39061eab776dd864c04df5840" translate="yes" xml:space="preserve">
          <source>Usually, the entities defined in the MIB are called &lt;strong&gt;Managed Objects (MOs)&lt;/strong&gt;, although they do not have to be objects in the object-oriented way. For example, a simple scalar variable defined in a MIB is called an MO. The MOs are logical objects, not necessarily with a one-to-one mapping to the resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34333d124dba7ee56119ecbb8915169706ed629f" translate="yes" xml:space="preserve">
          <source>Utility for reading and creating 'zip' archives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4587d8ae182b07cd6c5ddcc7013d5c9b99960884" translate="yes" xml:space="preserve">
          <source>Utility function for converting a value of type &lt;code&gt;BITS&lt;/code&gt; to &lt;code&gt;OCTET-STRING&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e44844d0966f1f6069d31b91bf4a8abdb72b4d1" translate="yes" xml:space="preserve">
          <source>Utility function for converting a value of type &lt;code&gt;OCTET-STRING&lt;/code&gt; to &lt;code&gt;BITS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4388b46bdace9a8dd94930d061cd808992ffbdfc" translate="yes" xml:space="preserve">
          <source>Utility function that starts the applications &lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;public_key&lt;/code&gt;, and &lt;code&gt;ssh&lt;/code&gt;. Default type is &lt;code&gt;temporary&lt;/code&gt;. For more information, see the &lt;code&gt;application(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7f90797d67794eeec5a51cfe794b557e3c3507" translate="yes" xml:space="preserve">
          <source>Utility function to produce a formated printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; and &lt;code&gt;versions2&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bbbc215beb617665e30c05f1df892f3ab385b7d" translate="yes" xml:space="preserve">
          <source>Utility function to produce a formatted printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; and &lt;code&gt;versions2&lt;/code&gt; functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ca3adcd5764dc7d65f56277bec220d9992d1f5" translate="yes" xml:space="preserve">
          <source>Utility function(s) to produce a formatted printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d38534bb1763cd2ba3d18a6d7ecd6c0ae55401" translate="yes" xml:space="preserve">
          <source>Utility functions for handling the agent config files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afa581e37f140ef78590e09404a9aae431c2390" translate="yes" xml:space="preserve">
          <source>Utility functions for handling the manager config files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6433ab0ec2c7394b801c26a999984771d7a0ae8b" translate="yes" xml:space="preserve">
          <source>Utility functions used to retrieve some system and application info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9f46ccd3ba41c02d70b7e973f34c959fc38d56" translate="yes" xml:space="preserve">
          <source>VACM is described in detail in RFC2275. Here is only a brief description given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f374392fc8216fb266b35c7afa3c5383908a973" translate="yes" xml:space="preserve">
          <source>Vai</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a5c44daefed8fa60457df49456ebe3ace77f95" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;BackupItems&lt;/code&gt; are the following tuples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f005ec226ccd5bd77580fd1619b366495013be6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;BindType&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3768a7ccfdefa3ace61d00f77e188549db26cf0f" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;InfoTuple&lt;/code&gt;s with corresponding &lt;code&gt;Item&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc05afbe09b2e8c8117fcc39f7f35cc60250e0d4" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Item&lt;/code&gt;s for functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf53d05dcad2f68d3d2da7de03839fc48e89fb6c" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Item&lt;/code&gt;s for ports and processes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="267195f93799c6c9557e8b18de85ebfc710db9e1" translate="yes" xml:space="preserve">
          <source>Valid Erlang expressions and guard sequences are described in &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b338a1ad5b1c7b18820779179ab41de826744b2b" translate="yes" xml:space="preserve">
          <source>Valid Return Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efbf48a6212e82d31e363fa76b710eb93043cb0c" translate="yes" xml:space="preserve">
          <source>Valid categories are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1cdb0f6fd9b5c7ae6270cdbd6aa6489ff170a68" translate="yes" xml:space="preserve">
          <source>Valid limits are values in the range &lt;code&gt;[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]&lt;/code&gt;. Limits are automatically adjusted to be sane. That is, the system adjusts values so that the low limit used is lower than or equal to the high limit used. By default the high limit is 8 kB and the low limit is 4 kB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead2bf03d6fc68d606be1689e0611b409e03bb2a" translate="yes" xml:space="preserve">
          <source>Valid option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6356256194f4dacdd3ceac883fb104c7079f63" translate="yes" xml:space="preserve">
          <source>Valid options &lt;code&gt;set_options&lt;/code&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850c962c3f063b586578621ee12bbb84d6f38bb7" translate="yes" xml:space="preserve">
          <source>Valid options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f1c0729761400496e047f8f256412e68cceee0" translate="yes" xml:space="preserve">
          <source>Valid return values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1630b32c9530f31c96e521c8cf0ccc55338fbbc7" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;NodeType&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b8127698b8ef2cfa8edc57143af42260620903" translate="yes" xml:space="preserve">
          <source>Validates a parsed well-formed XML element (Element).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b239d15c1167b7afc50fb4ba90a070cafbcead1e" translate="yes" xml:space="preserve">
          <source>Validates a parsed well-formed XML element towards an XML schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30aa57af8387dd9dda72f74225d0c83ea7830682" translate="yes" xml:space="preserve">
          <source>Validates in two steps. First it processes the schema, saves the type and structure info in an ets table and then validates the element towards the schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81dc9238e6ae4be4cef7714f7fca70a30cc0272" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;default&lt;/code&gt; states that the predefined properties are to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4b4232752a2d39d8445512cde28d28668f7d1f" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;force&lt;/code&gt; means that a reparation is made even if the table is properly closed. This is a seldom needed option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fbeacf98f8026e5fab1b1d01a773952a1337a76" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;true&lt;/code&gt; enables burst control and &lt;code&gt;false&lt;/code&gt; disables it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e5e9f151e03304f82baa34e7f4f70c22fcd0d8" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;true&lt;/code&gt; enables the feature and &lt;code&gt;false&lt;/code&gt; disables it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54db79fce832cc1178c718ad9c79945056373188" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;undefined&lt;/code&gt; for &lt;code&gt;A&lt;/code&gt; (the argument list) is only to be used internally in &lt;code&gt;supervisor&lt;/code&gt;. If the restart type of the child is &lt;code&gt;temporary&lt;/code&gt;, the process is never to be restarted and therefore there is no need to store the real argument list. Value &lt;code&gt;undefined&lt;/code&gt; is then stored instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c13cbe61dee9b68ffaef6134995ebd910fbd5e" translate="yes" xml:space="preserve">
          <source>Value = IOString | atom() | integer()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbca064dbc2becbd7d3555273dcd4ac5b367fab" translate="yes" xml:space="preserve">
          <source>Value of a configuration parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384e64d4c66abb9cfb384072bb26c3dd0bab6612" translate="yes" xml:space="preserve">
          <source>Value to convert time unit for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768d2b954af31866b6e32d7a85e19622323f08f3" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;atom()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97045cfdad33dd3dba2b9ed63a6c87874f526b4d" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;boolean()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a052394fb5d5289ec24690454284914e11a61275" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;integer()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813cf4fbeafa5124c59029940c3b8ba23a170cb6" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;on | off&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c8d38d0b9fb94d17867d4881ce4e1d9d89030a" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;runtime | reductions | memory | msg_q&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6970e248833158e8e073b58247bd68dcfc9cbf85" translate="yes" xml:space="preserve">
          <source>Values can be assigned in Erlang as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb45cee19fe1842c7fe4075c27f3b1076ddd053" translate="yes" xml:space="preserve">
          <source>Values can be assigned to an ASN.1 type within the ASN.1 code itself, as opposed to the actions in the previous section where a value was assigned to an ASN.1 type in Erlang. The full value syntax of ASN.1 is supported and X.680 describes in detail how to assign values in ASN.1. A short example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cebf5af2c916d50162daf2371942434d298c322" translate="yes" xml:space="preserve">
          <source>Values corresponding to the R(equest), P(roxiable), E(rror) and T(Potentially re-transmitted message) flags of the Diameter header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96ef06f93f26e99ce4292fa7f5fd3f23d636c4eb" translate="yes" xml:space="preserve">
          <source>Values in the AVP header, corresponding to AVP Code, the M flag, P flags and Vendor-ID respectively. A Vendor-ID other than &lt;code&gt;undefined&lt;/code&gt; implies a set V flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0444f2cacebf8b2705dc3aa6c687df85244bfd3" translate="yes" xml:space="preserve">
          <source>Values of the Version, Message Length, Command-Code, Application-ID, Hop-by-Hop Identifier and End-to-End Identifier fields of the Diameter header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b7b3117ec67f563a385f6a6bbb3fc464310423" translate="yes" xml:space="preserve">
          <source>Values of these types are not currently parsed by diameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14186fcac41fa3af58224092399d938dd7267c2" translate="yes" xml:space="preserve">
          <source>Values of this type can be assigned a value as an ordinary string as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297576f454c4d00030676aa9862a2b6c6efbd141" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;Emb&lt;/code&gt; can be assigned as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee70396c85e9d16e65df42fd317982706258e73" translate="yes" xml:space="preserve">
          <source>Variable ::= - same as Erlang variables -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748e5ba4cc296f39b4935e55b1705fc8ee581ce2" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;A&lt;/code&gt; is bound to the evaluated value of the list comprehension (&lt;code&gt;[1,2]&lt;/code&gt;). The compiler complains with an error message (&quot;argument is not a query list comprehension&quot;); the shell process stops with a &lt;code&gt;badarg&lt;/code&gt; reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a90e8a96c62ffb5d1cd6f65922e2fc9c80f1799" translate="yes" xml:space="preserve">
          <source>Variable bindings, and local process dictionary changes that are generated in user expressions are preserved, and the variables can be used in later commands to access their values. The bindings can also be forgotten so the variables can be reused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a8ee25c863aa2419107fceb204e47f57f1db36" translate="yes" xml:space="preserve">
          <source>Variable key length from 32 bits up to 448 bits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc036b2b9309c7bdc08e56f286b100a63accced" translate="yes" xml:space="preserve">
          <source>Variable key length from 8 bits up to 2048 bits (usually between 40 and 256)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c3d8899ac90eda2399d72ac989d5a5b85bf50c" translate="yes" xml:space="preserve">
          <source>Variables are bound to values through the &lt;strong&gt;pattern matching&lt;/strong&gt; mechanism. Pattern matching occurs when evaluating a function call, &lt;code&gt;case&lt;/code&gt;- &lt;code&gt;receive&lt;/code&gt;- &lt;code&gt;try&lt;/code&gt;- expressions and match operator (=) expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2184e01d1f22737f67295ee5c99577b7f02640c4" translate="yes" xml:space="preserve">
          <source>Variables are bound to values using &lt;code&gt;&lt;a href=&quot;patterns&quot;&gt;pattern matching&lt;/a&gt;&lt;/code&gt;. Erlang uses &lt;strong&gt;single assignment&lt;/strong&gt;, that is, a variable can only be bound once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1686696b0da48d910d4a99c77d1e302b425bc7" translate="yes" xml:space="preserve">
          <source>Variables can also be used to improve the readability of programs. For example, in function &lt;code&gt;list_max/2&lt;/code&gt; above, you can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e040ee86e634cf4aa0be3ce9492a2d6be860d5dc" translate="yes" xml:space="preserve">
          <source>Variables cannot be exported from a fun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c57858e4cc8b9cf7467d2261e8b3c42734717f8" translate="yes" xml:space="preserve">
          <source>Variables cannot be exported from a list comprehension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d2854195ed04278e5b7b15a33240c69501a326" translate="yes" xml:space="preserve">
          <source>Variables exported from &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;case&lt;/code&gt;/&lt;code&gt;receive&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb952951e49a9b2fcfc380fe82f3b23f85123e9" translate="yes" xml:space="preserve">
          <source>Variables from the environment can be imported, so that the following works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed92f2d37abdcb00aafc2e8c807cfc991b6f8842" translate="yes" xml:space="preserve">
          <source>Variables from the environment can be imported, so that this works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88c0b53ad71637f25dfbd793cc2441d427e3881" translate="yes" xml:space="preserve">
          <source>Variables imported into matches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b2ab1f9eb238cbc2cccee8878b2d4f07a335e18" translate="yes" xml:space="preserve">
          <source>Variables in a fun head shadow the function name and both shadow variables in the function clause surrounding the fun expression. Variables bound in a fun body are local to the fun body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d218f35a2e3577a6c500538445abcceb060b64" translate="yes" xml:space="preserve">
          <source>Variables in this section are only used, when configuring Erlang/OTP for cross compilation using &lt;code&gt;$ERL_TOP/otp_build configure&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08df3acc57d3675cf908a2f26030ccd4ae2beb38" translate="yes" xml:space="preserve">
          <source>Variables occurring in the head of the fun are replaced by match specification variables in the order of occurrence, so that fragment &lt;code&gt;fun({A,B,C})&lt;/code&gt; is replaced by &lt;code&gt;{'$1', '$2', '$3'}&lt;/code&gt;, and so on. Every occurrence of such a variable in the match specification is replaced by a match specification variable in the same way, so that the fun &lt;code&gt;fun({A,B}) when is_atom(A) -&amp;gt; B end&lt;/code&gt; is translated into &lt;code&gt;[{{'$1','$2'},[{is_atom,'$1'}],['$2']}]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0ae0e8be972f79e65125dff2b6c4f9cdfb890f0" translate="yes" xml:space="preserve">
          <source>Variables of type &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; can refer to any Erlang term. This is an opaque type and values of it can only by used either as arguments to API functions or as return values from NIFs. All &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;s belong to an environment (&lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt;). A term cannot be destructed individually, it is valid until its environment is destructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debd1f76422a0d8de3199d01bf29f5e66c2af413" translate="yes" xml:space="preserve">
          <source>Variables shadowed in funs and list comprehensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19ebfb8e1f3e97056afbbe53540cc96bcfb11ed" translate="yes" xml:space="preserve">
          <source>Variables start with an uppercase letter or underscore (_). Variables can contain alphanumeric characters, underscore and &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f862d436d21532b455bff8e767c989deff6bc5" translate="yes" xml:space="preserve">
          <source>Variables starting with &lt;code&gt;_@&lt;/code&gt;, for example &lt;code&gt;_@bar&lt;/code&gt; or &lt;code&gt;_@Bar&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1225854353b77d49f7cc40d13247de7c80827209" translate="yes" xml:space="preserve">
          <source>Variables starting with underscore (_), for example, &lt;code&gt;_Height&lt;/code&gt;, are normal variables, not anonymous. They are however ignored by the compiler in the sense that they do not generate any warnings for unused variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024d797490e6edf809ed5b6c2e34f4bc4f3bebd1" translate="yes" xml:space="preserve">
          <source>Variables take the form &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt;, where &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; is an integer between 0 and 100,000,000 (1e+8). The behavior if the number is outside these limits is &lt;strong&gt;undefined&lt;/strong&gt;. In the &lt;code&gt;MatchHead&lt;/code&gt; part, the special variable &lt;code&gt;'_'&lt;/code&gt; matches anything, and never gets bound (like &lt;code&gt;_&lt;/code&gt; in Erlang).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00bf9ad78f5cec1dd65d66ced1104921a78f995a" translate="yes" xml:space="preserve">
          <source>Variables that are defined before the fun, and that occur in function calls or guard tests within the fun, have the values they had outside the fun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0dcb58581abd4fe80849d394380c5cd405dc3e" translate="yes" xml:space="preserve">
          <source>Variables that are not included in the head are imported from the environment and made into match specification &lt;code&gt;const&lt;/code&gt; expressions. Example from the shell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55df9f3ef32c412357dbc3a18bd56c7d4ce619de" translate="yes" xml:space="preserve">
          <source>Variance :: number(),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e31c4461c806559eaf12528c8fe9a9d293a746d" translate="yes" xml:space="preserve">
          <source>Various &quot;isolate&quot;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d64fcf9bb61fad40e3871e66b33e563f5b1f28" translate="yes" xml:space="preserve">
          <source>Various Erlang net administration routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b924712003f40d3f2878b1cac363cf1976078c" translate="yes" xml:space="preserve">
          <source>Vendor-Id AVP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48eb606505901d94f78b31e43f73e095bdf04786" translate="yes" xml:space="preserve">
          <source>Vendor-Specific-Application-Id AVP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96f73110a27dcecf42e3942850fdb9a84214cad" translate="yes" xml:space="preserve">
          <source>Verbose = &lt;code&gt;boolean()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb0c527629b97acddda692f399e9ccb978796eb" translate="yes" xml:space="preserve">
          <source>Verbosity for a SNMP process. This specifies now much debug info is printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee450697a5689ff92f9f50edecbf9c5c91da171" translate="yes" xml:space="preserve">
          <source>Verifies PKIX x.509 certificate signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4326ee1947d5233b0586b451628ad661e97a0e04" translate="yes" xml:space="preserve">
          <source>Verifies a digital signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ade396ed77dbd522a02203fe6942326134914f" translate="yes" xml:space="preserve">
          <source>Verifies a digital signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9525ebe014b53689fa4e11b528180aae4abeb4b" translate="yes" xml:space="preserve">
          <source>Verifies that the current location of the execution is visible in the code area.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc4741dffd06fe660bc6cd57000623888541a03" translate="yes" xml:space="preserve">
          <source>Verify that &lt;code&gt;Cert&lt;/code&gt; is the &lt;code&gt;CRL&lt;/code&gt; signer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5417e5a99f86d22c5664ec343d3a6c2609ec65a" translate="yes" xml:space="preserve">
          <source>Version 1.6.10 or later of the &lt;strong&gt;asn1&lt;/strong&gt; application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a661417de642bc6b468d76fe5b3c6bc8775de7ac" translate="yes" xml:space="preserve">
          <source>Version 3.11 or later of &lt;strong&gt;this&lt;/strong&gt; application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e5ca082097444de77af1c9fd7d0a5134aed383" translate="yes" xml:space="preserve">
          <source>Version management is enabled for drivers that have set the &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended_marker&lt;/a&gt;&lt;/code&gt; field of their &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;. &lt;code&gt;erl_driver.h&lt;/code&gt; defines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b8714f6e355164babd4f77276d9b70c8b55f19" translate="yes" xml:space="preserve">
          <source>Version numbers in general are only partially ordered. However, normal version numbers (with three parts) as of OTP 17.0 have a total or linear order. This applies both to normal OTP versions and normal application versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e126978ac6222c855c920d79411bed5cf12c2966" translate="yes" xml:space="preserve">
          <source>Version of an application included in the release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473be10b81925976c7e4903e9b43ac593c8ae1c5" translate="yes" xml:space="preserve">
          <source>Version of the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7876f7a0f780d649e426501cf895ebbd7b0903" translate="yes" xml:space="preserve">
          <source>Vertical bar characters are used to separate alternative patterns. For example, the following pattern matches either &quot;gilbert&quot; or &quot;sullivan&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26a73edd5911cc59d619f45a8244a225ed70c75" translate="yes" xml:space="preserve">
          <source>Vertical tab</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd82a7e8d422aaa4b53ae82c82d9414739c27a0" translate="yes" xml:space="preserve">
          <source>Vertical tab (VT)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089b74a153ec7d14e48cc1b72fe57aef02d54503" translate="yes" xml:space="preserve">
          <source>Vertical tab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e9914d64c8384c209127eaf16006134a978f22" translate="yes" xml:space="preserve">
          <source>Very similar to &lt;code&gt;portTypeAcceptor&lt;/code&gt;, an intermediate stage between the request for a connect operation and that the socket is connected to an accepting ditto in the other end. When the sockets are connected, the port switches type to &lt;code&gt;portTypeCommand&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e64e0bec8b57844c72ad51fbe4f769f2b726868" translate="yes" xml:space="preserve">
          <source>Viewer menu:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76c37f0a0334ff643407ad5eae8341e4157dd19" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 (Visual Studio 12.0). Download and run the web installer from:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c915e18af7a75d3dbbd7d92286c7e2d9ac312998" translate="yes" xml:space="preserve">
          <source>Voila! &lt;code&gt;Start-&amp;gt;Programs-&amp;gt;Erlang OTP 21-&amp;gt;Erlang&lt;/code&gt; starts the Erlang Windows shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716dd3292ee085b4712046407eb276268b149ea2" translate="yes" xml:space="preserve">
          <source>Voluntarily lets other processes (if any) get a chance to execute. Using this function is similar to &lt;code&gt;receive after 1 -&amp;gt; ok end&lt;/code&gt;, except that &lt;code&gt;yield()&lt;/code&gt; is faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebf20f8d1333c6ed323b151df8d0b75baeab5a0" translate="yes" xml:space="preserve">
          <source>Wait for an ack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d14f3abfec373cbe89f6626aa814e6ca203b696" translate="yes" xml:space="preserve">
          <source>Wait for reply after having received a pending message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a3dd1877c6b650ce26278dad8e2fb191a587d5" translate="yes" xml:space="preserve">
          <source>Wait for reply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5a9ccfb857e48896b332926f19499a3bf34466" translate="yes" xml:space="preserve">
          <source>Waiting in a &lt;code&gt;receive...after&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e59facfb286b560b3bd7e76028f43e2127a06c" translate="yes" xml:space="preserve">
          <source>Waiting in a &lt;code&gt;receive&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d6ef3cb84dde159db4dc284cfdc308ccef71dd" translate="yes" xml:space="preserve">
          <source>Waiting. This state is currently only identified on Solaris.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c806137ff16518173274ba603d62ffafc3bdf63" translate="yes" xml:space="preserve">
          <source>Waits for a reply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2ac24407b3f1c35309d00d94c7cf3be1ef6a8a" translate="yes" xml:space="preserve">
          <source>Waits on a condition variable. The calling thread is blocked until another thread wakes it by signaling or broadcasting on the condition variable. Before the calling thread is blocked, it unlocks the mutex passed as argument. When the calling thread is woken, it locks the same mutex before returning. That is, the mutex currently must be locked by the calling thread when calling this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9651595cb08f88e44fd940126d1c71dd69f853" translate="yes" xml:space="preserve">
          <source>Waits until data have been committed and logged to disk (if disk is used) on every involved node before it returns, otherwise it behaves as &lt;code&gt;mnesia:transaction/[1,2,3]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d95099fabbff08dd069c5c4ee916cb8f9b1a506" translate="yes" xml:space="preserve">
          <source>Wallclock_Time_Since_Last_Call}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b288f7da975708a0f5e331c0f162ed064cf7c2" translate="yes" xml:space="preserve">
          <source>Warang_Citi</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cea05d9ab0a2033c2e880c88d16336c1ad4134" translate="yes" xml:space="preserve">
          <source>Warn about overspecified functions (the specification is strictly less allowing than the success typing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d2b974a5e842f51243b3499495df6bdd13bcaa" translate="yes" xml:space="preserve">
          <source>Warn about underspecified functions (the specification is strictly more allowing than the success typing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cccd5dcb30984a83e1ff196e1800d93a16fd24a" translate="yes" xml:space="preserve">
          <source>Warn when the specification is different than the success typing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83bd22f6ddfb4c6af6ec49ac28fc7020e55db1cb" translate="yes" xml:space="preserve">
          <source>Warning events were introduced in Erlang/OTP R9C and are enabled by default as from Erlang/OTP 18.0. To retain backwards compatibility with existing user-defined event handlers, the warning events can be tagged as &lt;code&gt;errors&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt; using command-line flag &lt;code&gt;+W &amp;lt;e | i | w&amp;gt;&lt;/code&gt;, thus showing up as &lt;code&gt;ERROR REPORT&lt;/code&gt; or &lt;code&gt;INFO REPORT&lt;/code&gt; in the logs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c71f2eab8af60b63ce0e407c87968c7af135f73" translate="yes" xml:space="preserve">
          <source>Warning option &lt;code&gt;-Wrace_conditions&lt;/code&gt; has no effect when set in source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b855954419a97257855c46e228014ea8104ff80a" translate="yes" xml:space="preserve">
          <source>Warning options can be restricted to functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350f98fe7365f5591c6175d100ed10f345354502" translate="yes" xml:space="preserve">
          <source>Warning: you wanted to visit the site www.example.com, but the certificate is for shop.example.com. Accept anyway (yes/no)?&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa481bc1014e68bf8d7481ee0ba5e89fda097c2" translate="yes" xml:space="preserve">
          <source>We add &lt;code&gt;-heart&lt;/code&gt; to &lt;code&gt;bin/start&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b280a7b7aba8731e641abebde7cc0face25615" translate="yes" xml:space="preserve">
          <source>We already have the data as (Unicode) lists and therefore only split the list in runs of a predefined size and put each run in the table at the current position (and forward). Functions &lt;code&gt;split_data/3&lt;/code&gt; and &lt;code&gt;apply_update/2&lt;/code&gt; are implemented below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5226f0d44c399be112d6e2c67714235696a1e7cd" translate="yes" xml:space="preserve">
          <source>We also see that the call to &lt;code&gt;file:write/2&lt;/code&gt; that writes 1/4 of the file contents takes very little time in itself. What takes time is to build the data (&lt;code&gt;lists:seq/2&lt;/code&gt; and &lt;code&gt;lists:map/2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49ee7e4ad5636419e727eed1a3416350054ba7c" translate="yes" xml:space="preserve">
          <source>We always strive to remain as compatible as possible even in the cases where we give no compatibility guarantees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c06b23c2a34df45341a353c1d6915221b4316d" translate="yes" xml:space="preserve">
          <source>We belive that the truth finally has caught with the following, retired myths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21d18a0aa2c147b58a169cb973ed1ce3338cf1f" translate="yes" xml:space="preserve">
          <source>We call a set of ordered sets (x[1], ..., x[n]) an &lt;strong id=&quot;n_ary_relation&quot;&gt;(n-ary) relation&lt;/strong&gt;, and say that the relation is a subset of the Cartesian product X[1] &amp;times; ... &amp;times; X[n], where x[i] is an element of X[i], 1 &amp;lt;= i &amp;lt;= n.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413c823c35b15bc9d9bba19b8e901ed4a84786b5" translate="yes" xml:space="preserve">
          <source>We call disconnect to log out from the database. (This should have been done from Erlang, but just in case.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a622cc685c06ebc1847f597b7b757bf135bf65a2" translate="yes" xml:space="preserve">
          <source>We can also start a distributed system (requires &lt;code&gt;bin/epmd&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27be01791833f5e7361c562bc0586ab7a53f67b" translate="yes" xml:space="preserve">
          <source>We can in this example hibernate in the &lt;code&gt;{open,_}&lt;/code&gt; state, because what normally occurs in that state is that the state time-out after a while triggers a transition to &lt;code&gt;{locked,_}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723ac72181a0f65089e1039932052a9e46e076de" translate="yes" xml:space="preserve">
          <source>We can now continue with further analyses, or we can delete the Xref server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256ebb1297d3c5168e6d4942a26c829b8f6be203" translate="yes" xml:space="preserve">
          <source>We continue trying to write until the queue is empty or the writing blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598054eadf14bd6e3fc4f983c0ea4bf5d2acfe0d" translate="yes" xml:space="preserve">
          <source>We could find the size of the closure of the module graph with a loop similar to one used for the function graph, but since the module graph is so much smaller, a more direct method is feasible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1991f07b9f9058aea6db1e8f77c1b4a56e270edc" translate="yes" xml:space="preserve">
          <source>We could say that the button was pressed too early so it is not to be recognized as the lock button. Or we can make the lock button part of the state so when we then change the lock button in the locked state, the change becomes a state change and all postponed events are retried, therefore the lock is immediately locked!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9ed4b8c10518737f16e11ac495badece57b9c4" translate="yes" xml:space="preserve">
          <source>We create the table using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32473b5c4698fb40d28c5576c29bf1a8447287f7" translate="yes" xml:space="preserve">
          <source>We define the state as &lt;code&gt;{StateName,LockButton}&lt;/code&gt;, where &lt;code&gt;StateName&lt;/code&gt; is as before and &lt;code&gt;LockButton&lt;/code&gt; is the current lock button:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e5b4ef345a93f5049df742fe31287578cf4c7e2" translate="yes" xml:space="preserve">
          <source>We do not need a sub-agent for each table holder. Normally, the sub-agent is needed to take care of communication, but in Distributed Erlang we use ordinary message passing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcce44305924654369f1be725b80d831eab3129" translate="yes" xml:space="preserve">
          <source>We execute a query and encode the result. Encoding is done in another C module, &lt;code&gt;pg_encode.c&lt;/code&gt;, which is also provided as sample code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fc2d127a89f720c3128d44e169672e74e15c80" translate="yes" xml:space="preserve">
          <source>We fill the table with randomly chosen data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1b0d2fdb890ab43ab70bb52624aa632e05a8ee" translate="yes" xml:space="preserve">
          <source>We find no particulary long suspend times, so no function seems to have waited in a receive statement. Actually, &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; contains a receive statement, but in this test program, the message lies in the process receive buffer when the receive statement is entered. We also see that the total suspend time for the test run is small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="539abdc8c79a99e16a54fd4c1353932c38835c6d" translate="yes" xml:space="preserve">
          <source>We get all features of Mnesia, such as fault tolerance, persistent data storage, replication, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162b9af34243f4c75d056a06375ee57f22d03768" translate="yes" xml:space="preserve">
          <source>We handle the requests for retrieving data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82bb167cd1f1aaced33ce89ec08193896c8c8861" translate="yes" xml:space="preserve">
          <source>We have a structure to store state needed by the driver, in this case we only need to keep the database connection:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f2ae2c27d8d0a5f2644b532540797a414ff961" translate="yes" xml:space="preserve">
          <source>We have included some simple tool(s) for codec measurement (meas), performance tests (mstone1 and mstone2) and message transformation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d35a0217a0c4d25516c55c6b13eeb0ee82ce246" translate="yes" xml:space="preserve">
          <source>We have instrumented our code in order to enable tracing. Running the application with tracing deactivated, causes a negligible performance overhead (an external call to a function which returns an atom). Activation of tracing does not require any recompilation of the code, since we rely on Erlang/OTP's built in support for dynamic trace activation. In our case tracing of calls to a given external function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f3224f897b7485ee092aee943fad0f50d468c0" translate="yes" xml:space="preserve">
          <source>We have introduced the term &quot;user&quot; as a generic term for either an MG or an MGC, since most of the functionality we support, is common for both MG's and MGC's. A (local) user may be configured in various ways and it may establish any number of connections to its counterpart, the remote user. Once a connection has been established, the connection is supervised and it may be used for the purpose of sending messages. N.B. according to the standard an MG is connected to at most one MGC, while an MGC may be connected to any number of MG's.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877518c89585383e3076c104aa3cd7f7e23bc498" translate="yes" xml:space="preserve">
          <source>We have made four different measurements of our Erlang/OTP implementation of the Megaco/H.248 protocol stack, in order to compare our different encoders/decoders. The result of each one is summarized in the table below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e594586e3be21133f5db0b9bde85bb9f42084bb6" translate="yes" xml:space="preserve">
          <source>We have sometimes experienced problems with Oracle's &lt;code&gt;java&lt;/code&gt; running out of memory when running &lt;code&gt;fop&lt;/code&gt;. Increasing the amount of memory available as follows has in our case solved the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc0044e17c922875d4350027f6b2f290ff7821f" translate="yes" xml:space="preserve">
          <source>We include &lt;code&gt;FromPid&lt;/code&gt; just in case we want to trace this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c14d96eb9053e2cc8b3f1d2c457d07c9567687" translate="yes" xml:space="preserve">
          <source>We loop through the requests one at the time, stopping when we either encounter an error or the list is exhausted. The last return value is sent back to the client (it is first returned to the main loop and then sent back by function &lt;code&gt;io_reply&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a36c7a61f34ba2a33c8e34b5446fa5e93cb80751" translate="yes" xml:space="preserve">
          <source>We match on the top element and embed the inner parts in an HTML body. Then we extract the string values of all motorcycle brands, sort them and removes duplicates by &lt;code&gt;remove_duplicates(value_of(select(&quot;bike/name/manufacturer&quot;, E)))&lt;/code&gt;. We also process the substructure of the top element and pass it to a function that sorts all motorcycle information by brand according to the task formulation in the beginning of this example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc0e2937cea34ba0f1d5aa2eb64c711b2673f69" translate="yes" xml:space="preserve">
          <source>We need to handle backward compatibility and the &lt;code&gt;file&lt;/code&gt; module (which uses the old requests until backward compatibility with pre-R13 nodes is no longer needed). Notice that the I/O server does not work with a simple &lt;code&gt;file:write/2&lt;/code&gt; if these are not added:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6ac95529809d2ef950ae107e48095fe8aabd08" translate="yes" xml:space="preserve">
          <source>We need to handle some requests. First the requests for writing characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65164610102defaf9d5b21fb95ba5620406fc14d" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;code&gt;-callback&lt;/code&gt; attribute rather than the &lt;code&gt;behaviour_info()&lt;/code&gt; function. The reason is that the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="346c9aa8780b8aa277233c8030ef3ce8528b2a4f" translate="yes" xml:space="preserve">
          <source>We refer to these as &quot;automatic metavariables&quot;. If in addition the name ends with &lt;code&gt;@&lt;/code&gt;, as in &lt;code&gt;_@Foo@&lt;/code&gt;, the value of the variable as an Erlang term will be automatically converted to the corresponding abstract syntax tree when used to construct a larger tree. For example, in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a9f8a4bc23ba990af592e409f5c51b8ea523ef" translate="yes" xml:space="preserve">
          <source>We see that &lt;code&gt;file:write/2&lt;/code&gt; only calls &lt;code&gt;prim_file:write/2&lt;/code&gt;, but let us refrain from digging into the internals of the kernel application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3b22518344463198707dd795380094d0c8925a" translate="yes" xml:space="preserve">
          <source>We see that the new release version is &lt;code&gt;permanent&lt;/code&gt;, so it would be safe to restart the node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50565a62199c6c141d92fc8afb4546283ef2fd4" translate="yes" xml:space="preserve">
          <source>We simply pick out an I/O vector from the queue (which is the whole queue as a &lt;code&gt;SysIOVec&lt;/code&gt;). If the I/O vector is too long (&lt;code&gt;IO_VECTOR_MAX&lt;/code&gt; is defined to 16), the vector length is decreased (line 15), otherwise the &lt;code&gt;writev&lt;/code&gt; call (line 17) fails. Writing is tried and anything written is dequeued (line 27). If the write fails with &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (notice that all sockets are in non-blocking mode), &lt;code&gt;driver_select&lt;/code&gt; is called to make the &lt;code&gt;uds_output&lt;/code&gt; routine be called when there is space to write again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0ada7dbfa4e9b0738c600e7e0aaa004c64d9416" translate="yes" xml:space="preserve">
          <source>We specify the filter, we want to view calls that resemble &lt;code&gt;ets:new(toy_table, &amp;lt;something&amp;gt;)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1235892250491b3de3e5ff2495a68e9d2682e8e0" translate="yes" xml:space="preserve">
          <source>We start a &lt;strong&gt;simple target system&lt;/strong&gt; as above. The only difference is that also the file &lt;code&gt;releases/RELEASES&lt;/code&gt; is present for code replacement in runtime to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c601e5855e0a64b0a4dc2997f72bc0154a5ac01a" translate="yes" xml:space="preserve">
          <source>We start writing the example Unix domain sockets driver by declaring prototypes and filling in a static &lt;code&gt;ErlDrvEntry&lt;/code&gt; structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644c408e343363fe6260f95a6a30cda576bd3ce6" translate="yes" xml:space="preserve">
          <source>We store the &lt;code&gt;creation&lt;/code&gt; serial number in the file. The &lt;code&gt;creation&lt;/code&gt; is a number that is to change between different instances of different Erlang emulators with the same name, so that process identifiers from one emulator do not become valid when sent to a new emulator with the same distribution name. The creation can be from 0 through 3 (two bits) and is stored in every process identifier sent to another node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a6ffdb62bb132307bcc5f5fe297a041b9ec3d7" translate="yes" xml:space="preserve">
          <source>We strongly encourage the use of the &lt;code&gt;RowStatus&lt;/code&gt; convention for every table that can be modified from the manager, even for newly designed SNMPv1 MIBs. In SNMPv1, everybody has invented their own scheme for emulating table operations, which has led to numerous inconsistencies. The convention in SNMPv2 is flexible and powerful and has been tested successfully. If the table is read only, no RowStatus column should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="508ccb34921947b5beb2005777369f595ad7c8a8" translate="yes" xml:space="preserve">
          <source>We study the state that is needed for the ports. Notice that not all fields are used for all types of ports. Some space could be saved by using unions, but that would clutter the code with multiple indirections, so here is used one struct for all types of ports, for readability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0570780114e9fc609087371872169fccbd297f49" translate="yes" xml:space="preserve">
          <source>We suspect the &lt;code&gt;ets:new/2&lt;/code&gt; call, as we match hard on the return value, but want only the particular &lt;code&gt;new/2&lt;/code&gt; call with &lt;code&gt;toy_table&lt;/code&gt; as first parameter. So we start a default tracer on the node:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5bbffab7f95f81cee247421bd092ab29a87848d" translate="yes" xml:space="preserve">
          <source>We turn on call tracing for all processes, we want to make a pretty restrictive trace pattern, so there is no need to call trace only a few processes (usually it is not):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f43c3a056dd53d064433399740ce5398c03179" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;dbg:tpl/3&lt;/code&gt; to ensure to catch local calls (assume that the module has grown since the smaller version and we are unsure if this inserting of atoms is not done locally). When in doubt, always use local call tracing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db459c71765166584b222966eebe056c8bcb451" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;port_control/3&lt;/code&gt; function for all calls into the driver. The result from the driver is returned immediately and converted to terms by calling &lt;code&gt;binary_to_term/1&lt;/code&gt;. (We trust that the terms returned from the driver are well-formed, otherwise the &lt;code&gt;binary_to_term&lt;/code&gt; calls could be contained in a &lt;code&gt;catch&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02fb426878fcef94b8e18d9576286ad65ac4ed4a" translate="yes" xml:space="preserve">
          <source>We use the binary format only to return data to the emulator; input data is a string parameter for &lt;code&gt;connect&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;. The returned data consists of Erlang terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014d84a4d3abb1236ee92db9f5f0d5547ff6a186" translate="yes" xml:space="preserve">
          <source>We use the function &lt;code&gt;Rep&lt;/code&gt; to denote the mapping from an Erlang source construct &lt;code&gt;C&lt;/code&gt; to its abstract format representation &lt;code&gt;R&lt;/code&gt;, and write &lt;code&gt;R = Rep(C)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b955b8cc53f04946e7906d8bccd83ad77bc547a4" translate="yes" xml:space="preserve">
          <source>We use the same internal form for both the binary and text encoding. Our internal form of Megaco/H.248 messages is heavily influenced by the internal format used by ASN.1 encoders/decoders:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09eafdf76bfe34feacf5ab1510c6a7720bed3f57" translate="yes" xml:space="preserve">
          <source>We use the simplest possible &lt;code&gt;sys.config&lt;/code&gt;, which we store in &lt;code&gt;releases/FIRST&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d8589e4a15b7a5013c9800a611e86facb44e60" translate="yes" xml:space="preserve">
          <source>We very much welcome user feedback - even wishlists! If you notice anything weird, especially if Dialyzer reports any discrepancy that is a false positive, please send an error report describing the symptoms and how to reproduce them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f285e2cc8e54c3430820d9c7f8e8768e8a5b79" translate="yes" xml:space="preserve">
          <source>We want a locking mechanism that gives no race conditions, to be sure if another Erlang node uses the listen socket name we require or if the file is only left there from a previous (crashed) session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d62af079f72041cf5e740a82dc4dbd33004d95" translate="yes" xml:space="preserve">
          <source>We want to find the reduction of the closure of the function graph to modules. The direct expression for doing that would be &lt;code&gt;(Mod)&amp;nbsp;(closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;AM)&lt;/code&gt;, but then we would have to represent all of the transitive closure of E in memory. Instead the number of indirectly used modules is found for each analyzed module, and the sum over all modules is calculated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1cec4b25e7ec82e4a29c249c1772265612c2f98" translate="yes" xml:space="preserve">
          <source>We will first go through the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure which people probably are most familiar with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ff38c2602baf56bc8c3440d3937fb894b7ad10" translate="yes" xml:space="preserve">
          <source>We will not be bug-compatible. A bug fix might introduce incompatible changes. This kind of incompatibility might occur in a patch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad9e6cc5dd978296e9f3155b1fac5bd4e904894" translate="yes" xml:space="preserve">
          <source>We will see more details of this later. If you want to experiment with distributed Erlang, but you only have one computer to work on, you can start two separate Erlang systems on the same computer but give them different names. Each Erlang system running on a computer is called an &lt;strong&gt;Erlang node&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd397370c00ee4d81771bc1a4690627c9a9c47d" translate="yes" xml:space="preserve">
          <source>We would recommend using 1.0.2d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843043fadfaea89e297baed2f38224161728a8fc" translate="yes" xml:space="preserve">
          <source>We write it using &lt;code&gt;ets:fun2ms/1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d11ec20af5e84fd81824db4ba0a8cd93159b8e2" translate="yes" xml:space="preserve">
          <source>We've tried up to 1.0, but the latest version should do. Make sure you download the &lt;code&gt;mingw-w64-bin_i686-mingw_&amp;lt;something&amp;gt;.zip&lt;/code&gt;, not a linux version. You unzip the package on top of your MinGW installation (&lt;code&gt;c:\MinGW&lt;/code&gt;) and that's it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8eef6e94eb7100a713ed2ea56c1d7018de92907" translate="yes" xml:space="preserve">
          <source>We've used this build procedure for a couple of releases, and it has worked fine for us. Still, there might be all sorts of troubles on different machines and with different setups. We'll try to give hints wherever we've encountered difficulties, but please share your experiences by using the &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;erlang-questions&lt;/a&gt;&lt;/code&gt; mailing list. We cannot, of course, help everyone with all their issues, so please try to solve such issues and submit solutions/workarounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36b032611690f561af6ed7868e7f249080a2d29" translate="yes" xml:space="preserve">
          <source>Web server users without server administrative privileges that need to manage authentication of web pages that are local to their user can use the per-directory runtime configurable user-authentication scheme &lt;code&gt;htaccess&lt;/code&gt;. It works as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee3b99c66ed2c1f02ee33b7f98ce7fdcb23b424" translate="yes" xml:space="preserve">
          <source>Welcome to Erlang/OTP, a complete development environment for concurrent programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c886918035c78f6182ee187f960d0ece83d0bb" translate="yes" xml:space="preserve">
          <source>What is a printable character in this case is determined by startup flag &lt;code&gt;+pc&lt;/code&gt; to the Erlang VM; see &lt;code&gt;&lt;a href=&quot;io#printable_range-0&quot;&gt;io:printable_range/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4edfb9d438187e25e8117b3d96348c8b942d6ff3" translate="yes" xml:space="preserve">
          <source>What is captured in this example is the part of the work the shell does while interpreting the command line that occurs between the actual calls to &lt;code&gt;cprof:start()&lt;/code&gt; and &lt;code&gt;cprof:analyse()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8308f9197a4bcfd38df815152af92e5bca4b765b" translate="yes" xml:space="preserve">
          <source>What makes the &lt;code&gt;Mnesia&lt;/code&gt; data model an extended relational model is the ability to store arbitrary Erlang terms in the attribute fields. One attribute value can, for example, be a whole tree of OIDs leading to other terms in other tables. This type of record is difficult to model in traditional relational DBMSs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405eee64426a95cf4618da03e92872e8805137ae" translate="yes" xml:space="preserve">
          <source>What more can you do? A simple answer is: see the documentation of &lt;code&gt;match specifications&lt;/code&gt; in ERTS User's Guide. However, the following is a brief overview of the most useful &quot;built-in functions&quot; that you can use when the fun is to be translated into a match specification by &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt;. It is not possible to call other functions than those allowed in match specifications. No &quot;usual&quot; Erlang code can be executed by the fun that is translated by &lt;code&gt;ets:fun2ms/1&lt;/code&gt;. The fun is limited exactly to the power of the match specifications, which is unfortunate, but the price one must pay for the execution speed of &lt;code&gt;ets:select/2&lt;/code&gt; compared to &lt;code&gt;ets:foldl/foldr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9abe5ff356944e50659de71982880b18848dd6" translate="yes" xml:space="preserve">
          <source>What reservation of physical memory means, highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587af77c14f789357e51980e72003df91f480665" translate="yes" xml:space="preserve">
          <source>What the &lt;code&gt;qlc&lt;/code&gt; module primarily adds to list comprehensions is that data can be read from QLC tables in small chunks. A QLC table is created by calling &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt;. Usually &lt;code&gt;qlc:table/2&lt;/code&gt; is not called directly from the query but through an interface function of some data structure. Erlang/OTP includes a few examples of such functions: &lt;code&gt;mnesia:table/1,2&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ets#table-1&quot;&gt;ets:table/1,2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;dets#table-1&quot;&gt;dets:table/1,2&lt;/a&gt;&lt;/code&gt;. For a given data structure, many functions can create QLC tables, but common for these functions is that they return a query handle created by &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt;. Using the QLC tables provided by Erlang/OTP is usually probably sufficient, but for the more advanced user section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; describes the implementation of a function calling &lt;code&gt;qlc:table/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e307252350d5f0ef992b3ab620b890f8bd198517" translate="yes" xml:space="preserve">
          <source>What the I/O server sends when there is no data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1804d21d5ef8f5b8cb1f89c4e94fe07aef9672aa" translate="yes" xml:space="preserve">
          <source>What this means, if anything, is implementation dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86e62a665b180d594c01dd61c21371b36d33af5" translate="yes" xml:space="preserve">
          <source>What you have to do in such cases is to write your metavariable in a syntactically valid position, and use lifting markers to denote where it should really apply, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c621a34cc77c693f796b9c9a4e0202b514808a" translate="yes" xml:space="preserve">
          <source>Whatever added by &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; in the test suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e65ac25edcc6a715cbfb229eba192595c676d46" translate="yes" xml:space="preserve">
          <source>When (*SKIP) has an associated name, its behavior is modified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fe958830198355cc811da35c494d7c1c3c2d18" translate="yes" xml:space="preserve">
          <source>When (finally?) everything is in order with the locale settings, fonts. and the terminal emulator, you have probably found a way to input characters in the script you desire. For testing, the simplest way is to add some keyboard mappings for other languages, usually done with some applet in your desktop environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c61293396a0994c6191d7911346e57c38611cf9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-2&quot;&gt;logger:set_handler_config/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#update_handler_config-2&quot;&gt;logger:update_handler_config/2&lt;/a&gt;&lt;/code&gt; is called, Logger calls &lt;code&gt;HModule:changing_config(OldConfig, NewConfig)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,NewConfig1}&lt;/code&gt;, Logger writes &lt;code&gt;NewConfig1&lt;/code&gt; to the configuration database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e75014a8819db24d123ffe574cf1058af1d7b3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Addr&lt;/code&gt; does not contain a port number, the value of &lt;code&gt;port&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3df4cc98d21f4d7157a7f5c03ed4afe7255c29" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;: if &lt;code&gt;Info&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;Result&lt;/code&gt; is returned by &lt;code&gt;erlang:cancel_timer()&lt;/code&gt;. otherwise &lt;code&gt;ok&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c3055751c190947148414125cb3febf1e8f6f5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;: if &lt;code&gt;Info&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a message on the form &lt;code&gt;{cancel_timer, TimerRef, Result}&lt;/code&gt; is sent to the caller of &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; when the cancellation operation has been performed, otherwise no message is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166a240b6e5cc60a7634b1583a60930de57018f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Common Test&lt;/code&gt; starts, it automatically attempts to compile any suites included in the specified tests. If particular suites are specified, only those suites are compiled. If a particular test object directory is specified (meaning all suites in this directory are to be part of the test), &lt;code&gt;Common Test&lt;/code&gt; runs function &lt;code&gt;make:all/1&lt;/code&gt; in the directory to compile the suites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42507199eef19752873563b14392dfa940c65fc9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Mnesia&lt;/code&gt; loads many tables, the default load order is used. However, the load order can be affected, by explicitly changing property &lt;code&gt;load_order&lt;/code&gt; for the tables, with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_load_order-2&quot;&gt;mnesia:change_table_load_order(Tab, LoadOrder)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;LoadOrder&lt;/code&gt; is by default &lt;code&gt;0&lt;/code&gt; for all tables, but it can be set to any integer. The table with the highest &lt;code&gt;load_order&lt;/code&gt; is loaded first. Changing the load order is especially useful for applications that need to ensure early availability of fundamental tables. Large peripheral tables are to have a low load order value, perhaps less than &lt;code&gt;0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69de3dae19f69610dd34e83bd997df060a7428e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, and &lt;code&gt;Arguments&lt;/code&gt; are provided, we apply it and do the same with the result as if the data was provided directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52ee13a4dcb299f5a385cfe15fc42403a860bc7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; calls a traced function. The return values of calls are never supplied, only the call and its arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323d59db6fafd89e5c07401fb7993540b99d690e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; exits &lt;strong&gt;from&lt;/strong&gt; the specified function because of an exception. This trace message is sent if flag &lt;code&gt;call&lt;/code&gt; is set, and the function has a match specification with an &lt;code&gt;exception_trace&lt;/code&gt; action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3d1426688af7f3815ab8ffb8557afa8cf69def" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; exits with reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a10c0e2595bc6a45b793e623dbb1d7e74c4840d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is scheduled out. The process was running in function {M, F, Arity}. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885b32e12e9f0ba67537b4a0349bf3e528dd7008" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is scheduled to run. The process runs in function &lt;code&gt;{M, F, Arity}&lt;/code&gt;. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2579456f2ac4547aa51c7500a5011980e64fed27" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is spawned by process &lt;code&gt;Pid2&lt;/code&gt; with the specified function call as entry point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6d840360c675d28fb4189ea75bcf500ea96744" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; links to a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0d2e5fb513b27fbae59d57a8659f003a4ecf83" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; opens a new port &lt;code&gt;Port&lt;/code&gt; with the running &lt;code&gt;Driver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ed889ebc9aca15515c2b45ca1a374fd67cf415" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; removes the link from a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5751eed2112a0c8b568fa52ffcbeb3e9cb0f2b8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; returns &lt;strong&gt;from&lt;/strong&gt; the specified function. This trace message is sent if flag &lt;code&gt;call&lt;/code&gt; is set, and the function has a match specification with a &lt;code&gt;return_trace&lt;/code&gt; or &lt;code&gt;exception_trace&lt;/code&gt; action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbfdb05819ccf5c6584d296609a8e52d12c64f1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; returns &lt;strong&gt;to&lt;/strong&gt; the specified function. This trace message is sent if both the flags &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; are set, and the function is set to be traced on &lt;strong&gt;local&lt;/strong&gt; function calls. The message is only sent when returning from a chain of tail recursive function calls, where at least one call generated a &lt;code&gt;call&lt;/code&gt; trace message (that is, the functions match specification matched, and &lt;code&gt;{message, false}&lt;/code&gt; was not an action).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba46a646e37ed8b7d35c674ed3b3e32924ba03e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; spawns a new process &lt;code&gt;Pid2&lt;/code&gt; with the specified function call as entry point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc371b2356f9951c5abbb937169272313d56c71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets linked to a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972a925137e0ccb08bc5aeffdfecb3782e3bc889" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets the name &lt;code&gt;RegName&lt;/code&gt; registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162e33555c86a661514ef9d4a857ec534b5a22a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets the name &lt;code&gt;RegName&lt;/code&gt; unregistered. This is done automatically when a registered process or port exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb1d708bf63c2940ea863c472a540929d8d0a03" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets unlinked from a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a6470e961b2d5912dd59eb5021ef79f690f562" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; receives message &lt;code&gt;Msg&lt;/code&gt;. If &lt;code&gt;Msg&lt;/code&gt; is set to time-out, a receive statement can have timed out, or the process received a message with the payload &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87cde17521c68e2a936fe17936bf5ceeb2c3d14" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; sends message &lt;code&gt;Msg&lt;/code&gt; to process &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61e6201a42785b41b69c2b7a25abb9b7fd4f07c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; sends message &lt;code&gt;Msg&lt;/code&gt; to the non-existing process &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15233790daaa8247a54c54b5c9b5074f4bf171a9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; closes with &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80787715e672faf25567796cfbe4be1ecff2d7f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; is scheduled out. The last command run was &lt;code&gt;Command&lt;/code&gt;. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;Command&lt;/code&gt; can contain the same commands as &lt;code&gt;in&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ef0bd2183c0bb797164fa66a45ee2bd8c3d2cf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; is scheduled to run. &lt;code&gt;Command&lt;/code&gt; is the first thing the port will execute, it can however run several commands before being scheduled out. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763a821ae322d45ebff08f1076aa08fd98dc4152" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;accept&lt;/code&gt; is issued, the values of the listening socket options are inherited. No such application variable is therefore needed for &lt;code&gt;accept&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a84fa4a21d8059b923917b5063cf77ca5a084f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/2,3&lt;/code&gt; is used with wrap logs, the returned continuation might not be valid in the next call to &lt;code&gt;chunk()&lt;/code&gt;. This is because the log can wrap and delete the file into which the continuation points. To prevent this, the log can be blocked during the search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b575a5e86459930acb9d9587352f01c78bb4d138" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/3&lt;/code&gt; is called, &lt;code&gt;N&lt;/code&gt; controls the maximum number of terms that are read from the log in each chunk. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which means that all the terms contained in the 64 kilobyte chunk are read. If less than &lt;code&gt;N&lt;/code&gt; terms are returned, this does not necessarily mean that the end of the file is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8aa73939a31b631da4d86b608b56e6f570baca" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/3&lt;/code&gt; is called, &lt;code&gt;N&lt;/code&gt; controls the maximum number of terms that are read from the log in each chunk. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which means that all the terms contained in the 8K chunk are read. If less than &lt;code&gt;N&lt;/code&gt; terms are returned, this does not necessarily mean that end of file is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99ff5779b67a6b782f749fc2ebb582cf983dde5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;erlang:system_flag(scheduler_bind_type, How)&lt;/code&gt; is called, an asynchronous signal is sent to all schedulers online, causing them to try to bind or unbind as requested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7f20feb6d8e86e2be7182c1146591f5b2c10e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;float/1&lt;/code&gt; is used in an expression in a guard, such as '&lt;code&gt;float(A) == 4.0&lt;/code&gt;', it converts a number as described earlier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71613609aa61c62cf20cbe58dfba008b2ab16c3a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;format_temps&lt;/code&gt; is called the first time, &lt;code&gt;City&lt;/code&gt; gets the value &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; and &lt;code&gt;Rest&lt;/code&gt; is the rest of the list. So the function &lt;code&gt;print_temp(convert_to_celsius({moscow,{c,-10}}))&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb83110e8f27a779d6f37f6cb1a70e2e21776a8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;handle_connect/2,3&lt;/code&gt; is triggered by an explicit call to &lt;code&gt;megaco:connect/4,5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672bdd7739faf4a0068adc26b9d59100e10bc739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;httpd&lt;/code&gt; is shut down, it tries to execute &lt;code&gt;remove/1&lt;/code&gt; in each Erlang web server callback module. The programmer can use this function to clean up resources created in the store function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34c8eb52d34fbd9a9b37c654c599a9d1639ad3b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;make install&lt;/code&gt; has finished, change directory into &lt;code&gt;$DESTDIR&lt;/code&gt;, package the system, move it to the target machine, and unpack it. Note that the installation will only be working on the target machine at the location determined by &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6458c29bc8527ea3593b744f1b95db5d14bc00a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;schema_location&lt;/code&gt; is set to &lt;code&gt;opt_disc&lt;/code&gt;, the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/3&lt;/a&gt;&lt;/code&gt; can be used to change the storage type of the schema. This is illustrated as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7039593357562dd4f3df83c986379cb1c6cf4e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;sys:get_status/1,2&lt;/code&gt; is called, &lt;code&gt;gen_event&lt;/code&gt; ensures that its return value contains &lt;code&gt;Status&lt;/code&gt; in place of the state term of the event handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5455489a72db154806b1402161102765e042f513" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_ack_maxcount&lt;/code&gt; number of ack's has been received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6f023a935d787f78f929b26ccb79c057c7e544" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_req_maxcount&lt;/code&gt; number of requests's has been received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4691b74e02fcb2a43c31be2ce08725b89f8c00a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_timer&lt;/code&gt; expires.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f62e8b515ecdd9f175ebeef24a151629f33f401" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trap_exit&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, exit signals arriving to a process are converted to &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; messages, which can be received as ordinary messages. If &lt;code&gt;trap_exit&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, the process exits if it receives an exit signal other than &lt;code&gt;normal&lt;/code&gt; and the exit signal is propagated to its linked processes. Application processes are normally not to trap exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb45a25cdcc4004483ae5e0296eb6055f647d85a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, sent multicast packets are looped back to the local sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10db437ea36ac965fd403789d69242cf01a29208" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;{active, true}&lt;/code&gt;, data is delivered on the form &lt;code&gt;port&lt;/code&gt; : &lt;code&gt;{S, {data, [H1,..Hsz | Data]}}&lt;/code&gt; or &lt;code&gt;term&lt;/code&gt; : &lt;code&gt;{tcp, S, [H1..Hsz | Data]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50818e5b2ee1eb06b98eca2c46320af1c49650c8" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;Reason&lt;/strong&gt; is &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; it means that the net_if process failed to send the message. This could happen because of any number of reasons, i.e. encoding error. &lt;strong&gt;ActualReason&lt;/strong&gt; is the actual reason in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f41f432bb6d6b04eaeac809774055cb313c3684" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;Reason&lt;/strong&gt; is &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; it means that the net_if process failed to send the message. This could happen because of any number of reasons, i.e. encoding error. &lt;strong&gt;R&lt;/strong&gt; is the actual reason in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8aec189a88e9a30ca27fcd657c83b4b7d31fa73" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;var_and_val()&lt;/strong&gt; is &lt;strong&gt;{oid(), value()}&lt;/strong&gt;, the manager makes an educated guess based on the loaded mibs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccaef80e646aaabd78d92b0630d31df5f39a479a" translate="yes" xml:space="preserve">
          <source>When Cover is stopped, all Cover compiled modules are unloaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce23e1563e5351f589159eb5b770cd3cbd2e8d8c" translate="yes" xml:space="preserve">
          <source>When Debugger is started in global mode (which is the default, see &lt;code&gt;&lt;a href=&quot;debugger#start-0&quot;&gt;debugger:start/0&lt;/a&gt;&lt;/code&gt;), modules added (or deleted) for interpretation are added (or deleted) on all known Erlang nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8c9662238adfc3364171ed2abae67b6db526e0" translate="yes" xml:space="preserve">
          <source>When EDNS is enabled (resolver option &lt;code&gt;edns&lt;/code&gt; is set to the EDNS version (that is, &lt;code&gt;0&lt;/code&gt; instead of &lt;code&gt;false&lt;/code&gt;), resolver option &lt;code&gt;udp_payload_size&lt;/code&gt; sets the limit. If a name server replies with the TC bit set (truncation), indicating that the answer is incomplete, the query is retried to that name server using TCP. Resolver option &lt;code&gt;udp_payload_size&lt;/code&gt; also sets the advertised size for the maximum allowed reply size, if EDNS is enabled, otherwise the name server uses the limit 512 bytes. If the reply is larger, it gets truncated, forcing a TCP requery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360f7568d87827777af3aa56a826957938118e43" translate="yes" xml:space="preserve">
          <source>When EUnit traverses the test representation in order to run the tests, the new generator will not be called to produce the next test until the previous test has been executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f08e2448799430bb11532279edecae41a087b4a7" translate="yes" xml:space="preserve">
          <source>When Erlang is started with &lt;code&gt;-oldshell&lt;/code&gt; or &lt;code&gt;-noshell&lt;/code&gt;, the I/O server for &lt;code&gt;standard_io&lt;/code&gt; is by default set to bytewise encoding, while an interactive shell defaults to what the environment variables says.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e501fa18494f297571df6ce7eaf406fc86c93dea" translate="yes" xml:space="preserve">
          <source>When Erlang starts up it reads the Kernel variable &lt;code&gt;inetrc&lt;/code&gt;, which, if defined, is to specify the location and name of a user configuration file. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128caf28b58716150fb0bb58c207dbe8dd83fd4e" translate="yes" xml:space="preserve">
          <source>When Erlang was designed, it was assumed that the wall clock time in the system showed a monotonic time moving forward at exactly the same pace as the definition of time. This more or less meant that an atomic clock (or better time source) was expected to be attached to your hardware and that the hardware was then expected to be locked away from any human tinkering forever. While this can be a compelling thought, it is simply never the case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fa1c320969db01352828d7fe383abc4a1895e0" translate="yes" xml:space="preserve">
          <source>When Erlang/OTP is started, the system searches for a file named &lt;code&gt;.erlang&lt;/code&gt; in the user's home directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f71d6c7e7a2c0c5ada3244d6eb663b401f9b01" translate="yes" xml:space="preserve">
          <source>When PER is used, there is a significant difference in the encoding scheme between &lt;code&gt;OCTET STRING&lt;/code&gt;s and other strings. The constraints specified for a type are especially important for PER, where they affect the encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b03f5d92803d36900a526928289b233412ad464" translate="yes" xml:space="preserve">
          <source>When SSL/TLS performs certificate path validation according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280 &lt;/a&gt;&lt;/code&gt; it should also perform CRL validation checks. To enable the CRL checks the application needs access to CRLs. A database of CRLs can be set up in many different ways. This module provides the behavior of the API needed to integrate an arbitrary CRL cache with the erlang ssl application. It is also used by the application itself to provide a simple default implementation of a CRL cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27327d683c2a19be0af9413a3ffb06c50231cc3" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Addr&lt;/code&gt; is not specified i.e by using only a &lt;code&gt;Domain&lt;/code&gt; atom, the host's name is resolved to find the IP address, and the value of &lt;code&gt;port&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dab5adc2b60fbe4714b50e24055b1753a3e2460" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;CHOICE&lt;/code&gt; contains an extension marker and the decoder detects an unknown alternative of the &lt;code&gt;CHOICE&lt;/code&gt;, the value is represented as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1d4d39dc5b42bbde592ff2e91a12f51026609b" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SEQUENCE&lt;/code&gt; or &lt;code&gt;SET&lt;/code&gt; contains an extension marker and extension components as the following, the type can get more components in newer versions of the ASN.1 spec:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6259eac0d0652866c8be2d5774deb52d326c9816" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;process&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; monitor is triggered, a &lt;code&gt;'DOWN'&lt;/code&gt; message is sent that has the following pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dabb982d5bde66066a06ee6a787d40663b30219a" translate="yes" xml:space="preserve">
          <source>When a NETCONF server receives a &lt;code&gt;close-session&lt;/code&gt; request, it gracefully closes the session. The server releases any locks and resources associated with the session and gracefully closes any associated connections. Any NETCONF requests received after a &lt;code&gt;close-session&lt;/code&gt; request are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aef919ab5c9d7ca0a1f781798e898aede6e2d15" translate="yes" xml:space="preserve">
          <source>When a NIF library is built, information about the NIF API version is compiled into the library. When a NIF library is loaded, the runtime system verifies that the library is of a compatible version. &lt;code&gt;erl_nif.h&lt;/code&gt; defines the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618a279b6e67c1feb5bfb9caf244cc07fcd0fd4b" translate="yes" xml:space="preserve">
          <source>When a capturing subpattern is repeated, the value captured is the substring that matched the final iteration. For example, after</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65b284abe74e6a02c174667276a95aa7be67345" translate="yes" xml:space="preserve">
          <source>When a client checks a server certificate there are a number of checks available like checks that the certificate is not revoked, not forged or not out-of-date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aadc5d6a9fff7e5e64260bfe5a84b55671b941b" translate="yes" xml:space="preserve">
          <source>When a combining transaction writes with &quot;dirty_reads&quot;, that is, the functions &lt;code&gt;dirty_match_object&lt;/code&gt;, &lt;code&gt;dirty_read&lt;/code&gt;, &lt;code&gt;dirty_index_read&lt;/code&gt;, &lt;code&gt;dirty_select&lt;/code&gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2b39b4ebe51a72b88123d3bad51bb926bc1540" translate="yes" xml:space="preserve">
          <source>When a complete sequence of valid events has been received, the result is returned as a list of letters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab3080f29934aab21a3904dcbbbf54ca9667260" translate="yes" xml:space="preserve">
          <source>When a configuration function fails (that is, terminates unexpectedly), the test cases depending on the configuration function are skipped automatically by &lt;code&gt;Common Test&lt;/code&gt;. The status of the test cases is then &quot;auto-skipped&quot;. Test cases are also &quot;auto-skipped&quot; by &lt;code&gt;Common Test&lt;/code&gt; if the required configuration data is unavailable at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b5a638207ad9c6b58bc05153489fdb31694f0d" translate="yes" xml:space="preserve">
          <source>When a configuration variable name is used as reference to the data specifying the connection, the handle returned as a result of opening the connection must be used in all subsequent calls (also for closing the connection). Repeated calls to the open function with the same variable name as reference results in multiple connections being opened. This can be useful, for example, if a test case needs to open multiple connections to the same server on the target node (using the same configuration data for each connection).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40f1ad1022ce7c7ff4a72defc83b1ece3312d0f" translate="yes" xml:space="preserve">
          <source>When a correct code has been given, the door is unlocked and the following tuple is returned from &lt;code&gt;locked/2&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c237674f28de05213f857e3fa04838ee21db142" translate="yes" xml:space="preserve">
          <source>When a directory is added to the code path and when the entire code path is (re)set, the code server decides which subdirectories in an application that are to be read from the archive and which that are to be read as regular files. If directories are added or removed afterwards, the file access can fail if the code path is not updated (possibly to the same path as before, to trigger the directory resolution update).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08512ee349a9c8aac50037692c41425ea5af4861" translate="yes" xml:space="preserve">
          <source>When a disk log is opened in read-write mode, any existing log file is checked for. If there is none, a new empty log is created, otherwise the existing file is opened at the position after the last logged item, and the logging of items starts from there. If the format is &lt;code&gt;internal&lt;/code&gt; and the existing file is not recognized as an internally formatted log, a tuple &lt;code&gt;{error, {not_a_log_file, FileName}}&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd89c709c241e9c3808c6d9ef3bbf0c663231656" translate="yes" xml:space="preserve">
          <source>When a distributed node is started it registers itself in the EPMD. The message &lt;code&gt;ALIVE2_REQ&lt;/code&gt; described below is sent from the node to the EPMD. The response from the EPMD is &lt;code&gt;ALIVE2_RESP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a52fed0cfcde5066a985fe2bdb039481aa8004a" translate="yes" xml:space="preserve">
          <source>When a driver creates a monitor for a process, a &lt;code&gt;ErlDrvMonitor&lt;/code&gt; is filled in. This is an opaque data type that can be assigned to, but not compared without using the supplied compare function (that is, it behaves like a struct).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d91cc2fa6325a0dec9adb1ac103e1c55c09f52b" translate="yes" xml:space="preserve">
          <source>When a driver is loaded it is executed in the context of the emulator, shares the same memory and the same thread. This means that all operations in the driver must be non-blocking, and that any crash in the driver brings the whole emulator down. In short, be careful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ef058276dd33859a9cf8494fcadec228e0e9ee" translate="yes" xml:space="preserve">
          <source>When a file descriptor is signaled for input. This callback is called when the emulator detects input on a file descriptor that the driver has marked for monitoring by using the interface &lt;code&gt;driver_select&lt;/code&gt;. The mechanism of driver select makes it possible to read non-blocking from file descriptors by calling &lt;code&gt;driver_select&lt;/code&gt; when reading is needed, and then do the reading in this callback (when reading is possible). The typical scenario is that &lt;code&gt;driver_select&lt;/code&gt; is called when an Erlang process orders a read operation, and that this routine sends the answer when data is available on the file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a679df0f77926839147106039935be1d682ca28a" translate="yes" xml:space="preserve">
          <source>When a file descriptor is signaled for output. This callback is called in a similar way as the previous, but when writing to a file descriptor is possible. The usual scenario is that Erlang orders writing on a file descriptor and that the driver calls &lt;code&gt;driver_select&lt;/code&gt;. When the descriptor is ready for output, this callback is called and the driver can try to send the output. Queuing can be involved in such operations, and there are convenient queue routines available to the driver writer to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff5a25a671ee65d3e016e0e72ebcef87ec1e190" translate="yes" xml:space="preserve">
          <source>When a file is saved the name in the &lt;code&gt;-module().&lt;/code&gt; line is checked against the file name. Should they mismatch Emacs can change the module specifier so that it matches the file name. By default, the user is asked before the change is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f363e70739be22c64648901764e5ee5e3346b81" translate="yes" xml:space="preserve">
          <source>When a filter includes the &lt;code&gt;no&lt;/code&gt; atom, it excludes the reports that match that filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b080dca26694157c4bd883a5fe6d59a076fa4f" translate="yes" xml:space="preserve">
          <source>When a function &lt;code&gt;m:f/N&lt;/code&gt; is called, first the code for the function is located. If the function cannot be found, an &lt;code&gt;undef&lt;/code&gt; runtime error occurs. Notice that the function must be exported to be visible outside the module it is defined in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74208e09de14be7d14103a45ed652bc9fc053707" translate="yes" xml:space="preserve">
          <source>When a function defined elsewhere is used as a fun, it can be referred to as &lt;code&gt;Function/Arity&lt;/code&gt; (remember that &lt;code&gt;Arity&lt;/code&gt; = number of arguments). So in the &lt;code&gt;map&lt;/code&gt;-call &lt;code&gt;lists:map(fun convert_to_c/1, List)&lt;/code&gt; is written. As shown, &lt;code&gt;convert_list_to_c&lt;/code&gt; becomes much shorter and easier to understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74001e8b9e330c78c97c92b41f6d0fc8532d215e" translate="yes" xml:space="preserve">
          <source>When a function is inlined, the original function is kept if it is exported (either by an explicit export or if the option &lt;code&gt;export_all&lt;/code&gt; was given) or if not all calls to the function are inlined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80601e5580fc09c93533fc9ff760c5048491df1" translate="yes" xml:space="preserve">
          <source>When a functional module has been changed, for example, if a new function has been added or a bug has been corrected, simple code replacement is sufficient, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177c42f544b61e4f56d8eebb388d0ad5082dd374" translate="yes" xml:space="preserve">
          <source>When a grammar rule is used by the parser to parse (part of) the input string as a grammatical phrase, the associated code is evaluated, and the value of the last expression becomes the value of the parsed phrase. This value may be used by the parser later to build structures that are values of higher phrases of which the current phrase is a part. The values initially associated with terminal category phrases, i.e. input tokens, are the token tuples themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b974112391a6bf5f0b5186bac330512807e3d96c" translate="yes" xml:space="preserve">
          <source>When a group of subtrees (as e.g., the argument list of an &lt;code&gt;application&lt;/code&gt; node) is at the specified depth, and there are two or more subtrees in the group, these will be collectively replaced by &lt;code&gt;Node&lt;/code&gt; even if they are leaf nodes. Groups of subtrees that are above the specified depth will be limited in size, as if each subsequent tree in the group were one level deeper than the previous. E.g., if &lt;code&gt;Tree&lt;/code&gt; represents a list of integers &quot;&lt;code&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/code&gt;&quot;, the result of &lt;code&gt;limit(Tree, 5)&lt;/code&gt; will represent &lt;code&gt;[1, 2, 3, 4, ...]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546a7cd5ad3598834756b341e22241b28b75ab4c" translate="yes" xml:space="preserve">
          <source>When a halt log has reached its maximum size, all attempts to log more items are rejected. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which for halt implies that there is no maximum size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0173ad86ffa8dc5a72f7880331dbb41cadacb3d5" translate="yes" xml:space="preserve">
          <source>When a handler is added, by for example a call to &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler(Id, HModule, Config)&lt;/a&gt;&lt;/code&gt;, Logger first calls &lt;code&gt;HModule:adding_handler(Config)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,Config1}&lt;/code&gt;, Logger writes &lt;code&gt;Config1&lt;/code&gt; to the configuration database, and the &lt;code&gt;logger:add_handler/3&lt;/code&gt; call returns. After this, the handler is installed and must be ready to receive log events as calls to &lt;code&gt;HModule:log/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b3fa26b8c4473c5e6353f135f20edbe40b9dc4c" translate="yes" xml:space="preserve">
          <source>When a line ending is defined as a single character, dot never matches that character. When the two-character sequence CRLF is used, dot does not match CR if it is immediately followed by LF, otherwise it matches all characters (including isolated CRs and LFs). When any Unicode line endings are recognized, dot does not match CR, LF, or any of the other line-ending characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40d296ef828ecaf94ab88122caa6be54ba75b8f" translate="yes" xml:space="preserve">
          <source>When a list of binaries is specified, it denotes a set of alternative binaries to search for. For example, if &lt;code&gt;[&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;]&lt;/code&gt; is specified as &lt;code&gt;Pattern&lt;/code&gt;, this means either &lt;code&gt;&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;&lt;/code&gt;&quot;. The pattern is a set of alternatives; when only a single binary is specified, the set has only one element. The order of alternatives in a pattern is not significant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e35511e71a7b0fd611ce8579dd128d7b017ba30" translate="yes" xml:space="preserve">
          <source>When a log file is opened (for appending or created), a time stamp is written to the file. If nothing has been written to the log files for 15 minutes, a record is inserted that says that we are still alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e4937e775c2f940892fdab2739edda1362aa4d" translate="yes" xml:space="preserve">
          <source>When a log macro is used, Logger also inserts location information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad0f82e057ba4854abcfc52c2eb835c19bd6591" translate="yes" xml:space="preserve">
          <source>When a managed object is referenced in an SNMP operation, the associated &lt;code&gt;{Module, Function, ListOfExtraArguments}&lt;/code&gt; is called. The function is applied to some standard arguments (for example, the operation type) and the extra arguments supplied by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bea9285e0f879b126068ba7917e2a2ade25429d" translate="yes" xml:space="preserve">
          <source>When a manager makes a request to the agent, the following illustrates the situation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092784e3d7c652eb428c18ea5b4a28b1c8500ff7" translate="yes" xml:space="preserve">
          <source>When a match succeeds, the name of the last encountered (*MARK:NAME), (*PRUNE:NAME), or (*THEN:NAME) on the matching path is passed back to the caller as described in section &quot;Extra data for &lt;code&gt;pcre_exec()&lt;/code&gt;&quot; in the &lt;code&gt;pcreapi&lt;/code&gt; documentation. In the following example of &lt;code&gt;pcretest&lt;/code&gt; output, the /K modifier requests the retrieval and outputting of (*MARK) data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ff74687968e879951bb5da792862457fd61b73" translate="yes" xml:space="preserve">
          <source>When a message has been received, it is the caller's responsibility to free the received message &lt;code&gt;emsg.msg&lt;/code&gt; and &lt;code&gt;emsg.to&lt;/code&gt; or &lt;code&gt;emsg.from&lt;/code&gt;, depending on the type of message received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed264eb2a6ed34dada4086d909002ae020169ab" translate="yes" xml:space="preserve">
          <source>When a message is received</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8503be402b4e5542f8b3e1bb21c05d662a4228ff" translate="yes" xml:space="preserve">
          <source>When a message is sent to a process on another Erlang node, it is first encoded to the Erlang External Format before being sent through a TCP/IP socket. The receiving Erlang node decodes the message and distributes it to the correct process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551c8d852b503a0a48471c3cded481149fff350c" translate="yes" xml:space="preserve">
          <source>When a module is Cover compiled, it is also loaded using the normal code loading mechanism of Erlang. This means that if a Cover compiled module is re-loaded during a Cover session, for example using &lt;code&gt;c(Module)&lt;/code&gt;, it will no longer be Cover compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072f598e1ef5d76264967426b11622ee9dff185e" translate="yes" xml:space="preserve">
          <source>When a module is to be updated, the release handler finds which processes that are &lt;strong&gt;using&lt;/strong&gt; the module by traversing the supervision tree of each running application and checking all the child specifications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9033ba75ed69bf751fa6e5b051720381187f258c" translate="yes" xml:space="preserve">
          <source>When a new OTP release is released it will have an OTP version on the form &lt;code&gt;&amp;lt;Major&amp;gt;.0&lt;/code&gt; where the major OTP version number equals the release number. The major version number is increased one step since the last major version. All other OTP versions with the same major OTP version number are patches on that OTP release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbb4bde17a561149622c0549faa70bd0cd996df" translate="yes" xml:space="preserve">
          <source>When a new fun is defined in the shell, the value of the fun is printed as &lt;code&gt;Fun#&amp;lt;erl_eval&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a3c0fc498149078e34911c14f7a085c035bd806" translate="yes" xml:space="preserve">
          <source>When a new version of a release is installed, the application specifications are automatically updated for all loaded applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1659bff51ef846577db0a731a65e27f0a6975ea2" translate="yes" xml:space="preserve">
          <source>When a node gets overloaded, it is not possible to issue &lt;code&gt;ttb:p/2&lt;/code&gt; or any command from the &lt;code&gt;ttb:tp/2,3,4&lt;/code&gt; family, as it would lead to inconsistent tracing state (different trace specifications on different nodes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9107c7e3a2ab54b42fe2aa4f90dbf2f0ef91d069" translate="yes" xml:space="preserve">
          <source>When a node tries to connect to another node, the magic cookies are compared. If they do not match, the connected node rejects the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91dc7db1911778980d1a145028f56ea061e34c24" translate="yes" xml:space="preserve">
          <source>When a parenthesized subpattern is quantified with a minimum repeat count that is &amp;gt; 1 or with a limited maximum, more memory is required for the compiled pattern, in proportion to the size of the minimum or maximum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17163b128ce2d3940abc9e287d9eb3065dfe4943" translate="yes" xml:space="preserve">
          <source>When a part in the version number increases, all less significant parts are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414ecb7481a0e4a00ed77662f92beb6946aca44b" translate="yes" xml:space="preserve">
          <source>When a pattern contains an unlimited repeat inside a subpattern that can itself be repeated an unlimited number of times, the use of an atomic group is the only way to avoid some failing matches taking a long time. The pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6c00c70d6d587bfac21cf87c7afe2ad1eacd1f" translate="yes" xml:space="preserve">
          <source>When a pending message is received, and the &lt;code&gt;long_request_timer&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; &quot;on its final leg&quot;, the timer will be restarted, and, if &lt;code&gt;long_request_resend = true&lt;/code&gt;, the request will be re-sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75f183f6a0a339836141c5520bd7b12114dfb3c" translate="yes" xml:space="preserve">
          <source>When a pending message is received, the timer is cancelled and the &lt;code&gt;long_request_timer&lt;/code&gt; is started instead (see below). No resends will be performed from this point (since we now know that the other side has received the request).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caca1f590c83f0cbc730079b288c0a340c8795e2" translate="yes" xml:space="preserve">
          <source>When a pending transaction is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9309b1e58646bc0004532eb714a09afd5a498a84" translate="yes" xml:space="preserve">
          <source>When a port is closed, either by an Erlang process or by the driver calling one of the &lt;code&gt;driver_failure_XXX&lt;/code&gt; routines. This routine is to clean up everything connected to one particular port. When other callbacks call a &lt;code&gt;driver_failure_XXX&lt;/code&gt; routine, this routine is immediately called. The callback routine issuing the error can make no more use of the data structures for the port, as this routine surely has freed all associated data and closed all file descriptors. If the queue utility available to driver writer is used, this routine is however &lt;strong&gt;not&lt;/strong&gt; called until the queue is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab97407457bdcec73d321074e9305a6e73487c1" translate="yes" xml:space="preserve">
          <source>When a port to the driver is opened (by a &lt;code&gt;open_port&lt;/code&gt; call from Erlang). This routine is to set up internal data structures and return an opaque data entity of the type &lt;code&gt;ErlDrvData&lt;/code&gt;, which is a data type large enough to hold a pointer. The pointer returned by this function is the first argument to all other callbacks concerning this particular port. It is usually called the port handle. The emulator only stores the handle and does never try to interpret it, why it can be virtually anything (anything not larger than a pointer that is) and can point to anything if it is a pointer. Usually this pointer refers to a structure holding information about the particular port, as it does in the example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c6008e1040993823cc1153b9087a328f65c269" translate="yes" xml:space="preserve">
          <source>When a process is killed by &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt;max_heap_size&lt;/a&gt;&lt;/code&gt;, it is killed before the garbage collection is complete and thus no large heap message is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c7049ba92415c934270df93ecc40c6ff49a6de" translate="yes" xml:space="preserve">
          <source>When a process is trapping exits, it does not terminate when an exit signal is received. Instead, the signal is transformed into a message &lt;code&gt;{'EXIT',FromPid,Reason}&lt;/code&gt;, which is put into the mailbox of the process, just like a regular message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f894aeebc67996f11b9c7ed1100aea86a6d270d1" translate="yes" xml:space="preserve">
          <source>When a process reaches a breakpoint, only that process is stopped. Other processes are not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5fe92890350a386281d849d2308c2fdf32b6229" translate="yes" xml:space="preserve">
          <source>When a process terminates, it always terminates with an &lt;strong&gt;exit reason&lt;/strong&gt;. The reason can be any term.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33255f3d61f1a754c180593962f65ef23e96913" translate="yes" xml:space="preserve">
          <source>When a process terminates, it terminates with an &lt;strong&gt;exit reason&lt;/strong&gt; as explained in &lt;code&gt;&lt;a href=&quot;#term&quot;&gt;Process Termination&lt;/a&gt;&lt;/code&gt;. This exit reason is emitted in an &lt;strong&gt;exit signal&lt;/strong&gt; to all linked processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f438ecf00c74cada65672d3aca9158bdc88f9b65" translate="yes" xml:space="preserve">
          <source>When a process that is started using &lt;code&gt;proc_lib&lt;/code&gt; terminates abnormally (that is, with another exit reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;), a &lt;strong&gt;crash report&lt;/strong&gt; is generated, which is written to terminal by the default logger handler setup by Kernel. For more information about how crash reports were logged prior to Erlang/OTP 21.0, see &lt;code&gt;SASL Error Logging&lt;/code&gt; in the SASL User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620e45b56f249c1dbe8f129dc957582dac227989" translate="yes" xml:space="preserve">
          <source>When a program runs in the service context, it must handle the control events that are sent to every program in the system when the interactive user logs off. This is done in different ways for programs running in the console subsystem and programs running as window applications. An application running in the console subsystem (normal for port programs) uses the win32 function &lt;code&gt;SetConsoleCtrlHandler&lt;/code&gt; to register a control handler that returns &lt;code&gt;true&lt;/code&gt; in answer to the &lt;code&gt;CTRL_LOGOFF_EVENT&lt;/code&gt; and &lt;code&gt;CTRL_SHUTDOWN_EVENT&lt;/code&gt; events. Other applications only forward &lt;code&gt;WM_ENDSESSION&lt;/code&gt; and &lt;code&gt;WM_QUERYENDSESSION&lt;/code&gt; to the default window procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ffb1b5dfb2cc8d3c94f0461fc310cb105f6b53" translate="yes" xml:space="preserve">
          <source>When a rekeying is done, both the timer and the byte counter are restarted. Defaults to one hour and one GByte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160df15be10c112ef08e1b12460eb364b392a9a7" translate="yes" xml:space="preserve">
          <source>When a reply &lt;code&gt;Reply&lt;/code&gt; is received from the &lt;code&gt;gen_server&lt;/code&gt; process at a node &lt;code&gt;Node&lt;/code&gt;, &lt;code&gt;{Node,Reply}&lt;/code&gt; is added to &lt;code&gt;Replies&lt;/code&gt;. &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3612568b6d1bd1adf395a8924394d4f1cda79d" translate="yes" xml:space="preserve">
          <source>When a reply transaction is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9676d76432236d4be5a23bf4ca85a4c81230e6" translate="yes" xml:space="preserve">
          <source>When a request is received, some info related to the reply is store internally (e.g. the binary of the reply). This info will live until either an ack is received or this timer expires. For instance, if the same request is received again (e.g. a request with the same transaction id), the (stored) reply will be (re-) sent automatically by megaco.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b06f9b88824f92a821ddd40390c63201a38782" translate="yes" xml:space="preserve">
          <source>When a request is sent using the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call/3&lt;/a&gt;&lt;/code&gt; function, a proxy process is started to handle all replies. When the reply has been received and delivered to the user, the proxy process continue to exist for as long as this option specifies. Any received messages, is passed on to the user via the &lt;code&gt;&lt;a href=&quot;megaco_user#handle_unexpected_trans&quot;&gt;handle_unexpected_trans&lt;/a&gt;&lt;/code&gt; callback function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88f71ef842c681d045f4cae79da80397386486a" translate="yes" xml:space="preserve">
          <source>When a run-time error occurs, that is an exception of class &lt;code&gt;error&lt;/code&gt;. The exit reason is a tuple &lt;code&gt;{Reason,Stack}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is a term indicating the type of error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b12f8bd1c57b6ce9840c0a7b9fe58cbedb898d" translate="yes" xml:space="preserve">
          <source>When a run-time error or generated error occurs in Erlang, execution for the process that evaluated the erroneous expression is stopped. This is referred to as a &lt;strong&gt;failure&lt;/strong&gt;, that execution or evaluation &lt;strong&gt;fails&lt;/strong&gt;, or that the process &lt;strong&gt;fails&lt;/strong&gt;, &lt;strong&gt;terminates&lt;/strong&gt;, or &lt;strong&gt;exits&lt;/strong&gt;. Notice that a process can terminate/exit for other reasons than a failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6222adda532a7ba95811b3f47ed6b592bce7369e" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details), transitions to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode, the controlling process is notified by a message of the following form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad380e3a94ebd517a8a93bc527d1a2a8c42ac9d" translate="yes" xml:space="preserve">
          <source>When a sticky write lock is acquired, all nodes are informed which node is locked. Then, sticky lock requests from the same node are performed as a local operation without any communication with other nodes. The sticky lock lingers on the node even after the transaction ends. For details, see the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a9afc8539f723b3d906fa063814442e45d9210" translate="yes" xml:space="preserve">
          <source>When a table is SNMP ordered, modifications are more expensive than usual, O(logN). Also, more memory is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09de174e5f27981b5d536ae7d587e5f775467043" translate="yes" xml:space="preserve">
          <source>When a table is fixed, a sequence of &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; calls are guaranteed to succeed, and each object in the table is returned only once, even if objects are removed or inserted during the traversal. The keys for new objects inserted during the traversal &lt;strong&gt;can&lt;/strong&gt; be returned by &lt;code&gt;next/2&lt;/code&gt; (it depends on the internal ordering of the keys).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25502d9a8f67791267ea14f5c70c734251d290a" translate="yes" xml:space="preserve">
          <source>When a target name is used for referencing the configuration data (that specifies the connection to be opened), the same name can be used as connection identity in all subsequent calls related to the connection (also for closing it). Only one open connection per target name is possible. If you attempt to open a new connection using a name already associated with an open connection, &lt;code&gt;Common Test&lt;/code&gt; returns the already existing handle so the previously opened connection is used. This feature makes it possible to call the function for opening a particular connection whenever useful. An action like this does not necessarily open any new connections unless it is required (which could be the case if, for example, the previous connection has been closed unexpectedly by the server). Using named connections also removes the need to pass handle references around in the suite for these connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b832ad499cefe25ddc82f36d870e896057644d6" translate="yes" xml:space="preserve">
          <source>When a term is passed as the initial process arguments in the &lt;code&gt;spawn&lt;/code&gt; call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e389307b8d59483ef3d7e87b6dfe90a060b042c" translate="yes" xml:space="preserve">
          <source>When a term is sent to another process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b733aebb93dce74a8914341750d479f7d8a549ed" translate="yes" xml:space="preserve">
          <source>When a term is stored in an Ets table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7ebdcd78a12cc7bd8bd97eb29bacb32f39549b" translate="yes" xml:space="preserve">
          <source>When a test case group is repeated, the configuration functions &lt;code&gt;init_per_group/2&lt;/code&gt; and &lt;code&gt;end_per_group/2&lt;/code&gt; are also always called with each repetition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be9bace113be2bd43525f396f001fb603a47ce4" translate="yes" xml:space="preserve">
          <source>When a test case group is specified, the resulting test executes function &lt;code&gt;init_per_group&lt;/code&gt;, followed by all test cases and subgroups (including their configuration functions), and finally function &lt;code&gt;end_per_group&lt;/code&gt;. Also, if particular test cases in a group are specified, &lt;code&gt;init_per_group&lt;/code&gt; and &lt;code&gt;end_per_group&lt;/code&gt;, for the group in question, are called. If a group defined (in &lt;code&gt;Suite:group/0&lt;/code&gt;) as a subgroup of another group, is specified (or if particular test cases of a subgroup are), &lt;code&gt;Common Test&lt;/code&gt; calls the configuration functions for the top-level groups and for the subgroup in question (making it possible to pass configuration data all the way from &lt;code&gt;init_per_suite&lt;/code&gt; down to the test cases in the subgroup).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eab1460f1347d0c73cb3c3a8b4439b39091de4a" translate="yes" xml:space="preserve">
          <source>When a test case is skipped, it is noted as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7277815e7b5fc7d7307a8ad2c9b5d0b7fee5390" translate="yes" xml:space="preserve">
          <source>When a timer expires. The driver can set timers with the function &lt;code&gt;driver_set_timer&lt;/code&gt;. When such timers expire, a specific callback function is called. No timers are used in the example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01248c84705afaa8d22118ccef5dc76865736320" translate="yes" xml:space="preserve">
          <source>When a transaction acknowledgement is received it is possible that user has decided not to bother about the acknowledgement. But in case the return value from UserMod:handle_trans_request/3 indicates that the acknowledgement is important the following callback function will be invoked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163b7a94b619edcfd4f6cd93b3333d250e24a1fb" translate="yes" xml:space="preserve">
          <source>When a user (MG/MGC) is distributed over several nodes, it is required that the node hosting the connection already has activated the connection and that it is in the &quot;normal&quot; state. The RemoteMid must be a real Megaco MID and not a preliminary_mid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19eb5cc222fe8477b606be0ecb93b47faec2127d" translate="yes" xml:space="preserve">
          <source>When a valid request reaches &lt;code&gt;httpd&lt;/code&gt;, it calls &lt;code&gt;do/1&lt;/code&gt; in each module, defined by the configuration option of &lt;code&gt;Module&lt;/code&gt;. The function can generate data for other modules or a response that can be sent back to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988284baf01c48f0333363a5420ee041f8e80f73" translate="yes" xml:space="preserve">
          <source>When accessing single attributes in a record, it is not necessary, or even recommended, to hard code any attribute names as atoms. Use construct &lt;code&gt;record_info(fields, RecordName)&lt;/code&gt; instead. It can be used for records of type &lt;code&gt;RecordName&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a069a06056d1779ba3b73665e6912fd948d0893" translate="yes" xml:space="preserve">
          <source>When adding or removing an application, no &lt;code&gt;.appup&lt;/code&gt; file is needed. When generating &lt;code&gt;relup&lt;/code&gt;, the &lt;code&gt;.rel&lt;/code&gt; files are compared and the &lt;code&gt;add_application&lt;/code&gt; and &lt;code&gt;remove_application&lt;/code&gt; instructions are added automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7dcf974a69ad2af0b183e9640143a16ca26c965" translate="yes" xml:space="preserve">
          <source>When adding processes or ports, a window with trace options is displayed. The chosen options are set for the selected processes/ports. To change the options, right-click the process or port and select &lt;strong&gt;Edit process options&lt;/strong&gt;. To remove a process or port from the list, right-click and select &lt;strong&gt;Remove process&lt;/strong&gt; or &lt;strong&gt;Remove port&lt;/strong&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed50d489e165b74cf018acee993218839df9d7b" translate="yes" xml:space="preserve">
          <source>When all involved (mandatory) nodes have been started, the distributed application can be started by calling &lt;code&gt;application:start(Application)&lt;/code&gt; at &lt;strong&gt;all of these nodes.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd73cca48ba2b286c66fc15f791c382c884ddbc5" translate="yes" xml:space="preserve">
          <source>When all nodes are operational, &lt;code&gt;myapp&lt;/code&gt; can be started. This is achieved by calling &lt;code&gt;application:start(myapp)&lt;/code&gt; at all three nodes. It is then started at &lt;code&gt;cp1&lt;/code&gt;, as shown in the following figure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd0a7b9eacf13a1791c55c3dbd5596c2928ca10" translate="yes" xml:space="preserve">
          <source>When all objects of the table have been matched, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1c6e68ed8acc251646eddfa314228262bb5f3b" translate="yes" xml:space="preserve">
          <source>When all table objects are matched, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c62a1cbadf2c2b8976473d30ec9850b0e30154" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;escript&lt;/code&gt; file contains an archive, there are no restrictions on the name of the &lt;code&gt;escript&lt;/code&gt; and no restrictions on how many applications that can be stored in the embedded archive. Single Beam files can also reside on the top level in the archive. At startup, the top directory in the embedded archive and all (second level) &lt;code&gt;ebin&lt;/code&gt; directories in the embedded archive are added to the code path. See &lt;code&gt;erts:escript(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9936eae6e93ab6d5c78b6480d03e1af10ab7148" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;usm_entry()&lt;/code&gt; tuple (or a list of such tuples) is returned, this data is then added to the &lt;code&gt;usmUserTable&lt;/code&gt; by the (master-) agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b976e99904fcceb1196e74093f891273ad96adf" translate="yes" xml:space="preserve">
          <source>When an ASN.1 specification is compiled with option &lt;code&gt;ber&lt;/code&gt;, the &lt;code&gt;asn1rt_nif&lt;/code&gt; module and the NIF library in &lt;code&gt;asn1/priv_dir&lt;/code&gt; are needed at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c483462464501bc7953de399a743714b5061e30" translate="yes" xml:space="preserve">
          <source>When an ASN.1 specification is compiled, all defined types of type &lt;code&gt;SET&lt;/code&gt; or &lt;code&gt;SEQUENCE&lt;/code&gt; result in a corresponding record in the generated &lt;code&gt;.hrl&lt;/code&gt; file. This is because the values for &lt;code&gt;SET&lt;/code&gt; and &lt;code&gt;SEQUENCE&lt;/code&gt; are represented as records by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9c8df5e2566ccd5d9fbe4734d8fd9d613779aa" translate="yes" xml:space="preserve">
          <source>When an Erlang process calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;, which is a synchronous interface to drivers. The control interface is used to set driver options, change states of ports, and so on. This interface is used a lot in the example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b618715bb8bb03bc07feda65b3a85bb43cb72de" translate="yes" xml:space="preserve">
          <source>When an Erlang process sends data to the port. The data arrives as a buffer of bytes, the interpretation is not defined, but is up to the implementor. This callback returns nothing to the caller, answers are sent to the caller as messages (using a routine called &lt;code&gt;driver_output&lt;/code&gt; available to all drivers). There is also a way to talk in a synchronous way to drivers, described below. There can be an additional callback function for handling data that is fragmented (sent in a deep io-list). That interface gets the data in a form suitable for Unix &lt;code&gt;writev&lt;/code&gt; rather than in a single buffer. There is no need for a distribution driver to implement such a callback, so we will not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd682219ed27952353a789f2a95e93eae1b95ef" translate="yes" xml:space="preserve">
          <source>When an Erlang runtime system is started, a number of processes are started as part of the Kernel application. One of these processes is the &lt;strong&gt;application controller&lt;/strong&gt; process, registered as &lt;code&gt;application_controller&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6e9cd273f9f4e055a8524b92a57509f35b9cee" translate="yes" xml:space="preserve">
          <source>When an I/O server receives an &lt;code&gt;io_request&lt;/code&gt; tuple, it acts upon the &lt;code&gt;Request&lt;/code&gt; part and eventually sends an &lt;code&gt;io_reply&lt;/code&gt; tuple with the corresponding &lt;code&gt;Reply&lt;/code&gt; part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97830caeadaae0c71c4a6641f2b72ee5a3a4441" translate="yes" xml:space="preserve">
          <source>When an MIB is compiled, the compiler detects if several managed objects use the same &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;. If that is the case, it issues an error message. However, the compiler cannot detect Oid conflicts between different MIBs. These kinds of conflicts generate an error at load time. To avoid this, the following function can be used to do consistency checking between MIBs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db011fd2eddc67aaa683180ce280cb84fa7377af" translate="yes" xml:space="preserve">
          <source>When an TLS/DTLS socket is in active mode (the default), data from the socket is delivered to the owner of the socket in the form of messages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996325d55085b77e5910030169e95fa9280c37bb" translate="yes" xml:space="preserve">
          <source>When an accept sequence has been completed the acceptor process is expected to continue accepting further requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709fa60f17ba558cd057f2a6b62757eac692ee54" translate="yes" xml:space="preserve">
          <source>When an application executes on several nodes and wants to be sure that the update is performed on the remote nodes before a remote process is spawned or a message is sent to a remote process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c28abc5b0d379d3a8ba44dbcc2c9763e0be3b27" translate="yes" xml:space="preserve">
          <source>When an application performs frequent or voluminous updates that can overload &lt;code&gt;Mnesia&lt;/code&gt; on other nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47a8128b591f9e03e1d7bb3a8b71505f2177f47" translate="yes" xml:space="preserve">
          <source>When an application performs frequent or voluminous updates that can overload &lt;code&gt;Mnesia&lt;/code&gt; on the nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8091d18c34c7568e437ad61e1779d1db887806b5" translate="yes" xml:space="preserve">
          <source>When an event handler terminates abnormally, &lt;code&gt;gen_event&lt;/code&gt; logs &lt;code&gt;Status&lt;/code&gt; in place of the state term of the event handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b856ad79c467961efb9c09f4c8c68ce2f0ae4ff" translate="yes" xml:space="preserve">
          <source>When an event manager is stopped, it gives each of the installed event handlers the chance to clean up by calling &lt;code&gt;terminate/2&lt;/code&gt;, the same way as when deleting a handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ecb64233649623988df5a15e4320b8e35507f15" translate="yes" xml:space="preserve">
          <source>When an installed release is made permanent, the system process &lt;code&gt;init&lt;/code&gt; is set to point out the new &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00873013d7a25ee81fef530c37b0fd219bde2fd" translate="yes" xml:space="preserve">
          <source>When an integer-value is specified, &lt;code&gt;TLS/DTLS-connection&lt;/code&gt; goes into hibernation after the specified number of milliseconds of inactivity, thus reducing its memory footprint. When &lt;code&gt;undefined&lt;/code&gt; is specified (this is the default), the process never goes into hibernation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd630c54a2a673edbcdeb121843359b4c127f6e0" translate="yes" xml:space="preserve">
          <source>When analysing code coverage, the result for &lt;code&gt;m1&lt;/code&gt; can be seen in the cover log in the &lt;code&gt;s1&lt;/code&gt; test result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c824ef18f1155e6eb73bb5f1e6f145e288eb6a" translate="yes" xml:space="preserve">
          <source>When analyzing from source, pass the &lt;code&gt;include_dir&lt;/code&gt; to Dialyzer. (**)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d86eb0ccd83bcc9cd8e9fc364281c878af586ee" translate="yes" xml:space="preserve">
          <source>When analyzing from source, pass the define to Dialyzer. (**)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac42477caf4c3ea1c573d88619291bc09d0583f2" translate="yes" xml:space="preserve">
          <source>When analyzing from source, you might have to supply Dialyzer with a list of include directories and macro definitions (as you can do with the &lt;code&gt;erlc&lt;/code&gt; flags &lt;code&gt;-I&lt;/code&gt; and &lt;code&gt;-D&lt;/code&gt;). This can be done either by starting Dialyzer with these flags from the command line as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658b2374a8aacc4b9e6927fe3e6096361c317c2b" translate="yes" xml:space="preserve">
          <source>When analyzing the result file from the profiling activity, look for functions that are called many times and have a long &quot;own&quot; execution time (time excluding calls to other functions). Functions that are called a lot of times can also be interesting, as even small things can add up to quite a bit if repeated often. Also ask yourself what you can do to reduce this time. The following are appropriate types of questions to ask yourself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="806459f8533827481672dc572cf1bf7921931e0f" translate="yes" xml:space="preserve">
          <source>When appending to a binary as follows, only the binary returned from the latest append operation will support further cheap append operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228cd4e5a8bc6e5b7fee2e6123af719e572f533e" translate="yes" xml:space="preserve">
          <source>When building in a Git working directory you also have to have a GNU &lt;code&gt;autoconf&lt;/code&gt; of at least version 2.59 on your system, because you need to generate the &lt;code&gt;configure&lt;/code&gt; scripts before you can start building.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf8c1d8b7925ac8c617463eca8b72a76f666d34" translate="yes" xml:space="preserve">
          <source>When building the documentation you need a full Erlang/OTP-21.0 system in the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90530c4b0ae5b8364ccb16ac3ef25111d36b377f" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;read&lt;/code&gt;, function &lt;code&gt;InitFun&lt;/code&gt; is assumed to return &lt;code&gt;end_of_input&lt;/code&gt; when there is no more input, or &lt;code&gt;{Objects, Fun}&lt;/code&gt;, where &lt;code&gt;Objects&lt;/code&gt; is a list of objects and &lt;code&gt;Fun&lt;/code&gt; is a new input function. Any other value &lt;code&gt;Value&lt;/code&gt; is returned as an error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt;. Each input function is called exactly once, and if an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07cb85581936567b82cbd8ae581b4c6171786cd2" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;read&lt;/code&gt;, the function &lt;code&gt;InitFun&lt;/code&gt; is assumed to return &lt;code&gt;end_of_input&lt;/code&gt; when there is no more input, or &lt;code&gt;{Objects, Fun}&lt;/code&gt;, where &lt;code&gt;Objects&lt;/code&gt; is a list of objects and &lt;code&gt;Fun&lt;/code&gt; is a new input function. Any other value &lt;code&gt;Value&lt;/code&gt; is returned as an error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt;. Each input function is called exactly once, and if an error occur, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364ba2a27b870da0b99015d17a3a2b5626ba1eeb" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;undefined&lt;/code&gt;, all system performance monitoring settings are cleared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44f8219d85b31453de272e6169e5dfa4f9585c9" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;qlc:q/1,2&lt;/code&gt; from the Erlang shell, the parse transform is automatically called. When this occurs, the fun substituted for the QLC is not compiled but is evaluated by &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt;. This is also true when expressions are evaluated by &lt;code&gt;file:eval/1,2&lt;/code&gt; or in the debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0142d7dfddbd655a17b503f022ba1db92cd0ecd9" translate="yes" xml:space="preserve">
          <source>When calling BIFs that accept deep lists, such as &lt;code&gt;list_to_binary/1&lt;/code&gt; or &lt;code&gt;iolist_to_binary/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c494144b9a22a3f981a6afcba77050a11fcf18" translate="yes" xml:space="preserve">
          <source>When calling this function, &lt;code&gt;iovec&lt;/code&gt; should contain a pointer to &lt;code&gt;NULL&lt;/code&gt; or a ErlNifIOVec structure that should be used if possible. e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865c3803d266e89c17825224f1f9b63a82983678" translate="yes" xml:space="preserve">
          <source>When caseless matching is set, any letters in a class represent both their uppercase and lowercase versions. For example, a caseless &lt;code&gt;[aeiou]&lt;/code&gt; matches &quot;A&quot; and &quot;a&quot;, and a caseless &lt;code&gt;[^aeiou]&lt;/code&gt; does not match &quot;A&quot;, but a caseful version would. In a UTF mode, PCRE always understands the concept of case for characters whose values are &amp;lt; 256, so caseless matching is always possible. For characters with higher values, the concept of case is supported only if PCRE is compiled with Unicode property support. If you want to use caseless matching in a UTF mode for characters &amp;gt;=, ensure that PCRE is compiled with Unicode property support and with UTF support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa07acc11a720ed656be365e748b1e786d781a3" translate="yes" xml:space="preserve">
          <source>When caseless matching is specified (option &lt;code&gt;caseless&lt;/code&gt;), letters are matched independently of case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ae8050f70165954f23ba0ebf3fbda68196592f" translate="yes" xml:space="preserve">
          <source>When changing this flag messages will be moved. This work has been initiated but not completed when this function call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c283832835fc69a63d88192d48cfa2b0fe0ad55" translate="yes" xml:space="preserve">
          <source>When changing to state &lt;code&gt;open&lt;/code&gt;, the collected buttons are reset, the lock unlocked, and a state timer for 10 s is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d2f7b0ec39f0b334cd93ff69fd7523f8653774" translate="yes" xml:space="preserve">
          <source>When comparing an integer to a float, the term with the lesser precision is converted into the type of the other term, unless the operator is one of &lt;code&gt;=:=&lt;/code&gt; or &lt;code&gt;=/=&lt;/code&gt;. A float is more precise than an integer until all significant figures of the float are to the left of the decimal point. This happens when the float is larger/smaller than +/-9007199254740992.0. The conversion strategy is changed depending on the size of the float because otherwise comparison of large floats and integers would lose their transitivity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057fdbcf9c89dcfcef51fc5e8e497f10a792cf05" translate="yes" xml:space="preserve">
          <source>When comparing external sets, operator &lt;code&gt;==/2&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc0d77de42806fcc3f093559352b14f83658b4e" translate="yes" xml:space="preserve">
          <source>When comparing two version numbers that have an order, one compare each part as ordinary integers from the most significant part to less significant parts. The order is defined by the first parts of the same significance that differ. An OTP version with a larger version includes all changes that are part of a smaller OTP version. The same goes for application versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7045558361dff4148b294c98385164fc4d95e222" translate="yes" xml:space="preserve">
          <source>When compilation is involved, exception &lt;code&gt;badarg&lt;/code&gt; is thrown if a compilation error occurs. Call &lt;code&gt;compile/2&lt;/code&gt; to get information about the location of the error in the regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f94aaa056c45f783cd020ccfb0c871d028ac6c" translate="yes" xml:space="preserve">
          <source>When connections gets broken (that is explicitly by megaco:disconnect/2 or when its controlling process dies) a user callback function is invoked in order to allow the user to re-establish the connection. The internal state of kept messages, re-send timers etc. is not affected by this. A few re-sends will of course fail while the connection is down, but the automatic re-send algorithm does not bother about this and eventually when the connection is up and running the messages will be delivered if the timeouts are set to be long enough. The user has the option of explicitly invoking megaco:cancel/2 to cancel all messages for a connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee80008193ca8beab002b82928ea575e05d44fd" translate="yes" xml:space="preserve">
          <source>When constructing a segment of a &lt;code&gt;utf&lt;/code&gt; type, &lt;code&gt;Value&lt;/code&gt; must be an integer in the range 0..16#D7FF or 16#E000....16#10FFFF. Construction fails with a &lt;code&gt;badarg&lt;/code&gt; exception if &lt;code&gt;Value&lt;/code&gt; is outside the allowed ranges. The size of the resulting binary segment depends on the type or &lt;code&gt;Value&lt;/code&gt;, or both:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfba87ba5340bf590a9719ae92123f1780ed535" translate="yes" xml:space="preserve">
          <source>When constructing binaries, &lt;code&gt;Value&lt;/code&gt; and &lt;code&gt;Size&lt;/code&gt; can be any Erlang expression. However, for syntactical reasons, both &lt;code&gt;Value&lt;/code&gt; and &lt;code&gt;Size&lt;/code&gt; must be enclosed in parenthesis if the expression consists of anything more than a single literal or a variable. The following gives a compiler syntax error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d4be88f085f6842045d6bb85ffd60f1c5e2495" translate="yes" xml:space="preserve">
          <source>When constructing binaries, if the size &lt;code&gt;N&lt;/code&gt; of an integer segment is too small to contain the given integer, the most significant bits of the integer are silently discarded and only the &lt;code&gt;N&lt;/code&gt; least significant bits are put into the binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7c4511bca13fde6765438ddbde809cac5d3478" translate="yes" xml:space="preserve">
          <source>When constructing, a literal string can be given followed by one of the UTF types, for example: &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;/utf8&amp;gt;&amp;gt;&lt;/code&gt; which is syntactic sugar for &lt;code&gt;&amp;lt;&amp;lt;$a/utf8,$b/utf8,$c/utf8&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ed84f016fc083dab3c16b2cd6e8fe5dee14cdb" translate="yes" xml:space="preserve">
          <source>When creating a record to be used in a select/match operation, you want most of the fields to have the value &quot;_&quot;. The easiest and fastest way to do that is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be878ceb74375986a99208578a50205223bc154" translate="yes" xml:space="preserve">
          <source>When creating a system using Erlang/OTP, the simplest way is to install Erlang/OTP somewhere, install the application-specific code somewhere else, and then start the Erlang runtime system, making sure the code path includes the application-specific code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a48110445b8b431b0a819b4efed940d95979f9" translate="yes" xml:space="preserve">
          <source>When creating test suites, it is strongly recommended to not create dependencies between test cases, that is, letting test cases depend on the result of previous test cases. There are various reasons for this, such as, the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26cf28e2e1bf20fe1af4eb848b0d0a7d334f0f8b" translate="yes" xml:space="preserve">
          <source>When debugging a process with the functions of this module, the process generates &lt;strong&gt;system_events&lt;/strong&gt;, which are then treated in the debug function. For example, &lt;code&gt;trace&lt;/code&gt; formats the system events to the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f636b27b7770791a083db3563a557efb2923ba0e" translate="yes" xml:space="preserve">
          <source>When decoding &lt;code&gt;property_group()&lt;/code&gt; or &lt;code&gt;property_groups()&lt;/code&gt;, those property parameter constructs that cannot be decoded (either because of decode error or because they are unknown), will be returned as a two-tuple. The first element of which will be the (undecoded) property parameter and the other the actual reason. This means that the caller of this function has to expect not only sdp-records, but also this two-tuple construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f3e727c9b04040e7e330882d55b9758d892ab6" translate="yes" xml:space="preserve">
          <source>When decoding a type that uses an extensible set constraint, it is always possible that the value in field &lt;code&gt;UNIQUE&lt;/code&gt; is unknown (that is, the type has been encoded with a later version of the ASN.1 specification). The unencoded data is then returned wrapped in a tuple as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c1a9e3a07dbc42bbebe73b1a8cb57a2a65f591" translate="yes" xml:space="preserve">
          <source>When decoding binaries from untrusted sources, consider using &lt;code&gt;binary_to_term/2&lt;/code&gt; to prevent Denial of Service attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e0e586b31755d07f5d7b42305304a2d4527232" translate="yes" xml:space="preserve">
          <source>When decoding, optional fields will be omitted from the map:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2aad35acaab6959e7cb6145c3615cfd817ae41a" translate="yes" xml:space="preserve">
          <source>When describing a set of functions (that is, a module, a part of a module, or an application), executing in a process and wanting to use a ddll-driver, we use the term &lt;strong&gt;user&lt;/strong&gt;. A process can have many users (different modules needing the same driver) and many processes running the same code, making up many &lt;strong&gt;users&lt;/strong&gt; of a driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d599e465efb7551b80d5232a1bfe503d0d783500" translate="yes" xml:space="preserve">
          <source>When developing with Erlang/OTP you usually test your programs from the interactive shell (see &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;) where you can call individual functions. There is also a number of tools available, such as the graphical &lt;a href=&quot;lib/debugger-4.2.5/doc/html/index&quot;&gt;Debugger&lt;/a&gt; and the &lt;a href=&quot;lib/observer-2.8/doc/html/index&quot;&gt;Observer tool&lt;/a&gt; for inspection of system information, ets and mnesia tables etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf2dfb99c11e0b6eebdf245aebada381fb9ab39" translate="yes" xml:space="preserve">
          <source>When disabling trace, the option must match the type of trace set on the function. That is, local tracing must be disabled with option &lt;code&gt;local&lt;/code&gt; and global tracing with option &lt;code&gt;global&lt;/code&gt; (or no option), and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e262a7b92cfd57af3c5fc673b211db44e0d61d2" translate="yes" xml:space="preserve">
          <source>When doing &lt;code&gt;make install&lt;/code&gt; and the default installation prefix is used, relative symbolic links will be created from &lt;code&gt;/usr/local/bin&lt;/code&gt; to all public Erlang/OTP executables in &lt;code&gt;/usr/local/lib/erlang/bin&lt;/code&gt;. The installation phase will try to create relative symbolic links as long as &lt;code&gt;--bindir&lt;/code&gt; and the Erlang bin directory, located under &lt;code&gt;--libdir&lt;/code&gt;, both have &lt;code&gt;--exec-prefix&lt;/code&gt; as prefix. Where &lt;code&gt;--exec-prefix&lt;/code&gt; defaults to &lt;code&gt;--prefix&lt;/code&gt;. &lt;code&gt;--prefix&lt;/code&gt;, &lt;code&gt;--exec-prefix&lt;/code&gt;, &lt;code&gt;--bindir&lt;/code&gt;, and &lt;code&gt;--libdir&lt;/code&gt; are all arguments that can be passed to &lt;code&gt;configure&lt;/code&gt;. One can force relative, or absolute links by passing &lt;code&gt;BINDIR_SYMLINKS=relative|absolute&lt;/code&gt; as arguments to &lt;code&gt;make&lt;/code&gt; during the install phase. Note that such a request might cause a failure if the request cannot be satisfied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2786f78387349e137e785c359068f69a038e2e9" translate="yes" xml:space="preserve">
          <source>When dumping the table, some information about the table is dumped to a header at the beginning of the dump. This information contains data about the table type, name, protection, size, version, and if it is a named table. It also contains notes about what extended information is added to the file, which can be a count of the objects in the file or a MD5 sum of the header and records in the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb8dc80e08844ad0426660bafbab7a03b0891ac" translate="yes" xml:space="preserve">
          <source>When editing normal text in text mode you can let Emacs reformat the text by the &lt;code&gt;fill-paragraph&lt;/code&gt; command. This command will not work for comments since it will treat the comment characters as words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385563ac3b6af3039b39f79f5505ddf536cbbbf9" translate="yes" xml:space="preserve">
          <source>When enabled, it prevents decoding data that can be used to attack the Erlang system. In the event of receiving unsafe data, decoding fails with a &lt;code&gt;badarg&lt;/code&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e911575fa07d922476972d70c313e02f9b293dc" translate="yes" xml:space="preserve">
          <source>When enabling an &lt;code&gt;Item&lt;/code&gt; that represents a group of processes, the &lt;code&gt;Item&lt;/code&gt; is enabled on all nodes added with the &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961f18823d723f8de73592aaed24463820242f21" translate="yes" xml:space="preserve">
          <source>When encoding action requests for one transaction, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt;. When encoding action requests for several transactions, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt;. Each element of the list is part of one transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e08a1905a5b3e0dc65abec6d55dd6312a7226f" translate="yes" xml:space="preserve">
          <source>When evaluating a digit map, a state machine waits for timeouts and letters reported by megaco:report_digit_event/2. The length of the various timeouts are defined in the digit_map_value() record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3c6596324fcf3c283be7c0b3555d1b46a28bd6" translate="yes" xml:space="preserve">
          <source>When evaluating an expression, the operator with the highest priority is evaluated first. Operators with the same priority are evaluated according to their associativity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1250bb19a7c4cde6aa87a09dc8b61c235001dd61" translate="yes" xml:space="preserve">
          <source>When executing in an emulator thread, it is &lt;strong&gt;very important&lt;/strong&gt; that you unlock &lt;strong&gt;all&lt;/strong&gt; locks you have locked before letting the thread out of your control; otherwise you are &lt;strong&gt;very likely&lt;/strong&gt; to deadlock the whole emulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d063e02c2be3b7faac0250e13934a29e88d4cb4" translate="yes" xml:space="preserve">
          <source>When executing the &lt;code&gt;etop&lt;/code&gt; script, configuration parameters can be specified as command-line options, for example, &lt;code&gt;etop -node testnode@myhost -setcookie MyCookie&lt;/code&gt;. The following configuration parameters exist for the tool:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb714d64a16860edb9466fdec5e16164e92007d" translate="yes" xml:space="preserve">
          <source>When executing within a CTH, all timetraps are shut off. So if your CTH never returns, the entire test run is stalled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407f5e1130fa4448aafc45d4cd243aed3adf7a96" translate="yes" xml:space="preserve">
          <source>When failing, all three functions set &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b47ee65ea9b082b925d4c051f321ad5844fe95" translate="yes" xml:space="preserve">
          <source>When fragments are added or deleted, &lt;code&gt;Mnesia&lt;/code&gt; automatically propagates the operation to all fragmented tables that have a foreign key referring to this table. Instead of using the record key to determine which fragment to access, the value of field &lt;code&gt;Attr&lt;/code&gt; is used. This feature makes it possible to colocate records automatically in different tables to the same node. &lt;code&gt;foreign_key&lt;/code&gt; defaults to &lt;code&gt;undefined&lt;/code&gt;. However, if the foreign key is set to something else, it causes the default values of the other fragmentation properties to be the same values as the actual fragmentation properties of the foreign table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333f980f252538f0da8f8c81fee6306212deb2e4" translate="yes" xml:space="preserve">
          <source>When generating the &lt;code&gt;relup&lt;/code&gt; file, &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; ensures that there is only one &lt;code&gt;restart_emulator&lt;/code&gt; instruction and that it is the last instruction in the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c099bc81dcbffa43792d0bf735abab5b902a73" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;code&gt;ssh&lt;/code&gt; subsystem for daemons, use &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;-behaviour(ssh_server_channel)&lt;/a&gt;&lt;/code&gt; (Replaces ssh_daemon_channel) instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6478258292a96422b7f4fde5f2a8507d5b2f75a" translate="yes" xml:space="preserve">
          <source>When implementing a client subsystem handler, use &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;-behaviour(ssh_client_channel)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0817fdff736a7fb006dde9156f2e254a826ee1a2" translate="yes" xml:space="preserve">
          <source>When importing MIBs, ensure that the imported MIBs as well as the importing MIB are compiled using the same version of the SNMP-compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d86af8d65c195f9b07f8aefb0aff8be5ef9554d" translate="yes" xml:space="preserve">
          <source>When inputting data using sql_query/[2,3] the values will always be in string format as they are part of an SQL-query. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a61084660618420bf57899c1e143bbdfd319d4" translate="yes" xml:space="preserve">
          <source>When installing a release, the application specifications are automatically updated before evaluating the &lt;code&gt;relup&lt;/code&gt; script. Thus, no instructions are needed in the &lt;code&gt;.appup&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab36faf918b13f9650566e7cda312d53b2b058cb" translate="yes" xml:space="preserve">
          <source>When instrumentation of the emulator is enabled, the emulator uses more memory and runs slower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613cb49badd27e8334ffae06e691a346b0c3156f" translate="yes" xml:space="preserve">
          <source>When interpreting the data for a process, it is helpful to know that anonymous function objects (funs) are given the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a1e6f2364e14a4f8731ff03ef081c6c153b8e5" translate="yes" xml:space="preserve">
          <source>When it comes to pure encode/decode performance, it turns out that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb9a1b728613db78be0dae343529296127017c3" translate="yes" xml:space="preserve">
          <source>When it is guaranteed that all trace messages are delivered to the tracer up to the point that &lt;code&gt;Tracee&lt;/code&gt; reached at the time of the call to &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;, then a &lt;code&gt;{trace_delivered, Tracee, Ref}&lt;/code&gt; message is sent to the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efe9163e0ae5672fec51b923b5f0a3fddf22450" translate="yes" xml:space="preserve">
          <source>When libraries and escripts are expanded, the names of their contained applications will be displayed. Double click on an application name to launch an application window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec607efa45c31ad1357f20a7d66c6c141bb9cf2" translate="yes" xml:space="preserve">
          <source>When linking:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08f2f18c94939c7eb816f59b144c9e39119701b" translate="yes" xml:space="preserve">
          <source>When loading, function &lt;code&gt;load/2&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt; when any instance of the driver is present. Thus, if a driver is waiting to get unloaded (because of open ports), it simply changes state to no longer need unloading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65fab8b9afb79981ea75c2c9f545c0487fc0a213" translate="yes" xml:space="preserve">
          <source>When looking at memory usage in a running system the most basic function to get information from is &lt;code&gt;erlang:memory()&lt;/code&gt;. It returns the current memory usage of the system. &lt;code&gt;instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of where memory is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc0303546ea4a5cee3b6a223eb3288b9d2ea037" translate="yes" xml:space="preserve">
          <source>When macros are expanded in expressions the macro calls are replaced by the macro value without any form of quoting or enclosing in parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e14461d99df8d7f5bd6dbaee93c610c2ce18da3" translate="yes" xml:space="preserve">
          <source>When many types (or another ASN.1 entity) only differ in some minor cases, but the structure of the types is similar, only one general type can be defined and the differences can be supplied through parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e3f53fcfe03af37581eeb29d3a1f8a21d06868" translate="yes" xml:space="preserve">
          <source>When matched against a term, both &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are matched against the term. The idea behind this feature is to avoid reconstruction of terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ef1970aabf29043b85da367698cefcc4f383ae" translate="yes" xml:space="preserve">
          <source>When matching &lt;code&gt;Value&lt;/code&gt;, value must be either a variable or an integer, or a floating point literal. Expressions are not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919226a6786be88542935b4ae72b62f44ea75480" translate="yes" xml:space="preserve">
          <source>When matching strings, the following is a valid pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c82c501be92ba824ae89344ef75c4d9af9bf67" translate="yes" xml:space="preserve">
          <source>When megaco fails to send the reply (see &lt;code&gt;&lt;a href=&quot;#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;), for whatever reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acae380ca138d49866a8d2225bb9fdf2866a8ef8" translate="yes" xml:space="preserve">
          <source>When messages are &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;passed between connected nodes&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; is used, the first byte containing the version number (131) is omitted from the terms that follow the distribution header. This is because the version number is implied by the version number in the distribution header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787e404397583f253bb775c283cf222bacb2db6c" translate="yes" xml:space="preserve">
          <source>When monitoring is requested, and a corresponding &lt;code&gt;{ok, pending_driver}&lt;/code&gt; or &lt;code&gt;{ok, pending_process}&lt;/code&gt; would be returned, the function instead returns a tuple &lt;code&gt;{ok, PendingStatus, reference()}&lt;/code&gt; and the process then gets a monitor message later, when the driver gets loaded. The monitor message to expect is described in the function description of &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb7c3fa2502fdd9d0754635086f8f9899582889" translate="yes" xml:space="preserve">
          <source>When multiple test specification files are specified at startup (either with &lt;code&gt;ct_run -spec file1 file2 ...&lt;/code&gt; or &lt;code&gt;ct:run_test([{spec, [File1,File2,...]}])&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; either executes one test run per specification file, or joins the files and performs all tests within one single test run. The first behavior is the default one. The latter requires that start flag/option &lt;code&gt;join_specs&lt;/code&gt; is provided, for example, &lt;code&gt;run_test -spec ./my_tests1.ts ./my_tests2.ts -join_specs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4d379ce1acc3e58649f3f6e5610dec08b734cc" translate="yes" xml:space="preserve">
          <source>When new nodes are added to the network, they are informed of the globally registered names that already exist. The network is also informed of any global names in newly connected nodes. If any name clashes are discovered, function &lt;code&gt;Resolve&lt;/code&gt; is called. Its purpose is to decide which pid is correct. If the function crashes, or returns anything other than one of the pids, the name is unregistered. This function is called once for each name clash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f8bd0d1896a4dff8f44b290b2a56e3f9fcb215" translate="yes" xml:space="preserve">
          <source>When one node wants to connect to another node it starts with a &lt;code&gt;PORT_PLEASE2_REQ&lt;/code&gt; request to the EPMD on the host where the node resides to get the distribution port that the node listens to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733930eec7fc5b747c5c2817c8d2e79c6f4e243c" translate="yes" xml:space="preserve">
          <source>When one of these option changes occurs at top-level (that is, not inside subpattern parentheses), the change applies to the remainder of the pattern that follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86cd46910a6aa214f7f42e5ee8633b337f649a0" translate="yes" xml:space="preserve">
          <source>When opening an existing wrap log, it is not necessary to supply a value for option &lt;code&gt;Size&lt;/code&gt;, but any supplied value must equal the current log size, otherwise the tuple &lt;code&gt;{error, {size_mismatch, CurrentSize, NewSize}}&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7edf9e74339539f6cc3b3080ee90687bd35019" translate="yes" xml:space="preserve">
          <source>When option &lt;code&gt;global&lt;/code&gt; is speciified, the &lt;code&gt;capture&lt;/code&gt; specification affects each match separately, so that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35779093faa3e10fba6141595e13648b564ea182" translate="yes" xml:space="preserve">
          <source>When option &lt;code&gt;unicode&lt;/code&gt; is specified, the regular expression is to be specified as a valid Unicode &lt;code&gt;charlist()&lt;/code&gt;, otherwise as any valid &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a165a455c0fbb6c5fe22fe047dc9f316e166c5" translate="yes" xml:space="preserve">
          <source>When ordered to shut down, the &lt;code&gt;gen_statem&lt;/code&gt; then calls callback function &lt;code&gt;terminate(shutdown, State, Data)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c0af6f0c64d162765f0e344a6e84e0addaa2a2" translate="yes" xml:space="preserve">
          <source>When packaging code using &lt;code&gt;systools&lt;/code&gt;, the code for each application is placed in a separate directory, &lt;code&gt;lib/Application-Vsn&lt;/code&gt;, where &lt;code&gt;Vsn&lt;/code&gt; is the version number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9753680bda30c348a14a4334e6baee4da1b60e94" translate="yes" xml:space="preserve">
          <source>When parsing a URI with an unknown scheme (that is, a scheme not found in the scheme defaults), a port number must be provided, otherwise the parsing fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710f52128840cdac154a523eb3c58c2968f8b895" translate="yes" xml:space="preserve">
          <source>When parts of the MIB are implemented, you recompile it and continue on by using default functions. With this approach, the SNMP agent can be developed incrementally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91864f69e3643249c414a5ca6b0b38fdf0614ca" translate="yes" xml:space="preserve">
          <source>When performance is of highest priority and you are interested in a limited part of the ASN.1 encoded message before deciding what to do with the rest of it, an option is to decode only this small part. The situation can be a server that has to decide the addressee of a message. The addressee can be interested in the entire message, but the server can be a bottleneck that you want to spare any unnecessary load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f8fec10d66dd9849d5606b35c3bae4eb0e24b0" translate="yes" xml:space="preserve">
          <source>When performing a GC, this is the max number of cache entries that will be deleted from the cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12910634b83422602cdf82ac5e1d4a0b08ca569" translate="yes" xml:space="preserve">
          <source>When positioning in a file with other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt;, caution must be taken to set the position on a correct character boundary. For details, see &lt;code&gt;&lt;a href=&quot;#position-2&quot;&gt;position/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edc83622335984eb1eafacb2b7c60d225676ad9" translate="yes" xml:space="preserve">
          <source>When reading and writing to Unicode-aware entities, like a file opened for Unicode translation, you probably want to format text strings using the functions in the &lt;code&gt;io&lt;/code&gt; module or the &lt;code&gt;io_lib&lt;/code&gt; module. For backward compatibility reasons, these functions do not accept any list as a string, but require a special &lt;strong&gt;translation modifier&lt;/strong&gt; when working with Unicode texts. The modifier is &lt;code&gt;t&lt;/code&gt;. When applied to control character &lt;code&gt;s&lt;/code&gt; in a formatting string, it accepts all Unicode code points and expects binaries to be in UTF-8:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8c1dd8823b82718c750f6e4752dce919973fd1c" translate="yes" xml:space="preserve">
          <source>When receiving data from untrusted sources, use option &lt;code&gt;ERL_NIF_BIN2TERM_SAFE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caaa8dcd0a5b73778282496efd8b85cdbc96febe" translate="yes" xml:space="preserve">
          <source>When receiving this event, the default simple handler clears the latest received alarm with id &lt;code&gt;AlarmId&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e62ca61b001221600279b3875635215766f5030" translate="yes" xml:space="preserve">
          <source>When receiving this event, the default simple handler stores the alarm. &lt;code&gt;AlarmId&lt;/code&gt; identifies the alarm and is used when the alarm is cleared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab9fe9e9b48ff6bfb268655c0f4e10837898a9b" translate="yes" xml:space="preserve">
          <source>When recompiling with &lt;code&gt;gcc&lt;/code&gt;, use flag &lt;code&gt;-Wstrict-prototypes&lt;/code&gt; to get better warnings. Try to find a similar flag if you use another compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa55ded95f5c996f7f21886e99692b06c59dfaf" translate="yes" xml:space="preserve">
          <source>When recursing and building a list, it is important to ensure that you attach the new elements to the beginning of the list. In this way, you will build &lt;strong&gt;one&lt;/strong&gt; list, not hundreds or thousands of copies of the growing result list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bab5f0a38ad7351ef92518566a8a66e14c70a0" translate="yes" xml:space="preserve">
          <source>When restricted shell mode is activated or deactivated, new jobs started on the node run in restricted or normal mode, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2049b6ccaf60623aba58c7816db28baba978c3" translate="yes" xml:space="preserve">
          <source>When run as above (this will take some time), the measurement process is done as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcae0656877ffa6ebb4290ed9f508d93d062de30" translate="yes" xml:space="preserve">
          <source>When run on Linux, &lt;code&gt;cpu_sup&lt;/code&gt; assumes that the &lt;code&gt;/proc&lt;/code&gt; file system is present and accessible by &lt;code&gt;cpu_sup&lt;/code&gt;. If it is not, &lt;code&gt;cpu_sup&lt;/code&gt; will terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf54f8998c8d68cc207a24a295ffc4553d6eff1" translate="yes" xml:space="preserve">
          <source>When runnable processes on priority &lt;code&gt;high&lt;/code&gt; exist, no processes on priority &lt;code&gt;low&lt;/code&gt; or &lt;code&gt;normal&lt;/code&gt; are selected for execution. Notice however that this does &lt;strong&gt;not&lt;/strong&gt; mean that no processes on priority &lt;code&gt;low&lt;/code&gt; or &lt;code&gt;normal&lt;/code&gt; can run when processes are running on priority &lt;code&gt;high&lt;/code&gt;. When using multiple schedulers, more processes can be running in parallel than processes on priority &lt;code&gt;high&lt;/code&gt;. That is, a &lt;code&gt;low&lt;/code&gt; and a &lt;code&gt;high&lt;/code&gt; priority process can execute at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac375c5ce5278df5f7742eba36c446680185abe" translate="yes" xml:space="preserve">
          <source>When runnable processes on priority &lt;code&gt;max&lt;/code&gt; exist, no processes on priority &lt;code&gt;low&lt;/code&gt;, &lt;code&gt;normal&lt;/code&gt;, or &lt;code&gt;high&lt;/code&gt; are selected for execution. As with priority &lt;code&gt;high&lt;/code&gt;, processes on lower priorities can execute in parallel with processes on priority &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680e4c2820f1533afc4212ad58a52897fa7b6ea9" translate="yes" xml:space="preserve">
          <source>When running SMP erlang on a multi-core machine the &quot;throughput&quot; is significantly higher. The mstone1 test is an extreme test, but it shows what is gained by using the reentrant flex-scanner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8603cea37568d4ea95955c8c7cd5ad79e8fceb" translate="yes" xml:space="preserve">
          <source>When running a distributed system with two or more participating nodes, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; must be executed on each participating node. This would typically be part of the boot script in an embedded environment. In a test environment or an interactive environment, &lt;code&gt;mnesia:start()&lt;/code&gt; can also be used either from the Erlang shell or another program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e9a6705c8969bac7cd69e2170ef9d9d0ac1c6a" translate="yes" xml:space="preserve">
          <source>When running in &lt;code&gt;utf8&lt;/code&gt; mode, functions &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read_link-1&quot;&gt;read_link/1&lt;/a&gt;&lt;/code&gt; never return raw filenames. To return all filenames including raw filenames, use functions &lt;code&gt;&lt;a href=&quot;#list_dir_all&quot;&gt;list_dir_all/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read_link_all&quot;&gt;read_link_all/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdc638646c31aefd08c7b469c60f917c3f883df" translate="yes" xml:space="preserve">
          <source>When running on OSs lacking support for monotonic time, &lt;code&gt;heart&lt;/code&gt; is susceptible to system clock adjustments of more than &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; seconds. When this happens, &lt;code&gt;heart&lt;/code&gt; times out and tries to reboot the system. This can occur, for example, if the system clock is adjusted automatically by use of the Network Time Protocol (NTP).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ecb6729e649e0c2e3875d3412d7df6f9ff2fc1b" translate="yes" xml:space="preserve">
          <source>When running on Windows, suppresses creation of a new console window when spawning the port program. (This option has no effect on other platforms.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b602ea12cff6b347850ec520a992d2e4051e4a" translate="yes" xml:space="preserve">
          <source>When selecting data from a table, all data types are returned from the database to the ODBC driver as an ODBC data type. The tables below shows the mapping between those data types and what is returned by the Erlang API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5028404a77ebb05ae66aa4cdb0300c35b354c2d2" translate="yes" xml:space="preserve">
          <source>When sending data to a port. Ports understand deep lists so there is no reason to flatten the list before sending it to the port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6655794aac8234bda9f3cc8627542cf28e39cd7" translate="yes" xml:space="preserve">
          <source>When sending one transaction in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt; (&lt;code&gt;UserReply&lt;/code&gt; will then be &lt;code&gt;user_reply()&lt;/code&gt;). When sending several transactions in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt; (&lt;code&gt;UserReply&lt;/code&gt; will then be &lt;code&gt;[user_reply()]&lt;/code&gt;). Each element of the list is part of one transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342bdd47df4ec30e4e5a4ebaa64afc70c7b8eea1" translate="yes" xml:space="preserve">
          <source>When sending one transaction in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt;. When sending several transactions in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt;. Each element of the list is part of one transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b19f5e353d16bcbf308a2928e10b271ad77a7b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system logs an error event via &lt;code&gt;logger&lt;/code&gt;, containing details about the process when the maximum heap size is reached. One log event is sent each time the limit is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a9f29c7c04f56d28d9864f8634905c97f0d23f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system sends an untrappable exit signal with reason &lt;code&gt;kill&lt;/code&gt; to the process if the maximum heap size is reached. The garbage collection that triggered the &lt;code&gt;kill&lt;/code&gt; is not completed, instead the process exits as soon as possible. When set to &lt;code&gt;false&lt;/code&gt;, no exit signal is sent to the process, instead it continues executing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1535dfcd1ada0e5df2bfdd93f8582a8fb9db2211" translate="yes" xml:space="preserve">
          <source>When set, informs the peer to use &lt;code&gt;{IP, Port}&lt;/code&gt; as the primary address of the local endpoint for the association specified by &lt;code&gt;assoc_id&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09fa3690c8e86bcc1ad44fbac6fe4381cfc8c36" translate="yes" xml:space="preserve">
          <source>When set, requests that the local endpoint uses the value specified by &lt;code&gt;adaptation_ind&lt;/code&gt; as the Adaptation Indication parameter for establishing new associations. For details, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extenstions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35268e3a52547204a88309f957a19dbdd29a75e6" translate="yes" xml:space="preserve">
          <source>When setting up a trace, the following features can also be activated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc86d8be157ab5b84c3a61f949941d9549419fe9" translate="yes" xml:space="preserve">
          <source>When something is to be sent, everything is packed into one message, unless the trigger was a reply transaction and the added size of the reply and all the requests is greater then &lt;code&gt;trans_req_maxsize&lt;/code&gt;, in which case the stored transactions are sent first in a separate message and the reply in another message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6669a85ba52eabed1bcac71536c7df178c1e61" translate="yes" xml:space="preserve">
          <source>When sorting or merging files, only the first of a sequence of terms that compare equal (&lt;code&gt;==&lt;/code&gt;) is output if this option is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;, which implies that all terms that compare equal are output. When checking files for sortedness, a check that no pair of consecutive terms compares equal is done if this option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c34b332981b8e474e02ef63bcc500fd0757ef2" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt; only the pid can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66f134384d3cc9012959c5c579272f12c941335" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt; only the pid can used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9910d3d66f8237ea301a1cc0a52c4d81c8b1682" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ce6035e3ae59d7f18987449985901fd92e494f" translate="yes" xml:space="preserve">
          <source>When started, the node waits for all nodes specified by &lt;code&gt;sync_nodes_mandatory&lt;/code&gt; and &lt;code&gt;sync_nodes_optional&lt;/code&gt; to come up. When all nodes are up, or when all mandatory nodes are up and the time specified by &lt;code&gt;sync_nodes_timeout&lt;/code&gt; has elapsed, all applications start. If not all mandatory nodes are up, the node terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f35884d86e4f1c2ac96377ac4d8d3d8958cc289" translate="yes" xml:space="preserve">
          <source>When started, the supervisor does not start any child processes. Instead, all child processes are added dynamically by calling:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af782a2bcb2a4b2a362bed6616a129bcc6a72b52" translate="yes" xml:space="preserve">
          <source>When starting &lt;code&gt;Mnesia&lt;/code&gt;, a &lt;code&gt;.LOG&lt;/code&gt; file called &lt;code&gt;LATEST.LOG&lt;/code&gt; is created and placed in the database directory. This file is used by &lt;code&gt;Mnesia&lt;/code&gt; to log disc-based transactions. This includes all transactions that write at least one record in a table that is of storage type &lt;code&gt;disc_copies&lt;/code&gt; or &lt;code&gt;disc_only_copies&lt;/code&gt;. The file also includes all operations that manipulate the schema itself, such as creating new tables. The log format can vary with different implementations of &lt;code&gt;Mnesia&lt;/code&gt;. The &lt;code&gt;Mnesia&lt;/code&gt; log is currently implemented in the standard library module &lt;code&gt;disk_log&lt;/code&gt; in &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcc2618bb75c573fc25f8a846a8fe36e4ed8763" translate="yes" xml:space="preserve">
          <source>When starting &lt;code&gt;prim_app&lt;/code&gt; as defined above, the application controller calls the following callback functions before &lt;code&gt;application:start(prim_app)&lt;/code&gt; returns a value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd4f1a6e7e43123fc3118e6461ff8abe900204f" translate="yes" xml:space="preserve">
          <source>When starting Erlang in embedded mode, it is assumed that exactly one system configuration file is used, named &lt;code&gt;sys.config&lt;/code&gt;. This file is to be located in &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the Erlang/OTP root installation directory and &lt;code&gt;Vsn&lt;/code&gt; is the release version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ddbb5d78d831c78a317496e7e2a2d2c40076a3" translate="yes" xml:space="preserve">
          <source>When starting Erlang/OTP using the boot script, all applications from the &lt;code&gt;.rel&lt;/code&gt; file are automatically loaded and started:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b604ec38ae2b79479f9ec0cb1378442b00d5b576" translate="yes" xml:space="preserve">
          <source>When starting a primary application with included applications, the primary application is started the normal way, that is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0f727403d7e975b13ca3d05489c37f1a495f5a" translate="yes" xml:space="preserve">
          <source>When starting an Erlang node, the default behaviour is that all log events on level &lt;code&gt;notice&lt;/code&gt; or more severe, are logged to the terminal via the default handler. To also log info events, you can either change the primary log level to &lt;code&gt;info&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d267d7fc52461e3316cc2f612f2db868d98e7a72" translate="yes" xml:space="preserve">
          <source>When starting external programs on Solaris, the system call &lt;code&gt;vfork&lt;/code&gt; is used in preference to &lt;code&gt;fork&lt;/code&gt; for performance reasons, although it has a history of being less robust. If there are problems using &lt;code&gt;vfork&lt;/code&gt;, setting environment variable &lt;code&gt;ERL_NO_VFORK&lt;/code&gt; to any value causes &lt;code&gt;fork&lt;/code&gt; to be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eba2c0286e1f80a8b6d2f783a23106deb0b2394" translate="yes" xml:space="preserve">
          <source>When starting snmpa_local_db it always tries to open an existing database. If &lt;code&gt;false&lt;/code&gt;, and some errors occur, a new database is created instead. If &lt;code&gt;true&lt;/code&gt;, an existing file will be repaired. If &lt;code&gt;force&lt;/code&gt;, the table will be repaired even if it was properly closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c86792af0c1fc90a287c8a9c5bae64d2165932" translate="yes" xml:space="preserve">
          <source>When starting the &lt;code&gt;Inets&lt;/code&gt; application, a manager process for the default profile is started. The functions in this API that do not explicitly use a profile accesses the default profile. A profile keeps track of proxy options, cookies, and other options that can be applied to more than one request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd05c53bfd126defe810f3a187a5cf1551a34b96" translate="yes" xml:space="preserve">
          <source>When starting the flex scanner a port to the linked in driver is created. This port has to be owned by a process. This process must not die. If it does the port will also terminate. Therefor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d9ab8ee43c8cd162c696fc7f8c9882054157b9c" translate="yes" xml:space="preserve">
          <source>When starting this release, three things must be specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e8349f617cc19cb94845c2b5a433d10397c346" translate="yes" xml:space="preserve">
          <source>When starting with Unicode, one often stumbles over some common issues. This section describes some methods of dealing with Unicode data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63dac761d2448700171ff70d4839175c0009a766" translate="yes" xml:space="preserve">
          <source>When stopped, the application is still loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcf5a7b78ff49a4689ff94e30fd3cc2e19a3b3d" translate="yes" xml:space="preserve">
          <source>When streaming to the calling processes using option &lt;code&gt;{self, once}&lt;/code&gt;, the first message has an extra element, that is, &lt;code&gt;{http, {RequestId, stream_start, Headers, Pid}}&lt;/code&gt;. This is the process id to be used as an argument to &lt;code&gt;httpc:stream_next/1&lt;/code&gt; to trigger the next message to be sent to the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715fec6e13a0abfe20ee555a6324b0802bfff927" translate="yes" xml:space="preserve">
          <source>When string or binary objects are stored in the registry it is important that some simple guidelines are followed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9879a39d7048a88467f14f974e9672e4f402cb5c" translate="yes" xml:space="preserve">
          <source>When tables are forcefully loaded from the local disc, all operations that were performed on the replicated table while the local node was down, and the remote replica was alive, are lost. This can cause the database to become inconsistent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9c626bcd30b7f8ecf9ddc823a493152c649dd7" translate="yes" xml:space="preserve">
          <source>When tests start, &lt;code&gt;Common Test&lt;/code&gt; Master displays information to console about the involved nodes. &lt;code&gt;Common Test&lt;/code&gt; Master also reports when tests finish, successfully or unsuccessfully. If connection is lost to a node, the test on that node is considered finished. &lt;code&gt;Common Test&lt;/code&gt; Master does not attempt to re-establish contact with the failing node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e15e615fec1bfe62b38c3373f94e44765c1055" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;'CHANGE'&lt;/code&gt; message has been received you are guaranteed not to retrieve the old time offset when calling &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt;. Notice that you can observe the change of the time offset when calling &lt;code&gt;erlang:time_offset()&lt;/code&gt; before you get the &lt;code&gt;'CHANGE'&lt;/code&gt; message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389c67d197284147820c964a147bf25f89168f89" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term and the state callback name is &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. This makes it easy to branch depending on state or event as you desire. Be careful about which events you handle in which states so that you do not accidentally postpone an event forever creating an infinite busy loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c771ceccfcda3b957b4a4bb8455365fc3a48832" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be an atom and is used as the state callback name; see &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt;. This co-locates all code for a specific state in one function as the &lt;code&gt;gen_statem&lt;/code&gt; engine branches depending on state name. Note the fact that the callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; makes the state name &lt;code&gt;terminate&lt;/code&gt; unusable in this mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd23a20d36b333c46d925b8fd401de86fe841dc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Addr&lt;/code&gt; value does not contain a port number, the value of &lt;code&gt;intAgentUDPPort&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22814bccf02caaf2232de9c743157f0b7348ee14" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;erl_tar&lt;/code&gt; core wants to, for example, write a piece of &lt;code&gt;Data&lt;/code&gt;, it would call &lt;code&gt;ExampleFun(write, {UserPrivate,Data})&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84a2f0be01530772a20ac645af7f54b604dbf79" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;fprof&lt;/code&gt; server is stopped the collected raw profile data is lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37d26017c607226a4f422562f10e0bd5f4835e3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt;, these functions are also called with arguments &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; whenever the state changes. In this case there are some restrictions on the &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; that may be returned: &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is not allowed since a &lt;strong&gt;state enter call&lt;/strong&gt; is not an event so there is no event to postpone, and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;{next_event,_,_}&lt;/a&gt;&lt;/code&gt; is not allowed since using &lt;strong&gt;state enter calls&lt;/strong&gt; should not affect how events are consumed and produced. You may also not change states from this call. Should you return &lt;code&gt;{next_state,NextState, ...}&lt;/code&gt; with &lt;code&gt;NextState =/= State&lt;/code&gt; the &lt;code&gt;gen_statem&lt;/code&gt; crashes. Note that it is actually allowed to use &lt;code&gt;{repeat_state, NewData, ...}&lt;/code&gt; although it makes little sense since you immediately will be called again with a new &lt;strong&gt;state enter call&lt;/strong&gt; making this just a weird way of looping, and there are better ways to loop in Erlang. If you do not update &lt;code&gt;NewData&lt;/code&gt; and have some loop termination condition, or if you use &lt;code&gt;{repeat_state_and_data, _}&lt;/code&gt; or &lt;code&gt;repeat_state_and_data&lt;/code&gt; you have an infinite loop! You are advised to use &lt;code&gt;{keep_state,...}&lt;/code&gt;, &lt;code&gt;{keep_state_and_data,_}&lt;/code&gt; or &lt;code&gt;keep_state_and_data&lt;/code&gt; since changing states from a &lt;strong&gt;state enter call&lt;/strong&gt; is not possible anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a1846d28e7d4cd1692423afe0396a4f961fecf" translate="yes" xml:space="preserve">
          <source>When the Cover analysis is ready, Cover is stopped and all Cover compiled modules are &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;unloaded&lt;/a&gt;&lt;/code&gt;. The code for &lt;code&gt;channel&lt;/code&gt; is now loaded as usual from a &lt;code&gt;.beam&lt;/code&gt; file in the current path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e678693029d9376dee27d1a3e9cecfc3eb0694b" translate="yes" xml:space="preserve">
          <source>When the Erlang function &lt;code&gt;t/1&lt;/code&gt; was applied to an Xref server loaded with the current version of OTP, the returned value was close to 84 (percent). This means that the number of indirectly used modules is approximately six times greater when using the module graph. So the answer to the above stated question is that it is definitely worth while using the function graph for this particular analysis. Finally, note that in the presence of unresolved calls, the graphs may be incomplete, which means that there may be indirectly used modules that do not show up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef14100f6973eec9a2da0c5aac1b652a8be07c43" translate="yes" xml:space="preserve">
          <source>When the Erlang mode is correctly installed, it is automatically activated when a file ending in &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; is opened in Emacs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064005753816c68987f62de4089ac63432bbee7f" translate="yes" xml:space="preserve">
          <source>When the Erlang runtime system is automatically started from the &lt;code&gt;S75otp.system&lt;/code&gt; script, the &lt;code&gt;TERM&lt;/code&gt; environment variable must be set. The following is a minimal setting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e452b2fde57d622fa0997d4cb19e28e4a65d9107" translate="yes" xml:space="preserve">
          <source>When the MGC receives its first message, the Service Change Request, the Megaco application will automatically establish the connection by using the MG MID found in the message header as remote mid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc1904c9d30ade44fccd694ce928f2cb4a5ad23" translate="yes" xml:space="preserve">
          <source>When the MIB definition work is finished, there are two major issues left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e36ed72ceac42895c73ec727502a81f2596dcdf" translate="yes" xml:space="preserve">
          <source>When the SASL application is started, it adds a Logger handler that formats and writes these reports, as specified in the &lt;code&gt;configuration parameters for SASL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b73a5fb29f56921e69c0ac4a2cd6ca545f386dd" translate="yes" xml:space="preserve">
          <source>When the SNMP manager has crashed, the dependent client application has to wait for the SNMP manager to be restarted before it can &lt;strong&gt;reconnect&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13e96b0328435d455e574296b3ea29ea96cf675" translate="yes" xml:space="preserve">
          <source>When the agent receives a request, it keeps the request ID for one second after the response is sent. If the agent receives another request with the same request ID during this time, from the same IP address and UDP port, that request will be discarded. This mechanism has nothing to do with the function &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76ffb17b2706d88d3e12e2091f84905c555d5ff" translate="yes" xml:space="preserve">
          <source>When the agent receives the same get-request as above, a call will be made to &lt;code&gt;generic_access(get,&lt;/code&gt;'&lt;code&gt;IPADR')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93278d10a2e49a183a4771ee8ba18b8f11a4c78" translate="yes" xml:space="preserve">
          <source>When the async operation is done, &lt;code&gt;&lt;a href=&quot;driver_entry#ready_async&quot;&gt;ready_async&lt;/a&gt;&lt;/code&gt; driver entry function is called. If &lt;code&gt;ready_async&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt; in the driver entry, the &lt;code&gt;async_free&lt;/code&gt; function is called instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fda767b9fff4af850e8e6b34bac5b879c78132" translate="yes" xml:space="preserve">
          <source>When the choice of directories in the code path is &lt;code&gt;strict&lt;/code&gt;, the directory that ends up in the code path is exactly the stated one. This means that if, for example, the directory &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7/ebin&lt;/code&gt; is explicitly added to the code path, the code server does not load files from &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85eceed499c5d35cfe880d316d8beaf6cbb94efc" translate="yes" xml:space="preserve">
          <source>When the command running at the other end terminates, the following message can be sent to return the exit status of the command. A zero &lt;code&gt;exit_status&lt;/code&gt; usually means that the command terminated successfully. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exit_status-3&quot;&gt;ssh_connection:exit_status/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d64a299ff94a9ee47249f94cefcc624dd35a6f" translate="yes" xml:space="preserve">
          <source>When the compiler encounters the module attribute &lt;code&gt;-behaviour(Behaviour).&lt;/code&gt; in a module &lt;code&gt;Mod&lt;/code&gt;, it calls &lt;code&gt;Behaviour:behaviour_info(callbacks)&lt;/code&gt; and compares the result with the set of functions actually exported from &lt;code&gt;Mod&lt;/code&gt;, and issues a warning if any callback function is missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844a9525ff66b482554dce5aa81432bba7df925d" translate="yes" xml:space="preserve">
          <source>When the data has passed through an Ets table, &lt;code&gt;erts_debug:size/1&lt;/code&gt; and &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; return the same value. Sharing has been lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0180fd29af0af06f5eb68c4a08485d210bd536c3" translate="yes" xml:space="preserve">
          <source>When the data is returned, we deallocate our data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b841886acb544968ed7c8d220277846a17d2018c" translate="yes" xml:space="preserve">
          <source>When the driver has passed the &lt;code&gt;driver_entry&lt;/code&gt; over to the emulator, the driver is &lt;strong&gt;not&lt;/strong&gt; allowed to modify the &lt;code&gt;driver_entry&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1b7d404a057ddcb6ce2d59d8b2bdb057597c3d" translate="yes" xml:space="preserve">
          <source>When the driver is implemented, one would preferably write an Erlang interface for the driver to be able to test the functionality of the driver separately. This interface can then be used by the distribution module, which will cover the details of the protocol from the &lt;code&gt;net_kernel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7f8ef65dc76d982cfe0dc69232e4e5827bba12" translate="yes" xml:space="preserve">
          <source>When the driver is loaded. This callback must have a special name and inform the emulator of what callbacks are to be used by returning a pointer to a &lt;code&gt;ErlDrvEntry&lt;/code&gt; struct, which is to be properly filled in (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f883c088fbc777f98b15d9733f9e21c9a4e592" translate="yes" xml:space="preserve">
          <source>When the emulator is run with instrumentation, the &lt;code&gt;system&lt;/code&gt; value is more accurate, but memory directly allocated for &lt;code&gt;malloc&lt;/code&gt; (and friends) is still not part of the &lt;code&gt;system&lt;/code&gt; value. Direct calls to &lt;code&gt;malloc&lt;/code&gt; are only done from OS-specific runtime libraries and perhaps from user-implemented Erlang drivers that do not use the memory allocation functions in the driver interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77fa82a9f2b1030c7423dea145244305c2d9ec50" translate="yes" xml:space="preserve">
          <source>When the end of the binary is reached and the second clause matches, the match context will simply be discarded (removed in the next garbage collection, as there is no longer any reference to it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6749f7e62fded072722b2a6ba9f855671542a797" translate="yes" xml:space="preserve">
          <source>When the external process connected to the port exits, a message of the form &lt;code&gt;{Port,{exit_status,Status}}&lt;/code&gt; is sent to the connected process, where &lt;code&gt;Status&lt;/code&gt; is the exit status of the external process. If the program aborts on Unix, the same convention is used as the shells do (that is, 128+signal).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4264b7112b0cfbe36495f0cf35a65dd07c402f" translate="yes" xml:space="preserve">
          <source>When the function &lt;code&gt;&lt;a href=&quot;mnesia#read-3&quot;&gt;mnesia:read/3&lt;/a&gt;&lt;/code&gt; cannot be used, &lt;code&gt;Mnesia&lt;/code&gt; provides the programmer with several functions for matching records against a pattern. The most useful ones are the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a19808ffaca3fd048abe14ac1422112fae7f8be" translate="yes" xml:space="preserve">
          <source>When the function returns &lt;code&gt;{ok, pending_driver}&lt;/code&gt; or &lt;code&gt;{ok, pending_process}&lt;/code&gt;, one can get information about when the driver is &lt;strong&gt;actually&lt;/strong&gt; loaded by using option &lt;code&gt;{monitor, MonitorOption}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ba8ad7fadddd0bcf392a93e44763cd846c6e5a" translate="yes" xml:space="preserve">
          <source>When the indexed set is a set of subsets of a set X, we call x a &lt;strong id=&quot;family&quot;&gt;family of subsets&lt;/strong&gt; of X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e8e9476aa05c51f4eed310e674f5ac07849f6f" translate="yes" xml:space="preserve">
          <source>When the initial message arrives the transport service forwards it to the protocol engine which automatically sets up the connection and invokes UserMod:handle_connect/2 before it invokes UserMod:handle_trans_request/3 with the Service Change Request like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b479e3b528c8dff428a540e36a91f070ee36f40" translate="yes" xml:space="preserve">
          <source>When the instrumentation function for the distributed table is called, the request should be forwarded to the table coordinator. The coordinator finds the requested information among the table holders and then returns the answer to the instrumentation function. The SNMP toolkit contains no support for coordination of tables since this must be independent of the implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4612fb76d339a555d7ce395426dfd7559ca7e3" translate="yes" xml:space="preserve">
          <source>When the logs are full, &lt;code&gt;run_erl&lt;/code&gt; deletes and reuses the oldest log file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981906d024a846c5ad60dd39439e2525942f2a29" translate="yes" xml:space="preserve">
          <source>When the message queue grows larger than this threshold, the handler switches to a mode in which it drops all new events that senders want to log. Dropping an event in this mode means that the call to the log function never results in a message being sent to the handler, but the function returns without taking any action. The handler keeps logging the events that are already in its message queue, and when the length of the message queue is reduced to a level below the threshold, synchronous or asynchronous mode is resumed. Notice that when the handler activates or deactivates drop mode, information about it is printed in the log.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377865ca162dc01a005c1cf33711bbbcf3cf6d3a" translate="yes" xml:space="preserve">
          <source>When the modifier &lt;code&gt;l&lt;/code&gt; is specified, no detection of printable character lists takes place, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28bc31ee472c6a6f71d309884c8eb89c306960b4" translate="yes" xml:space="preserve">
          <source>When the monitor is triggered a &lt;code&gt;'CHANGE'&lt;/code&gt; message is sent to the monitoring process. A &lt;code&gt;'CHANGE'&lt;/code&gt; message has the following pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6576c399613f943fdf757c4457a0db8dddece67" translate="yes" xml:space="preserve">
          <source>When the number of schedulers is less than or equal to the reader groups limit, each scheduler has its own reader group. When the number of schedulers is larger than the reader groups limit, schedulers share reader groups. Shared reader groups degrade read lock and read unlock performance while many reader groups degrade write lock performance. So, the limit is a tradeoff between performance for read operations and performance for write operations. Each reader group consumes 64 byte in each read/write lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36226219dde60c8da7ee7e2f3ead5fe94e62e1f9" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;maps&lt;/code&gt; is given, no &lt;code&gt;.hrl&lt;/code&gt; files will be generated. The rest of this section describes the behavior of the compiler when &lt;code&gt;maps&lt;/code&gt; is not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a21311cf0fcf49981af7057a09551734c3f7b1" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the check &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be performed in addition to the usual x509-path validation checks. If the check fails the error {bad_cert, hostname_check_failed} will be propagated to the path validation fun &lt;code&gt;&lt;a href=&quot;#verify_fun&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;, where it is possible to do customized checks by using the full possibilities of the &lt;code&gt;public_key:pkix_verify_hostname/3&lt;/code&gt; API. When the option &lt;code&gt;server_name_indication&lt;/code&gt; is provided, its value (the DNS name) will be used as &lt;code&gt;ReferenceID&lt;/code&gt; to &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;. When no &lt;code&gt;server_name_indication&lt;/code&gt; option is given, the &lt;code&gt;Host&lt;/code&gt; argument will be used as Server Name Indication extension. The &lt;code&gt;Host&lt;/code&gt; argument will also be used for the &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; check and if the &lt;code&gt;Host&lt;/code&gt; argument is an &lt;code&gt;inet:ip_address()&lt;/code&gt; the &lt;code&gt;ReferenceID&lt;/code&gt; used for the check will be &lt;code&gt;{ip, Host}&lt;/code&gt; otherwise &lt;code&gt;dns_id&lt;/code&gt; will be assumed with a fallback to &lt;code&gt;ip&lt;/code&gt; if that fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93a77e10e8decc9a9a5af353d5ffa646066813a" translate="yes" xml:space="preserve">
          <source>When the port has been opened, the driver can be called. In the &lt;code&gt;pg_sync&lt;/code&gt; example, we do not have any data from the port, only the return value from the &lt;code&gt;port_control&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2960ec142372aacf524e3c02cb29b3deda53c6" translate="yes" xml:space="preserve">
          <source>When the port is in &lt;code&gt;data&lt;/code&gt; mode, all data is sent to Erlang in a format that suits the distribution. In fact, the raw data will never reach any Erlang process, but will be translated/interpreted by the emulator itself and then delivered in the correct format to the correct processes. In the current emulator version, received data is to be tagged with a single byte of 100. That is what the macro &lt;code&gt;DIST_MAGIC_RECV_TAG&lt;/code&gt; is defined to. The tagging of data in the distribution can be changed in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a5fc45c74e8bc2edca91ff415618981adda324" translate="yes" xml:space="preserve">
          <source>When the protocol is available to Erlang through a driver and an Erlang interface module, a distribution module can be written. The distribution module is a module with well-defined callbacks, much like a &lt;code&gt;gen_server&lt;/code&gt; (there is no compiler support for checking the callbacks, though). This module implements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be29dce95eec97a67e2087b38e94bd51a5e3dde0" translate="yes" xml:space="preserve">
          <source>When the queue contains data, the driver does not close until the queue is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ba1599707f578e6da25bafa5c66c03f204937f" translate="yes" xml:space="preserve">
          <source>When the release handler encounters the instruction, it first generates a temporary boot file, which starts the new versions of the emulator and the core applications, and the old version of all other applications. Then it shuts down the current emulator by calling &lt;code&gt;init:reboot()&lt;/code&gt;, see the &lt;code&gt;init(3)&lt;/code&gt; manual page in Kernel. All processes are terminated gracefully and the system is rebooted by the &lt;code&gt;heart&lt;/code&gt; program, using the temporary boot file. After the reboot, the rest of the relup instructions are executed. This is done as a part of the temporary boot script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee98f8753d15dee1e12f17349a48be34b074873" translate="yes" xml:space="preserve">
          <source>When the release handler encounters the instruction, it shuts down the emulator by calling &lt;code&gt;init:reboot()&lt;/code&gt;, see the &lt;code&gt;init(3)&lt;/code&gt; manual page in Kernel. All processes are terminated gracefully and the system can then be rebooted by the &lt;code&gt;heart&lt;/code&gt; program using the new release version. No more upgrade instruction is executed after the restart.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a250d269026a9e3f5fca66518f55dd84f05c8c5d" translate="yes" xml:space="preserve">
          <source>When the request is received, the &lt;code&gt;gen_server&lt;/code&gt; calls &lt;code&gt;handle_cast(Request, State)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{noreply,State1}&lt;/code&gt;. &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d57c2ee62a9879fde2097882cf19d4663d2b600" translate="yes" xml:space="preserve">
          <source>When the restricted shell evaluates an expression and encounters a function call or an operator application, it calls a callback function (with information about the function call in question). This callback function returns &lt;code&gt;true&lt;/code&gt; to let the shell go ahead with the evaluation, or &lt;code&gt;false&lt;/code&gt; to abort it. There are two possible callback functions for the user to implement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54c402919b78665c1c8f198f292bab9fc59cd16" translate="yes" xml:space="preserve">
          <source>When the server is asked to provide a document type that cannot be determined by the MIME Type Settings, the server uses this default type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb82b8ca8c5a5957509c8e72df7e62feb33df317" translate="yes" xml:space="preserve">
          <source>When the shell starts, it starts a single evaluator process. This process, together with any local processes that it spawns, is referred to as a &lt;code&gt;job&lt;/code&gt;. Only the current job, which is said to be &lt;code&gt;connected&lt;/code&gt;, can perform operations with standard I/O. All other jobs, which are said to be &lt;code&gt;detached&lt;/code&gt;, are &lt;code&gt;blocked&lt;/code&gt; if they attempt to use standard I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c74035ba1de254b56bab74be22512784e14aa0a" translate="yes" xml:space="preserve">
          <source>When the size of all received requests exceeds &lt;code&gt;trans_req_maxsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7ff81cd7bcbcf93265972ba220ec58a44a2621" translate="yes" xml:space="preserve">
          <source>When the specified event occurs, the function &lt;code&gt;Function&lt;/code&gt; is called as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b740db20f360e56cbaf192b02a625103f61f81" translate="yes" xml:space="preserve">
          <source>When the supervisor terminates, then the next higher-level supervisor takes some action. It either restarts the terminated supervisor or terminates itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f021b23bfe2cd55d1b599da584871e714016f843" translate="yes" xml:space="preserve">
          <source>When the timer finally expires, a &quot;megaco segments not received&quot; (459) error message is sent to the other side and the user is notified with a &lt;code&gt;segment timeout&lt;/code&gt;&lt;code&gt;UserReply&lt;/code&gt; in either the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; callback function or the return value of the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf973279da0cedc632ba88c183b69c62e648346" translate="yes" xml:space="preserve">
          <source>When the timer reaches &lt;code&gt;0&lt;/code&gt; and expires, the driver entry function &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9f3b6a59efe7a46474fcba7bb50d20a40f5897" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the request is resent and the timer is restarted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4e877095aa4be1ada9827ad7529e4bc18e2c51" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the timer is restarted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157d3bfb09cfc45ece6b6d5a8c11a2c6035409d0" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the timer restarted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2702c4a29cb7ffd2d62635fddc60ffda837b937" translate="yes" xml:space="preserve">
          <source>When the timer reaches the final expire, either the function &lt;code&gt;megaco:call&lt;/code&gt; will return with &lt;code&gt;{error, timeout}&lt;/code&gt; or the callback function &lt;code&gt;handle_trans_reply&lt;/code&gt; will be called with &lt;code&gt;UserReply = {error, timeout}&lt;/code&gt; (if &lt;code&gt;megaco:cast&lt;/code&gt; was used).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d489b1aa41c1da0731c58c4d8333c65b8fb249f" translate="yes" xml:space="preserve">
          <source>When the tracing is completed, stop the tracer with &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0,1&lt;/a&gt;&lt;/code&gt; and format the trace log with &lt;code&gt;&lt;a href=&quot;ttb#format-1&quot;&gt;ttb:format/1,2&lt;/a&gt;&lt;/code&gt; (if there is anything to format).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36338011eef64525211dd65889fb16a9937ec35" translate="yes" xml:space="preserve">
          <source>When the transaction sender receives a request which is already &quot;in storage&quot; (indicated by the transaction id) it is assumed to be a resend and everything stored is sent. This could happen if the values of the &lt;code&gt;trans_timer&lt;/code&gt; and the &lt;code&gt;request_timer&lt;/code&gt; is not properly chosen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7862d7ec18f93027c83a7039d6cf2d951465703f" translate="yes" xml:space="preserve">
          <source>When the user has processed a transaction request in its callback function, the Megaco application assembles a transaction reply, encodes it using the selected encoding module and sends the message back by invoking the callback function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17fcbf724175dd6197cb33c7a80fb993e93fef84" translate="yes" xml:space="preserve">
          <source>When the web server is started at application start time, the properties are to be fetched from a configuration file that can consist of a regular Erlang property list, that is, &lt;code&gt;[{Option, Value}]&lt;/code&gt;, where &lt;code&gt;Option = property()&lt;/code&gt; and &lt;code&gt;Value = term()&lt;/code&gt;, followed by a full stop, or for backwards compatibility, an Apache-like configuration file. If the web server is started dynamically at runtime, a file can still be specified but also the complete property list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8385f08e883f730c6d6877fd915bdc9c53f2091" translate="yes" xml:space="preserve">
          <source>When the whole driver is unloaded. Every resource allocated by the driver is to be freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1864bbfe1bb4da0ed39ef620a0d58a044889dcf3" translate="yes" xml:space="preserve">
          <source>When the window (terminal) size changes on the client side, it &lt;strong&gt;can&lt;/strong&gt; send a message to the server side to inform it of the new dimensions. No API function generates this event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae6cb0d1aeff4baecd961c38c7a0d0343bce682" translate="yes" xml:space="preserve">
          <source>When there are no generators or bit string generators, a list comprehension returns either a list with one element (the result of evaluating &lt;code&gt;Expr&lt;/code&gt;) if all filters are true or an empty list otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c8a10137c4675b33b04fc152e8dd169fb08630" translate="yes" xml:space="preserve">
          <source>When there are no more objects in the table, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745f9cd3851e711d348b63ccc23a8f52273edfe7" translate="yes" xml:space="preserve">
          <source>When there are only simple restrictions on the key position, &lt;code&gt;qlc&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;dets#lookup-2&quot;&gt;dets:lookup/2&lt;/a&gt;&lt;/code&gt; to look up the keys. When that is not possible, the whole table is traversed. Option &lt;code&gt;traverse&lt;/code&gt; determines how this is done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97d09e0174e7ebcd752be249e317734288c7fe5" translate="yes" xml:space="preserve">
          <source>When there are only simple restrictions on the key position, QLC uses &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; to look up the keys. When that is not possible, the whole table is traversed. Option &lt;code&gt;traverse&lt;/code&gt; determines how this is done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1432344868741e2698e6a9b96d60c2837b98772c" translate="yes" xml:space="preserve">
          <source>When there is no risk of confusion, elements of Sets are identified with the sets they represent. For example, if U is the result of calling &lt;code&gt;&lt;a href=&quot;#union-2&quot;&gt;union/2&lt;/a&gt;&lt;/code&gt; with S1 and S2 as arguments, then U is said to be the union of S1 and S2. A more precise formulation is that Set(U) is the union of Set(S1) and Set(S2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3340db1e6247a69837f2ad75c699140be306fabf" translate="yes" xml:space="preserve">
          <source>When this argument is removed, a final CPU topology to use is determined at emulator boot time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b43ec86ba8c916251f60d0bb263cce04f4688f6" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the linked-in driver must manually acknowledge that the port has been successfully started using &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_init_ack&quot;&gt;erl_driver:erl_drv_init_ack()&lt;/a&gt;&lt;/code&gt;. This allows the implementor to make the &lt;code&gt;erlang:open_port&lt;/code&gt; exit with &lt;code&gt;badarg&lt;/code&gt; after some initial asynchronous initialization has been done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c9e4e469cc7c78f5cf4d1f7fdc335fb16bb6a9" translate="yes" xml:space="preserve">
          <source>When this function executes within a transaction, several processes running on different nodes can concurrently execute the function &lt;code&gt;raise/2&lt;/code&gt; without interfering with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5be18c956ae3c742f6fbc74a81c84e27f37de5" translate="yes" xml:space="preserve">
          <source>When this function is called the initiating &lt;code&gt;erlang:open_port&lt;/code&gt; call is returned as if the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; function had just been called. It can only be used when flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_INIT_ACK&lt;/a&gt;&lt;/code&gt; has been set on the linked-in driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1d28b41ff3a8afa6eef2cd6d49d478529957d0" translate="yes" xml:space="preserve">
          <source>When this function is called with a list of certificate options; it generates a configuration with just one node certificate where &lt;code&gt;cacerts&lt;/code&gt; contains the root cert and the intermediate certs that should be presented to a peer. In this case the same root cert must be used for all peers. This is useful in for example an Erlang distributed cluster where any node, towards another node, acts either as a server or as a client depending on who connects to whom. The generated certificate contains a subject altname, which is not needed in a client certificate, but makes the certificate useful for both roles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0dc82b5ddcdc81bd48ff82e4659150dc801ef9" translate="yes" xml:space="preserve">
          <source>When this function is called with a map containing client and server chain specifications; it generates both a client and a server certificate chain where the &lt;code&gt;cacerts&lt;/code&gt; returned for the server contains the root cert the server should trust and the intermediate certificates the server should present to connecting clients. The root cert the server should trust is the one used as root of the client certificate chain. Vice versa applies to the &lt;code&gt;cacerts&lt;/code&gt; returned for the client. The root cert(s) can either be pre-generated with &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;, or if options are specified; it is (they are) generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9a4bfdea86e7e0384f0eb8ca04b745e4df80d6" translate="yes" xml:space="preserve">
          <source>When this function is called, &lt;code&gt;*value_size&lt;/code&gt; is to contain the size of the &lt;code&gt;value&lt;/code&gt; buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0658a8caa71ae8ec3af2aaa874893698a63c04" translate="yes" xml:space="preserve">
          <source>When this function is executed inside a transaction-context, it returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdfcd8239bab330841cc445bcf6b51860555e6e" translate="yes" xml:space="preserve">
          <source>When this is triggered, the previous path through the pattern is searched for the most recent (*MARK) that has the same name. If one is found, the &quot;bumpalong&quot; advance is to the subject position that corresponds to that (*MARK) instead of to where (*SKIP) was encountered. If no (*MARK) with a matching name is found, (*SKIP) is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7db68b788b90d41b1ce4140671c7e956cf1dfc1" translate="yes" xml:space="preserve">
          <source>When this mapping is used, insertion and deletion in the original Mnesia table is slower, with a factor O(log n). The read access is not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb494176e860d606fcf89bbbcaf477ac48b4e483" translate="yes" xml:space="preserve">
          <source>When this option is set to &lt;code&gt;false&lt;/code&gt;, which is default, an RST received from the TCP peer is treated as a normal close (as though an FIN was sent). A caller to &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2&lt;/a&gt;&lt;/code&gt; gets &lt;code&gt;{error, closed}&lt;/code&gt;. In active mode, the controlling process receives a &lt;code&gt;{tcp_closed, Socket}&lt;/code&gt; message, indicating that the peer has closed the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7f5c99c2ce601b738e1cbcc7fe8e59a1211a42" translate="yes" xml:space="preserve">
          <source>When this option is specified, the &quot;start of line&quot; and &quot;end of line&quot; constructs match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. This is equivalent to Perl option &lt;code&gt;/m&lt;/code&gt; and can be changed within a pattern by a &lt;code&gt;(?m)&lt;/code&gt; option setting. If there are no newlines in a subject string, or no occurrences of &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; in a pattern, setting &lt;code&gt;multiline&lt;/code&gt; has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675f8d886654247d43dbcd4fe8a49b4d5b32073b" translate="yes" xml:space="preserve">
          <source>When this option is used, the result of &lt;code&gt;write/2&lt;/code&gt; calls can prematurely be reported as successful, and if a write error occurs, the error is reported as the result of the next file operation, which is not executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc30def2e6a5147d2d890feeb73645cc382d513" translate="yes" xml:space="preserve">
          <source>When time-out occurs, &lt;code&gt;Common Test&lt;/code&gt; never aborts the ongoing test case, as this can leave the SUT in an undefined, and possibly bad, state. Instead &lt;code&gt;Common Test&lt;/code&gt;, by default, finishes the current test run before stopping. If flag &lt;code&gt;force_stop&lt;/code&gt; is specified, &lt;code&gt;Common Test&lt;/code&gt; stops when the current test job is finished. If flag &lt;code&gt;force_stop&lt;/code&gt; is specified with &lt;code&gt;skip_rest&lt;/code&gt;, &lt;code&gt;Common Test&lt;/code&gt; only completes the current test case and skips the remaining tests in the test job.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7496cb290358c83d75813f93e436cc9aa7801dbd" translate="yes" xml:space="preserve">
          <source>When to use a Sub-agent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25981ff4244a1ee87a90be438c90aa93aa36e1ed" translate="yes" xml:space="preserve">
          <source>When trace flag &lt;code&gt;call&lt;/code&gt; is set on a process, function calls are traced on that process if a trace pattern is set for the called function.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
