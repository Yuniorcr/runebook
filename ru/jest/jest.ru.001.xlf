<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="jest">
    <body>
      <group id="jest">
        <trans-unit id="8039a41e04b2332bb9a1e006d40250afbf96b442" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2019 Facebook, Inc. and its affiliates.</source>
          <target state="translated">&amp;copy; 2019 Facebook, Inc. and its affiliates.</target>
        </trans-unit>
        <trans-unit id="8733204266bf9ef9d139b9cd40bbd88f570127e5" translate="yes" xml:space="preserve">
          <source>(default: &lt;code&gt;[ &quot;**/__tests__/**/*.[jt]s?(x)&quot;, &quot;**/?(*.)+(spec|test).[jt]s?(x)&quot; ]&lt;/code&gt;)</source>
          <target state="translated">(default: &lt;code&gt;[ &quot;**/__tests__/**/*.[jt]s?(x)&quot;, &quot;**/?(*.)+(spec|test).[jt]s?(x)&quot; ]&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="e44ebb5582c56abe12f2669212eb5c60e8d4853b" translate="yes" xml:space="preserve">
          <source>* Module factory function must return a function</source>
          <target state="translated">* Module factory function must return a function</target>
        </trans-unit>
        <trans-unit id="11a99659b9799607d24f99d1703d405ff90c24fb" translate="yes" xml:space="preserve">
          <source>. Please change the key configuration for one of the conflicting plugins to avoid overlap.</source>
          <target state="translated">. Please change the key configuration for one of the conflicting plugins to avoid overlap.</target>
        </trans-unit>
        <trans-unit id="af6ed7ba3a77d9c9041d1f9f34a1c12b90a41d5b" translate="yes" xml:space="preserve">
          <source>.not</source>
          <target state="translated">.not</target>
        </trans-unit>
        <trans-unit id="37f06d3dd43811fb4a3a366255d459cfd648f809" translate="yes" xml:space="preserve">
          <source>.rejects</source>
          <target state="translated">.rejects</target>
        </trans-unit>
        <trans-unit id="3a41b0fffb37be03170b7fc364408f5627fb6783" translate="yes" xml:space="preserve">
          <source>.resolves</source>
          <target state="translated">.resolves</target>
        </trans-unit>
        <trans-unit id="676b70f0ba2473d03d5c38bd58a4c33f141c1881" translate="yes" xml:space="preserve">
          <source>.toBe()</source>
          <target state="translated">.toBe()</target>
        </trans-unit>
        <trans-unit id="32a2cc64ae6a3e2a930d047916b812fe4b5d0e88" translate="yes" xml:space="preserve">
          <source>.toBeCloseTo()</source>
          <target state="translated">.toBeCloseTo()</target>
        </trans-unit>
        <trans-unit id="99ce778367e3457801132fbd52692b493aa35f2b" translate="yes" xml:space="preserve">
          <source>.toBeDefined()</source>
          <target state="translated">.toBeDefined()</target>
        </trans-unit>
        <trans-unit id="9b3929ba1aa6dd0ddf943ca0e147dbc91d13488d" translate="yes" xml:space="preserve">
          <source>.toBeFalsy()</source>
          <target state="translated">.toBeFalsy()</target>
        </trans-unit>
        <trans-unit id="8d1c7e785d4737e92e5db59d84e589ec79a15f1a" translate="yes" xml:space="preserve">
          <source>.toBeGreaterThan()</source>
          <target state="translated">.toBeGreaterThan()</target>
        </trans-unit>
        <trans-unit id="f276b89d8cc696f904c15a937aa2c4f57049c9d8" translate="yes" xml:space="preserve">
          <source>.toBeGreaterThanOrEqual()</source>
          <target state="translated">.toBeGreaterThanOrEqual()</target>
        </trans-unit>
        <trans-unit id="6bff9db7ccc5307cb1baba71f20f8dcb5eca7313" translate="yes" xml:space="preserve">
          <source>.toBeInstanceOf()</source>
          <target state="translated">.toBeInstanceOf()</target>
        </trans-unit>
        <trans-unit id="647d1cf6ca2e0af2106268548794474115aea36d" translate="yes" xml:space="preserve">
          <source>.toBeLessThan()</source>
          <target state="translated">.toBeLessThan()</target>
        </trans-unit>
        <trans-unit id="ea2494b392db9dcab4645d97c83fd9a2182286e4" translate="yes" xml:space="preserve">
          <source>.toBeLessThanOrEqual()</source>
          <target state="translated">.toBeLessThanOrEqual()</target>
        </trans-unit>
        <trans-unit id="720a4c5d8244f39f9f666e702c0e3852b57afea2" translate="yes" xml:space="preserve">
          <source>.toBeNaN()</source>
          <target state="translated">.toBeNaN()</target>
        </trans-unit>
        <trans-unit id="f0c9793c8f304879d82d7089132a47ef6cfb8593" translate="yes" xml:space="preserve">
          <source>.toBeNull()</source>
          <target state="translated">.toBeNull()</target>
        </trans-unit>
        <trans-unit id="077ff246559a6d00501b8fa5b20b80ff03301608" translate="yes" xml:space="preserve">
          <source>.toBeTruthy()</source>
          <target state="translated">.toBeTruthy()</target>
        </trans-unit>
        <trans-unit id="98663990dec7535feda7d7a24ff1693d1049c82f" translate="yes" xml:space="preserve">
          <source>.toBeUndefined()</source>
          <target state="translated">.toBeUndefined()</target>
        </trans-unit>
        <trans-unit id="7d1504d2c8e2ced7a503f0d02d0ca0a94cd67568" translate="yes" xml:space="preserve">
          <source>.toContain()</source>
          <target state="translated">.toContain()</target>
        </trans-unit>
        <trans-unit id="4bcc79e6f40ce4c5625a5d71c2dbc2a433e04c9c" translate="yes" xml:space="preserve">
          <source>.toContainEqual()</source>
          <target state="translated">.toContainEqual()</target>
        </trans-unit>
        <trans-unit id="26decec7a3cac6d27508b590d0ba65718d5b2de4" translate="yes" xml:space="preserve">
          <source>.toEqual()</source>
          <target state="translated">.toEqual()</target>
        </trans-unit>
        <trans-unit id="4e3793133f260880cc150fb12b6d7f1c053f3550" translate="yes" xml:space="preserve">
          <source>.toHaveBeenCalled()</source>
          <target state="translated">.toHaveBeenCalled()</target>
        </trans-unit>
        <trans-unit id="00772fdde0f479a0db9548a093488dcfd5588cc9" translate="yes" xml:space="preserve">
          <source>.toHaveBeenCalledTimes()</source>
          <target state="translated">.toHaveBeenCalledTimes()</target>
        </trans-unit>
        <trans-unit id="1dfa8f19daae4c3dc83cbec00ad04f332c9915ae" translate="yes" xml:space="preserve">
          <source>.toHaveBeenCalledWith()</source>
          <target state="translated">.toHaveBeenCalledWith()</target>
        </trans-unit>
        <trans-unit id="5959332ef495a103a4ccdc29a0e15aa7a7565d05" translate="yes" xml:space="preserve">
          <source>.toHaveBeenLastCalledWith()</source>
          <target state="translated">.toHaveBeenLastCalledWith()</target>
        </trans-unit>
        <trans-unit id="a3a97daff76f81f78afb83c331fc23947a78f45c" translate="yes" xml:space="preserve">
          <source>.toHaveBeenNthCalledWith()</source>
          <target state="translated">.toHaveBeenNthCalledWith()</target>
        </trans-unit>
        <trans-unit id="0c161a4b9f0d771ccd327f65278e09178b507795" translate="yes" xml:space="preserve">
          <source>.toHaveLastReturnedWith()</source>
          <target state="translated">.toHaveLastReturnedWith()</target>
        </trans-unit>
        <trans-unit id="a0443d967f32f1308634aa976c0d469385693824" translate="yes" xml:space="preserve">
          <source>.toHaveLength()</source>
          <target state="translated">.toHaveLength()</target>
        </trans-unit>
        <trans-unit id="794f45b9cd4158e59c5c292424191e68bf89e18e" translate="yes" xml:space="preserve">
          <source>.toHaveNthReturnedWith()</source>
          <target state="translated">.toHaveNthReturnedWith()</target>
        </trans-unit>
        <trans-unit id="a6dd5320db9ee9d51d1c8e22c168ba712935f3bb" translate="yes" xml:space="preserve">
          <source>.toHaveProperty()</source>
          <target state="translated">.toHaveProperty()</target>
        </trans-unit>
        <trans-unit id="44f8374b7809b36963550595e06fff53b46f64bb" translate="yes" xml:space="preserve">
          <source>.toHaveReturned()</source>
          <target state="translated">.toHaveReturned()</target>
        </trans-unit>
        <trans-unit id="e3c3d3edd9ad715908bf398891fb02d0c3c4932a" translate="yes" xml:space="preserve">
          <source>.toHaveReturnedTimes()</source>
          <target state="translated">.toHaveReturnedTimes()</target>
        </trans-unit>
        <trans-unit id="a5111ab06a437a3308c64674fc8fd62826ee0969" translate="yes" xml:space="preserve">
          <source>.toHaveReturnedWith()</source>
          <target state="translated">.toHaveReturnedWith()</target>
        </trans-unit>
        <trans-unit id="2e70316fe3608fd8ec3c03f9f87028c2c8363a05" translate="yes" xml:space="preserve">
          <source>.toMatch()</source>
          <target state="translated">.toMatch()</target>
        </trans-unit>
        <trans-unit id="73905b27654bb05043f04e3456080771951db1fd" translate="yes" xml:space="preserve">
          <source>.toMatchInlineSnapshot()</source>
          <target state="translated">.toMatchInlineSnapshot()</target>
        </trans-unit>
        <trans-unit id="dd215f94d457250f89ee5c13cffb1d58a988815c" translate="yes" xml:space="preserve">
          <source>.toMatchObject()</source>
          <target state="translated">.toMatchObject()</target>
        </trans-unit>
        <trans-unit id="7f8b4f8d30db6de4b405874a76c6a2f72c9f3142" translate="yes" xml:space="preserve">
          <source>.toMatchSnapshot()</source>
          <target state="translated">.toMatchSnapshot()</target>
        </trans-unit>
        <trans-unit id="67a75a5640e37db5bf286c0733cf73807148ddcc" translate="yes" xml:space="preserve">
          <source>.toStrictEqual()</source>
          <target state="translated">.toStrictEqual()</target>
        </trans-unit>
        <trans-unit id="daf6eadfb4ea82a0e7b370d4eb7e4e557cfec7c3" translate="yes" xml:space="preserve">
          <source>.toThrow()</source>
          <target state="translated">.toThrow()</target>
        </trans-unit>
        <trans-unit id="821616a911f93e7076cfbb743c648b0dc07240e2" translate="yes" xml:space="preserve">
          <source>.toThrowErrorMatchingInlineSnapshot()</source>
          <target state="translated">.toThrowErrorMatchingInlineSnapshot()</target>
        </trans-unit>
        <trans-unit id="dfc790de4e060a8cb2c6a3f3d9107f894635d8e4" translate="yes" xml:space="preserve">
          <source>.toThrowErrorMatchingSnapshot()</source>
          <target state="translated">.toThrowErrorMatchingSnapshot()</target>
        </trans-unit>
        <trans-unit id="d02f00544c5410b45100d8c26dc869d32c374dae" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;describe.each(table)(name, fn, timeout)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad05971b070fbc37cf9c07f4fcefdbfe80d469c" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;test.each(table)(name, fn, timeout)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce2deb0fd00df7e1bc70232ca6e95f15b442ea2" translate="yes" xml:space="preserve">
          <source>1. Treat snapshots as code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3a6811ab29a636472dbcf19ebed735d5088990" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;describe.each`table`(name, fn, timeout)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d60d82552a2ba8086d2f9a363a55553cd0161d" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;test.each`table`(name, fn, timeout)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0759e7d1939c65b0a51804dcf5e0e9eff89e699a" translate="yes" xml:space="preserve">
          <source>2. Tests should be deterministic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4054a23d3f0fea28f4ad5c16a5e2746a51ebdac4" translate="yes" xml:space="preserve">
          <source>3. Use descriptive snapshot names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d3cdecff2c457d98abdf63eb1eed93ccea97ba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.albertgao.xyz/2017/05/24/how-to-test-expressjs-with-jest-and-supertest/&quot;&gt;How to test Express.js with Jest and Supertest&lt;/a&gt; by Albert Gao (&lt;a href=&quot;https://twitter.com/albertgao&quot;&gt;@albertgao&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df494206c7fb512291d9c26b280d086c8f68221" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://alexjoverm.github.io/series/Unit-Testing-Vue-js-Components-with-the-Official-Vue-Testing-Tools-and-Jest/&quot;&gt;Testing Vue.js components with Jest&lt;/a&gt; by Alex Jover Morales (&lt;a href=&quot;https://twitter.com/alexjoverm&quot;&gt;@alexjoverm&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56b908cf5de025f16168813fe23530da4086bf1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://engineering.talentpair.com/running-angularjs-tests-with-jest-49d0cc9c6d26&quot;&gt;Running AngularJS Tests with Jest&lt;/a&gt; by Ben Brandt (&lt;a href=&quot;https://twitter.com/benjaminbrandt&quot;&gt;@benjaminbrandt&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5396961ac6b2c5f21f3d0317ec9f09404d9af19" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/jest-community&quot;&gt;jest-community&lt;/a&gt; is a new GitHub organization for high quality Jest additions curated by Jest maintainers and collaborators. It already features some of our favorite projects, to name a few:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99bce60cd49efb888fea268162f85d4db8fc8b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;Jest DynamoDB&lt;/a&gt; provides all required configuration to run your tests using DynamoDB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b359adbc76ca4d01768ec6507a7cd0a41449b82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;Jest MongoDB&lt;/a&gt; provides all required configuration to run your tests using MongoDB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9813ff97e2bfab1d3620d9cd0c674d6c319235" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;Jest Puppeteer&lt;/a&gt; provides all required configuration to run your tests using Puppeteer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e5d6a58c8bec76b77a3d04abb1b2a26fc4087e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/@kentaromiura_the_js_guy/jest-for-all-episode-1-vue-js-d616bccbe186#.d573vrce2&quot;&gt;Jest for all: Episode 1 &amp;mdash; Vue.js&lt;/a&gt; by Cristian Carlesso (&lt;a href=&quot;https://twitter.com/kentaromiura&quot;&gt;@kentaromiura&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5742738a051dfb6af1d4fff2bcc31ff0ec9ba9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/aya-experience/testing-an-angularjs-app-with-jest-3029a613251&quot;&gt;Testing an AngularJS app with Jest&lt;/a&gt; by Matthieu Lux (&lt;a href=&quot;https://twitter.com/Swiip&quot;&gt;@Swiip&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8c0a5d3a823c18229e23ca4494e3567d0bcdc6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redux.js.org/recipes/writing-tests&quot;&gt;Writing Tests&lt;/a&gt; by Redux docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55111a72c4fd1cefa5bb8c3683ca9b7e0a70243d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://semaphoreci.com/community/tutorials/how-to-test-react-and-mobx-with-jest&quot;&gt;How to Test React and MobX with Jest&lt;/a&gt; by Will Stern (&lt;a href=&quot;https://twitter.com/willsterndev&quot;&gt;@willsterndev&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb86efcd4fb0536b2d852e06deaf03e53e7a7f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.gatsbyjs.org/docs/unit-testing/&quot;&gt;Unit Testing&lt;/a&gt; by GatsbyJS docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81eac7c1a1ce0cc4e092235c95a04493ca09f53" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.xfive.co/blog/testing-angular-faster-jest/&quot;&gt;Testing Angular faster with Jest&lt;/a&gt; by Michał Pierzchała (&lt;a href=&quot;https://twitter.com/thymikee&quot;&gt;@thymikee&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f07fb064a1ca3650efef1c76fcbb075693e99c1f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;troubleshooting&quot;&gt;Troubleshoot&lt;/a&gt; problems with Jest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="443213bdc808a3fc65945784503fb0ee5e83725f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;tutorial-react&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;tutorial-react-native&quot;&gt;React Native&lt;/a&gt; components are a good use case for snapshot testing. However, snapshots can capture any serializable value and should be used anytime the goal is testing whether the output is correct. The Jest repository contains many examples of testing the output of Jest itself, the output of Jest's assertion library as well as log messages from various parts of the Jest codebase. See an example of &lt;a href=&quot;https://github.com/facebook/jest/blob/master/e2e/__tests__/console.test.ts&quot;&gt;snapshotting CLI output&lt;/a&gt; in the Jest repo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a5ed3d96a7d19aaa272ea4066717b8d7f08ea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%#&lt;/code&gt; - Index of the test case.</source>
          <target state="translated">&lt;code&gt;%#&lt;/code&gt; - Index of the test case.</target>
        </trans-unit>
        <trans-unit id="99439ec715d56673a87763600a5604708e1c38d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%%&lt;/code&gt; - single percent sign ('%'). This does not consume an argument.</source>
          <target state="translated">&lt;code&gt;%%&lt;/code&gt; - single percent sign ('%'). This does not consume an argument.</target>
        </trans-unit>
        <trans-unit id="be58a859ecea37f16b1baf755a833c937911e03a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%d&lt;/code&gt;- Number.</source>
          <target state="translated">&lt;code&gt;%d&lt;/code&gt;- Number.</target>
        </trans-unit>
        <trans-unit id="0210f4fcea5c1914a2ac951e9e76cb6796c46080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%f&lt;/code&gt; - Floating point value.</source>
          <target state="translated">&lt;code&gt;%f&lt;/code&gt; - Floating point value.</target>
        </trans-unit>
        <trans-unit id="55ee086a73fac1a68641f364d883a401f6667b1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%i&lt;/code&gt; - Integer.</source>
          <target state="translated">&lt;code&gt;%i&lt;/code&gt; - Integer.</target>
        </trans-unit>
        <trans-unit id="e01cf6855d89e736222379d96cb8f8c24d6b9544" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%j&lt;/code&gt; - JSON.</source>
          <target state="translated">&lt;code&gt;%j&lt;/code&gt; - JSON.</target>
        </trans-unit>
        <trans-unit id="bab6bb51afc0fd48dceefb2aac9b600984e09b3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%o&lt;/code&gt; - Object.</source>
          <target state="translated">&lt;code&gt;%o&lt;/code&gt; - Object.</target>
        </trans-unit>
        <trans-unit id="3ae24f8fcf878ada51ee4c476c8d990172aa5ed3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%p&lt;/code&gt; - &lt;a href=&quot;https://www.npmjs.com/package/pretty-format&quot;&gt;pretty-format&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;%p&lt;/code&gt; - &lt;a href=&quot;https://www.npmjs.com/package/pretty-format&quot;&gt;pretty-format&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c6e26914b39d77aae13dc19308b1d95ba59e4ac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%s&lt;/code&gt;- String.</source>
          <target state="translated">&lt;code&gt;%s&lt;/code&gt;- String.</target>
        </trans-unit>
        <trans-unit id="6549287d9dfc46e5e451bf23de875efc1b0450ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;''&lt;/code&gt; if matcher was not called with a promise modifier</source>
          <target state="translated">&lt;code&gt;''&lt;/code&gt; if matcher was not called with a promise modifier</target>
        </trans-unit>
        <trans-unit id="1d41bf2fd44861b9c5446bf7dcb05135d69e1d25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'incomplete'&lt;/code&gt; - Indicates that the call has not yet completed. This occurs if you test the result from within the mock function itself, or from within a function that was called by the mock.</source>
          <target state="translated">&lt;code&gt;'incomplete'&lt;/code&gt; - Indicates that the call has not yet completed. This occurs if you test the result from within the mock function itself, or from within a function that was called by the mock.</target>
        </trans-unit>
        <trans-unit id="3fe7dd9e456ce9a56ae609395aa81b172994f38f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'rejects'&lt;/code&gt; if matcher was called with the promise &lt;code&gt;.rejects&lt;/code&gt; modifier</source>
          <target state="translated">&lt;code&gt;'rejects'&lt;/code&gt; if matcher was called with the promise &lt;code&gt;.rejects&lt;/code&gt; modifier</target>
        </trans-unit>
        <trans-unit id="e00498ab57db7b93c2f28b7b12b8f7e1c69000f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'resolves'&lt;/code&gt; if matcher was called with the promise &lt;code&gt;.resolves&lt;/code&gt; modifier</source>
          <target state="translated">&lt;code&gt;'resolves'&lt;/code&gt; if matcher was called with the promise &lt;code&gt;.resolves&lt;/code&gt; modifier</target>
        </trans-unit>
        <trans-unit id="adefff17f597de4d74805fd1199cf58fdab871d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'return'&lt;/code&gt; - Indicates that the call completed by returning normally.</source>
          <target state="translated">&lt;code&gt;'return'&lt;/code&gt; - Indicates that the call completed by returning normally.</target>
        </trans-unit>
        <trans-unit id="076c5e0b99835c5f259fd2816ec766e57cb2d86e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'throw'&lt;/code&gt; - Indicates that the call completed by throwing a value.</source>
          <target state="translated">&lt;code&gt;'throw'&lt;/code&gt; - Indicates that the call completed by throwing a value.</target>
        </trans-unit>
        <trans-unit id="95e4e052d6f73f13eb9f5bf76796d91d0771e5d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.mock&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;.mock&lt;/code&gt; property</target>
        </trans-unit>
        <trans-unit id="3243a3eefd59ed3b1ef0411f8d2f9ef7ab6b869c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.resolves&lt;/code&gt; / &lt;code&gt;.rejects&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.resolves&lt;/code&gt; / &lt;code&gt;.rejects&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7aab89721f62c7711b7a39834e73ed2a7fa36b40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.toBeNull()&lt;/code&gt; is the same as &lt;code&gt;.toBe(null)&lt;/code&gt; but the error messages are a bit nicer. So use &lt;code&gt;.toBeNull()&lt;/code&gt; when you want to check that something is null.</source>
          <target state="translated">&lt;code&gt;.toBeNull()&lt;/code&gt; is the same as &lt;code&gt;.toBe(null)&lt;/code&gt; but the error messages are a bit nicer. So use &lt;code&gt;.toBeNull()&lt;/code&gt; when you want to check that something is null.</target>
        </trans-unit>
        <trans-unit id="104f305e00b892ddcf1d06c035b10b5490d792af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;//&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; [string]</target>
        </trans-unit>
        <trans-unit id="f7ca0bd8979a7f74cc25cbae3dbe74989087d213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;always&lt;/code&gt;: always send a notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6c44f3653f92b2c1c2a5de58ace2813f45e746" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="022d50ac602b48aff9f8d8e67b52ebc38346cad4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;automock&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0783465e37770f804a3fa338742cb29285642410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bail&lt;/code&gt; [number | boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5edc8e7748215afb6eeb00b3979bb3727afd5bb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;beforeEach&lt;/code&gt; and &lt;code&gt;afterEach&lt;/code&gt; can handle asynchronous code in the same ways that &lt;a href=&quot;asynchronous&quot;&gt;tests can handle asynchronous code&lt;/a&gt; - they can either take a &lt;code&gt;done&lt;/code&gt; parameter or return a promise. For example, if &lt;code&gt;initializeCityDatabase()&lt;/code&gt; returned a promise that resolved when the database was initialized, we would want to return that promise:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa76bca50406a98255ef02e9f43968260d65f7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;browser&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c365dba5039284274be41ec97d6931d406d1c7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; (clears filter patterns)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a96c151e6639e8670e9bdbe30a8b6c06780e8a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheDirectory&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5729d52a372a388e905516712336cc35653473" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;change&lt;/code&gt;: send a notification when the status changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e923e514d0d8eba3a5d4f42d5c2bb45b0c5de03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clearMocks&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363b6e4c7928db931e518577b11324769a502b2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collectCoverage&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d5f07893a1fda7fc63a1840bbc82b25e18b917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collectCoverageFrom&lt;/code&gt; [array]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22dfb0112951b3b9a5c84109d6afdb9cd84b9777" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coverageDirectory&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90eaa41d832548eff8171bf51ba277dd76c6cade" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecb7be43881b3eeda0756f75c31493d74e428a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; seems to not have any effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15415f908cbcc6f834bd96ab5ea0dd1791a0e2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coverageReporters&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc39b0fdbc72c893cbb45f06a4c77dc964c9da51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coverageThreshold&lt;/code&gt; [object]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc66e291a919f7f83c445c247998df66d9ff548" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dependencyExtractor&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578ea51611cafa4df7fdc64d59c1dcb405fe8410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe(name, fn)&lt;/code&gt; creates a block that groups together several related tests. For example, if you have a &lt;code&gt;myBeverage&lt;/code&gt; object that is supposed to be delicious but not sour, you could test it with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a747ebf25a9f2fa370e23024faca41ba1a337dab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe.each&lt;/code&gt; is available with two APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a624922279c16d34d13a44532e2a44816d8022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe.only.each&lt;/code&gt; is available with two APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be072a39475c0433ea29c8a3f3e03e51b6441308" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe.skip.each&lt;/code&gt; is available with two APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bc66969f1fd3507a08fc8554e866f921a0340f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;displayName&lt;/code&gt; [string, object]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ae6ab4c9dd50d862bc15af0f07ad924c3ea872" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errorOnDeprecated&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16d7cc8c63e72f5826c1d66754d6907d67dd5b1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.any(constructor)&lt;/code&gt; matches anything that was created with the given constructor. You can use it inside &lt;code&gt;toEqual&lt;/code&gt; or &lt;code&gt;toBeCalledWith&lt;/code&gt; instead of a literal value. For example, if you want to check that a mock function is called with a number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b048d4335638b4d1ce30d9e4cea456559c9b724" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.anything()&lt;/code&gt; matches anything but &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can use it inside &lt;code&gt;toEqual&lt;/code&gt; or &lt;code&gt;toBeCalledWith&lt;/code&gt; instead of a literal value. For example, if you want to check that a mock function is called with a non-null argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07e62eaf69f9b58e4a6fd2e376c27adf3aa7352" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.arrayContaining(array)&lt;/code&gt; matches a received array which contains all of the elements in the expected array. That is, the expected array is a &lt;strong&gt;subset&lt;/strong&gt; of the received array. Therefore, it matches a received array which contains elements that are &lt;strong&gt;not&lt;/strong&gt; in the expected array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad1cdf0d05ab1b5153ed2dc2199661f84a10214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.assertions(number)&lt;/code&gt; verifies that a certain number of assertions are called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7c7a571b63f72abaf51ebbecf601d2e3857d28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.extend&lt;/code&gt; also supports async matchers. Async matchers return a Promise so you will need to await the returned value. Let's use an example matcher to illustrate the usage of them. We are going to implement a matcher called &lt;code&gt;toBeDivisibleByExternalValue&lt;/code&gt;, where the divisible number is going to be pulled from an external source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b19b7b55164bf0bc4a0774f7d5a9823dfb8d66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.hasAssertions()&lt;/code&gt; verifies that at least one assertion is called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ec136e4c871d2955ba2a5ffdb1ec1f46d7ec62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.arrayContaining(array)&lt;/code&gt; matches a received array which does not contain all of the elements in the expected array. That is, the expected array &lt;strong&gt;is not a subset&lt;/strong&gt; of the received array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6547e93ef4972ca16b59d2de583bdf5f8e164aa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.objectContaining(object)&lt;/code&gt; matches any received object that does not recursively match the expected properties. That is, the expected object &lt;strong&gt;is not a subset&lt;/strong&gt; of the received object. Therefore, it matches a received object which contains properties that are &lt;strong&gt;not&lt;/strong&gt; in the expected object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a42e0113413fc40756feea32923e172a36b6b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.stringContaining(string)&lt;/code&gt; matches the received value if it is not a string or if it is a string that does not contain the exact expected string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce80cb6e4909d7c37e766e9b73b0bb99a177ade6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.stringMatching(string | regexp)&lt;/code&gt; matches the received value if it is not a string or if it is a string that does not match the expected string or regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875e89312fa291d9bbe18c260d1ae180219d97dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.objectContaining(object)&lt;/code&gt; matches any received object that recursively matches the expected properties. That is, the expected object is a &lt;strong&gt;subset&lt;/strong&gt; of the received object. Therefore, it matches a received object which contains properties that &lt;strong&gt;are present&lt;/strong&gt; in the expected object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873bd2740b6f065fa8199240ea0887a8832c981b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.stringContaining(string)&lt;/code&gt; matches the received value if it is a string that contains the exact expected string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b225d15ea2692d7f596ad71d130a9431391d603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.stringMatching(string | regexp)&lt;/code&gt; matches the received value if it is a string that matches the expected string or regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9601c02013ee7ce5f87da30784a1f36318a5dbff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extraGlobals&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0eae8733557670105e5264b5a44c22eff4ea60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;failure-change&lt;/code&gt;: send a notification when tests fail or once when it passes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731d19bd21f0367438f616985a2ff9bb56ea0ab1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;failure&lt;/code&gt;: send a notification when tests fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3447be7228fe480161197c25ed455c836a34b766" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findRepos&lt;/code&gt; returns a promise that resolves to a set of repositories contained in the specified path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9914d2c07c082d0ed34f77e91705dbe4bbc7ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the suite of tests to be ran, this is the function that will receive the parameters in each row as function arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298953e98c7eb6b4e3d57c99810d04acf9d73464" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the suite of tests to be ran, this is the function that will receive the test data object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f031349e7b8aa21079964750e0087a33dee28d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the test to be ran, this is the function that will receive the parameters in each row as function arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cbe17bb99201c9dc1c9f5c72dd39428e462a33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the test to be ran, this is the function that will receive the test data object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2604eaf97f1d7be032bcf96b602a694fcf53fdf5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceCoverageMatch&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a16227a95685b1c6861bbb5288faab8f371516cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getChangedFilesForRoots&lt;/code&gt; returns a promise that resolves to an object with the changed files and repos.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6948e0922a81f820a7782be1ef9bc1512a6b41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globalConfig&lt;/code&gt;: A representation of Jest's current global configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff896286fbcbc481378aeb8259b08bea7f02d0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globalSetup&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadaa8f683b3b302e2e7f420e35e198d8dd3816e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globalTeardown&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231b0edd70628d81723e0ee3029c6b4ff4d9110c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globals&lt;/code&gt; [object]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b098b2d9da9708ff9da0d38f84a27a261ab078ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasDeprecationWarnings&lt;/code&gt;, a boolean indicating whether the submitted configuration has deprecation warnings,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db064ee6440350f7fb0be817c2c86fd657c31ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; (updates non-matching snapshots interactively)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7667493d35310459ba4d865785385e0fa44f0893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isValid&lt;/code&gt;, a boolean indicating whether the configuration is correct or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63029f3c42dcfdbd97e5adf642c885fad142d9ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jest.isolateModules(fn)&lt;/code&gt; goes a step further than &lt;code&gt;jest.resetModules()&lt;/code&gt; and creates a sandbox registry for the modules that are loaded inside the callback function. This is useful to isolate specific modules for every test so that local module state doesn't conflict between tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d068ec96dd088b722efa247006c3a09b717017e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; takes a &lt;strong&gt;module factory&lt;/strong&gt; argument. A module factory is a function that returns the mock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90135d2aaad054e086325b1d57dde7c03baf6197" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt;: Modifies the plugin key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e41eef750008fd3d9034f9f24ad5c5b838e31f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxConcurrency&lt;/code&gt; [number]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71100c6b326e78ca130e91a087d319bbd82f524" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mockImplementation&lt;/code&gt; can also be used to mock class constructors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ac877b649f4b1baf1b0db360ca8a145e29d584" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;moduleDirectories&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a817d22cd4c1efa6fa7dba67c371451f4f6a3e40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;moduleFileExtensions&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4dbb493ef5de10d974140f3a1a68b88e828b841" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;moduleNameMapper&lt;/code&gt; [object&amp;lt;string, string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c30cf8163e2afdc999bcd7e41dcbb5851bb1e9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modulePathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5f993e08e79688971f5c75776fe7729160b62a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modulePaths&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3482e861b97dc8c4ad438b0fde5c9836aa35e26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c07e542178b2102b5826b97ac09964d210344a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6decfba5457add1abca3f7eefd904378908c40d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test suite, use &lt;code&gt;$variable&lt;/code&gt; to inject test data into the suite title from the tagged template expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efc7da2c3955c0b1cbac2ceaa166cfe2e82166b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1df03cf669a34600d3198e548795a6077ea6b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test, use &lt;code&gt;$variable&lt;/code&gt; to inject test data into the test title from the tagged template expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ed76fb5c443ad0c959e448b56418dc71e556c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6684ce050bf906e6380898754ff7da6938b703c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notifyMode&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd057db2f09c38e1e5b40068f877b8183233331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; (test filename pattern)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0c00c34cdc9a83d325ba92d761bc183ce4449f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preset&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f06be9be723c01ad4d3dbe06ff030523f7706bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prettierPath&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4505df26dc3d3a9cb7331fc60b4a4af4b244e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;projects: Array&amp;lt;config: ProjectConfig, testPaths: Array&amp;lt;string&amp;gt;&lt;/code&gt;: Includes all the test paths that Jest is watching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e98a5e7e066d6b8bfb3e0e2aa91fa1576bb9d6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;projects&lt;/code&gt; [array&amp;lt;string | ProjectConfig&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3c05f3ce8e21d04bb61eb33e6e4c93ba2018c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prompt&lt;/code&gt;: Allows user to customize the text in the plugin prompt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306725cc0ea4676fa203b49def3e6bf0647bc9e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; (quits)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21cf61c19fe87ba0d4595c865ab1260b42f36bbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-native&lt;/code&gt; ships with a Jest preset, so the &lt;code&gt;jest.preset&lt;/code&gt; field of your &lt;code&gt;package.json&lt;/code&gt; should point to &lt;code&gt;react-native&lt;/code&gt;. The preset is a node environment that mimics the environment of a React Native app. Because it doesn't load any DOM or browser APIs, it greatly improves Jest's startup time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8b23880a197c5f759c183cce18fb93d6fa1266" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reporters&lt;/code&gt; [array&amp;lt;moduleName | [moduleName, options]&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453d841d74b238a64faf3df95c585d289aa91e70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resetMocks&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac59f04d9734d7de733a2f890c1829d2243af0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resetModules&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82390a2391bf5fe68298d3c71d952e9f3396ffd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolver&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d7428212c791b1c98fa85a623f2916661a109d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;restoreMocks&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="116364b62ec3e96c831f81af2e20649d42921165" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rootDir&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b69cb276d844fde73a287c56443b24c85290f772" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roots&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31ac4f04b533e37944cd96caa5c49c10dc74438" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;runner&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b042371a36ef0f59de8c40ae970a1ae12fe9cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serialize&lt;/code&gt; is a function that serializes a value using existing plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7906f5769192dc093bd74f15955d14c8f44353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setupFiles&lt;/code&gt; [array]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad182506adf7a1eda3a2fe924a5d6b3ce10e38db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setupFilesAfterEnv&lt;/code&gt; [array]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6822a7af0f792c1be02fee0e6557b5f9aa6aa50d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;snapshotResolver&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020e33ceb836b81269226d47390ae8d910dd3d3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;snapshotSerializers&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba6dc074f7173c4e5c921c96d6172ca341c31c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success-change&lt;/code&gt;: send a notification when tests pass or once when it fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6809288cd383ca526de3a95e82dc40029d2ea62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt;: send a notification when tests pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4992aa1211cf11eace0fd6194105fe6e748c14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; (test name pattern)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c76e7cef2f994e9bc4b2ffa8fc15c6a863909e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table&lt;/code&gt;: &lt;code&gt;Array&lt;/code&gt; of Arrays with the arguments that are passed into the &lt;code&gt;fn&lt;/code&gt; for each row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317ad841253c3821eea1c4c55994b13ecd8b83d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table&lt;/code&gt;: &lt;code&gt;Array&lt;/code&gt; of Arrays with the arguments that are passed into the test &lt;code&gt;fn&lt;/code&gt; for each row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78df167d8e2f5e6ab08bd9f9210c72a24c886744" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table&lt;/code&gt;: &lt;code&gt;Tagged Template Literal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2da762274f49442e7234edf6edec01553d27cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.each&lt;/code&gt; is available with two APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee264ff7856e51845623e3380548e788bd1f445" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.only.each&lt;/code&gt; is available with two APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3170d96d60bef9c8c8d61879742230e8abe3b3cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.skip.each&lt;/code&gt; is available with two APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221510c066b929b735e5b28457b54416069c92c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testEnvironment&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44ab06de94eab7f0f3caa84b84945368e2009db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testEnvironmentOptions&lt;/code&gt; [Object]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d7ac195113b99da222c32b46f9f8233407fc14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testMatch&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d243b3891f943423546e59235dcdd8d976817d17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testPathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff12f0b18e5c1f64dc7329625443fae51cefdfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testRegex&lt;/code&gt; [string | array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17522f05ab6d628a3f251e9b900e451c21411a8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testResultsProcessor&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b73f8cad03992f278bb6a0f26575821f4b0243" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testRunner&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d21b02e2144b96e6faf94901f49db32825d01c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testSequencer&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749944ba3e96affa2798b2be0c8f9bdc7c202c07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testURL&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6c63d8dee4860bbe8b897df46edc678e1919d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timers&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a070639a8870b012e0b8c57d45e65d109ab4512" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBe&lt;/code&gt; uses &lt;code&gt;Object.is&lt;/code&gt; to test exact equality. If you want to check the value of an object, use &lt;code&gt;toEqual&lt;/code&gt; instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6b12ce5ef3f1a643ddde1103fc34b4841b2288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeDefined&lt;/code&gt; is the opposite of &lt;code&gt;toBeUndefined&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889cb4e9583e9ce69de99a59a883724a6a884c9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeFalsy&lt;/code&gt; matches anything that an &lt;code&gt;if&lt;/code&gt; statement treats as false</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5324f092772853a6ea4dd06b013577b9f5e80b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeNull&lt;/code&gt; matches only &lt;code&gt;null&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3405b1dad40d610da009d8481e79e69e967627b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeTruthy&lt;/code&gt; matches anything that an &lt;code&gt;if&lt;/code&gt; statement treats as true</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f24f9d6f2d8651c7998359500de6605bc512b83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeUndefined&lt;/code&gt; matches only &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388131813185919d7c4b9b7ce2e366b3f5c34296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toEqual&lt;/code&gt; recursively checks every field of an object or array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f97095c42ff3460af22106bcfc6894981843e89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transform&lt;/code&gt; [object&amp;lt;string, pathToTransformer | [pathToTransformer, object]&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32e2b6dc461e4c5c6a8c96613f67aca04ca902f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transformIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530e289551d0cb4aa78691c9e846cb8a050d78b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;u&lt;/code&gt; (updates all non-matching snapshots)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d05fea48435f8bb30fa51c665fb5ad81d02bcfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unmockedModulePathPatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022b56004e7d1552105c625dc749cbbcb0d70f49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updateConfigAndRun&lt;/code&gt;: Allows you to trigger a test run while the interactive plugin is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7555c9da609a937d25697703fb3b49efefa9685b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verbose&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add45525d19083f684e544eb3205026fe6f9e169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;w&lt;/code&gt; (displays watch mode usage / available actions)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df63f3efa68ef5278ebaa0d9bd8fe291d6f1adce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;watchPathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95c27dc635388fdb16992516dd7331adc390021" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;watchPlugins&lt;/code&gt; [array&amp;lt;string | [string, Object]&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49a0c0fce1f34eeb9dd0214fd85644975b89abf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note It is recommended to use &lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; instead. The &lt;code&gt;jest.mock&lt;/code&gt; API's second argument is a module factory instead of the expected exported module object.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddbe6c8d77331269086ec95d5b210111e1b5ebb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that using &lt;code&gt;'&amp;lt;rootDir&amp;gt;'&lt;/code&gt; as a string token in any other path-based config settings will refer back to this value. So, for example, if you want your &lt;a href=&quot;#setupfiles-array&quot;&gt;&lt;code&gt;setupFiles&lt;/code&gt;&lt;/a&gt; config entry to point at the &lt;code&gt;env-setup.js&lt;/code&gt; file at the root of your project, you could set its value to &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/env-setup.js&quot;]&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3245e4c0c525edd55a1fcdd702374cc73c464f5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: &lt;code&gt;jest.fn(implementation)&lt;/code&gt; is a shorthand for &lt;code&gt;jest.fn().mockImplementation(implementation)&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b80413aed034e693fba82c8e6ba876def35e50" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: &lt;code&gt;setupTestFrameworkScriptFile&lt;/code&gt; is deprecated in favor of &lt;code&gt;setupFilesAfterEnv&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3469d99eb365107c2b5a8486b65ceb080d7309e1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: &lt;code&gt;testRegex&lt;/code&gt; will try to detect test files using the &lt;strong&gt;absolute file path&lt;/strong&gt; therefore having a folder with name that match it will run all the files as tests&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3dea36c338e1ec0685907e97bd1e080d581b098" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: A global setup module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa556e4ca5fc57d212e06cf6bbf0fe286b5fbdd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: A global teardown module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02c6dd644e67a3e18203bbf480809bbd1604476" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Any global variables that are defined through &lt;code&gt;globalSetup&lt;/code&gt; can only be read in &lt;code&gt;globalTeardown&lt;/code&gt;. You cannot retrieve globals defined here in your test suites.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72424c7302fd6031f30bf655f1399a19b49aca1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: By default, &lt;code&gt;jest.spyOn&lt;/code&gt; also calls the &lt;strong&gt;spied&lt;/strong&gt; method. This is different behavior from most other test libraries. If you want to overwrite the original function, you can use &lt;code&gt;jest.spyOn(object, methodName).mockImplementation(() =&amp;gt; customImplementation)&lt;/code&gt; or &lt;code&gt;object[methodName] = jest.fn(() =&amp;gt; customImplementation);&lt;/code&gt;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff92012e564f8eaffa118d20c50c70351da45fb1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: By default, &lt;code&gt;roots&lt;/code&gt; has a single entry &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; but there are cases where you may want to have multiple roots within one project, for example &lt;code&gt;roots: [&quot;&amp;lt;rootDir&amp;gt;/src/&quot;, &quot;&amp;lt;rootDir&amp;gt;/tests/&quot;]&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654f3a05466fc139fdbd676423da234eaeeb606b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: CLI options take precedence over values from the &lt;a href=&quot;configuration&quot;&gt;Configuration&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc547a1465a2bedec561a4ee7304735175d4563a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Core modules, like &lt;code&gt;fs&lt;/code&gt;, are not mocked by default. They can be mocked explicitly, like &lt;code&gt;jest.mock('fs')&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88fb518a69761332477b8752972bb36e3b77eb0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: If you are upgrading your react-native application and previously used the &lt;code&gt;jest-react-native&lt;/code&gt; preset, remove the dependency from your &lt;code&gt;package.json&lt;/code&gt; file and change the preset to &lt;code&gt;react-native&lt;/code&gt; instead.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0830714d92959a808d52247893384954d5e59fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: If you provide module name without boundaries &lt;code&gt;^$&lt;/code&gt; it may cause hard to spot errors. E.g. &lt;code&gt;relay&lt;/code&gt; will replace all modules which contain &lt;code&gt;relay&lt;/code&gt; as a substring in its name: &lt;code&gt;relay&lt;/code&gt;, &lt;code&gt;react-relay&lt;/code&gt; and &lt;code&gt;graphql-relay&lt;/code&gt; will all be pointed to your stub.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f81422258f7a098cd45faf5ef4bdd43a45a63cd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: If you want to set the timeout for all test files, a good place to do this is in &lt;code&gt;setupFilesAfterEnv&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4dc9d7861274ab2e62663a272189579222ed51" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Jest comes with JSDOM@11 by default. Due to JSDOM 12 and newer dropping support for Node 6, Jest is unable to upgrade for the time being. However, you can install a custom &lt;code&gt;testEnvironment&lt;/code&gt; with whichever version of JSDOM you want. E.g. &lt;a href=&quot;https://www.npmjs.com/package/jest-environment-jsdom-thirteen&quot;&gt;jest-environment-jsdom-thirteen&lt;/a&gt;, which has JSDOM@13.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18cfaa133eaa4a08198b5a6bdaede6aa76594392" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Node modules are automatically mocked when you have a manual mock in place (e.g.: &lt;code&gt;__mocks__/lodash.js&lt;/code&gt;). More info &lt;a href=&quot;manual-mocks#mocking-node-modules&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b37680e518c9562d1b20b238b957e0975b25f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Setting this option overwrites the default values. Add &lt;code&gt;&quot;text&quot;&lt;/code&gt; or &lt;code&gt;&quot;text-summary&quot;&lt;/code&gt; to see a coverage summary in the console output.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5d7a04d9f60617951367c692c674f878b4d3ce" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: TestEnvironment is sandboxed. Each test suite will trigger setup/teardown in their own TestEnvironment.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18c919f8dac5a6c8256d9066dc763fe50b700dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The &lt;code&gt;runner&lt;/code&gt; property value can omit the &lt;code&gt;jest-runner-&lt;/code&gt; prefix of the package name.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf7dcc966f94fef3966960384230930aced5aa8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The default regex matching works fine on small runs, but becomes slow if provided with multiple patterns and/or against a lot of tests. This option replaces the regex matching logic and by that optimizes the time it takes Jest to filter specific test files&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa9163fcbea16af564621dc70234283c02d3dc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The default timeout interval is 5 seconds if this method is not called.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63787225224750cba830a505303efd48b28af5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The regex is matched against the full name, which is a combination of the test name and all its surrounding describe blocks.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2b5593cd2040bc5dc88584b808f0f16c4ca911" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The same caveat concerning transformation of &lt;code&gt;node_modules&lt;/code&gt; as for &lt;code&gt;globalSetup&lt;/code&gt; applies to &lt;code&gt;globalTeardown&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de8c744892d1e80ade401b930bb5ff3026cf2c7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The values in the &lt;code&gt;watchPlugins&lt;/code&gt; property value can omit the &lt;code&gt;jest-watch-&lt;/code&gt; prefix of the package name.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5ef76a1f1ec3f0291cffbabb3da084f7d88dec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This option requires &lt;code&gt;collectCoverage&lt;/code&gt; to be set to true or Jest to be invoked with &lt;code&gt;--coverage&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47d1171d233bfb1c984686159fc340c7de69fc8f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: When using multi project runner, it's recommended to add a &lt;code&gt;displayName&lt;/code&gt; for each project. This will show the &lt;code&gt;displayName&lt;/code&gt; of a project next to its tests.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238890f1d64dab554fbd8e7a47a71c12a5527b7a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: While &lt;code&gt;rootDir&lt;/code&gt; is mostly used as a token to be re-used in other configuration options, &lt;code&gt;roots&lt;/code&gt; is used by the internals of Jest to locate &lt;strong&gt;test files and source files&lt;/strong&gt;. This applies also when searching for manual mocks for modules from &lt;code&gt;node_modules&lt;/code&gt; (&lt;code&gt;__mocks__&lt;/code&gt; will need to live in one of the &lt;code&gt;roots&lt;/code&gt;).&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad471e5c15682503858f775c8abc45c5311d043" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: While code transformation is applied to the linked setup-file, Jest will &lt;strong&gt;not&lt;/strong&gt; transform any code in &lt;code&gt;node_modules&lt;/code&gt;. This is due to the need to load the actual transformers (e.g. &lt;code&gt;babel&lt;/code&gt; or &lt;code&gt;typescript&lt;/code&gt;) to perform transformation.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418af2dac0b05fa2cb9f81b3f930b355f006be8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: a transformer is only run once per file unless the file has changed. During development of a transformer it can be useful to run Jest with &lt;code&gt;--no-cache&lt;/code&gt; to frequently &lt;a href=&quot;troubleshooting#caching-issues&quot;&gt;delete Jest's cache&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482df035eced9bdb0040d455527831161176059c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: if you are using babel-jest with additional code preprocessors, you have to explicitly define babel-jest as a transformer for your JavaScript code to map &lt;code&gt;.js&lt;/code&gt; files to the babel-jest module.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987bdba952341368e9fdda0bef0beeff5ba6fefd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: if you are using the &lt;code&gt;babel-jest&lt;/code&gt; transformer and want to use an additional code preprocessor, keep in mind that when &quot;transform&quot; is overwritten in any way the &lt;code&gt;babel-jest&lt;/code&gt; is not loaded automatically anymore. If you want to use it to compile JavaScript code it has to be explicitly defined. See &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/babel-jest#setup&quot;&gt;babel-jest plugin&lt;/a&gt;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0ca3af28debded1b6575b80dc6e1d40989ed7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: this method was previously called &lt;code&gt;autoMockOff&lt;/code&gt;. When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;disableAutomock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use &lt;code&gt;autoMockOff&lt;/code&gt; if you want to explicitly avoid this behavior.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db84e7f21a1dc5ea39ab8f33265d09f707ee968c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: this method was previously called &lt;code&gt;autoMockOn&lt;/code&gt;. When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;enableAutomock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use &lt;code&gt;autoMockOn&lt;/code&gt; if you want to explicitly avoid this behavior.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7299bad6f178500fdc51abcc8e1569c344960ac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This means when you are using &lt;code&gt;test.each&lt;/code&gt; you cannot set the table asynchronously within a &lt;code&gt;beforeEach&lt;/code&gt; / &lt;code&gt;beforeAll&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241f4f76ffa23db053fa98e7e031ed5504849944" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt; If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. &lt;code&gt;[1, 2, 3] -&amp;gt; [[1], [2], [3]]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4754ed111a2e95c412ef07bc2c997fbd065c98bd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: If you supply a test callback function then the &lt;code&gt;test.todo&lt;/code&gt; will throw an error. If you have already implemented the test and it is broken and you do not want it to run, then use &lt;code&gt;test.skip&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729bd471822307d2a8eeaa5067f5939172676b34" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: In TypeScript, when using &lt;code&gt;@types/jest&lt;/code&gt; for example, you can declare the new &lt;code&gt;toBeWithinRange&lt;/code&gt; matcher like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47e6352c36ff3c98347b31a0de45d69527492e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note: Arrow functions won't work&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bce92dff88fcb38cb2ef321db1576b644934c39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And you're good to go!&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f47b7739e2f44e81da3d675dbe29d4cd4cfbea9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Babel 6 support&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d549a077eab38cced620afe6afdb993c9ceab815" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Making your Babel config jest-aware&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3c3de6e563d40a11c1426be3aa604177c1e48e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If the key for your plugin already exists as a default key, your plugin will override that key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77fe3aedc23c7d8702924c934dd835e094300fe6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you do call &lt;code&gt;updateConfigAndRun&lt;/code&gt;, your &lt;code&gt;run&lt;/code&gt; method should not resolve to a truthy value, as that would trigger a double-run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f90b799d6842bd0a0a8b24f41ee816215aadab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The ideal configuration for Babel will depend on your project.&lt;/strong&gt; See &lt;a href=&quot;https://babeljs.io/docs/en/&quot;&gt;Babel's docs&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce668cf7d663ed9bc164df218d8d07075d83d288" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Importing a module in a setup file (as specified by &lt;code&gt;setupTestFrameworkScriptFile&lt;/code&gt;) will prevent mocking for the module in question, as well as all the modules that it imports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e782c9c810486eccfdccdb83eabb6b178a1382e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You just successfully wrote your first test using Jest!&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0bb22c03cbc1ff18563b0958776167824861c6" translate="yes" xml:space="preserve">
          <source>A boolean to let you know this matcher was called with an &lt;code&gt;expand&lt;/code&gt; option. When Jest is called with the &lt;code&gt;--expand&lt;/code&gt; flag, &lt;code&gt;this.expand&lt;/code&gt; can be used to determine if Jest is expected to show full diffs and errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012dbb44ad2f6ca0c20c7b97c1ddcb94d414c9f2" translate="yes" xml:space="preserve">
          <source>A boolean to let you know this matcher was called with the negated &lt;code&gt;.not&lt;/code&gt; modifier allowing you to display a clear and correct matcher hint (see example code).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af490ebca4384b8349fd5f9297146f2aec7a3fc0" translate="yes" xml:space="preserve">
          <source>A glob pattern relative to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b7d8c7a67b8a17e4270a68f699bf890194473c" translate="yes" xml:space="preserve">
          <source>A limitation with the factory parameter is that, since calls to &lt;code&gt;jest.mock()&lt;/code&gt; are hoisted to the top of the file, it's not possible to first define a variable and then use it in the factory. An exception is made for variables that start with the word 'mock'. It's up to you to guarantee that they will be initialized on time! For example, the following will throw an out-of-scope error due to the use of 'fake' instead of 'mock' in the variable declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38da5fb413d73285571b89440d31882e9fc2da6" translate="yes" xml:space="preserve">
          <source>A list of paths to directories that Jest should use to search for files in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfcb41fe8954fc025d854be9b9598a2ec86464ce" translate="yes" xml:space="preserve">
          <source>A list of paths to modules that run some code to configure or set up the testing environment. Each setupFile will be run once per test file. Since every test runs in its own environment, these scripts will be executed in the testing environment immediately before executing the test code itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e1bd291245533c3461bfdd8ed955a870554cea" translate="yes" xml:space="preserve">
          <source>A list of paths to modules that run some code to configure or set up the testing framework before each test. Since &lt;a href=&quot;#setupfiles-array&quot;&gt;&lt;code&gt;setupFiles&lt;/code&gt;&lt;/a&gt; executes before the test framework is installed in the environment, this script file presents you the opportunity of running some code immediately after the test framework has been installed in the environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418f7a1fe2ae7327be6076c7526644e5f6102913" translate="yes" xml:space="preserve">
          <source>A list of paths to snapshot serializer modules Jest should use for snapshot testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a46db07aaab9152f5a9b72c5970e6d46fe37d14" translate="yes" xml:space="preserve">
          <source>A list of reporter names that Jest uses when writing coverage reports. Any &lt;a href=&quot;https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports/lib&quot;&gt;istanbul reporter&lt;/a&gt; can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10fd310121e376e1ef1248ca973cafa088db8588" translate="yes" xml:space="preserve">
          <source>A map from regular expressions to module names that allow to stub out resources, like images or styles with a single module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7d829b1f4fd705d3b5320bfde131a522e2ecc3" translate="yes" xml:space="preserve">
          <source>A map from regular expressions to paths to transformers. A transformer is a module that provides a synchronous function for transforming source files. For example, if you wanted to be able to use a new language feature in your modules or tests that isn't yet supported by node, you might plug in one of many compilers that compile a future version of JavaScript to a current one. Example: see the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/typescript/package.json#L16&quot;&gt;examples/typescript&lt;/a&gt; example or the &lt;a href=&quot;webpack&quot;&gt;webpack tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ea19c50da9069cc4d49aa47baff8528c53ac76" translate="yes" xml:space="preserve">
          <source>A new object will be created each time the mock constructor function is called during tests. To spy on method calls in all of these objects, we populate &lt;code&gt;playSoundFile&lt;/code&gt; with another mock function, and store a reference to that same mock function in our test file, so it's available during tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160f997798a9fad1ea7cbbac49992e492f385217" translate="yes" xml:space="preserve">
          <source>A number limiting the number of tests that are allowed to run at the same time when using &lt;code&gt;test.concurrent&lt;/code&gt;. Any test above this limit will be queued and executed once a slot is released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36dc2aec80d27ca5f391ce3fab1f19651dbe2e41" translate="yes" xml:space="preserve">
          <source>A preset that is used as a base for Jest's configuration. A preset should point to an npm module that has a &lt;code&gt;jest-preset.json&lt;/code&gt; or &lt;code&gt;jest-preset.js&lt;/code&gt; file at the root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371782ecc77ce4aff2f7102c108e974456414ab4" translate="yes" xml:space="preserve">
          <source>A regexp pattern string that is matched against all tests paths before executing the test. On Windows, you will need to use &lt;code&gt;/&lt;/code&gt; as a path separator or escape &lt;code&gt;\&lt;/code&gt; as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="771c72cf637d4dc2b4dcc0ad878cbe45a19120be" translate="yes" xml:space="preserve">
          <source>A set of global variables that need to be available in all test environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9f21925e50fbc4c20514cc0b67d91ec78b66ca" translate="yes" xml:space="preserve">
          <source>A similar approach can be taken when it comes to testing your React components. Instead of rendering the graphical UI, which would require building the entire app, you can use a test renderer to quickly generate a serializable value for your React tree. Consider this &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/link.react.test.js&quot;&gt;example test&lt;/a&gt; for a &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/Link.react.js&quot;&gt;Link component&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3f3cc749a42e125fb041eeb2151de773021c2b" translate="yes" xml:space="preserve">
          <source>A string allowing you to display a clear and correct matcher hint:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b045dcedc246b83978bc16fd0119acaf1bb3450" translate="yes" xml:space="preserve">
          <source>A typical snapshot test case for a mobile app renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a27227dfd567fa1e14aded42955e64a1211e71" translate="yes" xml:space="preserve">
          <source>A webpack example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="4a8b7c1d861ff3818c82461eaba792c636764ff9" translate="yes" xml:space="preserve">
          <source>Accepts a function that should be used as the implementation of the mock. The mock itself will still record all calls that go into and instances that come from itself &amp;ndash; the only difference is that the implementation will also be executed when the mock is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179d3db7494b4a55ec9382c56b083999dab4097c" translate="yes" xml:space="preserve">
          <source>Accepts a function that will be used as an implementation of the mock for one call to the mocked function. Can be chained so that multiple function calls produce different results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e5417eb3ede5aa3146561fc2e7f28ecffcd802" translate="yes" xml:space="preserve">
          <source>Accepts a string to use in test result output in place of &quot;jest.fn()&quot; to indicate which mock function is being referenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5deee23f2f4af004e724d36935577b403688324b" translate="yes" xml:space="preserve">
          <source>Accepts a value that will be returned for one call to the mock function. Can be chained so that successive calls to the mock function return different values. When there are no more &lt;code&gt;mockReturnValueOnce&lt;/code&gt; values to use, calls will return a value specified by &lt;code&gt;mockReturnValue&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2e03d6231e5e5d597041e1a89580d10a7c89d6" translate="yes" xml:space="preserve">
          <source>Accepts a value that will be returned whenever the mock function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627fd999fe60eb1e9fa61ee59d201b42906b203a" translate="yes" xml:space="preserve">
          <source>Activates notifications for test results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b26cac2f5cd92c194eaf6b35f2ccfb8b632ce9" translate="yes" xml:space="preserve">
          <source>Activates notifications for test results. Good for when you don't want your consciousness to be able to focus on anything except JavaScript testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b4d9faf83e823777e17d32c35a1ca5f152a2f8" translate="yes" xml:space="preserve">
          <source>Add the following section to your &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a19c94e2b8b3963d8f7c38fd24982dd6310852" translate="yes" xml:space="preserve">
          <source>Additional Configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d97a763f6b6d3194d818e5f34a2dd68b20b1a98" translate="yes" xml:space="preserve">
          <source>Additionally, custom reporters can be configured by passing an &lt;code&gt;options&lt;/code&gt; object as a second argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f5d5d810fd868ec5f1446605cf43a303b38e7d" translate="yes" xml:space="preserve">
          <source>Additionally, you can substitute captured regex groups using numbered backreferences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12f0e8115380c12166066c9e4f273d00f4c44d6" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;location&lt;/code&gt; field to test results. Useful if you want to report the location of a test in a reporter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a3d37ab930375cdcd79b34d3b10e75da31c499" translate="yes" xml:space="preserve">
          <source>Advance Timers by Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af9ddf57a7d50c5e6b5eff43535f9164538d33dc" translate="yes" xml:space="preserve">
          <source>Advances all timers by the needed milliseconds so that only the next timeouts/intervals will run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6e685581823cbf41e050cfa3d4d3efe68f3736" translate="yes" xml:space="preserve">
          <source>After this method is called, all &lt;code&gt;require()&lt;/code&gt;s will return the real versions of each module (rather than a mocked version).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e4edac6675eabca400c0935453060c87c093dd" translate="yes" xml:space="preserve">
          <source>Again, we create a test file in the &lt;code&gt;__tests__/&lt;/code&gt; folder:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3539642d3664ec2813c705bf1656fa80d215afd0" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-b&lt;/code&gt;. Exit the test suite immediately upon &lt;code&gt;n&lt;/code&gt; number of failing test suite. Defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f545c267035a3769cec67deb4d85dbdea5ed4279" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-c&lt;/code&gt;. The path to a Jest config file specifying how to find and execute tests. If no &lt;code&gt;rootDir&lt;/code&gt; is set in the config, the directory containing the config file is assumed to be the rootDir for the project. This can also be a JSON-encoded value which Jest will use as configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5168880339d67b2e370e60c0c6ab283939bd91e" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-e&lt;/code&gt;. Use this flag to show full diffs and errors instead of a patch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99493a7a51fd254391a3ebbc240c428c0990c61c" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-i&lt;/code&gt;. Run all tests serially in the current process, rather than creating a worker pool of child processes that run tests. This can be useful for debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2552460fa09d12f47cce10ce54895c78e5d11fe6" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-o&lt;/code&gt;. Attempts to identify which tests to run based on which files have changed in the current repository. Only works if you're running tests in a git/hg repository at the moment and requires a static dependency graph (ie. no dynamic requires).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0722768635f39bb520a598cac25b8461c84a1e" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-t&lt;/code&gt;. Run only tests with a name that matches the regex. For example, suppose you want to run only tests related to authorization which will have names like &lt;code&gt;&quot;GET /api/posts with auth&quot;&lt;/code&gt;, then you can use &lt;code&gt;jest -t=auth&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa1a34b400f2f90695824c1275bc4ed1fcfc281" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-u&lt;/code&gt;. Use this flag to re-record every snapshot that fails during this test run. Can be used together with a test suite pattern or with &lt;code&gt;--testNamePattern&lt;/code&gt; to re-record snapshots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ecc088a9387041c13956d514f3c30314c61256c" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-v&lt;/code&gt;. Print the version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9514d4a998cf0be55fdd8c1f8b3ab17496d0b427" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-w&lt;/code&gt;. Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f293634d4b71e268b9315270803e95d567d5c055" translate="yes" xml:space="preserve">
          <source>All mock functions have this special &lt;code&gt;.mock&lt;/code&gt; property, which is where data about how the function has been called and what the function returned is kept. The &lt;code&gt;.mock&lt;/code&gt; property also tracks the value of &lt;code&gt;this&lt;/code&gt; for each call, so it is possible to inspect this as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d200710c4a1cb0a5518adeb855b420c9df2492c3" translate="yes" xml:space="preserve">
          <source>All you need in a test file is the &lt;code&gt;test&lt;/code&gt; method which runs a test. For example, let's say there's a function &lt;code&gt;inchesOfRain()&lt;/code&gt; that should be zero. Your whole test could be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6cdf6ad0cf9e05d26b92de733df230ae967936" translate="yes" xml:space="preserve">
          <source>Allows for a label to be printed along side a test while it is running. This becomes more useful in multiproject repositories where there can be many jest configuration files. This visually tells which project a test belongs to. Here are sample valid values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2d2b88484d26d6b0274df05b58474c9355339d" translate="yes" xml:space="preserve">
          <source>Allows the test suite to pass when no files are found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee11433796f7928eadda086f2e6317eba0f644e" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;https://facebook.github.io/watchman/docs/troubleshooting.html&quot;&gt;watchman troubleshooting&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ded90d6a8a58f29b63088540765e42efe71e66" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.lastCalledWith(arg1, arg2, ...)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72068b84899b93d08efebb5fbde5f86a2871fab0" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.lastReturnedWith(value)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099a9c56b2ffb0e433746f2d5a063a53bf87848e" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.nthCalledWith(nthCall, arg1, arg2, ...)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71518680860b6335bd23e9b151d1d48ae804594" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.nthReturnedWith(nthCall, value)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a976e7b6194d79232f8dd968730fcf8fa8de0bd4" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.runTimersToTime()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395cc025e9320dbca3e418277a47146fbe85a545" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toBeCalled()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b36b77a3b08255bd86abb689d07b9d3cda7cd8" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toBeCalledTimes(number)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab40e2a7cc91a41899b406bbf45e995ae8a0ccb3" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toBeCalledWith()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f135f1b735c2c08a602b278941f22ef918f12f6" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toReturn()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7e9d708812efa106b415eb4de6b5bc6cf9f969" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toReturnTimes(number)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2bf1dae2731b6f4c302617ced0c81f8cbe1e1d" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toReturnWith(value)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05408f6b685f91d674e7459a4e02a520c37b9ff6" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toThrowError(error?)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1feacec240ab724aed9abf11d8481d5be016bb" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;fdescribe(name, fn)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa5b0deb73cbf5bf4609fd6f9f31b133a58ef15" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;it(name, fn, timeout)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f02580bb5866da485a9c58917275f794f170733" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;it.each(table)(name, fn)&lt;/code&gt; and &lt;code&gt;it.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86566af6d287f431b2f25caf18aaacdb4fe0fed9" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;xdescribe(name, fn)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49a6ff10db6d3abd0202c575a4990526242f321" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;fdescribe.each(table)(name, fn)&lt;/code&gt; and &lt;code&gt;fdescribe.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df617fb63c786231166be551a69c544fb3bc875f" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.only(name, fn, timeout)&lt;/code&gt; or &lt;code&gt;fit(name, fn, timeout)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a927b33c56953bae3577b5390aba2c2c4cb3bc" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.only.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;fit.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;it.only.each`table`(name, fn)&lt;/code&gt; and &lt;code&gt;fit.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b5764e499cb8d78c16305a6528c4899aa522b4" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.skip(name, fn)&lt;/code&gt; or &lt;code&gt;xit(name, fn)&lt;/code&gt; or &lt;code&gt;xtest(name, fn)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae7b77488478baa85c14484c98a4586556a4adf" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.skip.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;xit.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;xtest.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;it.skip.each`table`(name, fn)&lt;/code&gt;, &lt;code&gt;xit.each`table`(name, fn)&lt;/code&gt; and &lt;code&gt;xtest.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebaf7711efc2429bdcc957d7601bf8b98792f7e8" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;xdescribe.each(table)(name, fn)&lt;/code&gt; and &lt;code&gt;xdescribe.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09523aba51788d839f21a8368cdbeff7d157bb04" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;async/await&lt;/code&gt; in combination with &lt;code&gt;.rejects&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287ce7bb7699bc441de5c565dd6f0ff136cd6f02" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;async/await&lt;/code&gt; in combination with &lt;code&gt;.resolves&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="683a48469ae34941c2dfe3c02609cb488fc9cf6e" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; in your tests. To write an async test, use the &lt;code&gt;async&lt;/code&gt; keyword in front of the function passed to &lt;code&gt;test&lt;/code&gt;. For example, the same &lt;code&gt;fetchData&lt;/code&gt; scenario can be tested with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70e3500483b9c230e96ed71d6eb2850d7817875" translate="yes" xml:space="preserve">
          <source>Although Jest may be considered a React-specific test runner, in fact it is a universal testing platform, with the ability to adapt to any JavaScript library or framework. In this section we'd like to link to community posts and articles about integrating Jest into other popular JS libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f675838f49f79bd87cbdc6aa6c10ac099c8d1a7" translate="yes" xml:space="preserve">
          <source>Although it is possible to write snapshot files manually, that is usually not approachable. Snapshots help to figure out whether the output of the modules covered by tests is changed, rather than giving guidance to design the code in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aebd1363c6cc98b159d0cd54a133b3010fd2af74" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;.toBe&lt;/code&gt; matcher &lt;strong&gt;checks&lt;/strong&gt; referential identity, it &lt;strong&gt;reports&lt;/strong&gt; a deep comparison of values if the assertion fails. If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the &lt;code&gt;expect&lt;/code&gt; function. For example, to assert whether or not elements are the same instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5588d7b29731ae809c64e5bdc946641ff8cdc8da" translate="yes" xml:space="preserve">
          <source>Always strive to use descriptive test and/or snapshot names for snapshots. The best names describe the expected snapshot content. This makes it easier for reviewers to verify the snapshots during review, and for anyone to know whether or not an outdated snapshot is the correct behavior before updating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf3cd7d4822e4172301955fdbd34bbf3ead80369" translate="yes" xml:space="preserve">
          <source>An Async Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b45a17cec3531985bca09a2f51e8258c6a164d8" translate="yes" xml:space="preserve">
          <source>An ES6 Class Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9503b02977c75b74fc98515eaf543859ba4a5b20" translate="yes" xml:space="preserve">
          <source>An alternative API to setting the &lt;code&gt;NODE_PATH&lt;/code&gt; env variable, &lt;code&gt;modulePaths&lt;/code&gt; is an array of absolute paths to additional locations to search when resolving modules. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/app/&quot;]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18c5e14d9b27331affd203c3ba0a5ea7a448a7c" translate="yes" xml:space="preserve">
          <source>An array containing the call arguments of all calls that have been made to this mock function. Each item in the array is an array of arguments that were passed during the call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46ce930eedbd7ddf653339853dcb9a903d0d421" translate="yes" xml:space="preserve">
          <source>An array containing the results of all calls that have been made to this mock function. Each entry in this array is an object containing a &lt;code&gt;type&lt;/code&gt; property, and a &lt;code&gt;value&lt;/code&gt; property. &lt;code&gt;type&lt;/code&gt; will be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d55820d20196b774de801007398d7381eb5e21" translate="yes" xml:space="preserve">
          <source>An array of &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;glob patterns&lt;/a&gt; indicating a set of files for which coverage information should be collected. If a file matches the specified glob pattern, coverage information will be collected for it even if no tests exist for this file and it's never required in the test suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d3bdf241dff3305fbf27dbe0b111fd6f3b0eab9" translate="yes" xml:space="preserve">
          <source>An array of RegExp patterns that are matched against all source file paths before re-running tests in watch mode. If the file path matches any of the patterns, when it is updated, it will not trigger a re-run of tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e893f728a32633130f596bfb0591acef847120" translate="yes" xml:space="preserve">
          <source>An array of directory names to be searched recursively up from the requiring module's location. Setting this option will &lt;em&gt;override&lt;/em&gt; the default, if you wish to still search &lt;code&gt;node_modules&lt;/code&gt; for packages include it along with any other options: &lt;code&gt;[&quot;node_modules&quot;, &quot;bower_components&quot;]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504281b83c6e81672ff2b065f899819937fcacff" translate="yes" xml:space="preserve">
          <source>An array of file extensions your modules use. If you require modules without specifying a file extension, these are the extensions Jest will look for, in left-to-right order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b68561e3089004cad3aab8c72147f145d5ad00d9" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all file paths before executing the test. If the file path matches any of the patterns, coverage information will be skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87abc2e394f90095864df40d50a17bb32b006523" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all module paths before those paths are to be considered 'visible' to the module loader. If a given module's path matches any of the patterns, it will not be &lt;code&gt;require()&lt;/code&gt;-able in the test environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96ebc6e5bdb81dd85cf0fb671eb2514e1041de9" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them. If a module's path matches any of the patterns in this list, it will not be automatically mocked by the module loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6404a872edd8e55e2e1adae4ddcdf7e2a10352" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all source file paths before transformation. If the test path matches any of the patterns, it will not be transformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95938a1191b9cbb1d990900f10c57777a2e1ed42" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all test paths before executing the test. If the test path matches any of the patterns, it will be skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462ad2f4a8409549d0f759cb0132577334a47d4c" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that is tested against all tests paths before executing the test. Contrary to &lt;code&gt;--testPathPattern&lt;/code&gt;, it will only run those test with a path that does not match with the provided regexp expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ada50d1e8326b688b4e15a2802d96af20f6a4b7" translate="yes" xml:space="preserve">
          <source>An array that contains all the object instances that have been instantiated from this mock function using &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5d2ee3d8eaab26feb4c41b55794ee099a28cca" translate="yes" xml:space="preserve">
          <source>An example of such function can be found in our default &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-jasmine2/src/index.ts&quot;&gt;jasmine2 test runner package&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="607f0bc7049c328734f7e81696dd602383afb610" translate="yes" xml:space="preserve">
          <source>And More</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e09ac014c181587ec460524c0658c52a8de5d93" translate="yes" xml:space="preserve">
          <source>And finally, we have to handle the webpack &lt;code&gt;alias&lt;/code&gt;. For that we can make use of the &lt;code&gt;moduleNameMapper&lt;/code&gt; option again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbc245e76c3e8b9a776e2d6e639bb997d2acd75" translate="yes" xml:space="preserve">
          <source>And it will generate the following snapshot:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3a68e32529c05dce55087b82076e0dc6576f89" translate="yes" xml:space="preserve">
          <source>And the mock files themselves:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e09000e5c2a6bef346596ec2e0dec0fbf7495a6" translate="yes" xml:space="preserve">
          <source>Angular</source>
          <target state="translated">Angular</target>
        </trans-unit>
        <trans-unit id="2a3de4a9dc7c9f3bd23b0b53226033777b1c013b" translate="yes" xml:space="preserve">
          <source>AngularJS</source>
          <target state="translated">AngularJS</target>
        </trans-unit>
        <trans-unit id="742a5629f9bbfed1143d85bb3d0a7ea7fc795192" translate="yes" xml:space="preserve">
          <source>Another alternative to expediting test execution time on Continuous Integration Servers such as Travis-CI is to set the max worker pool to ~&lt;em&gt;4&lt;/em&gt;. Specifically on Travis-CI, this can reduce test execution time in half. Note: The Travis CI &lt;em&gt;free&lt;/em&gt; plan available for open source projects only includes 2 CPU cores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d396fa096245e4ff526d431e1fdc7511c337853" translate="yes" xml:space="preserve">
          <source>Another class of functions that is often considered difficult to test is code that directly manipulates the DOM. Let's see how we can test the following snippet of jQuery code that listens to a click event, fetches some data asynchronously and sets the content of a span.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893f79ed3ff3f37c6371db618f971f7d16027030" translate="yes" xml:space="preserve">
          <source>Another possibility is use &lt;code&gt;jest.advanceTimersByTime(msToRun)&lt;/code&gt;. When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via setTimeout() or setInterval(), and would be executed during this time frame, will be executed. Additionally if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue that should be run within msToRun milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3836d5626c7fcd443d2b13b3c90a168aeac159" translate="yes" xml:space="preserve">
          <source>Another test we might want to write for this module is one that asserts that the callback is called after 1 second. To do this, we're going to use Jest's timer control APIs to fast-forward time right in the middle of the test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a103c34b8de331bd76f45b2403f7aed399db936" translate="yes" xml:space="preserve">
          <source>Any docblock pragmas in test files will be passed to the environment constructor and can be used for per-test configuration. If the pragma does not have a value, it will be present in the object with it's value set to an empty string. If the pragma is not present, it will not be present in the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62674adc2fd45e062316f5e05f5f083ea662d480" translate="yes" xml:space="preserve">
          <source>Any given value that is not a matcher will be checked exactly and saved to the snapshot:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5b7ea7bd8c1a3b846217990f58a7237946847e" translate="yes" xml:space="preserve">
          <source>Any key not used by built-in functionality can be claimed, as you would expect. Try to avoid using keys that are difficult to obtain on various keyboards (e.g. &lt;code&gt;&amp;eacute;&lt;/code&gt;, &lt;code&gt;&amp;euro;&lt;/code&gt;), or not visible by default (e.g. many Mac keyboards do not have visual hints for characters such as &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="4565f29db31ebc3ed2837a5c66dc7f7115c60784" translate="yes" xml:space="preserve">
          <source>Are snapshots written automatically on Continuous Integration (CI) systems?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f735920f6b1287b080ec6ef4f28c968da24737c" translate="yes" xml:space="preserve">
          <source>Arguments can also be mixed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5eb7315732ba1dd9aa54c5447ef8251ac1f1a72" translate="yes" xml:space="preserve">
          <source>Array sparseness is checked. e.g. &lt;code&gt;[, 1]&lt;/code&gt; does not match &lt;code&gt;[undefined, 1]&lt;/code&gt; when using &lt;code&gt;.toStrictEqual&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bc07f8fe3ae265bc1c65271265c09fffe2ede6" translate="yes" xml:space="preserve">
          <source>Arrays and iterables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74911a9974788ee31baf4332aa46469914fc0018" translate="yes" xml:space="preserve">
          <source>As a secondary option, an object with the properties &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; can be passed. This allows for a custom configuration of the background color of the displayName. &lt;code&gt;displayName&lt;/code&gt; defaults to white when its value is a string. Jest uses &lt;a href=&quot;https://github.com/chalk/chalk&quot;&gt;chalk&lt;/a&gt; to provide the color. As such, all of the valid options for colors supported by chalk are also supported by jest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce4c489a4e9ecd6d0287803d6407ac937c080c8" translate="yes" xml:space="preserve">
          <source>As an example to show why this is the case, imagine we wrote a test like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bff98a0df6c56f2756da9281d0404c838a0e295" translate="yes" xml:space="preserve">
          <source>As mentioned previously, Jest uses &lt;a href=&quot;https://yarnpkg.com/en/package/pretty-format&quot;&gt;&lt;code&gt;pretty-format&lt;/code&gt;&lt;/a&gt; to make snapshots human-readable, but you may find it useful to introduce additional tools, like &lt;a href=&quot;https://yarnpkg.com/en/package/eslint-plugin-jest&quot;&gt;&lt;code&gt;eslint-plugin-jest&lt;/code&gt;&lt;/a&gt; with its &lt;a href=&quot;https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md&quot;&gt;&lt;code&gt;no-large-snapshots&lt;/code&gt;&lt;/a&gt; option, or &lt;a href=&quot;https://yarnpkg.com/en/package/snapshot-diff&quot;&gt;&lt;code&gt;snapshot-diff&lt;/code&gt;&lt;/a&gt; with its component snapshot comparison feature, to promote committing short, focused assertions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2edb0f24d18bfcbc00e0c78839a1fdf035ed9311" translate="yes" xml:space="preserve">
          <source>Ask questions and find answers from other Jest users like you. &lt;a href=&quot;http://www.reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; is a Discord chat where a lot of Jest discussion happens. Check out the &lt;a href=&quot;https://discord.gg/MWRhKCj&quot;&gt;#jest&lt;/a&gt; channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc2d7716879ffcf62253d1d725243538c0235af" translate="yes" xml:space="preserve">
          <source>Async Matchers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56a660f0dad726695b31dda5b8891615117ac6d" translate="yes" xml:space="preserve">
          <source>Async/Await</source>
          <target state="translated">Async/Await</target>
        </trans-unit>
        <trans-unit id="e27221756365cd045960f2e94d5cb617a09fd66c" translate="yes" xml:space="preserve">
          <source>At Facebook, we use Jest to test &lt;a href=&quot;http://facebook.github.io/react-native/&quot;&gt;React Native&lt;/a&gt; applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395b841bd250360a8d39d43d0cc9468e6a191ff3" translate="yes" xml:space="preserve">
          <source>At Facebook, we use Jest to test &lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cdaf4152db0f4f16342bd19654aceac0ca1e3e" translate="yes" xml:space="preserve">
          <source>Attempt to collect and print open handles preventing Jest from exiting cleanly. Use this in cases where you need to use &lt;code&gt;--forceExit&lt;/code&gt; in order for Jest to exit to potentially track down the reason. This implies &lt;code&gt;--runInBand&lt;/code&gt;, making tests run serially. Implemented using &lt;a href=&quot;https://nodejs.org/api/async_hooks.html&quot;&gt;&lt;code&gt;async_hooks&lt;/code&gt;&lt;/a&gt;, so it only works in Node 8 and newer. This option has a significant performance penalty and should only be used for debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6dc28e5599c9cab49b9e2c317821c7dd774121" translate="yes" xml:space="preserve">
          <source>Authorized configuration keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="116210a421ba183e44c078b53f193cdc6fb43a87" translate="yes" xml:space="preserve">
          <source>Automatic mock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0219bef967d8f707c8e0246d4db056aae02a5ccf" translate="yes" xml:space="preserve">
          <source>Automatically clear mock calls and instances before every test. Equivalent to calling &lt;code&gt;jest.clearAllMocks()&lt;/code&gt; before each test. This does not remove any mock implementation that may have been provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1087f99cc0f32ae4b69ceb38fb06f0ea54c89a40" translate="yes" xml:space="preserve">
          <source>Automatically reset mock state before every test. Equivalent to calling &lt;code&gt;jest.resetAllMocks()&lt;/code&gt; before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4c3e6aeec9cba44ed3be7bda907111f3172875" translate="yes" xml:space="preserve">
          <source>Automatically restore mock state before every test. Equivalent to calling &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="2c6957f4f82498b87545ed7a33f9f93969bbb3e6" translate="yes" xml:space="preserve">
          <source>Based on the &lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-262366820&quot;&gt;findings&lt;/a&gt;, one way to mitigate this issue and improve the speed by up to 50% is to run tests sequentially.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f2f862e91add8b90e4a6da877a14f5e16eb9dc" translate="yes" xml:space="preserve">
          <source>Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6bfef866c16d00ea780b8f331139cb8d28b83d" translate="yes" xml:space="preserve">
          <source>Be sure to return the assertion&amp;mdash;if you omit this &lt;code&gt;return&lt;/code&gt; statement, your test will complete before the promise returned from &lt;code&gt;fetchData&lt;/code&gt; is resolved and then() has a chance to execute the callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f556e536c0e7e0056301601d7417c65940d6ae" translate="yes" xml:space="preserve">
          <source>Be sure to return the promise - if you omit this &lt;code&gt;return&lt;/code&gt; statement, your test will complete before the promise returned from &lt;code&gt;fetchData&lt;/code&gt; resolves and then() has a chance to execute the callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9fd1717377fe3279d351011475ce90a698762e" translate="yes" xml:space="preserve">
          <source>Because we don't want to go to the network in our test, we are going to create a manual mock for our &lt;code&gt;request.js&lt;/code&gt; module in the &lt;code&gt;__mocks__&lt;/code&gt; folder (the folder is case-sensitive, &lt;code&gt;__MOCKS__&lt;/code&gt; will not work). It could look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64753a59b275da395d2c1dc8b7dcb455fad7c963" translate="yes" xml:space="preserve">
          <source>Below are the hooks available in Jest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36de90e22d47f94d755a4b1bb70aaddc1bb47593" translate="yes" xml:space="preserve">
          <source>Best Practices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f0fcd3b8d03992c8b96556ac49a857175afecc" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;mockClear&lt;/code&gt; will replace &lt;code&gt;mockFn.mock&lt;/code&gt;, not just &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt;. You should therefore avoid assigning &lt;code&gt;mockFn.mock&lt;/code&gt; to other variables, temporary or not, to make sure you don't access stale data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931ccb5668e93107bc30b0d906bbc9a8b26f7c56" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;mockFn.mockRestore&lt;/code&gt; only works when the mock was created with &lt;code&gt;jest.spyOn&lt;/code&gt;. Thus you have to take care of restoration yourself when manually assigning &lt;code&gt;jest.fn()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b002ef5dff177f13b0153d72646356c1a85e431" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;mockReset&lt;/code&gt; will replace &lt;code&gt;mockFn.mock&lt;/code&gt;, not just &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt;. You should therefore avoid assigning &lt;code&gt;mockFn.mock&lt;/code&gt; to other variables, temporary or not, to make sure you don't access stale data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb7bb160ae4e03b6bfacba742441ea7d2e578df" translate="yes" xml:space="preserve">
          <source>Browse the docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276a88c140a6bf7107571e0e3473c859f70d5592" translate="yes" xml:space="preserve">
          <source>Building your constructor function mock using &lt;code&gt;jest.fn().mockImplementation()&lt;/code&gt; makes mocks appear more complicated than they really are. This section shows how you can create your own mocks to illustrate how mocking works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72789db809aebd98e3793977340fa23a403dd9b2" translate="yes" xml:space="preserve">
          <source>By adding a &lt;code&gt;@jest-environment&lt;/code&gt; docblock at the top of the file, you can specify another environment to be used for all tests in that file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64a054e0008020bcca517ad251114bdd878bd10" translate="yes" xml:space="preserve">
          <source>By default the jest-react-native preset only processes the project's own source files and react-native. If you have npm dependencies that have to be transformed you can customize this configuration option by whitelisting modules other than react-native:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24192876f804f24abf879b9436d1771d8dea9d51" translate="yes" xml:space="preserve">
          <source>By default, Jest runs all tests and produces all errors into the console upon completion. The bail config option can be used here to have Jest stop running tests after &lt;code&gt;n&lt;/code&gt; failures. Setting bail to &lt;code&gt;true&lt;/code&gt; is the same as setting bail to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c18e033ac397507497b08aca298046458436f1b" translate="yes" xml:space="preserve">
          <source>By default, Jest tests complete once they reach the end of their execution. That means this test will &lt;em&gt;not&lt;/em&gt; work as intended:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e08a56bb6409c96440829d4111b8fe08c3fc8c" translate="yes" xml:space="preserve">
          <source>By default, each test file gets its own independent module registry. Enabling &lt;code&gt;resetModules&lt;/code&gt; goes a step further and resets the module registry before running each individual test. This is useful to isolate modules for every test so that local module state doesn't conflict between tests. This can be done programmatically using &lt;a href=&quot;jest-object#jestresetmodules&quot;&gt;&lt;code&gt;jest.resetModules()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd069e07b719971ba572ee8dd0ce8e0d70313aa8" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; blocks apply to every test in a file. You can also group tests together using a &lt;code&gt;describe&lt;/code&gt; block. When they are inside a &lt;code&gt;describe&lt;/code&gt; block, the &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; blocks only apply to the tests within that &lt;code&gt;describe&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff6b50d4d2916e059b4da78398d7f7528e06bc4" translate="yes" xml:space="preserve">
          <source>By now you should have a good idea of how Jest can help you test your applications. If you're interested in learning more, here's some related stuff you might want to check out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ee7b41c21d659b9270bc90149ebea235b5681e" translate="yes" xml:space="preserve">
          <source>Bypassing module mocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c44908e93edab5744658b1f65e26d8c711f11b" translate="yes" xml:space="preserve">
          <source>Caching Issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="29ebbaf2a884d1472efa612e0a99881e086b0d45" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;jest-object#jestmockmodulename-factory-options&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; with the module factory parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fb7b5fdc1cb7e80c6697d89dc59adbcb936cfd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;jest.mock('./sound-player')&lt;/code&gt; returns a useful &quot;automatic mock&quot; you can use to spy on calls to the class constructor and all of its methods. It replaces the ES6 class with a mock constructor, and replaces all of its methods with &lt;a href=&quot;mock-functions&quot;&gt;mock functions&lt;/a&gt; that always return &lt;code&gt;undefined&lt;/code&gt;. Method calls are saved in &lt;code&gt;theAutomaticMock.mock.instances[index].methodName.mock.calls&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20ec8cdd6ae393d85748c5307b9a180fdb961ea" translate="yes" xml:space="preserve">
          <source>Calls to jest.mock are hoisted to the top of the code. You can specify a mock later, e.g. in &lt;code&gt;beforeAll()&lt;/code&gt;, by calling &lt;code&gt;mockImplementation()&lt;/code&gt; (or &lt;code&gt;mockImplementationOnce()&lt;/code&gt;) on the existing mock instead of using the factory parameter. This also allows you to change the mock between tests, if needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b5e900f807b38adaa6e9c85b7fbbbdc6e0face" translate="yes" xml:space="preserve">
          <source>Camelcase &amp;amp; dashed args support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ceb09d577f5f6169012cae86d6ed0c20f9308f0" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;React Tree Snapshot Testing&lt;/a&gt; for more information on snapshot testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ad42e0821d727215f4c5c74225fda2de21bcbc" translate="yes" xml:space="preserve">
          <source>Check out the section on &lt;a href=&quot;snapshot-testing#inline-snapshots&quot;&gt;Inline Snapshots&lt;/a&gt; for more info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834816cb4074428815336a2cb6e1928bb56da7fb" translate="yes" xml:space="preserve">
          <source>Choosing a good key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f282371c2a1af22d1e4a9f0b7e80f6cb76f88540" translate="yes" xml:space="preserve">
          <source>Cleaning up between tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="951b5b48e067f46712c0fc43e2f448c71ed835a5" translate="yes" xml:space="preserve">
          <source>Clears the &lt;code&gt;mock.calls&lt;/code&gt; and &lt;code&gt;mock.instances&lt;/code&gt; properties of all mocks. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt;&lt;code&gt;.mockClear()&lt;/code&gt;&lt;/a&gt; on every mocked function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6db6e9b2b18300b8b1943a06238aa498f4d0ffe" translate="yes" xml:space="preserve">
          <source>Commit snapshots and review them as part of your regular code review process. This means treating snapshots as you would any other type of test or code in your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5317e60e1477cd7f5e0cf5cbb3fd4f6fbfd42186" translate="yes" xml:space="preserve">
          <source>Common Matchers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39af2b26c9ee2c162295a79a46bf64f2dcb740b9" translate="yes" xml:space="preserve">
          <source>Community projects under one organisation are a great way for Jest to experiment with new ideas/techniques and approaches. Encourage contributions from the community and publish contributions independently at a faster pace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac62a488978924e46345706e5701acf535027b1" translate="yes" xml:space="preserve">
          <source>Compatibility issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647a61b7661823bee3e0fb318ccb983ea06af198" translate="yes" xml:space="preserve">
          <source>Complete example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7338817b3b4ee94bffc83800ba5beb8a9de91061" translate="yes" xml:space="preserve">
          <source>Config: //</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419b3ad350c5399b2d30683f98566248a0ccc3a0" translate="yes" xml:space="preserve">
          <source>Config: automock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627e8b1a128fd33accae1330833eabb2bdca8973" translate="yes" xml:space="preserve">
          <source>Config: bail</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5d64a5311bb274fd46a79262ecb43ee3a1e121" translate="yes" xml:space="preserve">
          <source>Config: browser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4367a209c83015f162fc0ca638a3e053c9041bdb" translate="yes" xml:space="preserve">
          <source>Config: cacheDirectory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5e892834611f65829eeac25c2d08106d23b5a7" translate="yes" xml:space="preserve">
          <source>Config: clearMocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501c70b5aa067226067f0b907eb78a61fccc193d" translate="yes" xml:space="preserve">
          <source>Config: collectCoverage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b208010efbcc655b8d5fcea13db6ce8d2238cf7d" translate="yes" xml:space="preserve">
          <source>Config: collectCoverageFrom</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf43098f46df2169bb90995abc4f207c9f4654b" translate="yes" xml:space="preserve">
          <source>Config: coverageDirectory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61dfeddb711754aa3eea86892ddac143c1cf750" translate="yes" xml:space="preserve">
          <source>Config: coveragePathIgnorePatterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc823be9ce961ce58c7a5bd2c3ede521ec9b22c" translate="yes" xml:space="preserve">
          <source>Config: coverageReporters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731365c9b4185412e26d012a648d84274b7ee783" translate="yes" xml:space="preserve">
          <source>Config: coverageThreshold</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ddb77352d47cc2ab7211c5bb66e8ea1cf8dbedb" translate="yes" xml:space="preserve">
          <source>Config: dependencyExtractor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410a11c871d9b9ac5d1c84224af14915bc5687c9" translate="yes" xml:space="preserve">
          <source>Config: displayName</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27317b3ce2dc1add449b8f662db64de41a9e9ae6" translate="yes" xml:space="preserve">
          <source>Config: errorOnDeprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fecda0afbc8d772eae7fac9e4ba0b8b1d10e359f" translate="yes" xml:space="preserve">
          <source>Config: extraGlobals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25f9152c510580dbb37bfa8b225c9b83eec07f3" translate="yes" xml:space="preserve">
          <source>Config: forceCoverageMatch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79761896d6c24e1a388783f8ad0d4cf62e966150" translate="yes" xml:space="preserve">
          <source>Config: globalSetup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92db96d317bc0181d4c70c0a736f44496f34c5f0" translate="yes" xml:space="preserve">
          <source>Config: globalTeardown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2c2049305c4a3db421bc76e052ff49dd5e09c4" translate="yes" xml:space="preserve">
          <source>Config: globals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67799f97ad1d1ba5dbde5c2bbea2d9e7a64e588" translate="yes" xml:space="preserve">
          <source>Config: maxConcurrency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba41029a807595561e6313c2154c8d63b551b08f" translate="yes" xml:space="preserve">
          <source>Config: moduleDirectories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c69621f31253439feae40f7edb9f987c54a7c60" translate="yes" xml:space="preserve">
          <source>Config: moduleFileExtensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56cc759b41f3e82ba32926a92966a3f498e6902" translate="yes" xml:space="preserve">
          <source>Config: moduleNameMapper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a45c51d17976a84164108ba1570ebaa713c2d0" translate="yes" xml:space="preserve">
          <source>Config: modulePathIgnorePatterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8dfc9221f178a7e9e50e483363057b29737331d" translate="yes" xml:space="preserve">
          <source>Config: modulePaths</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="443a851b039bcd2776957b32886e287fea1ec06b" translate="yes" xml:space="preserve">
          <source>Config: notify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17139aeb93d058b72a2aa76ec6bb221cf0bef770" translate="yes" xml:space="preserve">
          <source>Config: notifyMode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3caeb9058b4e79e45f4cf9706757269977d12773" translate="yes" xml:space="preserve">
          <source>Config: preset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5eee9d73aa692050786b2b5d012b9c6430da5f" translate="yes" xml:space="preserve">
          <source>Config: prettierPath</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de718240490d094a4aca3e67beb56ce24d859f0e" translate="yes" xml:space="preserve">
          <source>Config: projects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12a5c71edd2c879af4190d0ca91fb1c41ed4691" translate="yes" xml:space="preserve">
          <source>Config: reporters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d3f1dda15c90c8537c0ebaae99cc9b6dab6d2c" translate="yes" xml:space="preserve">
          <source>Config: resetMocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ce92b9cce0a2fc0cfaa6bdc87fca0a67673a92" translate="yes" xml:space="preserve">
          <source>Config: resetModules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e342a2f1f10e2ce5223aeb58621bcfcaee80280" translate="yes" xml:space="preserve">
          <source>Config: resolver</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0db5ef6ee172dca67b2ec98bd9764765247d45" translate="yes" xml:space="preserve">
          <source>Config: restoreMocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbda260933b77348b0de3d059fb6eaafcfe9ed04" translate="yes" xml:space="preserve">
          <source>Config: rootDir</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a486beac88a05f5107d2963397c9a097a8b9c53d" translate="yes" xml:space="preserve">
          <source>Config: roots</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15087b6a38a2044fac1d8bca8ed5b732e85be8e9" translate="yes" xml:space="preserve">
          <source>Config: runner</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d7cd6c10e8ee3f4e5933ab036c264a961a3c6f" translate="yes" xml:space="preserve">
          <source>Config: setupFiles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b099bf0ed7f0b70b104f43a494c8a3601d6db3b" translate="yes" xml:space="preserve">
          <source>Config: setupFilesAfterEnv</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fceff3400dd04baa7d8cf445ca60d91c4b565d" translate="yes" xml:space="preserve">
          <source>Config: snapshotResolver</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926aa02967cb62919ed24d142e8ab790e7e88f40" translate="yes" xml:space="preserve">
          <source>Config: snapshotSerializers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2719c66aea5faa9e87f1dada70059a3cfbc1c722" translate="yes" xml:space="preserve">
          <source>Config: testEnvironment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e3d1362b32367666c7ee4106cc8a8c49ef9c56" translate="yes" xml:space="preserve">
          <source>Config: testEnvironmentOptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a067ac9bbff1c40f63b3c4571746aeb1f2c51ef3" translate="yes" xml:space="preserve">
          <source>Config: testMatch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b64c3b85bea8af5d02fcd06f985923761f20605" translate="yes" xml:space="preserve">
          <source>Config: testPathIgnorePatterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4324c80d83474910e2f7ba12475a97f71b780b" translate="yes" xml:space="preserve">
          <source>Config: testRegex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b1317ed93a2645076cae324fc69ab7bd2043de" translate="yes" xml:space="preserve">
          <source>Config: testResultsProcessor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebce535e49ba2d6e77c3ace6f1d4b4d227eb1005" translate="yes" xml:space="preserve">
          <source>Config: testRunner</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f361d3abf65818229de4fd0fd2b800c7132faa" translate="yes" xml:space="preserve">
          <source>Config: testSequencer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9dcaf483df4a5ad04db7728ded6a4a42efa7cc9" translate="yes" xml:space="preserve">
          <source>Config: testURL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6decdd2c51010466998366161fed9615c71ed2e" translate="yes" xml:space="preserve">
          <source>Config: timers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710dedba7705ede1b50331e3f82d3159bd25781c" translate="yes" xml:space="preserve">
          <source>Config: transform</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567cb22f9c7af2b996f4d744bf2d3e97d8f52294" translate="yes" xml:space="preserve">
          <source>Config: transformIgnorePatterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7d6430c4ac8b493a953f1b57daa83c4cf0b4fc" translate="yes" xml:space="preserve">
          <source>Config: unmockedModulePathPatterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9f98c1a91d2c94b70a6840de75ff48ff87cde9" translate="yes" xml:space="preserve">
          <source>Config: verbose</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc12f6eb1650abf575ed9f60726c3d8f9776c168" translate="yes" xml:space="preserve">
          <source>Config: watchPathIgnorePatterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6264b4990f0b105e5e1586412f25673503f78b81" translate="yes" xml:space="preserve">
          <source>Config: watchPlugins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0540e863b75a1e450632fdfba93847f16e57dfe" translate="yes" xml:space="preserve">
          <source>Configure Babel to target your current version of Node by creating a &lt;code&gt;babel.config.js&lt;/code&gt; file in the root of your project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="732bdf3d9ce078bf71b612048a4595a4eb70bdff" translate="yes" xml:space="preserve">
          <source>Configure DynamoDB client</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8f1ca94d78bf9bcf623acecc179502fe36fdf4" translate="yes" xml:space="preserve">
          <source>Configuring Jest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d69b5f49a85c3bbccb1893393cd0decc9db7f396" translate="yes" xml:space="preserve">
          <source>Configuring Jest to find our files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f73284b346579e5b9427a96d62cdd35e3340d4d0" translate="yes" xml:space="preserve">
          <source>Consider the following illustrative test file and output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195e9ca7f58f10ad0afe5f1b4587aa7d074cc2bd" translate="yes" xml:space="preserve">
          <source>Consider writing a test case for this &lt;code&gt;createUser&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7c7b509517031ce2942935f6e6675726c02dcb" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;jest-dynamodb-config.js&lt;/code&gt; and define DynamoDB tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f072285a90744179b098528df836611fec0f6e77" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; by saving a mock implementation in the &lt;code&gt;__mocks__&lt;/code&gt; folder. This allows you to specify the implementation, and it can be used across test files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7576c0fd5d12ef5fcd87f993a9d142bd20852f" translate="yes" xml:space="preserve">
          <source>Creates a mock function similar to &lt;code&gt;jest.fn&lt;/code&gt; but also tracks calls to &lt;code&gt;object[methodName]&lt;/code&gt;. Returns a Jest mock function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6af3b0b9c2d9efcee182c5badbf215b13de90d9" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;a href=&quot;mock-functions&quot;&gt;mock function&lt;/a&gt;. The new function has no formal parameters and when called will return &lt;code&gt;undefined&lt;/code&gt;. This functionality also applies to &lt;code&gt;async&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff88930a91ab80f14f3aebb7fde98a563da17ce4" translate="yes" xml:space="preserve">
          <source>Creates a new deeply cloned object. The object keys are maintained and their values are mocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499339901a2a6910de0fa6f2ee66c02b0aa8ec88" translate="yes" xml:space="preserve">
          <source>Creates a new empty array, ignoring the original.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5763b0dca9136215f4c1bd25d66fda4d413f5fa" translate="yes" xml:space="preserve">
          <source>Creates a new property with the same primitive value as the original property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a2d117a3682ce4e9ee56f51a4dddf39a8c9887" translate="yes" xml:space="preserve">
          <source>Creates new class. The interface of the original class is maintained, all of the class member functions and properties will be mocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c51941f39ba45e54075e0925fb6911178a577498" translate="yes" xml:space="preserve">
          <source>Custom Matchers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f825aa31c7f89df216a075a2e0407f6b8d69f3" translate="yes" xml:space="preserve">
          <source>Custom Matchers API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="119759fa773122549b207e8a3a246d10ce0d12df" translate="yes" xml:space="preserve">
          <source>Custom example without jest-puppeteer preset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d21fbbb8afbf0a16c827d47836dcb1856cc7708e" translate="yes" xml:space="preserve">
          <source>Custom reporter modules must define a class that takes a &lt;code&gt;GlobalConfig&lt;/code&gt; and reporter options as constructor arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714a39b633fc18946fa5b07fb026f29bf56da631" translate="yes" xml:space="preserve">
          <source>Custom reporters can also force Jest to exit with non-0 code by returning an Error from &lt;code&gt;getLastError()&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59764a788a550e0bcc7c2f3f06d2271ee9028a6a" translate="yes" xml:space="preserve">
          <source>Custom snapshot matchers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb96a7111f5d3ea6a3fe4177d7f8a2f59a345b0" translate="yes" xml:space="preserve">
          <source>Custom transformers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="796036624d60e8855428745a98834ec3d84c8f41" translate="yes" xml:space="preserve">
          <source>Custom watch plugins can add hooks to Jest events. These hooks can be added either with or without having an interactive key in the watch mode menu.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215e1af622d5b72a6cc168c70f4702a398bb2716" translate="yes" xml:space="preserve">
          <source>Custom watch plugins can also add or override functionality to the watch menu by specifying a key/prompt pair in &lt;code&gt;getUsageInfo&lt;/code&gt; method and a &lt;code&gt;run&lt;/code&gt; method for the execution of the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f0ac9e007291a6ccc21d036f4711505ad9d0b1" translate="yes" xml:space="preserve">
          <source>Customization</source>
          <target state="translated">Customization</target>
        </trans-unit>
        <trans-unit id="97bc0d0faf1db6773f46f77993cbfab01aef6415" translate="yes" xml:space="preserve">
          <source>DOM Manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d47c567751d80a763336c3531e448b81a834be1" translate="yes" xml:space="preserve">
          <source>DOM Testing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47d19ef23ccb3630dfbdcf2345caac51860dc04a" translate="yes" xml:space="preserve">
          <source>Debugging in VS Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b21e655f77156f74590b9394f284ad276659df" translate="yes" xml:space="preserve">
          <source>Debugging in WebStorm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8d2a884ab0f628a1f7f94392af6e76fa7a2fc7" translate="yes" xml:space="preserve">
          <source>Default timeout of a test in milliseconds. Default value: 5000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5aab0a956d1bf4178fda692ccbf9f96c049d2f" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;/tmp/&amp;lt;path&amp;gt;&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bb4405a1bd1698f8e13de63202bbb029fb7e5b" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;jest-runner&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47384bd44c204995dd251a440e0f2874c419f943" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;jsdom&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819cc760e16ea72f302b36952c68bdc74e37fbc0" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;'prettier'&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2e64757bbec7711d7708d7a5ad878780438205" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;(/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3569cdb24d4e3738060acfc3ad2efff4bb497560" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3230c6cb67eb67fb80df55aa548813d92e446d" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;5&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d90156b27c53ecc56aef155a22882f9031bbda" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;@jest/test-sequencer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec10196844ffb76ab5d5c304aacc13ac2e3cef9" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;&quot;]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5e027fc76915df0b4b1aa4ee05ea7cf2a7e108" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;/node_modules/&quot;]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a0fee6fa4afd6073a2bb2c2c33627e5932f689" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;js&quot;, &quot;json&quot;, &quot;jsx&quot;, &quot;ts&quot;, &quot;tsx&quot;, &quot;node&quot;]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96347c64af1e884636cd5cac216f125cf26bfaac" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;json&quot;, &quot;lcov&quot;, &quot;text&quot;, &quot;clover&quot;]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52bfa7d4e9de2ac8aff5837eee8067bcdd2d8d03" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;node_modules&quot;]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d48cfe315fd247262c98a909a60e72fe1adb7bd" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;['']&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffa1281e650e63433a7c2437e7f3068376e6c83" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b2f403a7a8a0196ba2b1e131b436bad9608f06" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;failure-change&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="614188609a5c964071cad1f8bd6a9a468d7e820f" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32578e58095a4c9dc16bbe18810864be9eb55e61" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;http://localhost&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7e8f5d26d527a1551f7fbe8540cdd2756856f1" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;jasmine2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72af77c264a4ee8b4a40880a27db11fcd236d73d" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;null&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59e0f6f5986d77c33cddbccdfb1f46b1dcfe17a" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;real&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440b4c5aa1e906e434fd52447e734719e939c93d" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7da6b7c92470df3b7f4b4cef35bf9321c6095a8" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;{}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a66f14241f019bfa4af9e9837d93ce753bdfcf" translate="yes" xml:space="preserve">
          <source>Default: The root of the directory containing your Jest config file&lt;em&gt;or&lt;/em&gt; the &lt;code&gt;package.json&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pwd&quot;&gt;&lt;code&gt;pwd&lt;/code&gt;&lt;/a&gt; if no &lt;code&gt;package.json&lt;/code&gt; is found</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428819bf9e83cebda50efafb08cd2534c1583949" translate="yes" xml:space="preserve">
          <source>Defaults</source>
          <target state="translated">Defaults</target>
        </trans-unit>
        <trans-unit id="708e979a86993e441e280091f83d90e49fb6e0fb" translate="yes" xml:space="preserve">
          <source>Defining Tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa37ce3402b9fdda8c547faa8f8a629231c38fc" translate="yes" xml:space="preserve">
          <source>Deletes the Jest cache directory and then exits without running tests. Will delete &lt;code&gt;cacheDirectory&lt;/code&gt; if the option is passed, or Jest's default cache directory. The default cache directory can be found by calling &lt;code&gt;jest --showConfig&lt;/code&gt;. &lt;em&gt;Note: clearing the cache will reduce performance.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9c3f11c071444f893ad63c8b10640d8dec604b" translate="yes" xml:space="preserve">
          <source>Determines if the given function is a mocked function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25fde793067d8261eed4bccfb3fd238dad8d6983" translate="yes" xml:space="preserve">
          <source>Differences from &lt;code&gt;.toEqual&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc8abd105b53147a8d0383ba5b505ee49226316a" translate="yes" xml:space="preserve">
          <source>Disable warnings all together (should be done in your jest setup file):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae71b8a8ed202bbaa7e42b1a5bdeb06c2525518d" translate="yes" xml:space="preserve">
          <source>Disables automatic mocking in the module loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e34bb12f80749a80b5838e96b2c150faa45ac0" translate="yes" xml:space="preserve">
          <source>Disables stack trace in test results output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e98b783a42cdc4f4a03ffd64649c5f26f6c011b" translate="yes" xml:space="preserve">
          <source>Display individual test results with the test suite hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f3f815fbd922415c3aa6adb4aa4e59a5e04a90" translate="yes" xml:space="preserve">
          <source>Divert all output to stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf393e4923d7954d9bc2a84e51b45079ca53939" translate="yes" xml:space="preserve">
          <source>Does code coverage work with snapshot testing?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fbd6d73ceaf62001f4cf5b3fc9c82f322ebedc" translate="yes" xml:space="preserve">
          <source>Does everything that &lt;a href=&quot;#mockfnmockclear&quot;&gt;&lt;code&gt;mockFn.mockClear()&lt;/code&gt;&lt;/a&gt; does, and also removes any mocked return values or implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7789e80d5d03d9a660831975a1ab1fb586436891" translate="yes" xml:space="preserve">
          <source>Does everything that &lt;a href=&quot;#mockfnmockreset&quot;&gt;&lt;code&gt;mockFn.mockReset()&lt;/code&gt;&lt;/a&gt; does, and also restores the original (non-mocked) implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8613a53b523abbac39b8070515f3ee0abf3b4d2" translate="yes" xml:space="preserve">
          <source>Does snapshot testing only work with React components?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bef91ef2504e85917d6489193a8b3d0184f65a1" translate="yes" xml:space="preserve">
          <source>Does snapshot testing replace unit testing?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3003258c19842b6d44deed813b6a58f22ceeab" translate="yes" xml:space="preserve">
          <source>Don't forget to install the &lt;code&gt;@babel/core&lt;/code&gt; and &lt;code&gt;babel-preset-jest&lt;/code&gt; packages for this example to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50dcc8f4ef764e131e9874eeed3d12dbbb7ac84" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;.toBe&lt;/code&gt; with floating-point numbers. For example, due to rounding, in JavaScript &lt;code&gt;0.2 + 0.1&lt;/code&gt; is not strictly equal to &lt;code&gt;0.3&lt;/code&gt;. If you have floating point numbers, try &lt;code&gt;.toBeCloseTo&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846c9004ef1bbb7bfccc704a3c8972b52308d069" translate="yes" xml:space="preserve">
          <source>ES6 Class Mocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e2d49f8d0560f741ac8577a93b663178bd7029" translate="yes" xml:space="preserve">
          <source>ES6 classes are constructor functions with some syntactic sugar. Therefore, any mock for an ES6 class must be a function or an actual ES6 class (which is, again, another function). So you can mock them using &lt;a href=&quot;mock-functions&quot;&gt;mock functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a979ca27d4f6a8704957153c1cfba9c7ff2928a" translate="yes" xml:space="preserve">
          <source>Enables automatic mocking in the module loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54bd6397692c956d8a24ca7382912f74c27ec19" translate="yes" xml:space="preserve">
          <source>Ensure that your snapshots are readable by keeping them focused, short, and by using tools that enforce these stylistic conventions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6165137242ac2de05a56584d9eb719723b240e" translate="yes" xml:space="preserve">
          <source>Ensures that a value matches the most recent snapshot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="9d818071488cd0fd15915face926b0ea26228d9d" translate="yes" xml:space="preserve">
          <source>Enzyme</source>
          <target state="translated">Enzyme</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">обработка ошибок</target>
        </trans-unit>
        <trans-unit id="6e250d15915a7dec07d85e3c69b7afec141c65b4" translate="yes" xml:space="preserve">
          <source>Errors can be handled using the &lt;code&gt;.catch&lt;/code&gt; method. Make sure to add &lt;code&gt;expect.assertions&lt;/code&gt; to verify that a certain number of assertions are called. Otherwise a fulfilled promise would not fail the test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc0f94d2d9aec32c6363119390d09ce3e2d82c5" translate="yes" xml:space="preserve">
          <source>Even though the call to &lt;code&gt;test&lt;/code&gt; will return right away, the test doesn't complete until the promise resolves as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181adc1fd91d7f613b0b29c21d874c50ec7c2a70" translate="yes" xml:space="preserve">
          <source>Every remaining file combined has less than 50% coverage (&lt;code&gt;global&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="cb707350932674779ac756d02c39f235519b003b" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;jest.setup.js&lt;/code&gt; file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf7849f7d6f11a7ab97ade4dda544885008f4d9" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;setupFilesAfterEnv&lt;/code&gt; array in a jest.config.js:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbaf433fef36ac3533442306ff42b392e258bb9" translate="yes" xml:space="preserve">
          <source>Example in a test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3724b80ab87b149dfc415f2947aa5d33aebb6cf1" translate="yes" xml:space="preserve">
          <source>Example reporter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc6113b2c0f485941bfab51b94f31a114ec2df2" translate="yes" xml:space="preserve">
          <source>Example serializer module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c6a3e7251096dba7461d173198c7d8db714d67" translate="yes" xml:space="preserve">
          <source>Example snapshot resolver module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f064f0c6b85d5dffb3101177b89f9992c1c9c7" translate="yes" xml:space="preserve">
          <source>Example test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">Пример использования:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="e7ff0674cdf6ffae58fcf1d17cf527103ca0f99c" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/bower_components/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="be81be2dc796bfe648c0ffaec826677af8dbaae5" translate="yes" xml:space="preserve">
          <source>Examples of dependencies that might be considered &quot;implementation details&quot; are things ranging from language built-ins (e.g. Array.prototype methods) to highly common utility methods (e.g. underscore/lo-dash, array utilities etc) and entire libraries like React.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8555073aa38480ab4d24bc6e10b3c3a6d435c74a" translate="yes" xml:space="preserve">
          <source>Examples of such compilers include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416308f6796b161308eac10d19357bbbc2a72314" translate="yes" xml:space="preserve">
          <source>Examples of watch plugins include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="1313d360bb16a7b6138236da32b21f4e7ed7a7ba" translate="yes" xml:space="preserve">
          <source>Executes only the macro task queue (i.e. all tasks queued by &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt; and &lt;code&gt;setImmediate()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb459b18680d2e43398c41cf444b3d8402f2523" translate="yes" xml:space="preserve">
          <source>Executes only the macro-tasks that are currently pending (i.e., only the tasks that have been queued by &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt; up to this point). If any of the currently pending macro-tasks schedule new macro-tasks, those new tasks will not be executed by this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4f4acc11d792baa1caf501e7e5f8ba241c5044" translate="yes" xml:space="preserve">
          <source>Exhausts all tasks queued by &lt;code&gt;setImmediate()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4db7db82b90f39ee739e36a7b63a98bed58ed23" translate="yes" xml:space="preserve">
          <source>Exhausts both the &lt;strong&gt;macro&lt;/strong&gt;-task queue (i.e., all tasks queued by &lt;code&gt;setTimeout()&lt;/code&gt;, &lt;code&gt;setInterval()&lt;/code&gt;, and &lt;code&gt;setImmediate()&lt;/code&gt;) and the &lt;strong&gt;micro&lt;/strong&gt;-task queue (usually interfaced in node via &lt;code&gt;process.nextTick&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8147ef3f4371ae39d61271bddec0259649620d" translate="yes" xml:space="preserve">
          <source>Exhausts the &lt;strong&gt;micro&lt;/strong&gt;-task queue (usually interfaced in node via &lt;code&gt;process.nextTick&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fc1be971a32518b08bb4967f47c3e29fc379b9" translate="yes" xml:space="preserve">
          <source>Expect</source>
          <target state="translated">Expect</target>
        </trans-unit>
        <trans-unit id="5ace91ad2cbf9bda63ef9585bd51f774c05c729c" translate="yes" xml:space="preserve">
          <source>Explicitly supplies the mock object that the module system should return for the specified module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad5808b4c7ea92e7c146eae0b94df7ca7d7179a" translate="yes" xml:space="preserve">
          <source>Exports a function that converts any JavaScript value into a human-readable string. Supports all built-in JavaScript types out of the box and allows extension for application-specific types via user-defined plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa5941d8206e78d8b9ca13243802ebceaeaed32" translate="yes" xml:space="preserve">
          <source>Express.js</source>
          <target state="translated">Express.js</target>
        </trans-unit>
        <trans-unit id="c7794e96c54b2b405e2be63ffda3e89b9afeb2a1" translate="yes" xml:space="preserve">
          <source>Failed snapshots can also be updated interactively in watch mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41c8da6c1bdd48b470d7efc6bf68d044e506f33" translate="yes" xml:space="preserve">
          <source>Finally tests would look as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d6a7dc26ea6d1316b486419821aae0420ac220" translate="yes" xml:space="preserve">
          <source>Finally we can close the puppeteer instance and clean-up the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e7714725872b9c1984e5322d6f02dd30da60a2" translate="yes" xml:space="preserve">
          <source>Finally, in order to make it less demanding to assert how mock functions have been called, we've added some custom matcher functions for you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ea460e76f8e03e89080e3127909c8138d82a71" translate="yes" xml:space="preserve">
          <source>Finally, run &lt;code&gt;yarn test&lt;/code&gt; or &lt;code&gt;npm run test&lt;/code&gt; and Jest will print this message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4e9242ce7c9aedcbc07728e61f3c9ca615c3c8" translate="yes" xml:space="preserve">
          <source>Finally, set &lt;code&gt;jest.config.js&lt;/code&gt; to read from these files. (The &lt;code&gt;jest-puppeteer&lt;/code&gt; preset does something like this under the hood.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab0f38c4058b80ab0f4c885e3986fc16770c677" translate="yes" xml:space="preserve">
          <source>Finally, we need an environment which supports dynamic importing. Please see &lt;a href=&quot;getting-started#using-babel&quot;&gt;Using Babel&lt;/a&gt; for the initial setup. Then add the plugin &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-dynamic-import-node&quot;&gt;babel-plugin-dynamic-import-node&lt;/a&gt;, or an equivalent, to your Babel config to enable dynamic importing in Node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c40bfe3ca4ca3e6970c1ba2f427bc5cf0ac97e5" translate="yes" xml:space="preserve">
          <source>Find and run the tests that cover a space separated list of source files that were passed in as arguments. Useful for pre-commit hook integration to run the minimal amount of tests necessary. Can be used together with &lt;code&gt;--coverage&lt;/code&gt; to include a test coverage for the source files, no duplicate &lt;code&gt;--collectCoverageFrom&lt;/code&gt; arguments needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6383d1303f59cd8ac9d056a3ec5b8a0155117bc7" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;@shelf/jest-dynamodb&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc88fb87447ec13c40c34c214ea754c225ddc5c9" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;@shelf/jest-mongodb&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee562eadcf9ddab28fe2316718a764478b89680" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;jest-puppeteer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558ef585a8582382dd2312c86147f35d19fd7f2a" translate="yes" xml:space="preserve">
          <source>First row of variable name column headings separated with &lt;code&gt;|&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49166127081da4be02dce4127fa195a83c32997f" translate="yes" xml:space="preserve">
          <source>First, enable Babel support in Jest as documented in the &lt;a href=&quot;getting-started#using-babel&quot;&gt;Getting Started&lt;/a&gt; guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4fc028d306fad456b0b3c8d93f171ca540a302" translate="yes" xml:space="preserve">
          <source>First, you write a test, calling &lt;code&gt;.toMatchInlineSnapshot()&lt;/code&gt; with no arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28e9e3ebcc459ad6465344f6b958b9cb52a1efe" translate="yes" xml:space="preserve">
          <source>Follow the &lt;a href=&quot;https://twitter.com/fbjest&quot;&gt;Jest Twitter account&lt;/a&gt; and &lt;a href=&quot;https://jestjs.io/blog/&quot;&gt;blog&lt;/a&gt; to find out what's happening in the world of Jest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2c453348c56f383fc00c98d57438686b82791f" translate="yes" xml:space="preserve">
          <source>For a complete list of matchers, check out the &lt;a href=&quot;expect&quot;&gt;reference docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710d3ddee3d05ae5ac4aab2c9b427bcb07986d80" translate="yes" xml:space="preserve">
          <source>For additional Jest matchers maintained by the Jest Community check out &lt;a href=&quot;https://github.com/jest-community/jest-extended&quot;&gt;&lt;code&gt;jest-extended&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b2aa71d87b57fd9d29b8331034a72dff8b8da9" translate="yes" xml:space="preserve">
          <source>For an example of how to use Jest with Webpack with React, Redux, and Node, you can view one &lt;a href=&quot;https://github.com/jenniferabowd/jest_react_redux_node_webpack_complex_example&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff533ca8de12b70302d788874c5ec33c12f132e5" translate="yes" xml:space="preserve">
          <source>For an individual test file, an added module precedes any modules from &lt;code&gt;snapshotSerializers&lt;/code&gt; configuration, which precede the default snapshot serializers for built-in JavaScript types and for React elements. The last module added is the first module tested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c20f94a38a3d142e50b602bce344f49a6c0fbbf" translate="yes" xml:space="preserve">
          <source>For cases where we have methods that are typically chained (and thus always need to return &lt;code&gt;this&lt;/code&gt;), we have a sugary API to simplify this in the form of a &lt;code&gt;.mockReturnThis()&lt;/code&gt; function that also sits on all mocks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dcf53a0abd5dceefdabe8547430b633eb5fc312" translate="yes" xml:space="preserve">
          <source>For environments with variable CPUs available, you can use percentage based configuration: &lt;code&gt;--maxWorkers=50%&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199cc1fa8955d4aa67143d0f4f14e4334b7f680c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;.toEqual&lt;/code&gt; and &lt;code&gt;.toBe&lt;/code&gt; behave differently in this test suite, so all the tests pass:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593913af50b6363a01b6e27cb17d3a8f783e3f15" translate="yes" xml:space="preserve">
          <source>For example, Jest ships with several plug-ins to &lt;code&gt;jasmine&lt;/code&gt; that work by monkey-patching the jasmine API. If you wanted to add even more jasmine plugins to the mix (or if you wanted some custom, project-wide matchers for example), you could do so in these modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97147f311fbef2d76543271148af18e8f65cb90" translate="yes" xml:space="preserve">
          <source>For example, compare:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b9f410a3e63e11e11d728aa4b998dca59892fd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;getAllFlavors()&lt;/code&gt; returns an array of flavors and you want to be sure that &lt;code&gt;lime&lt;/code&gt; is in there, you can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12258129998b33cad901597baea7bc212492df25" translate="yes" xml:space="preserve">
          <source>For example, if both &lt;code&gt;initializeCityDatabase&lt;/code&gt; and &lt;code&gt;clearCityDatabase&lt;/code&gt; returned promises, and the city database could be reused between tests, we could change our test code to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047e33c60bee55f41c10a3ae41e4a59ed4c6ef04" translate="yes" xml:space="preserve">
          <source>For example, if you have a &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/Clock.react.js&quot;&gt;Clock&lt;/a&gt; component that uses &lt;code&gt;Date.now()&lt;/code&gt;, the snapshot generated from this component will be different every time the test case is run. In this case we can &lt;a href=&quot;mock-functions&quot;&gt;mock the Date.now() method&lt;/a&gt; to return a consistent value every time the test is run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c52624003569af07b46970b0fc720da677fe0f5" translate="yes" xml:space="preserve">
          <source>For example, if you have tests in source files named with &lt;code&gt;.t.js&lt;/code&gt; extension as following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ce97754ad0ae68a81e69708826f13c59f1a71e" translate="yes" xml:space="preserve">
          <source>For example, if your code depends on a third party native video component called &lt;code&gt;react-native-video&lt;/code&gt; you might want to stub it out with a manual mock like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594cf95e63a36ce4ead65bcac2606fb4793f5b72" translate="yes" xml:space="preserve">
          <source>For example, if your tests call &lt;code&gt;Math&lt;/code&gt; often, you can pass it by setting &lt;code&gt;extraGlobals&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1f5a22319beabdfbabd11912aaeb825ac6e178" translate="yes" xml:space="preserve">
          <source>For example, let's say &lt;code&gt;fetchBeverageList()&lt;/code&gt; returns a promise that is supposed to resolve to a list that has &lt;code&gt;lemon&lt;/code&gt; in it. You can test this with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91bf2dd9d08b2408d6850dcb0015666facf63d27" translate="yes" xml:space="preserve">
          <source>For example, let's say that &lt;code&gt;drinkFlavor&lt;/code&gt; is coded like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1756cef91c9a3477b1322242e385d60cc54ab610" translate="yes" xml:space="preserve">
          <source>For example, let's say that &lt;code&gt;fetchData&lt;/code&gt;, instead of using a callback, returns a promise that is supposed to resolve to the string &lt;code&gt;'peanut butter'&lt;/code&gt;. We could test it with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f15af66e6a6e677b2e452f62fe482a06d1fa9e2" translate="yes" xml:space="preserve">
          <source>For example, let's say that several tests interact with a database of cities. You have a method &lt;code&gt;initializeCityDatabase()&lt;/code&gt; that must be called before each of these tests, and a method &lt;code&gt;clearCityDatabase()&lt;/code&gt; that must be called after each of these tests. You can do this with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6dbac819240657572137dc7fbd2f85952399df" translate="yes" xml:space="preserve">
          <source>For example, let's say that we expect an &lt;code&gt;onPress&lt;/code&gt; function to be called with an &lt;code&gt;Event&lt;/code&gt; object, and all we need to verify is that the event has &lt;code&gt;event.x&lt;/code&gt; and &lt;code&gt;event.y&lt;/code&gt; properties. We can do that with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874efdb115adcb599b6389e915c72466eb139681" translate="yes" xml:space="preserve">
          <source>For example, let's say that we have a few functions that all deal with state. &lt;code&gt;prepareState&lt;/code&gt; calls a callback with a state object, &lt;code&gt;validateState&lt;/code&gt; runs on that state object, and &lt;code&gt;waitOnState&lt;/code&gt; returns a promise that waits until all &lt;code&gt;prepareState&lt;/code&gt; callbacks complete. We can test this with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b90133a1da2bd721be03a9878aced8ee87402d1" translate="yes" xml:space="preserve">
          <source>For example, let's say that we have a function &lt;code&gt;doAsync&lt;/code&gt; that receives two callbacks &lt;code&gt;callback1&lt;/code&gt; and &lt;code&gt;callback2&lt;/code&gt;, it will asynchronously call both of them in an unknown order. We can test this with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbbbc61e2c5d99dfb2d92614d0dd1192b0d88661" translate="yes" xml:space="preserve">
          <source>For example, let's say that you can register a beverage with a &lt;code&gt;register&lt;/code&gt; function, and &lt;code&gt;applyToAll(f)&lt;/code&gt; should apply the function &lt;code&gt;f&lt;/code&gt; to all registered beverages. To make sure this works, you could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931d136a254e4d07f405b22f0ffa92a1088a08ec" translate="yes" xml:space="preserve">
          <source>For example, let's say that you have a &lt;code&gt;fetchData(callback)&lt;/code&gt; function that fetches some data and calls &lt;code&gt;callback(data)&lt;/code&gt; when it is complete. You want to test that this returned data is the string &lt;code&gt;'peanut butter'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40273c01c92ebe97ba2ea977841c404bf2c262a8" translate="yes" xml:space="preserve">
          <source>For example, let's say we had not just a city database, but also a food database. We could do different setup for different tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a8741fbad45210a09db8ad6539e976d1dec113" translate="yes" xml:space="preserve">
          <source>For example, let's say you had these tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144429e39562897fbccf4b94d4f8adfc39339a49" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a &lt;code&gt;drinkAll(drink, flavour)&lt;/code&gt; function that takes a &lt;code&gt;drink&lt;/code&gt; function and applies it to all available beverages. You might want to check that &lt;code&gt;drink&lt;/code&gt; gets called for &lt;code&gt;'lemon'&lt;/code&gt;, but not for &lt;code&gt;'octopus'&lt;/code&gt;, because &lt;code&gt;'octopus'&lt;/code&gt; flavour is really weird and why would anything be octopus-flavoured? You can do that with this test suite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5e0f3cd06a5bf9c4dca1f40534b4b77ff28e3e" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a &lt;code&gt;drinkEach(drink, Array&amp;lt;flavor&amp;gt;)&lt;/code&gt; function that takes a &lt;code&gt;drink&lt;/code&gt; function and applies it to array of passed beverages. You might want to check that drink function was called exact number of times. You can do that with this test suite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a18e498dc37e770eebf9088b5657094b5df58eb" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a &lt;code&gt;drinkFlavor&lt;/code&gt; function that throws whenever the flavor is &lt;code&gt;'octopus'&lt;/code&gt;, and is coded like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0e394a329140aa320ffab5691064eca7211fef" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a mock &lt;code&gt;drink&lt;/code&gt; that returns &lt;code&gt;true&lt;/code&gt;. You can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96cb3fce436e959ed4ff1a604e78cbd23c2e2492" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a mock &lt;code&gt;drink&lt;/code&gt; that returns the name of the beverage that was consumed. You can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0ef20a9a16b71f44a801db2115dcf4ceaa7ed0" translate="yes" xml:space="preserve">
          <source>For example, the following would create a global &lt;code&gt;__DEV__&lt;/code&gt; variable set to &lt;code&gt;true&lt;/code&gt; in all test environments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071b4caddeb027fae4504867a5d3ff914e164bce" translate="yes" xml:space="preserve">
          <source>For example, this code tests that the promise rejects with reason &lt;code&gt;'octopus'&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2a13885f18e36be7159ff50e29caef2aee6935" translate="yes" xml:space="preserve">
          <source>For example, this code tests that the promise resolves and that the resulting value is &lt;code&gt;'lemon'&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd7db6ccfa8b4522705daf177fc8fdd66902a9e" translate="yes" xml:space="preserve">
          <source>For example, this code will validate some properties of the &lt;code&gt;can&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21990133d4e4885c717a863643a6c3db329fd8fc" translate="yes" xml:space="preserve">
          <source>For example, this preset &lt;code&gt;foo-bar/jest-preset.js&lt;/code&gt; will be configured as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75730b175681e09d4947af40aa96097263db660e" translate="yes" xml:space="preserve">
          <source>For example, with the following configuration jest will fail if there is less than 80% branch, line, and function coverage, or if there are more than 10 uncovered statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21691166486d6f854fcdbed969ad08f56c5be3d3" translate="yes" xml:space="preserve">
          <source>For example, with the following configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d8bc1522a1c4b58ae364d57035e63c01139aac7" translate="yes" xml:space="preserve">
          <source>For example, you might not know what exactly &lt;code&gt;essayOnTheBestFlavor()&lt;/code&gt; returns, but you know it's a really long string, and the substring &lt;code&gt;grapefruit&lt;/code&gt; should be in there somewhere. You can test this with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="ff56bde239ab874f2e956a43f1424bb53acc1ac4" translate="yes" xml:space="preserve">
          <source>For example: A mock function &lt;code&gt;f&lt;/code&gt; that has been called three times, returning &lt;code&gt;'result1'&lt;/code&gt;, throwing an error, and then returning &lt;code&gt;'result2'&lt;/code&gt;, would have a &lt;code&gt;mock.results&lt;/code&gt; array that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d872a792c7892418e5f9ff3ed51e783257317905" translate="yes" xml:space="preserve">
          <source>For example: A mock function &lt;code&gt;f&lt;/code&gt; that has been called twice, with the arguments &lt;code&gt;f('arg1', 'arg2')&lt;/code&gt;, and then with the arguments &lt;code&gt;f('arg3', 'arg4')&lt;/code&gt;, would have a &lt;code&gt;mock.calls&lt;/code&gt; array that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cd0da2a66dfee53a78bdc3fd98cf8483f85a33" translate="yes" xml:space="preserve">
          <source>For example: A mock function that has been instantiated twice would have the following &lt;code&gt;mock.instances&lt;/code&gt; array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c176f04f272523170bec5099eee267107d1f94" translate="yes" xml:space="preserve">
          <source>For floating point equality, use &lt;code&gt;toBeCloseTo&lt;/code&gt; instead of &lt;code&gt;toEqual&lt;/code&gt;, because you don't want a test to depend on a tiny rounding error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c045e0e7243305deaa4aee87493fdfd39783b37b" translate="yes" xml:space="preserve">
          <source>For stability and safety reasons, only part of the global configuration keys can be updated with &lt;code&gt;updateConfigAndRun&lt;/code&gt;. The current white list is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66fb40c58c7f7d3b21d1398dcbcf990f95330c9" translate="yes" xml:space="preserve">
          <source>For the contrived example, the mock might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf5108e3716a31ac868c82b64f26462d0db96cf" translate="yes" xml:space="preserve">
          <source>For the full list of methods and argument types see &lt;code&gt;Reporter&lt;/code&gt; interface in &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-reporters/src/types.ts&quot;&gt;packages/jest-reporters/src/types.ts&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c50f795c83753fddbef63571049b5a7a72e84b" translate="yes" xml:space="preserve">
          <source>For these cases, Jest allows providing an asymmetric matcher for any property. These matchers are checked before the snapshot is written or tested, and then saved to the snapshot file instead of the received value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b7572af95fd60bcf8235bd8bc18e747afefdc9" translate="yes" xml:space="preserve">
          <source>Force Jest to exit after all tests have completed running. This is useful when resources set up by test code cannot be adequately cleaned up. &lt;em&gt;Note: This feature is an escape-hatch. If Jest doesn't exit at the end of a test run, it means external resources are still being held on to or timers are still pending in your code. It is advised to tear down external resources after each test to make sure Jest can shut down cleanly. You can use &lt;code&gt;--detectOpenHandles&lt;/code&gt; to help track it down.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a8a4fbef38bbbe48000abe9f4946c616769cb5" translate="yes" xml:space="preserve">
          <source>Forces test results output highlighting even if stdout is not a TTY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a47003cfd2a3396a2450eecc7022eb5baf66b2" translate="yes" xml:space="preserve">
          <source>Framework Guides</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">Часто задаваемые вопросы</target>
        </trans-unit>
        <trans-unit id="79e9687ea7f127fc79ca8e5c0f48f0aeee5eb4b5" translate="yes" xml:space="preserve">
          <source>From here you can choose to update that snapshot or skip to the next:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61384321378d81043daaf7aa5004f9649b760e53" translate="yes" xml:space="preserve">
          <source>GatsbyJS</source>
          <target state="translated">GatsbyJS</target>
        </trans-unit>
        <trans-unit id="75fabb5a96311113ca298de2d0ecaaa2aae1996e" translate="yes" xml:space="preserve">
          <source>General Advice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ffaf821b2d9a8192a641c430a1e7c2be181a98" translate="yes" xml:space="preserve">
          <source>Generate a basic configuration file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eff11ad6cc06e2f1ac1a723dc83bfd6e1768cde" translate="yes" xml:space="preserve">
          <source>Generate a basic configuration file. Based on your project, Jest will ask you a few questions that will help to generate a &lt;code&gt;jest.config.js&lt;/code&gt; file with a short description for each option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c15ec8813d8414ee1697eec1942000cc70d8ec" translate="yes" xml:space="preserve">
          <source>Generate unique test titles by positionally injecting parameters with &lt;a href=&quot;https://nodejs.org/api/util.html#util_util_format_format_args&quot;&gt;&lt;code&gt;printf&lt;/code&gt; formatting&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54dc9738cd540bb6ba39267578b63bf772cd9d8" translate="yes" xml:space="preserve">
          <source>Generating code coverage for test files using Puppeteer is currently not possible if your test uses &lt;code&gt;page.$eval&lt;/code&gt;, &lt;code&gt;page.$$eval&lt;/code&gt; or &lt;code&gt;page.evaluate&lt;/code&gt; as the passed function is executed outside of Jest's scope. Check out &lt;a href=&quot;https://github.com/facebook/jest/issues/7962#issuecomment-495272339&quot;&gt;issue #7962&lt;/a&gt; on GitHub for a workaround.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd13d25dc262c99d9c8684b86741b04a10d005f" translate="yes" xml:space="preserve">
          <source>Get a deeper insight into testing a working React Native app example by reading the following series: &lt;a href=&quot;https://callstack.com/blog/testing-react-native-with-the-new-jest-part-1-snapshots-come-into-play/&quot;&gt;Part 1: Jest &amp;ndash; Snapshot come into play&lt;/a&gt; and &lt;a href=&quot;https://callstack.com/blog/testing-react-native-with-the-new-jest-part-2-redux-snapshots-for-your-actions-and-reducers/&quot;&gt;Part 2: Jest &amp;ndash; Redux Snapshots for your Actions and Reducers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799d464814c35b3c4f2bd970cbd9a5bc23b78618" translate="yes" xml:space="preserve">
          <source>Gets called at the end of every test run. It has the test results as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df67fe80f33086b3ebe3ae445504840168a6c71b" translate="yes" xml:space="preserve">
          <source>Gets called whenever there is a change in the file system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0521fc5aa1b1f1dced820bdf16633c65d66fda68" translate="yes" xml:space="preserve">
          <source>Given the name of a module, use the automatic mocking system to generate a mocked version of the module for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f827c66e7e04723ed3fa1ab0945dff3f10b9b83" translate="yes" xml:space="preserve">
          <source>Globals</source>
          <target state="translated">Globals</target>
        </trans-unit>
        <trans-unit id="66e11c5171519fb11b18776bac2f49b3ef8097c8" translate="yes" xml:space="preserve">
          <source>Go ahead and accept the changes by running the above command. You may also use the equivalent single-character &lt;code&gt;-u&lt;/code&gt; flag to re-generate snapshots if you prefer. This will re-generate snapshot artifacts for all failing snapshot tests. If we had any additional failing snapshot tests due to an unintentional bug, we would need to fix the bug before re-generating snapshots to avoid recording snapshots of the buggy behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="9492d9787956a33e31c7c7ed4f3132bf12917883" translate="yes" xml:space="preserve">
          <source>Guides: Introduction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1cb6486159f8fb716bc26925fc1b77ba78c39a" translate="yes" xml:space="preserve">
          <source>Handling Static Assets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8c7c374697b9a0908767f6b8abbf4ca28b782b" translate="yes" xml:space="preserve">
          <source>Help:</source>
          <target state="translated">Help:</target>
        </trans-unit>
        <trans-unit id="8590c3106f1d77bf4a9ae5f0686ed9ef3f06f737" translate="yes" xml:space="preserve">
          <source>Here is a brief overview:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b82314997735c45eace267e10004814f476844b" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;afterAll&lt;/code&gt; ensures that &lt;code&gt;cleanUpDatabase&lt;/code&gt; is called after all tests run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53ee15f468af76ea014ce3192ad96c9f2769b46" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;afterEach&lt;/code&gt; ensures that &lt;code&gt;cleanUpDatabase&lt;/code&gt; is called after each test runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2c6ca85b8f247386b644a9b9448050fb98ba8b" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;beforeAll&lt;/code&gt; ensures that the database is set up before tests run. If setup was synchronous, you could do this without &lt;code&gt;beforeAll&lt;/code&gt;. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c986af0e0e93ca9be7580639b72afacb632a1fd1" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;beforeEach&lt;/code&gt; ensures that the database is reset for each test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11a344028eaa93e6dbdbf6a41de62398cbc4d4f" translate="yes" xml:space="preserve">
          <source>Here we enable fake timers by calling &lt;code&gt;jest.useFakeTimers();&lt;/code&gt;. This mocks out setTimeout and other timer functions with mock functions. If running multiple tests inside of one file or describe block, &lt;code&gt;jest.useFakeTimers();&lt;/code&gt; can be called before each test manually or with a setup function such as &lt;code&gt;beforeEach&lt;/code&gt;. Not doing so will result in the internal usage counter not being reset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3296e4a9a937d655fc487d89d44cc0a7f825b550" translate="yes" xml:space="preserve">
          <source>Here's a complete test file which uses the module factory parameter to &lt;code&gt;jest.mock&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23bc1c8fad4267f600ff0f8ca654e743fe48303" translate="yes" xml:space="preserve">
          <source>Here's a contrived example where we have a module that provides a summary of all the files in a given directory. In this case we use the core (built in) &lt;code&gt;fs&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0ef58a95e5aba79279e07fb2a779d1b19111a2" translate="yes" xml:space="preserve">
          <source>Here's a snapshot matcher that trims a string to store for a given length, &lt;code&gt;.toMatchTrimmedSnapshot(length)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ca12756b3286d1c69b00aa0dfabdef931475e9" translate="yes" xml:space="preserve">
          <source>Here's an example of the GlobalSetup script</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a016b4fe86ae49e4048497e86b5fd1a869d608" translate="yes" xml:space="preserve">
          <source>Here's how to run Jest on files matching &lt;code&gt;my-test&lt;/code&gt;, using &lt;code&gt;config.json&lt;/code&gt; as a configuration file and display a native OS notification after the run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa62494bb2468633777100c6526141484e1a9ce8" translate="yes" xml:space="preserve">
          <source>Here's the code of &lt;a href=&quot;https://github.com/xfumihiro/jest-puppeteer-example&quot;&gt;full working example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b880c8aa5a70aa5b6710448f8f53b517ba3960" translate="yes" xml:space="preserve">
          <source>Hooking into Jest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fb52372b98a249bee2e92c10585f1138a3a8d1" translate="yes" xml:space="preserve">
          <source>How do I resolve conflicts within snapshot files?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139e29398f2627a8696250a9f26ea0f35d4fe9da" translate="yes" xml:space="preserve">
          <source>However, if you ran that test you would find that the &lt;code&gt;createUser&lt;/code&gt; function would fail, throwing the error: &lt;code&gt;TypeError: response.text is not a function&lt;/code&gt;. This is because the &lt;code&gt;Response&lt;/code&gt; class you've imported from &lt;code&gt;node-fetch&lt;/code&gt; has been mocked (due to the &lt;code&gt;jest.mock&lt;/code&gt; call at the top of the test file) so it no longer behaves the way it should.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a65fb527f26996f958a4c7a7636697c68a57ae" translate="yes" xml:space="preserve">
          <source>However, there are some &lt;a href=&quot;https://babeljs.io/docs/en/next/babel-plugin-transform-typescript.html#caveats&quot;&gt;caveats&lt;/a&gt; to using TypeScript with Babel. Because TypeScript support in Babel is transpilation, Jest will not type-check your tests as they are run. If you want that, you can use &lt;a href=&quot;https://github.com/kulshekhar/ts-jest&quot;&gt;ts-jest&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf42de47519a8be85813abc9dbcf79a2336fd084" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;afterAll&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it runs at the end of the describe block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d6e89fb8810e2839bb626d3834bcbc4b498e76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;afterEach&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it only runs after the tests that are inside this describe block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06fd5213f105f4db8f2c74d9197183295af8cfef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;beforeAll&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it runs at the beginning of the describe block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48344c733bdd18ab3274d53de4f2dd945448596" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;beforeEach&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it runs for each test in the describe block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c26c494506944de906e943951a2399f7620cb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;done()&lt;/code&gt; is never called, the test will fail, which is what you want to happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1981223ccef65cb683fc43fc578f449a3eee3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;moduleNameMapper&lt;/code&gt; cannot fulfill your requirements, you can use Jest's &lt;a href=&quot;configuration#transform-objectstring-pathtotransformer--pathtotransformer-object&quot;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; config option to specify how assets are transformed. For example, a transformer that returns the basename of a file (such that &lt;code&gt;require('logo.jpg');&lt;/code&gt; returns &lt;code&gt;'logo'&lt;/code&gt;) can be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df09d1e5934f36cd1398174cf6c7629249a09bf" translate="yes" xml:space="preserve">
          <source>If a promise doesn't resolve at all, this error might be thrown:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31564de21c2565396696cb413016ff78b9a87fd" translate="yes" xml:space="preserve">
          <source>If a test is failing, one of the first things to check should be whether the test is failing when it's the only test that runs. To run only one test with Jest, temporarily change that &lt;code&gt;test&lt;/code&gt; command to a &lt;code&gt;test.only&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1368241bb9b6a677c253777f28e276302847afe6" translate="yes" xml:space="preserve">
          <source>If custom reporters are specified, the default Jest reporters will be overridden. To keep default reporters, &lt;code&gt;default&lt;/code&gt; can be passed as a module name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35c3c8f0f049c2d367440e4fa528eaf56ee5ab8" translate="yes" xml:space="preserve">
          <source>If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the &lt;code&gt;expect&lt;/code&gt; function. For example, use &lt;code&gt;equals&lt;/code&gt; method of &lt;code&gt;Buffer&lt;/code&gt; class to assert whether or not buffers contain the same content:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8531076ffab17b1e6a3078dd99ca2b637f2d89a8" translate="yes" xml:space="preserve">
          <source>If globs or paths are specified alongside &lt;code&gt;global&lt;/code&gt;, coverage data for matching paths will be subtracted from overall coverage and thresholds will be applied independently. Thresholds for globs are applied to all files matching the glob. If the file specified by path is not found, error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a21f6979cdac3c1b9ad4e08a0c6637f2d4dfa2" translate="yes" xml:space="preserve">
          <source>If some code uses a method which JSDOM (the DOM implementation used by Jest) hasn't implemented yet, testing it is not easily possible. This is e.g. the case with &lt;code&gt;window.matchMedia()&lt;/code&gt;. Jest returns &lt;code&gt;TypeError: window.matchMedia is not a function&lt;/code&gt; and doesn't properly execute the test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17517ca3e186444904834c38de35490f5610cc1b" translate="yes" xml:space="preserve">
          <source>If the module you are mocking is a Node module (e.g.: &lt;code&gt;lodash&lt;/code&gt;), the mock should be placed in the &lt;code&gt;__mocks__&lt;/code&gt; directory adjacent to &lt;code&gt;node_modules&lt;/code&gt; (unless you configured &lt;a href=&quot;configuration#roots-arraystring&quot;&gt;&lt;code&gt;roots&lt;/code&gt;&lt;/a&gt; to point to a folder other than the project root) and will be &lt;strong&gt;automatically&lt;/strong&gt; mocked. There's no need to explicitly call &lt;code&gt;jest.mock('module_name')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829141299a9251eaf1ce7f20d372e903be5b7bd4" translate="yes" xml:space="preserve">
          <source>If the user provided a custom configuration, it will be passed as an argument to the plugin constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0c525e5e5ddd2de8c8d823c3e142628ec07ed1" translate="yes" xml:space="preserve">
          <source>If you add a snapshot serializer in individual test files instead of to adding it to &lt;code&gt;snapshotSerializers&lt;/code&gt; configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30fd956763850c31b9ce0b4521be9bc8f3c1c8bb" translate="yes" xml:space="preserve">
          <source>If you are interested in learning more about how Jest works, what the architecture behind the framework is, and how Jest is split up into individual reusable packages, check out this video:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18026771171516f84ca810200b4fd3d6a03c8bac" translate="yes" xml:space="preserve">
          <source>If you are new to React, we recommend using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;. It is ready to use and &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests#docsNav&quot;&gt;ships with Jest&lt;/a&gt;! You will only need to add &lt;code&gt;react-test-renderer&lt;/code&gt; for rendering snapshots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a18016808e001b4a11dfaa241f7321f12becaa6" translate="yes" xml:space="preserve">
          <source>If you are seeing coverage output such as...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3538d9b6ba0bfe52daac18493de01cba0271f06a" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;AVA&lt;/a&gt;, &lt;a href=&quot;https://github.com/chaijs/chai&quot;&gt;Chai&lt;/a&gt;, &lt;a href=&quot;https://github.com/Automattic/expect.js&quot;&gt;Expect.js (by Automattic)&lt;/a&gt;, &lt;a href=&quot;https://github.com/jasmine/jasmine&quot;&gt;Jasmine&lt;/a&gt;, &lt;a href=&quot;https://github.com/mochajs/mocha&quot;&gt;Mocha&lt;/a&gt;, &lt;a href=&quot;https://github.com/thlorenz/proxyquire&quot;&gt;proxyquire&lt;/a&gt;, &lt;a href=&quot;https://github.com/shouldjs/should.js&quot;&gt;Should.js&lt;/a&gt; or &lt;a href=&quot;https://github.com/substack/tape&quot;&gt;Tape&lt;/a&gt; you can use the third-party &lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;jest-codemods&lt;/a&gt; to do most of the dirty migration work. It runs a code transformation on your codebase using &lt;a href=&quot;https://github.com/facebook/jscodeshift&quot;&gt;jscodeshift&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16afeeb67bb4f44c59d6fb688fc49403f7d400f9" translate="yes" xml:space="preserve">
          <source>If you are using AVA, Expect.js (by Automattic), Jasmine, Mocha, proxyquire, Should.js or Tape you can automatically migrate with Jest Codemods (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d950d3cb77c0e4d69b966651442d248b368ac31b" translate="yes" xml:space="preserve">
          <source>If you are using Facebook's &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;&lt;code&gt;create-react-app&lt;/code&gt;&lt;/a&gt;, in the Jest run/debug configuration specify the path to the &lt;code&gt;react-scripts&lt;/code&gt; package in the Jest package field and add &lt;code&gt;--env=jsdom&lt;/code&gt; to the Jest options field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04856c5821d9738bc23d4d6c7e49ea0d12a4e919" translate="yes" xml:space="preserve">
          <source>If you are using Facebook's &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;&lt;code&gt;create-react-app&lt;/code&gt;&lt;/a&gt;, you can debug your Jest tests with the following configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616d051e539968c48db9eb4e4947c7fe6ae3168c" translate="yes" xml:space="preserve">
          <source>If you are using Jasmine, or a Jasmine like API (for example &lt;a href=&quot;https://mochajs.org&quot;&gt;Mocha&lt;/a&gt;), Jest should be mostly compatible, which makes it less complicated to migrate to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a321ef2867f26ae4a6883b3f6fd1258c705b7b4" translate="yes" xml:space="preserve">
          <source>If you define an ES6 class using the same filename as the mocked class in the &lt;code&gt;__mocks__&lt;/code&gt; folder, it will serve as the mock. This class will be used in place of the real class. This allows you to inject a test implementation for the class, but does not provide a way to spy on calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed89a7be5b28b2da511d62933b8c9202a0453c7" translate="yes" xml:space="preserve">
          <source>If you don't need to replace the implementation of the class, this is the easiest option to set up. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785c7b2fc6591165ae39c3fd7d429eea3e2c5ec8" translate="yes" xml:space="preserve">
          <source>If you end up mocking the same modules over and over it is recommended to define these mocks in a separate file and add it to the list of &lt;code&gt;setupFiles&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a9582bd8b87124ac313d453b396a39ddd21d21" translate="yes" xml:space="preserve">
          <source>If you expect a promise to be rejected use the &lt;code&gt;.catch&lt;/code&gt; method. Make sure to add &lt;code&gt;expect.assertions&lt;/code&gt; to verify that a certain number of assertions are called. Otherwise a fulfilled promise would not fail the test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d508e058fa7773fc13858ed4af2eb2bbf552b483" translate="yes" xml:space="preserve">
          <source>If you expect a promise to be rejected use the &lt;code&gt;.rejects&lt;/code&gt; matcher. It works analogically to the &lt;code&gt;.resolves&lt;/code&gt; matcher. If the promise is fulfilled, the test will automatically fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9919159eb0a5f34daf61334b02158349c4deb0ab" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;prettier&lt;/code&gt; installed in a location where Jest can't find it, you can tell Jest how to find it using the &lt;a href=&quot;configuration#prettierpath-string&quot;&gt;&lt;code&gt;&quot;prettierPath&quot;&lt;/code&gt;&lt;/a&gt; configuration property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de2f8ea3278a9069dce525e3076d8f4531a1efb" translate="yes" xml:space="preserve">
          <source>If you have JavaScript files that are transformed by Babel, you can &lt;a href=&quot;getting-started#using-babel&quot;&gt;enable support for Babel&lt;/a&gt; by installing the &lt;code&gt;babel-jest&lt;/code&gt; plugin. Non-Babel JavaScript transformations can be handled with Jest's &lt;a href=&quot;configuration#transform-objectstring-pathtotransformer--pathtotransformer-object&quot;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; config option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7136dd51cf9e180f2a48ca203c9c72141190f47b" translate="yes" xml:space="preserve">
          <source>If you have a mock function, you can use &lt;code&gt;.toHaveBeenLastCalledWith&lt;/code&gt; to test what arguments it was last called with. For example, let's say you have a &lt;code&gt;applyToAllFlavors(f)&lt;/code&gt; function that applies &lt;code&gt;f&lt;/code&gt; to a bunch of flavors, and you want to ensure that when you call it, the last flavor it operates on is &lt;code&gt;'mango'&lt;/code&gt;. You can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0977c600c362140ee0f11a85d4e0e7f13e18104f" translate="yes" xml:space="preserve">
          <source>If you have a mock function, you can use &lt;code&gt;.toHaveBeenNthCalledWith&lt;/code&gt; to test what arguments it was nth called with. For example, let's say you have a &lt;code&gt;drinkEach(drink, Array&amp;lt;flavor&amp;gt;)&lt;/code&gt; function that applies &lt;code&gt;f&lt;/code&gt; to a bunch of flavors, and you want to ensure that when you call it, the first flavor it operates on is &lt;code&gt;'lemon'&lt;/code&gt; and the second one is &lt;code&gt;'octopus'&lt;/code&gt;. You can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993b27fa75c6ccc43f546084c9a5ed3da7f9f9a6" translate="yes" xml:space="preserve">
          <source>If you have a mock function, you can use &lt;code&gt;.toHaveReturned&lt;/code&gt; to test that the mock function successfully returned (i.e., did not throw an error) at least one time. For example, let's say you have a mock &lt;code&gt;drink&lt;/code&gt; that returns &lt;code&gt;true&lt;/code&gt;. You can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420b4fbe707501e81837408c0339f7b83dccab03" translate="yes" xml:space="preserve">
          <source>If you have a test that often fails when it's run as part of a larger suite, but doesn't fail when you run it alone, it's a good bet that something from a different test is interfering with this one. You can often fix this by clearing some shared state with &lt;code&gt;beforeEach&lt;/code&gt;. If you're not sure whether some shared state is being modified, you can also try a &lt;code&gt;beforeEach&lt;/code&gt; that logs data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bc00736b265df97dcccbb952c16a808f51eb48" translate="yes" xml:space="preserve">
          <source>If you have an existing application you'll need to install a few packages to make everything work well together. We are using the &lt;code&gt;babel-jest&lt;/code&gt; package and the &lt;code&gt;react&lt;/code&gt; babel preset to transform our code inside of the test environment. Also see &lt;a href=&quot;getting-started#using-babel&quot;&gt;using babel&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79990aa85d408f8fcea8c54e5341cb382a83ed88" translate="yes" xml:space="preserve">
          <source>If you have some work you need to do repeatedly for many tests, you can use &lt;code&gt;beforeEach&lt;/code&gt; and &lt;code&gt;afterEach&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756f402753805d9101cb2dc7198988431ec9ee20" translate="yes" xml:space="preserve">
          <source>If you have something awesome to share, feel free to reach out to us! We'd love to share your project on the awesome-jest list (&lt;a href=&quot;https://github.com/jest-community/awesome-jest/pulls&quot;&gt;send a PR here&lt;/a&gt;) or if you would like to transfer your project to the jest-community org reachout to one of the owners of the org.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d7ae11f48e4c50b3df992e0eb7601afc5a6361a" translate="yes" xml:space="preserve">
          <source>If you know how to test something, &lt;code&gt;.not&lt;/code&gt; lets you test its opposite. For example, this code tests that the best La Croix flavor is not coconut:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55dbb4d3f311b3d4eb68e5741b0d897b72ccb8b5" translate="yes" xml:space="preserve">
          <source>If you like &lt;a href=&quot;http://chaijs.com/&quot;&gt;chai&lt;/a&gt;, you can upgrade to Jest and continue using chai. However, we recommend trying out Jest's assertions and their failure messages. Jest Codemods can migrate from chai (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64089c71545ac9398fafdb10bbce2181a2f6a753" translate="yes" xml:space="preserve">
          <source>If you need more advanced functionality, you can also build your own transformer. Instead of using babel-jest, here is an example of using babel:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cd566d23f6580c1572508d5f198d62212efb88" translate="yes" xml:space="preserve">
          <source>If you need to restrict your test-runner to only run in serial rather then being executed in parallel your class should have the property &lt;code&gt;isSerial&lt;/code&gt; to be set as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352ca1b438b9b40e3f1f12e8c905d0575ee8ebf8" translate="yes" xml:space="preserve">
          <source>If you only need to run some setup code once, before any tests run, use &lt;code&gt;beforeAll&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4cf1bd9be869094293df92f2ed1d79a4685bb2" translate="yes" xml:space="preserve">
          <source>If you run Jest via &lt;code&gt;npm test&lt;/code&gt;, you can still use the command line arguments by inserting a &lt;code&gt;--&lt;/code&gt; between &lt;code&gt;npm test&lt;/code&gt; and the Jest arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786fc89b89e2b8432cf8d374c70aa7b7814df7b6" translate="yes" xml:space="preserve">
          <source>If you run Jest via &lt;code&gt;yarn test&lt;/code&gt;, you can pass the command line arguments directly as Jest arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9b34c839f0bb4065cf0cbfa5620da9d41b2be8" translate="yes" xml:space="preserve">
          <source>If you use dynamic imports (&lt;code&gt;import('some-file.js').then(module =&amp;gt; ...)&lt;/code&gt;), you need to enable the &lt;code&gt;dynamic-import-node&lt;/code&gt; plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9000a1baf94a23c5eda0e8f5bba72955e96ff9" translate="yes" xml:space="preserve">
          <source>If you want a path to be &lt;a href=&quot;#rootdir-string&quot;&gt;relative to the root directory of your project&lt;/a&gt;, please include &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; inside a path's string, like &lt;code&gt;&quot;&amp;lt;rootDir&amp;gt;/a-configs-folder&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554f70a642fd6f52b957f8ae2bf6f9d1be578ea3" translate="yes" xml:space="preserve">
          <source>If you want to inspect the cache, use &lt;code&gt;--showConfig&lt;/code&gt; and look at the &lt;code&gt;cacheDirectory&lt;/code&gt; value. If you need to clear the cache, use &lt;code&gt;--clearCache&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fda82da214d4a1bfae2a873dff3fffc4c9acd8c" translate="yes" xml:space="preserve">
          <source>If you want to run some cleanup after every test instead of after all tests, use &lt;code&gt;afterEach&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e29fce9e0a98c7b27c220dc5f9e52e9dea70cc71" translate="yes" xml:space="preserve">
          <source>If you want to run some cleanup just once, after all of the tests run, use &lt;code&gt;afterAll&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985cfb18842dcab5a2061f5fd939e231c11a1190" translate="yes" xml:space="preserve">
          <source>If you want to run something before every test instead of before any test runs, use &lt;code&gt;beforeEach&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c7d4d719f894e809c49dafe7d06515e3345af1" translate="yes" xml:space="preserve">
          <source>If you want to test that a particular function throws an error when it's called, use &lt;code&gt;toThrow&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa479dc2989b39264cd671e2e1b01fc3bc865c73" translate="yes" xml:space="preserve">
          <source>If you'd like to assert, and manipulate your rendered components you can use &lt;a href=&quot;https://github.com/kentcdodds/react-testing-library&quot;&gt;react-testing-library&lt;/a&gt;, &lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;, or React's &lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;TestUtils&lt;/a&gt;. The following two examples use react-testing-library and Enzyme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5abb36c3cf78ade7ac7c3e61eaa1bf15a7a6cf" translate="yes" xml:space="preserve">
          <source>If you'd like to build a transformer with babel support, you can also use babel-jest to compose one and pass in your custom configuration options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe8837a1b877e57fa5d26c99f5f76765b57c8f1" translate="yes" xml:space="preserve">
          <source>If you'd like to learn more about running &lt;code&gt;jest&lt;/code&gt; through the command line, take a look at the &lt;a href=&quot;cli&quot;&gt;Jest CLI Options&lt;/a&gt; page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b70976c9786f6bb152f5a17847893b3ea57a99e" translate="yes" xml:space="preserve">
          <source>If you'd like to limit which snapshot test cases get re-generated, you can pass an additional &lt;code&gt;--testNamePattern&lt;/code&gt; flag to re-record snapshots only for those tests that match the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493e22a5ff7ebb1b0bac76ca20348fbec098ff61" translate="yes" xml:space="preserve">
          <source>If you'd like to provide additional configuration for every test file, the &lt;a href=&quot;configuration#setupfiles-array&quot;&gt;&lt;code&gt;setupFiles&lt;/code&gt; configuration option&lt;/a&gt; can be used to specify setup scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904d7d5dbe5dfb9936b463c8afc5fd6ef73f873b" translate="yes" xml:space="preserve">
          <source>If you'd like to test timers, like &lt;code&gt;setTimeout&lt;/code&gt;, take a look at the &lt;a href=&quot;timer-mocks&quot;&gt;Timer mocks&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41daa174187a45b7973b50bb5da3fd6d898d179a" translate="yes" xml:space="preserve">
          <source>If you'd like to try out Jest with an existing codebase, there are a number of ways to convert to Jest:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829c5ae35e9a8ea6d6ab4a39e712800c72de37bf" translate="yes" xml:space="preserve">
          <source>If you're using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ES module imports&lt;/a&gt; then you'll normally be inclined to put your &lt;code&gt;import&lt;/code&gt; statements at the top of the test file. But often you need to instruct Jest to use a mock before modules use it. For this reason, Jest will automatically hoist &lt;code&gt;jest.mock&lt;/code&gt; calls to the top of the module (before any imports). To learn more about this and see it in action, see &lt;a href=&quot;https://github.com/kentcdodds/how-jest-mocking-works&quot;&gt;this repo&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d61bfdc856da28f2e5fd6d45fca8df20622b57a" translate="yes" xml:space="preserve">
          <source>If your code uses promises, there is a more straightforward way to handle asynchronous tests. Return a promise from your test, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb7cf87b9a1da1c03f262e7f2f52beaa2385481" translate="yes" xml:space="preserve">
          <source>If your test is long running, you may want to consider to increase the timeout by calling &lt;code&gt;jest.setTimeout&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f3aae12099b7ddfe3f20a402b497229b2307ab" translate="yes" xml:space="preserve">
          <source>Import the mock and the mock method shared by all instances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b1c9735c1b7f4127af7d7ab27db5831ecb658c" translate="yes" xml:space="preserve">
          <source>In JavaScript, there are six falsy values: &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt;. Everything else is truthy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4ae4f10df6814e92150ee1c7d3a629a5d7abd0" translate="yes" xml:space="preserve">
          <source>In depth: Understanding mock constructor functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abc59ae50f9e935393cdb945f05ee449764bb87" translate="yes" xml:space="preserve">
          <source>In order to do this you can run tests in the same thread using &lt;a href=&quot;cli#--runinband&quot;&gt;&lt;code&gt;--runInBand&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996bbd139f692ff1674caffb9c1a201da9541db8" translate="yes" xml:space="preserve">
          <source>In order to mock a constructor function, the module factory must return a constructor function. In other words, the module factory must be a function that returns a function - a higher-order function (HOF).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644861976bcc490e61ef690742a524fc490ebdcc" translate="yes" xml:space="preserve">
          <source>In order to track calls to the constructor, replace the function returned by the HOF with a Jest mock function. Create it with &lt;a href=&quot;jest-object#jestfnimplementation&quot;&gt;&lt;code&gt;jest.fn()&lt;/code&gt;&lt;/a&gt;, and then specify its implementation with &lt;code&gt;mockImplementation()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fe50509a9a46b66c2c06f2fc7d147da1de4215" translate="yes" xml:space="preserve">
          <source>In other cases you may want to mock a native module that isn't a React component. The same technique can be applied. We recommend inspecting the native module's source code and logging the module when running a react native app on a real device and then modeling a manual mock after the real module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9102da2371047bd722d0b515b5551f478299aa99" translate="yes" xml:space="preserve">
          <source>In some cases, you only need to do setup once, at the beginning of a file. This can be especially bothersome when the setup is asynchronous, so you can't do it inline. Jest provides &lt;code&gt;beforeAll&lt;/code&gt; and &lt;code&gt;afterAll&lt;/code&gt; to handle this situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b6c9124da9d2f164e70d048eada927d7685f3e" translate="yes" xml:space="preserve">
          <source>In tests you sometimes need to distinguish between &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;, but you sometimes do not want to treat these differently. Jest contains helpers that let you be explicit about what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9ae4862f96e5c36ede5f6a99e2b3637ee320d7" translate="yes" xml:space="preserve">
          <source>In that case, Jest will print this output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e505a4fa07187d3e2baaecd5d93fb006995c7f2" translate="yes" xml:space="preserve">
          <source>In the WebStorm menu &lt;code&gt;Run&lt;/code&gt; select &lt;code&gt;Edit Configurations...&lt;/code&gt;. Then click &lt;code&gt;+&lt;/code&gt; and select &lt;code&gt;Jest&lt;/code&gt;. Optionally specify the Jest configuration file, additional options, and environment variables. Save the configuration, put the breakpoints in the code, then click the green debug icon to start debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d0bc725310d5e7375a0939302ec84996aaee195" translate="yes" xml:space="preserve">
          <source>In the above implementation we expect the &lt;code&gt;request.js&lt;/code&gt; module to return a promise. We chain a call to &lt;code&gt;then&lt;/code&gt; to receive the user name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570678fe1ed00ace674c0422a21ff689d587c77f" translate="yes" xml:space="preserve">
          <source>In these cases, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are effectively syntactic sugar for the same logic as the promises example uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3642d4f1c233bd882101f40614b17fbab7b0347a" translate="yes" xml:space="preserve">
          <source>In these rare scenarios you can use this API to manually fill the slot in the module system's mock-module registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b652f7f89176ede040fc45adab5e36634e53950" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;toBe&lt;/code&gt; is the matcher function. There are a lot of different matcher functions, documented below, to help you test different things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="182fda0d71d0e8cdad09e61c342e4da86b15010a" translate="yes" xml:space="preserve">
          <source>In this case, mocking &lt;code&gt;matchMedia&lt;/code&gt; in the test file should solve the issue:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3f7577284c9c32a0e3ee6553d857ff29f2f2e7" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;expect(2 + 2)&lt;/code&gt; returns an &quot;expectation&quot; object. You typically won't do much with these expectation objects except call matchers on them. In this code, &lt;code&gt;.toBe(4)&lt;/code&gt; is the matcher. When Jest runs, it tracks all the failing matchers so that it can print out nice error messages for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcf71eeb459fb4f43d233569cc094471a4a5833" translate="yes" xml:space="preserve">
          <source>In your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e834252f464672f1c1dbeae76506145773ea65a" translate="yes" xml:space="preserve">
          <source>Indicates that test coverage information should be collected and reported in the output. This option is also aliased by &lt;code&gt;--collectCoverage&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1284d31f44064613a87f5368a4ace1fc81c96bbe" translate="yes" xml:space="preserve">
          <source>Indicates that the module system should never return a mocked version of the specified module from &lt;code&gt;require()&lt;/code&gt; (e.g. that it should always return the real module).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525344995f960a29bbb0a0780b82869722611218" translate="yes" xml:space="preserve">
          <source>Indicates whether each individual test should be reported during the run. All errors will also still be shown on the bottom after execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4810b9c6deb3cfc560d1b8be11be54439818a5" translate="yes" xml:space="preserve">
          <source>Indicates whether the coverage information should be collected while executing the test. Because this retrofits all executed files with coverage collection statements, it may significantly slow down your tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ffcf9de303be59af5e2e722fc87828180290e8" translate="yes" xml:space="preserve">
          <source>Injecting a test implementation is helpful, but you will probably also want to test whether the class constructor and methods are called with the correct parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16df8c50d3d5dd63ff045ec5082a89d1d9864d9" translate="yes" xml:space="preserve">
          <source>Inline Snapshots</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db4c16bd16f6d824e3ae08925279ff7d80be7fa7" translate="yes" xml:space="preserve">
          <source>Inline snapshots are powered by &lt;a href=&quot;https://prettier.io&quot;&gt;Prettier&lt;/a&gt;. To use inline snapshots you must have &lt;code&gt;prettier&lt;/code&gt; installed in your project. Your Prettier configuration will be respected when writing to test files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8634b51371ce9727d167fddae91a84b3084a1895" translate="yes" xml:space="preserve">
          <source>Inline snapshots behave identically to external snapshots (&lt;code&gt;.snap&lt;/code&gt; files), except the snapshot values are written automatically back into the source code. This means you can get the benefits of automatically generated snapshots without having to switch to an external file to make sure the correct value was written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94217fdf7438c2ec9d5e4178c873dbfe79b8612" translate="yes" xml:space="preserve">
          <source>Install Jest using &lt;a href=&quot;https://yarnpkg.com/en/package/jest&quot;&gt;&lt;code&gt;yarn&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6092d383d1cc73be163afe7eb2ce1f7872844a2a" translate="yes" xml:space="preserve">
          <source>Instead of literal property values in the expected object, you can use matchers, &lt;code&gt;expect.anything()&lt;/code&gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">Вместо этого:</target>
        </trans-unit>
        <trans-unit id="9cc2a78e6bbcf2a24971feabf0515729dc411624" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;.toBeCloseTo&lt;/code&gt;. Use &lt;code&gt;numDigits&lt;/code&gt; to control how many digits after the decimal point to check. For example, if you want to be sure that &lt;code&gt;0.2 + 0.1&lt;/code&gt; is equal to &lt;code&gt;0.3&lt;/code&gt; with a precision of 5 decimal digits, you can use this test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4c0946e29e0677ed77927a5a5b8175e597a81b" translate="yes" xml:space="preserve">
          <source>Instructs Jest to use fake versions of the standard timer functions (&lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, &lt;code&gt;clearTimeout&lt;/code&gt;, &lt;code&gt;clearInterval&lt;/code&gt;, &lt;code&gt;nextTick&lt;/code&gt;, &lt;code&gt;setImmediate&lt;/code&gt; and &lt;code&gt;clearImmediate&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f0e89b734a053251bf9ba130c561bca653f2ca" translate="yes" xml:space="preserve">
          <source>Instructs Jest to use the real versions of the standard timer functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580b09d323b391c56988f3afd1aa0348c802898c" translate="yes" xml:space="preserve">
          <source>Interactive Snapshot Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02513dac2749bb0bea9a23e68783f2f1b43824b8" translate="yes" xml:space="preserve">
          <source>Is it possible to apply test-driven development principles with snapshot testing?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9055c96fbca9c47e000ff8c108ec23e99fdd71fc" translate="yes" xml:space="preserve">
          <source>It fails because in JavaScript, &lt;code&gt;0.2 + 0.1&lt;/code&gt; is actually &lt;code&gt;0.30000000000000004&lt;/code&gt;. Sorry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f735d98c06c220d11d75c5397c9c1b8e52c4d4d" translate="yes" xml:space="preserve">
          <source>It is possible to override this setting in individual tests by explicitly calling &lt;code&gt;jest.mock()&lt;/code&gt; at the top of the test file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7f0fe9fa2e98d6b45b7e85870b6bebb4244c0e" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.arrayContaining&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa06d234ccf0592e6a7833abb4b44564a10ce20" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.objectContaining&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c45932d1b92f754d3092dcfc07a259652cb482f" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.stringContaining&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56fdb83f46a304e9e8a0b0082332d015e93ccfd5" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.stringMatching&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d71d3a81131ff51abfd443e0210b69c77cfc06" translate="yes" xml:space="preserve">
          <source>It's also worth noting that &lt;code&gt;setupFiles&lt;/code&gt; will execute &lt;em&gt;before&lt;/em&gt;&lt;a href=&quot;#setupfilesafterenv-array&quot;&gt;&lt;code&gt;setupFilesAfterEnv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e57c75a59ba04722961a96e662337fe62d32cd4" translate="yes" xml:space="preserve">
          <source>It's common in JavaScript for code to run asynchronously. When you have code that runs asynchronously, Jest needs to know when the code it is testing has completed, before it can move on to another test. Jest has several ways to handle this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e568a9bbdb9a0508a3a3ef0e439e109837c0942f" translate="yes" xml:space="preserve">
          <source>It's easier to understand this with an example. Let's say you have a method &lt;code&gt;bestLaCroixFlavor()&lt;/code&gt; which is supposed to return the string &lt;code&gt;'grapefruit'&lt;/code&gt;. Here's how you would test that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667bf8c3b168c667f3639da763c2b5c80fb59070" translate="yes" xml:space="preserve">
          <source>It's straightforward to spot when a snapshot test fails after a bug has been introduced. When that happens, go ahead and fix the issue and make sure your snapshot tests are passing again. Now, let's talk about the case when a snapshot test is failing due to an intentional implementation change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7afff3f789cd350ad5ef2e0ccd58b4b677f1d64" translate="yes" xml:space="preserve">
          <source>Jest</source>
          <target state="translated">Jest</target>
        </trans-unit>
        <trans-unit id="4f48cbea09ae54f44848cf5913f3a8fd18dc1890" translate="yes" xml:space="preserve">
          <source>Jest 24 dropped support for Babel 6. We highly recommend you to upgrade to Babel 7, which is actively maintained. However, if you cannot upgrade to Babel 7, either keep using Jest 23 or upgrade to Jest 24 with &lt;code&gt;babel-jest&lt;/code&gt; locked at version 23, like in the example below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c37bbcc2dc087e83d511674c69f117488f9a448" translate="yes" xml:space="preserve">
          <source>Jest CLI Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0763aa90e25f9dc7844da6152ce6f3059ffcb2" translate="yes" xml:space="preserve">
          <source>Jest Community</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea58238fa3c595c1ac8d7fc4a688da21db96450d" translate="yes" xml:space="preserve">
          <source>Jest Platform</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4848b4fe1132599637029a65960f94eb8531822" translate="yes" xml:space="preserve">
          <source>Jest adds the &lt;code&gt;inlineSnapshot&lt;/code&gt; string argument to the matcher in the test file (instead of an external &lt;code&gt;.snap&lt;/code&gt; file) the first time that the test runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0d7242dfd96ba5446eb996644a2e93256965b7" translate="yes" xml:space="preserve">
          <source>Jest allows third-party plugins to override some of its built-in feature keys, but not all. Specifically, the following keys are &lt;strong&gt;not overwritable&lt;/strong&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db4e21502b1cf82fe4554f5a22adc84d4239482" translate="yes" xml:space="preserve">
          <source>Jest allows you to mock out whole modules in your tests, which can be useful for testing if your code is calling functions from that module correctly. However, sometimes you may want to use parts of a mocked module in your &lt;em&gt;test file&lt;/em&gt;, in which case you want to access the original implementation, rather than a mocked version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a926667eb8c4ae03b1d94701be16eb503a21b695" translate="yes" xml:space="preserve">
          <source>Jest attempts to scan your dependency tree once (up-front) and cache it in order to ease some of the filesystem raking that needs to happen while running tests. This config option lets you customize where Jest stores that cache data on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7217bf7214933a525b967deb724c6b9162cbf15e" translate="yes" xml:space="preserve">
          <source>Jest can be used in projects that use &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; to manage assets, styles, and compilation. webpack &lt;em&gt;does&lt;/em&gt; offer some unique challenges over other tools because it integrates directly with your application to allow managing stylesheets, assets like images and fonts, along with the expansive ecosystem of compile-to-JavaScript languages and tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f07f770f308cce4d6d71cf7a65755091125d70" translate="yes" xml:space="preserve">
          <source>Jest can be used in projects that use &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the &lt;a href=&quot;webpack&quot;&gt;webpack guide&lt;/a&gt; to get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1f86ef9ac3ba9a1094e45789f0246c03864424" translate="yes" xml:space="preserve">
          <source>Jest can be used to mock ES6 classes that are imported into files you want to test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf92262b3a746cb5cadf84ee52757121913d4bb5" translate="yes" xml:space="preserve">
          <source>Jest configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3875a4b049058d09ee11ad3b9257c6fc76e7609" translate="yes" xml:space="preserve">
          <source>Jest executes all describe handlers in a test file &lt;em&gt;before&lt;/em&gt; it executes any of the actual tests. This is another reason to do setup and teardown inside &lt;code&gt;before*&lt;/code&gt; and &lt;code&gt;after*&lt;/code&gt; handlers rather than inside the describe blocks. Once the describe blocks are complete, by default Jest runs all the tests serially in the order they were encountered in the collection phase, waiting for each to finish and be tidied up before moving on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de3feadb801fdfceabb49f311df02bb3d2e6317" translate="yes" xml:space="preserve">
          <source>Jest has been rewritten with performance in mind, and snapshot testing is not an exception. Since snapshots are stored within text files, this way of testing is fast and reliable. Jest generates a new file for each test file that invokes the &lt;code&gt;toMatchSnapshot&lt;/code&gt; matcher. The size of the snapshots is pretty small: For reference, the size of all snapshot files in the Jest codebase itself is less than 300 KB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cecfbd4eff60247088ea6ea3e4cdcc4eadc368" translate="yes" xml:space="preserve">
          <source>Jest has default serializers for built-in JavaScript types, HTML elements (Jest 20.0.0+), ImmutableJS (Jest 20.0.0+) and for React elements. See &lt;a href=&quot;tutorial-react-native#snapshot-test&quot;&gt;snapshot test tutorial&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8f3b08f9e746db06cf8a8d8eb1728a20518b9e" translate="yes" xml:space="preserve">
          <source>Jest hooks can be attached by implementing the &lt;code&gt;apply&lt;/code&gt; method. This method receives a &lt;code&gt;jestHooks&lt;/code&gt; argument that allows the plugin to hook into specific parts of the lifecycle of a test run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78961166274ac390b7c628a0f785ac9679ec16ba" translate="yes" xml:space="preserve">
          <source>Jest supports TypeScript, via Babel. First make sure you followed the instructions on &lt;a href=&quot;#using-babel&quot;&gt;using Babel&lt;/a&gt; above. Next install the &lt;code&gt;@babel/preset-typescript&lt;/code&gt; via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df084822eb105d3a7a4cf3edd0cec8b8b50c092a" translate="yes" xml:space="preserve">
          <source>Jest supports both camelcase and dashed arg formats. The following examples will have equal result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26bd9497d9f62beebdda3158cf8b5bcd46589c3" translate="yes" xml:space="preserve">
          <source>Jest takes advantage of new features added to Node 6. We recommend that you upgrade to the latest stable release of Node. The minimum supported version is &lt;code&gt;v6.0.0&lt;/code&gt;. Versions &lt;code&gt;0.x.x&lt;/code&gt; and &lt;code&gt;4.x.x&lt;/code&gt; are not supported because the &lt;code&gt;jsdom&lt;/code&gt; version used in Jest doesn't support Node 4. However, if you need to run Jest on Node 4, you can use the &lt;code&gt;testEnvironment&lt;/code&gt; config to use a &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;custom environment&lt;/a&gt; that supports Node 4, such as &lt;a href=&quot;https://yarnpkg.com/en/package/jest-environment-node&quot;&gt;&lt;code&gt;jest-environment-node&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768460f31b776efe5a80d1b9f906e146b73387b9" translate="yes" xml:space="preserve">
          <source>Jest uses &quot;matchers&quot; to let you test values in different ways. This document will introduce some commonly used matchers. For the full list, see the &lt;a href=&quot;expect&quot;&gt;&lt;code&gt;expect&lt;/code&gt; API doc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82af62e3c4f58c048febf072e373b55ced751b5" translate="yes" xml:space="preserve">
          <source>Jest will fail if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e59a98c5fb0793e5a8bd46b25470fc7acc51f4" translate="yes" xml:space="preserve">
          <source>Jest will set &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; to &lt;code&gt;'test'&lt;/code&gt; if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d5c3a199ac87496dc718d131f247923a5cf3ff" translate="yes" xml:space="preserve">
          <source>Jest's configuration can be defined in the &lt;code&gt;package.json&lt;/code&gt; file of your project, or through a &lt;code&gt;jest.config.js&lt;/code&gt; file or through the &lt;code&gt;--config &amp;lt;path/to/js|json&amp;gt;&lt;/code&gt; option. If you'd like to use your &lt;code&gt;package.json&lt;/code&gt; to store Jest's config, the &quot;jest&quot; key should be used on the top level so Jest will know how to find your settings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e22c112121645c276dc7120c07fdacec26f44c5" translate="yes" xml:space="preserve">
          <source>Join the community</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab922b1d7b4717c074a882c0cc8961b6bee80d98" translate="yes" xml:space="preserve">
          <source>Keeping track of usage (spying on the mock)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aeb4bdd1784b8385939c2b4d4425b6e4b8d7dce" translate="yes" xml:space="preserve">
          <source>Keys with &lt;code&gt;undefined&lt;/code&gt; properties are checked. e.g. &lt;code&gt;{a: undefined, b: 2}&lt;/code&gt; does not match &lt;code&gt;{b: 2}&lt;/code&gt; when using &lt;code&gt;.toStrictEqual&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee55816ee3b1b4f1a6f30044867a661ab9181c42" translate="yes" xml:space="preserve">
          <source>Lastly, it may occasionally be useful in some tests to be able to clear all of the pending timers. For this, we have &lt;code&gt;jest.clearAllTimers()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a524bb87c02c371357d8cd4517ffca34064b2ab0" translate="yes" xml:space="preserve">
          <source>Learn about &lt;a href=&quot;snapshot-testing&quot;&gt;Snapshot Testing&lt;/a&gt;, &lt;a href=&quot;mock-functions&quot;&gt;Mock Functions&lt;/a&gt;, and more in our in-depth guides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4713da2c87e8066c2601dd3ebce0a9e9a2b367bd" translate="yes" xml:space="preserve">
          <source>Learn by example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73e45c2d9e4a09fc058543b28381a8d5615a8a2" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;configuration&quot;&gt;configure Jest&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7bb758fec5bace28a605b54e391a12fa494eb2" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;a href=&quot;snapshot-testing&quot;&gt;snapshot test&lt;/a&gt; for a Link component that renders hyperlinks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482beae4bfaae3f9fde0514bd3872927745e83f4" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;a href=&quot;snapshot-testing&quot;&gt;snapshot test&lt;/a&gt; for a small intro component with a few views and text components and some styles:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a993458f25570cd03bfa9e9bce6047cea0775b62" translate="yes" xml:space="preserve">
          <source>Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a &lt;code&gt;sum.js&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc8a6e48c03e9796bf746a0a520bcf38352c6b3" translate="yes" xml:space="preserve">
          <source>Let's imagine we're testing an implementation of a function &lt;code&gt;forEach&lt;/code&gt;, which invokes a callback for each item in a supplied array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062d6ba16b7346d8afbaec636d17b749060ac2a7" translate="yes" xml:space="preserve">
          <source>Let's implement a checkbox which swaps between two labels:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06fbcda1135b4a2d62c84a73f8043d399406587" translate="yes" xml:space="preserve">
          <source>Let's implement a module that fetches user data from an API and returns the user name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd426a8b3b04464a96cf78d5aa5692208e8f3496" translate="yes" xml:space="preserve">
          <source>Let's rewrite the test from above using Enzyme instead of react-testing-library. We use Enzyme's &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;shallow renderer&lt;/a&gt; in this example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157e685f0b5acabc2a4f6b50f0c1c98f974a8a3d" translate="yes" xml:space="preserve">
          <source>Let's start with a common sort of webpack config file and translate it to a Jest setup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd38479f084ecddacb918704233c6136d1f9d08" translate="yes" xml:space="preserve">
          <source>Lets you specify a custom test runner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0feff82f64a29645a993d706fca6c82a94899c" translate="yes" xml:space="preserve">
          <source>Lets you specify a custom test sequencer. Please refer to the documentation of the corresponding configuration property for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3dbc9fff53cb18c46d1dbe0926adbfb61c34df0" translate="yes" xml:space="preserve">
          <source>Lists all tests as JSON that Jest will run given the arguments, and exits. This can be used together with &lt;code&gt;--findRelatedTests&lt;/code&gt; to know which tests Jest will run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf968e7663782a1b2d3370cf3fab9d47ef5ec45" translate="yes" xml:space="preserve">
          <source>Logs the heap usage after every test. Useful to debug memory leaks. Use together with &lt;code&gt;--runInBand&lt;/code&gt; and &lt;code&gt;--expose-gc&lt;/code&gt; in node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3062ee96f10ceb01351b8c1d96e5d36b30dca2e3" translate="yes" xml:space="preserve">
          <source>Look at the full &lt;a href=&quot;api&quot;&gt;API Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8e7713a214ac3e151ee1f95eb5b5953bf52353" translate="yes" xml:space="preserve">
          <source>Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5c0e44a12b2c154dbab6ad20eb02b2ebda36df" translate="yes" xml:space="preserve">
          <source>Make sure you are not using the &lt;code&gt;babel-plugin-istanbul&lt;/code&gt; plugin. Jest wraps Istanbul, and therefore also tells Istanbul what files to instrument with coverage collection. When using &lt;code&gt;babel-plugin-istanbul&lt;/code&gt;, every file that is processed by Babel will have coverage collection code, hence it is not being ignored by &lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2601b2eb4063a28fa7ddf679595552390f7aaaad" translate="yes" xml:space="preserve">
          <source>Manual Mocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a515a8ca23977a705cfa165109739d0a5188aab8" translate="yes" xml:space="preserve">
          <source>Manual mock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24649abe70370a7c2be875cc1bb049c1d2c3120f" translate="yes" xml:space="preserve">
          <source>Manual mock that is another ES6 class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44695745ffcdd878a86f104986c6a105e40ebd17" translate="yes" xml:space="preserve">
          <source>Manual mocks are defined by writing a module in a &lt;code&gt;__mocks__/&lt;/code&gt; subdirectory immediately adjacent to the module. For example, to mock a module called &lt;code&gt;user&lt;/code&gt; in the &lt;code&gt;models&lt;/code&gt; directory, create a file called &lt;code&gt;user.js&lt;/code&gt; and put it in the &lt;code&gt;models/__mocks__&lt;/code&gt; directory. Note that the &lt;code&gt;__mocks__&lt;/code&gt; folder is case-sensitive, so naming the directory &lt;code&gt;__MOCKS__&lt;/code&gt; will break on some systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6043328f6dbc68531364ede4b70721943facae0" translate="yes" xml:space="preserve">
          <source>Manual mocks are used to stub out functionality with mock data. For example, instead of accessing a remote resource like a website or a database, you might want to create a manual mock that allows you to use fake data. This ensures your tests will be fast and not flaky.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4d90d06bd9381fe57041c5e2c6fa49629ba38e" translate="yes" xml:space="preserve">
          <source>Matchers are called with the argument passed to &lt;code&gt;expect(x)&lt;/code&gt; followed by the arguments passed to &lt;code&gt;.yourMatcher(y, z)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fdeb71c3b04a33085ca1c966123a1422dbbb545" translate="yes" xml:space="preserve">
          <source>Matchers should return an object (or a Promise of an object) with two keys. &lt;code&gt;pass&lt;/code&gt; indicates whether there was a match or not, and &lt;code&gt;message&lt;/code&gt; provides a function with no arguments that returns an error message in case of failure. Thus, when &lt;code&gt;pass&lt;/code&gt; is false, &lt;code&gt;message&lt;/code&gt; should return the error message for when &lt;code&gt;expect(x).yourMatcher()&lt;/code&gt; fails. And when &lt;code&gt;pass&lt;/code&gt; is true, &lt;code&gt;message&lt;/code&gt; should return the error message for when &lt;code&gt;expect(x).not.yourMatcher()&lt;/code&gt; fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="da4dc8d5f890d2faf608d0adbf35adbe19f4f359" translate="yes" xml:space="preserve">
          <source>Migrate your existing tests to Jest by following our &lt;a href=&quot;migration-guide&quot;&gt;migration guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ad73c448eb21acf03af42f65ee23278b00d994" translate="yes" xml:space="preserve">
          <source>Migrating to Jest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a893ece8e469a3ca3d935c49f41d08d04b75ecc" translate="yes" xml:space="preserve">
          <source>Misc</source>
          <target state="translated">Misc</target>
        </trans-unit>
        <trans-unit id="ce71db8c75c86bd1436468173cd4e8202c9dfc44" translate="yes" xml:space="preserve">
          <source>MobX</source>
          <target state="translated">MobX</target>
        </trans-unit>
        <trans-unit id="c599c38fbea82d50bf4f02778d2c491e8ffb771d" translate="yes" xml:space="preserve">
          <source>Mock Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d8638dc8b42629227f73d549ec402ed6ea4163" translate="yes" xml:space="preserve">
          <source>Mock Implementations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b383e089384d87712726a0bf225e81090b828eb" translate="yes" xml:space="preserve">
          <source>Mock Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd63f222517c40ccfb13bebc813ecec5f6f4c387" translate="yes" xml:space="preserve">
          <source>Mock Names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac64e00246b5445d75034bf18799b106ce0e9c67" translate="yes" xml:space="preserve">
          <source>Mock Return Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f17e11dc3d6f235c6b3173d2753715c699dccd" translate="yes" xml:space="preserve">
          <source>Mock functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16d7de714d1a0043e564d48599b0d8b9aadf62a1" translate="yes" xml:space="preserve">
          <source>Mock functions allow you to test the links between code by erasing the actual implementation of a function, capturing calls to the function (and the parameters passed in those calls), capturing instances of constructor functions when instantiated with &lt;code&gt;new&lt;/code&gt;, and allowing test-time configuration of return values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b436dfff5ba750a15d49f994af79b7a7a9443b9" translate="yes" xml:space="preserve">
          <source>Mock functions are also known as &quot;spies&quot;, because they let you spy on the behavior of a function that is called indirectly by some other code, rather than only testing the output. You can create a mock function with &lt;code&gt;jest.fn()&lt;/code&gt;. If no implementation is given, the mock function will return &lt;code&gt;undefined&lt;/code&gt; when invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4971c2547d472a78138b8f9d6790ae4e902b5810" translate="yes" xml:space="preserve">
          <source>Mock functions are also very effective in code that uses a functional continuation-passing style. Code written in this style helps avoid the need for complicated stubs that recreate the behavior of the real component they're standing in for, in favor of injecting values directly into the test right before they're used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277426c27099c2bbe1295ec0d37f76535f67bd0f" translate="yes" xml:space="preserve">
          <source>Mock functions can also be used to inject test values into your code during a test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f73fe7175c7ae1faf0611e3806c81041ff30671f" translate="yes" xml:space="preserve">
          <source>Mock native modules using jest.mock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2082c50c18e1f58690e6d14e16bfce63f4a55ed8" translate="yes" xml:space="preserve">
          <source>Mock timers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88bc2968cce370e084a967f2ffbedcdd7a9ef95" translate="yes" xml:space="preserve">
          <source>Mock using module factory parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de59347c925a26a9ab2dde60fa904ce3606c161" translate="yes" xml:space="preserve">
          <source>Mocking CSS Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e609b515d8887ae3c0a2bcd948b76d5eb888dcae" translate="yes" xml:space="preserve">
          <source>Mocking Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aca8ac03ce33b333f2207760098a53514b273da" translate="yes" xml:space="preserve">
          <source>Mocking Node modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00105b8c8ed55ecc038db2f39993e7f1167058b7" translate="yes" xml:space="preserve">
          <source>Mocking methods which are not implemented in JSDOM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8e30f89b00eb10d649edd097cb8226f41cc84f" translate="yes" xml:space="preserve">
          <source>Mocking user modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632801c55fe3abd89004fbdb78494e86beec94a0" translate="yes" xml:space="preserve">
          <source>Mocks a module with an auto-mocked version when it is being required. &lt;code&gt;factory&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; are optional. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f5b225cffab11e22dc40b6f05abef1d33d1561" translate="yes" xml:space="preserve">
          <source>Modes</source>
          <target state="translated">Modes</target>
        </trans-unit>
        <trans-unit id="009c795e3111448694cc3dc957f4b70c8f03b727" translate="yes" xml:space="preserve">
          <source>Module that identifies the primitive type of any JavaScript value. Exports a function that returns a string with the type of the value passed as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be53179917b8757ad3b5f547e48374b67d70e70" translate="yes" xml:space="preserve">
          <source>Module used for parallelization of tasks. Exports a class &lt;code&gt;Worker&lt;/code&gt; that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5123a0149608b8f62ab410c929a918587d7bbf79" translate="yes" xml:space="preserve">
          <source>Modules that are mapped to an alias are unmocked by default, regardless of whether automocking is enabled or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400881ff44dd95e53d5b70de2d221304a209dd8b" translate="yes" xml:space="preserve">
          <source>Modules that are mocked with &lt;code&gt;jest.mock&lt;/code&gt; are mocked only for the file that calls &lt;code&gt;jest.mock&lt;/code&gt;. Another file that imports the module will get the original implementation even if it runs after the test file that mocks the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb101179b6d768145f738342dfe298b98e4b70e0" translate="yes" xml:space="preserve">
          <source>More Resources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7a524aa43cd2033804e07ac0567266d5069451" translate="yes" xml:space="preserve">
          <source>More information can be found at &lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;https://github.com/skovhus/jest-codemods&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde45e0d5214ab7d193c97e2773574aa18d36ca8" translate="yes" xml:space="preserve">
          <source>More information on Node debugging can be found &lt;a href=&quot;https://nodejs.org/api/debugger.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a40503253892e6560d8d5c69a4720093cc2ba6" translate="yes" xml:space="preserve">
          <source>More information on how snapshot testing works and why we built it can be found on the &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;release blog post&lt;/a&gt;. We recommend reading &lt;a href=&quot;http://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/&quot;&gt;this blog post&lt;/a&gt; to get a good sense of when you should use snapshot testing. We also recommend watching this &lt;a href=&quot;https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074&quot;&gt;egghead video&lt;/a&gt; on Snapshot Testing with Jest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f58721cb66c8644aaf7f808a07bb173fa203cd2" translate="yes" xml:space="preserve">
          <source>Most commonly this is being caused by conflicting Promise implementations. Consider replacing the global promise implementation with your own, for example &lt;code&gt;global.Promise = jest.requireActual('promise');&lt;/code&gt; and/or consolidate the used Promise libraries to a single one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fa9ec15923cf5a4447d89705061f4895a3a460" translate="yes" xml:space="preserve">
          <source>Most likely your glob patterns are not matching any files. Refer to the &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt; documentation to ensure your globs are compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70aff9a2e6d1a508cc94211f970a06aadb07a7f" translate="yes" xml:space="preserve">
          <source>Most real-world examples actually involve getting ahold of a mock function on a dependent component and configuring that, but the technique is the same. In these cases, try to avoid the temptation to implement logic inside of any function that's not directly being tested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1743857a25bf614f38c27b820f8398e3eb15e127" translate="yes" xml:space="preserve">
          <source>Most ways of comparing numbers have matcher equivalents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d9d7323ef86fe85fd1d7687235aac297bdcdee" translate="yes" xml:space="preserve">
          <source>Next, let's configure Jest to gracefully handle asset files such as stylesheets and images. Usually, these files aren't particularly useful in tests so we can safely mock them out. However, if you are using CSS Modules then it's better to mock a proxy for your className lookups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd213a32f05bcc17b41830bc252640d32af3383" translate="yes" xml:space="preserve">
          <source>No default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069541cf8be1f0d43b5c179ab178c1af971111c3" translate="yes" xml:space="preserve">
          <source>No, as of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing &lt;code&gt;--updateSnapshot&lt;/code&gt;. It is expected that all snapshots are part of the code that is run on CI and since new snapshots automatically pass, they should not pass a test run on a CI system. It is recommended to always commit all snapshots and to keep them in version control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8a846eddb8681ebf180cd4b3a87cddb1fe5a15" translate="yes" xml:space="preserve">
          <source>None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593dc274bf37fc96d1260b84eb4792e03219586d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;column&lt;/code&gt; is 0-indexed while &lt;code&gt;line&lt;/code&gt; is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fbb94ab3f435207f3668ea824069ffb13ba8524" translate="yes" xml:space="preserve">
          <source>Note that the mock can't be an arrow function because calling &lt;code&gt;new&lt;/code&gt; on an arrow function is not allowed in JavaScript. So this won't work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e09d6f70cb52a597a44fb09de97ecc2bafcf55" translate="yes" xml:space="preserve">
          <source>Note that the top-level &lt;code&gt;beforeEach&lt;/code&gt; is executed before the &lt;code&gt;beforeEach&lt;/code&gt; inside the &lt;code&gt;describe&lt;/code&gt; block. It may help to illustrate the order of execution of all hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5317a3a7e7d23a56315a8874c449817c31ad8a0c" translate="yes" xml:space="preserve">
          <source>Note that, if you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will &lt;em&gt;not&lt;/em&gt; be persisted across test runs for other test files. In addition the &lt;code&gt;globals&lt;/code&gt; object must be json-serializable, so it can't be used to specify global functions. For that you should use &lt;code&gt;setupFiles&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc786612e42a25f8f3750696a48a69840f36cd3" translate="yes" xml:space="preserve">
          <source>Note that, since you are still testing promises, the test is still asynchronous. Hence, you will need to &lt;a href=&quot;asynchronous#promises&quot;&gt;tell Jest to wait&lt;/a&gt; by returning the unwrapped assertion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9794622b767437b0ecae517257f9db04f7adf32d" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; is a special token that gets replaced by Jest with the root of your project. Most of the time this will be the folder where your &lt;code&gt;package.json&lt;/code&gt; is located unless you specify a custom &lt;code&gt;rootDir&lt;/code&gt; option in your configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628dafac3ccff711682a19552f96e64d7e9e0c0e" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;.toEqual&lt;/code&gt; won't perform a &lt;em&gt;deep equality&lt;/em&gt; check for two errors. Only the &lt;code&gt;message&lt;/code&gt; property of an Error is considered for equality. It is recommended to use the &lt;code&gt;.toThrow&lt;/code&gt; matcher for testing against errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7613acf3a264c0259c7e5490495960bb2558a069" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;babel-jest&lt;/code&gt; is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the &lt;code&gt;transform&lt;/code&gt; configuration option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1bf41dd30024dc8f6a9cf73cdb3281441a7c127" translate="yes" xml:space="preserve">
          <source>Note: For more complex webpack configurations, you may also want to investigate projects such as: &lt;a href=&quot;https://github.com/istarkov/babel-plugin-webpack-loaders&quot;&gt;babel-plugin-webpack-loaders&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ee4f891332fe29d99fc8b7113be07b4978e5d9" translate="yes" xml:space="preserve">
          <source>Note: If a &lt;strong&gt;promise is returned&lt;/strong&gt; from &lt;code&gt;test&lt;/code&gt;, Jest will wait for the promise to resolve before letting the test complete. Jest will also wait if you &lt;strong&gt;provide an argument to the test function&lt;/strong&gt;, usually called &lt;code&gt;done&lt;/code&gt;. This could be handy when you want to test callbacks. See how to test async code &lt;a href=&quot;asynchronous#callbacks&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c9e685037a098f7ab5cab7e553edaf0c09711f" translate="yes" xml:space="preserve">
          <source>Note: In order to mock properly, Jest needs &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; to be in the same scope as the &lt;code&gt;require/import&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc7ec9481edc4a64cc4cee9fd0a5b4e7d421cf5" translate="yes" xml:space="preserve">
          <source>Note: Jest caches files to speed up test execution. If you updated .babelrc and Jest is still not working, try running Jest with &lt;code&gt;--no-cache&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18499d47a5d29c4202e6b0823b51b2cc1f3a7091" translate="yes" xml:space="preserve">
          <source>Note: Jest documentation uses &lt;code&gt;yarn&lt;/code&gt; commands, but &lt;code&gt;npm&lt;/code&gt; will also work. You can compare &lt;code&gt;yarn&lt;/code&gt; and &lt;code&gt;npm&lt;/code&gt; commands in the &lt;a href=&quot;https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison&quot;&gt;yarn docs, here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cff4d7445c3ba40f87a1439f00a6eba64d370e9" translate="yes" xml:space="preserve">
          <source>Note: The snapshot is directly scoped to the data you render &amp;ndash; in our example it's &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component with page prop passed to it. This implies that even if any other file has missing props (Say, &lt;code&gt;App.js&lt;/code&gt;) in the &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component, it will still pass the test as the test doesn't know the usage of &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component and it's scoped only to the &lt;code&gt;Link.react.js&lt;/code&gt;. Also, Rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f87616f2342dfb53f7c81b06d94dec773c92c7" translate="yes" xml:space="preserve">
          <source>Note: You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb20dc9b8a75cec38d02e8f54a09a224da2b36c" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;--runInBand&lt;/code&gt; cli option makes sure Jest runs test in the same process rather than spawning processes for individual tests. Normally Jest parallelizes test runs across processes but it is hard to debug many processes at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a5108cffe44c788bf001c5788a68bdfb2e0028" translate="yes" xml:space="preserve">
          <source>Note: the defaultResolver passed as options is the jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom one, e.g. (request, options).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63519bb0bd54e1b894cccdf4f3af7852ef618bb7" translate="yes" xml:space="preserve">
          <source>Note: the nth argument must be positive integer starting from 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc782aff0e671f43d928b262fb2a1ad60df35d44" translate="yes" xml:space="preserve">
          <source>Notice that Proxy is enabled in Node 6 by default. If you are not on Node 6 yet, make sure you invoke Jest using &lt;code&gt;node --harmony_proxies node_modules/.bin/jest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d92ee85a42081babf70348e9395eeb01e66cc8" translate="yes" xml:space="preserve">
          <source>Now imagine an implementation of &lt;code&gt;request.js&lt;/code&gt; that goes to the network and fetches some user data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb60cb13af7d9fd41f600f4cb00d4bff107937d6" translate="yes" xml:space="preserve">
          <source>Now let's use React's test renderer and Jest's snapshot feature to interact with the component and capture the rendered output and create a snapshot file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce0f103deaf5dc6dbc56bf66214617663420f57" translate="yes" xml:space="preserve">
          <source>Now let's write a test for our async functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4759fbb62123d73c1226706f0f4d34666a8582b0" translate="yes" xml:space="preserve">
          <source>Now that Jest knows how to process our files, we need to tell it how to &lt;em&gt;find&lt;/em&gt; them. For webpack's &lt;code&gt;modulesDirectories&lt;/code&gt;, and &lt;code&gt;extensions&lt;/code&gt; options there are direct analogs in Jest's &lt;code&gt;moduleDirectories&lt;/code&gt; and &lt;code&gt;moduleFileExtensions&lt;/code&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a5de53298548d7d54ae3ca8e892f7df5aa2243" translate="yes" xml:space="preserve">
          <source>Now we write our test. Note that we need to explicitly tell that we want to mock the &lt;code&gt;fs&lt;/code&gt; module because it&amp;rsquo;s a core Node module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a5c027241fe1614d4396220914efc2314503e5" translate="yes" xml:space="preserve">
          <source>Now, every time the snapshot test case runs, &lt;code&gt;Date.now()&lt;/code&gt; will return &lt;code&gt;1482363367071&lt;/code&gt; consistently. This will result in the same snapshot being generated for this component regardless of when the test is run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e6490929905f7bc8af5ccef9bf48f8668b1460" translate="yes" xml:space="preserve">
          <source>Now, in order to test this method without actually hitting the API (and thus creating slow and fragile tests), we can use the &lt;code&gt;jest.mock(...)&lt;/code&gt; function to automatically mock the axios module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="8d3eb6284bfb714ab8ca96c009bf8ad9c4fc7252" translate="yes" xml:space="preserve">
          <source>Object types are checked to be equal. e.g. A class instance with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will not equal a literal object with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2176a8ab6b1e30ac16f60c568568a437d540248" translate="yes" xml:space="preserve">
          <source>Often there are fields in the object you want to snapshot which are generated (like IDs and Dates). If you try to snapshot these objects, they will force the snapshot to fail on every run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ffecdf0087875891dd611103daecc4d8bcf8763" translate="yes" xml:space="preserve">
          <source>Often this is useful when you want to clean up a mock's usage data between two assertions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79cd3f6e68b0a9656087292d49bbeda556ae6d96" translate="yes" xml:space="preserve">
          <source>Often while writing tests you have some setup work that needs to happen before tests run, and you have some finishing work that needs to happen after tests run. Jest provides helper functions to handle this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f3d546a97573ddf0fe581d729e6b000ed006545" translate="yes" xml:space="preserve">
          <source>Oftentimes, you'll want to set this to &lt;code&gt;'src'&lt;/code&gt; or &lt;code&gt;'lib'&lt;/code&gt;, corresponding to where in your repository the code is stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12f3f3ee865af90cac56dabeb84091b38861136" translate="yes" xml:space="preserve">
          <source>On occasion there are times where the automatically generated mock the module system would normally provide you isn't adequate enough for your testing needs. Normally under those circumstances you should write a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that is more adequate for the module in question. However, on extremely rare occasions, even a manual mock isn't suitable for your purposes and you need to build the mock yourself inside your test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef0b229d34fbb64b6540632318f3fdbaa2280e6" translate="yes" xml:space="preserve">
          <source>Once we mock the module we can provide a &lt;code&gt;mockResolvedValue&lt;/code&gt; for &lt;code&gt;.get&lt;/code&gt; that returns the data we want our test to assert against. In effect, we are saying that we want axios.get('/users.json') to return a fake response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fd8cdd8b9b5a8885d7339d6a566088a20fe3d5" translate="yes" xml:space="preserve">
          <source>Once you enter Interactive Snapshot Mode, Jest will step you through the failed snapshots one test at a time and give you the opportunity to review the failed output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffee35fa0cdfd66f92f9f207350deb369bb338b" translate="yes" xml:space="preserve">
          <source>Once you're finished, Jest will give you a summary before returning back to watch mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e3f29cab1cd3970d5e34742e1c9209c2a454b6" translate="yes" xml:space="preserve">
          <source>Once you've learned about the matchers that are available, a good next step is to check out how Jest lets you &lt;a href=&quot;asynchronous&quot;&gt;test asynchronous code&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911829cb001fba297a8440e3959d077dc4ad2675" translate="yes" xml:space="preserve">
          <source>One example when this is useful is when you want to mock a module differently within the same file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d433b060d5be5e5cb29585b03e7a39cbe16040" translate="yes" xml:space="preserve">
          <source>One of the files matching the &lt;code&gt;./src/reducers/**/*.js&lt;/code&gt; glob has less than 90% statement coverage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33de0273fb385ef534431d972ca028ab9fae9e00" translate="yes" xml:space="preserve">
          <source>One or more subsequent rows of data supplied as template literal expressions using &lt;code&gt;${value}&lt;/code&gt; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfce43d345326fcdf5172027f076645beb3b6bbb" translate="yes" xml:space="preserve">
          <source>One such situation can arise if we intentionally change the address the Link component in our example is pointing to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3971f2be369ec67c710b4572f1ea126ad557a5" translate="yes" xml:space="preserve">
          <source>One-Time Setup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883b26a66c75d25a769cffa672f3388d833b2cc4" translate="yes" xml:space="preserve">
          <source>Only the &quot;it is raining&quot; test will run in that test file, since it is run with &lt;code&gt;test.only&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00991593a9f4d31e6c4dd6dbb447ea1e1f468c00" translate="yes" xml:space="preserve">
          <source>Only the &quot;it is raining&quot; test will run, since the other test is run with &lt;code&gt;test.skip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749db9a1ae125917392d1a5146e4c6d00c14a9d3" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide &lt;code&gt;steps&lt;/code&gt;, so it will run &lt;code&gt;steps&lt;/code&gt; amount of next timeouts/intervals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920bdedd844899cd5664de8cfd74adb5d459a38e" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf57bdba6d591e8cfd0266e8b8c0a594cbd7d55" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait for each row before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="5c52bc127f7b5826340dcf7c16bf51e0c271179b" translate="yes" xml:space="preserve">
          <source>Or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371316f168eab595bc4ea7391514a4fa0fe1808f" translate="yes" xml:space="preserve">
          <source>Or if you'd like to create your own manual mock, you can do something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e431292d05ab6b8e395a562d7c86a6ac7fe933b" translate="yes" xml:space="preserve">
          <source>Or through JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a0778a7a6879004009864ebf95b81c7e7732d5" translate="yes" xml:space="preserve">
          <source>Order of execution of describe and test blocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a3dd308dd30f061fa22d50cb21bc2220dcf9c9" translate="yes" xml:space="preserve">
          <source>Our mocked class will need to provide any member functions (&lt;code&gt;playSoundFile&lt;/code&gt; in the example) that will be called during our tests, or else we'll get an error for calling a function that doesn't exist. But we'll probably want to also spy on calls to those methods, to ensure that they were called with the expected parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc5a5b4ca8f80ee77043098ef9ffc04d559ec8c" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;debugger;&lt;/code&gt; statement in any of your tests, and then, in your project's directory, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d313b13f95b5bdfa47176161df9d9aac0aea191" translate="yes" xml:space="preserve">
          <source>Please keep in mind that the resulting configuration must be JSON-serializable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af206380956fb62af6fa59d92f109cd9641063d0" translate="yes" xml:space="preserve">
          <source>Please note that if you use arrow functions in your classes, they will &lt;em&gt;not&lt;/em&gt; be part of the mock. The reason for that is that arrow functions are not present on the object's prototype, they are merely properties holding a reference to a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c438f6772aa6520819506e7fbe99852dd87fd5" translate="yes" xml:space="preserve">
          <source>Plugins can be customized via your Jest configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e78b672f965eb7c8293baebd2be38d992a6655" translate="yes" xml:space="preserve">
          <source>Preset configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb26311747a6131c77f1e75e89e1da90925579c" translate="yes" xml:space="preserve">
          <source>Presets may also be relative filesystem paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33521f1e271c7d1369654933da9149112fe4281c" translate="yes" xml:space="preserve">
          <source>Prevent tests from printing messages through the console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0507f30be4f8c196c99ce7be2cba62397164f331" translate="yes" xml:space="preserve">
          <source>Prevents Jest from executing more than the specified amount of tests at the same time. Only affects tests that use &lt;code&gt;test.concurrent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7719ba43ff57b175fbd95f647e624ca1e3e38f9d" translate="yes" xml:space="preserve">
          <source>Print debugging info about your Jest config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169d23ffa6beb8bf0a8b932fddc3a716b615997f" translate="yes" xml:space="preserve">
          <source>Print your Jest config and then exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45ae5d1d90ee0d31bb43f56d9dee1beb6b5a14a" translate="yes" xml:space="preserve">
          <source>Prints the test results in JSON. This mode will send all other test output and user messages to stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="d3f60bcc6f5c4f59593f0501aca5c6e1a0e647d3" translate="yes" xml:space="preserve">
          <source>Property Matchers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b305ac456a0fe1de47f68c0f2dcb4be5edf55137" translate="yes" xml:space="preserve">
          <source>React 16 triggers these warnings due to how it checks element types, and the mocked module fails these checks. Your options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695d1116170755340f94ec3beb1f24f668859e58" translate="yes" xml:space="preserve">
          <source>Recommended config names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="84641ce3545468aef6d9992e246ecc28023bd7fa" translate="yes" xml:space="preserve">
          <source>Removes any pending timers from the timer system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571be88936b979291213a8fc1300d3eb34583940" translate="yes" xml:space="preserve">
          <source>Render as a custom element. DOM &quot;custom elements&quot; aren't checked for anything and shouldn't fire warnings. They are lowercase and have a dash in the name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456b6bb3ce6f2e6632c5f1e8d9ca1d06e7f178b9" translate="yes" xml:space="preserve">
          <source>Render as text. This way you won't see the props passed to the mock component in the snapshot, but it's straightforward:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e70132872e75d10f3ccbb11c8b73d9f202669fd" translate="yes" xml:space="preserve">
          <source>Rendered snapshot:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd1c22168650ecd82a31a115bed21a42399c269" translate="yes" xml:space="preserve">
          <source>Repeating Setup For Many Tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5add9c1dfb47ec8100a0659f89d63ed952ac6c86" translate="yes" xml:space="preserve">
          <source>Replacing the mock using &lt;a href=&quot;mock-function-api#mockfnmockimplementationfn&quot;&gt;&lt;code&gt;mockImplementation()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mock-function-api#mockfnmockimplementationoncefn&quot;&gt;&lt;code&gt;mockImplementationOnce()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19baff0fd9598875b3df0c02954246d178653887" translate="yes" xml:space="preserve">
          <source>Resets all information stored in the &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt; arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4baf164f97d04496389992c7c5da13fbb245ae" translate="yes" xml:space="preserve">
          <source>Resets the module registry - the cache of all required modules. This is useful to isolate modules where local state might conflict between tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee7cc0bddf7c5a4ef8549ea7c38c8d601b2255d" translate="yes" xml:space="preserve">
          <source>Resets the state of all mocks. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockreset&quot;&gt;&lt;code&gt;.mockReset()&lt;/code&gt;&lt;/a&gt; on every mocked function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46554c07d0e0360541685d38d9047e14f0a0601e" translate="yes" xml:space="preserve">
          <source>Respect Browserify's &lt;a href=&quot;https://github.com/substack/browserify-handbook#browser-field&quot;&gt;&lt;code&gt;&quot;browser&quot;&lt;/code&gt; field&lt;/a&gt; in &lt;code&gt;package.json&lt;/code&gt; when resolving modules. Some modules export different versions based on whether they are operating in Node or a browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27aceef5796ab8d68aed06c602f37330d5a900d4" translate="yes" xml:space="preserve">
          <source>Restores all mocks back to their original value. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockrestore&quot;&gt;&lt;code&gt;.mockRestore()&lt;/code&gt;&lt;/a&gt; on every mocked function. Beware that &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; only works when the mock was created with &lt;code&gt;jest.spyOn&lt;/code&gt;; other mocks will require you to manually restore them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ddb9b055cad613e29453fa554de9f36c7d6c8dd" translate="yes" xml:space="preserve">
          <source>Retry with &lt;a href=&quot;cli#--cache&quot;&gt;&lt;code&gt;--no-cache&lt;/code&gt;&lt;/a&gt;. Jest caches transformed module files to speed up test execution. If you are using your own custom transformer, consider adding a &lt;code&gt;getCacheKey&lt;/code&gt; function to it: &lt;a href=&quot;https://github.com/facebook/relay/blob/58cf36c73769690f0bbf90562707eadb062b029d/scripts/jest/preprocessor.js#L56-L61&quot;&gt;getCacheKey in Relay&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156ec26504d2692465a0d8ff00489f7b36d9fa41" translate="yes" xml:space="preserve">
          <source>Returns a boolean (or &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; for handling asynchronous operations) to specify if a test should be run or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d66ba4a66cb6cf526e2e08e5bcc4265e970107d" translate="yes" xml:space="preserve">
          <source>Returns a mock module instead of the actual module, bypassing all checks on whether the module should be required normally or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da978b2f0e20c11e4aa75b10631e43a25e02ab4" translate="yes" xml:space="preserve">
          <source>Returns a new, unused &lt;a href=&quot;mock-function-api&quot;&gt;mock function&lt;/a&gt;. Optionally takes a mock implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1acf18173b267510a46851d55a523216adab36c" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;jest&lt;/code&gt; object for chaining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08519e49635fb031179ab7f05284949daef9383" translate="yes" xml:space="preserve">
          <source>Returns the actual module instead of a mock, bypassing all checks on whether the module should receive a mock implementation or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2add96bbc9e9900cf433a5f2ebe6d67cb4660cf1" translate="yes" xml:space="preserve">
          <source>Returns the mock name string set by calling &lt;code&gt;mockFn.mockName(value)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9336539157509732381e95d2e9b2f4ceef9877" translate="yes" xml:space="preserve">
          <source>Returns the number of fake timers still left to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b392607deaf29a7e81453e069b7c07a32a6b18" translate="yes" xml:space="preserve">
          <source>Run</source>
          <target state="translated">Run</target>
        </trans-unit>
        <trans-unit id="641d1b198a65bb1bd4728078175e361d73f060b6" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;yarn test&lt;/code&gt; to run tests with Jest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7306d688c7598b3d294777df07da99e3d93d653c" translate="yes" xml:space="preserve">
          <source>Run All Timers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ad8b68bab570303d35cefd0d73cf6056dbfc2d" translate="yes" xml:space="preserve">
          <source>Run Pending Timers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89b3947b20f77096b75ca74d8fccf7526f1872b" translate="yes" xml:space="preserve">
          <source>Run all tests (default):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b363bdd7980fccab5552af0568d148195655d4" translate="yes" xml:space="preserve">
          <source>Run all tests affected by file changes in the last commit made. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcaa420e9fe3c70be68c6d8ee7d82ab5720e907" translate="yes" xml:space="preserve">
          <source>Run only the tests that were specified with a pattern or filename:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d791c05598e8218af4368bc378173046cea720" translate="yes" xml:space="preserve">
          <source>Run only the tests that were specified with their exact paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23686a3a58e4a1259f35510a9d0252c4f6745f24" translate="yes" xml:space="preserve">
          <source>Run tests from one or more projects, found in the specified paths; also takes path globs. This option is the CLI equivalent of the &lt;a href=&quot;configuration#projects-arraystring--projectconfig&quot;&gt;&lt;code&gt;projects&lt;/code&gt;&lt;/a&gt; configuration option. Note that if configuration files are found in the specified paths, &lt;em&gt;all&lt;/em&gt; projects specified within those configuration files will be run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ddd0d105f6204c8e90c3adf874ea7bc2b26987" translate="yes" xml:space="preserve">
          <source>Run tests related to &lt;code&gt;path/to/fileA.js&lt;/code&gt; and &lt;code&gt;path/to/fileB.js&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de5d0d69fc805a58b350e937e2690429d2970e2" translate="yes" xml:space="preserve">
          <source>Run tests related to changed files based on hg/git (uncommitted files):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44ae954d1ab8ef98e8adfe8b4785726ef8e4670" translate="yes" xml:space="preserve">
          <source>Run tests that match this spec name (match against the name in &lt;code&gt;describe&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt;, basically).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3250ade6678b3bc2a1ae0933ebec438d66c4c65a" translate="yes" xml:space="preserve">
          <source>Run tests with specified reporters. &lt;a href=&quot;configuration#reporters-arraymodulename--modulename-options&quot;&gt;Reporter options&lt;/a&gt; are not available via CLI. Example with multiple reporters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9d71147bb217981f158928624c5b13a6be2ead" translate="yes" xml:space="preserve">
          <source>Run watch mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6317e775f03f11757290b5bce78a11c48721ccd6" translate="yes" xml:space="preserve">
          <source>Running from command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d642ff91fd7ebdca37f4b2895153e438af4b378" translate="yes" xml:space="preserve">
          <source>Running from the command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437a88c377620b15b1bd26b6489ffe7cf9e58772" translate="yes" xml:space="preserve">
          <source>Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50450676d930383c48d2ec3efefa163347c39da6" translate="yes" xml:space="preserve">
          <source>Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b753442cff11f6ed337230a6a654b466728c0d" translate="yes" xml:space="preserve">
          <source>Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57284652d7931aab5ea782fa00d26cf2b4c59502" translate="yes" xml:space="preserve">
          <source>Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8886a35ac5b619bcc55c828058cdaa29e97376a1" translate="yes" xml:space="preserve">
          <source>Runs failed tests n-times until they pass or until the max number of retries is exhausted. This only works with &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;jest-circus&lt;/a&gt;!</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
