<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="ebedd29e20c0b181d70ffe15f5988d119d67516f" translate="yes" xml:space="preserve">
          <source>You can call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt; from anywhere in your app, including components and XHR callbacks, or even at scheduled intervals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870b3b70e7feab01dc48305e33a3f7b71d9e003a" translate="yes" xml:space="preserve">
          <source>You can control state key names by using different keys for the reducers in the passed object. For example, you may call &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; for the state shape to be &lt;code&gt;{ todos, counter }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b80aff840c6b3c2cb0814711f2e90fb9add9aa" translate="yes" xml:space="preserve">
          <source>You can even write a custom middleware to describe calls to your API, like the &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcfc87ae98655e6e4c23b31a5690541a13ff642" translate="yes" xml:space="preserve">
          <source>You can extract logging into a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1306a831686a52c567f5d3446dae27226d983c27" translate="yes" xml:space="preserve">
          <source>You can find more examples in &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1db4cdd68a98570c03ba8a576e981e8641ef738b" translate="yes" xml:space="preserve">
          <source>You can find the official logo &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;on GitHub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb1259c8d739932d68e05103d65deeafc4b13b1" translate="yes" xml:space="preserve">
          <source>You can see how this causes the state held by the store to change:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4eddcb9e81b002608a7bf4ef875c82738729233" translate="yes" xml:space="preserve">
          <source>You can set up your build tool of choice (Webpack, Browserify, etc.) to compile a bundle file into &lt;code&gt;static/bundle.js&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23310ba75752c6caee4c2c18e21c9fe454bf81a2" translate="yes" xml:space="preserve">
          <source>You can then pass &lt;code&gt;dispatch&lt;/code&gt; down to other components manually, if you want to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95f737abcdb30e78aa13a25f5076e2ef6dc3676" translate="yes" xml:space="preserve">
          <source>You can then use it everywhere instead of &lt;code&gt;store.dispatch()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbaa58ba5417a98c5d0d32b5ce14eba1d4e2fef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; or &lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt; to dispatch Promises instead of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d98266f375d43672febffb46f3ed5355675dc5b" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt; to dispatch Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9c266f69d53ba1763af2ada1d6653210151773" translate="yes" xml:space="preserve">
          <source>You can use Redux together with &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;, or with any other view library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d3cd95f0d488448a63a6b338cb50068a95d5d9" translate="yes" xml:space="preserve">
          <source>You can use it at all levels of your reducer structure, not just to create the root reducer. It's very common to have multiple combined reducers in various places, which are composed together to create the root reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490b5a07e2c5aad3ad0c9fd7a27a52665898f60e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt; middleware to dispatch promise-based asynchronous actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0e299c97c2207cdace456ccd47c72d8b63f087" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt; middleware to build more complex asynchronous actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be61aa399225330ac3c7c8f8b6d9263d4b58435" translate="yes" xml:space="preserve">
          <source>You cannot mutate an immutable object; instead, you must mutate a copy of it, leaving the original intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9002cfc3dd43f6e0951811e8e815e8e77752e185" translate="yes" xml:space="preserve">
          <source>You could also give them different keys, or call functions differently. These two ways to write a combined reducer are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be388744a3e109fec6dfea1a28f5eb27d9ed9a9" translate="yes" xml:space="preserve">
          <source>You could even go as far as to make a generic filtering higher-order reducer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e73413f8379bbd8e9bb56a500c7eb3c5f375e13" translate="yes" xml:space="preserve">
          <source>You do not need to use Immutable.JS with Redux. Plain JavaScript, if written correctly, is perfectly capable of providing immutability without having to use an immutable-focused library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9581e0ed51066ff103253aa77beee1d1478416ea" translate="yes" xml:space="preserve">
          <source>You don't have to define action type constants in a separate file, or even to define them at all. For a small project, it might be easier to just use string literals for action types. However, there are some benefits to explicitly declaring constants in larger codebases. Read &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;Reducing Boilerplate&lt;/a&gt; for more practical tips on keeping your codebase clean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199448d814bc5e9584035a52d2115857f50dad49" translate="yes" xml:space="preserve">
          <source>You have two reducers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192eb5ae977897417943647ddbcb6a6f3d4104d2" translate="yes" xml:space="preserve">
          <source>You may call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; from a change listener, with the following caveats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebca9d5f96869ed296e545e937054edc0f8c94d" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;combineReducers&lt;/code&gt; at any level of the reducer hierarchy. It doesn't have to happen at the top. In fact you may use it again to split the child reducers that get too complicated into independent grandchildren, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3644afb1fd9b1feb972c2dc856f2ca012f2fd6b3" translate="yes" xml:space="preserve">
          <source>You may enhance &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;. It is not required, but it lets you &lt;a href=&quot;asyncactions&quot;&gt;express asynchronous actions in a convenient way&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d912b7407f7325b0f1291dd95c400a5024e9614d" translate="yes" xml:space="preserve">
          <source>You may need to write some custom functions for handling some of these actions. This may require replacing &lt;code&gt;combineReducers&lt;/code&gt; with your own top-level reducer function. You can also use a utility such as &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; to run &lt;code&gt;combineReducers&lt;/code&gt; to handle most actions, but also run a more specialized reducer for specific actions that cross state slices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09059cc37b1193dbc15c30252c07daa76e286f64" translate="yes" xml:space="preserve">
          <source>You may optionally specify the initial state as the second argument to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;. This is useful for hydrating the state of the client to match the state of a Redux application running on the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee0e53b45fb2fa831d9c837168e8230281cd9d8" translate="yes" xml:space="preserve">
          <source>You may use a dedicated &lt;code&gt;status&lt;/code&gt; field in your actions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db87382954c55c5d2ee83adf7f38146a50266b8e" translate="yes" xml:space="preserve">
          <source>You may want to read &lt;a href=&quot;../advanced/asyncactions&quot;&gt;Async Actions&lt;/a&gt; to learn more about expressing asynchronous flow in Redux with async primitives such as Promises and thunks. Keep in mind that anything you learn there can also be applied to universal rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6c69e4ca4e0cce6a488148dc045be49daaf6a8" translate="yes" xml:space="preserve">
          <source>You may wrap one or more reducers in &lt;code&gt;undoable&lt;/code&gt; at any level of the reducer composition hierarchy. We choose to wrap &lt;code&gt;todos&lt;/code&gt; instead of the top-level combined reducer so that changes to &lt;code&gt;visibilityFilter&lt;/code&gt; are not reflected in the undo history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5dbd93add81c61b1e16815b79f40079a123eba8" translate="yes" xml:space="preserve">
          <source>You might ask: why don't we bind the action creators to the store instance right away, like in classical Flux? The problem is that this won't work well with universal apps that need to render on the server. Most likely you want to have a separate store instance per request so you can prepare them with different data, but binding action creators during their definition means you're stuck with a single store instance for all requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2896f8f64f8c4e00e8362d43f027ff694ea34032" translate="yes" xml:space="preserve">
          <source>You might be familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;higher order functions&lt;/a&gt;. If you use React, you might be familiar with &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher order components&lt;/a&gt;. Here is a variation on the same pattern, applied to reducers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc80378efa78f4250982b149969a4e4206388634" translate="yes" xml:space="preserve">
          <source>You might have heard that Redux was influenced by &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture&lt;/a&gt;. It shouldn't come as a surprise that this example is very similar to &lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;elm-undo-redo package&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8f897b9ef506870651387b41362b89ab366329" translate="yes" xml:space="preserve">
          <source>You might want to use it to apply several &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt; in a row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8edb49caaa697733e02d643699b140e0476f6b" translate="yes" xml:space="preserve">
          <source>You might write an action creator in a separate file, and import it into your component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5012c361d888ca9c67b230342b72327b08a9b0ab" translate="yes" xml:space="preserve">
          <source>You never see this, of course - the data you give to an Immutable.JS object is never mutated. Rather, it&amp;rsquo;s the &lt;em&gt;intermediate&lt;/em&gt; data generated within Immutable.JS from a chained sequence of method calls that is free to be mutated. You therefore get all the benefits of immutable data structures with none (or very little) of the potential performance hits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536f6105b2c796a51f197bb3552df6076809a08a" translate="yes" xml:space="preserve">
          <source>You will need to wrap the reducer you wish to enhance with &lt;code&gt;undoable&lt;/code&gt; function. For example, if you exported a &lt;code&gt;todos&lt;/code&gt; reducer from a dedicated file, you will want to change it to export the result of calling &lt;code&gt;undoable()&lt;/code&gt; with the reducer you wrote:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d71f702363520e8d52cd5cf66c6865dbac24253" translate="yes" xml:space="preserve">
          <source>You will probably want to remove the hash from the URL (e.g: &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt;). For doing this, you will need to also import &lt;code&gt;browserHistory&lt;/code&gt; from React Router:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847e7a43a897e6825651ba6a7171789bd4f8c993" translate="yes" xml:space="preserve">
          <source>You will use &lt;code&gt;connect()&lt;/code&gt; from &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate a container component. To determine whether to enable Undo and Redo buttons, you can check &lt;code&gt;state.todos.past.length&lt;/code&gt; and &lt;code&gt;state.todos.future.length&lt;/code&gt;. You won't need to write action creators for performing undo and redo because Redux Undo already provides them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced3f60087b9c7dc7b64e901bea63d5a41a88099" translate="yes" xml:space="preserve">
          <source>You would only use the named export for tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f002654c7b958bdea2528eaaa9c1e1ce5d2cfe9d" translate="yes" xml:space="preserve">
          <source>You'll know when you need Flux. If you aren't sure if you need it, you don't need it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e4884b4000a8d2ac41ed531bf7a37bd6a9faaa2" translate="yes" xml:space="preserve">
          <source>You'll often find that you need to store some data, as well as some UI state, in the state tree. This is fine, but try to keep the data separate from the UI state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483dc0e6baee4af78f1c3f12ab8f28dda9a34453" translate="yes" xml:space="preserve">
          <source>You've seen middleware in action in the &lt;a href=&quot;asyncactions&quot;&gt;Async Actions&lt;/a&gt; example. If you've used server-side libraries like &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; and &lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt;, you were also probably already familiar with the concept of &lt;em&gt;middleware&lt;/em&gt;. In these frameworks, middleware is some code you can put between the framework receiving a request, and the framework generating a response. For example, Express or Koa middleware may add CORS headers, logging, compression, and more. The best feature of middleware is that it's composable in a chain. You can use multiple independent third-party middleware in a single project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7028f3891ebf7e4827d5eaddfa0e16584b0b4466" translate="yes" xml:space="preserve">
          <source>Your dumb components should be pure; that is, they should produce the same output given the same input, and have no external dependencies. If you pass such a component an Immutable.JS object as a prop, you make it dependent upon Immutable.JS to extract the prop&amp;rsquo;s value and otherwise manipulate it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395dd2fb0c94aec217ae48791e24ace04816fc89" translate="yes" xml:space="preserve">
          <source>Your process will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b13a159884d03a53c5b0abbb9540e28b3419ef7" translate="yes" xml:space="preserve">
          <source>Your selectors should return Immutable.JS objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281e35c0465b8b3d761e36f053ead41086e72367" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;enhancer&lt;/code&gt;] &lt;em&gt;(Function)&lt;/em&gt;: The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87286375e4668a58823fba92d2b07b7a44fc0be4" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;preloadedState&lt;/code&gt;] &lt;em&gt;(any)&lt;/em&gt;: The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced &lt;code&gt;reducer&lt;/code&gt; with &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt;, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your &lt;code&gt;reducer&lt;/code&gt; can understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70c7e915a4a2b3601daa15f9ed309a470505e50" translate="yes" xml:space="preserve">
          <source>and configure it to use ES2015 features in &lt;code&gt;.babelrc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3ab734b4fb4c62257230890e59143d0e998962" translate="yes" xml:space="preserve">
          <source>and pass it to the &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in order to remove the hash from the URL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f432ecbf9e6a7a5c1f170d992e60626ab120d96" translate="yes" xml:space="preserve">
          <source>and run &lt;code&gt;npm test&lt;/code&gt; to run it once, or &lt;code&gt;npm run test:watch&lt;/code&gt; to test on every file change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81edf81cd89734f8439987c58e09f5451875a46" translate="yes" xml:space="preserve">
          <source>and then pass the state along to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3894228d526596c3cf53c57bbed5aae8b11537a" translate="yes" xml:space="preserve">
          <source>applyMiddleware()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ad41cdd6bf4c2b18169a773d483861384cd204" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middleware)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fedb9730abc492e1bcf1596264f044b04661aab" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middlewares)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f5c37526331395762baf88047f99e6d8b619f94" translate="yes" xml:space="preserve">
          <source>bindActionCreators()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e632a0686333c0fcc1b71ebd9b524a2ddd992d" translate="yes" xml:space="preserve">
          <source>bindActionCreators(actionCreators, dispatch)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3042d6bd02c4ca7273effadee7e63bf42bed16c9" translate="yes" xml:space="preserve">
          <source>calls the appropriate reducer and passes it the slice;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cf4ce11b3b5577a3871fe5b3cd80587b04a46c" translate="yes" xml:space="preserve">
          <source>can be tested like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991b9417df7c9c174211ba006b7edc0195725286" translate="yes" xml:space="preserve">
          <source>combineReducers()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f164696008c84fbdf8d8f93fe6bbfa9b14e143" translate="yes" xml:space="preserve">
          <source>combineReducers(reducers)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8dc852570744e8e3067cca75ce9fe7af17afec8" translate="yes" xml:space="preserve">
          <source>compose()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5745a141fb4592e3d9eb885924e51235574f61c6" translate="yes" xml:space="preserve">
          <source>compose(...functions)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112d9f2631778cd8a08a4296c2ccbf312712f2b3" translate="yes" xml:space="preserve">
          <source>cpsubrian: React decorators for redux/react-router/immutable &amp;lsquo;smart&amp;rsquo; components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ba045109577a1f4ae2fedc6ca6e16e7cec8d37" translate="yes" xml:space="preserve">
          <source>create a fresh, new Redux store instance on every request;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44915cfa2285ca11f257a840e99d4d3f28fc3a7" translate="yes" xml:space="preserve">
          <source>createStore()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ab01e2a484c9683cca2393d2ba3c93180699ee0" translate="yes" xml:space="preserve">
          <source>createStore(reducer, [preloadedState], [enhancer])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa33131b6a660bc8d77fd4bb48a66d021301526" translate="yes" xml:space="preserve">
          <source>creates a reference to the current state slice referred to by each key;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a4682977bb863d850d9eae5d719e2585e731e5" translate="yes" xml:space="preserve">
          <source>creates a reference to the possibly-mutated state slice that's returned by the reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="280c1cc5f52574880ff013357b30094632bcbd78" translate="yes" xml:space="preserve">
          <source>dispatch(action)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e86cff86751f0236e17d84f44ac6dc44060213" translate="yes" xml:space="preserve">
          <source>for scale, we have ~500 action types, ~400 reducer cases, ~150 components, 5 middlewares, ~200 actions, ~2300 tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe375f56e9a0fa7dc88b61b3c4b3425c5636e79" translate="yes" xml:space="preserve">
          <source>getState()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cffe5ee80305aeabc52048276f1acf872533639" translate="yes" xml:space="preserve">
          <source>is equivalent to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0bbc97bd6780fb3baf83d4730c736904a39e76" translate="yes" xml:space="preserve">
          <source>optionally dispatch some actions;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7916345e570f1bcf19d018b0792a5db68935506" translate="yes" xml:space="preserve">
          <source>pull the state out of store;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ad63d785b9b9fdb536fac77ce747b9c5a69bc1" translate="yes" xml:space="preserve">
          <source>react-redux-jwt-auth-example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52295e92a7867dd2bf6e329dcebd064d09c14653" translate="yes" xml:space="preserve">
          <source>redux-immutable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88f184d5bfff1ab2b78bc41b8b30999ba677a10" translate="yes" xml:space="preserve">
          <source>replaceReducer(nextReducer)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9bbe4119c43d2a84a043196b4690c761b01d0a" translate="yes" xml:space="preserve">
          <source>subscribe(listener)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c8253fda7262249d6aacde189c2d069461b383" translate="yes" xml:space="preserve">
          <source>the keys &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;counter&lt;/code&gt; each refer to a separate state slice;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd2b6bf0fb616dda82e8ec1df11d135e0adf003" translate="yes" xml:space="preserve">
          <source>the values &lt;code&gt;myTodosReducer&lt;/code&gt; and &lt;code&gt;myCounterReducer&lt;/code&gt; are reducer functions, with each acting on the state slice identified by the respective key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="365862a50c0682caa8baa6f30edca76e3e5f81ed" translate="yes" xml:space="preserve">
          <source>where:</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
