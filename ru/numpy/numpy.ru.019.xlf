<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="9b1fda8ace6e89d25e3a8cbabcfb78e28c9ddeb0" translate="yes" xml:space="preserve">
          <source>to +1 for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e306ad4de2ed181679e6ab7fcaaee69ea6e7e1" translate="yes" xml:space="preserve">
          <source>to fix the data length problem, and &lt;a href=&quot;#input-arrays&quot;&gt;Input Arrays&lt;/a&gt; will work fine, but &lt;a href=&quot;#in-place-arrays&quot;&gt;In-Place Arrays&lt;/a&gt; might fail type-checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ae7b35dde44fa5c9d357b7f07fa08e3cb46013" translate="yes" xml:space="preserve">
          <source>to represent each value uniquely. Different elements may have a different number of digits. The value of the &lt;code&gt;precision&lt;/code&gt; option is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd8cb2bcd4a9b931952c41222fa43febd3bb03f" translate="yes" xml:space="preserve">
          <source>to the working build directory for you project, and this problem will be fixed. It is suggested that you do this anyway, as it only increases the capabilities of your Python interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0379d428ea0f0836a773a332a60958d79cf24b5a" translate="yes" xml:space="preserve">
          <source>transpose</source>
          <target state="translated">transpose</target>
        </trans-unit>
        <trans-unit id="5f946e1ced44070d1839f34b41052d7bd12f3944" translate="yes" xml:space="preserve">
          <source>tuple of array dimensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695101fbec8a1b13644c179a7dd1f7522255d005" translate="yes" xml:space="preserve">
          <source>tuple of bytes steps in each dimension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4446d1731f587461a48f513954e125002636bb7" translate="yes" xml:space="preserve">
          <source>tuple of int_types: functions as does a single int_type argument, except that the argument is interpreted as an nd-index into the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e46bf3f7ea41c027482ef49f372e0e7d17dcfc2" translate="yes" xml:space="preserve">
          <source>tuple of ints: &lt;code&gt;i&lt;/code&gt; in the &lt;code&gt;j&lt;/code&gt;-th place in the tuple means &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s &lt;code&gt;i&lt;/code&gt;-th axis becomes &lt;code&gt;a.transpose()&lt;/code&gt;&amp;rsquo;s &lt;code&gt;j&lt;/code&gt;-th axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28c5d1a070327205b30fe8531773766ea947a03" translate="yes" xml:space="preserve">
          <source>tuple of iterators along &lt;code&gt;self&lt;/code&gt;&amp;rsquo;s &amp;ldquo;components.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8ce8fa84c719c1bbcf894bbe004f41bdb9ca06" translate="yes" xml:space="preserve">
          <source>two 128-bit floats, platform?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a273fc5b4b2f1ccd2810a037fdece1201f24956" translate="yes" xml:space="preserve">
          <source>two 32-bit floats</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3137ebae0faac986aa18ecd2cf17247e93cf8551" translate="yes" xml:space="preserve">
          <source>two 64-bit floats</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d4a988d03f6a10ddf77712e9a2326afd520a52" translate="yes" xml:space="preserve">
          <source>two 96-bit floats, platform?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e69892ab49df85c6230ccc57f8e1d1606caccc" translate="yes" xml:space="preserve">
          <source>u</source>
          <target state="translated">u</target>
        </trans-unit>
        <trans-unit id="f176e851b7e196ef0d57ceb9e9c0d534373fab76" translate="yes" xml:space="preserve">
          <source>ufunc.accumulate()</source>
          <target state="translated">ufunc.accumulate()</target>
        </trans-unit>
        <trans-unit id="3afb2f2c14b058d406a7d011ba9e9fcb61cb4d5b" translate="yes" xml:space="preserve">
          <source>ufunc.at()</source>
          <target state="translated">ufunc.at()</target>
        </trans-unit>
        <trans-unit id="b2203289069bb97ba80f99e40ed94c691de1e5d3" translate="yes" xml:space="preserve">
          <source>ufunc.identity</source>
          <target state="translated">ufunc.identity</target>
        </trans-unit>
        <trans-unit id="7f555ddeb7c7ab8bb8e00ea4525da52b4aa57d26" translate="yes" xml:space="preserve">
          <source>ufunc.nargs</source>
          <target state="translated">ufunc.nargs</target>
        </trans-unit>
        <trans-unit id="11242754eba2d4a40a968da3622059ecc44c27bc" translate="yes" xml:space="preserve">
          <source>ufunc.nin</source>
          <target state="translated">ufunc.nin</target>
        </trans-unit>
        <trans-unit id="6f73343cc6915896eef6f0fc25b8f995ccdd30a6" translate="yes" xml:space="preserve">
          <source>ufunc.nout</source>
          <target state="translated">ufunc.nout</target>
        </trans-unit>
        <trans-unit id="243b3229b9bbd3c76f87557d62d03aaae946243b" translate="yes" xml:space="preserve">
          <source>ufunc.ntypes</source>
          <target state="translated">ufunc.ntypes</target>
        </trans-unit>
        <trans-unit id="0ca5a5c1905a8786fd349c797dbd655dce528380" translate="yes" xml:space="preserve">
          <source>ufunc.outer()</source>
          <target state="translated">ufunc.outer()</target>
        </trans-unit>
        <trans-unit id="740194df52956c6a322db7bcdcab2b25c5a1eb8d" translate="yes" xml:space="preserve">
          <source>ufunc.reduce()</source>
          <target state="translated">ufunc.reduce()</target>
        </trans-unit>
        <trans-unit id="055c89ccb210644ad33e5681a3a32b73719c2341" translate="yes" xml:space="preserve">
          <source>ufunc.reduceat()</source>
          <target state="translated">ufunc.reduceat()</target>
        </trans-unit>
        <trans-unit id="466a95f51c8cc8d8d5e429f560cb744517f8b29b" translate="yes" xml:space="preserve">
          <source>ufunc.signature</source>
          <target state="translated">ufunc.signature</target>
        </trans-unit>
        <trans-unit id="3ffc066183d2e5c8b2ed6e5dbd4492deded40174" translate="yes" xml:space="preserve">
          <source>ufunc.types</source>
          <target state="translated">ufunc.types</target>
        </trans-unit>
        <trans-unit id="8012ff51a005eaa8ed8f4c08ccdce580f462fff6" translate="yes" xml:space="preserve">
          <source>unchanged</source>
          <target state="translated">unchanged</target>
        </trans-unit>
        <trans-unit id="a1a69d7d1c031266d6f1c7384fcd34f9b338ab59" translate="yes" xml:space="preserve">
          <source>unsigned Py_intptr_t (an integer that is the size of a pointer on the platform).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc18dcd473df56e24394a603bf719736a1efe79" translate="yes" xml:space="preserve">
          <source>unsigned byte</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d916941b2254a2d922c096a6c0813816f84bdb" translate="yes" xml:space="preserve">
          <source>unsigned char; The constants &lt;a href=&quot;c-api.array#c.NPY_FALSE&quot;&gt;&lt;code&gt;NPY_FALSE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;c-api.array#c.NPY_TRUE&quot;&gt;&lt;code&gt;NPY_TRUE&lt;/code&gt;&lt;/a&gt; are also defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2626ac7a48f1f07a409dbf9acb1e5814c8a9defa" translate="yes" xml:space="preserve">
          <source>unsigned int</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0808dbcd7aef8dc0ee223e4d84cd8a2ddafdc83" translate="yes" xml:space="preserve">
          <source>unsigned integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995d911a51805fb95053a05be72eb2908963d90c" translate="yes" xml:space="preserve">
          <source>unsigned short</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2b128800d4e129def769b7ec5decc00517fa8b" translate="yes" xml:space="preserve">
          <source>us</source>
          <target state="translated">us</target>
        </trans-unit>
        <trans-unit id="bb5dbce7c7fc91e42137b7ed0b685952e8d18f3b" translate="yes" xml:space="preserve">
          <source>used the nditer as a context manager using the &lt;code&gt;with&lt;/code&gt; statement, and the temporary data will be written back when the context is exited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d8b8731ae45d0b6f7734d6c02fc8c99ebc80ed3" translate="yes" xml:space="preserve">
          <source>values automatically have whitespace removed from the end when indexed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5baec5c424b72a798ed9e6ad67fb93a926716bd8" translate="yes" xml:space="preserve">
          <source>values to insert at those indices. Its shape and dimension are broadcast to match that of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de50d502d1b349419ea8b503c480391588e6829" translate="yes" xml:space="preserve">
          <source>variable PATH. Equivalent to posix &lt;code&gt;which&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09f1aceeed50982588504b15839a69838e80256" translate="yes" xml:space="preserve">
          <source>vecmat</source>
          <target state="translated">vecmat</target>
        </trans-unit>
        <trans-unit id="9bc50cca69cebe36a27161a0fa8f357300da80cd" translate="yes" xml:space="preserve">
          <source>vector-matrix multiplication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e235514259ccc281233d75d56bc01af9e085dd" translate="yes" xml:space="preserve">
          <source>vector-vector multiplication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e26fc16e498359404951f7d38e364302a88ad14" translate="yes" xml:space="preserve">
          <source>vectorize.__call__()</source>
          <target state="translated">vectorize.__call__()</target>
        </trans-unit>
        <trans-unit id="19399207372e8d7c054365b0a529ccf2981f3b82" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.endswith.html#numpy.chararray.endswith&quot;&gt;&lt;code&gt;endswith&lt;/code&gt;&lt;/a&gt;) and infix operators (e.g. &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b72c98ed88bb4df85be360c468c57b064be204e" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;a href=&quot;numpy.char.chararray.endswith#numpy.char.chararray.endswith&quot;&gt;&lt;code&gt;endswith&lt;/code&gt;&lt;/a&gt;) and infix operators (e.g. &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b595ca1ad64c45adbaa59fe3b6b7fb1e998d72d6" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;code&gt;str.endswith&lt;/code&gt;) and infix operators (e.g. &lt;code&gt;+, *, %&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e122cd45e8e9df8c348e263b4143f2a68e76e98d" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;code&gt;str.endswith&lt;/code&gt;) and infix operators (e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;,``%``)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd190f5456486754027935ce9caa900beed7ccd" translate="yes" xml:space="preserve">
          <source>version:</source>
          <target state="translated">version:</target>
        </trans-unit>
        <trans-unit id="e9cede9b80ea3abd89c755f1117337d429162c86" translate="yes" xml:space="preserve">
          <source>void</source>
          <target state="translated">void</target>
        </trans-unit>
        <trans-unit id="48b1339239922b5e07d5ce4184fcf5e87effde2b" translate="yes" xml:space="preserve">
          <source>von Mises, R., &amp;ldquo;Mathematical Theory of Probability and Statistics&amp;rdquo;, New York: Academic Press, 1964.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddc3bec9c70c5c7e765cd8cf5fa5aa389917ef0" translate="yes" xml:space="preserve">
          <source>warn: Print a &lt;code&gt;RuntimeWarning&lt;/code&gt; (via the Python &lt;a href=&quot;https://docs.python.org/dev/library/warnings.html#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ee32d825d6ddb4025ab74af0609969ecc419c8" translate="yes" xml:space="preserve">
          <source>week</source>
          <target state="translated">week</target>
        </trans-unit>
        <trans-unit id="916d4dfd40fa788d4f97c5cbd19732b935ee5e9e" translate="yes" xml:space="preserve">
          <source>what are the names of the &amp;ldquo;&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt;&amp;rdquo; of the structure, by which they can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdf2c9a9320c2bb30296f2a5be0fd38903dcd4d" translate="yes" xml:space="preserve">
          <source>what exactly &lt;code&gt;seq&lt;/code&gt; is. Is it a single value to be altered in-place? Is it an array, and if so what is its length? Is it input-only? Output-only? Input-output? &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; cannot determine these details, and does not attempt to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52be18891fe12a3ccc69a948daf4a9df395f8160" translate="yes" xml:space="preserve">
          <source>what is the data-type of each &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;field&lt;/a&gt;, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0192f6d7a8d53807254215b637508c53444c530" translate="yes" xml:space="preserve">
          <source>when &lt;code&gt;i = len(indices) - 1&lt;/code&gt; (so for the last index), &lt;code&gt;indices[i+1] = a.shape[axis]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46148cc3b4d2b3ac8073f14b0cba7f25ffff54bd" translate="yes" xml:space="preserve">
          <source>where</source>
          <target state="translated">where</target>
        </trans-unit>
        <trans-unit id="cfaf285482cf6c4f89cd534ed09bc1fa065bdd59" translate="yes" xml:space="preserve">
          <source>where &amp;lt;package install directory&amp;gt; is the package (or sub-package) directory such as &amp;lsquo;/usr/lib/python2.4/site-packages/mypackage&amp;rsquo; (&amp;lsquo;C: Python2.4 Lib site-packages mypackage&amp;rsquo;) or &amp;lsquo;/usr/lib/python2.4/site- packages/mypackage/mysubpackage&amp;rsquo; (&amp;lsquo;C: Python2.4 Lib site-packages mypackage mysubpackage&amp;rsquo;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27722a8f94c49a1d17c79d2d98a28d7cd4fd50e2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Chebyshev polynomial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833860b51f45a74ee06a8481e7b59dec2776a9c5" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Hermite polynomial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69795dbab93fd4905d0bc022d8ac56b6e1e0f54" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the HermiteE polynomial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde30796ed968ed7657f0df45af477fbb40047da" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Laguerre polynomial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b4ff5c9a6986803c5708a92c411c4b253dec9c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Legendre polynomial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538f7fb88a53c793cea30da00779237a649749e0" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the power of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de9c198e8ca08018e505031f38efeea306eb563" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Chebyshev polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c023f7138aa8d794b6a146fabd54c47a0508cbe" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Hermite polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cf2ba80598064afebb705d3f96da951d339ad7" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the HermiteE polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931ddf7a677dd0bb054e68bb0682795a7ecb2d44" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Laguerre polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4f668563e3498fcf093b6cc70e0bf28243dbb5" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Legendre polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae534bb750508bd12922fca33e07ed9e9147c7d1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the powers of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968a8f99ae65dc781347987604737e4885f0347e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Chebyshev polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290595042428a0adec26dcab062e9c72d203d119" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Hermite polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3522d9ec4777ff57457a39fea3d27eb87e001f3" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the HermiteE polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21aabee789ef859247cb7d579e69b9306ad94e9" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Laguerre polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fec4bcf4d4a798ecc63d7a8b21b974ec59ac767" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Legendre polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef93d8eb54977daa7c98c55d5dde9a9422edf21b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the powers of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8c6ec18c2c43533633b2d6348c84d0e98e4282" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;V&lt;/code&gt; is the pseudo Vandermonde matrix of &lt;code&gt;x&lt;/code&gt;, the elements of &lt;code&gt;c&lt;/code&gt; are the coefficients to be solved for, and the elements of &lt;code&gt;y&lt;/code&gt; are the observed values. This equation is then solved using the singular value decomposition of &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed15d23c255396f5ff96e362455881dfb6045bf" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;V&lt;/code&gt; is the weighted pseudo Vandermonde matrix of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; are the coefficients to be solved for, &lt;code&gt;w&lt;/code&gt; are the weights, &lt;code&gt;y&lt;/code&gt; are the observed values. This equation is then solved using the singular value decomposition of &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d134ecc4ceb9149fc7a25fccd08e5a7a0a731874" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;V&lt;/code&gt; is the weighted pseudo Vandermonde matrix of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; are the coefficients to be solved for, &lt;code&gt;w&lt;/code&gt; are the weights, and &lt;code&gt;y&lt;/code&gt; are the observed values. This equation is then solved using the singular value decomposition of &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ef8bc2bec31043ebddcd21aa113fe148170b4b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;n == len(roots) - 1&lt;/code&gt;; note that this implies that &lt;code&gt;1&lt;/code&gt; is always returned for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4156f50382951be2ffb97afbef02067c099be6a8" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;deg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da8ce8d8d1ee0181c57af0f31c56ab31f259987" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;n&lt;/code&gt; is the number of streams spawned. If a program uses an aggressive million streams, about</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="227e7320c448b66cb7c7d238597d7f3a2804dfcf" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;p&lt;/code&gt; is the probability of success of an individual trial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e11a7633599dcc0b171bd3aeedc2980516829b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;seq&lt;/code&gt; would be a NumPy array of &lt;code&gt;double&lt;/code&gt; values, and its length &lt;code&gt;n&lt;/code&gt; would be extracted from &lt;code&gt;seq&lt;/code&gt; internally before being passed to the C routine. Even better, since NumPy supports construction of arrays from arbitrary Python sequences, &lt;code&gt;seq&lt;/code&gt; itself could be a nearly arbitrary sequence (so long as each element can be converted to a &lt;code&gt;double&lt;/code&gt;) and the wrapper code would internally convert it to a NumPy array before extracting its data and length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa7dcc068f2c1b22079c4e51b9b1d150978fe4d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;x2&lt;/code&gt; is often taken to be 0.5, but 0 and 1 are also sometimes used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9eda89bfd511983f4021317b7dd5833b1e827e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;{bits}&lt;/code&gt; is the number of bits in the type and can be &lt;strong&gt;8&lt;/strong&gt;, &lt;strong&gt;16&lt;/strong&gt;, &lt;strong&gt;32&lt;/strong&gt;, &lt;strong&gt;64&lt;/strong&gt;, 128, and 256 for integer types; 16, &lt;strong&gt;32&lt;/strong&gt; , &lt;strong&gt;64&lt;/strong&gt;, 80, 96, 128, and 256 for floating-point types; and 32, &lt;strong&gt;64&lt;/strong&gt;, &lt;strong&gt;128&lt;/strong&gt;, 160, 192, and 512 for complex-valued types. Which bit-widths are available is platform dependent. The bolded bit-widths are usually available on all platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc8cdc0932dfe2cf825eb22285d6dc4584efd79" translate="yes" xml:space="preserve">
          <source>where &lt;strong&gt;I&lt;/strong&gt; is the &lt;code&gt;n&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt; identity matrix. &lt;a href=&quot;#r6c2ffae921d1-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d65fe7270866ad53495d99232a820922277569" translate="yes" xml:space="preserve">
          <source>where R is a non-nan real value. Complex values with the same nan placements are sorted according to the non-nan part if it exists. Non-nan values are sorted as before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5caa3907f70cffcfedf3fb4994a98de6a74be54f" translate="yes" xml:space="preserve">
          <source>where in this case the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0047659d01e6a2429cd941ed10ecc15806ec5e4" translate="yes" xml:space="preserve">
          <source>where p = probability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca92675847cdd29f796e592505c1d46281fcc976" translate="yes" xml:space="preserve">
          <source>where the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1ce56b739d1a90c6c7a8decdd89da276904513" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;r_n&lt;/code&gt; are the roots specified in &lt;code&gt;roots&lt;/code&gt;. If a zero has multiplicity n, then it must appear in &lt;code&gt;roots&lt;/code&gt; n times. For instance, if 2 is a root of multiplicity three and 3 is a root of multiplicity 2, then &lt;code&gt;roots&lt;/code&gt; looks something like [2, 2, 2, 3, 3]. The roots can appear in any order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de25e1e31fb8e144046ff201f8ad1ae5facb6b87" translate="yes" xml:space="preserve">
          <source>where the normalization, B, is the beta function,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1279820475c803c32a1be658737be93ee2a97148" translate="yes" xml:space="preserve">
          <source>where the points &lt;code&gt;(a, b)&lt;/code&gt; consist of all pairs formed by taking &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;y&lt;/code&gt;. The resulting points form a grid with &lt;code&gt;x&lt;/code&gt; in the first dimension and &lt;code&gt;y&lt;/code&gt; in the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6af8e5313e77ee7d6837ec79be794a7042e7075" translate="yes" xml:space="preserve">
          <source>where the points &lt;code&gt;(a, b, c)&lt;/code&gt; consist of all triples formed by taking &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; from &lt;code&gt;z&lt;/code&gt;. The resulting points form a grid with &lt;code&gt;x&lt;/code&gt; in the first dimension, &lt;code&gt;y&lt;/code&gt; in the second, and &lt;code&gt;z&lt;/code&gt; in the third.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="365862a50c0682caa8baa6f30edca76e3e5f81ed" translate="yes" xml:space="preserve">
          <source>where:</source>
          <target state="translated">where:</target>
        </trans-unit>
        <trans-unit id="e37dbee4cae0df6201c1f4811e9b9537f69aabb6" translate="yes" xml:space="preserve">
          <source>which evaluates to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01e140cc92cbe722c0b95c684104ebb6b342985" translate="yes" xml:space="preserve">
          <source>which extends in the obvious way to higher dimensions, and the inverses in higher dimensions also extend in the same way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced4c5cabdd3ef65db772d8c6ef758745f7d3e32" translate="yes" xml:space="preserve">
          <source>which is different from a common alternative,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee66060f3ffdf52489d6d257097e268641308e4" translate="yes" xml:space="preserve">
          <source>which is related to &lt;code&gt;c_{av}[k]&lt;/code&gt; by &lt;code&gt;c'_{av}[k] = c_{av}[-k]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778d43b6da6e59d12f7b859a3d029062778f7c7d" translate="yes" xml:space="preserve">
          <source>which part of the memory block each field takes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03234ac0a2f49221ceb858c5491d51de84061ef9" translate="yes" xml:space="preserve">
          <source>which provides 5 pointers. The first is an opaque pointer to the data structure used by the BitGenerators. The next three are function pointers which return the next 64- and 32-bit unsigned integers, the next random double and the next raw value. This final function is used for testing and so can be set to the next 64-bit unsigned integer function if not needed. Functions inside &lt;code&gt;Generator&lt;/code&gt; use this structure as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63577216ef75495c55551997ebb50867df34281b" translate="yes" xml:space="preserve">
          <source>which would have provided automatic type conversions for arrays of type &lt;code&gt;Py_complex&lt;/code&gt;, &lt;code&gt;npy_cfloat&lt;/code&gt; and &lt;code&gt;npy_cdouble&lt;/code&gt;. However, it seemed unlikely that there would be any independent (non-Python, non-NumPy) application code that people would be using &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; to generate a Python interface to, that also used these definitions for complex types. More likely, these application codes will define their own complex types, or in the case of C++, use &lt;code&gt;std::complex&lt;/code&gt;. Assuming these data structures are compatible with Python and NumPy complex types, &lt;code&gt;%numpy_typemap&lt;/code&gt; expansions as above (with the user&amp;rsquo;s complex type substituted for the first argument) should work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2776b6c93cb7c4153849413953e56a2e5f33d80a" translate="yes" xml:space="preserve">
          <source>width:</source>
          <target state="translated">width:</target>
        </trans-unit>
        <trans-unit id="5c7e83ac1040b10c50be2504c71c5845f663b6fd" translate="yes" xml:space="preserve">
          <source>will compile the &lt;code&gt;library&lt;/code&gt; sources without optimization flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d20a2ce8660814e46481f17cf57f185c268fa43" translate="yes" xml:space="preserve">
          <source>will install data files to the following locations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9431832ed81f189de77da34df58a265d7a0dab02" translate="yes" xml:space="preserve">
          <source>will install these data files to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf97db7680020e322957977ba54cdaae4e7c664" translate="yes" xml:space="preserve">
          <source>will result in typemaps that will produce code that reference improper data lengths. You can implement the following macro expansion:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09fffb5db2d7f631ba43ccc256617b444056d2e" translate="yes" xml:space="preserve">
          <source>win32</source>
          <target state="translated">win32</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
        <trans-unit id="85906e975567ef059f93ee1ec6cded27b66be258" translate="yes" xml:space="preserve">
          <source>with a and v sequences being zero-padded where necessary and conj being the conjugate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4da7b2e3434f85dca212e250f77b33115633d3" translate="yes" xml:space="preserve">
          <source>with assert_warns(SomeWarning):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475445d83d4b5fb4eb9cadb9634afa9926972eb2" translate="yes" xml:space="preserve">
          <source>with the weight function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9106aaf08247a295732f94cac129b955c2a6cce" translate="yes" xml:space="preserve">
          <source>with their Taylor series expansion, this translates into solving the following the linear system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ac21e5524a785601b5d72a44f59a41ff0de1fa" translate="yes" xml:space="preserve">
          <source>with which we now extract only three elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73978edcd3b1eeaba9e3510afd89a742dbbd379c" translate="yes" xml:space="preserve">
          <source>work space</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d664dcdca19ca8d9b446631ef2412473ee2226f1" translate="yes" xml:space="preserve">
          <source>worst case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1f2b93f598ca8c33b6833c0a41bac0f1e8474a" translate="yes" xml:space="preserve">
          <source>wrap values &amp;lt; 0 by adding len(&lt;em&gt;op&lt;/em&gt;) and values &amp;gt;=len(&lt;em&gt;op&lt;/em&gt;) by subtracting len(&lt;em&gt;op&lt;/em&gt;) until they are in range;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f6ad8ec52a2984abaafd7c3b516503785c2072" translate="yes" xml:space="preserve">
          <source>x</source>
          <target state="translated">x</target>
        </trans-unit>
        <trans-unit id="308f064ded46d05826bfd10e2ded24601eb24df9" translate="yes" xml:space="preserve">
          <source>x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59dd422e447dd066581be0b92845e52e84b598c5" translate="yes" xml:space="preserve">
          <source>x-coordinates of the &lt;code&gt;M&lt;/code&gt; sample (data) points &lt;code&gt;(x[i], y[i])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba94ec9deda2ba79411318119236f9d9739ce86c" translate="yes" xml:space="preserve">
          <source>x-coordinates of the M sample points &lt;code&gt;(x[i], y[i])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb437551401adf121138e8924c8f0383053f491" translate="yes" xml:space="preserve">
          <source>x.__getitem__(y) &amp;lt;==&amp;gt; x[y]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc9be9752ea52874fd39a2bdad0f5823c5b6118" translate="yes" xml:space="preserve">
          <source>x.__setitem__(i, y) &amp;lt;==&amp;gt; x[i]=y</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da421920ce1bd5a03d063f77e2157e2573edaac2" translate="yes" xml:space="preserve">
          <source>xP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b073b5ec82f790856556cc378140ccaef2424ed" translate="yes" xml:space="preserve">
          <source>xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x)))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef078637a19fed7e5c5fce6ae955f054edcce03b" translate="yes" xml:space="preserve">
          <source>xP_i(x) = (P_{i + 1}(x)/2 + i*P_{i - 1}(x))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e771f58043b3b39cee02a1814b5e97f817e4084" translate="yes" xml:space="preserve">
          <source>y : A floating point representation of Not a Number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe74eb20b81eed402c9b311b14c54faa75f17f0e" translate="yes" xml:space="preserve">
          <source>y = floor(&lt;code&gt;x1&lt;/code&gt;/&lt;code&gt;x2&lt;/code&gt;) This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0153765279a24863ca46c77e0a9178c4b4e2152f" translate="yes" xml:space="preserve">
          <source>y is an array of the same subtype as &lt;code&gt;a&lt;/code&gt;, with shape &lt;code&gt;(a.size,)&lt;/code&gt;. Note that matrices are special cased for backward compatibility, if &lt;code&gt;a&lt;/code&gt; is a matrix, then y is a 1-D ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b29d0659535339d20f2f2d3906d3133889c3fc" translate="yes" xml:space="preserve">
          <source>y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5bcca9b96afa5b616e3604f848cc87a49f687f" translate="yes" xml:space="preserve">
          <source>y-coordinates of the sample points. Several sets of sample points sharing the same x-coordinates can be (independently) fit with one call to &lt;a href=&quot;#numpy.polynomial.polynomial.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; by passing in for &lt;code&gt;y&lt;/code&gt; a 2-D array that contains one data set per column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff0b1538469338a0073e2cdaab6a517801b6ab4" translate="yes" xml:space="preserve">
          <source>year</source>
          <target state="translated">year</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="321f014e68afc5d27fa673e253b66c1d1a885e28" translate="yes" xml:space="preserve">
          <source>zero-dimensional numpy arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="851d6a9d4f40adec7bdb22e6aa7d78c29e7bad48" translate="yes" xml:space="preserve">
          <source>zero-terminated bytes (not recommended)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b16e4ea6cc467a3916252ca6ee5a838978ad9b6" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;&amp;gt;&amp;rsquo;, &amp;lsquo;B&amp;rsquo;} - big endian</source>
          <target state="translated">{&amp;lsquo;&amp;gt;&amp;rsquo;, &amp;lsquo;B&amp;rsquo;} - big endian</target>
        </trans-unit>
        <trans-unit id="69450a331083a0b68e4b8ea4f8d3ea5eed96797f" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;&amp;lt;&amp;rsquo;, &amp;lsquo;L&amp;rsquo;} - little endian</source>
          <target state="translated">{&amp;lsquo;&amp;lt;&amp;rsquo;, &amp;lsquo;L&amp;rsquo;} - little endian</target>
        </trans-unit>
        <trans-unit id="4a18b0c9674466129cdcccc0b853d0e7924dffb5" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;=&amp;rsquo;, &amp;lsquo;N&amp;rsquo;} - native order</source>
          <target state="translated">{&amp;lsquo;=&amp;rsquo;, &amp;lsquo;N&amp;rsquo;} - native order</target>
        </trans-unit>
        <trans-unit id="d8c7bacdfb9bb97d8000c8d86e26ecc69e84c128" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;|&amp;rsquo;, &amp;lsquo;I&amp;rsquo;} - ignore (no change to byte order)</source>
          <target state="translated">{&amp;lsquo;|&amp;rsquo;, &amp;lsquo;I&amp;rsquo;} - ignore (no change to byte order)</target>
        </trans-unit>
        <trans-unit id="129c2a92772859dd050db619eaedbf46e847091c" translate="yes" xml:space="preserve">
          <source>~n/2</source>
          <target state="translated">~n/2</target>
        </trans-unit>
        <trans-unit id="ff8c31042699d05d07f6e439438f8c8528e3badb" translate="yes" xml:space="preserve">
          <source>~self</source>
          <target state="translated">~self</target>
        </trans-unit>
        <trans-unit id="8105745e3f0510d3e2e069ea766a5a441edea419" translate="yes" xml:space="preserve">
          <source>“descr” : dtype.descr</source>
          <target state="translated">“descr” : dtype.descr</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
