<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="71fff5ea85661c16e7519843bc17a41ff8e91eb9" translate="yes" xml:space="preserve">
          <source>Distributions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b193321a119fbd0dcd684bd2d9426886ca75352" translate="yes" xml:space="preserve">
          <source>Divide one Chebyshev series by another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143efc24501a0aca7c9b8146445d3052ccca2768" translate="yes" xml:space="preserve">
          <source>Divide one Hermite series by another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59969920d0ad8492606516de2799361ab80e51e4" translate="yes" xml:space="preserve">
          <source>Divide one Laguerre series by another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8fb14724e04e74acd5ed518b7956bde57f9f7f" translate="yes" xml:space="preserve">
          <source>Divide one Legendre series by another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b11bc9ec8586eecc94bbdfc2f103e8f1cdcb61" translate="yes" xml:space="preserve">
          <source>Divide one polynomial by another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c51ce5484f877f3b3126642a285f454856b1a199" translate="yes" xml:space="preserve">
          <source>Divide other into self, and return a new masked array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef1e5ad95321353adac46fbc8491e615e836d21" translate="yes" xml:space="preserve">
          <source>Divide self by other in-place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e3c651961978f36b837c449de83e63bcfcd74e0" translate="yes" xml:space="preserve">
          <source>Divide self into other, and return a new masked array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdde9e15039c0cebf1238ec9b7a4737bb63abb02" translate="yes" xml:space="preserve">
          <source>Dividend array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94054a2bd282906d6045981a996c888ef4e4b84a" translate="yes" xml:space="preserve">
          <source>Dividend polynomial&amp;rsquo;s coefficients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3d5366321b2cda8048303484a9efb3b8012809" translate="yes" xml:space="preserve">
          <source>Dividend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da76ff26283ccdfb95f22f35e70c08074f9c0d6" translate="yes" xml:space="preserve">
          <source>Division by zero: infinite result obtained from finite numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c970858ddd5ebfccc0979913547b40892ea84f0" translate="yes" xml:space="preserve">
          <source>Division:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e528cec9df846efb2d96080851febbb0ef5214b8" translate="yes" xml:space="preserve">
          <source>Divisor array. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ac85bf74de66241c9334431207aa5df69df721" translate="yes" xml:space="preserve">
          <source>Divisor polynomial&amp;rsquo;s coefficients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a079e40a62a4209488cf119d0047ff12fb70cf71" translate="yes" xml:space="preserve">
          <source>Divisor. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a536da5cd434d26e0ec447ec43ce448909aa6d1" translate="yes" xml:space="preserve">
          <source>Divmod:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d78017db5e95583684a29d66eb903a8ce60aba4" translate="yes" xml:space="preserve">
          <source>Do a keyword search on docstrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9d279c47a9187c1db7b1f7b114b04d8f0172e5" translate="yes" xml:space="preserve">
          <source>Do not lose the type info if the sequence contains unknown objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d435c090c5ec2cb12a71fd3a6a6e5087869ea8" translate="yes" xml:space="preserve">
          <source>Do not rely on the combination of &lt;code&gt;tofile&lt;/code&gt; and &lt;a href=&quot;#numpy.fromfile&quot;&gt;&lt;code&gt;fromfile&lt;/code&gt;&lt;/a&gt; for data storage, as the binary files generated are are not platform independent. In particular, no byte-order or data-type information is saved. Data can be stored in the platform independent &lt;code&gt;.npy&lt;/code&gt; format using &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;save&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3e1823cbbdfbb28b0abf8529520a9bf10c3f493" translate="yes" xml:space="preserve">
          <source>Do not use the Python keywords &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; to combine logical array expressions. These keywords will test the truth value of the entire array (not element-by-element as you might expect). Use the bitwise operators &amp;amp; and | instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e01c221d853296d84e769113c74b2df4ca129d1" translate="yes" xml:space="preserve">
          <source>Doctests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974974af4b7655224f60ff495507eedae4f6994e" translate="yes" xml:space="preserve">
          <source>Doctests are a convenient way of documenting the behavior of a function and allowing that behavior to be tested at the same time. The output of an interactive Python session can be included in the docstring of a function, and the test framework can run the example and compare the actual output to the expected output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2706eec51222f32b825a53b6e68123a18fe8dfd" translate="yes" xml:space="preserve">
          <source>Documentation for the ufunc. Should not contain the function signature as this is generated dynamically when __doc__ is retrieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7bd4643db21c4724f9db11e4bb21b57a80e3fc" translate="yes" xml:space="preserve">
          <source>Does &lt;em&gt;not&lt;/em&gt; conjugate! For the complex conjugate transpose, use &lt;code&gt;.H&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0e5a02446a93df5c6a9418c49d06da3e217cfb" translate="yes" xml:space="preserve">
          <source>Does not check that the x-coordinate sequence &lt;code&gt;xp&lt;/code&gt; is increasing. If &lt;code&gt;xp&lt;/code&gt; is not increasing, the results are nonsense. A simple check for increasing is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a9483068c43f31f29b0fa4bbb6e7ded8b89453" translate="yes" xml:space="preserve">
          <source>Does not include memory consumed by non-element attributes of the array object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82197e5e2b65bee680b92d50de02f93e5275ccd4" translate="yes" xml:space="preserve">
          <source>Does their energy intake deviate systematically from the recommended value of 7725 kJ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda52ba5b69a393e193dac1fab0651122da1f1df" translate="yes" xml:space="preserve">
          <source>Doing a little timing in IPython shows that the reduced overhead and memory allocation of the Cython inner loop is providing a very nice speedup over both the straightforward Python code and an expression using NumPy&amp;rsquo;s built-in sum function.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2e054286be13032ccbf78259a0703d8d83b801" translate="yes" xml:space="preserve">
          <source>Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is [].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb122f9bcef4efacc38db644f8b8fbbbd3f1f52" translate="yes" xml:space="preserve">
          <source>Domain over which &lt;code&gt;func&lt;/code&gt; is interpolated. The default is None, in which case the domain is [-1, 1].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d15df66fa784a07d3132cdc84cc4e9d2a43f78" translate="yes" xml:space="preserve">
          <source>Domain to use for the returned series. If &lt;code&gt;None&lt;/code&gt;, then a minimal domain that covers the points &lt;code&gt;x&lt;/code&gt; is chosen. If &lt;code&gt;[]&lt;/code&gt; the class domain is used. The default value was the class domain in NumPy 1.4 and &lt;code&gt;None&lt;/code&gt; in later versions. The &lt;code&gt;[]&lt;/code&gt; option was added in numpy 1.5.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82edf41d9d3177c9bd118b575de636ba573d4e3f" translate="yes" xml:space="preserve">
          <source>Domain to use. The interval &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; is mapped to the interval &lt;code&gt;[window[0], window[1]]&lt;/code&gt; by shifting and scaling. The default value is [-1, 1].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b2e5d2cce01727bf325f6bd8595469a9076b39" translate="yes" xml:space="preserve">
          <source>Domain to use. The interval &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; is mapped to the interval &lt;code&gt;[window[0], window[1]]&lt;/code&gt; by shifting and scaling. The default value is [0, 1].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ef7d89dc77a04fadda76f62633917fa42d732a" translate="yes" xml:space="preserve">
          <source>Domains. Each domain must (successfully) convert to a 1-d array containing precisely two values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845a637b103bbcbbace502867de0ec52f11db37e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be fooled by this attribute&amp;rsquo;s name: &lt;code&gt;reduceat(a)&lt;/code&gt; is not necessarily smaller than &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f6c0cae180c1519a43cdaf129188e65581d9cb" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; for element-wise comparison of 2 arrays; when &lt;code&gt;a.shape[0]&lt;/code&gt; is 2, &lt;code&gt;maximum(a[0], a[1])&lt;/code&gt; is faster than &lt;code&gt;amax(a, axis=0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee45e18cb25f4ffa299fe638bc542425558ed71" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; for element-wise comparison of 2 arrays; when &lt;code&gt;a.shape[0]&lt;/code&gt; is 2, &lt;code&gt;minimum(a[0], a[1])&lt;/code&gt; is faster than &lt;code&gt;amin(a, axis=0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ed26a26d95479b379119608058dbb2109efb38" translate="yes" xml:space="preserve">
          <source>Dot product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Can be an int, float, or complex depending on the types of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b5eb09c46c81da930e48b39cbd0988e1d15009" translate="yes" xml:space="preserve">
          <source>Dot product of two arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69fc04836f683a90b063205daff794ec842891ec" translate="yes" xml:space="preserve">
          <source>Dot product of two arrays. Specifically,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10eebd1ec669729dbb8a387ff1f1ee83e265b551" translate="yes" xml:space="preserve">
          <source>Draw &lt;code&gt;size&lt;/code&gt; samples of dimension k from a Dirichlet distribution. A Dirichlet-distributed random variable can be seen as a multivariate generalization of a Beta distribution. The Dirichlet distribution is a conjugate prior of a multinomial distribution in Bayesian inference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cef6690ff1fb5f0c2316445230ab79655322c59" translate="yes" xml:space="preserve">
          <source>Draw each 100 values for lambda 100 and 500:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a1f06763debec752f9772c00b9c8c55a29d67f" translate="yes" xml:space="preserve">
          <source>Draw random samples from a multivariate normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8a71087c0197828056ce59780ae3569bbf2e6d" translate="yes" xml:space="preserve">
          <source>Draw random samples from a normal (Gaussian) distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c671d5af70be0d6ee7f133745fc1b0ba932a0dc3" translate="yes" xml:space="preserve">
          <source>Draw samples and plot the distribution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0efc43d29d4ab1659826dde574edba31ec35e3f" translate="yes" xml:space="preserve">
          <source>Draw samples from a 1-parameter Weibull distribution with the given shape parameter &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc465d9bb43792a6a4d6d0b79fc58926df796844" translate="yes" xml:space="preserve">
          <source>Draw samples from a Beta distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db385760aa8dd626fb9adb8853dfd6288a91a9df" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gamma distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ab6a861638484d02fed32908592521ecb292b9" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gumbel distribution with specified location and scale. For more information on the Gumbel distribution, see Notes and References below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a815e387ea9da74fa2238bda4162c421a8c8a9" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gumbel distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb301b24d49678b3e9fff80704432281d0df654a" translate="yes" xml:space="preserve">
          <source>Draw samples from a Hypergeometric distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836d1593a600cfcfb833fff8c11191d4c4c5d27a" translate="yes" xml:space="preserve">
          <source>Draw samples from a Pareto II or Lomax distribution with specified shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721b7e6dfb7ad60658e5e614aa751c343f6988fc" translate="yes" xml:space="preserve">
          <source>Draw samples from a Poisson distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a0b4d313dadcf54cda2bc4c9745765dcc56eb6" translate="yes" xml:space="preserve">
          <source>Draw samples from a Rayleigh distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cdf4a2aee4c3b56a5568531ce7576534f61561f" translate="yes" xml:space="preserve">
          <source>Draw samples from a Wald, or inverse Gaussian, distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16cd7ccf53dc2b531e1445308d5381898213743b" translate="yes" xml:space="preserve">
          <source>Draw samples from a Weibull distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e097ecaf2ff3b51bfb55b676dfdfa6cbd8e50b1" translate="yes" xml:space="preserve">
          <source>Draw samples from a Zipf distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b159750cd52438190e80fd2b264928bcdbbeffee" translate="yes" xml:space="preserve">
          <source>Draw samples from a binomial distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e18e00273a5fae8bbde1791f129e0cbe3bd2452" translate="yes" xml:space="preserve">
          <source>Draw samples from a chi-square distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7461bda090453d4ff12b83f4027e9d3a1946262b" translate="yes" xml:space="preserve">
          <source>Draw samples from a log-normal distribution with specified mean, standard deviation, and array shape. Note that the mean and standard deviation are not the values for the distribution itself, but of the underlying normal distribution it is derived from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418d59729801e30d611ad0edbc665078409b6f57" translate="yes" xml:space="preserve">
          <source>Draw samples from a log-normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1bc3727e4de5e7ab2b6eea3e4aaf62bfcf5bf0d" translate="yes" xml:space="preserve">
          <source>Draw samples from a logarithmic series distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259f9fd69d995b257a6d58ec3161de00c6ac8e73" translate="yes" xml:space="preserve">
          <source>Draw samples from a logistic distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caeefc0caf49fe896c077769862c6d8f2a2d4d55" translate="yes" xml:space="preserve">
          <source>Draw samples from a multinomial distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f26805ca2b4fd1c182f06df074a9a855b5c8e20" translate="yes" xml:space="preserve">
          <source>Draw samples from a negative binomial distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fad248b8adad205bba771cea1b6af2c597903fb" translate="yes" xml:space="preserve">
          <source>Draw samples from a noncentral chi-square distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9282b1d217bfacf12c8b8d4a104f2cce46e68b92" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Cauchy distribution with mode = 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf09a114ab7401dced2153d963e20885d1b64c6" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Gamma distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c3ce03d59dad5f0ba6dbc68a1db4e39a115c97" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Normal distribution (mean=0, stdev=1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5ed72650600061c64a7b3836210429f01c8df4" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Student&amp;rsquo;s t distribution with &lt;code&gt;df&lt;/code&gt; degrees of freedom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9791d093a2516b6b22df69cdc89a44c76c8547c" translate="yes" xml:space="preserve">
          <source>Draw samples from a uniform distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8dcd074131ab16cf48b101b69dbb09a06467e24" translate="yes" xml:space="preserve">
          <source>Draw samples from a von Mises distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f67bb2441c84f4b1162da84f12a83a78820075f" translate="yes" xml:space="preserve">
          <source>Draw samples from an F distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4cb12b4006c936a1a5eaa65c28e2a7372035b59" translate="yes" xml:space="preserve">
          <source>Draw samples from an exponential distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9016ff24a09fb989d28a00e24a13cde2696b4777" translate="yes" xml:space="preserve">
          <source>Draw samples from the Dirichlet distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fdcad14f303f834dc59b1f3dccb9f86e1705cd" translate="yes" xml:space="preserve">
          <source>Draw samples from the Laplace or double exponential distribution with specified location (or mean) and scale (decay).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308c6270dd43fde905a32469d95cef01a142bca2" translate="yes" xml:space="preserve">
          <source>Draw samples from the distribution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b28ac74b7769bfdc417f7f61e050393575dc125" translate="yes" xml:space="preserve">
          <source>Draw samples from the distribution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf043e5601b2f68702eac5005c66d1ebbc6a2030" translate="yes" xml:space="preserve">
          <source>Draw samples from the geometric distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570de821167a667775bfd8af3be681420e790f2f" translate="yes" xml:space="preserve">
          <source>Draw samples from the noncentral F distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c575768cb70c661f622a7746787703873a7fb9c5" translate="yes" xml:space="preserve">
          <source>Draw samples from the standard exponential distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc17866b1f3b7819078bdef07b4d9d1716739b78" translate="yes" xml:space="preserve">
          <source>Draw samples from the triangular distribution over the interval &lt;code&gt;[left, right]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1abf94062d6b0e1580c4eed26b19473395f5dd35" translate="yes" xml:space="preserve">
          <source>Draw ten thousand values from the geometric distribution, with the probability of an individual success equal to 0.35:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226c6736b8b9dc551d8a75e9fd86f951df1752ee" translate="yes" xml:space="preserve">
          <source>Draw values from a noncentral chisquare with very small noncentrality, and compare to a chisquare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3329d33efc5189ab8786b87fd997f1cb2a5fa5e8" translate="yes" xml:space="preserve">
          <source>Draw values from the distribution and plot the histogram</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb6c903d93ed4163d8a9ba3d7777ce26bf70cc2" translate="yes" xml:space="preserve">
          <source>Draw values from the distribution and plot the histogram:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345d5990ad5e8dc2505201d616bdccd87cd84e5e" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Fisher distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d957a8e68c68660a252e592ee001bf286ee4ee" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Gumbel distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3874e3e9ab062a1d7bfdc5d30325b887fbc419d7" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Laplace distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf05e207a79201534bfd254b9ef20861558f17e" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Pareto distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c373308c04f8e25032a7f57925fc2cd89f5c43" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Poisson distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800df344bc4e042b278de9e7bd37c782c2e5c6c8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Rayleigh distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c79cda5fd0d2766220ff50c40f50e59b603b40" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Wald distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881edd9192611978afca45ae863cda6f17a1d7fb" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Weibull distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec1a5674838f11821fe1b57bed9970f730915c8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Zipf distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3af0fcef04d64e093680f90bd154da4da6f7e6" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized beta distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66aa1280d92bc58e93f2dd0657680e02202ddedc" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803cd0d20a6c49e0eab984068f59353e0ec6f797" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized chi-square distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a07d0ff0927ba822ed7f54576b179ec4780bfd4" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized exponential distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f28dab17c9ec69c1e4c0816e2b49d0d97cc8c9" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized gamma distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645b194e18330c38a086d019ef409b1ad04a10ac" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized geometric distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675c1d8f69c01109a94a55f050b7feba6cfeb004" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized hypergeometric distribution. Each sample is the number of good items within a randomly selected subset of size &lt;code&gt;nsample&lt;/code&gt; taken from a set of &lt;code&gt;ngood&lt;/code&gt; good items and &lt;code&gt;nbad&lt;/code&gt; bad items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec5fd25c15e2f401571dd2213b5e63981af1884" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized log-normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c1e4b50e7e0ed6389caf6bd275c9d96e903819" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logarithmic series distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0418a31cc205f33ce6262d40794bf3e47add1b19" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logistic distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ad062ab33ce9488dba4d726621ff0742f56c11" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized negative binomial distribution, where each sample is equal to N, the number of failures that occurred before a total of n successes was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe023dcddff604c4223693c51bcae1660f6eba8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral Fisher distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dad06577da3cf941b7346f737f68fc3b67c036b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral chi-square distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7aa6be999ea249ca4e25e9eb3c5a161f178b65" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a239b9fd8457ca43a81ea8883cb90f669b784d" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized power distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417f5f8f2a7e8f51ee4be6e5ef1c8c34cc318b2f" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard Student&amp;rsquo;s t distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cfa7b49541ac131db1708e85662c20f82750d1b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard gamma distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c6b8b6588f6544b47569ada0a5521ca47031b8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized triangular distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ea0a59c91c46f3d89e817e79cad726c3dc2dab" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized uniform distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20dd8e0ca9375ee4c56dd90351efacbd5b573d8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized von Mises distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8b86177c95587cf24b6f015131fe691b9fc3ba" translate="yes" xml:space="preserve">
          <source>Drawn samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d18cceebff607d37e9bf2c1387fbd956866a568" translate="yes" xml:space="preserve">
          <source>Draws samples in [0, 1] from a power distribution with positive exponent a - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d056b5f5f0adde2e16d37463c52db860d944e35" translate="yes" xml:space="preserve">
          <source>Dtype for the structured array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6259462846b5f9baee7053eaac196aa6133053" translate="yes" xml:space="preserve">
          <source>Dtypes for structured arrays can be specified in several forms, but all forms specify at least the data type and field name. For details see &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#module-numpy.doc.structured_arrays&quot;&gt;&lt;code&gt;doc.structured_arrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffaaa2445408170b57b919ca6485e258a7c95d8b" translate="yes" xml:space="preserve">
          <source>Duda, R. O., Hart, P. E., and Stork, D. G., &amp;ldquo;Pattern Classification,&amp;rdquo; 2nd ed., New York: Wiley, 2001.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6baaefd65351906a350ba168fbf221f0d184adfa" translate="yes" xml:space="preserve">
          <source>Due to floating point rounding the resulting array may not be Hermitian, the diagonal elements may not be 1, and the elements may not satisfy the inequality abs(a) &amp;lt;= 1. The real and imaginary parts are clipped to the interval [-1, 1] in an attempt to improve on that situation but is not much help in the complex case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5668939217d0a50f3a990081bee30e034ec210d" translate="yes" xml:space="preserve">
          <source>Due to limitations in the interpretation of structured dtypes, dtypes with fields with empty names will have the names replaced by &amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, etc. Such arrays will not round-trip through the format entirely accurately. The data is intact; only the field names will differ. We are working on a fix for this. This fix will not require a change in the file format. The arrays with such structures can still be saved and restored, and the correct dtype may be restored by using the &lt;code&gt;loadedarray.view(correct_dtype)&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be47cf08679632a886113408bbed677d155a3d74" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5317185019827371b1e31a396e0d441834d3252" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file. The array can be read back with pickle.load or numpy.load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2c1b02316fce9ee22b42f7f9087251340c710e" translate="yes" xml:space="preserve">
          <source>During iteration, you may want to use the index of the current element in a computation. For example, you may want to visit the elements of an array in memory order, but use a C-order, Fortran-order, or multidimensional index to look up values in a different array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a97e818f2855e4e5e1bc73604c63d51f0dc4bf1" translate="yes" xml:space="preserve">
          <source>Durran D. R. (1999) Numerical Methods for Wave Equations in Geophysical Fluid Dynamics. New York: Springer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26aa5b06114619ee705d4e196e09408f75d82651" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 106-108.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7020945b62676f3792048d52264e61eaf1f2f06e" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 109-110.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd1ccd7ec68cbb9d222ef47028613ad14f66cf8" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 177-178.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9282259a9bffd46a322a6acfc9997c91e019e7d4" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension. The added dimension is the position of the &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76bc743577aee15d005972242975d93c3b7f843" translate="yes" xml:space="preserve">
          <source>Each array in the tuple has the same shape as the &lt;code&gt;indices&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386efca9f91ba00773f6c9bc7ed1232d730522e6" translate="yes" xml:space="preserve">
          <source>Each array must have the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286a71006dd39afde343b3c45a4fd98ff7cec30e" translate="yes" xml:space="preserve">
          <source>Each boolean array corresponds to a function in &lt;code&gt;funclist&lt;/code&gt;. Wherever &lt;code&gt;condlist[i]&lt;/code&gt; is True, &lt;code&gt;funclist[i](x)&lt;/code&gt; is used as the output value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef78733a1d1f7432ec1ab2af99217db7ce78c93" translate="yes" xml:space="preserve">
          <source>Each boolean array in &lt;code&gt;condlist&lt;/code&gt; selects a piece of &lt;code&gt;x&lt;/code&gt;, and should therefore be of the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe6ffb6ecffd6c39387e8f0ab0c3a109b7064bf" translate="yes" xml:space="preserve">
          <source>Each built-in data-type has a character code (the updated Numeric typecodes), that uniquely identifies it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69a75e46ca3ac2d199e74b13f3b32f8dd1d6b80" translate="yes" xml:space="preserve">
          <source>Each differentiation is multiplied by &lt;code&gt;scl&lt;/code&gt;. The end result is multiplication by &lt;code&gt;scl**m&lt;/code&gt;. This is for use in a linear change of variable. (Default: 1)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d6286823e7a8996b335e27ee039bd71682bf33" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a7c87b9ea1dd98d592dea35e0511973a19c5ea" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple. These are the core dimensions, and they must be present in the arrays, or an error will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8fa7f34f98b652b735f9d41844bf81c524a5373" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;a&lt;/code&gt; represents a bit-field that should be unpacked into a binary-valued output array. The shape of the output array is either 1-D (if &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;) or the same shape as the input array with unpacking done along the axis specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50237f597aa5c58319566769ed4e784a20d0c8c4" translate="yes" xml:space="preserve">
          <source>Each element of the sum of the &amp;lsquo;ipmt&amp;rsquo; and &amp;lsquo;ppmt&amp;rsquo; arrays should equal &amp;lsquo;pmt&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6596e910451a16280ea499b967185410396fa721" translate="yes" xml:space="preserve">
          <source>Each function is evaluated over &lt;code&gt;x&lt;/code&gt; wherever its corresponding condition is True. It should take a 1d array as input and give an 1d array or a scalar value as output. If, instead of a callable, a scalar is provided then a constant function (&lt;code&gt;lambda x: scalar&lt;/code&gt;) is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8deda694e466984ce525e906c00ea4f5dea09d" translate="yes" xml:space="preserve">
          <source>Each generalized ufunc has information associated with it that states what the &amp;ldquo;core&amp;rdquo; dimensionality of the inputs is, as well as the corresponding dimensionality of the outputs (the element-wise ufuncs have zero core dimensions). The list of the core dimensions for all arguments is called the &amp;ldquo;signature&amp;rdquo; of a ufunc. For example, the ufunc numpy.add has signature &lt;code&gt;(),()-&amp;gt;()&lt;/code&gt; defining two scalar inputs and one scalar output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ff2ff5db4665bc2536253e2cbc256cc6ee369b" translate="yes" xml:space="preserve">
          <source>Each item is used as an &amp;ldquo;op_axes&amp;rdquo; argument to an nditer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83888ab60bad511e4b53bdc1db03bb5f1c808f79" translate="yes" xml:space="preserve">
          <source>Each line past the first &lt;code&gt;skip_header&lt;/code&gt; lines is split at the &lt;code&gt;delimiter&lt;/code&gt; character, and characters following the &lt;code&gt;comments&lt;/code&gt; character are discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3956c5acda082528edb0dd788f86e08b90ce29c7" translate="yes" xml:space="preserve">
          <source>Each of the arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;divmod()&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; or &lt;code&gt;pow()&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) and the comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;) is equivalent to the corresponding universal function (or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) in NumPy. For more information, see the section on &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;Universal Functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce900752c03b63d004b95034fc7fe45e45781bb2" translate="yes" xml:space="preserve">
          <source>Each of these 12 classes is collected into a &lt;code&gt;unittest.TestSuite&lt;/code&gt;, which is then executed. Errors and failures are summed together and returned as the exit argument. Any non-zero result indicates that at least one test did not pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67c4cfb6e2d44f4338462a5c73308f6ff60ab98" translate="yes" xml:space="preserve">
          <source>Each row in the text file must have the same number of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b09b89b09738ea85b440f6b9b0782f598ebe968" translate="yes" xml:space="preserve">
          <source>Each sequence should be of integer or boolean type. Boolean sequences will be interpreted as boolean masks for the corresponding dimension (equivalent to passing in &lt;code&gt;np.nonzero(boolean_sequence)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b117b16ba13396092e447a51f24074ff2e6bd854" translate="yes" xml:space="preserve">
          <source>Each test defined by the &lt;code&gt;VectorTestCase&lt;/code&gt; class extracts the python function it is trying to test by accessing the &lt;code&gt;Vector&lt;/code&gt; module&amp;rsquo;s dictionary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7730362892427e71964e48c12006a9cf86055b3" translate="yes" xml:space="preserve">
          <source>Each ufunc consists of an elementary function that performs the most basic operation on the smallest portion of array arguments (e.g. adding two numbers is the most basic operation in adding two arrays). The ufunc applies the elementary function multiple times on different parts of the arrays. The input/output of elementary functions can be vectors; e.g., the elementary function of inner1d takes two vectors as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1cf57d2ff93f75da1bd8ea2b2acd61c3fea8cd" translate="yes" xml:space="preserve">
          <source>Each universal function takes array inputs and produces array outputs by performing the core function element-wise on the inputs (where an element is generally a scalar, but can be a vector or higher-order sub-array for generalized ufuncs). Standard broadcasting rules are applied so that inputs not sharing exactly the same shapes can still be usefully operated on. Broadcasting can be understood by four rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778a8f870adb20070c9bbd4345579e90072a320d" translate="yes" xml:space="preserve">
          <source>Easier setup and teardown functions / methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d5c22f934ab8df1b20f8c3472b63bf839853fa" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16a3ec6ab9f466c4d89051f80bac7ab3d7a2dde" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;code&gt;shrink&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b4ace616414347d2dd3d2801314c174bc7ba08" translate="yes" xml:space="preserve">
          <source>Effectively, this implements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4d17c36c1ff28a27a4b2931f3e20dd1dbef5a2" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e03cfade90e6c295c76156a8e2c563a63efa318" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays. To get started using this object, see the &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036e376170c1d3906a5f0a04018619e235105dc6" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem (maximum number of candidate solutions to consider). The following special values are recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3820529f3b083c6a31ff8350ee28b11115b842" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem. See &lt;a href=&quot;numpy.shares_memory#numpy.shares_memory&quot;&gt;&lt;code&gt;shares_memory&lt;/code&gt;&lt;/a&gt; for details. Default for &lt;code&gt;may_share_memory&lt;/code&gt; is to do a bounds check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444baf679021343f134e3ab4afdb77852c13f5b7" translate="yes" xml:space="preserve">
          <source>Einstein summation convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f574da7dabc16cec8dc28f2e16dcdf93d39e214" translate="yes" xml:space="preserve">
          <source>Either &amp;lsquo;inv&amp;rsquo; or &amp;lsquo;zig&amp;rsquo;. &amp;lsquo;inv&amp;rsquo; uses the default inverse CDF method. &amp;lsquo;zig&amp;rsquo; uses the much faster Ziggurat method of Marsaglia and Tsang.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f248b6168fbf2f57439344bf599f0d52d7a807c7" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or a dictionary containing low-level casting functions for user- defined data-types. Each function is wrapped in a &lt;code&gt;PyCObject *&lt;/code&gt; and keyed by the data-type number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff36def358c4174701abf75ea4d4e0cdcf5bd477" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of &lt;a href=&quot;c-api.array#c.NPY_NSCALARKINDS&quot;&gt;&lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt;&lt;/a&gt; pointers. These pointers should each be either &lt;code&gt;NULL&lt;/code&gt; or a pointer to an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt;) indicating data-types that a scalar of this data-type of the specified kind can be cast to safely (this usually means without losing precision).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b68604ef80074abda088f5c021808f55b2ed04d" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; ) indicated data-types that this data-type can be cast to safely (this usually means without losing precision).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accffd1618e3de5c69c33d1510a23e42c114bdf3" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;None&lt;/code&gt; to indicate a C-style contiguous array or a Tuple of strides which provides the number of bytes needed to jump to the next array element in the corresponding dimension. Each entry must be an integer (a Python &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;). As with shape, the values may be larger than can be represented by a C &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo;; the calling code should handle this appropriately, either by raising an error, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; in C. The default is &lt;code&gt;None&lt;/code&gt; which implies a C-style contiguous memory buffer. In this model, the last dimension of the array varies the fastest. For example, the default strides tuple for an object whose array entries are 8 bytes long and whose shape is (10,20,30) would be (4800, 240, 8)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e35b148ce133a87759db1169ada9bc7afe8b136" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;PyUFunc_One&lt;/code&gt;, &lt;code&gt;PyUFunc_Zero&lt;/code&gt;, &lt;code&gt;PyUFunc_None&lt;/code&gt; or &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; to indicate the identity for this operation. It is only used for a reduce-like call on an empty array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987f54d54272ffd5f21f8146bd411a9086f8f96d" translate="yes" xml:space="preserve">
          <source>Either a basic-type description string as in &lt;em&gt;typestr&lt;/em&gt; or another list (for nested structured types)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36f94dd4a5bc304e7b8e5a337101261c2694c11" translate="yes" xml:space="preserve">
          <source>Either a data-type, a tuple of data-types, or a special signature string indicating the input and output types of a ufunc. This argument allows you to provide a specific signature for the 1-d loop to use in the underlying calculation. If the loop specified does not exist for the ufunc, then a TypeError is raised. Normally, a suitable loop is found automatically by comparing the input types with what is available and searching for a loop with data-types to which all inputs can be cast safely. This keyword argument lets you bypass that search and choose a particular loop. A list of available signatures is provided by the &lt;strong&gt;types&lt;/strong&gt; attribute of the ufunc object. For backwards compatibility this argument can also be provided as &lt;em&gt;sig&lt;/em&gt;, although the long form is preferred. Note that this should not be confused with the generalized ufunc &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; that is stored in the &lt;strong&gt;signature&lt;/strong&gt; attribute of the of the ufunc object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7015ddb90f8a42ecbacfed5d690fb153cc71ff7" translate="yes" xml:space="preserve">
          <source>Either the file name (string) or an open file (file-like object) where the data will be saved. If file is a string or a Path, the &lt;code&gt;.npz&lt;/code&gt; extension will be appended to the file name if it is not already there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2953df344283c54bedef1d8e252fb3c96e667a80" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th element will be in its final sorted position and all smaller elements will be moved before it and all larger elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all of them into their sorted position at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603f2f92b6e79eef48a044dac1baeab309560ae3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th value of the element will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all elements indexed by k-th of them into their sorted position at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1e5c082697760ec705616bbb818b3e3054f2a3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67afd821e881e618d2d3c592047caa6ab2545d17" translate="yes" xml:space="preserve">
          <source>Element-wise 2 to the power &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adaf9e130e6f948876c40cb7079ab5374d49e139" translate="yes" xml:space="preserve">
          <source>Element-wise &lt;code&gt;x*x&lt;/code&gt;, of the same shape and dtype as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808b6a2cc974757f97aaa854c54baffd849df5f9" translate="yes" xml:space="preserve">
          <source>Element-wise arc tangent of &lt;code&gt;x1/x2&lt;/code&gt; choosing the quadrant correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac96759d5e7cde7bc053be626eb0c73009447e8" translate="yes" xml:space="preserve">
          <source>Element-wise exponential minus one: &lt;code&gt;out = exp(x) - 1&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e24669e28a8f1555e04e187ba59f7b56eef5d74" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of array elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0f8227b430f00f150f25df31d4c6130cd8dee1" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignores NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0000ade51e0b31f8609d90f1fdd9bbd95746777" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignoring any NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0de4ef4fdf4c984be543486b8ef23d43631cea6" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagates NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdcc1733a93ea05c9ded4af3bbc823384a01061c" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagating any NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="117fbbb294a3d3f4ec6bf9953291f0979ba3eb6d" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of array elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10c8e11f8111bdb87b272aa363c7d5a87d2958e" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignores NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1d7d39298313f44ede26ddbe99082deaf8d999" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignoring any NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129e7a520fce7febf9e89723a4b3e31c307bd988" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagates NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ccb3abbc1e393d00365ccd1319992c54e9ed13" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagating any NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a664254a8e3d768c1b8ca8504a3064612680ed55" translate="yes" xml:space="preserve">
          <source>Element-wise quotient resulting from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a0aab7c92a2f3f84b40cb7246ed8c1bcebd9a8" translate="yes" xml:space="preserve">
          <source>Element-wise remainder from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a18c5c80ce790e4ab72162c437f0a9d09ae712" translate="yes" xml:space="preserve">
          <source>Elementary Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04982a80ae05d1b0cdf8cb6f954f5d90370c1f1a" translate="yes" xml:space="preserve">
          <source>Elements shapes must match along the appropriate axes (without broadcasting), but leading 1s will be prepended to the shape as necessary to make the dimensions match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec73af38a64af612d36b6b1e08ea284a14bd8798" translate="yes" xml:space="preserve">
          <source>Elements that roll beyond the last position are re-introduced at the first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec956445b767a135cb8c6d627b5a2dfeb02537d" translate="yes" xml:space="preserve">
          <source>Elements to compare for the maximum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba7c2272413ef1378137b3e69e8b4722f8659b1" translate="yes" xml:space="preserve">
          <source>Elements to compare for the minimum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0973f46abdf4cfdea56a1e0e2597c002a92fb2" translate="yes" xml:space="preserve">
          <source>Elements to include in the product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836bba81daa7bbfa24fcec9d876cd0ca01db1438" translate="yes" xml:space="preserve">
          <source>Elements to include in the sum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68b36609400536b206e5ed8f4915662a0a2020b" translate="yes" xml:space="preserve">
          <source>Elements to sum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680319fcdd621a03121d173370e025227fa7d8d6" translate="yes" xml:space="preserve">
          <source>Elementwise bit operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777a53a52816c5597e4f366c2ef31bc0f2a213da" translate="yes" xml:space="preserve">
          <source>Empty array of the given shape and type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b8b3469c24b495eeedeb9693c9bf36670e4dcd" translate="yes" xml:space="preserve">
          <source>Empty masked array modelled on an existing array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6985c4b0d668125594b4f0ca6436e1c86a0154e8" translate="yes" xml:space="preserve">
          <source>Empty masked array with all elements masked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680b8e573f5c82aced131f36a223b41bb3352d25" translate="yes" xml:space="preserve">
          <source>Empty masked array with the properties of an existing array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a122b7a065f1b0b6e65770d5576676e667e835a7" translate="yes" xml:space="preserve">
          <source>Enables support for iteration of sub-ranges of the full &lt;code&gt;iterindex&lt;/code&gt; range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;. Use the function &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; to specify a range for iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc79001ca7d4881c81aec2ea04317198e31e1bd" translate="yes" xml:space="preserve">
          <source>Enables the specified array flags. This function does no validation, and assumes that you know what you&amp;rsquo;re doing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2919970bd082897345d32d119a4800b54dae0c81" translate="yes" xml:space="preserve">
          <source>Encapsulate the functionality of functions and methods that take the axis= keyword and work properly with None as the axis argument. The input array is &lt;code&gt;obj&lt;/code&gt;, while &lt;code&gt;*axis&lt;/code&gt; is a converted integer (so that &amp;gt;=MAXDIMS is the None value), and &lt;code&gt;requirements&lt;/code&gt; gives the needed properties of &lt;code&gt;obj&lt;/code&gt;. The output is a converted version of the input so that requirements are met and if needed a flattening has occurred. On output negative values of &lt;code&gt;*axis&lt;/code&gt; are converted and the new value is checked to ensure consistency with the shape of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fcbf1219e531263b67edb6bcb90e0e603ad6031" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27e46c5a085977e5cb88681f8a881b52c0fec71" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensures you receive byte arrays as results if possible and passes &amp;lsquo;latin1&amp;rsquo; encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6776a87f17cb7165db7de968828852a089f8cd2b" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply when &lt;code&gt;fname&lt;/code&gt; is a file object. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensure that you receive byte arrays when possible and passes latin1 encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2939a9752e2c7114a267e7bcdaebdf8d9a69e0" translate="yes" xml:space="preserve">
          <source>Encoding used to encode the outputfile. Does not apply to output streams. If the encoding is something other than &amp;lsquo;bytes&amp;rsquo; or &amp;lsquo;latin1&amp;rsquo; you will not be able to load the file in NumPy versions &amp;lt; 1.14. Default is &amp;lsquo;latin1&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672959489089d143587fef9e4d4ad09fb66e2197" translate="yes" xml:space="preserve">
          <source>End of interval. The interval does not include this value, except in some cases where &lt;code&gt;step&lt;/code&gt; is not an integer and floating point round-off affects the length of &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b220f5e9cefe4e27d14fddf001bfa3a63353e7" translate="yes" xml:space="preserve">
          <source>Endianness of this data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a41a009718ba8b1b08f10745bce80452ba74f4" translate="yes" xml:space="preserve">
          <source>Enlarging an array: as above, but missing entries are filled with zeros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a314f110f22f052f3fa828713d2b2afb82f2d3" translate="yes" xml:space="preserve">
          <source>Ensures that the input or output matches the iteration dimensions exactly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a6fa7af7b1354d47707152a8ad806c277ca980" translate="yes" xml:space="preserve">
          <source>Entropy bits in 32-bit unsigned integers. A scalar is returned if size is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0366a10ef9d6d3ef8c64dd51eeccb78bad1656a" translate="yes" xml:space="preserve">
          <source>Enumerated Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ac742e5d17c07aad844f80aaa89a24ed90f881" translate="yes" xml:space="preserve">
          <source>Equal to &lt;code&gt;np.prod(a.shape)&lt;/code&gt;, i.e., the product of the array&amp;rsquo;s dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75f0322b44b0e91520f5021f79c37a01c9e121d" translate="yes" xml:space="preserve">
          <source>Equivalent array function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87b0e23e278c7d5e4e266e84f6badc171df142a" translate="yes" xml:space="preserve">
          <source>Equivalent array method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f85d863747d1d952d2380d6f9b0e6bc4a93c6e6" translate="yes" xml:space="preserve">
          <source>Equivalent function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec48c460ff53cdf24f427482ba077c38b868cbe6" translate="yes" xml:space="preserve">
          <source>Equivalent function for ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b16a4308d5d95c02caa6becddf32961f2329b1" translate="yes" xml:space="preserve">
          <source>Equivalent function in the NumPy module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fda7b941f8c3619f7cfea52fae50b8fafb8283f" translate="yes" xml:space="preserve">
          <source>Equivalent function in the masked array module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3946f30225c2c4e0913895a299311328885ca06" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top level NumPy module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79348928e8ad109f51e4deea501091d1124a6a4" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top-level NumPy module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f012d5b24482ab2f7fe8b36bc8562d2e06cf863d" translate="yes" xml:space="preserve">
          <source>Equivalent function in top-level NumPy module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb89f40e9f2471ebbc500654e8790a75f09e8680" translate="yes" xml:space="preserve">
          <source>Equivalent function with additional &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; arguments for setting the mean and standard deviation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fec03561045f830610698c03c4e7cda301e9182" translate="yes" xml:space="preserve">
          <source>Equivalent functionality of &lt;a href=&quot;numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73110076e1002b6b052fe8f385604bf0bd306ff9" translate="yes" xml:space="preserve">
          <source>Equivalent method in ndarray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b818de9537a41af44762a6ff8c93846b78172ce" translate="yes" xml:space="preserve">
          <source>Equivalent method on ndarray object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323a53e2d1eaaaf783c2a6e70d300696fee31861" translate="yes" xml:space="preserve">
          <source>Equivalent method when working on 1-D arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198298ece560304dd9cecebb0a6c0ea2bb7a8bae" translate="yes" xml:space="preserve">
          <source>Equivalent method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b37d7b2f299efd2d123535be0f6369732ae724" translate="yes" xml:space="preserve">
          <source>Equivalent ndarray method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c920736bc05ff403de2ed423ca7f0b9c0f3adffb" translate="yes" xml:space="preserve">
          <source>Equivalent of Python &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505d790701850092dede13a1225a7d0508099ca4" translate="yes" xml:space="preserve">
          <source>Equivalent of the MATLAB &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdc670d68d8d05adfb0ac70f3d0ea4670424187" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#c.PyDataType_FLAGCHK&quot;&gt;&lt;code&gt;PyDataType_FLAGCHK&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;dtype&lt;/em&gt;, &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ecf3d3dd70eafb08906a1ad49ac399520f10f8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;code&gt;self&lt;/code&gt; defined by &lt;code&gt;axis&lt;/code&gt; in which all the elements are True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd8289812e23cf1b7df07369198edcd67ccd665" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;ndarray.any&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;em&gt;self&lt;/em&gt; defined by &lt;em&gt;axis&lt;/em&gt; in which any of the elements are True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea109271e7fe639649aeaaf2a0b5dd56ecc23fcf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5a451b453bc4aefcc71e37cd8b0e84168886e8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7a1a44ff60373e9f731b7ce7e339177577c561" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt;&lt;code&gt;ndarray.argpartition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a partitioned version of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75ff39235401fe4390dbb04fd226bfccafd46e5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt;&lt;code&gt;ndarray.argsort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a sorted version of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6daadea926a9bfb0a800c60a35b85b50c40374a1" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt;&lt;code&gt;ndarray.byteswap&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;inplace&lt;/em&gt;). Return an array whose data area is byteswapped. If &lt;em&gt;inplace&lt;/em&gt; is non-zero, then do the byteswap inplace and return a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab0b0009765a5d262f32c0eec580607299fc96a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt;&lt;code&gt;ndarray.choose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;). Create a new array by selecting elements from the sequence of arrays in &lt;em&gt;op&lt;/em&gt; based on the integer values in &lt;em&gt;self&lt;/em&gt;. The arrays must all be broadcastable to the same shape and the entries in &lt;em&gt;self&lt;/em&gt; should be between 0 and len(&lt;em&gt;op&lt;/em&gt;). The output is placed in &lt;em&gt;ret&lt;/em&gt; unless it is &lt;code&gt;NULL&lt;/code&gt; in which case a new output is created. The &lt;em&gt;clipmode&lt;/em&gt; argument determines behavior for when entries in &lt;em&gt;self&lt;/em&gt; are not between 0 and len(&lt;em&gt;op&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07498cd87fe2ef12a2b26de127164c39b4bd9e44" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt;&lt;code&gt;ndarray.clip&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;min&lt;/em&gt;, &lt;em&gt;max&lt;/em&gt;). Clip an array, &lt;em&gt;self&lt;/em&gt;, so that values larger than &lt;em&gt;max&lt;/em&gt; are fixed to &lt;em&gt;max&lt;/em&gt; and values less than &lt;em&gt;min&lt;/em&gt; are fixed to &lt;em&gt;min&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c163c568fd35392b35f7cb27b6a29f0e9cbd90da" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt;&lt;code&gt;ndarray.compress&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;condition&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt; ). Return the elements along &lt;em&gt;axis&lt;/em&gt; corresponding to elements of &lt;em&gt;condition&lt;/em&gt; that are true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9acb1c9e137920376909d2dadce0362beab80c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt;&lt;code&gt;ndarray.conjugate&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return the complex conjugate of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; is not of complex data type, then return &lt;em&gt;self&lt;/em&gt; with a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf40d04106c5d52e1884e99b3a37b71d8a81e331" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt;&lt;code&gt;ndarray.copy&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;fortran&lt;/em&gt;). Make a copy of the &lt;em&gt;old&lt;/em&gt; array. The returned array is always aligned and writeable with data interpreted the same as the old array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, then a C-style contiguous array is returned. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;, then a Fortran-style contiguous array is returned. If &lt;em&gt;order is&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the array returned is Fortran-style contiguous only if the old one is; otherwise, it is C-style contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98feecd02ab5026f0970a3c09806ab4167d96259" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt;&lt;code&gt;ndarray.cumprod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d cumulative products of elements in &lt;code&gt;self&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;. Perform the product after converting data to data type &lt;code&gt;rtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f34a6ad4ecf38e07a2778b6f8366d8507a10ea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt;&lt;code&gt;ndarray.cumsum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return cumulative 1-d sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d031ba857ad4460b29f51ce74504941e945e52" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt;&lt;code&gt;ndarray.diagonal&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt; ). Return the &lt;em&gt;offset&lt;/em&gt; diagonals of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6400ea427e27ba969159bbf1cd1e50c3dd25455" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;ndarray.flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return a 1-d copy of the array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; the elements are scanned out in Fortran order (first-dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, the elements of &lt;code&gt;self&lt;/code&gt; are scanned in C-order (last dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the result of &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;) is used to determine which order to flatten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb7bf8250a91a19555dbcdb02102524e6c94de7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt;&lt;code&gt;ndarray.getfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;). This function &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;steals a reference&lt;/a&gt; to &lt;code&gt;PyArray_Descr&lt;/code&gt; and returns a new array of the given &lt;code&gt;dtype&lt;/code&gt; using the data in the current array at a specified &lt;code&gt;offset&lt;/code&gt; in bytes. The &lt;code&gt;offset&lt;/code&gt; plus the itemsize of the new array type must be less than &lt;code&gt;self
-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; or an error is raised. The same shape and strides as the original array are used. Therefore, this function has the effect of returning a field from a structured array. But, it can also be used to select specific bytes or groups of bytes from any array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1e5da9cdc7a9b4c6725235e40182f3951d083a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Returns the largest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd01120eccb02f99889760c9ef36e279a9f9ea8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt;&lt;code&gt;ndarray.mean&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Returns the mean of the elements along the given &lt;em&gt;axis&lt;/em&gt;, using the enumerated type &lt;em&gt;rtype&lt;/em&gt; as the data type to sum in. Default sum behavior is obtained using &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e276f562081b61880c79febde9752c6b4583d12" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the smallest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e792db3a62a29831ce03976f5ea2350fba5a323b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;ndarray.nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Returns a tuple of index arrays that select elements of &lt;em&gt;self&lt;/em&gt; that are nonzero. If (nd= &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; ))==1, then a single index array is returned. The index arrays have data type &lt;a href=&quot;c-api.dtype#c.NPY_INTP&quot;&gt;&lt;code&gt;NPY_INTP&lt;/code&gt;&lt;/a&gt;. If a tuple is returned (nd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70d121c7d953594f404dacb0d342fd3ab8b30ba" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt;&lt;code&gt;ndarray.partition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Partitions the array so that the values of the element indexed by &lt;em&gt;ktharray&lt;/em&gt; are in the positions they would be if the array is fully sorted and places all elements smaller than the kth before and all elements equal or greater after the kth element. The ordering of all elements within the partitions is undefined. If &lt;em&gt;self&lt;/em&gt;-&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type. Returns zero on success and -1 on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1404ab20af4a0d50c24ff1ca93cc3a3448c7e38e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt;&lt;code&gt;ndarray.prod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d products of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the product after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1100d008c0276fd76e61e9204938c06e2c190cea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt;&lt;code&gt;ndarray.ptp&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the difference between the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt; and the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c16f538cf9a4222086ade1f8bc40148ea4157cd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt;&lt;code&gt;ndarray.repeat&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Copy the elements of &lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt; times along the given &lt;em&gt;axis&lt;/em&gt;. Either &lt;em&gt;op&lt;/em&gt; is a scalar integer or a sequence of length &lt;em&gt;self&lt;/em&gt; -&amp;gt;dimensions[ &lt;em&gt;axis&lt;/em&gt; ] indicating how many times to repeat each item along the axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f8dce1a3fdb6440169e6117acb2747787948e3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt;&lt;code&gt;ndarray.reshape&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;shape&lt;/em&gt;) where &lt;em&gt;shape&lt;/em&gt; is a sequence. Converts &lt;em&gt;shape&lt;/em&gt; to a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Dims&quot;&gt;&lt;code&gt;PyArray_Dims&lt;/code&gt;&lt;/a&gt; structure and calls &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt;&lt;code&gt;PyArray_Newshape&lt;/code&gt;&lt;/a&gt; internally. For back-ward compatibility &amp;ndash; Not recommended</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c66cfa86b4fd8c96342e13259600ca57c73356a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;newshape&lt;/em&gt;, refcheck &lt;code&gt;=&lt;/code&gt;&lt;em&gt;refcheck&lt;/em&gt;, order= fortran ). This function only works on single-segment arrays. It changes the shape of &lt;em&gt;self&lt;/em&gt; inplace and will reallocate the memory for &lt;em&gt;self&lt;/em&gt; if &lt;em&gt;newshape&lt;/em&gt; has a different total number of elements then the old shape. If reallocation is necessary, then &lt;em&gt;self&lt;/em&gt; must own its data, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt;, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt;, and (unless refcheck is 0) not be referenced by any other array. The fortran argument can be &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;. It currently has no effect. Eventually it could be used to determine how the resize operation should view the data when constructing a differently-dimensioned array. Returns None on success and NULL on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35d0fb0b3b672f40f8ed22b6a36b98bc32ccd79" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt;&lt;code&gt;ndarray.round&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;decimals&lt;/em&gt;, &lt;em&gt;out&lt;/em&gt;). Returns the array with elements rounded to the nearest decimal place. The decimal place is defined as the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c91912c2f0496c5da34bf18831db8c3ec272aa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt;&lt;code&gt;ndarray.searchsorted&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;values&lt;/em&gt;, &lt;em&gt;side&lt;/em&gt;, &lt;em&gt;perm&lt;/em&gt;). Assuming &lt;em&gt;self&lt;/em&gt; is a 1-d array in ascending order, then the output is an array of indices the same shape as &lt;em&gt;values&lt;/em&gt; such that, if the elements in &lt;em&gt;values&lt;/em&gt; were inserted before the indices, the order of &lt;em&gt;self&lt;/em&gt; would be preserved. No checking is done on whether or not self is in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129c27494826551cd6d91c742839f2dd3b7a2b39" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt;&lt;code&gt;ndarray.setfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;val&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt; ). Set the field starting at &lt;em&gt;offset&lt;/em&gt; in bytes and of the given &lt;em&gt;dtype&lt;/em&gt; to &lt;em&gt;val&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; plus &lt;em&gt;dtype&lt;/em&gt; -&amp;gt;elsize must be less than &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr-&amp;gt;elsize or an error is raised. Otherwise, the &lt;em&gt;val&lt;/em&gt; argument is converted to an array and copied into the field pointed to. If necessary, the elements of &lt;em&gt;val&lt;/em&gt; are repeated to fill the destination array, But, the number of elements in the destination must be an integer multiple of the number of elements in &lt;em&gt;val&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329e170888d304760a845c23e2123d83a997ded2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt;&lt;code&gt;ndarray.sort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array with the items of &lt;em&gt;self&lt;/em&gt; sorted along &lt;em&gt;axis&lt;/em&gt;. The array is sorted using the algorithm denoted by &lt;em&gt;kind&lt;/em&gt; , which is an integer/enum pointing to the type of sorting algorithms used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f23f95a5677bb30c45f3519a8a38c4eb9ab14d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt;&lt;code&gt;ndarray.squeeze&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a new view of &lt;em&gt;self&lt;/em&gt; with all of the dimensions of length 1 removed from the shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ea257f6db1c3b5b426fb4027029e9f1b7413a5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the standard deviation using data along &lt;em&gt;axis&lt;/em&gt; converted to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7387b455871f5d5fed3305db644e74b9628876" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d vector sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9ac6ba7775647d994932881b5b117c78bc1d61" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt;&lt;code&gt;ndarray.swapaxes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;a1&lt;/em&gt;, &lt;em&gt;a2&lt;/em&gt;). The returned array is a new view of the data in &lt;em&gt;self&lt;/em&gt; with the given axes, &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt;, swapped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526d5a8267bf48a76f6e4bef39106e81c90185a6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;ndarray.take&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;) except &lt;em&gt;axis&lt;/em&gt; =None in Python is obtained by setting &lt;em&gt;axis&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; in C. Extract the items from self indicated by the integer-valued &lt;em&gt;indices&lt;/em&gt; along the given &lt;em&gt;axis.&lt;/em&gt; The clipmode argument can be &lt;a href=&quot;#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt; to indicate what to do with out-of-bound indices. The &lt;em&gt;ret&lt;/em&gt; argument can specify an output array rather than having one created internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fbb6db45f5065f7d5f46448fca11ee7f459d488" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return the bytes of this array in a Python string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1487cf1aae9421a58178865b5cc518907b872e6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt;&lt;code&gt;ndarray.tolist&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a nested Python list from &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f6eaf18a532cc83a7879c0fc5e0cdb9219ac58" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt;&lt;code&gt;ndarray.trace&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the sum (using &lt;em&gt;rtype&lt;/em&gt; as the data type of summation) over the &lt;em&gt;offset&lt;/em&gt; diagonal elements of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt; variables. A positive offset chooses diagonals above the main diagonal. A negative offset selects diagonals below the main diagonal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903dc5f64afb6611725d0b8ef7bd16c3db35ef02" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;ndarray.transpose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;permute&lt;/em&gt;). Permute the axes of the ndarray object &lt;em&gt;self&lt;/em&gt; according to the data structure &lt;em&gt;permute&lt;/em&gt; and return the result. If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the resulting array has its axes reversed. For example if &lt;em&gt;self&lt;/em&gt; has shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e84dfaf00361747bc32ce6d08fe80d8b155279f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;ndarray.view&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;). Return a new view of the array &lt;em&gt;self&lt;/em&gt; as possibly a different data-type, &lt;em&gt;dtype&lt;/em&gt;, and different array subclass &lt;em&gt;ptype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c80f2487a92354ad196d90ca737086d6a28cb501" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657a5eba5419e2937f0d7b0877025c3f2a8bf379" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821886e91092ad64682392ad985ffcb281eaf4b3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) + np.exp(-x))&lt;/code&gt; and &lt;code&gt;np.cos(1j*x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cedbe2e2d0fc9bc98c2a4058eb21de10f0ba961" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) - np.exp(-x))&lt;/code&gt; or &lt;code&gt;-1j * np.sin(1j*x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cabfa0a0b1ab314bf5ad313943ea0a61c9f913" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;a.copy(order='K')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8b0df6f8f30decfdb8712f593677bd0361c0ef" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;divmod(x, 1)&lt;/code&gt; for positive &lt;code&gt;x&lt;/code&gt; with the return values switched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f28125a3d825d23c8591cf7b44d136f5206aec6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;m[::-1,...]&lt;/code&gt;. Does not require the array to be two-dimensional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="158b7bdd2f113f05d23975a3a9ae7c4cbbee72c4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(self)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b757950b99b3fb5a49cac119260ff6b59afd089" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(x).ravel()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b942f822242874c950f31737a64908f9f10037" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sin(x)/np.cos(x)&lt;/code&gt; element-wise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03e98ed258ef214f7093f680237951ada6cdb9f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sinh(x)/np.cosh(x)&lt;/code&gt; or &lt;code&gt;-1j * np.tan(1j*x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b5ff4ad03763736f9b2a4f6770ab65b1c73219" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.transpose(self)&lt;/code&gt; if &lt;code&gt;self&lt;/code&gt; is real-valued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b818defe3ad1876ebfb087b965f01d49fa2ec9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sqrt(x1**2 + x2**2)&lt;/code&gt;, element-wise. If &lt;code&gt;x1&lt;/code&gt; or &lt;code&gt;x2&lt;/code&gt; is scalar_like (i.e., unambiguously cast-able to a scalar type), it is broadcast for use with each element of the other argument. (See Examples)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00df9c133fe8747499700e75effeb0cd5d136ccc" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x.copy()&lt;/code&gt;, but only defined for types that support arithmetic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23adb20441299c90dbd1e383cfab76bf7d2274b8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1 - x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c304ff74936613f3d12e0fc5cde4c506dd3f3ab" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; * &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98520850afe8056507d9d642ea9323b3ed72e130" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; + &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202bf1615636b8e0a84392691bc084a70b43390b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.put(&lt;em&gt;values&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt; ). Put &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;self&lt;/em&gt; at the corresponding (flattened) &lt;em&gt;indices&lt;/em&gt;. If &lt;em&gt;values&lt;/em&gt; is too small it will be repeated as necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d607762120cf690bb00c590b16fa127fb75062" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.ravel(&lt;em&gt;order&lt;/em&gt;). Same basic functionality as &lt;a href=&quot;#c.PyArray_Flatten&quot;&gt;&lt;code&gt;PyArray_Flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;) except if &lt;em&gt;order&lt;/em&gt; is 0 and &lt;em&gt;self&lt;/em&gt; is C-style contiguous, the shape is altered but no copy is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9032a6cc40438a50e150a4a41ff47d4fe89a4820" translate="yes" xml:space="preserve">
          <source>Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1dee2d3e2220598a3bbd05e1af8c95afb8286e" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c543b869fe6bab79a3a934117c7c6a1eff863d6f" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731025cc785b584c28e327dc6f1d60cad5cb1eb2" translate="yes" xml:space="preserve">
          <source>Equivalent to but faster than &lt;code&gt;np.maximum(a_min, np.minimum(a, a_max))&lt;/code&gt;. No check is performed to ensure &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e127cc159cef630175cb2a2528435fea3e7fcdb3" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;$ nosetests &amp;lt;argv&amp;gt; &amp;lt;file_to_run&amp;gt;&lt;/code&gt; from the command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b847d0d31d2133c0201a061723b9aa92d8890f7" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_INT or NPY_LONGLONG, depending on the platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f38ed4c0f6096936fc4b84fb6a21d19adcc1cb" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_UINT or NPY_ULONGLONG, depending on the platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d656dbe889cfc08e9f09fa23957b7de58cae8caa" translate="yes" xml:space="preserve">
          <source>Equivalent to m[:,::-1]. Requires the array to be at least 2-D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a910d755d7e89acbf27b19fb05f069771ab0e7b" translate="yes" xml:space="preserve">
          <source>Equivalent to the Python &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c299359dd358c2f6f22a22ce8b45b901e994e8" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;&lt;code&gt;mask&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eed85d2c6463174f53200b994de55fedca2fe50" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;code&gt;MaskedArray&lt;/code&gt;&lt;code&gt;data&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59ba61683ec6d73dab0ba426c13a6a7d9ed31cf" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, the last two lines would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b59734e1b8f67d36df303549c4673ff4f6c8d66" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, this can be expressed as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b75128748a47d2bb367541f76250db5dd9b6a0" translate="yes" xml:space="preserve">
          <source>Equivalently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f577c8bef8739558c43df8e8796bc8e5a825a61" translate="yes" xml:space="preserve">
          <source>Error objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4884820cd63fe6870fd18f5bb40f96cacf7c1253" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e944c31c80a964e18589df952c8e941c618fb2" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6896dc5d66baa055255d6a61e0f3010c1fcb944f" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is supplied when the first argument is a scalar, or if the first and second arguments have different shapes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5c90765bd01e407f47b56e1714c9f9bd1ace4b" translate="yes" xml:space="preserve">
          <source>Estimate a covariance matrix, given data and weights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff0c8c72ff670edbc5bdbae93aa2dbd2e54c4c0" translate="yes" xml:space="preserve">
          <source>Estimate the covariance matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e86acb34f53f4c550f3dcf28b42823f0f59d900" translate="yes" xml:space="preserve">
          <source>Estimator based on leave-one-out cross-validation estimate of the integrated squared error. Can be regarded as a generalization of Scott&amp;rsquo;s rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35592e888d12a9934594d9f1f111830a7b9f7f37" translate="yes" xml:space="preserve">
          <source>Estimator does not take variability into account, only data size. Commonly overestimates number of bins required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da87f1093e8c246b1f6d85fea3650000b6da3790" translate="yes" xml:space="preserve">
          <source>Euler&amp;rsquo;s constant, base of natural logarithms, Napier&amp;rsquo;s constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91dd3dbbfae685abb68bc410da02d957a011629" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series at points (x, y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05e0d192839700194b0291808ce8475fe0d0cc1" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7249c2fe23f2e17738db2110e9c2474dc3a27187" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series at points (x, y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12ed956c99b6390def2dd7ee918ef9474cc02f06" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series on the Cartesian product of x and y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cedce799e74482d1942c64f4cd11a5b3fd98c128" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series at points (x, y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cc948294af1d7f259543794e3f125d854efce7" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series on the Cartesian product of x and y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338d5b747397dce60dd29055f57344efa1d37666" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series at points (x, y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a829f126487a9ec9a923ab666b31db182581736" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series on the Cartesian product of x and y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb447e6da0b73bad544e19cbcbc6052261416eb9" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series at points (x, y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7373a9e22eb3236ef35b254cc0cb7ed7d29c6948" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series on the Cartesian product of x and y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a527503bfcf8c4cb30f6f6943d6775ba7732cdef" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial at points (x, y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03726da2d6f02abab8a254ba40a2a300ecaef683" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial on the Cartesian product of x and y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9029d2c825f46990756a36847b1a1b6ef93e7f31" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series at points (x, y, z).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0bda3c65d8c3458e685987ef115c2f03e1ce48" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae23b9ad402238d53a7767ef4d1d0feecad8d46a" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series at points (x, y, z).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa86ea2fa2a78cb282ebd3e58571d4035e81572" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e36a6aa699aa19c71e1fd7089481c08a161992" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645e8b8ce98d2275a7fb6f40acce5d53b7f2ad81" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite_e series at points (x, y, z).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea580f96650cb24e9fc6eb589c30aba361084e3d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series at points (x, y, z).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345ed8afbed95aea3201f6d8df2e9d955fe4ee9d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1af478b3c58299201cb5fd893a359ec10739ca" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series at points (x, y, z).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888774bb82f3f8de5edab168d25dbd0a2eb3d033" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8846df08e194f124fe8cded1c782376715e8f39" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial at points (x, y, z).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f78fc3c5ae1454f9df0431d3f3fda38023ac26" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial on the Cartesian product of x, y and z.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b4e7acfc43ebffbd9c6285f10ac1b60b175795c" translate="yes" xml:space="preserve">
          <source>Evaluate a Chebyshev series at points x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4ce01843c1515b967b600cb8fa4018d3436eaa" translate="yes" xml:space="preserve">
          <source>Evaluate a Laguerre series at points x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161f6a7aae0d5d7f196e5ee0e04ba73d7963b76b" translate="yes" xml:space="preserve">
          <source>Evaluate a Legendre series at points x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc49d22e70eea61f6bdc96018100e105aba00e0" translate="yes" xml:space="preserve">
          <source>Evaluate a piecewise-defined function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a283e785c7b9ab6cbfe6dbfe59b713502d0afb" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at points x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac86c84a106ffc30d8eceed0ff68761b61ebad9a" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at specific values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283714fe4f49f84ab071c16c98a04aac5c0eb13d" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial specified by its roots at points x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ae76cb25d3ddcb8fd7f5add4137cfe2c33287a6" translate="yes" xml:space="preserve">
          <source>Evaluate an Hermite series at points x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1ba49b7053d6908dd1d4b7a38524a5c4ffc2df" translate="yes" xml:space="preserve">
          <source>Evaluate an HermiteE series at points x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a389fe7d0ca7745a323c209ce5b023a9e30716fa" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201867eba810e127d20356b4920cc833601a5f27" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the iterator has not looped through all of the elements, otherwise it evaluates FALSE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61e7944eeb541b39ec48ef4572671aa9245dfe1" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the multi-iterator has not looped through all of the elements (of the broadcasted result), otherwise it evaluates FALSE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e5fc7652637561dc1ca3671ce7888c08020803" translate="yes" xml:space="preserve">
          <source>Evaluates a Chebyshev series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5b426162065bbed8197ac088255c41cba4b070" translate="yes" xml:space="preserve">
          <source>Evaluates a Hermite series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7f15c01da2df8b851fc9f6e1e067fbbad7da62" translate="yes" xml:space="preserve">
          <source>Evaluates a Laguerre series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24200a16cfb4d36b211f0c64c8db3868f1aa7d7b" translate="yes" xml:space="preserve">
          <source>Evaluates a Legendre series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ee46dc575694a88add8fcac6da5ac9ea0ec2c1" translate="yes" xml:space="preserve">
          <source>Evaluates a polynomial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6780dad55d1f852632365f7570aa643328d5b06" translate="yes" xml:space="preserve">
          <source>Evaluates as True if arrays &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt; have the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b73bad8268092556c3d59c6262a1db866e29f2" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is FORTRAN ordered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74face1b8e76f520379a33453af827275b42370d" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is a contiguous array. Equivalent to &lt;code&gt;(PyArray_ISCONTIGUOUS(a))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a92de714017736a8a012563cdae53ed5c18d733" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt; and can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b857f72fdd592a4e93e214be9f6a2a22f1daa5" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;em&gt;obj&lt;/em&gt; is a data-type object ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d60164442fc0f55a5557baa1dde2ec4ee3a192" translate="yes" xml:space="preserve">
          <source>Evaluates as true if the data buffer of &lt;code&gt;a&lt;/code&gt; uses native byte order. Equivalent to &lt;code&gt;(PyArray_ISNOTSWAPPED(a))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a80c85f7d09b073fbd515eb093798e576dcd94" translate="yes" xml:space="preserve">
          <source>Evaluates the Einstein summation convention on the operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f56994a692d463245ca900188d259358a1a1e3" translate="yes" xml:space="preserve">
          <source>Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fdb9cdb108616be69434eab1761cc78b88d33b" translate="yes" xml:space="preserve">
          <source>Evaluates to a pointer of type &lt;code&gt;void*&lt;/code&gt; that points to the data buffer of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b165cdcba7dabc88d6d0700bab2cea35959b8e6" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the lengths of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d18aba4418a76811df39bd817fcca0ecc3daf26" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the stridess of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;. A stride is the distance in bytes between an element and its immediate neighbor along the same axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0a95426dfe5b7eb47ffd5ae2f4fb51edb35193" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th dimension size of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4d289826f9e7f76dff23ce9b5a0d1ae92ad3cc" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th stride of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b35e339f75424281676b07ad9e28b079acb58f" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer data type code of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ab5981a7770a6202629fec1405f5cf8e6b68cf" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer number of dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be0f4e7a59afdff5acbdbf74f20f94ceb3fdc16" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is C-style contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd3cb113f37e222d005c24c43bbeb4bb385e088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;em&gt;not&lt;/em&gt; C-style contiguous. &lt;a href=&quot;#c.PyArray_IS_F_CONTIGUOUS&quot;&gt;&lt;code&gt;PyArray_IS_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is the correct way to test for Fortran-style contiguity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299ed12a95038cc7c47da499ceb2b1bb9bee7088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6d7ddd3ec484ead393ec310ff7dd53898345cc" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object whose type is a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda799e9981a95fbdf277bb7b4cac9dbe1897388" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object with type &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eeb9c0e570ee6c3d7212996fe6c19be5c590a98" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;), an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt;) or an instance of a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782aad878c58725282c24466a66a6d37025e0309" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a builtin Python scalar object (int, float, complex, str, unicode, long, bool).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b432815e26220931657feceb0900b1d3b25457" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an array iterator (or instance of a subclass of the array iterator type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e9df6c71cba94b804e10a331ae768c03dc3136" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of (a subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and has 0 dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5906e8dd00d0a1adb4ea6aa8b5091429c7f25bb2" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of &lt;code&gt;Py{cls}ArrType_Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb6fa662c78b1650cad28ec8017fe594278de63" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of a builtin numeric type (int, float, complex, long, bool)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab21393a2ba887799bdff9d28c50be01d0b70f5b" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;) or an array scalar (an instance of a sub- type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7b1413b57bbc99790ccf42c73ff86cedf1427a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ), or an instance of (a sub-class of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82908b45216f6f64aa572e8d9614febf36cdc646" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; can be written to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6798bac58d14b80f66da409bb3101b7acf52c78" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; consists of a single (C-style or Fortran-style) contiguous segment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d051a4856042792e3562a8cf85f0b04c4a4af1" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, aligned, and in machine byte-order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e202a99f33c9bfd2e1c5ac0fa0b8a81399b57105" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="effc549b6cbff87555006675e1c79c18e43a5365" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df904ca22ec2803d50d17cdbf121eedc6d72400" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous, aligned, and in machine byte-order &lt;strong&gt;.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1b64683aef87f7f1b4257764cf4227296d827e" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and in machine byte-order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f20e7e1e5772639b1f7c4eb4bff4d2800f8c2a" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and writeable and in machine byte-order according to its descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e474d3b13b1be737b699dd99e94b826acd4340ff" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is properly aligned on the machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa74bf1ebb6946b1363906270140aeda279cf9f" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is &lt;strong&gt;not&lt;/strong&gt; in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3267c071decd2c90623cf8528c8e4938c54505e6" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74157d4f0e365e7c26ee7ae56617ac39f0fc6cb5" translate="yes" xml:space="preserve">
          <source>Evaluation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfed403a77ac8bf381d674a3abfc57ba60883a8b" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1298a53951ccd9aa53bf4ad3ab74e5154ee53b89" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true. The correct way to access the &lt;code&gt;itemsize&lt;/code&gt; of an array from the C API is &lt;code&gt;PyArray_ITEMSIZE(arr)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17cc6a8778f1a9a25e4a2f86caa32ef74f1e599" translate="yes" xml:space="preserve">
          <source>Even when the input array is two-dimensional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a0931fb2d7f42f3ac87c5b18547abf5d77fe06" translate="yes" xml:space="preserve">
          <source>Evenly round to the given number of decimals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19e0ffd5cc3d9a3df8ad933c77e6bea9dd169fb" translate="yes" xml:space="preserve">
          <source>Evenly spaced numbers with careful handling of endpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b950907a8c83b7ddb21092298e5404983c4a665" translate="yes" xml:space="preserve">
          <source>Eventually, expect to &lt;code&gt;__array_function__&lt;/code&gt; to always be enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581f2179fc03c06bcc3dcff4b3f8f2a107464b3a" translate="yes" xml:space="preserve">
          <source>Every Python module, extension module, or subpackage in the SciPy package directory should have a corresponding &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; file. Pytest examines these files for test methods (named test*) and test classes (named Test*).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae734cbfb45b3c7fcea4a1b93bd51caeedc12aa" translate="yes" xml:space="preserve">
          <source>Every ufunc calculation involves some overhead related to setting up the calculation. The practical significance of this overhead is that even though the actual calculation of the ufunc is very fast, you will be able to write array and type-specific code that will work faster for small arrays than the ufunc. In particular, using ufuncs to perform many calculations on 0-D arrays will be slower than other Python-based solutions (the silently-imported scalarmath module exists precisely to give array scalars the look-and-feel of ufunc based calculations with significantly reduced overhead).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30643b2e1a03cdc521bd995bce3101935a638007" translate="yes" xml:space="preserve">
          <source>Example 1: Matrix creation from a string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3d11c2b2ea882cbd46aab60dee035848945f1a" translate="yes" xml:space="preserve">
          <source>Example 2: Matrix creation from nested sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a618a4143ae0244c26c66d93ae5ab076865eca3" translate="yes" xml:space="preserve">
          <source>Example 3: Matrix creation from an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0d4f43d7d9bdb2a4af703ab58a4be1e4d7fae7" translate="yes" xml:space="preserve">
          <source>Example illustrating a common use of &lt;a href=&quot;#numpy.linalg.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;: solving of least squares problems</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b9b4c475cb57be9cefc272ad9e58398f1d4a72d" translate="yes" xml:space="preserve">
          <source>Example of ellipsis use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663d5de84d17f73904544fdaa7818c43c339aab6" translate="yes" xml:space="preserve">
          <source>Example of the &lt;em&gt;axis&lt;/em&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441193d28defb7b45677223f2e8385cc1771ef57" translate="yes" xml:space="preserve">
          <source>Example showing broadcast of scalar_like argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7651c4bad19b71b6cb07d324b05afde4b46e15c" translate="yes" xml:space="preserve">
          <source>Exceeded max_work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a918f3b3ebec530b94769e489c47c784e700d0" translate="yes" xml:space="preserve">
          <source>Except for splitting from the right, &lt;a href=&quot;#numpy.char.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; behaves like &lt;a href=&quot;numpy.char.split#numpy.char.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50cf8f9b1990e86989de06e0c8538067135c84c5" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcfc562b386cd345086d419126e4274f3e7274f0" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e6ce501ea40e3a3a4030f941745cb2ec376d8c" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;func1d(a, *args)&lt;/code&gt; where &lt;code&gt;func1d&lt;/code&gt; operates on 1-D arrays and &lt;code&gt;a&lt;/code&gt; is a 1-D slice of &lt;code&gt;arr&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd62d234a86ea4d63bc3019c94a352e75700653" translate="yes" xml:space="preserve">
          <source>Existing array to use for output. If not given, returns a default copy of a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49efde5e22ecb6838665120a39ab53a2bd9e68ce" translate="yes" xml:space="preserve">
          <source>Existing arrays are not copied:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49afcf31d80f21e8d0b1602a5dec36d208fe71f8" translate="yes" xml:space="preserve">
          <source>Expand the shape of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffcf950230f953a0aa6e82e09f28f2ca5a3b9124" translate="yes" xml:space="preserve">
          <source>Expectation of interval, must be &amp;gt;= 0. A sequence of expectation intervals must be broadcastable over the requested size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1e24ddaed54869cdb52d8afc4913163a237789" translate="yes" xml:space="preserve">
          <source>Expects a 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, returns None if all values are masked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308f613122797fe7bbf7289f6c7ded6a9a215476" translate="yes" xml:space="preserve">
          <source>Explained without fancy indexing, this is equivalent to the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a8ab3710ac4db36fc8b2f6b13aa845d130b020" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest (most negative) power of &lt;code&gt;ibeta&lt;/code&gt; that, added to 1.0, gives something different from 1.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c379526da851c2c188007fc0f60f969489df7a" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest power of &lt;code&gt;ibeta&lt;/code&gt; that, subtracted from 1.0, gives something different from 1.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6764a081f01f39974a118ba6996f7bb9dae570" translate="yes" xml:space="preserve">
          <source>Exponentials</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce964226c06687afb0e1cd2608b915c6e2ae80f" translate="yes" xml:space="preserve">
          <source>Exponents and logarithms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be9a4abd6d7c8083fc1a7bf9004e653250a9ba5" translate="yes" xml:space="preserve">
          <source>Extending</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8df212e6d243492be0344c26fa93a5ac0e105d8" translate="yes" xml:space="preserve">
          <source>Extends &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt; with several advanced options providing more control over broadcasting and buffering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730550afb5b9c93a998c435ea0c0d79790c3f92e" translate="yes" xml:space="preserve">
          <source>External Links:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5695baec527125ed849fab25176346709bcdc26" translate="yes" xml:space="preserve">
          <source>Extra arguments to be used in the function call. Default is no extra arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7475cdd2c7bf2da401a59201928f6e438e74c2c4" translate="yes" xml:space="preserve">
          <source>Extra data to be passed to the 1-d vector loops or &lt;code&gt;NULL&lt;/code&gt; if no extra-data is needed. This C-array must be the same size ( &lt;em&gt;i.e.&lt;/em&gt; ntypes) as the functions array. &lt;code&gt;NULL&lt;/code&gt; is used if extra_data is not needed. Several C-API calls for UFuncs are just 1-d vector loops that make use of this extra data to receive a pointer to the actual function to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b524fa169ed9d7419720ac2e63f1800fb02fd6" translate="yes" xml:space="preserve">
          <source>Extra features in NumPy Distutils</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b908b04be2629c5ae91c968b91dbf4fa38bfee" translate="yes" xml:space="preserve">
          <source>Extract a diagonal or construct a diagonal array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2f355e8dba1681289d909a9095fc402d801e4a" translate="yes" xml:space="preserve">
          <source>Extract the diagonal (requires explicit form):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b194f535090973445600575106dc4bd4b91c15" translate="yes" xml:space="preserve">
          <source>F &amp;amp; C order preserved, otherwise most similar order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a82a1967b0685fff927bd0da5e7638582e5ea69" translate="yes" xml:space="preserve">
          <source>F order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79b9dbc4a93112f31ab2f13620d941f25753284" translate="yes" xml:space="preserve">
          <source>F order if input is F and not C, otherwise C order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8300dc1be4d8761c3816eeb71051b6b621dd6e" translate="yes" xml:space="preserve">
          <source>FFT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca600c25350318c92a93eef893cdd109ac18c10d" translate="yes" xml:space="preserve">
          <source>FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform (DFT) can be calculated efficiently, by using symmetries in the calculated terms. The symmetry is highest when &lt;code&gt;n&lt;/code&gt; is a power of 2, and the transform is therefore most efficient for these sizes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e904f6af52956913c4ff703c15d71d4683c8dd0" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS / F / FORTRAN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ba031202732234b30a39bc920cbaa6d821ef6b" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542219cc1d690d05adfbb2e51a8b3ccb1985fddc" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c6c271be69ba94867c22f54f57654f454c41b4" translate="yes" xml:space="preserve">
          <source>Factor the matrix &lt;code&gt;a&lt;/code&gt; as &lt;em&gt;qr&lt;/em&gt;, where &lt;code&gt;q&lt;/code&gt; is orthonormal and &lt;code&gt;r&lt;/code&gt; is upper-triangular.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb318cde14ee94b6e5d32ac7d527c0788644b0e1" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class and with message that matches expected_regexp is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021d84299e2248496708e7d1e546ad6c2c18b0ba" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88591071684d50acd16039be01f0c08d81ea457a" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs. If a different type of exception is thrown, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719788786f4bf9fa2ee26b39d5371d0a438935c3" translate="yes" xml:space="preserve">
          <source>Fail unless the given callable throws the specified warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552c13b4b3257ae89f519cb962e935c59da9aa88" translate="yes" xml:space="preserve">
          <source>Fanaticism consists of redoubling your efforts when you have forgotten your aim. &amp;mdash; &lt;em&gt;George Santayana&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35d6e8cdee3fab38ad9c3056a80a39fdb1d90ea" translate="yes" xml:space="preserve">
          <source>Faster version of &lt;a href=&quot;#numpy.base_repr&quot;&gt;&lt;code&gt;base_repr&lt;/code&gt;&lt;/a&gt; for base 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6f34280b7f890c09c370b6ae106bab782a8ea7" translate="yes" xml:space="preserve">
          <source>Field Access</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f20e66b17a6eb7c2baf1ab68337d91eaf6f4f80" translate="yes" xml:space="preserve">
          <source>Figure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373ecfdf236324d2c0d2c0966daa4376bd84ecc7" translate="yes" xml:space="preserve">
          <source>File extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09479e812c08194a796ba5cf0534018f31d75df" translate="yes" xml:space="preserve">
          <source>File like object that the output is written to, default is &lt;code&gt;stdout&lt;/code&gt;. The object has to be opened in &amp;lsquo;w&amp;rsquo; or &amp;lsquo;a&amp;rsquo; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87eae4c8fed58e613f33763392061f9f060bfb3a" translate="yes" xml:space="preserve">
          <source>File mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd757708817417e6d160c4d854e159b642dde015" translate="yes" xml:space="preserve">
          <source>File name or file object to read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9cb7966c21c4ba3f863696ad8ce671f4f627493" translate="yes" xml:space="preserve">
          <source>File object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a94520c92dda87c31025fbdcee94cc740835e3c" translate="yes" xml:space="preserve">
          <source>File on disk is unchanged:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0031f1b0b3ec78263f049edb5bf2d9bd62cb7daa" translate="yes" xml:space="preserve">
          <source>File or filename to which the data is saved. If file is a file-object, then the filename is unchanged. If file is a string or Path, a &lt;code&gt;.npy&lt;/code&gt; extension will be appended to the file name if it does not already have one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e820f26629f1b163437a25da45907f2a0bdeef89" translate="yes" xml:space="preserve">
          <source>File, filename, list, or generator to read. If the filename extension is &lt;code&gt;gz&lt;/code&gt; or &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt;, the file is first decompressed. Note that generators must return byte strings in Python 3k. The strings in a list or produced by a generator are treated as lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822b222e1d15e367e3952f91b983db03e9a7813a" translate="yes" xml:space="preserve">
          <source>File, filename, or generator to read. If the filename extension is &lt;code&gt;.gz&lt;/code&gt; or &lt;code&gt;.bz2&lt;/code&gt;, the file is first decompressed. Note that generators should return byte strings for Python 3k.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13aad6dcb77e8786c02dc6c8f0cc3a100a87f10" translate="yes" xml:space="preserve">
          <source>File-like object to write the output to. If omitted, use a pager.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafc76c090d17de83480422080a28bd0d7fd39f0" translate="yes" xml:space="preserve">
          <source>Fill a newly created array with a single value obj at all locations in the structure with object data-types. No checking is performed but &lt;em&gt;arr&lt;/em&gt; must be of data-type &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; and be single-segment and uninitialized (no previous objects in position). Use &lt;code&gt;PyArray_DECREF&lt;/code&gt; (&lt;em&gt;arr&lt;/em&gt;) if you need to decrement all the items in the object array prior to calling this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260366fdf73d36b977576943b4aedf90420566c3" translate="yes" xml:space="preserve">
          <source>Fill the array pointed to by &lt;em&gt;obj&lt;/em&gt; &amp;mdash;which must be a (subclass of) ndarray&amp;mdash;with the contents of &lt;em&gt;val&lt;/em&gt; (evaluated as a byte). This macro calls memset, so obj must be contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc72d434ca66ec2855e95222b47cf34ee62d6a9" translate="yes" xml:space="preserve">
          <source>Fill the array with a scalar value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5d5966e608173a9667b1c1fac892e66538c72e9" translate="yes" xml:space="preserve">
          <source>Fill the array, &lt;em&gt;arr&lt;/em&gt;, with the given scalar object, &lt;em&gt;obj&lt;/em&gt;. The object is first converted to the data type of &lt;em&gt;arr&lt;/em&gt;, and then copied into every location. A -1 is returned if an error occurs, otherwise 0 is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bee882405d3a5e1e28b315ab4a7baab2498c486" translate="yes" xml:space="preserve">
          <source>Fill the main diagonal of the given array of any dimensionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0054199bd21115b17143e2277b55874769f1942" translate="yes" xml:space="preserve">
          <source>Fill value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3edc087fa7c92433208963d028502658cb11c3c" translate="yes" xml:space="preserve">
          <source>Filling a masked array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16b1c014bc041df050e0baec2b30b9a58147141" translate="yes" xml:space="preserve">
          <source>Filling in the missing data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4473d8b6f530a08d5d328b58cdecfd819be6ec67" translate="yes" xml:space="preserve">
          <source>Filling value. A consistency test is performed to make sure the value is compatible with the dtype of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13227282778cd8d20999d32a512e651e3ee07193" translate="yes" xml:space="preserve">
          <source>Filling value. Default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1d42d50fc7e4074f490614ad1bcf00ba471b76" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outreadflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be read from, and to 0 if not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749d04ce696c047f8e1f31d9e0905d115c8ee6f7" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outwriteflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be written to, and to 0 if not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3ad1e9024ff38aba4d75bcdff8761b89757502" translate="yes" xml:space="preserve">
          <source>Filter deprecation warnings while running the test suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d64090d55b3e9e6c51d2a5eb3eec10a8e6734d" translate="yes" xml:space="preserve">
          <source>Filters added inside the context manager will be discarded again when leaving it. Upon entering all filters defined outside a context will be applied automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7718a6ac69fd3c4dc296189cd48158349007af" translate="yes" xml:space="preserve">
          <source>Final output manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba468d0ce6c90f05fb67a4c2a63c164ebea004bd" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;Configuration&lt;/code&gt; has &lt;code&gt;.todict()&lt;/code&gt; method that returns all the configuration data as a dictionary suitable for passing on to the &lt;code&gt;setup(..)&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889c8c42cccc1d124561a48d8ca41abb6ac29d7b" translate="yes" xml:space="preserve">
          <source>Finally, a data type can describe items that are themselves arrays of items of another data type. These sub-arrays must, however, be of a fixed size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591676022a4d7afed7631e7209e11f88a0c70ca2" translate="yes" xml:space="preserve">
          <source>Finally, if you are only interested in testing a subset of SciPy, for example, the &lt;code&gt;integrate&lt;/code&gt; module, use the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd9ab198daaf3fb255075968e2a8d87bc37a3b9" translate="yes" xml:space="preserve">
          <source>Finally, it is emphasized that &lt;code&gt;v&lt;/code&gt; consists of the &lt;em&gt;right&lt;/em&gt; (as in right-hand side) eigenvectors of &lt;code&gt;a&lt;/code&gt;. A vector &lt;code&gt;y&lt;/code&gt; satisfying &lt;code&gt;dot(y.T, a) = z * y.T&lt;/code&gt; for some number &lt;code&gt;z&lt;/code&gt; is called a &lt;em&gt;left&lt;/em&gt; eigenvector of &lt;code&gt;a&lt;/code&gt;, and, in general, the left and right eigenvectors of a matrix are not necessarily the (perhaps conjugate) transposes of each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d9a64e4784c058720be52ad39c03d39a9fcbd1" translate="yes" xml:space="preserve">
          <source>Finally, specific entries can be masked and/or unmasked by assigning to the mask a sequence of booleans:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ee797bc2c97cc8f17d94ef802f458cb35c39bc" translate="yes" xml:space="preserve">
          <source>Finally, the decision is made about how to execute the looping mechanism to ensure that all elements of the input arrays are combined to produce the output arrays of the correct type. The options for loop execution are one-loop (for contiguous, aligned, and correct data type), strided-loop (for non-contiguous but still aligned and correct data type), and a buffered loop (for mis-aligned or incorrect data type situations). Depending on which execution method is called for, the loop is then setup and computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3616e9f1dcf861efd823c12b4478a31e6b82b402" translate="yes" xml:space="preserve">
          <source>Financial functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75334f040026f76d3eebb8839bcb303508014551" translate="yes" xml:space="preserve">
          <source>Find a domain suitable for a polynomial or Chebyshev series defined at the values supplied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a6e9c15d888c380a37d1831fa7891adeb9bb51" translate="yes" xml:space="preserve">
          <source>Find contiguous unmasked data in a masked array along the given axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ea5a445ce3dee9c559f1f1b3b7f52dca61477d" translate="yes" xml:space="preserve">
          <source>Find elements in a sorted array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cd38efe59f33f3a5f798ed6a4cf4880d549aa4" translate="yes" xml:space="preserve">
          <source>Find elements in sorted array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a5d00a32b708a9fb964c2d1da18b0ebb9fba20" translate="yes" xml:space="preserve">
          <source>Find indices where elements of v should be inserted in a to maintain order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d914d41d09d92c97e462c896bc6019f8705e89" translate="yes" xml:space="preserve">
          <source>Find indices where elements should be inserted to maintain order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4372485b0452a2bbbc2898c490d8eaeffc724caf" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with a given sequence of roots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa2e8dff7b7635f67ecf147d005df15f99ba737" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with the given sequence of roots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb3d9e0549601789e7c859dc2344bd2a9cd19fd" translate="yes" xml:space="preserve">
          <source>Find the derivative of order &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2e68d5137b01880925e686f099633be3e06dde" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted array &lt;code&gt;a&lt;/code&gt; such that, if the corresponding elements in &lt;code&gt;v&lt;/code&gt; were inserted before the indices, the order of &lt;code&gt;a&lt;/code&gt; would be preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9d95dd2166bd57167eb2521a394d4c2313d8ed" translate="yes" xml:space="preserve">
          <source>Find the indices of array elements that are non-zero, grouped by element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2515b150e246a2efffb14706325a36534baa7e52" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values along an axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696f121ac590832370778adcb2254fdcf409cf46" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c77cbf79b427711a4234d92c8cd55031f045a5a" translate="yes" xml:space="preserve">
          <source>Find the intersection of two arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d747b61a4dca9ab1a6c9357e1706a93f4e98f6e" translate="yes" xml:space="preserve">
          <source>Find the product of two polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f141aa841d4a25a7614625f7b95555f03b44cb1f" translate="yes" xml:space="preserve">
          <source>Find the roots:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e641c4ed98de6b655c0148c1b174236bccd25db9" translate="yes" xml:space="preserve">
          <source>Find the set difference of two arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d47458289ee93eb8b76d9bd5fb051fb0ed38ef9" translate="yes" xml:space="preserve">
          <source>Find the set exclusive-or of two arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c6faf7e08f7eff45fa7f2fb510420c1dd0653b" translate="yes" xml:space="preserve">
          <source>Find the sum of two polynomials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc296de5854442d0290915421679a6d44da683c5" translate="yes" xml:space="preserve">
          <source>Find the union of two arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2a1d48695ed18506cd6bf1d2bc59c3cfb89875" translate="yes" xml:space="preserve">
          <source>Find the unique elements of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5a640c918941c9e6a6ecbfe984c3f4bfbed0d7" translate="yes" xml:space="preserve">
          <source>Finding help</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b7033e44afb091d2adc537dc898dc007a565a8f" translate="yes" xml:space="preserve">
          <source>Finding masked data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f98684f09d3dc8ddcf467b643533c39f6675211" translate="yes" xml:space="preserve">
          <source>Finds the data type of smallest size and kind to which &lt;em&gt;type1&lt;/em&gt; and &lt;em&gt;type2&lt;/em&gt; may be safely converted. This function is symmetric and associative. A string or unicode result will be the proper size for storing the max value of the input types converted to a string or unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce819b28621d52328ceb9faf1bacb0b89098499a" translate="yes" xml:space="preserve">
          <source>Finds the polynomial resulting from the multiplication of the two input polynomials. Each input must be either a poly1d object or a 1D sequence of polynomial coefficients, from highest to lowest degree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f34df28a801d8ac2bf79f8d990420b3ba51454a" translate="yes" xml:space="preserve">
          <source>First adjusts the date to fall on a valid day according to the &lt;code&gt;roll&lt;/code&gt; rule, then applies offsets to the given dates counted in valid days.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d783583ca6eea2b3fefbcfe238ea095a9cef1e3" translate="yes" xml:space="preserve">
          <source>First argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d88798d2f2c8c94dabdac74a6e61e0c6a796bf" translate="yes" xml:space="preserve">
          <source>First array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac9adbced8bb3d28582fadcfc79411667f91541" translate="yes" xml:space="preserve">
          <source>First array elements raised to powers from second array, element-wise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e663054d84a3a5ee1c34a1c08db3c0840bbd3a5" translate="yes" xml:space="preserve">
          <source>First axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="683b791e072100a372b3bb52b18b0195b72f135d" translate="yes" xml:space="preserve">
          <source>First data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c696689a14b681bedf220e6fcb537947492362e7" translate="yes" xml:space="preserve">
          <source>First input vector. Input is flattened if not already 1-dimensional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da5db5b8e385a1ee882571360fd0091e5988af4" translate="yes" xml:space="preserve">
          <source>First mode, &lt;code&gt;buffer&lt;/code&gt; is None:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79fb79c693534cb9180b2dc2b3dd92f6526ad678" translate="yes" xml:space="preserve">
          <source>First of all, if confused or uncertain, definitely look at the Examples - in its full generality, this function is less simple than it might seem from the following code description (below ndi = &lt;code&gt;numpy.lib.index_tricks&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9507aadaef3c19b4ad781014173284bb4bf64a4d" translate="yes" xml:space="preserve">
          <source>First one-dimensional input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563237e589c4b3a10445b43e30dbcdf140e6cad9" translate="yes" xml:space="preserve">
          <source>First we need a polynomial class and a polynomial instance to play with. The classes can be imported directly from the polynomial package or from the module of the relevant type. Here we import from the package and use the conventional Polynomial class because of its familiarity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5747b08f0749ca8d3f849c4ccb46feb2a535fd" translate="yes" xml:space="preserve">
          <source>First, we solve for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b876747d103212266850792bf08c2d985fdb7ec" translate="yes" xml:space="preserve">
          <source>Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The relation between the number of species and the number of individuals in a random sample of an animal population. Journal of Animal Ecology, 12:42-58.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c009756385026adf817423fdf3347327b7bcadd" translate="yes" xml:space="preserve">
          <source>Fit a line, &lt;code&gt;y = mx + c&lt;/code&gt;, through some noisy data-points:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b6a58e5360946679575e2105b73e661e63702d" translate="yes" xml:space="preserve">
          <source>Fit a polynomial &lt;code&gt;p(x) = p[0] * x**deg + ... + p[deg]&lt;/code&gt; of degree &lt;code&gt;deg&lt;/code&gt; to points &lt;code&gt;(x, y)&lt;/code&gt;. Returns a vector of coefficients &lt;code&gt;p&lt;/code&gt; that minimises the squared error in the order &lt;code&gt;deg&lt;/code&gt;, &lt;code&gt;deg-1&lt;/code&gt;, &amp;hellip; &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63bb8e80d7458f568a44355aa0204375070cb16" translate="yes" xml:space="preserve">
          <source>Fits using Chebyshev series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac350719f356e32b4a5aa08bc22f253d0d0c702" translate="yes" xml:space="preserve">
          <source>Fits using Hermite series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Hermite weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt;&lt;code&gt;hermweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676d43f6371871e1abab21b58a8b9ef9e5c444e9" translate="yes" xml:space="preserve">
          <source>Fits using HermiteE series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the HermiteE weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt;&lt;code&gt;hermeweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ad2d45b7ba84d02856af83a31db48500b6c521" translate="yes" xml:space="preserve">
          <source>Fits using Laguerre series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Laguerre weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt;&lt;code&gt;lagweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49cebd2c0a64b6ed696a25d8e9c66d10c8d54a0" translate="yes" xml:space="preserve">
          <source>Fits using Legendre series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5165daf49b08b1322899a60f534d050a344807b1" translate="yes" xml:space="preserve">
          <source>Fitting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e51f96db68dc8fabd62d003884216322595fc6f" translate="yes" xml:space="preserve">
          <source>Fitting is the reason that the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt; attributes are part of the convenience classes. To illustrate the problem, the values of the Chebyshev polynomials up to degree 5 are plotted below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa2ab2730080c4d8658ad57247e52d05152019e" translate="yes" xml:space="preserve">
          <source>Fixed stride displacement from the beginning of an axis? Default is 0. Needs to be &amp;gt;=0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35076585aaced59b92c591cb61ebdef18acdfe9a" translate="yes" xml:space="preserve">
          <source>Flag checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59933a6089d6095752a4cce71d3ac903e7e62ac" translate="yes" xml:space="preserve">
          <source>Flag indicating the return a legacy tuple state when the BitGenerator is MT19937.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eae779d408b29132a4d17f05274c96311b19164" translate="yes" xml:space="preserve">
          <source>Flag indicating whether a tuple &lt;code&gt;(result, sum of weights)&lt;/code&gt; should be returned as output (True), or just the result (False). Default is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba3c052d7e9a9fd1a29828876ef83802ed53ad9" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark test as deprecated or not. If the condition is a callable, it is used at runtime to dynamically make the decision. Default is True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc63716a41208b1dbc0ebbf61137c2d0ff0fbfd4" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark the decorated test as a known failure (if True) or not (if False).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a36aef11ecfbbf2d82d57b5084b3ab96e773b04" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to skip the decorated test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e57359674e825c88bcaaa1bf354a5ba42abc10" translate="yes" xml:space="preserve">
          <source>Flag-like constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684f757afc22b26a0ad180a11e58599da12d805b" translate="yes" xml:space="preserve">
          <source>Flags indicating how the memory pointed to by data is to be interpreted. Possible flags are &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25e18657a4cd94e4091eda9ea0dfb9fbc2878ec" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt; are any combination of the global and per-operand flags documented in &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;, except for &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc811e4e9d890d1a74c59122b943f93451db31b" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt;, applying to the whole iterator, are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e576896ed3787e8ae91c02c3fee7275b55ae4f5d" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;op_flags[i]&lt;/code&gt;, where &lt;code&gt;0 &amp;lt;= i &amp;lt; nop&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0902dde9b75159ba7b0f6af69bd12aa3aed3ab46" translate="yes" xml:space="preserve">
          <source>Flags to control the behavior of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbaad527fcacc3d77ae0f546c2f20b2e4ef2d71" translate="yes" xml:space="preserve">
          <source>Flat Iterator indexing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0541280577eeacfb45501ad1950007e690905f" translate="yes" xml:space="preserve">
          <source>Flat array iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f8292fdeb383ecef90303832ffb1117799af185" translate="yes" xml:space="preserve">
          <source>Flat iteration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666002e8705384831180e281fa74a843e3206b27" translate="yes" xml:space="preserve">
          <source>Flat iterator object to iterate over arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4ad130c0f4e03f5e84c5e86d9264a95dc6c3f6" translate="yes" xml:space="preserve">
          <source>Flattened version of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21fe615f2b66ecf8096308ee67f646d6664a1077" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally (axis=1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7849c3ad46cd56097aefd350ce5a24872c1a9619" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25cec9261711d7c64f4f0328d27630ff4251008" translate="yes" xml:space="preserve">
          <source>Flip an array vertically (axis=0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f1196dc69384b1c0ff7122abf54115c6fe24e6" translate="yes" xml:space="preserve">
          <source>Flip an array vertically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054ba7b0cd3f0b3aa1e4b17f975a52c4e03f8b87" translate="yes" xml:space="preserve">
          <source>Flip array in the left/right direction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71aa214a7a981c7e5292f4c8603043e9a55d042" translate="yes" xml:space="preserve">
          <source>Flip array in the up/down direction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6b601389a5cfb7f115ef7332083ae3431e4e4e3" translate="yes" xml:space="preserve">
          <source>Flip the entries in each column in the up/down direction. Rows are preserved, but appear in a different order than before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14bb6de935d5a8cea7f1dc6e4323a38f4e11462" translate="yes" xml:space="preserve">
          <source>Flip the entries in each row in the left/right direction. Columns are preserved, but appear in a different order than before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7d4f9efa22847d513f86cb336f4d917bb3ff00" translate="yes" xml:space="preserve">
          <source>Float type code to coerce input array &lt;code&gt;a&lt;/code&gt;. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is one of the &amp;lsquo;int&amp;rsquo; dtypes, it is replaced with float64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01625a6e71519a2c19afcda12e2e9da94df799dc" translate="yes" xml:space="preserve">
          <source>Floating functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c47a1b436ef0cc135c28b0dd8fa381311e23c7a" translate="yes" xml:space="preserve">
          <source>Floating point</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1229245ed91cf5c1f6662011b64e640e64679fd2" translate="yes" xml:space="preserve">
          <source>Floating point classification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82951541de1b33acb443a62a7f1b908de9e19ba0" translate="yes" xml:space="preserve">
          <source>Floating point error handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe05d916add7aed11140c3ac753c505841f4681" translate="yes" xml:space="preserve">
          <source>Floating point number &lt;code&gt;beta**minexp&lt;/code&gt; (the smallest [in magnitude] usable floating value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd86bfd9f81a559ed8b4c9674c5d1f9e823b143" translate="yes" xml:space="preserve">
          <source>Floating point precision can be set:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481d82b2ccb68e7d8e1fe5eda973bb77f53833f0" translate="yes" xml:space="preserve">
          <source>Floating point precision. Defaults to &lt;code&gt;numpy.get_printoptions()['precision']&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6770ad9e8703a79e53fa3beb7d8e8f53215f921c" translate="yes" xml:space="preserve">
          <source>Floating point routines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb20a81d8b5780d9de2483bc5cafd120d0cd965" translate="yes" xml:space="preserve">
          <source>Floating point values are not demoted to integers, and complex values are not demoted to floats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a6aa48e3a6c80756547c7551fe79b07bb4f3a1c" translate="yes" xml:space="preserve">
          <source>Floating values between -1 and 1. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f0281f3f5728d7cb1a3465fbf569e0196bf3cd" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**machep&lt;/code&gt; (floating point precision)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8899b4f72c4b482d21d27616c70625d6596dd90" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**negep&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eae9dc4dc291f4562016bea57ea67a7a3b1f88f" translate="yes" xml:space="preserve">
          <source>Floating-point numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55734ad7ec5ec7776c0a844d3df4e815b482074b" translate="yes" xml:space="preserve">
          <source>Floats uniformly distributed over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c505c67e9b4dbb54495e1dc42c80f1a7a1c454f" translate="yes" xml:space="preserve">
          <source>Floor divide self by other in-place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ddc7d58e45f89f16199c2075dcd43275a50c059" translate="yes" xml:space="preserve">
          <source>Floor division, &amp;lsquo;//&amp;rsquo;, is the division operator for the polynomial classes, polynomials are treated like integers in this regard. For Python versions &amp;lt; 3.x the &amp;lsquo;/&amp;rsquo; operator maps to &amp;lsquo;//&amp;rsquo;, as it does for Python, for later versions the &amp;lsquo;/&amp;rsquo; will only work for division by scalars. At some point it will be deprecated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977e7ae24b1ce53baf0769e85a5d553c0c1ba1a9" translate="yes" xml:space="preserve">
          <source>Following each integration the result is &lt;em&gt;multiplied&lt;/em&gt; by &lt;code&gt;scl&lt;/code&gt; before the integration constant is added. (Default: 1)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0edda5efdca0ba777ab89777b73ae8abb0ac8170" translate="yes" xml:space="preserve">
          <source>Following the header comes the array data. If the dtype contains Python objects (i.e. &lt;code&gt;dtype.hasobject is True&lt;/code&gt;), then the data is a Python pickle of the array. Otherwise the data is the contiguous (either C- or Fortran-, depending on &lt;code&gt;fortran_order&lt;/code&gt;) bytes of the array. Consumers can figure out the number of bytes by multiplying the number of elements given by the shape (noting that &lt;code&gt;shape=()&lt;/code&gt; means there is 1 element) by &lt;code&gt;dtype.itemsize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e3737ce90be5e40d3542337b2a16d0ddfea15fe" translate="yes" xml:space="preserve">
          <source>For 18 of the 21 types this number is fixed by the data-type. For the flexible data-types, this number can be anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe31cdcb6c6646809088d5903655d52a55d450e" translate="yes" xml:space="preserve">
          <source>For 2-D arrays it is the matrix product:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f962aedbf83ef9d65d44b9e69490919cc79f9a0" translate="yes" xml:space="preserve">
          <source>For 2-D mixed with 1-D, the result is the usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249d7389fa64403ab6c1fc03103e6db107907e49" translate="yes" xml:space="preserve">
          <source>For 8-bit strings, this method is locale-dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34d3054bfe352b99ce08082d1411334b317ca53" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; one-dimensional, this is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fa074fdf944e6525f90fb53e3868628cc3a171" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;a.view(some_dtype)&lt;/code&gt;, if &lt;code&gt;some_dtype&lt;/code&gt; has a different number of bytes per entry than the previous dtype (for example, converting a regular array to a structured array), then the behavior of the view cannot be predicted just from the superficial appearance of &lt;code&gt;a&lt;/code&gt; (shown by &lt;code&gt;print(a)&lt;/code&gt;). It also depends on exactly how &lt;code&gt;a&lt;/code&gt; is stored in memory. Therefore if &lt;code&gt;a&lt;/code&gt; is C-ordered versus fortran-ordered, versus defined as a slice or transpose, etc., the view may give different results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272593adff1434bde1d4cd33b0346e0c6d20e042" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;e, E&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; specifiers, the number of digits to print after the decimal point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b87fa4bee96c31297a2faf4474562d50259437" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;, the maximum number of significant digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f16f572df2de5dbe71ab6b482a26aade3788153" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;s&lt;/code&gt;, the maximum number of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96de2b474663e4b27c100d387c234e173e9360ba" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0 a view of &lt;code&gt;a&lt;/code&gt; is always returned. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187181bc029dad6f61070b7f6592eecd79b97aa5" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0, if &lt;code&gt;a&lt;/code&gt; is an ndarray, then a view of &lt;code&gt;a&lt;/code&gt; is returned; otherwise a new array is created. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f70af9beed617bc137c199798e6f21c9093a8c" translate="yes" xml:space="preserve">
          <source>For Python, the preferred way of handling contiguous (or technically, &lt;em&gt;strided&lt;/em&gt;) blocks of homogeneous data is with NumPy, which provides full object-oriented access to multidimensial arrays of data. Therefore, the most logical Python interface for the &lt;code&gt;rms&lt;/code&gt; function would be (including doc string):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f9e5f045d92376c7d38dda0f2622f9b6352be6" translate="yes" xml:space="preserve">
          <source>For a 1-D array this has no effect, as a transposed vector is simply the same vector. To convert a 1-D array into a 2D column vector, an additional dimension must be added. &lt;code&gt;np.atleast2d(a).T&lt;/code&gt; achieves this, as does &lt;code&gt;a[:, np.newaxis]&lt;/code&gt;. For a 2-D array, this is a standard matrix transpose. For an n-D array, if axes are given, their order indicates how the axes are permuted (see Examples). If axes are not provided and &lt;code&gt;a.shape = (i[0], i[1], ... i[n-2], i[n-1])&lt;/code&gt;, then &lt;code&gt;a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f2a60e0b01b84231d8024aebcc5e084e0ba27d" translate="yes" xml:space="preserve">
          <source>For a 1D array, &lt;code&gt;a.tolist()&lt;/code&gt; is almost the same as &lt;code&gt;list(a)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0f7c81098fcc87863f3be5d59395a987825914" translate="yes" xml:space="preserve">
          <source>For a complete discussion of creation methods for masked arrays please see section &lt;a href=&quot;#maskedarray-generic-constructing&quot;&gt;Constructing masked arrays&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bdfc3356f177e5d7773cb796069c781e6c3ff20" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="197692467968599b779c0574e1302cadc5d30a4f" translate="yes" xml:space="preserve">
          <source>For a full description of these options, see &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt;&lt;code&gt;set_printoptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b040ed436e354a6dfab8e28023d68c6eed7a06c2" translate="yes" xml:space="preserve">
          <source>For a function that returns a 1D array, the number of dimensions in &lt;code&gt;outarr&lt;/code&gt; is the same as &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9409ae5300d15907687b38139959611e06963f16" translate="yes" xml:space="preserve">
          <source>For a function that returns a higher dimensional array, those dimensions are inserted in place of the &lt;code&gt;axis&lt;/code&gt; dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adc015d596be980abdfb7f52ddd54b20d9ed4e4" translate="yes" xml:space="preserve">
          <source>For a multi-dimensional array, accumulate is applied along only one axis (axis zero by default; see Examples below) so repeated use is necessary if one wants to accumulate over multiple axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a70a58adc76a39cce5a267ab70438cf75b9572e" translate="yes" xml:space="preserve">
          <source>For a non-trivial signature, &lt;code&gt;dimensions&lt;/code&gt; will also contain the sizes of the core dimensions as well, starting at the second entry. Only one size is provided for each unique dimension name and the sizes are given according to the first occurrence of a dimension name in the signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8218bd5d7a6649aa63226e5b622d4b8efad4dc34" translate="yes" xml:space="preserve">
          <source>For a one-dimensional array, accumulate produces results equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0424b9224931152a35a50c93d8cc0ece880de71a" translate="yes" xml:space="preserve">
          <source>For a one-sided t-test, how far out in the distribution does the t statistic appear?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3911c3b2407712ae47f85ee3fb1ac557138ff00b" translate="yes" xml:space="preserve">
          <source>For a possible future loop selector with a different signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c991a419f14da45f93fac679b2b79a552dc6a583" translate="yes" xml:space="preserve">
          <source>For a simple example, consider taking the sum of all elements in an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b58d63b284139c1918d1c4f188a0cdc07b3bf2" translate="yes" xml:space="preserve">
          <source>For advanced assignments, there is in general no guarantee for the iteration order. This means that if an element is set more than once, it is not possible to predict the final result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08105fb315fdfa97977e494fc0f07ee6275d676" translate="yes" xml:space="preserve">
          <source>For all of these macros &lt;em&gt;arr&lt;/em&gt; must be an instance of a (subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;, but no checking is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c98e7efdd0450f6d403ff7e88bf2f5b1a932b5" translate="yes" xml:space="preserve">
          <source>For all-NaN slices or slices with zero degrees of freedom, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b523336c8d394d1599c127fd9600cfe28ac8e406" translate="yes" xml:space="preserve">
          <source>For all-NaN slices, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f544bc19358af783f5828a5e5053cd2cf057f05c" translate="yes" xml:space="preserve">
          <source>For an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;, the diagonal is the list of locations with indices &lt;code&gt;a[i, ..., i]&lt;/code&gt; all identical. This function modifies the input array in-place, it does not return a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836b756b5d814f029c077f0578ba6c0e58a3c672" translate="yes" xml:space="preserve">
          <source>For an array with rank greater than 1, some of the padding of later axes is calculated from padding of previous axes. This is easiest to think about with a rank 2 array where the corners of the padded array are calculated by using padded values from the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e96c6b0d98bc68cbd820a41e54b4b8abe37a921" translate="yes" xml:space="preserve">
          <source>For an even number of input points, &lt;code&gt;A[n//2]&lt;/code&gt; represents the sum of the values at the positive and negative Nyquist frequencies, as the two are aliased together. See &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57743d92673c43f581b946774bebcebd154a8f73" translate="yes" xml:space="preserve">
          <source>For an example, see &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe48c8702effa07c62fb464257e567d9ddc8002" translate="yes" xml:space="preserve">
          <source>For any index combination, including slicing and axis insertion, &lt;code&gt;a[indices]&lt;/code&gt; is the same as &lt;code&gt;a[np.index_exp[indices]]&lt;/code&gt; for any array &lt;code&gt;a&lt;/code&gt;. However, &lt;code&gt;np.index_exp[indices]&lt;/code&gt; can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5bdb26c08f7af1b31abb9fd2aadbeeef092f4f" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;em&gt;axis&lt;/em&gt; keyword, it defaults to &lt;code&gt;None&lt;/code&gt;. If axis is &lt;em&gt;None&lt;/em&gt;, then the array is treated as a 1-D array. Any other value for &lt;em&gt;axis&lt;/em&gt; represents the dimension along which the operation should proceed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba10981a70013794c3901be17ecdedebc27a1a" translate="yes" xml:space="preserve">
          <source>For backward compatibility and as a standard &amp;ldquo;container &amp;ldquo;class, the UserArray from Numeric has been brought over to NumPy and named &lt;a href=&quot;generated/numpy.lib.user_array.container#numpy.lib.user_array.container&quot;&gt;&lt;code&gt;numpy.lib.user_array.container&lt;/code&gt;&lt;/a&gt; The container class is a Python class whose self.array attribute is an ndarray. Multiple inheritance is probably easier with numpy.lib.user_array.container than with the ndarray itself and so it is included by default. It is not documented here beyond mentioning its existence because you are encouraged to use the ndarray class directly if you can.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1756e23a025872fd532e8ba6c08bb9a4085acd5e" translate="yes" xml:space="preserve">
          <source>For backward compatibility with Python 2 the &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; typestrings remain zero-terminated bytes and &lt;code&gt;np.string_&lt;/code&gt; continues to map to &lt;code&gt;np.bytes_&lt;/code&gt;. To use actual strings in Python 3 use &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;np.unicode_&lt;/code&gt;. For signed bytes that do not need zero-termination &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;i1&lt;/code&gt; can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77dfb74768b5914a720e322bd9c4f4d3188beb4" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, datetime64 still parses timezone offsets, which it handles by converting to UTC. However, the resulting datetime is timezone naive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c64f15e60882d9539499a036901b91bc24bc19f" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the form (str, array of 624 uints, int) is also accepted although it is missing some information about the cached Gaussian value: &lt;code&gt;state = ('MT19937', keys, pos)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb2208bc27c7545536cb93635c9264ced09a6ad" translate="yes" xml:space="preserve">
          <source>For bandlimited interpolation of discrete-time signals, the ideal interpolation kernel is proportional to the sinc function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0640d05a7ef317b56adcd70bde409c84daf4b12d" translate="yes" xml:space="preserve">
          <source>For buffered loops, care must be taken to copy and cast data before the loop function is called because the underlying loop expects aligned data of the correct data-type (including byte-order). The buffered loop must handle this copying and casting prior to calling the loop function on chunks no greater than the user-specified bufsize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ea569e34a0a0f36b8d0d5224e34f847b3cf085" translate="yes" xml:space="preserve">
          <source>For clarity it is useful to provide some examples of the type description and corresponding &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; &amp;lsquo;descr&amp;rsquo; entries. Thanks to Scott Gilbert for these examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aefcdcec95bb0a9f49c3ea43d81c147b480f4a1a" translate="yes" xml:space="preserve">
          <source>For complete documentation of the types of floating-point exceptions and treatment options, see &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6638e7aa649639c70b61a262d3fcb528e530dcc" translate="yes" xml:space="preserve">
          <source>For completeness, we&amp;rsquo;ll also add the &amp;lsquo;external_loop&amp;rsquo; and &amp;lsquo;buffered&amp;rsquo; flags, as these are what you will typically want for performance reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823eefe35591ae1ef0928dcf4115410e8d28b81a" translate="yes" xml:space="preserve">
          <source>For complex arguments, &lt;code&gt;x = a + ib&lt;/code&gt;, we can write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d19b01697a76f9042f9abe787cb066622b4409" translate="yes" xml:space="preserve">
          <source>For complex dtypes, the above is applied to each of the real and imaginary components of &lt;code&gt;x&lt;/code&gt; separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aabc240767fa8c38770aded9994dbfb9309fc85" translate="yes" xml:space="preserve">
          <source>For complex inputs, the &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a57514466afa09fc7538317ff0a405ada2d56e" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has branch cuts &lt;code&gt;[-inf, -1]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff44215d073bf2342406439d430f9b3eb5cc308c" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 1]&lt;/code&gt; and is continuous from above on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f377fde8ecd4efebbb4d5831dcc8bc678877a9" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arcsin&quot;&gt;&lt;code&gt;arcsin&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has, by convention, the branch cuts [-inf, -1] and [1, inf] and is continuous from above on the former and from below on the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57038706eece9d133e1f92cf4c0e30653094f94f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has [&lt;code&gt;1j, infj&lt;/code&gt;] and [&lt;code&gt;-1j, -infj&lt;/code&gt;] as branch cuts, and is continuous from the left on the former and from the right on the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c701e0e2c7136fbf8b3d11659944481b8208402" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[-1, -inf]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159e5638a9f1467d3dd2785cf39347fd2d548d9f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba7031abf7f62c036d84ca3e657ff0bbe63c9b4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d03218ffbd2a27086f21639f1e5d2c57e1fdb96" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, -1]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714b21ba8fb7b3f93db097558f921f5a3cc7d7e7" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a557bc2da4dcaaf761d30f4619e8e0d4a2f4e8f4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[1j, infj]&lt;/code&gt; and &lt;code&gt;[-1j, -infj]&lt;/code&gt; and is continuous from the right on the former and from the left on the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81428e8e562739a6cb03d81d7a49ece97991e48" translate="yes" xml:space="preserve">
          <source>For consistency with histogram, an array of pre-computed bins is passed through unmodified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4c585fafb6282979d170d7fc49312f2240470" translate="yes" xml:space="preserve">
          <source>For convenience and backward compatibility, a single &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s methods are imported into the numpy.random namespace, see &lt;a href=&quot;legacy#legacy&quot;&gt;Legacy Random Generation&lt;/a&gt; for the complete list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d19661d614c330e3a9e7e16801d7b1d4abdea7" translate="yes" xml:space="preserve">
          <source>For data types that are always the same size (such as long), this holds the size of the data type. For flexible data types where different arrays can have a different elementsize, this should be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88871b72e212455bd0a3305f24c658a9086cd65b" translate="yes" xml:space="preserve">
          <source>For data types that describe sub-arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665e908efd043172f3a61d4025a859ec2c83aba8" translate="yes" xml:space="preserve">
          <source>For definition of the DFT and conventions used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5f8bb3afe673736236ecca5864cdc9f7fc37e1" translate="yes" xml:space="preserve">
          <source>For developers of NumPy: do not instantiate this at the module level. The initial calculation of these parameters is expensive and negatively impacts import times. These objects are cached, so calling &lt;code&gt;finfo()&lt;/code&gt; repeatedly inside your functions is not a problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58f9c7b61fa3d8a2763dc4a797daee41cc03eb8" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, a set of &lt;code&gt;UFUNC_CORE_DIM*&lt;/code&gt; flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396b05c439db2438a9382de672b6fa8e95c31893" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, the possible &lt;a href=&quot;c-api.generalized-ufuncs#frozen&quot;&gt;frozen&lt;/a&gt; size if &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; is 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb98f2bacd6f2ddd2321b31d6e02518d57ef1a01" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd82d55a1666ac371b70f835404bd2254f11112" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0072392849c4a29d135980cb1732127fb7c8293" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce017fa2090bd21769500e23616f51df45b2cf16" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc8c5cf0a4ab8429da79ab635d524c5cd68a8b9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48d2d67a82f24a073bc0fd48d1c7c812f1f1bea" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96129628d06f13e5afb8f18fe53cee0a045c865" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53321b75d28930691a06237aff36907b43cca790" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01fe9cacbc57867bf7b4b4ec2f69fefe5c4a037" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the first occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7288d8c0ac4641f453c7b03f986690cbb92d91ab" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the last occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2be6980f0e55faed04690c7996e6d49756d7224" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only decimal characters in the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59ff6bcceb7225ac9cadb07484ec0465abb9c2a" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only numeric characters in the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9058afe727e5f02cb1c2a82daba2773477e47ab5" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef526a1c4bb908663ee9a7ed64b48415ce75d7c1" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e51c79c7e0159f28fc2312e8504acece61be2e0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with uppercase characters converted to lowercase and vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563e89160eca98fee13c4e654d4638943cb7ede0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46f8951acf83f33ee77a16371dbcf5fcea54c99" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c528552cf6666391ba164c6c98e3136c037ac0d0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c87a7be827172789e8630db0faa9be334e4260" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca0a78fe28a9ed4242353e9fcde6e632b8bffa9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b923cc154e9a0efebee6038be59b5d66a9e904" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fdbaa4039cefb583d1742ab7a44dc37da553da" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66977f41b0aa64aabf235a79a75dcf6b6472f8b1" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only decimal characters in the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1bf891f44f7ba1a69d9acfd1c67a586b04384f4" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only numeric characters in the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1f34aa0e69ee353932bddbc1b5178f2575078b" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained in the range [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0516f761ea835ae249621609400fab8f420640" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42afabee0f54dc6a738be8285f1c8adb1a389c2c" translate="yes" xml:space="preserve">
          <source>For events with an expected separation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f5ea3c2094e2e0d29f615dbd5f1be3db9e9635" translate="yes" xml:space="preserve">
          <source>For example &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;slicing&lt;/a&gt; can produce views of the array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba61c52342c8ca357f9b025f520786b1e36f952" translate="yes" xml:space="preserve">
          <source>For example suppose the source directory contains fun/foo.dat and fun/bar/car.dat:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c528a73750dc2b0ea8c9a4908a64744d7d47416a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; has a state consisting of 624 &lt;code&gt;uint32&lt;/code&gt; integers. A naive way to take a 32-bit integer seed would be to just set the last element of the state to the 32-bit seed and leave the rest 0s. This is a valid state for &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt;, but not a good one. The Mersenne Twister algorithm &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;suffers if there are too many 0s&lt;/a&gt;. Similarly, two adjacent 32-bit integer seeds (i.e. &lt;code&gt;12345&lt;/code&gt; and &lt;code&gt;12346&lt;/code&gt;) would produce very similar streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bc5e66732d4344162eb54fb50c625865f9eafb" translate="yes" xml:space="preserve">
          <source>For example, add.accumulate() is equivalent to np.cumsum().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8d227d278d37b6250f8f06b0e4ddba59ee6707" translate="yes" xml:space="preserve">
          <source>For example, add.reduce() is equivalent to sum().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10dea8dee68a389bd052fd52669dfbae04bf6a1e" translate="yes" xml:space="preserve">
          <source>For example, calculating 3*a, where a is an array of 32-bit floats, intuitively should result in a 32-bit float output. If the 3 is a 32-bit integer, the NumPy rules indicate it can&amp;rsquo;t convert losslessly into a 32-bit float, so a 64-bit float should be the result type. By examining the value of the constant, &amp;lsquo;3&amp;rsquo;, we see that it fits in an 8-bit integer, which can be cast losslessly into the 32-bit float.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e896d341feb39ad2e94789a2fa3a61f98c1ab6de" translate="yes" xml:space="preserve">
          <source>For example, consider a ufunc with signature &lt;code&gt;(i,j),(i)-&amp;gt;()&lt;/code&gt;. In this case, &lt;code&gt;args&lt;/code&gt; will contain three pointers to the data of the input/output arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;. Furthermore, &lt;code&gt;dimensions&lt;/code&gt; will be &lt;code&gt;[N, I, J]&lt;/code&gt; to define the size of &lt;code&gt;N&lt;/code&gt; of the loop and the sizes &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;J&lt;/code&gt; for the core dimensions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;. Finally, &lt;code&gt;steps&lt;/code&gt; will be &lt;code&gt;[a_N, b_N, c_N, a_i, a_j, b_i]&lt;/code&gt;, containing all necessary strides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c761c5136870def0974489fd65a1f38ad92d78" translate="yes" xml:space="preserve">
          <source>For example, for functions like &lt;code&gt;log&lt;/code&gt; with branch cuts, the versions in this module provide the mathematically valid answers in the complex plane:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae012c1a0fdd5d83c39490663637fce0836fd8c" translate="yes" xml:space="preserve">
          <source>For example, here is a typical source generator function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f16b11fb1616884a1f7f0284cf2a3ad3bd24f37" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;a&lt;/code&gt; is a 3x3 array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1eba6b832e945c1e4ddb165d50f426b3bfee26" translate="yes" xml:space="preserve">
          <source>For example, if an iterator was created with a single array as its input, and it was possible to rearrange all its axes and then collapse it into a single strided iteration, this would return a view that is a one-dimensional array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b454223ff8bed8a9b0c67509f246c5fba091e9" translate="yes" xml:space="preserve">
          <source>For example, on a (typical linux x64 gcc) system, the numpy &lt;code&gt;complex64&lt;/code&gt; datatype is implemented as &lt;code&gt;struct { float real, imag; }&lt;/code&gt;. This has &amp;ldquo;true&amp;rdquo; alignment of 4 and &amp;ldquo;uint&amp;rdquo; alignment of 8 (equal to the true alignment of &lt;code&gt;uint64&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b82f8996b94b3076d2602f80a0b8a902b3a3586" translate="yes" xml:space="preserve">
          <source>For examples, see the various functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b2e9c534395e7c5f78b138c5b0b5d135b327e2" translate="yes" xml:space="preserve">
          <source>For finite values, isclose uses the following equation to test whether two floating point values are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62c0e35a11ece55b5adf0e9c849759b322d0ed9" translate="yes" xml:space="preserve">
          <source>For floating point arguments, the length of the result is &lt;code&gt;ceil((stop - start)/step)&lt;/code&gt;. Because of floating point overflow, this rule may result in the last element of &lt;code&gt;out&lt;/code&gt; being greater than &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9208c67472507d398cb8a93a13859f9ce375088" translate="yes" xml:space="preserve">
          <source>For floating point numbers the numerical precision of sum (and &lt;code&gt;np.add.reduce&lt;/code&gt;) is in general limited by directly adding each number individually to the result causing rounding errors in every step. However, often numpy will use a numerically better approach (partial pairwise summation) leading to improved precision in many use-cases. This improved precision is always provided when no &lt;code&gt;axis&lt;/code&gt; is given. When &lt;code&gt;axis&lt;/code&gt; is given, it will depend on which axis is summed. Technically, to provide the best speed possible, the improved precision is only used when the summation is along the fast axis in memory. Note that the exact precision may vary depending on other parameters. In contrast to NumPy, Python&amp;rsquo;s &lt;code&gt;math.fsum&lt;/code&gt; function uses a slower but more precise approach to summation. Especially when summing a large number of lower precision floating point numbers, such as &lt;code&gt;float32&lt;/code&gt;, numerical errors can become significant. In such cases it can be advisable to use &lt;code&gt;dtype=&amp;rdquo;float64&amp;rdquo;&lt;/code&gt; to use a higher precision for the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41c623cdcb4a0e7f4eb2e6a140ca19a3b6cef7a" translate="yes" xml:space="preserve">
          <source>For floating-point input, the &lt;em&gt;std&lt;/em&gt; is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for float32 (see example below). Specifying a higher-accuracy accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="effdce45ed2fe7c4c7447e7c5d6ed579806ca2bd" translate="yes" xml:space="preserve">
          <source>For floating-point input, the variance is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt; (see example below). Specifying a higher-accuracy accumulator using the &lt;code&gt;dtype&lt;/code&gt; keyword can alleviate this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b2341f620f885d0f8ab294ce3abbf3b1a90c60" translate="yes" xml:space="preserve">
          <source>For full documentation, see &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;numpy.searchsorted&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c711733607bfc1bae041078b86f27ea8766c29" translate="yes" xml:space="preserve">
          <source>For further information, see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;memmap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e32d40cffc64e1d0297c17e549d89391273d13d" translate="yes" xml:space="preserve">
          <source>For help in printing, the following strings are defined as the correct format specifier in printf and related commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="489d6f9ad36355f45e025471f49df88064ca87ee" translate="yes" xml:space="preserve">
          <source>For higher dimensional arrays summing a single axis can be done with ellipsis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a424dcac51ca8b201228fd393c244dbeb8c5216" translate="yes" xml:space="preserve">
          <source>For i in &lt;code&gt;range(len(indices))&lt;/code&gt;, &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt;&lt;code&gt;reduceat&lt;/code&gt;&lt;/a&gt; computes &lt;code&gt;ufunc.reduce(a[indices[i]:indices[i+1]])&lt;/code&gt;, which becomes the i-th generalized &amp;ldquo;row&amp;rdquo; parallel to &lt;code&gt;axis&lt;/code&gt; in the final result (i.e., in a 2-D array, for example, if &lt;code&gt;axis = 0&lt;/code&gt;, it becomes the i-th row, but if &lt;code&gt;axis = 1&lt;/code&gt;, it becomes the i-th column). There are three exceptions to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f651225304ab9158ee3f9e677f8c577d092edf" translate="yes" xml:space="preserve">
          <source>For input arrays that are smaller than the specified buffer size, copies are made of all non-contiguous, mis-aligned, or out-of- byteorder arrays to ensure that for small arrays, a single loop is used. Then, array iterators are created for all the input arrays and the resulting collection of iterators is broadcast to a single shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37dbe6dc0691b61b379d0a2afb8134a45871395a" translate="yes" xml:space="preserve">
          <source>For integer arguments with absolute value larger than 1 the result is always zero because of the way Python handles integer division. For integer zero the result is an overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="117e2f99abde5ef34211f008976cf994cee261a9" translate="yes" xml:space="preserve">
          <source>For integer input the return values are floats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f2302ae3afa42e90f16f1c35bbd2af61213570" translate="yes" xml:space="preserve">
          <source>For integer specifiers (eg. &lt;code&gt;d,i,o,x&lt;/code&gt;), the minimum number of digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7401aba5507b33d4914d20070660b9faa95209c3" translate="yes" xml:space="preserve">
          <source>For integer types, exact equality is used, in the same way as &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e54c6af26706ff283ff28256c72b54eb26fbc6b" translate="yes" xml:space="preserve">
          <source>For integers, the fill value will be different in general to the result of &lt;code&gt;masked_equal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d049cee37488c14a6b5c65b1da77ab9e42f2daa" translate="yes" xml:space="preserve">
          <source>For matrices that are not square or that (for negative powers) cannot be inverted numerically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="582e5fdc5986730f5cfb2129f1c085cdd20f4ef0" translate="yes" xml:space="preserve">
          <source>For monotonically _increasing_ &lt;code&gt;bins&lt;/code&gt;, the following are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83fdf15871a7264e4f60e9ab78a977dea92e1a03" translate="yes" xml:space="preserve">
          <source>For more detailed documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ae37abcab4e25dbfe5d8b108d91993462a8cf5" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.random.mtrand.randomstate.set_state#numpy.random.mtrand.RandomState.set_state&quot;&gt;&lt;code&gt;set_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7f38b00189236c28757faab4aba491a5544afa" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;code&gt;linalg.lstsq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f4a148b39366545cf97da19167eb00139c5efc" translate="yes" xml:space="preserve">
          <source>For more information on the qr factorization, see for example: &lt;a href=&quot;https://en.wikipedia.org/wiki/QR_factorization&quot;&gt;https://en.wikipedia.org/wiki/QR_factorization&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3985651be63157e0b3fd0f006d48347a4d4ad484" translate="yes" xml:space="preserve">
          <source>For more information, a way to suppress the warning, and an example of &lt;a href=&quot;#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; being issued, see &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4cae020b6b04928ab8186f1d73c1c26eba4002" translate="yes" xml:space="preserve">
          <source>For more information, refer to the &lt;a href=&quot;../index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; module and examine the methods and attributes of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32b573b8f00ce30b3419ec834d75448d214948d" translate="yes" xml:space="preserve">
          <source>For negative numbers, if width is not given, a minus sign is added to the front. If width is given, the two&amp;rsquo;s complement of the number is returned, with respect to that width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2721282deb17b4500d92138a510cdb4754bcd3" translate="yes" xml:space="preserve">
          <source>For operations which are either not commutative or not associative, doing a reduction over multiple axes is not well-defined. The ufuncs do not currently raise an exception in this case, but will likely do so in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce08ac0d595dc1fc36977f113db0494cd013706" translate="yes" xml:space="preserve">
          <source>For other keyword-only arguments, see the &lt;a href=&quot;../ufuncs#ufuncs-kwargs&quot;&gt;ufunc docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c08ef249ec6e440d6a8f4e999cc7fb84e271c54" translate="yes" xml:space="preserve">
          <source>For our example, we&amp;rsquo;ll create a sum of squares function. To start, let&amp;rsquo;s implement this function in straightforward Python. We want to support an &amp;lsquo;axis&amp;rsquo; parameter similar to the numpy &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; function, so we will need to construct a list for the &lt;code&gt;op_axes&lt;/code&gt; parameter. Here&amp;rsquo;s how this looks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e34004cd49470f698985ea088603e79d6737af" translate="yes" xml:space="preserve">
          <source>For pickling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d056f2d6dc25af69ffd36f748681cb1b37bcb7" translate="yes" xml:space="preserve">
          <source>For positive integers &lt;code&gt;n&lt;/code&gt;, the power is computed by repeated matrix squarings and matrix multiplications. If &lt;code&gt;n == 0&lt;/code&gt;, the identity matrix of the same shape as M is returned. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, the inverse is computed and then raised to the &lt;code&gt;abs(n)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2868f608509a0fb880318bfa1ea537e24b697cca" translate="yes" xml:space="preserve">
          <source>For private use, NumPy also constructs a &lt;code&gt;config.h&lt;/code&gt; in the NumPy include directory, which is not exported by NumPy (that is a python extension which use the numpy C API will not see those symbols), to avoid namespace pollution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cba0cef0ecc3bf15466cf0b613737ac43d7cf46" translate="yes" xml:space="preserve">
          <source>For random samples from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b14ea0275a3817032fbdd7fbc1e7bdb06b2af67" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f985096374044eb3c8f423921e1ca43a25a0a64a" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd6dae91050b378f422d64d0fd3d06caee7dc76" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arcsinh&quot;&gt;&lt;code&gt;arcsinh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it returns &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a3e2a79ac88302cd49ced01b5ae36cb593f786" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e59a4a7e10620a1dcf06247438f5e136a0933eb" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00463e3d9bf72a8660310a707c972e6c6b2f2a87" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd401d005377ef79add082427bec36bd76d7d40" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c562bcbaf668e2b82c801663121e7d15eaaa37" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb65926ba3df7c570cfbf88879b3b9d563294100" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a691d6f039d37de2f424c2292fd24a2e8849ab5" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;em&gt;arcsin&lt;/em&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8dda629e47802177efe000a2d093f5e016a0cb" translate="yes" xml:space="preserve">
          <source>For real-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is accurate also for &lt;code&gt;x&lt;/code&gt; so small that &lt;code&gt;1 + x == 1&lt;/code&gt; in floating-point accuracy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8718e777159adb99e6030aa86f73aaa6419d14ea" translate="yes" xml:space="preserve">
          <source>For repeatability and readability, the dictionary keys are sorted in alphabetic order. This is for convenience only. A writer SHOULD implement this if possible. A reader MUST NOT depend on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd239911d468099089301c7ec88d5d1667469b6" translate="yes" xml:space="preserve">
          <source>For reshape, resize, and transpose, the single tuple argument may be replaced with &lt;code&gt;n&lt;/code&gt; integers which will be interpreted as an n-tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe957d6ccb5cf28dddb483265ed8d862961930a" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22863dbfbfce9a1b2c0c06d8e441eed6ee432e4b" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value. For non-scalar array &lt;code&gt;a&lt;/code&gt;, returns the vector&amp;rsquo;s dtype unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5642e4133974cc82494c6e2e1a04d4f6b4435c53" translate="yes" xml:space="preserve">
          <source>For several methods, an optional &lt;em&gt;out&lt;/em&gt; argument can also be provided and the result will be placed into the output array given. The &lt;em&gt;out&lt;/em&gt; argument must be an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and have the same number of elements. It can have a different data type in which case casting will be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0753b0fcbeca94ce7630240e047138c854a65dd" translate="yes" xml:space="preserve">
          <source>For signed integer inputs, the two&amp;rsquo;s complement is returned. In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#rde927b304c4f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1790f111eccdfcb9badd8e72bbfbae78adf5ee18" translate="yes" xml:space="preserve">
          <source>For standard library functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58c1a1b97b83acb57ac2ac307ed0d7c16b3baf7" translate="yes" xml:space="preserve">
          <source>For structured arrays, all fields are combined, with masked values ignored. The result is masked if all fields were masked, with self and other considered equal only if both were fully masked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b403ec15e745ce9b0d408a4253b0a3db036c37" translate="yes" xml:space="preserve">
          <source>For structured types, a structured scalar is returned, with each field the default fill value for its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0b7d9c35a991bbf7b4be3304607a91761fd2e6" translate="yes" xml:space="preserve">
          <source>For subarray types, the fill value is an array of the same size containing the default scalar fill value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1668cc4f1ad2127afa574513a965e4f8de0bd1" translate="yes" xml:space="preserve">
          <source>For tall matrices in NumPy version up to 1.6.2, the diagonal &amp;ldquo;wrapped&amp;rdquo; after N columns. You can have this behavior with this option. This affects only tall matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e3d7bba1f8f57e3e3d0698a1673d2f7dbd0218" translate="yes" xml:space="preserve">
          <source>For the first run, we threw 3 times 1, 4 times 2, etc. For the second, we threw 2 times 1, 4 times 2, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f9e5e8e38fa061436e99d12c2a915135e47ac9" translate="yes" xml:space="preserve">
          <source>For the following methods there are also corresponding functions in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;generated/numpy.all#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.any#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmax#numpy.argmax&quot;&gt;&lt;code&gt;argmax&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmin#numpy.argmin&quot;&gt;&lt;code&gt;argmin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.choose#numpy.choose&quot;&gt;&lt;code&gt;choose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.clip#numpy.clip&quot;&gt;&lt;code&gt;clip&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.compress#numpy.compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumprod#numpy.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumsum#numpy.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.diagonal#numpy.diagonal&quot;&gt;&lt;code&gt;diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.imag#numpy.imag&quot;&gt;&lt;code&gt;imag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amax#numpy.amax&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.partition#numpy.partition&quot;&gt;&lt;code&gt;partition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.prod#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ptp#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.put#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ravel#numpy.ravel&quot;&gt;&lt;code&gt;ravel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.real#numpy.real&quot;&gt;&lt;code&gt;real&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.repeat#numpy.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.around#numpy.around&quot;&gt;&lt;code&gt;round&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.squeeze#numpy.squeeze&quot;&gt;&lt;code&gt;squeeze&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.std#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.swapaxes#numpy.swapaxes&quot;&gt;&lt;code&gt;swapaxes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.var#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f398fd04d9f322afdba477002ec5cde7b5d2d1b" translate="yes" xml:space="preserve">
          <source>For the general case, the iteration works by keeping track of a list of coordinate counters in the iterator object. At each iteration, the last coordinate counter is increased (starting from 0). If this counter is smaller than one less than the size of the array in that dimension (a pre-computed and stored value), then the counter is increased and the dataptr member is increased by the strides in that dimension and the macro ends. If the end of a dimension is reached, the counter for the last dimension is reset to zero and the dataptr is moved back to the beginning of that dimension by subtracting the strides value times one less than the number of elements in that dimension (this is also pre-computed and stored in the backstrides member of the iterator object). In this case, the macro does not end, but a local dimension counter is decremented so that the next-to-last dimension replaces the role that the last dimension played and the previously-described tests are executed again on the next-to-last dimension. In this way, the dataptr is adjusted appropriately for arbitrary striding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a106ff191577f5e49df4ba4a5b92a5dff872216c" translate="yes" xml:space="preserve">
          <source>For the most part, the rules for dispatch with &lt;code&gt;__array_function__&lt;/code&gt; match those for &lt;code&gt;__array_ufunc__&lt;/code&gt;. In particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aabe002787ac5ab3c2a4862f3aa6c788cd300e2" translate="yes" xml:space="preserve">
          <source>For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that can be directly interpreted as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3c40fa5c98be8aa15b70b390891bf28a170212" translate="yes" xml:space="preserve">
          <source>For these reasons it is advisable to avoid &lt;code&gt;as_strided&lt;/code&gt; when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb33fc8c29e1bd562bffb815c2697c66a036bae2" translate="yes" xml:space="preserve">
          <source>For these reasons, NumPy provides an API to work with npy_half values accessible by including &amp;lt;numpy/halffloat.h&amp;gt; and linking to &amp;lsquo;npymath&amp;rsquo;. For functions that are not provided directly, such as the arithmetic operations, the preferred method is to convert to float or double and back again, as in the following example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b0d8b34011752e4113aaa6a6fce2b3c78d19e5" translate="yes" xml:space="preserve">
          <source>For this function to work on sub-classes of ndarray, they must define &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; with the kwarg &lt;code&gt;keepdims&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b38cff3c38a7296ea244a6f149ab3fa89299cb" translate="yes" xml:space="preserve">
          <source>For this reason, it is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.apply_along_axis#numpy.apply_along_axis&quot;&gt;&lt;code&gt;apply_along_axis&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bbee921f7bbec73ea6da64c3957049942fe48c" translate="yes" xml:space="preserve">
          <source>For this sample array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef360ecaea0bceb4141bc860c62269adcea43126" translate="yes" xml:space="preserve">
          <source>For two dimensional arrays, the return will be two arrays ordered by axis. In this example the first array stands for the gradient in rows and the second one in columns direction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5688be18895d1ed44e4e4ac9ea5a009f3d8f644d" translate="yes" xml:space="preserve">
          <source>For ufuncs dynamically created from python functions, this member holds a reference to the underlying Python function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51d3a13e3a61d2cfd5f82478bfc77249b90c3e8" translate="yes" xml:space="preserve">
          <source>For ufuncs, it is hoped to eventually deprecate this method in favour of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fec4c12c09d2caf632487f32e741d15fde50a70" translate="yes" xml:space="preserve">
          <source>For unpickling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a617d92aada34c5b1b91d32c80426c8f059f29" translate="yes" xml:space="preserve">
          <source>For unsigned integer arrays, the results will also be unsigned. This should not be surprising, as the result is consistent with calculating the difference directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b61801e49c04aeb574dfd6c0384db9e70e2d05c" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#r0933ec43c7c9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f7c1942ce335813533514ab6d97be522e99c17" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;, this flag disables allocating an array subtype for the output, forcing it to be a straight ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f63cfae8856e0c1b4c745d806a5044a1d2050ad" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f0a5ecb33fee954cb51300dbd6244641e9062e" translate="yes" xml:space="preserve">
          <source>For values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due to the inexact representation of decimal fractions in the IEEE floating point standard &lt;a href=&quot;#r907366b089c1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; and errors introduced when scaling by powers of ten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8df8eb2541671de725aa87916abd483ac03487" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;ord &amp;lt;= 0&lt;/code&gt;, the result is, strictly speaking, not a mathematical &amp;lsquo;norm&amp;rsquo;, but it may still be useful for various numerical purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c5fe59c42bb96e8794f338a14a9afba25af3e6" translate="yes" xml:space="preserve">
          <source>For vectors (1-D arrays) it computes the ordinary inner-product:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31afbaa8abd3ce58c5bf83aec637268a269a63d" translate="yes" xml:space="preserve">
          <source>For vectors &lt;code&gt;x1&lt;/code&gt;, &lt;code&gt;x2&lt;/code&gt;,&amp;hellip;, &amp;lsquo;xn&amp;rsquo; with lengths &lt;code&gt;Ni=len(xi)&lt;/code&gt; , return &lt;code&gt;(N1, N2, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;ij&amp;rsquo; or &lt;code&gt;(N2, N1, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;xy&amp;rsquo; with the elements of &lt;code&gt;xi&lt;/code&gt; repeated to fill the matrix along the first dimension for &lt;code&gt;x1&lt;/code&gt;, the second for &lt;code&gt;x2&lt;/code&gt; and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6242c0a79a41aa81490f6fd1ec86280110a2af" translate="yes" xml:space="preserve">
          <source>Force a cast to the output type even if it cannot be done safely. Without this flag, a data cast will occur only if it can be done safely, otherwise an error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ec8aad2bec1b3220d7b727c3bf434f0d55bc18" translate="yes" xml:space="preserve">
          <source>Force the mask to hard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0355317a1ab931fccb7ea5788f7a01c8683490" translate="yes" xml:space="preserve">
          <source>Force the mask to soft.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e07bf1dcba4f22fb0998d98afd707eecb583d3" translate="yes" xml:space="preserve">
          <source>Format Version 1.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5ba690bca66f9b43bf7dce492a8ecc14116342" translate="yes" xml:space="preserve">
          <source>Format Version 2.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d476621018ad05f5efc66b66f9628e71614d77b" translate="yes" xml:space="preserve">
          <source>Format Version 3.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082aa72e2e80659bc0dafa9d8a6a53207113bd45" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in positional notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ec1825c81674406abf9c065439398606f8e9c4" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in scientific notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba865544cbf6ad122958e97b9cb7e6ee2fca0ce" translate="yes" xml:space="preserve">
          <source>Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using &amp;ldquo;format&amp;rdquo; % item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a92b78c74fdad3772b95c0bef006808c6f5062" translate="yes" xml:space="preserve">
          <source>Fornberg B. (1988) Generation of Finite Difference Formulas on Arbitrarily Spaced Grids, Mathematics of Computation 51, no. 184 : 699-706. &lt;a href=&quot;http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b756e1ed184faeae9981dd9378f750e8c6c0e04f" translate="yes" xml:space="preserve">
          <source>Fortran files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="443b7dd908046f637f8adbdcefe50ee302b6f087" translate="yes" xml:space="preserve">
          <source>Fortran order if all the inputs are Fortran, C otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dbb13a4208640c43e953aa1ecfe0492f9b453d1" translate="yes" xml:space="preserve">
          <source>Fortran order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa529d42774f0768730f12bc0880f9965a988000" translate="yes" xml:space="preserve">
          <source>Forward bytes from a subprocess call to the console, without attempting to decode them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2982346b57dba0536f8cd38d08e71e22e03b5068" translate="yes" xml:space="preserve">
          <source>Four values of the output are invalid: the first one comes from taking the square root of a negative number, the second from the division by zero, and the last two where the inputs were masked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f163a620e6be53409bc7d6c8a56980a06cc8552e" translate="yes" xml:space="preserve">
          <source>Fourier analysis is fundamentally a method for expressing a function as a sum of periodic components, and for recovering the function from those components. When both the function and its Fourier transform are replaced with discretized counterparts, it is called the discrete Fourier transform (DFT). The DFT has become a mainstay of numerical computing in part because of a very fast algorithm for computing it, called the Fast Fourier Transform (FFT), which was known to Gauss (1805) and was brought to light in its current form by Cooley and Tukey &lt;a href=&quot;#rfb1dc64dd6a5-ct&quot; id=&quot;id1&quot;&gt;[CT]&lt;/a&gt;. Press et al. &lt;a href=&quot;#rfb1dc64dd6a5-nr&quot; id=&quot;id2&quot;&gt;[NR]&lt;/a&gt; provide an accessible introduction to Fourier analysis and its applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55427a60a4bc7584f941291fc8f1c78e3b48892c" translate="yes" xml:space="preserve">
          <source>Fourteen C macros and fifteen C functions that can be used to write specialized typemaps, extensions, or inlined functions that handle cases not covered by the provided typemaps. Note that the macros and functions are coded specifically to work with the NumPy C/API regardless of NumPy version number, both before and after the deprecation of some aspects of the API after version 1.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55119325a9e50ab95a500e00074b97b1b9e36d5" translate="yes" xml:space="preserve">
          <source>Fractional part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef0af518168c89e00d0d671000eff79ef6d0866" translate="yes" xml:space="preserve">
          <source>Francis Hunt and Paul Johnson, On the Pareto Distribution of Sourceforge projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1702d7b8bdd07fbea0c5cab99e1759e69160609f" translate="yes" xml:space="preserve">
          <source>Frequency bins for given FFT parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7beab7a6d84d3a1004bcc75ccd72648a4866a0" translate="yes" xml:space="preserve">
          <source>Frobenius norm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb8d23120bc74b1cfb060aa5332c0996e661cf6" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449b24b6007276ad9bb465db2968bb8f2f82cb23" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91799328361ed7f1f3c997458139cffb3209540" translate="yes" xml:space="preserve">
          <source>From a 4x3 array the corner elements should be selected using advanced indexing. Thus all elements for which the column is one of &lt;code&gt;[0, 2]&lt;/code&gt; and the row is one of &lt;code&gt;[0, 3]&lt;/code&gt; need to be selected. To use advanced indexing one needs to select all elements &lt;em&gt;explicitly&lt;/em&gt;. Using the method explained previously one could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43663857b3b074086e6a5458d7eeb8cc710716c" translate="yes" xml:space="preserve">
          <source>From a date and time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27ac815b804369e0e908095a8f60fb839b9ffbc" translate="yes" xml:space="preserve">
          <source>From an array, select all rows which sum up to less or equal two:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b1e37af40ab4883a1e4a8a3dc83bcc94bb649dc" translate="yes" xml:space="preserve">
          <source>From each row, a specific element should be selected. The row index is just &lt;code&gt;[0, 1, 2]&lt;/code&gt; and the column index specifies the element to choose for the corresponding row, here &lt;code&gt;[0, 1, 0]&lt;/code&gt;. Using both together the task can be solved using advanced indexing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bdc929241ee7611d7ce8654d5c0e7a97c5922e2" translate="yes" xml:space="preserve">
          <source>From existing data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7dc9b3626b3cb541c458a7c7758c637090adb4" translate="yes" xml:space="preserve">
          <source>From other objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dce71950093c2ccd6198a0075dc3e5ee84cb7ec" translate="yes" xml:space="preserve">
          <source>From scratch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6cd09bf0f40761ab28ccaa4cab2a4c6c336752" translate="yes" xml:space="preserve">
          <source>Full indirect sort</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d106cfe968d6ee1cdc60bee01550735688b85f7" translate="yes" xml:space="preserve">
          <source>Full sort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733bce60654becd4d4e1700d743ab7573d5f2742" translate="yes" xml:space="preserve">
          <source>Full sorting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fafc2ca93d61a962accac1563a05d9b48e0a23a" translate="yes" xml:space="preserve">
          <source>Function decorator to apply certain suppressions to a whole function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6611eada8817f5f656a38dbcf1f891cb71be30b3" translate="yes" xml:space="preserve">
          <source>Function operating on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb4f2de4dfb1639014358c3b7015d9c6a5f5d6b" translate="yes" xml:space="preserve">
          <source>Function pointer from &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636b3b392dcabee45d972282bc714f124a2984ee" translate="yes" xml:space="preserve">
          <source>Function that converts a float array to float. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. Note that this does not seem to do anything useful in the current implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f491198ced438a979dee0c06f7b99f4c27522c" translate="yes" xml:space="preserve">
          <source>Function that converts a float or float array to an integer or integer array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c65cb38bc5533518bfad836c738613691b12bd" translate="yes" xml:space="preserve">
          <source>Function that converts a single float to a string. Default is &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e035248ad61f94c49b3411ced40a15d03e994b" translate="yes" xml:space="preserve">
          <source>Function that converts an integer or integer array to a float or float array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdbff65d2dcd6dbb1f176839d343d5cd6740b77" translate="yes" xml:space="preserve">
          <source>Function to be used to pretty print arrays. The function should expect a single array argument and return a string of the representation of the array. If None, the function is reset to the default NumPy function to print arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5428e59d421faf071ea47a590fb561ece5a39d" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecfa9e590ef0d3ed65da85a7cdda1af66b824ea3" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3daae79264ded053c68caf5a77aad1db49558306" translate="yes" xml:space="preserve">
          <source>Function to call upon floating-point errors (&amp;lsquo;call&amp;rsquo;-mode) or object whose &amp;lsquo;write&amp;rsquo; method is used to log such message (&amp;lsquo;log&amp;rsquo;-mode).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936e3c682ce34cc0f0f7b3b6776919fc933d5fe1" translate="yes" xml:space="preserve">
          <source>Function which returns a masked inner loop for the ufunc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb4e042b9d6249db97e6680ab8276b237985bd9" translate="yes" xml:space="preserve">
          <source>Functional programming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a31942f8f4b1c24c2cf2f6e11f8f96977c918a6" translate="yes" xml:space="preserve">
          <source>Functions For Iteration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7916ccc48b7ce0f25ff69e01c25e39ce11de03b" translate="yes" xml:space="preserve">
          <source>Functions implementing internal features. Not all of these function pointers must be defined for a given type. The required members are &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;setitem&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;cast&lt;/code&gt;. These are assumed to be non- &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;NULL&lt;/code&gt; entries will cause a program crash. The other functions may be &lt;code&gt;NULL&lt;/code&gt; which will just mean reduced functionality for that data-type. (Also, the nonzero function will be filled in with a default function if it is &lt;code&gt;NULL&lt;/code&gt; when you register a user-defined data-type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786d8b1defa125829799bc249caf1adda1184b6a" translate="yes" xml:space="preserve">
          <source>Functions returning an index along an axis, like &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, produce suitable indices for this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7961218e053edec8b5fc62ef3005af10a3415803" translate="yes" xml:space="preserve">
          <source>Functions that are also in the numpy namespace and return matrices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da76886d65d87e4650f5c14ec791f8c2f676112" translate="yes" xml:space="preserve">
          <source>Further explanation of the &lt;code&gt;fmt&lt;/code&gt; parameter (&lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad9659f7e2980db9b405ad20b3c5294ccc96416" translate="yes" xml:space="preserve">
          <source>Further, note how &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are combined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af0aaaf4de03972531671e0eb9bb87000ba4e1d" translate="yes" xml:space="preserve">
          <source>Furthermore, arrays created with this function often contain self overlapping memory, so that two elements are identical. Vectorized write operations on such arrays will typically be unpredictable. They may even give different results for small, large, or transposed arrays. Since writing to these arrays has to be tested and done with great care, you may want to use &lt;code&gt;writeable=False&lt;/code&gt; to avoid accidental write operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f84a7ca85b2fada9bdf949e608abf006366bb0e" translate="yes" xml:space="preserve">
          <source>Furthermore, the callback function is of the same type as before, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt;. When invoked, &lt;code&gt;args&lt;/code&gt; is a list of length &lt;code&gt;nargs&lt;/code&gt; containing the data of all input/output arguments. For a scalar elementary function, &lt;code&gt;steps&lt;/code&gt; is also of length &lt;code&gt;nargs&lt;/code&gt;, denoting the strides used for the arguments. &lt;code&gt;dimensions&lt;/code&gt; is a pointer to a single integer defining the size of the axis to be looped over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7285e0cef5e4daf805eb913ea140d9a03dc8d07" translate="yes" xml:space="preserve">
          <source>Future value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d44fa727f9b3f4d912a98a3e170b462f52557e6" translate="yes" xml:space="preserve">
          <source>Future value (default = 0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4092807d491bea64803fff0c7e477eac372847" translate="yes" xml:space="preserve">
          <source>Future values. If all input is scalar, returns a scalar float. If any input is array_like, returns future values for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f44d78e0bf8d58385fdcde50f5d5e7baff3d944" translate="yes" xml:space="preserve">
          <source>G. H. Golub and C. F. Van Loan, &lt;em&gt;Matrix Computations&lt;/em&gt;, Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd53064adb7ff38d27c336291f9eaba7270aacd" translate="yes" xml:space="preserve">
          <source>G. Strang, &amp;ldquo;Linear Algebra and Its Applications, 2nd Edition,&amp;rdquo; Academic Press, pg. 182, 1980.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fee945837fcad5efdf449e24366c4e1f7b65d37" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, Various pp.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d62050a6efa830b0646c86cf65d2a276c097206" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5685424a4a906ee371dfacdea6a5b47dc7b3ff" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 222.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db937a0ed23b9cf712fadda8ce2d53e90fb3fb34" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pp. 139-142.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d923f5047de7db54bb0494345e02c3e60011f631" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, Orlando, FL, Academic Press, Inc., 1980, pg. 285.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a5e73fba8665db50a8e3577ecf8eb28b80e421" translate="yes" xml:space="preserve">
          <source>Gammas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027498996e260dbd9c33778f3168019dfde3d4cc" translate="yes" xml:space="preserve">
          <source>Gauss-Chebyshev quadrature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372d4c8be97b59c2965354454eaf80e844e74e50" translate="yes" xml:space="preserve">
          <source>Gauss-Hermite quadrature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90aa100cf157ec594ce20f650ca9a1d9019f03be" translate="yes" xml:space="preserve">
          <source>Gauss-HermiteE quadrature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d10f081127b50e1f17e0a5c3971976017840cbe" translate="yes" xml:space="preserve">
          <source>Gauss-Laguerre quadrature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f1f37c698b12eaffdc9bbccbc77d8b6246ccd8" translate="yes" xml:space="preserve">
          <source>Gauss-Legendre quadrature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d731fc16d10c539de3eb06ab7ca854e8f4dd60e" translate="yes" xml:space="preserve">
          <source>General check of Python Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b31f308f2ce85a33700b95c3da21fcb018ed716" translate="yes" xml:space="preserve">
          <source>General purpose exception class, derived from Python&amp;rsquo;s exception.Exception class, programmatically raised in linalg functions when a Linear Algebra-related condition would prevent further correct execution of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5d5977ff7dabeb26104f13133251775857ac24" translate="yes" xml:space="preserve">
          <source>Generalised matrix product, using second last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9332c2d546d63dda92dba61cafe3df82f0dd8b19" translate="yes" xml:space="preserve">
          <source>Generalized Universal Function API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b50941190dd87fa655dc29ac5df20dd7d7c66f" translate="yes" xml:space="preserve">
          <source>Generalized function class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a042cdeb42f3ae672017ab4c672646772ccf00" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is &lt;code&gt;None&lt;/code&gt;, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96ae300222cf76379f354819a4df06d3fbfa490" translate="yes" xml:space="preserve">
          <source>Generalized universal function signature, e.g., &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; for vectorized matrix-vector multiplication. If provided, &lt;code&gt;pyfunc&lt;/code&gt; will be called with (and expected to return) arrays with shapes given by the size of corresponding core dimensions. By default, &lt;code&gt;pyfunc&lt;/code&gt; is assumed to take scalars as input and output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b3bfe4a96aaf1f0210aadbf43dc393e3a362c6" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;code&gt;Configuration&lt;/code&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba56532a4a3fb8146e876e1d3659dfdac724a189" translate="yes" xml:space="preserve">
          <source>Generate a 1 by 3 array with 3 different lower bounds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3724c74e69c85b7924eab36b9e17078ea85e817c" translate="yes" xml:space="preserve">
          <source>Generate a 1 x 3 array with 3 different upper bounds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78b4920f6305013e33283131f3991e4d5dda157" translate="yes" xml:space="preserve">
          <source>Generate a 2 by 4 array using broadcasting with dtype of uint8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ec8bca285ae5da030ea4680d276692f61c3804" translate="yes" xml:space="preserve">
          <source>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e541c44f7aa5d7ed7acb09f3c0fe019e268af5e" translate="yes" xml:space="preserve">
          <source>Generate a Chebyshev series with given roots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c791c1439e16e2fd0efb50c6644249b5b3eebb5" translate="yes" xml:space="preserve">
          <source>Generate a Hermite series with given roots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd121a27d585c3734742539ee143a52ac9b73de" translate="yes" xml:space="preserve">
          <source>Generate a HermiteE series with given roots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d697582320e7c884bbfd6a03995e4b278f2c74" translate="yes" xml:space="preserve">
          <source>Generate a Laguerre series with given roots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd152ea5ebdb08e6cd481a5737f68bdf9d18ad6" translate="yes" xml:space="preserve">
          <source>Generate a Legendre series with given roots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67cead80b0965ee4736c5f23fba251df4f3ebe37" translate="yes" xml:space="preserve">
          <source>Generate a Vandermonde matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b901c2336926f254f07d1ab7b60e0386e5b58c" translate="yes" xml:space="preserve">
          <source>Generate a monic polynomial with given roots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e173a5f3c2204af8ef7b9a77d34afee8c360a27" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b032abdb8bc3ee596986f951aad13aeb29eff03" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ecb4243c3f96a98ea55b6a9b74781792dce996" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7e8cdcfbc5d1d81d3a8108edeaf14a80335951" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382b425e693319395299c741c143ce2398939efe" translate="yes" xml:space="preserve">
          <source>Generate and install a npy-pkg config file from a template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a90f1dba170779ac0befe5afd3d6d9c884c6d1" translate="yes" xml:space="preserve">
          <source>Generate config.py file containing system_info information used during building the package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c49c62f8886e09ca6e64b9c96074bf60926d62" translate="yes" xml:space="preserve">
          <source>Generate package __config__.py file containing system_info information used during building the package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14952923eed9a754d36fbf7d9df88e59880c6dad" translate="yes" xml:space="preserve">
          <source>Generate package __svn_version__.py file from SVN revision number, it will be removed after python exits but will be available when sdist, etc commands are executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd9212c9f1d53d55d853a3b264e1b6b858f35fd" translate="yes" xml:space="preserve">
          <source>Generates a random sample from a given 1-D array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150ce9aa76a74d0a43ead917a8c785193ed877b1" translate="yes" xml:space="preserve">
          <source>Generating index arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb174c2f425e0d1a36b6da19833f5708052f5b2" translate="yes" xml:space="preserve">
          <source>Generator.beta()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c54211367d38fc1c657f1a2b11682aa7073f8a0" translate="yes" xml:space="preserve">
          <source>Generator.binomial()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d222082a3e85bc085f3813830709c1091b870201" translate="yes" xml:space="preserve">
          <source>Generator.bit_generator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf1aa45703830ef34744bdb91c5ee84eb339af2" translate="yes" xml:space="preserve">
          <source>Generator.bytes()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e223f39e59656efb6dcd2b450fd1f3d11e0f5b" translate="yes" xml:space="preserve">
          <source>Generator.chisquare()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2cf011c29fcb364a340b0b0739ed3940f0415ce" translate="yes" xml:space="preserve">
          <source>Generator.choice()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb19d66e8b5e00bd8ab9eaa938d00f3718515fe" translate="yes" xml:space="preserve">
          <source>Generator.dirichlet()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c841ae15f138b1059c14b8ebc34f2ceb6506da" translate="yes" xml:space="preserve">
          <source>Generator.exponential()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb6ee1b51ecd1875248d0ca388e0fb1daabb181" translate="yes" xml:space="preserve">
          <source>Generator.f()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5544f1f1d846a0215be8277752788b52f5d5ae" translate="yes" xml:space="preserve">
          <source>Generator.gamma()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb698152656074b26c2b514594b6841ba98646e0" translate="yes" xml:space="preserve">
          <source>Generator.geometric()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe271ee0cdf14a0b127e97b8a754332b21122bf" translate="yes" xml:space="preserve">
          <source>Generator.gumbel()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb4c4773f6c2e362f6bdc12b4738edbd30f23d2" translate="yes" xml:space="preserve">
          <source>Generator.hypergeometric()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50dbdf77399f33f0754452bd827d7d9972e1f6e" translate="yes" xml:space="preserve">
          <source>Generator.integers()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac6ee43d1992ed473a404e92103ad981ee56dd8" translate="yes" xml:space="preserve">
          <source>Generator.laplace()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a01e0244542efabb99865e59014bd47d50fe182" translate="yes" xml:space="preserve">
          <source>Generator.logistic()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c320801600fb9c31cc3d790a76584f303a266f0d" translate="yes" xml:space="preserve">
          <source>Generator.lognormal()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2133a52d0f531222ffd5b10595265bd407d65eae" translate="yes" xml:space="preserve">
          <source>Generator.logseries()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb5b968b7c3c6e4334e366ce81b7d1c72dd0587" translate="yes" xml:space="preserve">
          <source>Generator.multinomial()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee77530caf29c96157f8b247c28bc2729509bc1f" translate="yes" xml:space="preserve">
          <source>Generator.multivariate_normal()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4accfbbf5411ba4e6ed6190c6c4a4f347889476" translate="yes" xml:space="preserve">
          <source>Generator.negative_binomial()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c86d9e1ec54b1f6ceef69c6b35acbc51980bb9" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_chisquare()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffb9eb22957bfe4ccb8d5eb67072da9ed2c8fe8" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_f()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155766b36ed963438beae39d25dc848285e67bec" translate="yes" xml:space="preserve">
          <source>Generator.normal()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ff7a92707e2ef9f9f69eb28c0f2a89afd2fb30" translate="yes" xml:space="preserve">
          <source>Generator.pareto()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76efb5ddfe9997620fd07ade2a0e0cee44bb8c62" translate="yes" xml:space="preserve">
          <source>Generator.permutation()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a00012743deaf56311a785e2b3c42ad040930cb" translate="yes" xml:space="preserve">
          <source>Generator.poisson()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ebe8ebc29357762dc172bd7a50a6d2bbec0bbc0" translate="yes" xml:space="preserve">
          <source>Generator.power()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760d539be436a9fd5786ef5406b94bdadd320519" translate="yes" xml:space="preserve">
          <source>Generator.random()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe55f2eb5b58a57536abac4e6392ebd311bfe6e" translate="yes" xml:space="preserve">
          <source>Generator.rayleigh()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fff1d63fa4122d609dcfb229ec0499ef08a14a7" translate="yes" xml:space="preserve">
          <source>Generator.shuffle()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1634a618bfbc7c72035711945372ce07c3fe19" translate="yes" xml:space="preserve">
          <source>Generator.standard_cauchy()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34db4ce80b61d7d21ff61b89aa2d2d63aa910f5c" translate="yes" xml:space="preserve">
          <source>Generator.standard_exponential()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34031ad3432250f012a4d89407bba35b84a16c3c" translate="yes" xml:space="preserve">
          <source>Generator.standard_gamma()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87dab3cf1af1d204bcf4e1ac664f4ea0ea2557c9" translate="yes" xml:space="preserve">
          <source>Generator.standard_normal()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f906f6a0afddbf8cdbe07f5b8f0720c2656e3a0d" translate="yes" xml:space="preserve">
          <source>Generator.standard_t()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b2b3ce2c0360b1a89e482830d2d3c0cbab9581" translate="yes" xml:space="preserve">
          <source>Generator.triangular()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3025f762e986dfbed9abf7722d638afcbcac65" translate="yes" xml:space="preserve">
          <source>Generator.uniform()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41234839ae9e6c31f86b35be70f95dd2edfdb45f" translate="yes" xml:space="preserve">
          <source>Generator.vonmises()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524f7ff03bcd2538def6c2fcd08d18e053cd0a0d" translate="yes" xml:space="preserve">
          <source>Generator.wald()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d43ca17b95d21950576674e14eac05300d6600" translate="yes" xml:space="preserve">
          <source>Generator.weibull()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425fdb323ea262485eeead85528e77951596ac23" translate="yes" xml:space="preserve">
          <source>Generator.zipf()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5e162e441d1aa68e920c4da50498c7a00cc1ca" translate="yes" xml:space="preserve">
          <source>Generators: Objects that transform sequences of random bits from a BitGenerator into sequences of numbers that follow a specific probability distribution (such as uniform, Normal or Binomial) within a specified interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcca6d928c0647f440353ba62ca89c9a77b6389a" translate="yes" xml:space="preserve">
          <source>Generic Python-exception-derived object raised by linalg functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f5365cdbef14515226dcd384583192170cc525" translate="yes" xml:space="preserve">
          <source>Generic functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36687e3d4c6e89be61413141c9001bd1269ea61f" translate="yes" xml:space="preserve">
          <source>Generic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4725fc543850e19ff2039cda197dd7e9e18cc3b7" translate="yes" xml:space="preserve">
          <source>Get a Python object of a builtin type from the ndarray, &lt;em&gt;arr&lt;/em&gt;, at the location pointed to by itemptr. Return &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bba80c206cb8084a11e65d5dc5c897b6a8a686" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator as a 1-D array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e3ab2dfabd54e64b9ac5580bc305e9c24165dc" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator in its current state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b8e4a6c47eabed3fcd4c264f91d248484dbd8e" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27b9509ff4121a0e1b9f0986d9920de57d819f0" translate="yes" xml:space="preserve">
          <source>Get floating point status. Returns a bitmask with following possible flags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddfceaf39034459b039832aa5e0f88a5294c648e" translate="yes" xml:space="preserve">
          <source>Get help information for a function, class, or module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec25cf47cdd55b9b521bbdadbef69d3ea1d8e5a4" translate="yes" xml:space="preserve">
          <source>Get information about the step size of a date or time type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693a41351204b667429ed1f8f87172706e8b4a91" translate="yes" xml:space="preserve">
          <source>Get or set the PRNG state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c0240016b842d9be6c9625e5a572e040565a6a" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a74bcddcc3142595e265c6f91c54ba0941f6e3f" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields. For structured arrays, returns a ndarray of booleans where entries are &lt;code&gt;True&lt;/code&gt; if &lt;strong&gt;all&lt;/strong&gt; the fields are masked, &lt;code&gt;False&lt;/code&gt; otherwise:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ab6b2bea51cfebc1977ab8830dcd90e5d8f56d" translate="yes" xml:space="preserve">
          <source>Get resources information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d41ad59188f890aeb1ed8209e30d553a33f1536" translate="yes" xml:space="preserve">
          <source>Get the Python values used for ufunc processing from the thread-local storage area unless the defaults have been set in which case the name lookup is bypassed. The name is placed as a string in the first element of &lt;em&gt;*errobj&lt;/em&gt;. The second element is the looked-up function to call on error callback. The value of the looked-up buffer-size to use is passed into &lt;em&gt;bufsize&lt;/em&gt;, and the value of the error mask is placed into &lt;em&gt;errmask&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42cef4d77cbf66bab7c534b082e6107163dee92" translate="yes" xml:space="preserve">
          <source>Get the current way of handling floating-point errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695f3e243afdf261b45538304791ad040f8d34f0" translate="yes" xml:space="preserve">
          <source>Get the number of dimensions of an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b4332f0fd288d9a8660cb9b90eb2d70399cb30" translate="yes" xml:space="preserve">
          <source>Getitem/setitem/copyswap function: Similar to ufuncs, these functions generally have two code paths. If &lt;code&gt;ALIGNED&lt;/code&gt; is False they will use a code path that buffers the arguments so they are true-aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9042cc4b8d1c2a38a88090c5bbf827e249e726" translate="yes" xml:space="preserve">
          <source>Gets an array of strides which are fixed, or will not change during the entire iteration. For strides that may change, the value NPY_MAX_INTP is placed in the stride.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30fc1fed71b9648bc39ebe85c632c9c96d68765c" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; of the iterator, which is an index matching the iteration order of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9217aeddd13f7d6ea905e46252fcb27732c6211" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; sub-range that is being iterated. If &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt; was not specified, this always returns the range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29099a868ef51a061ab01f34d141a4b26e68b87" translate="yes" xml:space="preserve">
          <source>Gets the array of data pointers directly into the arrays (never into the buffers), corresponding to iteration index 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1880ff271cb91c83bb908e9bec8d5e682e13f9" translate="yes" xml:space="preserve">
          <source>Gets the array of strides for the specified axis. Requires that the iterator be tracking a multi-index, and that buffering not be enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcc80db035da4f014fe2b35abfcfb7fdf954c8c" translate="yes" xml:space="preserve">
          <source>Gets the bit generator instance used by the generator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a46b1f79c63a304cb32357fb767b2f9f13f63b7" translate="yes" xml:space="preserve">
          <source>Getting extra Fortran 77 compiler options from source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed2b47c2eb6fcb9566d8e5b338ef20c663258ac" translate="yes" xml:space="preserve">
          <source>Give a new shape to an array without changing its data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a577ea656c2f3aa2b8af6ec81a5f57008704a3bb" translate="yes" xml:space="preserve">
          <source>Give a new shape to the array without changing its data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5633a94c306e1317df951f106e430c35db17233f" translate="yes" xml:space="preserve">
          <source>Given a sequence of a polynomial&amp;rsquo;s zeros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc543f62ec648afbd60f8c46e36515054ff8b40" translate="yes" xml:space="preserve">
          <source>Given a sequence of arrays (&lt;em&gt;sort_keys&lt;/em&gt;) of the same shape, return an array of indices (similar to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;)) that would sort the arrays lexicographically. A lexicographic sort specifies that when two keys are found to be equal, the order is based on comparison of subsequent keys. A merge sort (which leaves equal entries unmoved) is required to be defined for the types. The sort is accomplished by sorting the indices first using the first &lt;em&gt;sort_key&lt;/em&gt; and then using the second &lt;em&gt;sort_key&lt;/em&gt; and so forth. This is equivalent to the lexsort(&lt;em&gt;sort_keys&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;) Python command. Because of the way the merge-sort works, be sure to understand the order the &lt;em&gt;sort_keys&lt;/em&gt; must be in (reversed from the order you would use when comparing two elements).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675ac4930884c9f7a3554ad9fd66c39834a06013" translate="yes" xml:space="preserve">
          <source>Given a set of conditions and corresponding functions, evaluate each function on the input data wherever its condition is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9104557d433ccbecbd40d5b471167b269afd4924" translate="yes" xml:space="preserve">
          <source>Given a shape of, for example, &lt;code&gt;(m,n,k)&lt;/code&gt;, &lt;code&gt;m*n*k&lt;/code&gt; samples are generated, and packed in an &lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt;-by-&lt;code&gt;k&lt;/code&gt; arrangement. Because each sample is &lt;code&gt;N&lt;/code&gt;-dimensional, the output shape is &lt;code&gt;(m,n,k,N)&lt;/code&gt;. If no shape is specified, a single (&lt;code&gt;N&lt;/code&gt;-D) sample is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd43bd0b568c4a20eb55e09b56aec26e4bcf57e8" translate="yes" xml:space="preserve">
          <source>Given a square array object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c727e55b5284efd4b0f949a20f79f07a731a7def" translate="yes" xml:space="preserve">
          <source>Given a square matrix &lt;code&gt;a&lt;/code&gt;, return the matrix &lt;code&gt;ainv&lt;/code&gt; satisfying &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3ba91f03af5d3e0b135a4d459d0b8c153beab2" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the &lt;code&gt;q&lt;/code&gt;-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1966cedf9ce61fd3a211e32f4abbb9573112f3e8" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11a60c1be0b2a1a4251da19f3ebb410f0917d80" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i.e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d76c2715df60bdab25092c54104462a6d39f23bb" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfd59ffc41fbed91404c5101ddfa184c5392006b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th quantile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the quantile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=0.5&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0.0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=1.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97afe1ab394be8a96329790e96c805504acf970b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; with &lt;code&gt;N&lt;/code&gt; non masked values, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt; (&lt;code&gt;Vs&lt;/code&gt;) - i.e. &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, or &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f958084a15b1cea997fb4f3882497b30e2d92da" translate="yes" xml:space="preserve">
          <source>Given a window length &lt;code&gt;n&lt;/code&gt; and a sample spacing &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf50be3014d334ce381b3182c6e22be99505ba7" translate="yes" xml:space="preserve">
          <source>Given an &amp;ldquo;index&amp;rdquo; array (&lt;code&gt;a&lt;/code&gt;) of integers and a sequence of &lt;code&gt;n&lt;/code&gt; arrays (&lt;code&gt;choices&lt;/code&gt;), &lt;code&gt;a&lt;/code&gt; and each choice array are first broadcast, as necessary, to arrays of a common shape; calling these &lt;em&gt;Ba&lt;/em&gt; and &lt;em&gt;Bchoices[i], i = 0,&amp;hellip;,n-1&lt;/em&gt; we have that, necessarily, &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; for each &lt;code&gt;i&lt;/code&gt;. Then, a new array with shape &lt;code&gt;Ba.shape&lt;/code&gt; is created as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="182d11d96136738a2da66eeca81246c173e18b8d" translate="yes" xml:space="preserve">
          <source>Given an array of integers and a set of n choice arrays, this method will create a new array that merges each of the choice arrays. Where a value in &lt;code&gt;a&lt;/code&gt; is i, the new array will have the value that choices[i] contains in the same place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37e450d620d60b14cee7269755ab57ba8f06da4" translate="yes" xml:space="preserve">
          <source>Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of &lt;code&gt;[0, 1]&lt;/code&gt; is specified, values smaller than 0 become 0, and values larger than 1 become 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e44e10395d6cbc3f11e11b2660a79eed5fd62a" translate="yes" xml:space="preserve">
          <source>Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, it&amp;rsquo;s rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d67e5173e989786e884148ab1ee5c292352200" translate="yes" xml:space="preserve">
          <source>Given the &amp;ldquo;legs&amp;rdquo; of a right triangle, return its hypotenuse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7a5a167593ffa963306f804bdee09ec39e8fd9" translate="yes" xml:space="preserve">
          <source>Given the shape of an array, an &lt;a href=&quot;#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; instance iterates over the N-dimensional index of the array. At each iteration a tuple of indices is returned, the last dimension is iterated over first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d84cece4ac6198159f79505d6fa6346cdc3c584" translate="yes" xml:space="preserve">
          <source>Given two &lt;em&gt;n&lt;/em&gt; -length arrays of integers, &lt;em&gt;l1&lt;/em&gt;, and &lt;em&gt;l2&lt;/em&gt;, return 1 if the lists are identical; otherwise, return 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d93ad7919330e367279622118fac9cd99eb66a" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of the first object are strictly smaller than those of the second object. An exception is raised at shape mismatch or incorrectly ordered values. Shape mismatch does not raise if an object has zero dimension. In contrast to the standard usage in numpy, NaNs are compared, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fdf131a8e234662a4baf7342d5cbfdd8815673" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c045ae56fa8df86b5ce72f657667f3cc594e54" translate="yes" xml:space="preserve">
          <source>Given two numbers, check that they are approximately equal. Approximately equal is defined as the number of significant digits that agree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d002c83204235df23caf3ec14f4354842036c7" translate="yes" xml:space="preserve">
          <source>Given two objects (scalars, lists, tuples, dictionaries or numpy arrays), check that all elements of these objects are equal. An exception is raised at the first conflicting values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d61f0f6669477d0eddf6043188e0f420dad8728" translate="yes" xml:space="preserve">
          <source>Given two polynomials &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt;, returns &lt;code&gt;a1 - a2&lt;/code&gt;. &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt; can be either array_like sequences of the polynomials&amp;rsquo; coefficients (including coefficients equal to zero), or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8737cb46ba6778426f460962013153a76a798f04" translate="yes" xml:space="preserve">
          <source>Given two tensors, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and an array_like object containing two array_like objects, &lt;code&gt;(a_axes, b_axes)&lt;/code&gt;, sum the products of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s elements (components) over the axes specified by &lt;code&gt;a_axes&lt;/code&gt; and &lt;code&gt;b_axes&lt;/code&gt;. The third argument can be a single non-negative integer_like scalar, &lt;code&gt;N&lt;/code&gt;; if it is such, then the last &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;a&lt;/code&gt; and the first &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;b&lt;/code&gt; are summed over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcbaa6d418fa3c95df027de6ff9d3bb5387a091" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3854728349ae7af32452ae7e4400a155448f9794" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ea28027215a4aa397564db3b7818bf4ec592b8" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4975cd64a92e88880758085eef7772db2bdb4f4d" translate="yes" xml:space="preserve">
          <source>Given:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8020f30b057521f3745170a52c99adab4537c734" translate="yes" xml:space="preserve">
          <source>Gives a new shape to an array without changing its data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6df81d1943f224253f7e8824d4f6d90b5a6fd6" translate="yes" xml:space="preserve">
          <source>Glantz, Stanton A. &amp;ldquo;Primer of Biostatistics.&amp;rdquo;, McGraw-Hill, Fifth Edition, 2002.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a7f06ad80d74e23ee701e64001d24ce844ca07" translate="yes" xml:space="preserve">
          <source>Gradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61aa58c2b09a3034acae73f52494d42574c0ca1c" translate="yes" xml:space="preserve">
          <source>Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0fcf87d2287941521d49f814fee6c705ce244c" translate="yes" xml:space="preserve">
          <source>Graphical illustration of &lt;code&gt;endpoint&lt;/code&gt; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4d80637c2066c9e7bffa72841d8f27a47b292b" translate="yes" xml:space="preserve">
          <source>Graphical illustration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d14a2a20cf23aef24c6cf5ba97cf49567e1739" translate="yes" xml:space="preserve">
          <source>Greedy &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (faster optimal path approximation): ~160ms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6534be852374768c36e7beef74b1f4199fef68a" translate="yes" xml:space="preserve">
          <source>Grid-shaped arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d291656cb315e59b3437432c3e771768a130826d" translate="yes" xml:space="preserve">
          <source>Group 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374327355d21f90b289f6f435aa2da5d797f0ae6" translate="yes" xml:space="preserve">
          <source>Group 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ac35811e25f377d3ea665e7f41177582e5b116" translate="yes" xml:space="preserve">
          <source>Guaranteeing safe aligned access for ufuncs/setitem/casting code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141d1d74d8a6b3e7a7f1418ef539a53ce746ef34" translate="yes" xml:space="preserve">
          <source>Guidelines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefaa04c360e4a9e3930a2840029cc9f56039f5f" translate="yes" xml:space="preserve">
          <source>Gumbel, E. J., &amp;ldquo;Statistics of Extremes,&amp;rdquo; New York: Columbia University Press, 1958.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c895f403bde1ed69e17f92c19862768cc5f5de8d" translate="yes" xml:space="preserve">
          <source>Half-precision functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636dbc8830ea645ecf6015e1f4a6dd1accda26f4" translate="yes" xml:space="preserve">
          <source>Handled by &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7178628eaa2183565412d3981a3508d31193d4b5" translate="yes" xml:space="preserve">
          <source>Handling complex numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210d84fcc7fb5c4b75800916312424c57f881c7b" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;fill_value&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e59976d95e4c0283fbcfa38c1a2f893c3bfd15d" translate="yes" xml:space="preserve">
          <source>Handling the mask</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78dcc8157bbf5d134fc488651952052da7016437" translate="yes" xml:space="preserve">
          <source>Hard-coded dimensions, data-buffer-then-dimensions specification, and dimensions-then-data-buffer specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfcf418a2bb124e6b8ce652d8bb7600c0be7269" translate="yes" xml:space="preserve">
          <source>Hardness of the mask</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a06e8ccba0be0394ad2df2eedd04a51d1a1039c5" translate="yes" xml:space="preserve">
          <source>Has no effect, do not use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4669500ffada7a9acbed3d1bf7fceec5a930f074" translate="yes" xml:space="preserve">
          <source>Has the same shape as &lt;code&gt;element&lt;/code&gt;. The values &lt;code&gt;element[isin]&lt;/code&gt; are in &lt;code&gt;test_elements&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7b6e9a18227e2359efe8c98f693affe997e690" translate="yes" xml:space="preserve">
          <source>Heckert, N. A. and Filliben, James J. &amp;ldquo;NIST Handbook 148: Dataplot Reference Manual, Volume 2: Let Subcommands and Library Functions&amp;rdquo;, National Institute of Standards and Technology Handbook Series, June 2003. &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334c16fc9ac63595f080f7bbcdf324a43ffd5267" translate="yes" xml:space="preserve">
          <source>Helper Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cffecba0fc696fb0b452757e50e8d2d6aa15660" translate="yes" xml:space="preserve">
          <source>Helper for pickle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0ce1fc0fa49364a15481aa8d6e74b5ad646a8c" translate="yes" xml:space="preserve">
          <source>Helper routines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2d508ec85c3c97b5a1229502e255e40023669a" translate="yes" xml:space="preserve">
          <source>Here are several examples of custom weekmask values. These examples specify the &amp;ldquo;busday&amp;rdquo; default of Monday through Friday being valid days.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc8d83645ead10353d3c11cd3d81d28f5fe4bc7" translate="yes" xml:space="preserve">
          <source>Here are some examples of signatures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcf4d32cc0d6364c8d8b907e9c3e1d6fd286f96" translate="yes" xml:space="preserve">
          <source>Here are the date units:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e64dc50ed3c98bebd079533bedfe8d3d04f0a87" translate="yes" xml:space="preserve">
          <source>Here is a conversion table for which functions to use with the new iterator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f499cb9c92d0a44a206fb77f5f29cb1c19da659" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
