<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="reactivex">
    <body>
      <group id="reactivex">
        <trans-unit id="8bb1a4880b71bbf96c77904b471633be02e4f575" translate="yes" xml:space="preserve">
          <source>&amp;copy; ReactiveX contributors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada27a33bf9c68fb3cbac205322beb072f9bf4a3" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectConcat&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;concatMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f33193ba4ed9e4a70c0886da9f44ed6474f4347" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectConcatObserver&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;concatMapObserver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011bbafe1b211deabe6d4d163f504bc37bba4438" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectMany&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="652d537945ac6e2a2be380a114ed6b84ec433624" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectManyObserver&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMapObserver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8858fe29d08b4ac07353302ff7337adc9c17e17e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectSwitch&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMapLatest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a182db8bfa5293706ee292aab892f1c223187092" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Hot&amp;rdquo; and &amp;ldquo;Cold&amp;rdquo; Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628e3c0ed13b486bb51f51ba494993cd92feca15" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;The Observable Contract,&amp;rdquo; which you may see referenced in various places in source documentation and in the pages on this site, is an attempt at a formal definition of an Observable, based originally on the 2010 document &lt;a href=&quot;https://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;&lt;cite&gt;Rx Design Guidelines&lt;/cite&gt;&lt;/a&gt; from Microsoft that described its Rx.NET implementation of ReactiveX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3064f51b892e08b0c317bd603ed6b1c5496873e8" translate="yes" xml:space="preserve">
          <source>(If, on the other hand, you want to append a sequence of items to the end of those normally emitted by an Observable, you want the &lt;a href=&quot;concat&quot;&gt;Concat&lt;/a&gt; operator.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d18aff50d4af9918043a17429ab9d8422faab7" translate="yes" xml:space="preserve">
          <source>(optional) a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; or an Observable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a49259eb5c4104d411ab272baaefc70db9d42e" translate="yes" xml:space="preserve">
          <source>(required) a function that accepts an item from the source Observable and returns its key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472fde8dfbd26d60ec634739e7c5baef720d6a9e" translate="yes" xml:space="preserve">
          <source>(required) a function that returns an Observable, the emissions from which trigger the termination of any open Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec0db89f0508beecc88e44a4f261c96a84f7a76" translate="yes" xml:space="preserve">
          <source>), you only use two methods to subscribe:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="d2f39249308876151e8d9b31ac981ad614b505db" translate="yes" xml:space="preserve">
          <source>. An Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ac4cc21e92b26c247d2d196cac30ab387310d2" translate="yes" xml:space="preserve">
          <source>. Then that observer reacts to whatever item or sequence of items the Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fe6dc75cfc49521ecb18667ffda03016ec73bf" translate="yes" xml:space="preserve">
          <source>. This pattern facilitates concurrent operations because it does not need to block while waiting for the Observable to emit objects, but instead it creates a sentry in the form of an observer that stands ready to react appropriately at whatever future time the Observable does so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">:</target>
        </trans-unit>
        <trans-unit id="b3bae60012f7a78cc91257251e629489a51994ea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;filtering-observables#wiki-first-and-takefirst&quot;&gt;&lt;code&gt;first( )&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;filtering-observables#wiki-take&quot;&gt;&lt;code&gt;take(1)&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.&lt;/code&gt;&lt;a href=&quot;observable-utility-operators#wiki-single-and-singleordefault&quot;&gt;&lt;code&gt;single( )&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59266734c85708062c27299be8478b239f26b4ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;filtering-observables#wiki-ignoreelements&quot;&gt;&lt;code&gt;ignoreElements( )&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;filtering-observables#wiki-filter&quot;&gt;&lt;code&gt;filter(alwaysFalse( ))&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4667e98d48cafefe965c6cfbbf931c271b1e90b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations.html&quot;&gt;Pitfalls of Operator Implementations (part 1)&lt;/a&gt; and &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;(part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e206efd342d6f311e4eaf22aa1dad1f1c530786a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/subjects-part-1.html&quot;&gt;Advanced RxJava: Subject&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f33eda1a69dd738f1849ddb4b492a4b2e5509d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html&quot;&gt;Advanced Reactive Java: SubscribeOn and ObserveOn&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e230c3946af5006280175d640abe4d4a13419ba5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/&quot;&gt;&lt;cite&gt;Grokking RxJava&lt;/cite&gt;: Operator, Operator&lt;/a&gt; by Dan Lew</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d0073935807280d0be6f71fbb272c064199c60" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/&quot;&gt;Loading data from multiple sources with RxJava&lt;/a&gt; by Dan Lew (example using Concat and First)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b0f482a744066f1f064e5f01147915d1aa0700" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2015/07/23/deferring-observable-code-until-subscription-in-rxjava/&quot;&gt;Deferring Observable code until subscription in RxJava&lt;/a&gt; by Dan Lew</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ca84472fb7904b99b27002018564cb5a4547cc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.joanzapata.com/experimentation-with-rx/&quot;&gt;Experimentation with RxJava&lt;/a&gt; by Joan Zapata</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03861d52c0ac7e93ae1206503fa91b22d7f7e21" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.kaush.co/2015/01/21/rxjava-tip-for-the-day-share-publish-refcount-and-all-that-jazz/&quot;&gt;&lt;cite&gt;Wedding Party&lt;/cite&gt;: Share, Publish, Refcount, and All That Jazz&lt;/a&gt; by Kaushik Gopal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce980c6203942d6328150d8b1c308fa22c0eaa5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blogs.microsoft.co.il/iblogger/2015/08/11/animations-of-rx-operators-groupby/&quot;&gt;Animations of Rx operators: GroupBy&lt;/a&gt; by Tamir Dresher</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbfa59fd65771d372675362d61976b92c09f6c20" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://davesexton.com/blog/post/To-Use-Subject-Or-Not-To-Use-Subject.aspx&quot;&gt;To Use or Not to Use Subject&lt;/a&gt; from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759d49d6a27ee607b3399f224c41924b74508d45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.couchbase.com/developer/java-2.0/observables.html&quot;&gt;&lt;cite&gt;Mastering observables&lt;/cite&gt;&lt;/a&gt; (from the Couchbase Server documentation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896a64d54c6458d527ffcfd1ff702993ee89e715" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Triangular_number&quot;&gt;triangular numbers&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf025e741372bc56b5fa846f8b8c00cb06df70f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/&quot;&gt;RxJava Observable transformation: concatMap() vs. flatMap()&lt;/a&gt; by Fernando Cejas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d3f563e622ffc28d2ef40034bcd9d4f00ca617" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://java.dzone.com/articles/async-abstractios-using-rx&quot;&gt;Async Abstractions using rx-java&lt;/a&gt; by Biju Kunjummen,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a54c1db4af03308f492e88a17125cdba0d0c092" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jschneider.io/2014/11/26/Recursive-Observables-with-Rx-Java.html&quot;&gt;&lt;cite&gt;Recursive Observables with RxJava&lt;/cite&gt;&lt;/a&gt; by Jon Schneider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16022b407d5c10a64a78eb6bcb293d94191d92c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedulePeriodically(rx.functions.Action0,%20long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;Another &lt;code&gt;Scheduler&lt;/code&gt; method&lt;/a&gt; allows you to schedule an action to take place at regular intervals. The following example schedules &lt;code&gt;someAction&lt;/code&gt; to be performed on &lt;code&gt;someScheduler&lt;/code&gt; after 500ms have passed, and then every 250ms thereafter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37f7ccc01d776219ff3c86d486170b61368bb91" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html&quot;&gt;The &lt;code&gt;TestScheduler&lt;/code&gt;&lt;/a&gt; allows you to exercise fine-tuned manual control over how the Scheduler&amp;rsquo;s clock behaves. This can be useful for testing interactions that depend on precise arrangements of actions in time. This Scheduler has three additional methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b99f29bcb2b76c81e30b2a8987e758a20001805" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html&quot;&gt;RxJava: Understanding observeOn() and subscribeOn()&lt;/a&gt; by Thomas Nield</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5434e93f83f2e22d891275d0648442c8413f6ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;&lt;cite&gt;RxJava Threading Examples&lt;/cite&gt;&lt;/a&gt; by Graham Lea</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d280bc18cadf90c9c47536bb1dda083a732e6f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examlpes&lt;/a&gt; by Graham Lea</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f17e88de08b7b705152e13a4c7159ebecfb889" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.nurkiewicz.com/2014/12/accessing-meetups-streaming-api-with.html&quot;&gt;Aligning packets with JSON documents&lt;/a&gt; with the &lt;code&gt;split&lt;/code&gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f646afbe00e0bfa7ba10a96b4ffa0e66bb17b8c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/implementing_your_own_operators.html&quot;&gt;Implementing Your Own Observable Operators&lt;/a&gt; (in RxJS) by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de4cdb66506641a1d2be3db34ce3c18d520fb41" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/scheduling_and_concurrency.html&quot;&gt;Using Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704f937aee915cf54084238d4d732aaafe152536" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/subjects.html&quot;&gt;Using Subjects&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4848d0a67536767bfc3a46b25a389c6c12411971" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/helpers/pluck.html&quot;&gt;&lt;code&gt;Rx.helpers.pluck(property)&lt;/code&gt;&lt;/a&gt; from Dennis Stoyanov&amp;rsquo;s RxJS book</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3ad2689ab54eb0e90eeaa55c13b2942af325ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/observable/index.html&quot;&gt;Observable object&lt;/a&gt; (RxJS) by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05fc805666c7d298737b623ab15f7e3dc904dae7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/schedulers/index.html&quot;&gt;Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3189bb2a65685a675d2fc7b27dec30afc63ad7c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html&quot;&gt;Which Operator do I use?&lt;/a&gt; by Dennis Stoyanov (a similar decision tree, specific to RxJS operators)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8e12a5cf50d130360fa140e3c6026b7357fde7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://afterecho.uk/blog/turning-a-callback-into-an-rx-observable.html&quot;&gt;Turning a callback into an Rx Observable&lt;/a&gt; by @afterecho</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93a2223081711dc6a16e0d515e0ae72c9ea57ff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/lessons/javascript-introducing-the-observable&quot;&gt;Introducing the Observable&lt;/a&gt; by Jafar Husain (JavaScript Video Tutorial)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334e700ad37dedaa75e68b424f31c8fa60b1fb0a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/lessons/javascript-using-the-map-method-with-observable&quot;&gt;Using the map method with Observable&lt;/a&gt; by Jafar Husain (JavaScript Video Tutorial)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b97a092a417ac6514a68c890f6e9a31313afc87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877&quot;&gt;&lt;cite&gt;2 minute introduction to Rx&lt;/cite&gt;&lt;/a&gt; by Andre Staltz (&amp;ldquo;Think of an Observable as an asynchronous immutable array.&amp;rdquo;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57e3b7ba34ac94a726bbf8003c34e5a0fd3f3d6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://speakerdeck.com/benjchristensen/applying-rxjava-to-existing-applications-at-philly-ete-2015&quot;&gt;Testing Reactive Applications&lt;/a&gt; by Ben Christensen</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64d773c526ed13fecf935007c5b8b42451946ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;mathematical-and-aggregate-operators#wiki-reduce&quot;&gt;&lt;code&gt;reduce(a)&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;transforming-observables#wiki-scan&quot;&gt;&lt;code&gt;scan(a)&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.&lt;/code&gt;&lt;a href=&quot;filtering-observables#wiki-last&quot;&gt;&lt;code&gt;last( )&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aedba0e61fd807ab73f1bcd257861ff700c36541" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/all&quot;&gt;&lt;code&gt;All&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether all items emitted by an Observable meet some criteria</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4af39a8182c43692831b7f5254a2e5a28ab5e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/amb&quot;&gt;&lt;code&gt;Amb&lt;/code&gt;&lt;/a&gt; &amp;mdash; given two or more source Observables, emit all of the items from only the first of these Observables to emit an item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6abf056e15446abb733a1356236897d0eb88fbc5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/and-then-when&quot;&gt;&lt;code&gt;And&lt;/code&gt;/&lt;code&gt;Then&lt;/code&gt;/&lt;code&gt;When&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine sets of items emitted by two or more Observables by means of &lt;code&gt;Pattern&lt;/code&gt; and &lt;code&gt;Plan&lt;/code&gt; intermediaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebf0c5f54c5bec720782a934c3ac450d6d61240" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/average&quot;&gt;&lt;code&gt;Average&lt;/code&gt;&lt;/a&gt; &amp;mdash; calculates the average of numbers emitted by an Observable and emits this average</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b94b62bcc7c953efa686abfda740c404bb41fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/backpressure&quot;&gt;&lt;strong&gt;backpressure operators&lt;/strong&gt;&lt;/a&gt; &amp;mdash; strategies for coping with Observables that produce items more rapidly than their observers consume them</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4188b6a7d79bcd68189ca1745286160ac1b4b8b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; &amp;mdash; periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1e7131303f464e9943733bedda780f33c1a666" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/catch&quot;&gt;&lt;code&gt;Catch&lt;/code&gt;&lt;/a&gt; &amp;mdash; recover from an &lt;code&gt;onError&lt;/code&gt; notification by continuing the sequence without error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da57d968e0e4216a34863a171db7ab41b9812ec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/combinelatest&quot;&gt;&lt;code&gt;CombineLatest&lt;/code&gt;&lt;/a&gt; &amp;mdash; when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5080500198e0f8811c8452bb3beb14dec470f66" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/concat&quot;&gt;&lt;code&gt;Concat&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit the emissions from two or more Observables without interleaving them</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ae6daf6671ffcf155c2fa5c4d803d4f7af8682" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/connect&quot;&gt;&lt;code&gt;Connect&lt;/code&gt;&lt;/a&gt; &amp;mdash; instruct a connectable Observable to begin emitting items to its subscribers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e31fa5a564732c4705e3cfc70e314969dc504c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/contains&quot;&gt;&lt;code&gt;Contains&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether an Observable emits a particular item or not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd2683bd64c47ab143020ad6a8b004e6473f895" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/count&quot;&gt;&lt;code&gt;Count&lt;/code&gt;&lt;/a&gt; &amp;mdash; count the number of items emitted by the source Observable and emit only this value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b703b9011ffb0e21799b507e8d5b7991453ff2f5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/create&quot;&gt;&lt;code&gt;Create&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable from scratch by calling observer methods programmatically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d520a5275eeadd415b96286025e57173c2f421ef" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/debounce&quot;&gt;&lt;code&gt;Debounce&lt;/code&gt;&lt;/a&gt; &amp;mdash; only emit an item from an Observable if a particular timespan has passed without it emitting another item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcbedf41620fc26c55f3a79460e1936597cd6376" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/defaultifempty&quot;&gt;&lt;code&gt;DefaultIfEmpty&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit items from the source Observable, or a default item if the source Observable emits nothing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ead6b29bf678adce5dda8d26b2b84e8a029610e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/defer&quot;&gt;&lt;code&gt;Defer&lt;/code&gt;&lt;/a&gt; &amp;mdash; do not create the Observable until the observer subscribes, and create a fresh Observable for each observer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c877468ebfffede1767292c312dce60b414b3e7e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/delay&quot;&gt;&lt;code&gt;Delay&lt;/code&gt;&lt;/a&gt; &amp;mdash; shift the emissions from an Observable forward in time by a particular amount</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd3bc1c02474c98160f5c3daaaf519e81d28a2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/distinct&quot;&gt;&lt;code&gt;Distinct&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress duplicate items emitted by an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bcec9b0ef7199fdfb5d4143f346557af694831" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/do&quot;&gt;&lt;code&gt;Do&lt;/code&gt;&lt;/a&gt; &amp;mdash; register an action to take upon a variety of Observable lifecycle events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78138361fd31ace0165e9d2c41fa553949f98a1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/elementat&quot;&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ea48737e4cf7e24239f531b16f54742f291f19" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/empty-never-throw&quot;&gt;&lt;code&gt;Empty&lt;/code&gt;/&lt;code&gt;Never&lt;/code&gt;/&lt;code&gt;Throw&lt;/code&gt;&lt;/a&gt; &amp;mdash; create Observables that have very precise and limited behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d35f0e202be5da8bca269f843088bbc301dc44" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only those items from an Observable that pass a predicate test</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e10a2781542f87afbf33eb4a144578a352afb60" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; (RxScala version of &lt;strong&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af7efb0e5277caa8bcb4ca047ec46c742ccb1fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; (alternate name of &lt;strong&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b1e5aa586c9c45e855a67c901087f73288790f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/first&quot;&gt;&lt;code&gt;First&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the first item, or the first item that meets a condition, from an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0333194f18a33a7a679904ac05075d80fb58292e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/first&quot;&gt;&lt;code&gt;Next&lt;/code&gt;&lt;/a&gt; (BlockingObservable version)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e51f771a5f9140c8f1c5f545f5f8d7fa162868d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/flatmap&quot;&gt;&lt;code&gt;FlatMap&lt;/code&gt;&lt;/a&gt; &amp;mdash; transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f2ef1fb92d5f7acf826243fcc2a2bbb36aecb1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert some other object or data structure into an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c784fcd85d0d9eee95eec8546747974634737771" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/groupby&quot;&gt;&lt;code&gt;GroupBy&lt;/code&gt;&lt;/a&gt; &amp;mdash; divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961f7bdad0209a178b650ec75f14ba3dbab617cd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/ignoreelements&quot;&gt;&lt;code&gt;IgnoreElements&lt;/code&gt;&lt;/a&gt; &amp;mdash; do not emit any items from an Observable but mirror its termination notification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a0c12a44344d7075bd1bab89a82bb9105a316b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a sequence of integers spaced by a particular time interval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c0927b758a710d223a235baa006d1ad82eacf1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/join&quot;&gt;&lt;code&gt;Join&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f789526a11cbf951f3017cad8bb11a7e4f2ae5f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/just&quot;&gt;&lt;code&gt;Just&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an object or a set of objects into an Observable that emits that or those objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24150c757b2d9fe51daa5b9af6362ed547f642d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/last&quot;&gt;&lt;code&gt;Last&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the last item emitted by an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfa4568e3237e07a49192561a240de86776b19c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/last&quot;&gt;&lt;code&gt;takeRight&lt;/code&gt;&lt;/a&gt; (see also: &lt;a href=&quot;operators/takelast&quot;&gt;&lt;code&gt;TakeLast&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6273a6a4cb7f838288a2e07ef52f0d3d06baaf4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &amp;mdash; transform the items emitted by an Observable by applying a function to each item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1ea99f33b2d42aa36a7fc325095d80ff73e6e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/map&quot;&gt;&lt;code&gt;Select&lt;/code&gt;&lt;/a&gt; (alternate name of &lt;strong&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce6754f280c0d41eb1e96d9819d872ea7cbb479" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/materialize-dematerialize&quot;&gt;&lt;code&gt;Materialize&lt;/code&gt;/&lt;code&gt;Dematerialize&lt;/code&gt;&lt;/a&gt; &amp;mdash; represent both the items emitted and the notifications sent as emitted items, or reverse this process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43ea78d80899fb195485fd3038b95794736c693" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/max&quot;&gt;&lt;code&gt;Max&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine, and emit, the maximum-valued item emitted by an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896d525218ff0dfffdd195a9e6eee022104a5cda" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/merge&quot;&gt;&lt;code&gt;Merge&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine multiple Observables into one by merging their emissions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f540a11749020205078336f04e2c0c14a5a0beb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/min&quot;&gt;&lt;code&gt;Min&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine, and emit, the minimum-valued item emitted by an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c97bac5d1832ec1abde2e15368384c4243e8cc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/observeon&quot;&gt;&lt;code&gt;ObserveOn&lt;/code&gt;&lt;/a&gt; &amp;mdash; specify the scheduler on which an observer will observe this Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e4de04374963ac6f0703deddf542b57beab534" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/publish&quot;&gt;&lt;code&gt;Publish&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an ordinary Observable into a connectable Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d19d53dfbba576a9be303d133898023ec0f1468" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a range of sequential integers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220d9225db54aea0568c311fb54c1b1af2b03d83" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/reduce&quot;&gt;&lt;code&gt;Reduce&lt;/code&gt;&lt;/a&gt; &amp;mdash; apply a function to each item emitted by an Observable, sequentially, and emit the final value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ebff59c0c373b115b3a5c2d65e3f91e16e588e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/refcount&quot;&gt;&lt;code&gt;RefCount&lt;/code&gt;&lt;/a&gt; &amp;mdash; make a Connectable Observable behave like an ordinary Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ec521fdbc793707013621bfc8fb2ba153a0cd8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/repeat&quot;&gt;&lt;code&gt;Repeat&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a particular item or sequence of items repeatedly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2804cd9e5f0367f7c9558927abf3a72ef9c06ac4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/replay&quot;&gt;&lt;code&gt;Replay&lt;/code&gt;&lt;/a&gt; &amp;mdash; ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ec748f863300265c910192f8f5af498feb4f55" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/retry&quot;&gt;&lt;code&gt;Retry&lt;/code&gt;&lt;/a&gt; &amp;mdash; if a source Observable sends an &lt;code&gt;onError&lt;/code&gt; notification, resubscribe to it in the hopes that it will complete without error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe03930f3581f4dad5c8a3922092b89e1191d93d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sample&quot;&gt;&lt;code&gt;Sample&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit the most recent item emitted by an Observable within periodic time intervals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75c698d2f0fe31254942270f4f860c2edd619a3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/scan&quot;&gt;&lt;code&gt;Scan&lt;/code&gt;&lt;/a&gt; &amp;mdash; apply a function to each item emitted by an Observable, sequentially, and emit each successive value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb4dcaeae3f881353f0198da0ed07774810c96e4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sequenceequal&quot;&gt;&lt;code&gt;SequenceEqual&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether two Observables emit the same sequence of items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9082009ddd16283a5a15007359dd764bf941bf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/serialize&quot;&gt;&lt;code&gt;Serialize&lt;/code&gt;&lt;/a&gt; &amp;mdash; force an Observable to make serialized calls and to be well-behaved</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5b3dde082c7f134651c5c0ee0f77c10d8849f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skip&quot;&gt;&lt;code&gt;Skip&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress the first</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c550f6342285873d1251001f507a49dd499b9a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skiplast&quot;&gt;&lt;code&gt;SkipLast&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress the last</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4091fcbf30f6cac5a853be94132763f8026869c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skipuntil&quot;&gt;&lt;code&gt;SkipUntil&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable until a second Observable emits an item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2508b5d42729a80bcadabbd948ac432565126f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skipwhile&quot;&gt;&lt;code&gt;SkipWhile&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable until a specified condition becomes false</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715557b9c7b5c8b25056c589cc3f188f11be2cc2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/start&quot;&gt;&lt;code&gt;Start&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits the return value of a function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a16879f166f96ec4f6c887a4b17c95425000b2d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/startwith&quot;&gt;&lt;code&gt;StartWith&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit a specified sequence of items before beginning to emit the items from the source Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0ff74e8a6826625e34447a02f61eea2babf5abb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribe&quot;&gt;&lt;code&gt;Subscribe&lt;/code&gt;&lt;/a&gt; &amp;mdash; operate upon the emissions and notifications from an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8c65f3783b491e2da19c9577fc47f408f83f9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribe&quot;&gt;The &lt;code&gt;Subscribe&lt;/code&gt; method&lt;/a&gt; is how you connect an observer to an Observable. Your observer implements some subset of the following methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20bd35f3cd630e6729cd59d5f5871941dbba7336" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribeon&quot;&gt;&lt;code&gt;SubscribeOn&lt;/code&gt;&lt;/a&gt; &amp;mdash; specify the scheduler an Observable should use when it is subscribed to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c9b8fa32c3e32960d4065945b8d21ee9ae586d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sum&quot;&gt;&lt;code&gt;Sum&lt;/code&gt;&lt;/a&gt; &amp;mdash; calculate the sum of numbers emitted by an Observable and emit this sum</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff5479ffc0e2648d627b6a506e5a3ac0a369e95" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sum&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; (string)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12270334cc52f8a9daf70d2dd8a4a15c526d5d82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/switch&quot;&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18cfa275521a80308ec35ddf6041423b53915ce9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/switch&quot;&gt;&lt;code&gt;latest&lt;/code&gt;&lt;/a&gt; (Rx.rb version of &lt;strong&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c512d0a45fbef14a0ca00b1ba15611f0f470c5fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/take&quot;&gt;&lt;code&gt;Take&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the first</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f2c659ea7a1fbd932f5dfd6f64cbda8bd8e8b88" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takelast&quot;&gt;&lt;code&gt;TakeLast&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the last</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a4532cb238dde4e68093af52658f5445b11adf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takeuntil&quot;&gt;&lt;code&gt;TakeUntil&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable after a second Observable emits an item or terminates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a388db3da085f5150944c06f479a2f12efe907" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takewhile&quot;&gt;&lt;code&gt;TakeWhile&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable after a specified condition becomes false</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90712fbd60a57bf67f06b86afd680c3c52c8c0e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timeinterval&quot;&gt;&lt;code&gt;TimeInterval&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56fae76408c63619174d789717205ca81e57c61d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timeout&quot;&gt;&lt;code&gt;Timeout&lt;/code&gt;&lt;/a&gt; &amp;mdash; mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b4d7785cee0739e289b4511c57a47b43fb0a69" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timer&quot;&gt;&lt;code&gt;Timer&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a single item after a given delay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8153fd468994e7f23f93090e11c64478da3a861a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timestamp&quot;&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;/a&gt; &amp;mdash; attach a timestamp to each item emitted by an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08036d386b50af7605f69d72032e90ec9b7ae3be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/to&quot;&gt;&lt;code&gt;To&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable into another object or data structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27441bb348b701709f46ba2a9e1fd000edbe104" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/using&quot;&gt;&lt;code&gt;Using&lt;/code&gt;&lt;/a&gt; &amp;mdash; create a disposable resource that has the same lifespan as the Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7798a9984bb26f086d17dce14b65fb99ceeb7d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/window&quot;&gt;&lt;code&gt;Window&lt;/code&gt;&lt;/a&gt; &amp;mdash; periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cf183eb5d366413ed5d5c204d8b7fa6f3b0e5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d6d8e38830f49548b2c4afc11148786a0b1e918" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; (RxClojure version of &lt;strong&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79293a7f079b9373f12db529fcf04630f0840459" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;mapCat&lt;/code&gt;&lt;/a&gt; (RxClojure version of &lt;strong&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc842fac1c68ceb5773485119db93147ac0c6b6e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;single&quot;&gt;&lt;tt&gt;Single&lt;/tt&gt;&lt;/a&gt; &amp;mdash; a specialized version of an Observable that emits only a single item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84438b704c9fca4e5527512cd5c27340544d75ab" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Buffer &amp;mdash; Simple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3999cc1a087194796f932be496866a6f0182c3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: CombineLatest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfeeecdc7b7288e5ea70c6c892c1d944664cf48" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: CombineLatest &amp;mdash; Parallel Execution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b4feb080d4814c3633843d31049b4ae614c799" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Concat &amp;mdash; cold observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e2ed6732260c865ef6eccba85b4ddc0466e81a" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Concat &amp;mdash; hot observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f1e8f5e8387df20c1e2eec385011ae6468129f3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Delay &amp;mdash; Simple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cd41c26800564ad47aa6441382096c455b8e77" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Generate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ed1f3ab8250846a6b02df43301b10c649c335e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: GroupJoin &amp;mdash; Joins two streams by matching by one of their attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a401a286d1a0539e3f17195639b2743803c2c5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: ISubject&amp;lt;T&amp;gt; and ISubject&amp;lt;T1,T2&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4497c7c8e023a9337eb5395666b4310b2d91e7e8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Interval &amp;mdash; Simple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a953c40a21409172145703f425a7a60796dd5e88" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Interval &amp;mdash; With TimeInterval()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65190ea0c6ca0b42f3664eb352fbfe370afd6443" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Merge</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e8128889f9b5776897d04d41bfbd2cef9c6fde" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Observation Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49730b290b423f322940dab1ff7061f932845d63" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Observing the Passing of Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfc989ca6ffd7c7cbf77916f7081d7bbbcf3c03" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Publish &amp;mdash; Sharing a subscription with multiple Observers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e1b94cb3df3df1bc50246ed5e11b9d9a413f3e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd72099514d7ac2d1520ae4b1cd03541ecb3d75b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Sample &amp;mdash; Simple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5982dbcf362e5fe59b0b1a74ae7c356eb14b62" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Select &amp;mdash; Indexed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="758e63347c494706666595c451133580e55bb6b1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Start &amp;mdash; Run Code Asynchronously</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2323d4a4016773c83f1325ef75d2d80d33e98d7" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Throttle &amp;mdash; Simple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d228cb755846dd4e2bab50fb5eab415316bfec1c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timeout &amp;mdash; Simple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002c8dac44d68094923f2810a86c6d928664e2f1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timer &amp;mdash; Simple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb1c8d362fc1bea83ee3e202602ece035e7c32e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timestamp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee1829693fce377b6ff46cbe5704191231dfef0" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Window</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1cda1b914a8d023f1dc4d23b17ff394f90c636" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Zip</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4bda5dfe90db399b7c4b0b87d01c88b07162ee5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;DebounceBuffer: Use publish(), debounce() and buffer() together to capture bursts of events.&lt;/cite&gt; by Ben Christensen</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c0ae8f6836ea32e237cbdd5a36d5da68d09d69" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;DebouncedBuffer With RxJava&lt;/cite&gt; by Gopal Kaushik</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda16f284575e40f90ac1dc6981b546622a0c621" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Aggregate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29247369a4b0d247d97753a93d41653acdcc1b2c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: All</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93019059f558486ba0ef91989fbb8dc88733b68e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: And-Then-When</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc360128e41bbeba319356f06f179ae8502f246c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: AsyncSubject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035b87099a1834a0e066b29f62655685da21f8a6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: BehaviorSubject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc61a26f41cc061366ee6101362cf6f70d41f1b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b117e897e1a17fe032c5af3a2ce613ff6014d11" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Buffer revisited</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab41ea4f239b99143925cd4be6c94ac1e3cfefa7" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Cast and OfType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd718e0e229c64fe1688ec231dd8353c9a412db9" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Catch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b321cc1c9b76079278935ccb62bff36d39200bc5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: CombineLatest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="116fa0f10acbbeea88e8d3059138b6ffe66c5444" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Concat</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1528f7d4c47527e0e461233c282602ab6d7c644e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Contains</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cbe58edf946b3f8dfb0bb7c462598c80afc1e93" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35d04abcc5dd65704022c34cf83804415cc2818" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Create</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1fd0c382a8358907465f71dddc50255a92ecd52" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: DefaultIfEmpty</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b4c1fb3d3566c798e145f7923dc2a08228d7a6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Delay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54a5e164dffee3139f0b8af5169e80489a8e13b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Distinct and DistinctUntilChanged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777d04576f3bc70403fbe3a7bb1a9372ec841588" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb3452c0d7a0dadb569326b2e61144cf85c9fd3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: ElementAt and ElementAtUntilChanged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102fcee9f7ec081921ab59ef89ed1c5e6b30e5de" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Finally</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ea11e182295d6ed28a6220510e239e26b5282e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: First</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c115a63e4865e74a4f8c5c291e91b00b3a150355" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Generate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60542fbfdcd01dc53807bc0478ce040a8e2f6f10" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: GroupBy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540568cfdc74e1f0a4c7b8678fd0356e93246f46" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: GroupJoin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6339c110750aea5eb774297c37884bfcde2b0f79" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IObservable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d98673531f7a8b8b3f9e8256945795eeabd6f8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IObserver</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd627340831e496d98293a5f69462983384dde95" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IgnoreElements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62256229d5203f226886b8e64e6ea284cf6957eb" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Interval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4474d3483ee629a00095c34b8d299693d81065" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Join</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87545688a3ea5ebc6e25e2842e72c8dd9c5d1e62" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Last</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de669709c1879b9f542aa4f94c433bcc8290782" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Leaving the monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec1f4dfc1029c5aa7773b137724641aade3c9a3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Materialize and Dematerialize</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04f7fc5eb7b8ba52c2a9a92360ca02e81cf40ad" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Merge</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7869d155329c64ed405fc5786876dad056073d" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Min, Max, Sum, and Average</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d365b1eb7a9536f57568dab1fe5dd916f25bda8d" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Publish &amp;amp; Connect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e878ce5258868ac3eb4fdf5d6843d2c8b3a76f7b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cf07af2c8eace50997f716a98f99e4c0971f00" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: RefCount</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084764999a741c143088232da1c0321b35e44092" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Repeat</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26de299ed749b577f696b62b39924a8a9e30ef6b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Replay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06a12ff37836439265ffeb4d10fc8154fcfaa4f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: ReplaySubject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30bd9ac68d920b64f5efe285e03d588837291f5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Retry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54854f0097fa9244f288e39b24e48e27f8b83e4b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e2be634bb26a274d4fdf88c706025ebeaa2d11" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Sample</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1001379cadd511d49b86bafe6e12c95acd7607" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Scan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0d36e7e05dd4add274fb3feede439a3a19fa5b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Scheduling and Threading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7dab96b686167a434b97d22488b8cb79d6c5417" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Select</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477286cb919491f0f63e72a8903656eb7a6282c1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SelectMany</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1800b1d9f701e32bfd1c70be2fcb64008e74f8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SequenceEqual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed818ec833039363080c9f8f4e89173be2b16966" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Simple Factory Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd00bb3e997d8645bdf8fe33420a70c94cda4c6e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Single</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b745a93a790b9dad2a52091e6386fcbbc51de6ee" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Skip and Take</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1443306acabe169cf8f390ed1c3f8bbc6913bfee" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipLast and TakeLast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cfe8d6a7fee34f4bb8d00922555c4a8c705669f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipUntil and TakeUntil</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6650c255e70bfd3620e12c3cc72fedf90eadf2e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipWhile and TakeWhile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc66b563aabc4fbedb00d8119ba74bacef0ab41" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: StartWith</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9086b49d24c6b80e0f6a79b601213b2ce91d13b5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Subject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a983fed5c5e768256355b29f51e96fa5bbb549e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SubscribeOn and ObserveOn</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b0d127d96097cab2795ab626cee0a49915b626" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Switch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598171f79ea0f898758ff883e3ad03569f596954" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Throttle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b85e9531a48451320c69fba5b56201a54cdb7f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timeout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98b8b62bdf570f0a4177044a6de1ba2c46e8d5c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aaa2e22718c5ee322409e5e0fbbf4c9fbefbd6c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timestamp and TimeInterval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b1306a6995c5be8256f3ea632e95419c48355f6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e2eaaf295a67907acba8525225401373b5b6e8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88acce28317e2934f05b0089a12e44c31a31df21" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Window</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="311056bb87e8631686c9a13f7a9aa24b48a750b3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Zip</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9f75058fd74c2e40d3fbad984b2426f71c5f1b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Microsoft Developer Network&lt;/cite&gt;: &amp;ldquo;What does the new ManySelect operator do?&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2513d452931404692c534110e17b00bb086db47" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Design Guidelines&lt;/cite&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16b13d1d2d48a4ab59af38cc3f2786f48280ae9" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop: Schedulers&lt;/cite&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b16a529d6fb7f077c4e534c2ba8a41a8b5195c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop&lt;/cite&gt;: Introduction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e372f7712619b05579788c28d99a8619d24c02b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop&lt;/cite&gt;: Schedulers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5060b2e8a80327e13489eab521802fc2c1470513" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;RxJS Design Guidelines&lt;/cite&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84472df2bda697a25594c7286ae6152a2914a3d3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;RxJava Threading Examples&lt;/cite&gt; by Graham Lea</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c89a5198e1f457a5def50b38dd05269b98b494b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;StackOverflow&lt;/cite&gt;: What is a &amp;ldquo;Scheduler&amp;rdquo; in RxJS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ad2748ced1a268c1da5ba38bef169ec3221a63" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;ad-hockery&lt;/cite&gt;: Simple Background Polling with RxJava</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc895a0d19a290d9d7e1ce1ff10f8f31be62c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt;. This behaves similarly to &lt;code&gt;stopAndWait&lt;/code&gt; but has an internal buffer of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8c7fe962e91ed4b8f8c0b825242e59e8443a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;All&lt;/code&gt;, &lt;code&gt;Amb&lt;/code&gt;, &lt;code&gt;Contains&lt;/code&gt;, &lt;code&gt;DefaultIfEmpty&lt;/code&gt;, &lt;code&gt;SequenceEqual&lt;/code&gt;, &lt;code&gt;SkipUntil&lt;/code&gt;, &lt;code&gt;SkipWhile&lt;/code&gt;, &lt;code&gt;TakeUntil&lt;/code&gt;, and &lt;code&gt;TakeWhile&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d4b2413273db5421b89d5d4bf5bbc759de0ea7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;And&lt;/code&gt;/&lt;code&gt;Then&lt;/code&gt;/&lt;code&gt;When&lt;/code&gt;, &lt;code&gt;CombineLatest&lt;/code&gt;, &lt;code&gt;Join&lt;/code&gt;, &lt;code&gt;Merge&lt;/code&gt;, &lt;code&gt;StartWith&lt;/code&gt;, &lt;code&gt;Switch&lt;/code&gt;, and &lt;code&gt;Zip&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7126635798dce02399a0d9194f6641dfa46c0068" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Average&lt;/code&gt;, &lt;code&gt;Concat&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;, &lt;code&gt;Max&lt;/code&gt;, &lt;code&gt;Min&lt;/code&gt;, &lt;code&gt;Reduce&lt;/code&gt;, and &lt;code&gt;Sum&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5c2eccca242affd9bbd13eb09e3476a9ed7742" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BlockingObservable.forEach&lt;/code&gt; takes a single function as its parameter, and this function behaves much like an &lt;code&gt;onNext&lt;/code&gt; function in the subscription to an ordinary Observable. The &lt;code&gt;forEach&lt;/code&gt; operator itself blocks until the &lt;code&gt;BlockingObservable&lt;/code&gt; completes, and it is by unblocking, rather than by calling a callback function, that it indicates that it is complete. If it encounters an error it will throw a &lt;code&gt;RuntimeException&lt;/code&gt; (rather than calling an analogue to the &lt;code&gt;onError&lt;/code&gt; callback).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fbef09e1b4ea0717efe751ffcefe7699946c25c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;BufferOpenings&lt;/code&gt;, that emits &lt;code&gt;TBufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new &lt;code&gt;IList&lt;/code&gt; to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;TBufferOpening&lt;/code&gt; object into the &lt;code&gt;bufferClosingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;Buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it closes the &lt;code&gt;IList&lt;/code&gt; and emits it as its own emission.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d76f7cc4ba89864f1b43d8207b52f2436f06ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;IList&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;IList&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7081d72299cbb568724327709a714b40f340cd51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;IList&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da2abc6a4d49055692e67ed62d86fc2cb0e1e82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan)&lt;/code&gt; emits a new &lt;code&gt;IList&lt;/code&gt; of items periodically, every &lt;code&gt;timeSpan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first list, since the subscription to the source Observable. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0db02107ba69f00dfab9f9466aa0e853bf477c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan, count)&lt;/code&gt; emits a new &lt;code&gt;IList&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timeSpan&lt;/code&gt; has elapsed since its last list emission, it emits a list of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b47fc6baedd7b73f21f5f4d7959f2aa975a8452" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan, timeShift)&lt;/code&gt; creates a new &lt;code&gt;IList&lt;/code&gt; of items every &lt;code&gt;timeShift&lt;/code&gt; period of time, and fills this list with every item emitted by the source Observable from that time until &lt;code&gt;timeSpan&lt;/code&gt; time has passed since the list&amp;rsquo;s creation, before emitting this &lt;code&gt;IList&lt;/code&gt; as its own emission. If &lt;code&gt;timeSpan&lt;/code&gt; is longer than &lt;code&gt;timeShift&lt;/code&gt;, the emitted lists will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dabc780819d59525df52a91f7676a389f3e0f2a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer&lt;/code&gt;, &lt;code&gt;FlatMap&lt;/code&gt;, &lt;code&gt;GroupBy&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Scan&lt;/code&gt;, and &lt;code&gt;Window&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36249d8634975dadb84d72123168f8247b877485" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Catch&lt;/code&gt; and &lt;code&gt;Retry&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1e26c0b89264fa68e936ea021b56c4aec1f096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Connect&lt;/code&gt;, &lt;code&gt;Publish&lt;/code&gt;, &lt;code&gt;RefCount&lt;/code&gt;, and &lt;code&gt;Replay&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2352bf3b7789aa73de64405f99b50a6b876dcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Defer&lt;/code&gt;, &lt;code&gt;Empty&lt;/code&gt;/&lt;code&gt;Never&lt;/code&gt;/&lt;code&gt;Throw&lt;/code&gt;, &lt;code&gt;From&lt;/code&gt;, &lt;code&gt;Interval&lt;/code&gt;, &lt;code&gt;Just&lt;/code&gt;, &lt;code&gt;Range&lt;/code&gt;, &lt;code&gt;Repeat&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt;, and &lt;code&gt;Timer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0cc0f15199ef85fbb9ecd6605602fd48b0e87a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Debounce&lt;/code&gt;, &lt;code&gt;Distinct&lt;/code&gt;, &lt;code&gt;ElementAt&lt;/code&gt;, &lt;code&gt;Filter&lt;/code&gt;, &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;IgnoreElements&lt;/code&gt;, &lt;code&gt;Last&lt;/code&gt;, &lt;code&gt;Sample&lt;/code&gt;, &lt;code&gt;Skip&lt;/code&gt;, &lt;code&gt;SkipLast&lt;/code&gt;, &lt;code&gt;Take&lt;/code&gt;, and &lt;code&gt;TakeLast&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5f8d43efabcb2ababea7b078ba251a574b59be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Delay&lt;/code&gt;, &lt;code&gt;Do&lt;/code&gt;, &lt;code&gt;Materialize&lt;/code&gt;/&lt;code&gt;Dematerialize&lt;/code&gt;, &lt;code&gt;ObserveOn&lt;/code&gt;, &lt;code&gt;Serialize&lt;/code&gt;, &lt;code&gt;Subscribe&lt;/code&gt;, &lt;code&gt;SubscribeOn&lt;/code&gt;, &lt;code&gt;TimeInterval&lt;/code&gt;, &lt;code&gt;Timeout&lt;/code&gt;, &lt;code&gt;Timestamp&lt;/code&gt;, and &lt;code&gt;Using&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b4675304049fa90cdf432a831ba6b5c8ac581b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PublishSubject&lt;/code&gt; emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c856f5db49856ca93f078770fa39860cfdd2e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReplaySubject&lt;/code&gt; emits to any observer all of the items that were emitted by the source Observable(s), regardless of when the observer subscribes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6e191c77e6cb37262a32efe110a3b46253be77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e2656e1a12907334ba6ba9dbb22e19905e2e0d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a145b69fbb341823a7e2b8ac1730617d11c3e2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="652dd811848564f467f4c6881792205b07b1ddcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;average&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5d83aa14e9a24c0de81cecf086101bb52aa929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(boundary)&lt;/code&gt; monitors an Observable, &lt;code&gt;boundary&lt;/code&gt;. Each time that Observable emits an item, it creates a new &lt;code&gt;List&lt;/code&gt; to begin collecting items emitted by the source Observable and emits the previous &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697675068739693864b5220ff9294b45d325c570" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(boundary&lt;/code&gt;[&lt;code&gt;, initialCapacity&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41bbfe617dacf8cd6bfdd7ec53d1681abb55514b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferBoundaries)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferBoundaries&lt;/code&gt;. Each time that Observable emits an item, it creates a new collection to begin collecting items emitted by the source Observable and emits the previous collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5308080ad587c5e4577043e64860d26d587755fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferOpenings&lt;/code&gt;, that emits &lt;code&gt;BufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new &lt;code&gt;List&lt;/code&gt; to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;bufferOpenings&lt;/code&gt; Observable into the &lt;code&gt;closingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it closes the &lt;code&gt;List&lt;/code&gt; and emits it as its own emission.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2570789cc0e868e96a6ac6bd1dc1fbc11fe2d472" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferOpenings&lt;/code&gt;, that emits &lt;code&gt;BufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new collection to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;bufferOpenings&lt;/code&gt; Observable into the &lt;code&gt;bufferClosingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it emits the current collection and begins a new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fe61d7081d96d83ff99876095e8a6fd192610b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(buffer_openings=boundaryObservable)&lt;/code&gt; monitors an Observable, &lt;code&gt;buffer_openings&lt;/code&gt;. Each time that Observable emits an item, it creates a new array to begin collecting items emitted by the source Observable and emits the previous array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863a8824c4e8d667b06cdd3b24a0e6ddd6012b66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(closing_selector=closingSelector)&lt;/code&gt; begins collecting items emitted by the source Observable immediately upon subscription, and also calls the &lt;code&gt;closing_selector&lt;/code&gt; function to generate a second Observable. It monitors this new Observable and, when it completes or emits an item, it emits the current array, begins a new array to collect items from the source Observable, and calls &lt;code&gt;closing_selector&lt;/code&gt; again to generate a new Observable to monitor in order to determine when to emit the new array. It repeats this process until the source Observable terminates, whereupon it emits the final array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4258a2e6df22ec7068de8e9b1e62f83c9e1a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(closing_selector=openingSelector,&amp;nbsp;buffer_closing_selector=closingSelector)&lt;/code&gt; begins by calling &lt;code&gt;closing_selector&lt;/code&gt; to get an Observable. It monitors this Observable, and, whenever it emits an item, &lt;code&gt;buffer&lt;/code&gt; creates a new array, begins to collect items subsequently emitted by the source Observable into this array, and calls &lt;code&gt;buffer_closing_selector&lt;/code&gt; to get a new Observable to govern the closing of that array. When this new Observable emits an item or terminates, &lt;code&gt;buffer&lt;/code&gt; closes and emits the array that the Observable governs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e14b0f10edb4752edcbe58757c5d212bbc1279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;List&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;List&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2056abba30f4856c7d26994b3b4bbf8b8a30285a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;vector&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;vector&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee3ca99f3c9242184fe103637a7205a45e39454" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;List&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22dda51013aba339b4f5301fae6b2e4da5eccb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;vector&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583f8a99c7e6fa0453a17cde605fa702f865a085" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa2109d7bb913a1ea95726f4100c1cebac8aa2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit, count&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491a83da4e4bb96760c09269a5758b2ad4a9dafe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fa6aff05106cdc04eb3c628a3821de1a4df244" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift, unit)&lt;/code&gt; creates a new &lt;code&gt;List&lt;/code&gt; of items every &lt;code&gt;timeshift&lt;/code&gt; period of time, and fills this bundle with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; time has passed since the bundle&amp;rsquo;s creation, before emitting this &lt;code&gt;List&lt;/code&gt; as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b98a3f859f7bbc620366a633025b1515dde55a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift=timeshift)&lt;/code&gt; creates a new array of items every &lt;code&gt;timeshift&lt;/code&gt; milliseconds, and fills this array with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; milliseconds have passed since the array&amp;rsquo;s creation, before emitting this array as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0533305f953f0a309e5df453b9e133d20568e589" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; Scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e360891f0984ef4090aa7ada4740dcbb4f704617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8371395551452bb18051c520c2f4b5a089268672" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit, count)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; has elapsed since its last bundle emission, it emits a bundle of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065b6459d070388eac1369f1d551fcb749fb19e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c3817e4bc1a4a104318a507d1f1df1dcce46ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer&lt;/code&gt; requires one of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f240d669d61624f913fe346aa844fe8dd4cbf0fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount(count)&lt;/code&gt; emits non-overlapping buffers, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted buffer may contain fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a77fe8590e836748bec1afceb482424cc55b73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and a new one for every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones, emitting each buffer when it is complete. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d936831debc89a8b2338b3a3007dc091decf55f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725109d45ba1846de8a6b8392b6391092d1a98ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime(timeSpan)&lt;/code&gt; emits a new collection of items periodically, every &lt;code&gt;timeSpan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6826b6f33554f8fb1de2ebf021c2cadcb4cd9c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime(timeSpan, timeShift)&lt;/code&gt; creates a new collection of items every &lt;code&gt;timeShift&lt;/code&gt; milliseconds, and fills this bundle with every item emitted by the source Observable from that time until &lt;code&gt;timeSpan&lt;/code&gt; milliseconds has passed since the collection&amp;rsquo;s creation, before emitting this collection as its own emission. If &lt;code&gt;timeSpan&lt;/code&gt; is longer than &lt;code&gt;timeShift&lt;/code&gt;, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d0e7bcf4ac65e74eca9ba20646e209c2c82ff0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime&lt;/code&gt; and &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5725f9a1a6a7c85dc4d290333be130a63966d6a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime&lt;/code&gt; and &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; require one of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29da60953849f79c94578371fc21981b0e02a7a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTimeOrCount(timeSpan, count)&lt;/code&gt; emits a new collection of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timeSpan&lt;/code&gt; milliseconds have elapsed since its last collection emission, it emits a collection of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa343001bbb40cc3e8b3cc541b1d7a9764e511ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_count(count)&lt;/code&gt; emits non-overlapping buffers in the form of arrays, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted array may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b64633ff8b9b99511e1f91464f9c7b8f23d5b394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_count(count, skip=skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as arrays. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6265be2e09c0f88dba2c30d63bf9e68b96a9c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; emits a new array of items periodically, every &lt;code&gt;timespan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c21c1882f580b27cb8db9eac720ea9eaf14d8e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; emits a new array of items periodically, every &lt;code&gt;timespan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dedb9b5d750555c146f9ea815130104bd7cdac7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time_or_count(timespan, count)&lt;/code&gt; emits a new array of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; milliseconds have elapsed since its last bundle emission, it emits an array of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8efbc0dfab77384e5695e0391a88f43d1c0aa03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt;/&lt;code&gt;switchCase&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ab85f941795ebebc7621966c024835b3854ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eada5ba41149936eb42223cb804a2da3d2fb07e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collect&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e34bcdea7b0a4428fe34327e1ecd484b3e7fa08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; and &lt;code&gt;concatAll&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4f8fb42b68e7c7b7e5316591de9ce7532f3f71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; takes a variable number of Observables (or Promises) as parameters (or a single array of Observables or Promises), and concatenates them in the order they appear in the parameter list (or array). It exists as both an Observable prototype method and as an instance method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a05f7b7657968ed6c712decc49d7b955c8b6966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatAll&lt;/code&gt; is an instance method that operates on an Observable of Observables, concatinating each of these Observables in the order they are emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66c4829b49a33917cc27c0640b2259d52e1e55f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatAll&lt;/code&gt; operates on an Observable of Observables, concatinating each of these Observables in the order they are emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0409c43e5cc9d6d379c8bea27199652abd6f255" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d029702d3e9b15b15c6b4d30027e9cc6d70b4e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatMapObserver&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb35a6a3b4f9a20c3186e62ff7a21cb33bee0fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connect&lt;/code&gt; is found in the following packages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9640f1d7fa4ad35d3539ac1d849fef7fe71caa33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connect&lt;/code&gt; requires one of the following packages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e5e027558b94847fe199fe7233b289d43c3988" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contains&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02a10531ba2d78eaba589a48c7af53fab6e76c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; is part of the following packages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fcbf042928888fd25281733fb74efa8027c00f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; requires one of any of the following packages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6fbc195a31b898bd2620e8000a89499dcc9336" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9606d8bf5fdf3394981d341c49d099b55449f265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb2205ee6a769cc0527dc0468e5653d34418731" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounce&lt;/code&gt; and &lt;code&gt;debounceWithSelector&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ec38915190181a63aae2734403ec6811aa79ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultIfEmpty&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0501ae0183e1bc12b30af5067f70d83fa221b7e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; does not by default operate on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4d06d8cc0b00cad69791240d6a9faa69aef0a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0453f1952ccc6ca5fae76fdaa5a6430077591489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delay&lt;/code&gt;, &lt;code&gt;delaySubscription&lt;/code&gt;, and &lt;code&gt;delayWithSelector&lt;/code&gt; require &lt;code&gt;rx.lite.js&lt;/code&gt; or &lt;code&gt;rx.lite.compat.js&lt;/code&gt; and are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a42e6eae40facebfc9412f8cd67d437d4ba55fa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delaySubscription&lt;/code&gt; is similar to &lt;code&gt;delay&lt;/code&gt; but rather than timeshifting the emissions from the source Observable, it timeshifts the moment of subscription to that Observable. You pass to this operator a time value (either a &lt;code&gt;Number&lt;/code&gt;, in which case this sets the number of milliseconds of delay, or a &lt;code&gt;Date&lt;/code&gt;, in which case this sets an absolute future time at which &lt;code&gt;delaySubscription&lt;/code&gt; will trigger the subscription). You may optionally pass a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as a second parameter, which &lt;code&gt;delaySubscription&lt;/code&gt; will use to govern the delay period or trigger time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7adbe72591784b4a714d2eb115365bb13e4cea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delayWithSelector&lt;/code&gt; is like &lt;code&gt;delay&lt;/code&gt; but does not use a constant delay duration (or absolute time), but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85526d492d5d878f590368951b13d664cbf0ab56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70c73d8be9dbb0a7ddccccd361323bf2f38ab4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca4c8f4b2a43c908128d7d73fdfa0aeec78bd21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; reverses this process: converting the emitted &lt;code&gt;Notification&lt;/code&gt; objects from the source Observable into notifications from the resulting Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df41a1151275a1c436292bf439c78eb32a392ec7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; reverses this process: converting the emitted &lt;code&gt;Notification&lt;/code&gt; objects from the source Observable into notifications from the resulting Observable. The following example dematerializes the materialized Observable from the previous section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575b0cbaa7c437c082382619ee3d2b599c5d8aa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinct&lt;/code&gt; and &lt;code&gt;distinctUntilChanged&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f65514f172ddc744697e1b142c1194449befad2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinct&lt;/code&gt; and &lt;code&gt;distinctUntilChanged&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a0882d7b2db85098410d045d7dff19792f7aa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;/&lt;code&gt;tap&lt;/code&gt;, &lt;code&gt;doOnNext&lt;/code&gt;/&lt;code&gt;tapOnNext&lt;/code&gt;, &lt;code&gt;doOnError&lt;/code&gt;/&lt;code&gt;tapOnError&lt;/code&gt;, &lt;code&gt;doOnCompleted&lt;/code&gt;/&lt;code&gt;tapOnCompleted&lt;/code&gt;, and &lt;code&gt;finally&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba28eb2a98755e124f1d52b5b9dcc8bd04262dc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;doWhile&lt;/code&gt; is found in each of the following distributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aee9c417fde4cd2d46ade859aa7f69f1f2a52e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; and &lt;code&gt;elementAtOrDefault&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e41302836be86491f3b9837b34145fcc104fcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d85c47be76d2b86ddbf1d36c82dae7e0563118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1144ef5b59f5d111eb78cf1787143dd56d384a19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;every&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3575ee1fc6c15b236ec3868735424258902118a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c7c4225690df0f39e51c9f6112ab29eac89a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; requires one of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd400c1c5833ab09d2d1362e8821a842f57ba3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4160a64d95ca2627e911591e307254638dca079" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b415955a2aa1c5cbed5857327ffa9aa9dba51fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finallyDo&lt;/code&gt; is deprecated since RxJava 1.1.1, in favor of &lt;code&gt;doAfterTerminate&lt;/code&gt; with the same behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5fe9a72c0b449743099df91b382964ece8478c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt;, &lt;code&gt;findIndex&lt;/code&gt;, and &lt;code&gt;first&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9e2cc1497254c384bab408eec27fc4e6d63a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findIndex&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2968359c689419c3b851f5749fe9db70e799191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, &lt;code&gt;single&lt;/code&gt;, &lt;code&gt;singleOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc69e12ef4eb80735da7a8ffa7381624d352d14e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;firstOrDefault&lt;/code&gt; also has a variant to which you can pass a predicate function, so that its Observable will emit the first item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;, or the default item if no items emitted by the source Observable pass the predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f0ceae9a2712cef444daa2be24a1a18e0220a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73ed2b1d04a2afe67083d006a5767d38008225d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; works just as well if the function you provide transforms items from the source Observables into Observables, into Promises, or into arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e16d10a285700e7dab486c58a155a35a9ce31e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapLatest&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c825a3961cc54c6c6ef805e3fd98b58b8f603ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapObserver&lt;/code&gt; creates (and flattens) a new Observable for each item &lt;em&gt;and notification&lt;/em&gt; from the source Observable. It accepts a different transformation function to respond to &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt; notifications and to return an Observable for each.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51b699df8e1441a48690c6b1971732a8b76801f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapObserver&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef78b641e6d3a740830c8f89647cba368bc89806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatten&lt;/code&gt; takes as its parameter an Observable that emits Observables. It merges the items emitted by each of these Observables to create its own single Observable sequence. A variant of this operator allows you to pass in an &lt;code&gt;Int&lt;/code&gt; indicating the maximum number of these emitted Observables you want &lt;code&gt;flatten&lt;/code&gt; to try to be subscribed to at any time. It it hits this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f490d9df4739ffcbdfd79e77f05c1a12ad66261d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flattenDelayError&lt;/code&gt; is similar to &lt;code&gt;flatten&lt;/code&gt; except that it will always emit all items from all of the emitted Observables even if one or more of those Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification before the other Observables have finished emitting items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c2292ff2aabdc802f42755a7f15ac367b4fbc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e1a4342d8e23599b8291e0535a43c3e1c8b990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, however you can pass the variant that converts a Future a Scheduler as an optional second parameter, and it will use that Scheduler to govern the Future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df439cbc86cf0b9ba3bedfa57ed66e6100a4072" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65f1e48b7bb0d9d9d719896dcd792a4cfc83fec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromCallback&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a72db4b80dc8bad54f16580c97b432c8b2daadb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07265cef8fee5d99da56092ca85c52c79f93584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromNodeCallback&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2ed748a3852498d48388eaf367201f153d93fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromPromise&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3520858faf7a23e64e6c3d2f6e3307fbd26f8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generate&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0afae411108bbc561cc1122700b256b35c45fbaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; is found in the following distribution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52da1d549ee7151f9db69e4a561c0990d7a46355" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generateWithRelativeTime&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a23135807c49156cdc8b6752177c1f0c084e2c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupBy&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ad833301d1835f103f1baa096fee152ae86986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupBy&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3a79fda5beb1254249bb177d0da34e38313a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupByUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0893202a0ecab0d0f8ea3b772158225e7098703c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupJoin&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f5d0735a424248247ad9aae5cc496d8ece526a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477fd73d586b9fcbec825cd0ec0de785a84f39a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignoreElements&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69048ec3ceda893dbaff054dda9cc09355fcca6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignoreElements&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf6f3923e8284b46d6b215d9e7373efbab268c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indexOf&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccd0f02c09cee4ec7aa4d5fa8f66c339d4d6f8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interleave*&lt;/code&gt; is similar but operates on an Observable of Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b50914802b5744bb9a29e53495e66d8ae29742e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interleave&lt;/code&gt; is like &lt;code&gt;merge&lt;/code&gt;, but more deliberate about how it interleaves the items from the source Observables: the resulting Observable emits the first item emitted by the first source Observable, then the first item emitted by the second source Observable, and so forth, and having reached the last source Observable, then emits the second item emitted by the first source Observable, the second item emitted by the second source Observable, and so forth, until all of the source Observables terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7264e5224d0efb5bbea1588870c9d1c16097664b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f6fbc36a92a3bb6ea90875470f4264e24b6511f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There are also variants that allow you to set the Scheduler by passing one in as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4788908a9674cee42b2359c4082011fd9d64a96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; operates by default on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can optionally pass in a different Scheduler as a second parameter, and &lt;code&gt;interval&lt;/code&gt; will operate on that Scheduler instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45aed2147ce95798c6a80412108c06c33d406eaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isEmpty&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396a69205a9eb0971c9c7f55db588708f79c4271" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&lt;/code&gt; and &lt;code&gt;groupJoin&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0266ff7e3c64a16c14367e7d9c449c8da592883a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a69e5a2478476a9c491318f02a1ebcb2c00072d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jortSort&lt;/code&gt; and &lt;code&gt;jortSortUntil&lt;/code&gt; are found in the following distribution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9b0c411484d69c52e4c13d11908433ad2a8d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;just&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d74f67c03c213281eab1d7970a0f0aa9fb5f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a533c3a569a685efc0f2ff08c697bf6945290e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a36090f51769beb59adcc22b7e8c1ea2e87040" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastOrDefault&lt;/code&gt; also has a variant to which you can pass a predicate function, so that its Observable will emit the last item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;, or the default item if no items emitted by the source Observable pass the predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aacfc7731f6c17a90c6eb8a8408b8626b6b4c65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; internally transforms each item emitted by the source Observable into an Observable that emits that item and all items subsequently emitted by the source Observable, in the same order. So, for example, it internally transforms an Observable that emits the numbers 1,2,3 into three Observables: one that emits 1,2,3, one that emits 2,3, and one that emits 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852bf5291fc644db30f6e600aef002fc5fd9aca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09057d142824186fbe022f1998c81ae84e72dcae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; requires one of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1e17116f83269cfcbfba129278c4ac51598937" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt;/&lt;code&gt;select&lt;/code&gt; and &lt;code&gt;pluck&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48520b92abdd1b6f13c2e1a944c18d0136643e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;materialize&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03109dd70ccd2d5f3ce0b4ab597c88f2b1775f8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max&lt;/code&gt; and &lt;code&gt;maxBy&lt;/code&gt; are found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177fec1f130af6e4eaca7a4228a28a204b1d0476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxBy&lt;/code&gt; emits a list. If more than one item has the maximum key value, each such item will be represented in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027592fb8ecb9365d5e058e59e73870c0dd9b14f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge*&lt;/code&gt; converts an Observable that emits Observables into a single Observable that emits all of the items emitted by all of the emitted Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15ed57f77ad2ac1e3613ef0567150f3e1436e28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge-delay-error*&lt;/code&gt; is a similarly-modified version of &lt;code&gt;merge*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67f6049e6dc049459c7c289d724002ca5233350" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge-delay-error&lt;/code&gt; is like &lt;code&gt;merge&lt;/code&gt;, but will emit all items from all of the merged Observables even if one or more of those Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification while emissions are still pending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7977d5c910e7ed3bb342e6e05eb0de4027e714" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; converts two or more Observables into a single Observable that emits all of the items emitted by all of those Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b76e9c0a1d27549afef80505e42f88c49ea336f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; merges a second Observable into the one it is operating on to create a new merged Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6eb56447889e6eff2f5548660c3d51a27016c77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; takes a second Observable as a parameter and merges that Observable with the one the &lt;code&gt;merge&lt;/code&gt; operator is applied to in order to create a new output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="614290ed812f3587868cc3180159ce55ec920f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; takes as its parameter an Observable that emits Observables. It merges the items emitted by each of these Observables to create its own single Observable sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf87e244577c5c553ce2ac58ddee944690c8ba13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0395844b120445f674db48bf21d82e4cc405b67e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; is like this second variant of &lt;code&gt;merge&lt;/code&gt; except that it does not allow you to set this maximum subscription count. It only takes the single parameter of an Observable of Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97640809c79f9e4649a2564f86200103b701783" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; behaves much like &lt;code&gt;merge&lt;/code&gt;. The exception is when one of the Observables being merged terminates with an &lt;code&gt;onError&lt;/code&gt; notification. If this happens with &lt;code&gt;merge&lt;/code&gt;, the merged Observable will immediately issue an &lt;code&gt;onError&lt;/code&gt; notification and terminate. &lt;code&gt;mergeDelayError&lt;/code&gt;, on the other hand, will hold off on reporting the error until it has given any other non-error-producing Observables that it is merging a chance to finish emitting their items, and it will emit those itself, and will only terminate with an &lt;code&gt;onError&lt;/code&gt; notification when all of the other merged Observables have finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a167493a245b87e171e08f6f02fdf1ad8bc9e2ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; has fewer variants. You cannot pass it an Iterable or Array of Observables, but you can pass it an Observable that emits Observables or between one and nine individual Observables as parameters. There is not an instance method version of &lt;code&gt;mergeDelayError&lt;/code&gt; as there is for &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0cfd0dcaa2b00079a42cbbc16dfd8134a7228f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df4328bd8b1f65ea0f113efcd6669bdfaa33239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; is similar to &lt;code&gt;merge&lt;/code&gt; except that it will always emit all items from both Observables even if one of the Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification before the other Observable has finished emitting items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82f40498bf692a5a78433f62179f34c2ce3ab0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_all&lt;/code&gt; and its alias &lt;code&gt;merge_observable&lt;/code&gt; take as their single parameter an Observable that emits Observables. They merge the emissions of all of these Observables to create their own Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6c5d2e202b7b40759b72a1934f54b5e9a83c2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_all&lt;/code&gt; is like &lt;code&gt;merge_concurrent(1)&lt;/code&gt;. It subscribes to each emitted Observable one at a time, mirroring its emissions as its own, and waiting to subscribe to the next Observable until the present one terminates with an &lt;code&gt;onCompleted&lt;/code&gt; notification. In this respect it is more like a Concat variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b205f7b96cb7796621bb13f277b683df3a9c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_concurrent&lt;/code&gt; operates on an Observable that emits Observables, merging the emissions from each of these Observables into its own emissions. You can optionally pass it an integer parameter indicating how many of these emitted Observables &lt;code&gt;merge_concurrent&lt;/code&gt; should try to subscribe to concurrently. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification. The default is 1, which makes it equivalent to &lt;code&gt;merge_all&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6a4567c47afea1f9ff91a96e2a66d903320fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&lt;/code&gt; and &lt;code&gt;minBy&lt;/code&gt; are found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe33d78b21d502ce077f3e6214cf1f1e0a7a2b32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minBy&lt;/code&gt; emits a list. If more than one item has the minimum key value, each such item will be represented in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f478b05a123aaaa05e677793d3fd97a7fc5e6e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;never&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1866924109e9670646683e6e6766eb97e7a636" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observeOn&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14dc5b4b8485471c8c4af3ad8e073920b5b1958d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a718b7958aac2f3f301ac09717b03f007e843a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ofType&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897f67f71a1a6044cc793578bc84958ce3a7edc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureBuffer&lt;/code&gt; maintains a buffer of all unobserved emissions from the source Observable and emits them to downstream observers according to the requests they generate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae0fdf6c6ae888dae1f1dca903ede5835c8e193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureDrop&lt;/code&gt; drops emissions from the source Observable unless there is a pending request from a downstream observer, in which case it will emit enough items to fulfill the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dad14f2756c6a7c1c084ae4a7d8630d2936a429" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureLatest&lt;/code&gt; (new in RxJava 1.1) holds on to the most-recently emitted item from the source Observable and immediately emits that item to its observer upon request. It drops any other items that it observes between requests from its observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb4b05219c46f2a0b6b1c9f6f952ca7e8293a54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorFlatMap&lt;/code&gt; handles a special case: a source Observable that is noncompliant with &lt;a href=&quot;../contract&quot;&gt;the Observable contract&lt;/a&gt; in such a way that it may interleave &lt;code&gt;onError&lt;/code&gt; notifications with its emissions without terminating. This operator allows you to replace those &lt;code&gt;onError&lt;/code&gt; notifications with the emissions of an Observable of your choosing without unsubscribing from the source, so that any future items emitted from the source will be passed along to observers as though the sequence had not been interrupted with an &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b872759b6ef289a58cf969ce8164979b4a51e72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ce8ec757b038f51c2a32661634197b973e09f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt; and &lt;code&gt;onError&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7ec9d67ac28a19f77f9e07b0ebd85713ac02e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e4196398c53c4e2d07989c689f8952690797af5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairs&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c770e3f67c8bd25718da8165ccdb6ade967737f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition-all&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;step&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;step&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;n&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;step&amp;nbsp;=&amp;nbsp;n&lt;/code&gt; (which is the default if you omit the &lt;code&gt;step&lt;/code&gt; parameter) then the window size is the same as the step size and there will be a one-to-one correspondence between the items emitted by the source Observable and the items emitted by the collection of window Observables. If &lt;code&gt;step&amp;nbsp;&amp;lt;&amp;nbsp;n&lt;/code&gt; the windows will overlap by &lt;code&gt;n&amp;nbsp;&amp;minus;&amp;nbsp;step&lt;/code&gt; items; if &lt;code&gt;step&amp;nbsp;&amp;gt;&amp;nbsp;n&lt;/code&gt; the windows will drop &lt;code&gt;step&amp;nbsp;&amp;minus;&amp;nbsp;n&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84833cea1699df3f9c2492c38f87c6af17d1f1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but there is a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eafc670c3b2d8e5043fd46a8907dcc34eb1f5b13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517b7b00820d459d58d54fad2526893d4209d655" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; operates by default on the &lt;code&gt;currentThread&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but there is a variant that allows you to set the Scheduler by passing one in as the optional third parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05f7cc6a3cc8526b6a38205df25a5634604f34d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d54f7eb381b9a648070132276d93e7ee0df8d0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657f9e448cd627b5f491b7783525a31edf1ce8b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; requires one of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0129da905d929db4ea918fd5191306e7b396dbfb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refCount&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8010dd75a4a1c1c6ac0ecdc7cdf94b599657a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeat&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0999f08cc9f2ca4d3eeb983282250b4bcab5e4a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeat&lt;/code&gt; operates by default on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There is also a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161c846b7dafa9a83956414dd4c228d2f2b26cde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeatWhen&lt;/code&gt; operates by default on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There is also a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b5f2f16447f11ba64e3a948984ca696d80d8a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replay&lt;/code&gt; and &lt;code&gt;shareReplay&lt;/code&gt; are found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00fe8d32c6838f3365164673884bc9df59b8c18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; by default operates on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76be19f4fc07a54681d48e171bccef56c65fb404" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd834c8bce0a7dab20890b38a2731341bb7b199" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single argument, a count of the number of times it should try resubscribing to the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ac3633b230eaa4da4ae659b81b5fd1fd01a960" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single optional parameter, a count of the number of times it should try resubscribing to and mirroring the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78968626021de35abce2defdd55ea6bc88f55708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single optional parameter, a count of the number of times it should try resubscribing to and mirroring the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers. If you omit this parameter, &lt;code&gt;retry&lt;/code&gt; will attempt to resubscribe and mirror indefinitely, no matter how many &lt;code&gt;onError&lt;/code&gt; notifications it receives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3bb930ea61541d82eaef3c327715478723458b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retryInfinitely&lt;/code&gt;, on the other hand, will attempt to resubscribe to and mirror the source Observable indefinitely, no matter how many &lt;code&gt;onError&lt;/code&gt; notifications it receives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaab55adc8c8a728f1f75c3bb1edfb90ef94d65c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retryWhen&lt;/code&gt; by default operates on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, and there is also a version that accepts a Scheduler as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4120f82ca0762ba3c67980e47fd96b3d4ff4e869" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;/&lt;code&gt;just&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6865b6419ccb621e514ec4fb6db7f12fbeb36594" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;/&lt;code&gt;just&lt;/code&gt; operates by default on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can also pass in a Scheduler of your choosing as an optional second parameter, in which case it will operate on that Scheduler instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4047a0ea36585603f6ec748627509f0b4a9855" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.async.compat.js&lt;/code&gt; (requires &lt;code&gt;rx.binding.js&lt;/code&gt; and either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d0dd6df299ad0b8c56978d03652785c9ad339a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.async.js&lt;/code&gt; (requires &lt;code&gt;rx.binding.js&lt;/code&gt; and either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39644825f66c15f5ee185ab93766411f09e927f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93ed12dffc1802ecae7f2aae2ec6a8f70ebd5be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b53d4d110e21e5825ad980e2a5e7cb13d935856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2cc3de70d097deb29bf9d0c5b850ca4930bbc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires either &lt;code&gt;rx.lite.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2357fcc02566cafce52d99070b5f15ba04fcac3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.experimental.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80c6ea09cb52e61d700bbdb778801b2438d5986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.experimental.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc8c4efacdb08ca9c78c34c4d28e124e3430c88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6345f31b107cb0269a8802101482908e912220" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2f74b508eb1599da60aa8c859b12c78401a19f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ebf3cb3c682607b13423bb830edbe481a23fde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.timejs&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4cf9e648d81d20eae0105dc67ee6d7971f1afe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sample&lt;/code&gt; and &lt;code&gt;throttleFirst&lt;/code&gt; operate by default on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. They are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9642d89ad52f3aff730c9fe3b50d35f97e92dedf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scan&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becbe9059426bc4fdaba799ee68f66c3ae0ff3d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1811fd6d4b8cc5e673ff4d9dd6085e1bd30090" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; requires one of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c4ac4b83afedf5680116e88c507a16fc48b2f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share&lt;/code&gt; and &lt;code&gt;shareValue&lt;/code&gt; are found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a461966af16fa4245c4bf73e1a8c7b411d6636cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;single&lt;/code&gt; also has a version that accepts a predicate, and emits the sole item emitted by the source Observable that matches that predicate, or notifies of an exception if exactly one such item does not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb3c85771d4d9bde7a35c9a62319373f3d8d96cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;single&lt;/code&gt; also has a version that accepts a predicate, and returns the sole item emitted by the source Observable that matches that predicate, or throws an exception if exactly one such item does not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6b89edd7f0936e1694c251ce2e83ac36b9534cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skip&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7842b740b14a1bb4f092eb32d23be6838b6de48c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLast&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd24cf6d6309824f9efd2307264bd0c82d87abd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLastWithTime&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional second parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0ea964517cee199a2e9698d0f8b9b282d1a2d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLastWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f855d9577dee628df260ad5b16cd6e2f479e252e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntil&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efb342bef695a8ba90ab5c3a186c1d1e80d96db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0054a1a7c41a519ebdff4961eb2a9c6387f209df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntilWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aedae37e764a8cae3228eb19bf3866cfec747304" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipWhile&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d271030a25e4748daf89de63d1f23c0bf647fd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipWhile&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d8fb08b646ff0db07c057e6b35171eb8becd51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sliding(timespan,timeshift,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sliding(timespan,timeshift,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d6b6f01fe681143dafffd2ce2f286570c01a2fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sliding(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sliding(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="340607a150f05545c373687c169c0693f97e838b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;Seq&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e800efd9702220c22509e95b689d97ed23b2e491" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(openings,closings)&lt;/code&gt; monitors the &lt;code&gt;openings&lt;/code&gt; Observable, and, whenever it emits an &lt;code&gt;Opening&lt;/code&gt; item, &lt;code&gt;slidingBuffer&lt;/code&gt; creates a new &lt;code&gt;Seq&lt;/code&gt;, begins to collect items subsequently emitted by the source Observable into this buffer, and calls &lt;code&gt;closings&lt;/code&gt; to get a new Observable to govern the closing of that buffer. When this new Observable emits an item or terminates, &lt;code&gt;slidingBuffer&lt;/code&gt; closes and emits the &lt;code&gt;Seq&lt;/code&gt;that the Observable governs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a2d8b32d98cd2d85f509ed919d5b6fe0c839176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(timespan, timeshift)&lt;/code&gt; creates a new &lt;code&gt;Seq&lt;/code&gt; of items every &lt;code&gt;timeshift&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;), and fills this buffer with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; (also a &lt;code&gt;Duration&lt;/code&gt;) has passed since the buffer&amp;rsquo;s creation, before emitting this &lt;code&gt;Seq&lt;/code&gt; as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24dd0a01354cced0a2acf0aa8063d70ee7f154a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed91665030b67875ffc98a470567ddb8eb0537e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startAsync&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7557812c5d12bce96afff2c6f2acef59e4f6bf67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startWith&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a9ba7e0e5a1992b4c0bbcf9fa451a208dde737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeOn&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82eb96c199934418a5718cf08684f1241d7a926" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sum&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70375bcfc9c823861ed0e18d51cf92d8acf08eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1afa68f56894c76f703ac9f3769b28164434fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4525d7b7fbc759ff9dd8eb06674f4280a9073b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLast&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2941ac03f0842c43596c3b89634f04257ea7c68b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBuffer&lt;/code&gt; also has its duration-based variant, &lt;code&gt;takeLastBufferWithTime&lt;/code&gt;, which is similar to &lt;code&gt;takeLastWithTime&lt;/code&gt; except that it emits its items not individually but collected into a single array of items that is emitted as a single item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5a21060536e4921b09043d6957f61a67e85859" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBuffer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02450ab9c999ca1cdd1497e8d7bf3269e1ad1a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBufferWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b665df985a737dfb05ba93333df8ea966170a9ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastWithTime&lt;/code&gt; by default operates the timer on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; and emits items on the &lt;code&gt;currentThread&lt;/code&gt; Scheduler, but you may also pass in Schedulers of your choosing to override these, as an optional second and third parameters, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14da141683decf3ce03f63343d83fd24c709bfb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20c87a0557376049c73e16b9f4ff3c38215594a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d6c84288e3575f42359e8018cdff6b7b45d977" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9042095065b7d2b25a7d1e092da6338622f2d9fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntilWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb79aed0b0d7386fc7de8e365183d8e2e8e7ca97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df06abff8c84fc5b0f1f4a67410984a32d92db1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8ebe39bb4a1d479f5ac26c962f779363985e11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttleFirst&lt;/code&gt; operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can optionally pass in a Scheduler of your choosing as a third parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58e7fab93ffb2601599bf75a4c5989ad7f8b9cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throw&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fb397d3568ae4d036414110394066d39b1ed4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; by default operates on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="757c130c5ec90e41b55716e7d8ceb364f6a8e288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b3b52092b0ce3ee3f4d96c9a24a943c2d938d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b213b55f226a478725826835dafe9681d5f8644" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;timeoutWithSelector&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce975a53ac15047ca82f47b9d9d146a0d85da69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeoutWithSelector&lt;/code&gt; does not use a constant timeout duration, but sets its timeout duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. If any such Observable completes before the source Observable emits another item, this is considered a timeout condition, and triggers an &lt;code&gt;onError&lt;/code&gt; notification (&amp;ldquo;&lt;code&gt;Error: Timeout&lt;/code&gt;&amp;rdquo;) from the Observable &lt;code&gt;timeoutWithSelector&lt;/code&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73773bfa5b563e9eba5535983817af426985e541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can override this by passing in a Scheduler as a final parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cbc3a49fd6d590f7657eb64c4bf3aee582bf2ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can override this by passing in a Scheduler as a final parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166b0d0c1925597895a20348e99d636f269ba52f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6994ab170fc57b3c6ae8b13a3eb78514353eada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; returns an Observable that emits a single number zero after a delay period you specify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d152bee231bbb8e03f92f397a5f47c8bc06dd80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; by default operates on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; but also has a variant that allows you to choose the Scheduler by passing it in as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4b64c965f491d895a7583ac5fd6181c6b636c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cd8475782d97de9ca5e1e58e9b309ed7b54305" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c19fb0c2dc91fdd7ff204e2e2b3dde5ed1cea6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toArray&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2436f143a44933d4ae386a7d36228fa95d3b9e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toAsync&lt;/code&gt; is found in the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf929490433a6f89a9386a35013a74f1cafb6c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toList&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480dfc94c15fb8040d8e100d3fa4d5194e955fdd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMap&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c39b03d1c2b125af83fb8e2d096e30c15ec785" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac9c9dc84a67060553324ea4b1a5883b58175151" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMultiMap&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea2ad74dcc9fb9b4b1703685d68edf066c0841f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toSet&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7965f3d811250e08e8d9ceb0744100f593b518" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toSortedList&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46584cfb17a9dfd026e64a70ece0028c2345433e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumbling(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tumbling(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="946b7fdda870bee85c6810d8f4b8baea15808387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumbling(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tumbling(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="114b0ca34209466be8813d092973923f1b9b4190" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(boundary)&lt;/code&gt; monitors an Observable, &lt;code&gt;boundary&lt;/code&gt;. Each time that Observable emits an item, it creates a new &lt;code&gt;Seq&lt;/code&gt; to begin collecting items emitted by the source Observable and emits the previous &lt;code&gt;Seq&lt;/code&gt;. This variant of the operator has an optional second parameter, &lt;code&gt;initialCapacity&lt;/code&gt; with which you can indicate the expected size of these buffers so as to make memory allocation more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46125dcac2cbaa797114df6c032348ed56b10dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;Seq&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted buffer may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd1e55878e9963160e69e3e46fbcc3ba5b0c630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(timespan)&lt;/code&gt; emits a new &lt;code&gt;Seq&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;), containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. This variant of the operator has an optional second parameter, &lt;code&gt;scheduler&lt;/code&gt;, with which you can set the &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; that you want to govern the timespan calculation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21cd4f65fc506789ef4e59831405d1e22f95404" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(timespan, count)&lt;/code&gt; emits a new &lt;code&gt;Seq&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;) has elapsed since its last bundle emission, it emits a &lt;code&gt;Seq&lt;/code&gt; containing however many items the source Observable emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. This variant of the operator has an optional third parameter, &lt;code&gt;scheduler&lt;/code&gt;, with which you can set the &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; that you want to govern the timespan calculation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dbb96ec506e9ea7b859c90a031a511f04f5a25b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fe99075e97e899a8a29e4d7d6bbf8bc6656d37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9180af64681c5e6bbe87c5747504627d06e37279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; is found in the &lt;code&gt;rx.experimental.js&lt;/code&gt; distribution. It requires one of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cff6c004ac3784284d1aafacb977d88056d9a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, timeshift, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5feef256593decbc4e3c0668b5c74c2b7542ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, unit, count&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88858274463fe4c29e450ff892be4ab3cdd04ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df2411d37d8d9a19673d8cc2fca09e073fe8588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTime(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTime(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0082a3e53e214cc5277d43c253721adf6ffebe46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTime(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTime(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afd4e92b2e4ccb74b8e4469f1bd7c11303336a25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTimeOrCount(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTimeOrCount(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ba9f5753ce09bb018d7eea164bf09706e308337" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTimeOrCount&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd00380205a686ee17604d17356c523c0e72c3a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(period, skip&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db0580b8d43ac68544b774f2554c7d3ba35e259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(period&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e83f25479adacc961806d24bc915b042ddee0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fee332926b0d48f2889ec46f5f950b3c4e76d18c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89d3d2c45562db6fe6c52b9d1508809b4531e5ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count(period, count&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f76e50530b051a16903cb3a749bbf3d0ebcbc93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="641566bee8a202a27ae03c144854e648d69bf89d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;period&lt;/code&gt; of time (optionally computed by a given Coordination) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c4c18c7ec6364acc53cb5fe05e73f534b19a73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc83188733343337e00c5f1f317f3281f7cb8498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; accepts a variable number of Observables or Promises as parameters, followed by a function that accepts one item emitted by each of those Observables or resolved by those Promises as input and produces a single item to be emitted by the resulting Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e1debe572209b748af04eb0b1aaf0617354592" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; and &lt;code&gt;zipWith&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4541e5aef8fc275a2be0435a981bbc433ea604d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zipArray&lt;/code&gt; accepts a variable number of Observables as parameters and returns an Observable that emits arrays, each one containing the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c6161ea024bd469cc2d9d1691023d9244d7b73" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; item from each source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3866d4dc2075c3f5d0d914e8fb5c6c5cf655d6" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; item that it expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="5a9ea636768e98730048d960cb7b94ce27c67345" translate="yes" xml:space="preserve">
          <source>A Decision Tree of Observable Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b08c72f6a37159d94745e3d486d34e86abda5ad" translate="yes" xml:space="preserve">
          <source>A Single is something like an Observable, but instead of emitting a series of values &amp;mdash; anywhere from none at all to an infinite number &amp;mdash; it always either emits one value or an error notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0a565fcadf77db3f8a879c0832ebb221aa9780" translate="yes" xml:space="preserve">
          <source>A Single will call only one of these methods, and will only call it once. Upon calling either method, the Single terminates and the subscription to it ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59605fccb31cb127c02c09296155efa5fe013b9c" translate="yes" xml:space="preserve">
          <source>A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable. Because it is an observer, it can subscribe to one or more Observables, and because it is an Observable, it can pass through the items it observes by reemitting them, and it can also emit new items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5115867d3f9ec7f7973522f38b1446136baf293" translate="yes" xml:space="preserve">
          <source>A chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate &lt;em&gt;in turn&lt;/em&gt;, each one operating on the Observable generated by the operator immediately previous in the chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa1692172bf25b6129069ba0c0eaa218eb4bcab" translate="yes" xml:space="preserve">
          <source>A more complete &lt;code&gt;subscribe&lt;/code&gt; call example looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0af329e9352bf7003c7730a1fbf549f05c11689" translate="yes" xml:space="preserve">
          <source>A related operator, IsEmpty returns an Observable that emits &lt;code&gt;true&lt;/code&gt; if and only if the source Observable completes without emitting any items. It emits &lt;code&gt;false&lt;/code&gt; if the source Observable emits an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd6fdbcf4ffd98efa9870facaa7222cee24194a" translate="yes" xml:space="preserve">
          <source>A second possibility is to use the &lt;code&gt;windowed(&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="470bb39ca8f873b411a9bf2795442d8e2de5abb2" translate="yes" xml:space="preserve">
          <source>A second variant of &lt;code&gt;forkJoin&lt;/code&gt; exists as a prototype function, and you call it on an instance of one source Observable, passing it another source Observable as a parameter. As a second parameter, you pass it a function that combines the final item emitted by the two source Observables into the sole item to be emitted by the resulting Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80636dd32da61a598e55857994e632bbd4be9e7d" translate="yes" xml:space="preserve">
          <source>A second variant of &lt;code&gt;timeout&lt;/code&gt; differs from the first in that instead of issuing an error notification in case of a timeout condition, it instead immediately switches to a backup Observable that you specify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1014e078d9399bc4430b8c0f57f75f79b89ad343" translate="yes" xml:space="preserve">
          <source>A second version of this operator was released in RxGroovy 1.1. It uses a predicate function that evaluates the items emitted by the source Observable, rather than a second Observable, to terminate the resulting Observable sequence. In this way, it behaves in a similar way to &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a7d4a46c5c7bc15a9d7db1fc1edb5b764d3a73" translate="yes" xml:space="preserve">
          <source>A second version of this operator was released in RxJava 1.1. It uses a predicate function that evaluates the items emitted by the source Observable, rather than a second Observable, to terminate the resulting Observable sequence. In this way, it behaves in a similar way to &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc9c3e84a8e5b9e18d52bf83f76d74a848d15d8" translate="yes" xml:space="preserve">
          <source>A similar operator is &lt;code&gt;ofObjectChanges&lt;/code&gt;. It returns an Observable that emits any changes made to a particular object, as reported by its &lt;code&gt;Object.observe&lt;/code&gt; method. It is also found only in the &lt;code&gt;rx.all.js&lt;/code&gt; distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9b3babb124228b9672822ea408e026abe9f755" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;retry&lt;/code&gt; takes a predicate function as a parameter. You write this function to accept two arguments: an Int count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the &lt;code&gt;onError&lt;/code&gt; notification. This function returns a Boolean to indicate whether or not &lt;code&gt;retry&lt;/code&gt; should resubscribe to and mirror the source Observable. If it does not, then &lt;code&gt;retry&lt;/code&gt; passes the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c9ea5b2183ed2e503c70773c2a45edce947b6d" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;retry&lt;/code&gt; takes a predicate function as a parameter. You write this function to accept two arguments: an Integer count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the &lt;code&gt;onError&lt;/code&gt; notification. This function returns a Boolean to indicate whether or not &lt;code&gt;retry&lt;/code&gt; should resubscribe to and mirror the source Observable. If it does not, then &lt;code&gt;retry&lt;/code&gt; passes the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59dc0040b390fb0df014aee4d31dbc580181dd4c" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;timeout&lt;/code&gt; does not use a constant timeout duration, but sets its timeout duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. If any such Observable completes before the source Observable emits another item, this is considered a timeout condition, and triggers an &lt;code&gt;onError&lt;/code&gt; notification (&amp;ldquo;&lt;code&gt;TimeoutException&lt;/code&gt;&amp;rdquo;) from the Observable &lt;code&gt;timeout&lt;/code&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63b86ec2cc6e89e587945cf3c2a65042288e202" translate="yes" xml:space="preserve">
          <source>A toolbox of useful Operators for working with Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12bf70fec688d32e9df77570a93f7d9de2beb9f6" translate="yes" xml:space="preserve">
          <source>A typical implementation of the Subscribe operator may accept one to three methods (which then constitute the observer), or it may accept an object (sometimes called an &lt;code&gt;Observer&lt;/code&gt; or &lt;code&gt;Subscriber&lt;/code&gt;) that implements the interface which includes those three methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326f047b7addbda19eb8d949bed620511187ece5" translate="yes" xml:space="preserve">
          <source>A variant of distinct that only compares emitted items from the source Observable against their immediate predecessors in order to determine whether or not they are distinct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628cd375e74040d3f1575481baed0a36bf589549" translate="yes" xml:space="preserve">
          <source>A variant of this operator &lt;code&gt;merge(maxConcurrent:)&lt;/code&gt; allows you to pass in an &lt;code&gt;Int&lt;/code&gt; indicating the maximum number of these emitted Observables you want &lt;code&gt;merge&lt;/code&gt; to try to be subscribed to at any time. If it hits this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35ccc7301b7ce4feccd9c396c10c5d8cca3b515" translate="yes" xml:space="preserve">
          <source>A variant of this operator, called &lt;code&gt;ofWithScheduler&lt;/code&gt; takes a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as its first parameter, and operates the resulting Observable on this Scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0925a0e0dd3f224e5197c574ea37e59cffa4f0d" translate="yes" xml:space="preserve">
          <source>A version of the timeout operator allows you to switch to a backup Single rather than sending an error notification if the timeout expires:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c20b67a1841fd8175f5bbf824b5bd0534f744a" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in RxGroovy 1.1 allows you to set the capacity of the buffer; applying this operator will cause the resulting Observable to terminate with an error if this buffer is overrun. A second version, introduced during the same release, allows you to set an &lt;code&gt;Action&lt;/code&gt; that &lt;code&gt;onBackpressureBuffer&lt;/code&gt; will call if the buffer is overrun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f994ec3ff86b720b838d74d54795039e7a5aa034" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in RxJava 1.1 allows you to set the capacity of the buffer; applying this operator will cause the resulting Observable to terminate with an error if this buffer is overrun. A second version, introduced during the same release, allows you to set an &lt;code&gt;Action&lt;/code&gt; that &lt;code&gt;onBackpressureBuffer&lt;/code&gt; will call if the buffer is overrun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17462ee811b15366ad770504e8600c231368974f" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in the 1.1 release notifies you, by means of an &lt;code&gt;Action&lt;/code&gt; you pass as a parameter, when an item has been dropped and which item was dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850d4acf22d3a4e1c03049abdf78b9a93ef3eccf" translate="yes" xml:space="preserve">
          <source>A version of this variant of the operator (still in Beta as of this writing) takes an additional &lt;code&gt;int&lt;/code&gt; parameter. This parameter sets the maximum number of concurrent subscriptions that &lt;code&gt;flatMap&lt;/code&gt; will attempt to have to the Observables that the items emitted by the source Observable map to. When it reaches this maximum number, it will wait for one of those Observables to terminate before subscribing to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf0103a4b2b868a1a60d776479c80ac940f5052" translate="yes" xml:space="preserve">
          <source>A well-formed finite Observable must attempt to call either the observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method exactly once or its &lt;code&gt;onError&lt;/code&gt; method exactly once, and must not thereafter attempt to call any of the observer&amp;rsquo;s other methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653657e1f29569ba5423fd7a08a85817bf13a50d" translate="yes" xml:space="preserve">
          <source>A well-formed, finite Observable will invoke its observer&amp;rsquo;s &lt;code&gt;onNext&lt;/code&gt; method zero or more times, and then will invoke either the &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; method exactly once. The Materialize operator converts this series of invocations &amp;mdash; both the original &lt;code&gt;onNext&lt;/code&gt; notifications and the terminal &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification &amp;mdash; into a series of &lt;em&gt;items&lt;/em&gt; emitted by an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805825d0f7d22f43a512c60285f688fee71614c5" translate="yes" xml:space="preserve">
          <source>Advanced RxJava: Schedulers (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html&quot;&gt;part 1&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html&quot;&gt;part 2&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html&quot;&gt;part 3&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html&quot;&gt;part 4&lt;/a&gt;) by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf48d7677040c3e9d2bf95bb0839fd2703291b5" translate="yes" xml:space="preserve">
          <source>Alias for Map</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba6cd005270d28a5da0365e14fbe1da3cdff860" translate="yes" xml:space="preserve">
          <source>Alias for filter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0fb5d23e5194856f864607d264c2dcc4f20d1e" translate="yes" xml:space="preserve">
          <source>Alias for flatMap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="c80ac46ff1f8aeeb94f7a8999a13b0a1e6062b2c" translate="yes" xml:space="preserve">
          <source>Also in the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxGroovy core there is a specialty mapping operator called &lt;code&gt;byLine&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits lines of text, by buffering the strings from the source Observable until a line-feed is found in one of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4f6274689c272bebb2b489085539520b4a1e6a" translate="yes" xml:space="preserve">
          <source>Also in the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxJava core there is a specialty mapping operator called &lt;code&gt;byLine&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits lines of text, by buffering the strings from the source Observable until a line-feed is found in one of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd5794be8096ff7869d94f283eedcf7b7672bb9" translate="yes" xml:space="preserve">
          <source>Amb</source>
          <target state="translated">Amb</target>
        </trans-unit>
        <trans-unit id="851ac2f8e49b2f26ad526a214ceca7b96c49f162" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AsyncSubject&lt;/code&gt; emits the last value (and only the last value) emitted by the source Observable, and only after that source Observable completes. (If the source Observable does not emit any values, the &lt;code&gt;AsyncSubject&lt;/code&gt; also completes without emitting any values.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd649dc1e5fe644141b9e448ab2c1ac4a152926" translate="yes" xml:space="preserve">
          <source>An Alphabetical List of Observable Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2839cacd293e99aa08485d95a5eaad72408dc3f8" translate="yes" xml:space="preserve">
          <source>An Observable calls this method after it has called &lt;code&gt;onNext&lt;/code&gt; for the final time, if it has not encountered any errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea9db047d5da0996289f4901a31c06634ef96eb" translate="yes" xml:space="preserve">
          <source>An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. It will not make further calls to &lt;code&gt;onNext&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt;. The &lt;code&gt;onError&lt;/code&gt; method takes as its parameter an indication of what caused the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c53d34a4f49cf4f5df1fa4953366bbd8ebe91d" translate="yes" xml:space="preserve">
          <source>An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. This stops the Observable and it will not make further calls to &lt;code&gt;onNext&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt;. The &lt;code&gt;onError&lt;/code&gt; method takes as its parameter an indication of what caused the error (sometimes an object like an Exception or Throwable, other times a simple string, depending on the implementation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d2f09477c8a4f1394bf039fd16d24d7fa53421" translate="yes" xml:space="preserve">
          <source>An Observable calls this method whenever the Observable emits an item. This method takes as a parameter the item emitted by the Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a9dcd358629f823cb0ef4d649474083b6c5bb3" translate="yes" xml:space="preserve">
          <source>An Observable communicates with its observers with the following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a76c3a98e43666ea0eb0740c08e3a7cbd79ab65" translate="yes" xml:space="preserve">
          <source>An Observable is called a &amp;ldquo;cold&amp;rdquo; Observable if it does not begin to emit items until an observer has subscribed to it; an Observable is called a &amp;ldquo;hot&amp;rdquo; Observable if it may begin emitting items at any time, and a subscriber may begin observing the sequence of emitted items at some point after its commencement, missing out on any items emitted previously to the time of the subscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7bf7c542baf1867dd7cef5a402b7db67b5190bd" translate="yes" xml:space="preserve">
          <source>An Observable is the asynchronous/push &lt;a href=&quot;http://en.wikipedia.org/wiki/Dual_(category_theory)&quot;&gt;&amp;ldquo;dual&amp;rdquo;&lt;/a&gt; to the synchronous/pull Iterable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbafffea1979fbff2b9d19c9947eecf861d10073" translate="yes" xml:space="preserve">
          <source>An Observable may begin issuing notifications to an observer immediately after the Observable receives a Subscribe notification from the observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c3d8f2d0e01af84eba974448d28b40c4172a8e" translate="yes" xml:space="preserve">
          <source>An Observable may emit no items at all. An Observable may also never terminate with either an OnCompleted or an OnError notification. That is to say that it is proper for an Observable to issue no notifications, to issue only an OnCompleted or an OnError notification, or to issue only OnNext notifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2b11572810d9a5ac8311dae558136ea173beb4" translate="yes" xml:space="preserve">
          <source>An Observable may make zero or more OnNext notifications, each representing a single emitted item, and it may then follow those emission notifications by either an OnCompleted or an OnError notification, but not both. Upon issuing an OnCompleted or OnError notification, it may not thereafter issue any further notifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645e6d39de346178f5938830b549355de0e6e3e5" translate="yes" xml:space="preserve">
          <source>An Observable that does not implement backpressure should respond to a Request notification from an observer by issuing an OnError notification that indicates that backpressure is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689703d4ac79bcdd377cfb6c92ab325f0021d3b4" translate="yes" xml:space="preserve">
          <source>An OnError notification must contain the cause of the error (that is to say, it is invalid to call OnError with a &lt;code&gt;null&lt;/code&gt; value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff87217adf75afaa1c6885b1ac6c1d5742a3cbd" translate="yes" xml:space="preserve">
          <source>An advantage of this approach is that when you have a bunch of tasks that are not dependent on each other, you can start them all at the same time rather than waiting for each one to finish before starting the next one &amp;mdash; that way, your entire bundle of tasks only takes as long to complete as the longest task in the bundle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85814a55f42e0261226556859d609d250a378ba" translate="yes" xml:space="preserve">
          <source>An even simpler operator in the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package (also not part of the standard RxGroovy set of operators) is &lt;code&gt;ifThen&lt;/code&gt;. This operator checks a condition and then either mirrors the source Observable or an empty Observable depending on the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f829bc7f8186b73be4fd6d24d31abb651902daa" translate="yes" xml:space="preserve">
          <source>An observer communicates with its Observable by means of the following notifications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c74c14e78b3bf3709270805f239144c3e35aa94" translate="yes" xml:space="preserve">
          <source>An optional third parameter (named &lt;code&gt;defaultValue&lt;/code&gt;) allows you to choose an item that &lt;code&gt;first&lt;/code&gt; will emit if the source Observable does not emit any items (or if it does not emit the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16bafd99d71f935206c53ee2503366667c35c3c" translate="yes" xml:space="preserve">
          <source>And importantly: with ReactiveX you can later change your mind, and radically change the underlying nature of your Observable implementation, without breaking the consumers of your Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214cbe57ae28db943c3ec9b46b47b3101daf0c7b" translate="yes" xml:space="preserve">
          <source>And that variant also has a cousin that will switch to a specified backup Observable rather than emitting an error upon hitting a timeout condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd733cd8e342ef935e8375aac0d129d8c255f6b" translate="yes" xml:space="preserve">
          <source>And there is a variant of &lt;code&gt;delaySubscription&lt;/code&gt; that uses an Observable (returned by a function you supply) rather than a fixed duration in order to set the subscription delay.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ee68728e1626f87277753fcdb831fc09c7b3d5" translate="yes" xml:space="preserve">
          <source>And there is also a verion of &lt;code&gt;singleOrDefault&lt;/code&gt; that takes a predicate function and emits the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and makes an error notification if multiple items match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f667a90816681f20bf11089e389629e58978843f" translate="yes" xml:space="preserve">
          <source>And there is also a verion of &lt;code&gt;singleOrDefault&lt;/code&gt; that takes a predicate function and returns the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and throws an error if multiple items match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10883d7bc99bd25d1b6cd9f78cf866a8856bbf98" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;first&lt;/code&gt;, there is a &lt;code&gt;firstOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and retrieves the first item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61cf36b9bbc9f1f59d3790764d487afdbb2624c" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;first&lt;/code&gt;, there is a &lt;code&gt;firstOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and returns the first item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d569317120812ad4b1a0a46c5a1a37fce2c43e2" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;last&lt;/code&gt;, there is a &lt;code&gt;lastOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and retrieves the last item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8251dbbd4d407b2ba611d6bab161e9f49c31af8d" translate="yes" xml:space="preserve">
          <source>And/Then/When</source>
          <target state="translated">And/Then/When</target>
        </trans-unit>
        <trans-unit id="5e3f7fc4502eaa43261cf03af6ffe0dd602b81e7" translate="yes" xml:space="preserve">
          <source>Another variant allows you to instruct &lt;code&gt;timeout&lt;/code&gt; to switch to a backup Observable that you specify, rather than terminating with an error, if the timeout condition is triggered. To use this variant, pass the backup Observable (or &lt;code&gt;Promise&lt;/code&gt;) as the second parameter to &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a94542011650405c857cbde913a1b92445107e" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;Retry&lt;/code&gt; takes a single parameter: a count of the number of &lt;code&gt;onError&lt;/code&gt; notification it should be willing to accept before it too fails and passes the &lt;code&gt;onError&lt;/code&gt; to its observers. For example, &lt;code&gt;Retry(2)&lt;/code&gt; means that &lt;code&gt;Retry&lt;/code&gt; will resubscribe to and mirror the source Observable the first time it receives an &lt;code&gt;onError&lt;/code&gt; notification, but will terminate with an error the second time this happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02efaeb4d2bdd19b23fcdfa7078d0965b0543f39" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;delay&lt;/code&gt; does not use a constant delay duration, but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable emits a item or completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cb02c7b8b0dc8585c179d8f7a980076f44300b" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;delay&lt;/code&gt; does not use a constant delay duration, but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable emits an item or completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e4f38385f3555737f4cc37f65db6f2b2cb3f98" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;retry&lt;/code&gt; takes a single parameter: a count of the number of &lt;code&gt;onError&lt;/code&gt; notification it should be willing to accept before it too fails and passes the &lt;code&gt;onError&lt;/code&gt; to its observers. For example, &lt;code&gt;retry(2)&lt;/code&gt; means that &lt;code&gt;retry&lt;/code&gt; will resubscribe to and mirror the source Observable the first time it receives an &lt;code&gt;onError&lt;/code&gt; notification, but will terminate with an error the second time this happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a31e30b7b7961ac8ac1fd52bd1e592dd652cbb" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;retry&lt;/code&gt; takes a single parameter: a count of the number of times it should try to resubscribe to the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe again and will instead pass the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180c4e210c4586ad6515a4efe0a7bfdaf14fb209" translate="yes" xml:space="preserve">
          <source>Another version combines items from the source Observable with the Observable triggered by those source items, and emits these combinations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3e74fdeb39fa8f79f8b41f914729603db3668b" translate="yes" xml:space="preserve">
          <source>Another version of &lt;code&gt;flatMap&lt;/code&gt; creates (and flattens) a new Observable for each item &lt;em&gt;and notification&lt;/em&gt; from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416f48df8cc3910b8bb048511d0a6e4801002873" translate="yes" xml:space="preserve">
          <source>Another version of &lt;code&gt;groupBy&lt;/code&gt; allows you to pass in a transformative function that changes the elements before they are emitted by the resulting &lt;code&gt;GroupedObservable&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cbe5dee754659834a3070a07a4de32cd17c626d" translate="yes" xml:space="preserve">
          <source>Another version takes two or more Singles and merges them into an Observable that emits the items emitted by the source Singles (in an arbitrary order):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc07229ca716771de12a56cf5816c03a72ab3bb" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e968236df359a0c3a3b48d1101e20c7334bc87e3" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6482ebf54fcf3fef454ac6beb793ddcb408e9393" translate="yes" xml:space="preserve">
          <source>As an alternative to using &lt;code&gt;request&lt;/code&gt; to pull items from a &lt;code&gt;ControlledObservable&lt;/code&gt;, you may apply the &lt;code&gt;stopAndWait&lt;/code&gt; operator to it. This operator will request a new item from the Observable each time its observers&amp;rsquo; &lt;code&gt;onNext&lt;/code&gt; routine receives the latest item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2402a383d153594ac341c580a389f352b429f3" translate="yes" xml:space="preserve">
          <source>As shown in the above diagram, an &lt;code&gt;onError&lt;/code&gt; notification from any of the source Observables will immediately be passed through to observers and will terminate the merged Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2944d9f0e54e8337eac2b3e9e3efb8980e22c066" translate="yes" xml:space="preserve">
          <source>As shown in this illustration, the SubscribeOn operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called. ObserveOn, on the other hand, affects the thread that the Observable will use &lt;em&gt;below&lt;/em&gt; where that operator appears. For this reason, you may call ObserveOn multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90336d424ebddac61136082a2c6d772454fe8231" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;distinct&lt;/code&gt;, there is also a version of &lt;code&gt;distinctUntilChanged&lt;/code&gt; that accepts a key selector function and that uses the resulting key to determine whether or not two adjacently-emitted items are distinct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea92b7b4b8b9fa35e6026e8b95b2e25ebb1fc5c4" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;firstOrDefault&lt;/code&gt; there is also a &lt;code&gt;singleOrDefault&lt;/code&gt; that emits a default item if the source Observable is empty, although it will still notify of an error if the source Observable emits more than one item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d92ac954f9b7869499152c6f9dac87389cc9d017" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;firstOrDefault&lt;/code&gt; there is also a &lt;code&gt;singleOrDefault&lt;/code&gt; that returns a default item if the source Observable is empty, although it will still throw an error if the source Observable emits more than one item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dca8bd3303f27dee6fa18df112035b5a22c5486" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;concatMap&lt;/code&gt; works just as well if the function you provide transforms items from the source Observables into Observables, into Promises, or into arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e9229a21e2a7672f82daa0c3b3a03f4a076628" translate="yes" xml:space="preserve">
          <source>As with the filtering operators, the &lt;code&gt;first&lt;/code&gt; method of &lt;code&gt;BlockingObservable&lt;/code&gt; will throw a &lt;code&gt;NoSuchElementException&lt;/code&gt; if there is no first element in the source &lt;code&gt;BlockingObservable&lt;/code&gt;. To return a default item instead in such cases, use the &lt;code&gt;firstOrDefault&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3967a0eb108ca47a2858158ed9dfb9574c5f8ca" translate="yes" xml:space="preserve">
          <source>As with the filtering operators, the &lt;code&gt;last&lt;/code&gt; method of &lt;code&gt;BlockingObservable&lt;/code&gt; will throw a &lt;code&gt;NoSuchElementException&lt;/code&gt; if there is no last element in the source &lt;code&gt;BlockingObservable&lt;/code&gt;. To return a default item instead in such cases, use the &lt;code&gt;lastOrDefault&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcf5a04971327e7fdf42936464bd21e8b771ab5" translate="yes" xml:space="preserve">
          <source>Aside from passing these Schedulers in to RxJava Observable operators, you can also use them to schedule your own work on Subscriptions. The following example uses &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0)&quot;&gt;the &lt;code&gt;schedule&lt;/code&gt; method&lt;/a&gt; of &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html&quot;&gt;the &lt;code&gt;Scheduler.Worker&lt;/code&gt; class&lt;/a&gt; to schedule work on the &lt;code&gt;newThread&lt;/code&gt; Scheduler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a3a332582f8b7c97ecac0a351df1689bfb7637" translate="yes" xml:space="preserve">
          <source>AsyncSubject</source>
          <target state="translated">AsyncSubject</target>
        </trans-unit>
        <trans-unit id="4cd01c057417c6358415753c1e3270378ba8ff9e" translate="yes" xml:space="preserve">
          <source>At any time after it receives an OnSubscribe notification, an observer may issue a Request notification to the Observable it has subscribed to. This notification requests a particular number of items. The Observable responds to such a Request by emitting no more items to the observer than the number of items the observer requests. However the Observable may, in addition, issue an OnCompleted or OnError notification, and it may even issue such a notification before the observer requests any items at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7c2b7fecd45fc8d48965e405aa02103af88d8a" translate="yes" xml:space="preserve">
          <source>Attach the observer to that Observable by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f86c051ecf0b64e5f8cdc8c689552f42595942" translate="yes" xml:space="preserve">
          <source>Average</source>
          <target state="translated">Average</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="bfded4a21da8efbb2fa839d4b2207399ba6ad7be" translate="yes" xml:space="preserve">
          <source>Backpressure</source>
          <target state="translated">Backpressure</target>
        </trans-unit>
        <trans-unit id="35262f52104832142bf6755bccc1f3e12433d190" translate="yes" xml:space="preserve">
          <source>Backpressure Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2eb3d3593072fa90c30c72ab2ea8bae6bdb0314" translate="yes" xml:space="preserve">
          <source>Backpressure is optional; not all ReactiveX implementations include backpressure, and in those that do, not all Observables or operators honor backpressure. An Observable &lt;em&gt;may&lt;/em&gt; implement backpressure if it detects that its observer implements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17bead9671f0fa78aeae30852ed269b9a2823ed" translate="yes" xml:space="preserve">
          <source>Backpressure-related Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430ace144fb8a573f293eacace0939475b0d212a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;onErrorFlatMap&lt;/code&gt; is designed to work with pathological source Observables that do not terminate after issuing an error, it is mostly useful in debugging/testing scenarios.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd066d9d682432c2ab720b8c76cae63bcdae1811" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;runAsync&lt;/code&gt; immediately invokes the &lt;code&gt;Action&lt;/code&gt; and begins emitting the items (that is, it produces a &lt;em&gt;hot&lt;/em&gt; Observable), it is possible that some items may be lost in the interval between when you establish the &lt;code&gt;StoppableObservable&lt;/code&gt; with this operator and when your &lt;code&gt;Observer&lt;/code&gt; is ready to receive items. If this is a problem, you can use the variant of &lt;code&gt;runAsync&lt;/code&gt; that also accepts a &lt;code&gt;Subject&lt;/code&gt; and pass a &lt;code&gt;ReplaySubject&lt;/code&gt; with which you can retrieve the otherwise-missing items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580926df80f2bb9b9ffac06756ddd1d4eed2fe8f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;runAsync&lt;/code&gt; immediately invokes the &lt;code&gt;Action&lt;/code&gt; and begins emitting the items, it is possible that some items may be lost in the interval between when you establish the &lt;code&gt;StoppableObservable&lt;/code&gt; with this method and when your &lt;code&gt;Observer&lt;/code&gt; is ready to receive items. If this is a problem, you can use the variant of &lt;code&gt;runAsync&lt;/code&gt; that also accepts a &lt;a href=&quot;../subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; and pass a &lt;code&gt;ReplaySubject&lt;/code&gt; with which you can retrieve the otherwise-missing items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d4b461dae7aa4c7f69430372ef95db326bbe71" translate="yes" xml:space="preserve">
          <source>Because a Subject subscribes to an Observable, it will trigger that Observable to begin emitting items (if that Observable is &amp;ldquo;cold&amp;rdquo; &amp;mdash; that is, if it waits for a subscription before it begins to emit items). This can have the effect of making the resulting Subject a &amp;ldquo;hot&amp;rdquo; Observable variant of the original &amp;ldquo;cold&amp;rdquo; Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea3c830df555c58d5b9d3068d47dee7f418f5fe" translate="yes" xml:space="preserve">
          <source>Because it is possible that more than one of the merged Observables encountered an error, &lt;code&gt;mergeDelayError&lt;/code&gt; may pass information about &lt;em&gt;multiple&lt;/em&gt; errors in the &lt;code&gt;onError&lt;/code&gt; notification (it will never invoke the observer&amp;rsquo;s &lt;code&gt;onError&lt;/code&gt; method more than once). For this reason, if you want to know the nature of these errors, you should write your observers&amp;rsquo; &lt;code&gt;onError&lt;/code&gt; methods so that they accept a parameter of the class &lt;code&gt;CompositeException&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40504d93089e459126b9f714fa64da0432bf9cb2" translate="yes" xml:space="preserve">
          <source>Before an Observable terminates it must first issue either an OnCompleted or OnError notification to all of the observers that are subscribed to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368c978e94ba7ae5d0f5a362fef744af7dd7667e" translate="yes" xml:space="preserve">
          <source>BehaviorSubject</source>
          <target state="translated">BehaviorSubject</target>
        </trans-unit>
        <trans-unit id="2be5f64b36230104ef9c6e230215846a83d18df6" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="translated">Buffer</target>
        </trans-unit>
        <trans-unit id="c7edc1ce6b23272555c0452f3036c8ab489ea4bc" translate="yes" xml:space="preserve">
          <source>Buffer can reduce a sequence of many items to a sequence of fewer buffers-of-items, making them more manageable. You could, for example, close and emit a buffer of items from a bursty Observable periodically, at a regular interval of time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d726676ef856039a619e5c8fc3b22b65bd1d7d3f" translate="yes" xml:space="preserve">
          <source>But as with Futures, while callbacks are easy to use with a single level of asynchronous execution, &lt;a href=&quot;https://gist.github.com/4677544&quot;&gt;with nested composition they become unwieldy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3806ea89275a484caaeb8fb736ffc6a0c360406a" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;delay&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;delay&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853cd838d6aa239dfebc6fe472f15b378a7e9fd0" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;timeout&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c7c6971a230126aa6e972a720f0bb289a01e7e" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;timeout&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5e38e8783b4ae293ff3a5deb6299790a6fded1" translate="yes" xml:space="preserve">
          <source>By default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its &lt;code&gt;Subscribe&lt;/code&gt; method is called. The SubscribeOn operator changes this behavior by specifying a different Scheduler on which the Observable should operate. The ObserveOn operator specifies a different Scheduler that the Observable will use to send notifications to its observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349ec7cf4de33246924ed8834527eb97fcddde0c" translate="yes" xml:space="preserve">
          <source>By the terms of &lt;a href=&quot;contract&quot;&gt;the Observable contract&lt;/a&gt;, it may call &lt;code&gt;onNext&lt;/code&gt; zero or more times, and then may follow those calls with a call to either &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; but not both, which will be its last call. By convention, in this document, calls to &lt;code&gt;onNext&lt;/code&gt; are usually called &amp;ldquo;emissions&amp;rdquo; of items, whereas calls to &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; are called &amp;ldquo;notifications.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7f884b18f0e71ef27dcc9eb107c69b22184b8e" translate="yes" xml:space="preserve">
          <source>Bypasses a specified number of elements at the end of an observable sequence. This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a26a63bf2967d76012cc29baf8e343e4f53b12" translate="yes" xml:space="preserve">
          <source>Bypasses a specified number of elements in an observable sequence and then returns the remaining elements. Transform the items emitted by an Observable into Observables, and mirror those items emitted by the most-recently transformed Observable. The flatMapLatest operator is similar to the flatMap and concatMap methods described above, however, rather than emitting all of the items emitted by all of the Observables that the operator generates by transforming items from the source Observable, flatMapLatest instead emits items from each such transformed Observable only until the next such Observable is emitted, then it ignores the previous one and begins emitting items emitted by the new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49745efca49c630e89bcd950cbd9b790a40a26ec" translate="yes" xml:space="preserve">
          <source>Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5074688d8a8d1a7a2f2146111a01a2d5efa03be4" translate="yes" xml:space="preserve">
          <source>Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78dc0e523eb5336a4517027ee20f8ce8c1283c64" translate="yes" xml:space="preserve">
          <source>Call a &lt;code&gt;ConnectableObservable&lt;/code&gt;&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; method to instruct it to begin emitting the items from its underlying Observable to its Subscribers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c805453a51ab6e5402991a6b7905abbb82969b88" translate="yes" xml:space="preserve">
          <source>Call a method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846a84e9501ad053efd6f0622ac43a7f2f1a41f9" translate="yes" xml:space="preserve">
          <source>Callbacks Have Their Own Problems</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0513dc45b99b203cc47abe5101858366b0aaa9" translate="yes" xml:space="preserve">
          <source>Callbacks solve the problem of premature blocking on &lt;code&gt;Future.get()&lt;/code&gt; by not allowing anything to block. They are naturally efficient because they execute when the response is ready.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadfad0ea9282bb47746b81a6a4235042d5882c1" translate="yes" xml:space="preserve">
          <source>Canonical, core operator names are in &lt;strong&gt;boldface&lt;/strong&gt;. Other entries represent language-specific variants of these operators or specialty operators outside of the main ReactiveX core set of operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="e6f5247c2c2f3a3279ed51693bfefd3a423b8bf0" translate="yes" xml:space="preserve">
          <source>Chaining Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902bd9921de41f5d7e6b42366eb8310a65a2c945" translate="yes" xml:space="preserve">
          <source>Chaining Your Custom Operators with Standard RxJava Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75951d379af65c103f979b689d8cd3675b822a8" translate="yes" xml:space="preserve">
          <source>Checking or Setting Unsubscribed Status</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe96207c9c96f4636acc27e3c848d00d3a71f54" translate="yes" xml:space="preserve">
          <source>Cold Observables are ideal for the reactive pull model of backpressure implemented by some implementations of ReactiveX (which is described elsewhere). Hot Observables typically do not cope well with a reactive pull model, and are better candidates for other flow control strategies, such as the use of the operators described on this page, or operators like &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt;, &lt;a href=&quot;sample&quot;&gt;Sample&lt;/a&gt;, &lt;a href=&quot;debounce&quot;&gt;Debounce&lt;/a&gt;, or &lt;a href=&quot;window&quot;&gt;Window&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4a4428705e4ab030e6ba205ec9858d5968be1b" translate="yes" xml:space="preserve">
          <source>Combine an Observable together with another Observable by merging their emissions into a single Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eaeb8e90e404219d2475ade2286223421965733" translate="yes" xml:space="preserve">
          <source>CombineLatest</source>
          <target state="translated">CombineLatest</target>
        </trans-unit>
        <trans-unit id="6c3a08025c1d0f1b566061e55f26255f61bfc3ba" translate="yes" xml:space="preserve">
          <source>Combining</source>
          <target state="translated">Combining</target>
        </trans-unit>
        <trans-unit id="88d3a1111da9d1eda1c639562973e23995473442" translate="yes" xml:space="preserve">
          <source>Combining Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5747c92bf0fa0eeb7e1e03446b2293ecf1be9ebd" translate="yes" xml:space="preserve">
          <source>Composition via Observable Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5c874513b4df302338425830ff176188a2f641" translate="yes" xml:space="preserve">
          <source>Composition via Single Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3304bad3c3afa5d187ab48d870d028da8b016b08" translate="yes" xml:space="preserve">
          <source>Computes the average of an observable sequence of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086146e076b0941ac82db3612259103a8c72834b" translate="yes" xml:space="preserve">
          <source>Computes the sum of a sequence of values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad79ab6353b1eee8ebbc085e10d17c4fcfb024f" translate="yes" xml:space="preserve">
          <source>Concat</source>
          <target state="translated">Concat</target>
        </trans-unit>
        <trans-unit id="af22bc2cd4677bc8c0a76b729fa90aba7f0a85a8" translate="yes" xml:space="preserve">
          <source>Concat waits to subscribe to each additional Observable that you pass to it until the previous Observable completes. Note that because of this, if you try to concatenate a &amp;ldquo;hot&amp;rdquo; Observable, that is, one that begins emitting items immediately and before it is subscribed to, Concat will not see, and therefore will not emit, any items that Observable emits before all previous Observables complete and Concat subscribes to the &amp;ldquo;hot&amp;rdquo; Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a49591ac407c790c483a17d515d9fb2a8a38be" translate="yes" xml:space="preserve">
          <source>ConcatMap</source>
          <target state="translated">ConcatMap</target>
        </trans-unit>
        <trans-unit id="7d817faef75bfe91293d3714de7420c6573f23e2" translate="yes" xml:space="preserve">
          <source>Concatenate an observable sequence onto the end of the source observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105eca8e21d6f9c476cc3a553058b085eb5233eb" translate="yes" xml:space="preserve">
          <source>Concatenates a sequence of observable sequences into a single observable sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769151df54c355c60c55756c44028ce4f3ae5d6a" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b047f76f02c3292f835923209499db8eb35fdb8" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65463cb6a42a17de514acc4659f7fd331e0876a" translate="yes" xml:space="preserve">
          <source>Connect</source>
          <target state="translated">Connect</target>
        </trans-unit>
        <trans-unit id="1f7db7f19ce7165e91e31ee1d9b3ccf7f4d5ddb2" translate="yes" xml:space="preserve">
          <source>Connectable</source>
          <target state="translated">Connectable</target>
        </trans-unit>
        <trans-unit id="7b18cca5708f430e8e5e76af7d6ca811b7d401af" translate="yes" xml:space="preserve">
          <source>Connectable Observable Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e15d008d511f3101566a2e25203ef2a3f605a0" translate="yes" xml:space="preserve">
          <source>Contains</source>
          <target state="translated">Contains</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="0815d31f649e51c84f54caac71abf843ed3f8bb3" translate="yes" xml:space="preserve">
          <source>Continues an observable sequence that is terminated by an exception with the next observable sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e687c89a4954fc6df4498ea2002f2818d836141" translate="yes" xml:space="preserve">
          <source>Converting Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54800ec0ba74d95f4ae763fd411edb7cb335d1b" translate="yes" xml:space="preserve">
          <source>Converts a promise into an observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6fd01b29250836779bf34c8cd915aff0e9c6ef1" translate="yes" xml:space="preserve">
          <source>Converts an Iterator into an observable sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff785cfdb5ffb690f81079fc7680305d01077af0" translate="yes" xml:space="preserve">
          <source>Converts an array to an observable sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e12969c225cc6d65e18210488acb826eba907e" translate="yes" xml:space="preserve">
          <source>Count</source>
          <target state="translated">Count</target>
        </trans-unit>
        <trans-unit id="6e157c5da4410b7e9de85f5c93026b9176e69064" translate="yes" xml:space="preserve">
          <source>Create</source>
          <target state="translated">Create</target>
        </trans-unit>
        <trans-unit id="3017d922d76f674ffb9131a65a9d9805b40b649a" translate="yes" xml:space="preserve">
          <source>Creates an observable sequence containing a single element which is an array containing all the elements of the source sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba20da44f8a1b3b058041022a942932e59185655" translate="yes" xml:space="preserve">
          <source>Creates an observable sequence from a specified subscribeAction callable implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bf119aef55197510b4be1bbec7191fb09b536e" translate="yes" xml:space="preserve">
          <source>Creating</source>
          <target state="translated">Creating</target>
        </trans-unit>
        <trans-unit id="6ad6131d04bc2f8da39dba3829954ab817589a3f" translate="yes" xml:space="preserve">
          <source>Creating Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f6f421ef32670498c220ee8ee339df076a5ad9" translate="yes" xml:space="preserve">
          <source>DOM</source>
          <target state="translated">DOM</target>
        </trans-unit>
        <trans-unit id="7cb67bc80f28063e0c70dca78f5ac1f7a7e27b33" translate="yes" xml:space="preserve">
          <source>DZone</source>
          <target state="translated">DZone</target>
        </trans-unit>
        <trans-unit id="9d15bbaea70fed040952f827d04bf23d37deee20" translate="yes" xml:space="preserve">
          <source>Dave Sexton&amp;rsquo;s blog</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba25d0847d81dc2070dc7517ad59c0bcd4bf477c" translate="yes" xml:space="preserve">
          <source>Debounce</source>
          <target state="translated">Debounce</target>
        </trans-unit>
        <trans-unit id="7ee8d644320fde72f64c3c02faecdd18b75c6696" translate="yes" xml:space="preserve">
          <source>Default Schedulers for RxGroovy Observable Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9dcde6cb5b0bfc6c5ca51b240a6adb12ef894c" translate="yes" xml:space="preserve">
          <source>Default Schedulers for RxJava 1.x Observable Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123deaeef87eca8cb2b99f856d5107f914acdc3a" translate="yes" xml:space="preserve">
          <source>DefaultIfEmpty</source>
          <target state="translated">DefaultIfEmpty</target>
        </trans-unit>
        <trans-unit id="c4357816d34305505b749a4ff11d936352064da0" translate="yes" xml:space="preserve">
          <source>Defer</source>
          <target state="translated">Defer</target>
        </trans-unit>
        <trans-unit id="530d7bc391670a9d12abc2c95fba599d8d6a4fa3" translate="yes" xml:space="preserve">
          <source>Define a method that does something useful with the return value from the asynchronous call; this method is part of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c776a2467c885ed63c4827a40f24318ee838b755" translate="yes" xml:space="preserve">
          <source>Define the asynchronous call itself as an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d05798be1bf5aad240451b19cea28a1042183aa" translate="yes" xml:space="preserve">
          <source>Define your operator as a public class that implements the &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.Operator.html&quot;&gt;&lt;code&gt;Operator&lt;/code&gt;&lt;/a&gt; interface, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c200bb0d1f7ba2b7c3e166470a4cb39be0daab" translate="yes" xml:space="preserve">
          <source>Delay</source>
          <target state="translated">Delay</target>
        </trans-unit>
        <trans-unit id="24eb06fa1daed4a5e60d45a988c3f8068a35cdf2" translate="yes" xml:space="preserve">
          <source>DelaySubscription</source>
          <target state="translated">DelaySubscription</target>
        </trans-unit>
        <trans-unit id="17582fe13ad63f1268f0a279d97ba7524dcb4b53" translate="yes" xml:space="preserve">
          <source>Delayed and Periodic Schedulers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9573648319d57f22c34e294a58048517caa06a5" translate="yes" xml:space="preserve">
          <source>Dematerialize</source>
          <target state="translated">Dematerialize</target>
        </trans-unit>
        <trans-unit id="8a57a3d654adf9c3caf76455456be92d962c8113" translate="yes" xml:space="preserve">
          <source>Dematerializes the explicit notification values of an observable sequence as implicit notifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faf2e90a3c1b400f4ee9d8c8176a362bc102d3a" translate="yes" xml:space="preserve">
          <source>Distinct</source>
          <target state="translated">Distinct</target>
        </trans-unit>
        <trans-unit id="1fa9ca2d50e91f64ba10b23625a789d1d514ba76" translate="yes" xml:space="preserve">
          <source>DistinctUntilChanged</source>
          <target state="translated">DistinctUntilChanged</target>
        </trans-unit>
        <trans-unit id="22bdf47be3fd0a53ecdf5d6edbde0a2c6b97f0e0" translate="yes" xml:space="preserve">
          <source>Do</source>
          <target state="translated">Do</target>
        </trans-unit>
        <trans-unit id="990799e2354088401f54e49252cb9cd2887b10be" translate="yes" xml:space="preserve">
          <source>Do not block within your operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde4f7dc6a6a9b2fc7ddc5c5285b6941c477da41" translate="yes" xml:space="preserve">
          <source>Each element of the array is produced as an emission. The difference between this method and &lt;code&gt;Observable.just&lt;/code&gt; is that the latter emits the whole array as one emission.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a91a226ecfae7f33d903980a454ab6aaa9b48e8" translate="yes" xml:space="preserve">
          <source>Each language-specific implementation of ReactiveX has its own naming quirks. There is no canonical naming standard, though there are many commonalities between implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef6d442e8c8b1f7447957e1c9784e5f4cc239dc" translate="yes" xml:space="preserve">
          <source>Each language-specific implementation of ReactiveX implements a set of operators. Although there is much overlap between implementations, there are also some operators that are only implemented in certain implementations. Also, each implementation tends to name its operators to resemble those of similar methods that are already familiar from other contexts in that language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41b061bd9083507610ef2dcf5baaac02b4db60a" translate="yes" xml:space="preserve">
          <source>ElementAt</source>
          <target state="translated">ElementAt</target>
        </trans-unit>
        <trans-unit id="5c002992eecc90de6e3515445216429d901f6529" translate="yes" xml:space="preserve">
          <source>Emit only those items from an Observable that pass a predicate test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3159fe421b3221381b3c778dc1c3c26e4540be37" translate="yes" xml:space="preserve">
          <source>Empty</source>
          <target state="translated">Empty</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a2a7f6e5c6d27ddebfed1897c207d4db559890" translate="yes" xml:space="preserve">
          <source>Error Handling Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c83f123791849e254666f68cc88dae689457e0d" translate="yes" xml:space="preserve">
          <source>Errors the observable sequence if no item is emitted in the specified time. When a timeout occurs, this operator errors with an instance of Rx\Exception\TimeoutException</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c51d8ac13956137d7379dd1c673b6057e36f8fc" translate="yes" xml:space="preserve">
          <source>Establishing Observers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7a78ddd1e28dabdd3fb142de5c9c3d0907593c" translate="yes" xml:space="preserve">
          <source>Example code showing how similar high-order functions can be applied to an Iterable and an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="9075edca21736af901d2add18e4d9491f2452b4d" translate="yes" xml:space="preserve">
          <source>Filtering</source>
          <target state="translated">Filtering</target>
        </trans-unit>
        <trans-unit id="b3d1e836b8c9937992dbfac26e772ac39afe998a" translate="yes" xml:space="preserve">
          <source>Filtering Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8978f6a09cf524ab9596b508a2479904c83591c3" translate="yes" xml:space="preserve">
          <source>Finally, there is an alphabetical list of most of the operators available in the many language-specific implementations of ReactiveX. These link to the page that documents the core operator that most closely resembles the language-specific operator (so, for instance, the Rx.NET &amp;ldquo;SelectMany&amp;rdquo; operator links to the documentation of the FlatMap ReactiveX operator, of which &amp;ldquo;SelectMany&amp;rdquo; is the Rx.NET implementation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2160fad1531c502a9ce03c129b6f655416e93f" translate="yes" xml:space="preserve">
          <source>Finally, you can pass it an object that implements either of the &lt;code&gt;Observer&lt;/code&gt; or &lt;code&gt;Subscriber&lt;/code&gt; interfaces. The &lt;code&gt;Observer&lt;/code&gt; interface consists of the three previously-described &amp;ldquo;&lt;code&gt;on&lt;/code&gt;&amp;rdquo; methods. The &lt;code&gt;Subscriber&lt;/code&gt; interface implements these also, and adds a number of additional methods that facilitate reactive pull backpressure and that permit the Subscriber to unsubscribe to an Observable before it completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916a78d701ded328cd66da58a97ef8cd28a99e84" translate="yes" xml:space="preserve">
          <source>First</source>
          <target state="translated">First</target>
        </trans-unit>
        <trans-unit id="c5bda5b47fc05cd947485d9dcbc97c118c87af17" translate="yes" xml:space="preserve">
          <source>FlatMap</source>
          <target state="translated">FlatMap</target>
        </trans-unit>
        <trans-unit id="273946dd5d2d1288f9b2aafed80ce36284371ce6" translate="yes" xml:space="preserve">
          <source>For example there is the &lt;code&gt;on&lt;i&gt;Event&lt;/i&gt;&lt;/code&gt; naming pattern (e.g. &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onCompleted&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;). In some contexts such names would indicate methods by means of which event handlers are &lt;em&gt;registered&lt;/em&gt;. In ReactiveX, however, they name the event handlers themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217442e28d51221a4fdad0309844d07ab64be02a" translate="yes" xml:space="preserve">
          <source>For example, imagine using the &lt;a href=&quot;zip&quot;&gt;Zip&lt;/a&gt; operator to zip together two infinite Observables, one of which emits items twice as frequently as the other. A naive implementation of the operator would have to maintain an ever-expanding buffer of items emitted by the faster Observable to eventually combine with items emitted by the slower one. This could cause ReactiveX to seize an unwieldy amount of system resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c04f7c1d2fb4ddd89c1509683905da7e098003b" translate="yes" xml:space="preserve">
          <source>For example, the following code merges the &lt;code&gt;odds&lt;/code&gt; and &lt;code&gt;evens&lt;/code&gt; into a single Observable. (The &lt;code&gt;subscribeOn&lt;/code&gt; operator makes &lt;code&gt;odds&lt;/code&gt; operate on a different thread from &lt;code&gt;evens&lt;/code&gt; so that the two Observables may both emit items at the same time, to demonstrate how Merge may interleave these items.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc05c0ee12f75173f33b61a359852128b084b9e1" translate="yes" xml:space="preserve">
          <source>For example, the following code takes a list of unsorted integers, converts it into an Observable, then converts that Observable into one that emits the original list in sorted form as a single item:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbdfcad6b5a5793860447cf0201a70bee8a2b57" translate="yes" xml:space="preserve">
          <source>For example, the following code uses &lt;code&gt;reduce&lt;/code&gt; to compute, and then emit as an Observable, the sum of the numbers emitted by the source Observable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875655c8a87dcab782ffad12361168b23205728f" translate="yes" xml:space="preserve">
          <source>For example, the following rather pointless code takes a list of integers, converts it into an Observable, then converts that Observable into one that emits the original list as a single item:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4afe05eb65cfed34c46b0c5cfa9d72af6ef87ec" translate="yes" xml:space="preserve">
          <source>For the special case of &lt;code&gt;take(0)&lt;/code&gt; you can also pass as a second parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;take&lt;/code&gt; will use to immediately schedule a call to &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e288d7fa19e1bf4757ab1d8f5269ca19ed723b7" translate="yes" xml:space="preserve">
          <source>For this reason, instead of subscribing to a Single with the three methods you use to respond to notifications from an Observable (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2737986da43814cbc95d7c442ca5b8a689aa03a4" translate="yes" xml:space="preserve">
          <source>For this reason, most ReactiveX implementations have methods that allow you to convert certain language-specific objects and data structures into Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="392276019fcc1d5272942bce719b6342fcb81e7b" translate="yes" xml:space="preserve">
          <source>From the Observer&amp;rsquo;s point of view, it doesn&amp;rsquo;t matter!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42428a2d2e461a43cab074a94ea7b862a5694eb9" translate="yes" xml:space="preserve">
          <source>Furthermore, some of these names have different implications in other contexts, or seem awkward in the idiom of a particular implementing language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3db6203d1cee531e933dc661377957741fd7c7" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d0f29396a5c34e31ebc967172deef307fe570f" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence that repeats the given element the specified number of times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b53270ad371697bc1e589de2e23706a1f6bcaa9" translate="yes" xml:space="preserve">
          <source>Go on with your business; whenever the call returns, the observer&amp;rsquo;s method will begin to operate on its return value or values &amp;mdash; the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63718ab0ad2dfd113729e407e5fdf344eb231fd5" translate="yes" xml:space="preserve">
          <source>GroupBy</source>
          <target state="translated">GroupBy</target>
        </trans-unit>
        <trans-unit id="5b580ccc31ee66edb3fbe2b6a9872b6baf3565df" translate="yes" xml:space="preserve">
          <source>Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec80db1447579253ebd9672ba573bfff5db58f5b" translate="yes" xml:space="preserve">
          <source>Here is an example that provides its own sorting function: in this case, one that sorts numbers according to how close they are to the number 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3a2bd6db43943919933044f161c73f3f3b3390" translate="yes" xml:space="preserve">
          <source>Hides the identity of an observable sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4a28cce6229ef2c4b35941085f06d550791705" translate="yes" xml:space="preserve">
          <source>How is this Observable implemented?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f43fbd596793edf6bbe3749bc8742ef91cfde4" translate="yes" xml:space="preserve">
          <source>However, if the source Observable terminates with an error, the &lt;code&gt;BehaviorSubject&lt;/code&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b8c0a40d90b726e62fff83e0e5d057ad8f6562" translate="yes" xml:space="preserve">
          <source>I want an Observable that does not start emitting items to subscribers until asked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e0c99e2ca6299088acf813f3684ac6db4f290d" translate="yes" xml:space="preserve">
          <source>I want an Observable that will notify observers of an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ac8f52c641ecf8295c3126651b68566f69ca55" translate="yes" xml:space="preserve">
          <source>I want an Observable to invoke a particular action when certain events occur</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71de0f2184ab945ae7071514e5714fa44c58f556" translate="yes" xml:space="preserve">
          <source>I want an Observable to recover gracefully</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4218745ff4559c04307408b48fa3c0d95b2e3c" translate="yes" xml:space="preserve">
          <source>I want an operator to operate on a particular &lt;a href=&quot;http://reactivex.io/scheduler.html&quot;&gt;Scheduler&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcee030a9b0fc7754e86e874779c1dd0d6fbcf4" translate="yes" xml:space="preserve">
          <source>I want to collect items from an Observable and reemit them as buffers of items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da6c79bd44786fa9d805be97358190877889323" translate="yes" xml:space="preserve">
          <source>I want to convert the entire sequence of items emitted by an Observable into some other data structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99621e91d6f81783ccbca5febefcff99798c51ba" translate="yes" xml:space="preserve">
          <source>I want to create a new Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95392e6ebe4cd2b8d976a6b5dc15ebcc8652c19" translate="yes" xml:space="preserve">
          <source>I want to create a resource that has the same lifespan as the Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e5a804f40a4ae53ad6d865409b7eb39972641d" translate="yes" xml:space="preserve">
          <source>I want to create an Observable by combining other Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba42083fc42c06c02ced02fc27975097eda340f" translate="yes" xml:space="preserve">
          <source>I want to emit the items from an Observable after transforming them</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678a797d3d44a8e136336de41859f44d87ea12d0" translate="yes" xml:space="preserve">
          <source>I want to evaluate the entire sequence of items emitted by an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342d9df0dc00c6409e061ccbe8bd7a43ec0f1e2f" translate="yes" xml:space="preserve">
          <source>I want to ignore all items emitted by an Observable and only pass along its completed/error notification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1e59137d512a13724ce068546bdef43aa1b2cf" translate="yes" xml:space="preserve">
          <source>I want to mirror an Observable but prefix items to its sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bdd0d540cc5c4d1feeab4c1bf757d0bb5b1651e" translate="yes" xml:space="preserve">
          <source>I want to reemit items from an Observable only on condition that it was the first of a collection of Observables to emit an item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afea5ad42757cc0909b83ee4ce1bb6c62bd02f89" translate="yes" xml:space="preserve">
          <source>I want to reemit only certain items from an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e5e42e408215716d6b5f291913c77f52df5dd6" translate="yes" xml:space="preserve">
          <source>I want to retrieve a particular item emitted by an Observable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386e533e7f72fc5f43c8113497f862fc5eede916" translate="yes" xml:space="preserve">
          <source>I want to shift the items emitted by an Observable forward in time before reemitting them</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a6925e0701483bb01af42b8def481ec4f9b265" translate="yes" xml:space="preserve">
          <source>I want to split one Observable into multiple Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51428b8b50c14765922c8b036cca4988742e7efd" translate="yes" xml:space="preserve">
          <source>I want to subscribe to an Observable and receive a &lt;code&gt;Future&lt;/code&gt; that blocks until the Observable completes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e67d5551cb9e7fce5308aac618b27ccc290f104" translate="yes" xml:space="preserve">
          <source>I want to transform items &lt;em&gt;and&lt;/em&gt; notifications from an Observable into items and reemit them</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caced85795e91d7af9dfe4ed9e1f46fd5fea7321" translate="yes" xml:space="preserve">
          <source>If a second observer subscribes to an Observable that is already emitting items to a first observer, it is up to the Observable whether it will thenceforth emit the same items to each observer, or whether it will replay the complete sequence of items from the beginning to the second observer, or whether it will emit a wholly different sequence of items to the second observer. There is no general guarantee that two observers of the same Observable will see the same sequence of items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ef7637d7666db7b1cac27130564f15f9858d6b" translate="yes" xml:space="preserve">
          <source>If an Observable has not issued an OnCompleted or OnError notification, an observer may consider it to be still active (even if it is not currently emitting items) and may issue it notifications (such as an Unsubscribe or Request notification). When an Observable does issue an OnCompleted or OnError notification, the Observable may release its resources and terminate, and its observers should not attempt to communicate with it any further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7b046dde03b5ea699c95f5183b34be3f0cf4c2" translate="yes" xml:space="preserve">
          <source>If an Observable implements backpressure and its observer employs backpressure, the Observable will not begin to emit items to the observer immediately upon subscription. Instead, it will issue an OnSubscribe notification to the observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733ae6509dbabf4aba675cc3ed47501f58834086" translate="yes" xml:space="preserve">
          <source>If any of the individual Observables passed into &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;mergeAll&lt;/code&gt; terminates with an &lt;code&gt;onError&lt;/code&gt; notification, the resulting Observable will immediately terminate with an &lt;code&gt;onError&lt;/code&gt; notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use &lt;code&gt;mergeDelayError&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd3e9e82373d3dfce17c1d4311251fdd13222d5" translate="yes" xml:space="preserve">
          <source>If any of the individual Observables passed into &lt;code&gt;merge&lt;/code&gt; terminates with an &lt;code&gt;onError&lt;/code&gt; notification, the Observable produced by &lt;code&gt;merge&lt;/code&gt; itself will immediately terminate with an &lt;code&gt;onError&lt;/code&gt; notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use &lt;code&gt;mergeDelayError&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d250294c4e6c5532d682c6ee0dcbdc73daefb50" translate="yes" xml:space="preserve">
          <source>If instead you want the Observable to emit a default value in such a case, you can pass a second parameter (named &lt;code&gt;defaultValue&lt;/code&gt;) to &lt;code&gt;last&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72eba74aab57235e91614104d881cad347d5f3c6" translate="yes" xml:space="preserve">
          <source>If the Observable produces more items than the observer requests, it is up to the Observable whether it will discard the excess items, store them to emit at a later time, or use some other strategy to deal with the overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574236c3473cbd9e1a8324c3c8b4368c27b83052" translate="yes" xml:space="preserve">
          <source>If the predicate function returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; will increment the tally of items that it will report when the source Observable completes. If you want to count &lt;em&gt;all&lt;/em&gt; of the items emitted by the source Observable, simply pass &lt;code&gt;count&lt;/code&gt; a predicate that always returns &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eef9a5d07bff0abbbfddd99e1e6d78b055ea35c" translate="yes" xml:space="preserve">
          <source>If the source Observable emits no items (or no items that match the predicate), &lt;code&gt;first&lt;/code&gt; will terminate with a &amp;ldquo;&lt;code&gt;Sequence contains no elements.&lt;/code&gt;&amp;rdquo; &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9453ca79c20e7c3d4fd2ab97401f3e8fafa02aee" translate="yes" xml:space="preserve">
          <source>If the source Observable emits no items (or no items that match the predicate), &lt;code&gt;last&lt;/code&gt; will terminate with a &amp;ldquo;&lt;code&gt;Sequence contains no elements.&lt;/code&gt;&amp;rdquo; &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8c354d5fd059c1f261a3b43af7ba6bf089e618" translate="yes" xml:space="preserve">
          <source>If the source Observable invokes &lt;code&gt;onCompleted&lt;/code&gt; before emitting any items, the Observable returned by &lt;code&gt;toList&lt;/code&gt; will emit an empty list before invoking &lt;code&gt;onCompleted&lt;/code&gt;. If the source Observable invokes &lt;code&gt;onError&lt;/code&gt;, the Observable returned by &lt;code&gt;toList&lt;/code&gt; will immediately invoke the &lt;code&gt;onError&lt;/code&gt; methods of its observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb1875188746c3fc8a2a22c90eacf4a3b187726" translate="yes" xml:space="preserve">
          <source>If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e65b113c5ab2efc19f456b3ae0c066cd172ca0d" translate="yes" xml:space="preserve">
          <source>If the source Observable terminates with an error, Count will pass this error notification along without emitting an item first. If the source Observable does not terminate at all, Count will neither emit an item nor terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f688a0570f5d1b8ac889532c92767877018306e3" translate="yes" xml:space="preserve">
          <source>If the source Observable terminates with an error, the &lt;code&gt;PublishSubject&lt;/code&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bb4470ea625098ffc957da0e83887d5445085ec" translate="yes" xml:space="preserve">
          <source>If there is no element in the source sequence with the index value you specify, &lt;code&gt;elementAt&lt;/code&gt; will issue an &lt;code&gt;onError&lt;/code&gt; notification: &amp;ldquo;&lt;code&gt;Argument out of range&lt;/code&gt;&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e894ab20d3a46c26c42e98c6dfcddf872f60c1f" translate="yes" xml:space="preserve">
          <source>If you apply the Replay operator to an Observable before you convert it into a connectable Observable, the resulting connectable Observable will always emit the same complete sequence to any future observers, even those observers that subscribe after the connectable Observable has begun to emit items to other subscribed observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3097ba365bdc02567dbcce3f4aa13b9f891570a9" translate="yes" xml:space="preserve">
          <source>If you are only interested in the first item emitted by an Observable, or the first item that meets some criteria, you can filter the Observable with the First operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c46bce5c8de030e8f87b590429e41a9b0aa7c5" translate="yes" xml:space="preserve">
          <source>If you are only interested in the last item emitted by an Observable, or the last item that meets some criteria, you can filter the Observable with the Last operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde6dfb819e5be751bb6438b8bc1e8380bd27d52" translate="yes" xml:space="preserve">
          <source>If you are unable to guarantee that your operator conforms to the above two tenets, you can add the &lt;a href=&quot;observable-utility-operators#serialize&quot;&gt;&lt;code&gt;serialize( )&lt;/code&gt;&lt;/a&gt; operator to it to force the correct behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb580494f8e2917761a21353dfc55e61852dd40" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;pause&lt;/code&gt; method of a &lt;code&gt;PausableObservable&lt;/code&gt; created with the &lt;code&gt;pausable&lt;/code&gt; operator, it will drop (ignore) any items emitted by the underlying source Observable until such time as you call its &lt;code&gt;resume&lt;/code&gt; method, whereupon it will continue to pass along emitted items to its observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ebf1e42c4df41cf02c078fef78bef390ab290dc" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;pause&lt;/code&gt; method of a &lt;code&gt;PausableObservable&lt;/code&gt; created with the &lt;code&gt;pausableBuffered&lt;/code&gt; operator, it will buffer any items emitted by the underlying source Observable until such time as you call its &lt;code&gt;resume&lt;/code&gt; method, whereupon it will emit those buffered items and then continue to pass along any additional emitted items to its observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2ab002bb963be41d5c16f8da5e55d6b8a3fce9" translate="yes" xml:space="preserve">
          <source>If you do not care about the items being emitted by an Observable, but you do want to be notified when it completes or when it terminates with an error, you can apply the &lt;code&gt;ignoreElements&lt;/code&gt; operator to the Observable, which will ensure that it will never call its observers&amp;rsquo; &lt;code&gt;onNext&lt;/code&gt; handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d22ca088df792825f2a6dd1d5192358b2d0b360" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window&lt;/code&gt; uses the &lt;code&gt;computation&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100e150c378c4889cd317549f1e83b99541904e3" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;windowWithTime&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888dd3de98d14ac68c9106daa319827d52cfb772" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2211604bc2e7c059844a1087c3b24f75a19cf04" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window_with_time&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c494ea4ea43f0b89b77c160f3bc5c87d3d7f3fd4" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window_with_time_or_count&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d565ade5214a4fb6f8454dd74c4548834ae2dc50" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;Subject&lt;/code&gt; and you want to pass it along to some other agent without exposing its &lt;code&gt;Subscriber&lt;/code&gt; interface, you can mask it by calling its &lt;code&gt;asObservable&lt;/code&gt; method, which will return the Subject as a pure &lt;code&gt;Observable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f599ae77d4264a95da87490e66763c1573b59a6f" translate="yes" xml:space="preserve">
          <source>If you pass an Enumerable or Observable of Observables, you have the option of also passing in an integer indicating the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57eb4e1625176691f9e6cc11d8fa0b29717c9f7b" translate="yes" xml:space="preserve">
          <source>If you pass in a negative index value, &lt;code&gt;elementAt&lt;/code&gt; will throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd08e0ec3efa5ea25eaca8fcf04453442b6d2375" translate="yes" xml:space="preserve">
          <source>If you pass in a negative index value, or if the source Observable emits fewer than &lt;code&gt;&lt;i&gt;index
       value&lt;/i&gt;&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; items, &lt;code&gt;elementAt&lt;/code&gt; will throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb67bd2fcbd71bad891a7d78a921dd997297707" translate="yes" xml:space="preserve">
          <source>If you pass in an Observable of Observables, you have the option of also passing in a value indicating to &lt;code&gt;merge&lt;/code&gt; the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5aeff66e4f4beed635dbbd159c10910227639f" translate="yes" xml:space="preserve">
          <source>If you pass it no parameters, it will trigger a subscription to the underlying Observable, but will ignore its emissions and notifications. This will activate a cold Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc00be547db596f59e064ee2c08761c5578d5d79" translate="yes" xml:space="preserve">
          <source>If you unsubscribe from one of the &lt;code&gt;GroupedObservable&lt;/code&gt;s, or if an operator like &lt;code&gt;take&lt;/code&gt; that you apply to the &lt;code&gt;GroupedObservable&lt;/code&gt; unsubscribes from it, that &lt;code&gt;GroupedObservable&lt;/code&gt; will be terminated. If the source Observable later emits an item whose key matches the &lt;code&gt;GroupedObservable&lt;/code&gt; that was terminated in this way, &lt;code&gt;groupBy&lt;/code&gt; will create and emit a &lt;em&gt;new&lt;/em&gt;&lt;code&gt;GroupedObservable&lt;/code&gt; to match the key. In other words, unsubscribing from a &lt;code&gt;GroupedObservable&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; cause &lt;code&gt;groupBy&lt;/code&gt; to swallow items from its group. For example, see the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27ee58c426e22c185bfcc111ee4433c42e68d05" translate="yes" xml:space="preserve">
          <source>If you unsubscribe from one of the &lt;code&gt;GroupedObservable&lt;/code&gt;s, that &lt;code&gt;GroupedObservable&lt;/code&gt; will be terminated. If the source Observable later emits an item whose key matches the &lt;code&gt;GroupedObservable&lt;/code&gt; that was terminated in this way, &lt;code&gt;groupBy&lt;/code&gt; will create and emit a new &lt;code&gt;GroupedObservable&lt;/code&gt; to match the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54bb9339c9f0a6407d30c5087cb9c774545f641e" translate="yes" xml:space="preserve">
          <source>If you use a &lt;code&gt;ReplaySubject&lt;/code&gt; as an observer, take care not to call its &lt;code&gt;onNext&lt;/code&gt; method (or its other &lt;code&gt;on&lt;/code&gt; methods) from multiple threads, as this could lead to coincident (non-sequential) calls, which violates &lt;a href=&quot;contract&quot;&gt;the Observable contract&lt;/a&gt; and creates an ambiguity in the resulting Subject as to which item or notification should be replayed first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0d3520b5f3d10a48dc017e12fbce21ddb7dc02" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;take(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator (or its synonym, &lt;code&gt;limit(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt;) on an Observable, and that Observable emits fewer than</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb665f0140ca7cfd676978a94899df0df149f98a" translate="yes" xml:space="preserve">
          <source>If you want an Observable to emit a specific sequence of items before it begins emitting the items normally expected from it, apply the StartWith operator to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed9b26cc4846dd7ff3a51b44674d518103045141" translate="yes" xml:space="preserve">
          <source>If you want to convert an Observable that may emit multiple items into a &lt;code&gt;Future&lt;/code&gt;, try something like this: &lt;code&gt;myObservable.toList().toBlocking().toFuture()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126fda7bd3aebaa0b8ff116732464d2b0b7d7b8b" translate="yes" xml:space="preserve">
          <source>If you want to implement your own operator, see &lt;a href=&quot;implement-operator&quot;&gt;Implementing Your Own Operators&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f09f724f096a4aeef1d6681ca23a57c6938f183" translate="yes" xml:space="preserve">
          <source>If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf253b6526751dab305e3b5af636233ab2cfc540" translate="yes" xml:space="preserve">
          <source>If your operator is designed to &lt;em&gt;originate&lt;/em&gt; an Observable, rather than to transform or react to a source Observable, use the &lt;a href=&quot;operators/create&quot;&gt;&lt;code&gt;create( )&lt;/code&gt;&lt;/a&gt; method rather than trying to implement &lt;code&gt;Observable&lt;/code&gt; manually. Otherwise, follow the instructions below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4b5013699939e2ed2c63f5435fe7f247de7353" translate="yes" xml:space="preserve">
          <source>If your operator uses functions or lambdas that are passed in as parameters (predicates, for instance), note that these may be sources of exceptions, and be prepared to catch these and notify subscribers via &lt;code&gt;onError( )&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d10a49a1c9f362ffcdd30bcc2d70e20ca8a33fb" translate="yes" xml:space="preserve">
          <source>IgnoreElements</source>
          <target state="translated">IgnoreElements</target>
        </trans-unit>
        <trans-unit id="6e3bf6a26e7b015407f7e23c30d9aad02237ac19" translate="yes" xml:space="preserve">
          <source>Implementing Your Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080201a38e03e3f517b6f68adc6f2cdb032d6de9" translate="yes" xml:space="preserve">
          <source>Implementing Your Own Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9746961ed48f27eba42c580dc7c910e85405477" translate="yes" xml:space="preserve">
          <source>In ReactiveX an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07101b5e398b22985de43fce99e80ccc71f4b18" translate="yes" xml:space="preserve">
          <source>In ReactiveX it is not difficult to get into a situation in which an Observable is emitting items more rapidly than an operator or observer can consume them. This presents the problem of what to do with such a growing backlog of unconsumed items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d88767b8ff979df7115dbd13cc1795448ccafca" translate="yes" xml:space="preserve">
          <source>In Rx.NET the Observable this operator creates emits an Integer value, but there is also a &lt;code&gt;LongCount&lt;/code&gt; whose Observable emits a Long value. With both variants, you can either pass the source Observable in to the operator as a parameter or you can call the operator as an instance method of the source Observable (in which case you omit the parameter).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082753d6aa99a3e49c22beaa10c53f7d50ccf53c" translate="yes" xml:space="preserve">
          <source>In Rx.NET there are several variants of Buffer. For each variety you can either pass in the source Observable as the first parameter, or you can call it as an instance method of the source Observable (in which case you can omit that parameter):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866459115059c570312783d7d933eb56a2044752" translate="yes" xml:space="preserve">
          <source>In Rx.rb you have the option to pass &lt;code&gt;count&lt;/code&gt; a predicate that takes an item emitted by the source Observable as a parameter. If you do so, &lt;code&gt;count&lt;/code&gt; will emit a count only of those items from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;. Otherwise it will emit a count of all items emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174c58d2e87272ea8e66142ea84c078a35283c3e" translate="yes" xml:space="preserve">
          <source>In Rx.rb, &lt;code&gt;on_error_resume_next&lt;/code&gt; inherits the misleading nomenclature from Rx.NET in that it concatenates the second Observable sequence to the source sequence whether that source sequence terminates normally or with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc1fcc902763003b44007791de3712de7a57a0c" translate="yes" xml:space="preserve">
          <source>In Rx.rb, the &lt;code&gt;concat&lt;/code&gt; operator operates on two Observables as an instance operator, or on an array of Observables as a class method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3abf8fb4fa82e726050a8136a37f39dd9dbaf32" translate="yes" xml:space="preserve">
          <source>In RxClojure &lt;code&gt;concat&lt;/code&gt; concatenates some number of individual Observables together in the order in which they are given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc54b08c66d20cbbb553766813dfa06d5c1e25ba" translate="yes" xml:space="preserve">
          <source>In RxClojure there are six operators of concern here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659fe011d5c89b01a2304a5c8e2bb81d2ad313c9" translate="yes" xml:space="preserve">
          <source>In RxGroovy the operator is called &lt;code&gt;count&lt;/code&gt; and the Observable it creates emits an Integer value. There is also a &lt;code&gt;countLong&lt;/code&gt; whose Observable emits a Long value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d76cd52669eae9e069058fa6344e3c8d433d43c8" translate="yes" xml:space="preserve">
          <source>In RxGroovy there are several variants of Buffer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03bd02f7f4db8f2104aaf4dd90fc1dad471cf32a" translate="yes" xml:space="preserve">
          <source>In RxGroovy there is a variety of the &lt;code&gt;replay&lt;/code&gt; operator that returns a connectable Observable. You must &lt;a href=&quot;publish&quot;&gt;Publish&lt;/a&gt; this connectable Observable before observers can subscribe to it, and then &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; to it in order to observe its emissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db754926010b838dcaf35e54ecc9e4308fc9f4d" translate="yes" xml:space="preserve">
          <source>In RxGroovy there is also a version of the &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; operator that converts a &lt;code&gt;Future&lt;/code&gt; into an Observable, and in this way resembles the Start operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7572e0a31faefbf7ff70dca0814645c09d2770c6" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;doWhile&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;doWhile&lt;/code&gt; checks a condition after each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa8ae88df582d489c98f809e108617b6f090787" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;materialize&lt;/code&gt; transforms the notifications from the source Observable into &lt;code&gt;Notification&lt;/code&gt; objects and emits them as the emissions from the Observable it returns. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237f50a50a7216fd4056fb13f9fb3ed56266ba27" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;whileDo&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;whileDo&lt;/code&gt; checks a condition before each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4459eb5576a0985852d40aad97090be35fe7fe" translate="yes" xml:space="preserve">
          <source>In RxGroovy, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; interface. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0218c1d751cc26a5e8cbb187a070d185be55fd96" translate="yes" xml:space="preserve">
          <source>In RxGroovy, the &lt;code&gt;from&lt;/code&gt; operator can convert a Future, an Iterable, or an Array. In the case of an Iterable or an Array, the resulting Observable will emit each item contained in the Iterable or Array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077b76d936cc54a4fbdf52bb6a3d71bca4542ef9" translate="yes" xml:space="preserve">
          <source>In RxGroovy, these are not part of the core ReactiveX implementation, but are found as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;then&lt;/code&gt;, and &lt;code&gt;when&lt;/code&gt; in the &lt;code&gt;rxjava-joins&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c6ab7a826f68ee896f9e7bbec6a50b13018591" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this filtering operator is implemented as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29837dbff839813080383499d8c69a5c010c8559" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this filtering operator is implemented as &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524670218e1528528dc3e43a23a6e9ec903626f3" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a0032a96a9e999b2568c2953d3e8ba98be07a8" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;skipUntil&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab9e4908bb4235f47b80c1c77b023791f672cb3" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5071f8b712a1a2faafa543e15f33108e9b05eb0e" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;takeUntil&lt;/code&gt;. Note that the second Observable can cause &lt;code&gt;takeUntil&lt;/code&gt; to quit emitting items either by emitting an item or by issuing an &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da02f4576a4b5a5747703904db2371ebcf038e26" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;averageDouble&lt;/code&gt;, &lt;code&gt;averageFloat&lt;/code&gt;, &lt;code&gt;averageInteger&lt;/code&gt;, and &lt;code&gt;averageLong&lt;/code&gt;. The following example shows how these operators work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="badd3303a8eb778bfc48d7a87db09f83d8fb14fa" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;sumDouble&lt;/code&gt;, &lt;code&gt;sumFloat&lt;/code&gt;, &lt;code&gt;sumInteger&lt;/code&gt;, and &lt;code&gt;sumLong&lt;/code&gt;. The following example shows how these operators work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07cae2ff645e10f1475b173e92b2e4d1731fbd8" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f81aa6294cb9c74bcf4eb9eeea361e7952d8bb" translate="yes" xml:space="preserve">
          <source>In RxJS the operator &lt;code&gt;count&lt;/code&gt; counts the number of items in the source Observable that satisfy a specified predicate. That predicate takes the form of a function that takes three parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089ff40ee2d57ffddd76d98e11442fdb0f93e79e" translate="yes" xml:space="preserve">
          <source>In RxJS there are two versions of the &lt;code&gt;timer&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546ed95cf4899b2546736d0dc77f0000eca5cc15" translate="yes" xml:space="preserve">
          <source>In RxJS you can set the per-item delay in two ways: by passing a number of milliseconds into the &lt;code&gt;delay&lt;/code&gt; operator (which will delay each emission by that amount of time), or by passing in a &lt;code&gt;Date&lt;/code&gt; object (which will delay the beginning of the sequence of emissions until that absolute point in time).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91657e27431e8473a66e219d9cffa8076861683" translate="yes" xml:space="preserve">
          <source>In RxJS you obtain Schedulers from the &lt;code&gt;Rx.Scheduler&lt;/code&gt; object or as independently-implemented objects. The following table shows the varieties of Scheduler that are available to you in RxJS:.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59380515fb1764dd57d6d356f045c860c3897dad" translate="yes" xml:space="preserve">
          <source>In RxJS, &lt;code&gt;sequenceEqual&lt;/code&gt; is a method of a particular Observable instance, so you pass it exactly one other Observable to compare the instance to. You can optionally pass a second parameter: a function that accepts two items and returns &lt;code&gt;true&lt;/code&gt; if they are equal according to a standard of your choosing. &lt;code&gt;sequenceEqual&lt;/code&gt; returns an Observable that will emit a &lt;code&gt;true&lt;/code&gt; if the two Observables emit the same set of items in the same order before completing, or a &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39fb67c9a541a9b33aa36d76685b7973746c9cf" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; prototype. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1dad5015733748479ef787bfb5054f381799c6" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;distinct&lt;/code&gt; operator has two optional parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60aeaf00dfd42ac1f2aa979d31edd932b2e05c96" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;from&lt;/code&gt; operator converts an array-like or iterable object into an Observable that emits the items in that array or iterable. A String, in this context, is treated as an array of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f572fa2a9a0912cc3687d3d2b76c82ee440842" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;publish&lt;/code&gt; operator takes a function as a parameter. This function takes an emitted item from the source Observable as a parameter and produces the item that will be emitted in its place by the returned &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220a1ea76599fe696f6ff55d0b0240936d7391d9" translate="yes" xml:space="preserve">
          <source>In RxJS, you can subscribe to an Observable in two ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0434c25ac778b06dc0f0e430a507026d4ffcd13" translate="yes" xml:space="preserve">
          <source>In RxJava the operator is called &lt;code&gt;count&lt;/code&gt; and the Observable it creates emits an Integer value. There is also a &lt;code&gt;countLong&lt;/code&gt; whose Observable emits a Long value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4d2614f2ccefc9538a2a5b53a4e9f2384b8a21" translate="yes" xml:space="preserve">
          <source>In RxJava there are several variants of Buffer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5324a1b154d0b35b0430e397999d44bbb2293830" translate="yes" xml:space="preserve">
          <source>In RxJava there is a variety of the &lt;code&gt;replay&lt;/code&gt; operator that returns a connectable Observable. You must &lt;a href=&quot;publish&quot;&gt;Publish&lt;/a&gt; this connectable Observable before observers can subscribe to it, and then &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; to it in order to observe its emissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa9a02b1a23712e12eaf9bf38e6513173d05aad6" translate="yes" xml:space="preserve">
          <source>In RxJava there is also a version of the &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; operator that converts a &lt;code&gt;Future&lt;/code&gt; into an Observable, and in this way resembles the Start operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66e9a41859140e63d2a513b65a3eb33c3064950" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;doWhile&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;doWhile&lt;/code&gt; checks a condition after each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278ec5920441fdbb971e38eb40408f25e66352a0" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;materialize&lt;/code&gt; transforms the notifications from the source Observable into &lt;code&gt;Notification&lt;/code&gt; objects and emits them as the emissions from the Observable it returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9040120474fb9e9d6678ef11c5d331e3831055d" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;whileDo&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;whileDo&lt;/code&gt; checks a condition before each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cda80172d796ec17e6de8b0b3fb7df8961f5322" translate="yes" xml:space="preserve">
          <source>In RxJava, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; interface. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d915aa8a6371b24d546a898d5927650d68298d10" translate="yes" xml:space="preserve">
          <source>In RxJava, the &lt;code&gt;from&lt;/code&gt; operator can convert a Future, an Iterable, or an Array. In the case of an Iterable or an Array, the resulting Observable will emit each item contained in the Iterable or Array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa6f776ef4b58ae93606199eab5d7aae9f12a1b" translate="yes" xml:space="preserve">
          <source>In RxJava, this filtering operator is implemented as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4f120274458ea753c59c58263b7e7f5ac97cf7" translate="yes" xml:space="preserve">
          <source>In RxJava, this filtering operator is implemented as &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aaf45cbe7681d9fc78492e0e1abae440e60cdd8" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7d874d083f1f23b84c1a24058def9a12d847a5" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;skipUntil&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0df78c0cd8e0c04b88996b41f57536868e395ae" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c04fd97bf99939674e16f0e2e06fb85b1f5316" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;takeUntil&lt;/code&gt;. Note that the second Observable can cause &lt;code&gt;takeUntil&lt;/code&gt; to quit emitting items either by emitting an item or by issuing an &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cafebc8da2c395e45b748adaf4d16e424147df6" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa451d401756cfb43e0af09e28153a9dcf363ef1" translate="yes" xml:space="preserve">
          <source>In RxJs the &lt;code&gt;replay&lt;/code&gt; operator takes four optional parameters and returns an ordinary Observable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f6338e063dd1fe484cfc1e5f6bdc92e7874c61" translate="yes" xml:space="preserve">
          <source>In RxKotlin there are several variants of Buffer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f9d22e6333dc41077c541c793d2b34999696d3" translate="yes" xml:space="preserve">
          <source>In RxPY &lt;code&gt;concat&lt;/code&gt; takes a variable number of Observables as parameters (or an array of Observables), and concatenates them in the order they appear in the parameter list (or array).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73aa488412dc01ff1bb9df22470c5c2d99a3e49" translate="yes" xml:space="preserve">
          <source>In RxPY you have the option to pass &lt;code&gt;count&lt;/code&gt; a predicate that takes an item emitted by the source Observable as a parameter. If you do so, &lt;code&gt;count&lt;/code&gt; will emit a count only of those items from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;. Otherwise, it will emit a count of all items emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b529c9a0dc4b531af4b60f80f6f0cf3876ca4b7" translate="yes" xml:space="preserve">
          <source>In RxScala the operator &lt;code&gt;count&lt;/code&gt; counts the number of items in the source Observable that satisfy a specified predicate. That predicate accepts an emitted item as a parameter and returns a Boolean. &lt;code&gt;count&lt;/code&gt; will emit a count of all items for which this predicate returned &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ec499010df4b2455c2dfd317e76e966b3946e5" translate="yes" xml:space="preserve">
          <source>In Swift, this is implemented using the &lt;code&gt;Observable.from&lt;/code&gt; class method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="138a5f790b58f03a816d8788ec73857af8ed119a" translate="yes" xml:space="preserve">
          <source>In Swift, this is implemented using the &lt;code&gt;Observable.just&lt;/code&gt; class method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e45263cc87b0ac4023f88773e7a4a3cd1488684" translate="yes" xml:space="preserve">
          <source>In addition, in the &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, you have available to you the following operators that convert actions, callables, functions, and runnables into Observables that emit the results of those things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c705eb2803752c9ee28584efe3fc60abb165fff0" translate="yes" xml:space="preserve">
          <source>In an ordinary method call &amp;mdash; that is, &lt;em&gt;not&lt;/em&gt; the sort of asynchronous, parallel calls typical in ReactiveX &amp;mdash; the flow is something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70afa1a17dffe1d75fa8ae4871f89baf7ba04903" translate="yes" xml:space="preserve">
          <source>In general, notify subscribers of error conditions immediately, rather than making an effort to emit more items first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51d0ee6ef32193720cf5577081be13382e0461c" translate="yes" xml:space="preserve">
          <source>In many ReactiveX implementations there is a second operator, MergeDelayError, that changes this behavior &amp;mdash; reserving &lt;code&gt;onError&lt;/code&gt; notifications until all of the merged Observables complete and only then passing it along to the observers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1c152b88bf70837256cdf207124847c96b400f" translate="yes" xml:space="preserve">
          <source>In many software programming tasks, you more or less expect that the instructions you write will execute and complete incrementally, one-at-a-time, in order as you have written them. But in ReactiveX, many instructions may execute in parallel and their results are later captured, in arbitrary order, by &amp;ldquo;observers.&amp;rdquo; Rather than &lt;em&gt;calling&lt;/em&gt; a method, you define a mechanism for retrieving and transforming the data, in the form of an &amp;ldquo;Observable,&amp;rdquo; and then &lt;em&gt;subscribe&lt;/em&gt; an observer to it, at which point the previously-defined mechanism fires into action with the observer standing sentry to capture and respond to its emissions whenever they are ready.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1cde5def7e314848c7b5ea89de136a83b3d54d" translate="yes" xml:space="preserve">
          <source>In other documents and other contexts, what we are calling an &amp;ldquo;observer&amp;rdquo; is sometimes called a &amp;ldquo;subscriber,&amp;rdquo; &amp;ldquo;watcher,&amp;rdquo; or &amp;ldquo;reactor.&amp;rdquo; This model in general is often referred to as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Reactor_pattern&quot;&gt;&amp;ldquo;reactor pattern&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c110d63fdae361275771c2c4e8b7c4bd49374d1" translate="yes" xml:space="preserve">
          <source>In several of the language-specific implementations there is also an operator that does &lt;em&gt;not&lt;/em&gt; interleave the emissions from the transformed Observables, but instead emits these emissions in strict order, often called ConcatMap or something similar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bfb63abe1513baa690460365bb2e32de9329bf" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations there is also a ConcatMap operator (a.k.a. &lt;code&gt;concat_all&lt;/code&gt;, &lt;code&gt;concat_map&lt;/code&gt;, &lt;code&gt;concatMapObserver&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;forIn&lt;/code&gt;/&lt;code&gt;for_in&lt;/code&gt;, &lt;code&gt;mapcat&lt;/code&gt;, &lt;code&gt;selectConcat&lt;/code&gt;, or &lt;code&gt;selectConcatObserver&lt;/code&gt;) that transforms the items emitted by a source Observable into corresponding Observables and then concatenates the items emitted by each of these Observables in the order in which they are observed and transformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d6b73f37ee57d71fdff6d16884e54ade3b0ef5" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, there is a specialized observer interface, &lt;code&gt;Subscriber&lt;/code&gt;, that implements an &lt;code&gt;unsubscribe&lt;/code&gt; method. You can call this method to indicate that the Subscriber is no longer interested in any of the Observables it is currently subscribed to. Those Observables can then (if they have no other interested observers) choose to stop generating new items to emit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2949e25812bc031cf61fa47668bcad6970f74f74" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, there is an operator called something like &amp;ldquo;OnErrorResumeNext&amp;rdquo; that behaves like a Catch variant: specifically reacting to an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. In others, there is an operator with that name that behaves more like a Concat variant: performing the concatenation operation regardless of whether the source Observable terminates normally or with an error. This is unfortunate and confusing, but something we have to live with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb01da6c51b0285d3263e371d3483d2cae53174" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, your operator may need to be sensitive to that implementation&amp;rsquo;s &amp;ldquo;backpressure&amp;rdquo; strategies. (See, for example: &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;Pitfalls of Operator Implementations (part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d968bca48f34a1b9d629e8c8e5bc7f1f9e7409" translate="yes" xml:space="preserve">
          <source>In some circumstances, waiting until the last minute (that is, until subscription time) to generate the Observable can ensure that this Observable contains the freshest data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d97597b94f7d0965b9edaef42c16ac57210f4bf" translate="yes" xml:space="preserve">
          <source>In some implementations of ReactiveX, there is also an operator that converts an Observable into a &amp;ldquo;Blocking&amp;rdquo; Observable. A Blocking Observable extends the ordinary Observable by providing a set of methods, operating on the items emitted by the Observable, that block. Some of the To operators are in this Blocking Observable set of extended operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8063bc63842afdac26b9e318a09b125cd96bc99" translate="yes" xml:space="preserve">
          <source>In some implementations of ReactiveX, there is also something called a &amp;ldquo;Connectable&amp;rdquo; Observable. Such an Observable does not begin emitting items until its &lt;a href=&quot;operators/connect&quot;&gt;Connect&lt;/a&gt; method is called, whether or not any observers have subscribed to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037dec5a983c9517e8c8c6b9e8942bbe78e32581" translate="yes" xml:space="preserve">
          <source>In some implementations there are variants that allow you to adjust the criteria by which two items are considered &amp;ldquo;distinct.&amp;rdquo; In some, there is a variant of the operator that only compares an item against its immediate predecessor for distinctness, thereby filtering only &lt;em&gt;consecutive&lt;/em&gt; duplicate items from the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd136608bd7e489e77433f289366dd451d69a68" translate="yes" xml:space="preserve">
          <source>In some implementations there is also a Single operator. It behaves similarly to First except that it waits until the source Observable terminates in order to guarantee that it only emits a single item (otherwise, rather than emitting that item, it terminates with an error). You can use this to not only take the first item from the source Observable but to also guarantee that there was only one item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0dc45fcc76d537e1792d8725c9220fda83cacf" translate="yes" xml:space="preserve">
          <source>In some implementations there is also an UnsubscribeOn operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e47960cd978595f0079e3a0166c1245438c4c9" translate="yes" xml:space="preserve">
          <source>In some implementations, &lt;code&gt;First&lt;/code&gt; is not implemented as a filtering operator that returns an Observable, but as a blocking function that returns a particular item at such time as the source Observable emits that item. In those implementations, if you instead want a filtering operator, you may have better luck with &lt;a href=&quot;take&quot;&gt;&lt;code&gt;Take(1)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;elementat&quot;&gt;&lt;code&gt;ElementAt(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4334a2a1ddeb5e11e72e20d2fc45eef1bd9c0c63" translate="yes" xml:space="preserve">
          <source>In some implementations, &lt;code&gt;Last&lt;/code&gt; is not implemented as a filtering operator that returns an Observable, but as a blocking function that returns a particular item when the source Observable terminates. In those implementations, if you instead want a filtering operator, you may have better luck with &lt;a href=&quot;take&quot;&gt;&lt;code&gt;TakeLast(1)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a21a2695ee7461574576b39692f2c5743113615" translate="yes" xml:space="preserve">
          <source>In some implementations, there is also a ThrottleFirst operator that is similar, but emits not the most-recently emitted item in the sample period, but the &lt;em&gt;first&lt;/em&gt; item that was emitted during that period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6343b30db7af9b5aa728419488dd86296f2eea2" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxGroovy core there is also a specialty mapping operator, &lt;code&gt;encode&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978e2cb0f06af222730ceae268a71aa2cf8778d0" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxJava core there is also a specialty mapping operator, &lt;code&gt;encode&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c205481240cf9f67657691f8018f19dd3c8c2fa" translate="yes" xml:space="preserve">
          <source>In the above code, the source Observable emits the sequence &lt;code&gt;{ 1 2 3 4 5 }&lt;/code&gt;. When it emits the first item in this sequence, the &lt;code&gt;groupBy&lt;/code&gt; operator creates and emits a &lt;code&gt;GroupedObservable&lt;/code&gt; with the key of &lt;code&gt;0&lt;/code&gt;. The &lt;code&gt;flatMap&lt;/code&gt; operator applies the &lt;code&gt;take(1)&lt;/code&gt; operator to that &lt;code&gt;GroupedObservable&lt;/code&gt;, which gives it the item (&lt;code&gt;1&lt;/code&gt;) that it emits and that also unsubscribes from the &lt;code&gt;GroupedObservable&lt;/code&gt;, which is terminated. When the source Observable emits the second item in its sequence, the &lt;code&gt;groupBy&lt;/code&gt; operator creates and emits a &lt;em&gt;second&lt;/em&gt;&lt;code&gt;GroupedObservable&lt;/code&gt; with the same key (&lt;code&gt;0&lt;/code&gt;) to replace the one that was terminated. &lt;code&gt;flatMap&lt;/code&gt; again applies &lt;code&gt;take(1)&lt;/code&gt; to this new &lt;code&gt;GroupedObservable&lt;/code&gt; to retrieve the new item to emit (&lt;code&gt;2&lt;/code&gt;) and to unsubscribe from and terminate the &lt;code&gt;GroupedObservable&lt;/code&gt;, and this process repeats for the remaining items in the source sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a01097bd263f962d72c9a363627040454cd407d" translate="yes" xml:space="preserve">
          <source>In the asynchronous model the flow goes more like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b52ecbc0dd6f70ce33a2a266322bee10c5b7034" translate="yes" xml:space="preserve">
          <source>In the case of Action, the process is similar, but there is no return value. In this case, the Observable created by this operator will emit a &lt;code&gt;null&lt;/code&gt; before terminating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fae0c623313d6102a6c3767b510998af08ec342" translate="yes" xml:space="preserve">
          <source>In the case of a Future, it will emit the single result of the &lt;code&gt;get&lt;/code&gt; call. You may optionally pass the version of &lt;code&gt;from&lt;/code&gt; that accepts a future two additional parameters indicating a timeout span and the units of time that span is denominated in. The resulting Observable will terminate with an error if that span of time passes before the Future responds with a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0dcc4a6d4282af18fc9e92a4494b472d3679b88" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;join&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of each of them, delimited by a string of your choosing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af1cd94fd507d9f3d910ef5d0527af5287336a9" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;split&lt;/code&gt; operator that converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary, then merges the results of this split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5fda7ff19786c8da468ff346658e01540bcd69" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;stringConcat&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of them all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7212957ad6271a30e781217f05729777cde9078" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;join&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of each of them, delimited by a string of your choosing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbcfee3dbda596d98d950905c64f0d80750c8c34" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;split&lt;/code&gt; operator that converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary, then merges the results of this split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80fab375b638934674bb3b50669b96064b97edfb" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;stringConcat&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of them all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4360fc13798a2ced2520c5e5f6f7e632c555c696" translate="yes" xml:space="preserve">
          <source>In the separate &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, which is not included by default with RxGroovy, there is also a &lt;code&gt;runAsync&lt;/code&gt; function. Pass &lt;code&gt;runAsync&lt;/code&gt; an &lt;code&gt;Action&lt;/code&gt; and a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;, and it will return a &lt;code&gt;StoppableObservable&lt;/code&gt; that uses the specified &lt;code&gt;Action&lt;/code&gt; to generate items that it emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85226d29791a941dfdc4a830caf1c1b4e7fa5b2f" translate="yes" xml:space="preserve">
          <source>In the separate &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, which is not included by default with RxJava, there is also a &lt;code&gt;runAsync&lt;/code&gt; function. Pass &lt;code&gt;runAsync&lt;/code&gt; an &lt;code&gt;Action&lt;/code&gt; and a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;, and it will return a &lt;code&gt;StoppableObservable&lt;/code&gt; that uses the specified &lt;code&gt;Action&lt;/code&gt; to generate items that it emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c13cd89c3c45da83ad846b47b1bedfc77c6fafa" translate="yes" xml:space="preserve">
          <source>In this way you can include a &lt;code&gt;Future&lt;/code&gt; that returns an Observable in a cascade of Observables as a peer to other Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4249028943582ec355115c174d01896c5b993590" translate="yes" xml:space="preserve">
          <source>In this way, each item emitted by the resulting Observable is a function of the corresponding item in the source Observable and all of the items emitted by the source Observable after it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72cba1d7a40bef7433b1f435b701d906c44bcbac" translate="yes" xml:space="preserve">
          <source>Instead of passing multiple Observables (up to nine) into &lt;code&gt;merge&lt;/code&gt;, you could also pass in a &lt;code&gt;List&amp;lt;&amp;gt;&lt;/code&gt; (or other Iterable) of Observables, an Array of Observables, or even an Observable that emits Observables, and &lt;code&gt;merge&lt;/code&gt; will merge their output into the output of a single Observable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011efcd591019b5969a332a24dff728a8107dbe2" translate="yes" xml:space="preserve">
          <source>Interval</source>
          <target state="translated">Interval</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="21bcc15c6b9dfe99deeeef31607f80ad9a914de1" translate="yes" xml:space="preserve">
          <source>Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence. This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline. When using do, it is important to note that the Observer may receive additional events after a stream has completed or errored (such as when using a repeat or resubscribing). If you are using an Observable that extends the AbstractObservable, you will not receive these events. For this special case, use the DoObserver. doOnNext, doOnError, and doOnCompleted uses the DoObserver internally and will receive these additional events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d0b0f09c8bd2482d8e9bdd538591ca34488ba8f" translate="yes" xml:space="preserve">
          <source>Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002b9d3672a67b31dde384d5c82b77b20d5c5873" translate="yes" xml:space="preserve">
          <source>IsEmpty</source>
          <target state="translated">IsEmpty</target>
        </trans-unit>
        <trans-unit id="e9a2dbf8c765801c6abecc06d035b1c259eda973" translate="yes" xml:space="preserve">
          <source>It decides whether to resubscribe and remirror the source Observable by passing that Observable&amp;rsquo;s termination notifications (error or completed) to a notification handler as &lt;code&gt;void&lt;/code&gt; emissions. This notification handler acts as an Observable operator, taking an Observable that emits these &lt;code&gt;void&lt;/code&gt; notifications as input, and returning an Observable that emits &lt;code&gt;void&lt;/code&gt; items (meaning, resubscribe and mirror the source Observable) or terminates (meaning, terminate the sequence emitted by &lt;code&gt;repeatWhen&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05b47ee27b95bf575e3effc01ae6ec08f9813b1" translate="yes" xml:space="preserve">
          <source>It does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2649f51f97bc1799c96a9e6cbbf8c69285c15c00" translate="yes" xml:space="preserve">
          <source>It does not have the variant that uses the emissions from a second Observable to regulate the sampling periodicity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3a19396735f14c2206b8954fc9b9b7c96aadb3" translate="yes" xml:space="preserve">
          <source>It extends &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;the observer pattern&lt;/a&gt; to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39092222be5c5128f83455e200a511d51d81a068" translate="yes" xml:space="preserve">
          <source>It is &lt;a href=&quot;https://gist.github.com/4671081#file-futuresb-java-L163&quot;&gt;difficult to use Futures to optimally compose conditional asynchronous execution flows&lt;/a&gt; (or impossible, since latencies of each request vary at runtime). This &lt;a href=&quot;http://www.amazon.com/gp/product/0321349601?ie=UTF8&amp;amp;tag=none0b69&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321349601&quot;&gt;can be done&lt;/a&gt;, of course, but it quickly becomes complicated (and thus error-prone) or it prematurely blocks on &lt;code&gt;Future.get()&lt;/code&gt;, which eliminates the benefit of asynchronous execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f071bee56464f0e79be82a201585f9d5ef9e78d" translate="yes" xml:space="preserve">
          <source>It is a bad idea to use &lt;code&gt;reduce&lt;/code&gt; to collect emitted items into a mutable data structure. Instead, use &lt;code&gt;collect&lt;/code&gt; for that purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18385c80df1400f4f48ad03f26fe11b4b8b04677" translate="yes" xml:space="preserve">
          <source>It is good practice to check the observer&amp;rsquo;s &lt;code&gt;isUnsubscribed&lt;/code&gt; state from within the function you pass to &lt;code&gt;create&lt;/code&gt; so that your Observable can stop emitting items or doing expensive calculations when there is no longer an interested observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7151837303b01430de52221292363b8696a1db7" translate="yes" xml:space="preserve">
          <source>It is good practice to check the observer&amp;rsquo;s &lt;code&gt;isUnsubscribed&lt;/code&gt; state so that your Observable can stop emitting items or doing expensive calculations when there is no longer an interested observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9807d8fc75f41fdce45545c5c2eab52b2cde18ce" translate="yes" xml:space="preserve">
          <source>It is possible for an Observable to invoke its observers&amp;rsquo; methods asynchronously, perhaps from different threads. This could make such an Observable violate &lt;a href=&quot;../contract&quot;&gt;the Observable contract&lt;/a&gt;, in that it might try to send an &lt;code&gt;OnCompleted&lt;/code&gt; or &lt;code&gt;OnError&lt;/code&gt; notification before one of its &lt;code&gt;OnNext&lt;/code&gt; notifications, or it might make an &lt;code&gt;OnNext&lt;/code&gt; notification from two different threads concurrently. You can force such an Observable to be well-behaved and synchronous by applying the Serialize operator to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eff2d2cefa3f5847f61455d90784355746d0b04" translate="yes" xml:space="preserve">
          <source>It is sometimes called &amp;ldquo;functional reactive programming&amp;rdquo; but this is a misnomer. ReactiveX may be functional, and it may be reactive, but &amp;ldquo;functional reactive programming&amp;rdquo; is a different animal. One main point of difference is that functional reactive programming operates on values that change &lt;em&gt;continuously&lt;/em&gt; over time, while ReactiveX operates on &lt;em&gt;discrete&lt;/em&gt; values that are emitted over time. (See &lt;a href=&quot;https://github.com/conal/essence-and-origins-of-frp&quot;&gt;Conal Elliott&amp;rsquo;s work for more-precise information on functional reactive programming&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdbf510bdf3d816e45ee8d48f0cc1228dc05a4a9" translate="yes" xml:space="preserve">
          <source>It is usually best that you compose new operators by combining existing ones, to the extent that this is possible, rather than reinventing the wheel. RxJava itself does this with some of its standard operators, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89174431a1a966b8fb514184bda6c8efce66dfd4" translate="yes" xml:space="preserve">
          <source>It may call a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onNext( )&lt;/code&gt;&lt;/a&gt; method any number of times, but these calls must be non-overlapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1823f48cd27350e850e10e37c5ce6fe62ec4444" translate="yes" xml:space="preserve">
          <source>It may call either a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onCompleted( )&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onError( )&lt;/code&gt;&lt;/a&gt; method, but not both, exactly once, and it may not subsequently call a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onNext( )&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f070c7f11576ed486233e35474ddda41c4700b8" translate="yes" xml:space="preserve">
          <source>It requires one of the following distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca33803823f2ece4ecb5834672e63305ef95cfe5" translate="yes" xml:space="preserve">
          <source>It requires one of the following packages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d3d61d261c2ecef4925faed7443e2f2b6b049b" translate="yes" xml:space="preserve">
          <source>It requires one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595e4e764020b5cf5ee3bcbb8f01313e97b8eb51" translate="yes" xml:space="preserve">
          <source>It will also emit this same final value to any subsequent observers. However, if the source Observable terminates with an error, the &lt;code&gt;AsyncSubject&lt;/code&gt; will not emit any items, but will simply pass along the error notification from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f02c71d6fa00b4deeade3bfbabd8b4f0199f33" translate="yes" xml:space="preserve">
          <source>Iterable (pull)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c1c3007f7e0cc78d64781295922fced377fcae" translate="yes" xml:space="preserve">
          <source>Iterables, for example, can be thought of as a sort of synchronous Observable; Futures, as a sort of Observable that always emits only a single item. By explicitly converting such objects to Observables, you allow them to interact as peers with other Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4315de8eb96f9d5efab572bae1c956c26e04d48" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#all(io.reactivex.functions.Predicate)&quot;&gt;&lt;code&gt;all(Predicate)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2d2bb807348c5a5bb2c5970e7049467cbc2bc0" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#amb(java.lang.Iterable)&quot;&gt;&lt;code&gt;amb(Iterable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d652bb88043ecd2f247b688bb25aba237a1670" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#ambWith(io.reactivex.ObservableSource)&quot;&gt;&lt;code&gt;ambWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79801e93b31ea69def0891c5ca351103123a0395" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#empty()&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d612270b0b6dae224275e36de2f214e983b9162a" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.lang.Throwable)&quot;&gt;&lt;code&gt;error(Throwable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739b3189dd25d213d0efe5f2677878877c3bb018" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.util.concurrent.Callable)&quot;&gt;&lt;code&gt;error(Callable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d7842c837d4d62344821564ad93d023e2720cb" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#never()&quot;&gt;&lt;code&gt;never()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d8819c38a240885157cbd94598334402e3674d" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#all(rx.functions.Func1)&quot;&gt;&lt;code&gt;all(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e16a78f86bba91a61a8a39b0bee1639141b4a0" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(java.lang.Iterable)&quot;&gt;&lt;code&gt;amb(Iterable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb914eb34da607efe1851c51fece981b8a5d93ad" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(rx.Observable,%20rx.Observable)&quot;&gt;&lt;code&gt;amb(Observable,Observable)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observable parameters)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa8dcea2523bcdb9be5374ff461051895601ef9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#ambWith(rx.Observable)&quot;&gt;&lt;code&gt;ambWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ac6f58e233b25dd5d275d2b6dbbeb82402fadfd" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int)&quot;&gt;&lt;code&gt;buffer(int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f4da8ad769c45ae36504e5e4b7db9678f04beed" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int)&quot;&gt;&lt;code&gt;buffer(int,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3114cc9509b09ba21be9976417c1d41b12b542" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f079df920af6fbe33cc7438b0af7d1b861068b58" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f01ab7dca8a888386fa5570d9f0b2e382b0f4a" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,int,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a169daeda654c4fee9bff30b2d8a9d0424179071" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b62647dc23afa8babf67cfbc877e420f4ebb819" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;buffer(long,long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a877f462a5deb198dfc0204b93c36359d93eae06" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,long,TimeUnit,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d0c1c1c839634afc3f6c3c4a219ba201e6a4f2" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable)&quot;&gt;&lt;code&gt;buffer(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507fd0d63c19e5259957c06f2c5e974b2361ac5e" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int)&quot;&gt;&lt;code&gt;buffer(Observable,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19480f4a8a048d195247eca7c8ae389d06924f5d" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1)&quot;&gt;&lt;code&gt;buffer(Observable,Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c5bc0bbf6f71e96eeb78bdbb7b8d2effc287b6" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)&quot;&gt;&lt;code&gt;buffer(Func0)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4208c1d7ad4205ea40fa25a698af88ff2e762b45" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#cast(java.lang.Class)&quot;&gt;&lt;code&gt;cast(Class)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3db7ed2c0b62e5c36cbfc3fa2ca492c81d1a49" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#collect(rx.functions.Func0,%20rx.functions.Action2)&quot;&gt;&lt;code&gt;collect(Func0,Action2)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa67b873ecab3613f6b64ce78a0bdc32e5926fa9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(java.util.List,%20rx.functions.FuncN)&quot;&gt;&lt;code&gt;combineLatest(List,FuncN)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7df6aac2f2e3c95a112f207b4dbda0f7a7d0c6" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(rx.Observable,%20rx.Observable,%20rx.functions.Func2)&quot;&gt;&lt;code&gt;combineLatest(Observable,Observable,Func2)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observables)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065654bfbdd9b9bee866590ec170ff626ea47e08" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable)&quot;&gt;&lt;code&gt;concat(Observable&amp;lt;Observable&amp;gt;)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5260958a449491f7610db2dc9bb82bc9b45e109" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable,%20rx.Observable)&quot;&gt;&lt;code&gt;concat(Observable,Observable)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observables)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e62fe96dcbddd17b24ab4cd101fe1c35a3d6df" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1)&quot;&gt;&lt;code&gt;concatMap(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f8062d4eceee18625891f695512adafea0ce1b" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatWith(rx.Observable)&quot;&gt;&lt;code&gt;concatWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af422290d005f62aabe996a727d72476d3979818" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#contains(java.lang.Object)&quot;&gt;&lt;code&gt;contains(Object)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70bacf76ad19d833c6f617bc4a72f0211c2df6b9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#count()&quot;&gt;&lt;code&gt;count()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0135bdfd6a0be2f5741df4e612e42cc09264016" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#countLong()&quot;&gt;&lt;code&gt;countLong()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6913a045e4bd9b5ec923b8deed52b537c92fcf3" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#create(rx.Observable.OnSubscribe)&quot;&gt;&lt;code&gt;create(OnSubscribe)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4e32a121d2f3b9718d60b90e2a55ca637ed7d5" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(rx.functions.Func1)&quot;&gt;&lt;code&gt;debounce(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e04e6e0b8a579ec0455332f25d673a969ebe63" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defaultIfEmpty(T)&quot;&gt;&lt;code&gt;defaultIfEmpty(T)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3665f849f7caae696ee21ed577b42416b67b5e53" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defer(rx.functions.Func0)&quot;&gt;&lt;code&gt;defer()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24e91a0b092b6e002922bb2340a890ca0edec33" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;delay(long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2b29abfc91519e0f51d0c4dd0da82457c7399e" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717692751f13ce675134817fa7e5eb5df12afdf9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(rx.functions.Func0,%20rx.functions.Func1)&quot;&gt;&lt;code&gt;delay(Func0,Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28652dbaa998ef055bfae73545644254032f18f7" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(rx.functions.Func1)&quot;&gt;&lt;code&gt;delay(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2d3eaa5e2b4a6de4f63add88066188b5713b58" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;delaySubscription(long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d3288afe0ee571db849a975fd47547f1f0c1ce" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;delaySubscription(long,TimeUnit,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="732a9dca672863690786565ad8aeb72f70cc9ad4" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(rx.functions.Func0)&quot;&gt;&lt;code&gt;delaySubscription(Func0)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4ab76a7d58dd80c667fcaf6ae9ad090f1d9e2c" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#dematerialize()&quot;&gt;&lt;code&gt;dematerialize()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b84e8d69464f02b4e83d67f6aafc31e664487c8" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinct()&quot;&gt;&lt;code&gt;distinct()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046ec7ac723e7f013f3cb8dc9ce884d56026d7c8" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinct(rx.functions.Func1)&quot;&gt;&lt;code&gt;distinct(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd753995d2d0e9d3e50e36ab555fb17a25a42252" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinctUntilChanged()&quot;&gt;&lt;code&gt;distinctUntilChanged()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b2d5a3d5a6fe7ff7b10d7e0aec9cad965a35b4" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinctUntilChanged(rx.functions.Func1)&quot;&gt;&lt;code&gt;distinctUntilChanged(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64731c436cc8b38ff8a2297e8f2a2c3906bef4b" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#doAfterTerminate(rx.functions.Action0)&quot;&gt;&lt;code&gt;doAfterTerminate(Action0)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaad85d05872a51e0db5300421a45cbee9210698" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnCompleted(rx.functions.Action0)&quot;&gt;&lt;code&gt;doOnCompleted(Action0)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e9d8725a20e51dffd34601bb2cd9e2122166dd" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnEach(rx.Observer)&quot;&gt;&lt;code&gt;doOnEach(Observer)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bccca67551e1deb0e7c77c5c4459400e581048c" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnEach(rx.functions.Action1)&quot;&gt;&lt;code&gt;doOnEach(Action1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c41b9ac0ef357333d22842402fc9ebc508ae3c0" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnError(rx.functions.Action1)&quot;&gt;&lt;code&gt;doOnError(Action1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0b6dadbfc900d997d2578671f7c1badc8f13c0" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnNext(rx.functions.Action1)&quot;&gt;&lt;code&gt;doOnNext(Action1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc6382298342fc9973a930b0734cebe882d9aac" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnRequest(rx.functions.Action1)&quot;&gt;&lt;code&gt;doOnRequest(Action1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8690344363f64bde6c1d0822714044264f5b49ff" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnSubscribe(rx.functions.Action0)&quot;&gt;&lt;code&gt;doOnSubscribe(Action0)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
