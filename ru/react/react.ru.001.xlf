<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127b65641fa47a43d190a53aa1819065ddbc9d8b" translate="yes" xml:space="preserve">
          <source>&amp;hellip;could be rewritten using a React component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411af19f51081800932d697191d96f1ba6662478" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;CSS-in-JS&amp;rdquo; refers to a pattern where CSS is composed using JavaScript instead of defined in external files. Read a comparison of CSS-in-JS libraries &lt;a href=&quot;https://github.com/MicheleBertoli/css-in-js&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474f555551dc0ace2b8ee29980fc27176a860957" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Create&amp;rdquo; wouldn&amp;rsquo;t be quite accurate because the state is only created the first time our component renders. During the next renders, &lt;code&gt;useState&lt;/code&gt; gives us the current state. Otherwise it wouldn&amp;rsquo;t be &amp;ldquo;state&amp;rdquo; at all! There&amp;rsquo;s also a reason why Hook names &lt;em&gt;always&lt;/em&gt; start with &lt;code&gt;use&lt;/code&gt;. We&amp;rsquo;ll learn why later in the &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f451b7c89dd904f3aef210c86d4117268ade522" translate="yes" xml:space="preserve">
          <source>&amp;lt;SuspenseList&amp;gt;</source>
          <target state="translated">&amp;lt;SuspenseList&amp;gt;</target>
        </trans-unit>
        <trans-unit id="003bacc820ad6ed64a7150ba533c1f205d753675" translate="yes" xml:space="preserve">
          <source>(The identity of the &lt;code&gt;setCount&lt;/code&gt; function is guaranteed to be stable so it&amp;rsquo;s safe to omit.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5537feccba2706d8c7567ba108d3ea81718c256a" translate="yes" xml:space="preserve">
          <source>(This same property also allows &lt;code&gt;connect&lt;/code&gt; and other enhancer-style HOCs to be used as decorators, an experimental JavaScript proposal.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec0311501a4dc653fb7b1449410f6e5df587029" translate="yes" xml:space="preserve">
          <source>**: Warns in development.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7fd61b5cc7e86f044d5b2120a1f2f5e7dd0bde" translate="yes" xml:space="preserve">
          <source>*: Legacy mode has automatic batching in React-managed events but it&amp;rsquo;s limited to one browser task. Non-React events must opt-in using &lt;code&gt;unstable_batchedUpdates&lt;/code&gt;. In Blocking Mode and Concurrent Mode, all &lt;code&gt;setState&lt;/code&gt;s are batched by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b349d3c84eca2532fac6087f7427aeb1fb288d12" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#example-using-classes-1&quot;&gt;Earlier on this page&lt;/a&gt;, we introduced an example &lt;code&gt;FriendStatus&lt;/code&gt; component that displays whether a friend is online or not. Our class reads &lt;code&gt;friend.id&lt;/code&gt; from &lt;code&gt;this.props&lt;/code&gt;, subscribes to the friend status after the component mounts, and unsubscribes during unmounting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d0e66fe3bcbaf7fb71d7c9c7ced93e8dcd7d2f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#experimental-channel&quot;&gt;&lt;strong&gt;Experimental&lt;/strong&gt;&lt;/a&gt; includes experimental APIs and features that aren&amp;rsquo;t available in the stable releases. These also track the master branch, but with additional feature flags turned on. Use this to try out upcoming features before they are released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8acd483f2b7766c5939834892982283be276ca" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#latest-channel&quot;&gt;&lt;strong&gt;Latest&lt;/strong&gt;&lt;/a&gt; is for stable, semver React releases. It&amp;rsquo;s what you get when you install React from npm. This is the channel you&amp;rsquo;re already using today. &lt;strong&gt;Use this for all user-facing React applications.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f331b32dba01c22c3f9ee9dcd30160741976454" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#next-channel&quot;&gt;&lt;strong&gt;Next&lt;/strong&gt;&lt;/a&gt; tracks the master branch of the React source code repository. Think of these as release candidates for the next minor semver release. Use this for integration testing between React and third party projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1626442757705f12d753a3a5d0a59017c028e31a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#optional-try-react-with-jsx&quot;&gt;Optional: Try React with JSX&lt;/a&gt; (no bundler necessary!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659e2140b913cf60f03be174b35c605c49e283a8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;components-and-props&quot;&gt;&lt;code&gt;props&lt;/code&gt;&lt;/a&gt; (short for &amp;ldquo;properties&amp;rdquo;) and &lt;a href=&quot;state-and-lifecycle&quot;&gt;&lt;code&gt;state&lt;/code&gt;&lt;/a&gt; are both plain JavaScript objects. While both hold information that influences the output of render, they are different in one important way: &lt;code&gt;props&lt;/code&gt; get passed &lt;em&gt;to&lt;/em&gt; the component (similar to function parameters) whereas &lt;code&gt;state&lt;/code&gt; is managed &lt;em&gt;within&lt;/em&gt; the component (similar to variables declared within a function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11587663134187b0dab35da7c0f9449ba536da9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-adoption&quot;&gt;Adopting Concurrent Mode&lt;/a&gt; explains how you can try Concurrent Mode in your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d6142e8402580e0bbbd015a289393a5ab03417" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt; shows some UI patterns made possible by Concurrent Mode and Suspense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13c6c20a36b89ed034032b2df5848a62e0eae1e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-reference&quot;&gt;Concurrent Mode API Reference&lt;/a&gt; documents the new APIs available in experimental builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8b0168cc4bbf653a7b87a3e660739cc7e23de3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense for Data Fetching&lt;/a&gt; describes a new mechanism for fetching data in React components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b3a6755e2482086d497d80dc7b04fda7312afb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;error-boundaries&quot;&gt;Error boundaries&lt;/a&gt; are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50dd970eac1bdc84a77e8463664190c3a8e7086a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;forms#controlled-components&quot;&gt;Controlled&lt;/a&gt; vs. &lt;a href=&quot;uncontrolled-components&quot;&gt;Uncontrolled Components&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9deaea842b2a2025b0d2c4183deba20a474ebb43" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;hooks-overview&quot;&gt;Hooks at a Glance&lt;/a&gt; is a good place to start learning Hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbff4fdc2fc809052b076958d62db8674fc3040e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html&quot;&gt;Subscriptions&lt;/a&gt; in Rx.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd0571199be7c81b3ae4cbaac1e3b4ad6076fd6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt; views typically use HTML strings, or string-producing template functions, to create the content for their DOM elements. This process, too, can be replaced with rendering a React component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af6fbc549852becb801f8d5e2e60f7a599b43ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/a&gt; is a way of queuing a function to be executed in the browser at the optimal time for rendering performance. A function that is queued with &lt;code&gt;requestAnimationFrame&lt;/code&gt; will fire in the next frame. The browser will work hard to ensure that there are 60 frames per second (60 fps). However, if the browser is unable to it will naturally &lt;em&gt;limit&lt;/em&gt; the amount of frames in a second. For example, a device might only be able to handle 30 fps and so you will only get 30 frames in that second. Using &lt;code&gt;requestAnimationFrame&lt;/code&gt; for throttling is a useful technique in that it prevents you from doing more than 60 updates in a second. If you are doing 100 updates in a second this creates additional work for the browser that the user will not see anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc593d53096ee1019613a19d2c3be835f80be32a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;React Native 0.59&lt;/a&gt; and above support Hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7761f99601bdbfa373520f6ad6ca588b809637c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; is a static type checker for your JavaScript code. It is developed at Facebook and is often used with React. It lets you annotate the variables, functions, and React components with a special type syntax, and catch mistakes early. You can read an &lt;a href=&quot;https://flow.org/en/docs/getting-started/&quot;&gt;introduction to Flow&lt;/a&gt; to learn its basics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc4ff25c8b08bae8e391179afdb401d0925dc91" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; has this plugin with a subset of rules activated. If you want to enable even more accessibility rules, you can create an &lt;code&gt;.eslintrc&lt;/code&gt; file in the root of your project with this content:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fce689a30d167b5be218e539f61cb024a4501e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; is a comfortable environment for &lt;strong&gt;learning React&lt;/strong&gt;, and is the best way to start building &lt;strong&gt;a new &lt;a href=&quot;glossary#single-page-application&quot;&gt;single-page&lt;/a&gt; application&lt;/strong&gt; in React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b261ad394a28f97a4ba639292739131c48b332" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting&quot;&gt;Algebraic effects&lt;/a&gt; in Multicore OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1beba2269c05a33decc78c25f4769e740904efe9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/sebmarkbage&quot;&gt;Sebastian Markb&amp;aring;ge&lt;/a&gt; came up with the original design for Hooks, later refined by &lt;a href=&quot;https://github.com/acdlite&quot;&gt;Andrew Clark&lt;/a&gt;, &lt;a href=&quot;https://github.com/sophiebits&quot;&gt;Sophie Alpert&lt;/a&gt;, &lt;a href=&quot;https://github.com/trueadm&quot;&gt;Dominic Gannaway&lt;/a&gt;, and other members of the React team.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a028d74af46c420b5cfb12fdc16fbb5b92d0f34c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/trueadm&quot;&gt;Dominic Gannaway&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067&quot;&gt;&lt;code&gt;adopt&lt;/code&gt; keyword&lt;/a&gt; proposal as a sugar syntax for render props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2a5cf38e105f920474aadb97cc98a8fb17e6a5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://kotlinlang.org/&quot;&gt;Kotlin&lt;/a&gt; is a statically typed language developed by JetBrains. Its target platforms include the JVM, Android, LLVM, and &lt;a href=&quot;https://kotlinlang.org/docs/reference/js-overview.html&quot;&gt;JavaScript&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b406c5a7ef4d2530bdb4fca8799640b156ac54" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://nextjs.org/&quot;&gt;Next.js&lt;/a&gt; is a popular and lightweight framework for &lt;strong&gt;static and server‑rendered applications&lt;/strong&gt; built with React. It includes &lt;strong&gt;styling and routing solutions&lt;/strong&gt; out of the box, and assumes that you&amp;rsquo;re using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; as the server environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee851673be2d30ea8c8f63acabb6e99b5c8864b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://react-window.now.sh/&quot;&gt;react-window&lt;/a&gt; and &lt;a href=&quot;https://bvaughn.github.io/react-virtualized/&quot;&gt;react-virtualized&lt;/a&gt; are popular windowing libraries. They provide several reusable components for displaying lists, grids, and tabular data. You can also create your own windowing component, like &lt;a href=&quot;https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3&quot;&gt;Twitter did&lt;/a&gt;, if you want something more tailored to your application&amp;rsquo;s specific use case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec74ab70c3c50d041a9625d49999fc73d2b52df" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key&quot;&gt;Here&lt;/a&gt; is an example of the issues that can be caused by using indexes as keys on CodePen, and &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key&quot;&gt;here&lt;/a&gt; is an updated version of the same example showing how not using indexes as keys will fix these reordering, sorting, and prepending issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60eebbd123cdc3177bbe55d829eb6495eb0a2456" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://reasonml.github.io/&quot;&gt;Reason&lt;/a&gt; is not a new language; it&amp;rsquo;s a new syntax and toolchain powered by the battle-tested language, &lt;a href=&quot;https://ocaml.org/&quot;&gt;OCaml&lt;/a&gt;. Reason gives OCaml a familiar syntax geared toward JavaScript programmers, and caters to the existing NPM/Yarn workflow folks already know.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51704da4ca578722a2b6aecca6033abc42fafc9c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html&quot;&gt;Reducer components&lt;/a&gt; in ReasonReact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507c854bed88971402cdd4e75eb17ff213b9f9a9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.chromevox.com/&quot;&gt;ChromeVox&lt;/a&gt; is an integrated screen reader on Chromebooks and is available &lt;a href=&quot;https://chrome.google.com/webstore/detail/chromevox/kgejglhpjiefppelpmljglcjbhoiplfn?hl=en&quot;&gt;as an extension&lt;/a&gt; for Google Chrome.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95e67778c2804202a6bfb18c1978277a39275e9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.deque.com/products/axe/&quot;&gt;The Accessibility Engine&lt;/a&gt; or aXe, is an accessibility inspector browser extension built on &lt;code&gt;aXe-core&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f8e9ad7eafaa77baf2a863ca7a0a7708237a83" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.freedomscientific.com/Products/software/JAWS/&quot;&gt;Job Access With Speech&lt;/a&gt; or JAWS, is a prolifically used screen reader on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c59281500e4647172f2bc7d1c2d241f8533e108" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt; is the best way to create &lt;strong&gt;static websites&lt;/strong&gt; with React. It lets you use React components, but outputs pre-rendered HTML and CSS to guarantee the fastest load time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e111bc5c6ed31a7244c06ecd3a45a04232ee6e59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.nvaccess.org/&quot;&gt;NonVisual Desktop Access&lt;/a&gt; or NVDA is an open source Windows screen reader that is widely used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1c72f7a39fed3103f79e6934d680b5f8640aa0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.paciellogroup.com/blog/2015/01/the-browser-accessibility-tree/&quot;&gt;The Accessibility Tree&lt;/a&gt; is a subset of the DOM tree that contains accessible objects for every DOM element that should be exposed to assistive technology, such as screen readers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b37c8997661be6f87f540ff73ff4239f26b970f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; is a programming language developed by Microsoft. It is a typed superset of JavaScript, and includes its own compiler. Being a typed language, TypeScript can catch errors and bugs at build time, long before your app goes live. You can learn more about using TypeScript with React &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter#typescript-react-starter&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0a68c5959b325979016d4ef5818f5d3835df00" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;This post by Yehuda Katz&lt;/a&gt; explains what binding is, and how functions work in JavaScript, in detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df88d6cbd086d1137e1b90460b2ae5daeb6e02d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;testing-environments&quot;&gt;Environments&lt;/a&gt;: What to consider when setting up a testing environment for React components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a050b272e7248967a84a74e4e4bd2b6ba64fa3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;testing-recipes&quot;&gt;Recipes&lt;/a&gt;: Common patterns when writing tests for React components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b486e3fcc27a7fb19f9db032b3f4035175b1759" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;testing-recipes&quot;&gt;Testing Recipes&lt;/a&gt; include many examples that you can copy and paste.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899e47cb75bdfa2c9463f015b04ba588ae7307f2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Try it on CodePen&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2668baa3995626a387d9d0db8c0e74c80d30c4e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;Columns /&amp;gt;&lt;/code&gt; would need to return multiple &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; elements in order for the rendered HTML to be valid. If a parent div was used inside the &lt;code&gt;render()&lt;/code&gt; of &lt;code&gt;&amp;lt;Columns /&amp;gt;&lt;/code&gt;, then the resulting HTML will be invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c48f4f018d496ec7a9fc3610cfc090f4535bedd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; coordinates the &amp;ldquo;reveal order&amp;rdquo; of the closest &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; nodes below it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16be52f847db59c8b851d5a60c48482650c507e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; is the last pattern that&amp;rsquo;s related to orchestrating loading states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b873bb3d00c9528b75a68b611f719965252de42f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.ts&lt;/code&gt; is the default file extension while &lt;code&gt;.tsx&lt;/code&gt; is a special extension used for files which contain &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cce24d484768d091fea665846435e70110e03e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Clock&lt;/code&gt; is now defined as a class rather than a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97fbce190263926ad39364b0f1f1231de906168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;BlogPost&lt;/code&gt; aren&amp;rsquo;t identical &amp;mdash; they call different methods on &lt;code&gt;DataSource&lt;/code&gt;, and they render different output. But much of their implementation is the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9dc387b207d4eba8712af5ec2de3b114017f7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ProductTable&lt;/code&gt; needs to filter the product list based on state and &lt;code&gt;SearchBar&lt;/code&gt; needs to display the search text and checked state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3ab449a39f9f5441443dff9073f64b0a14d353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Profiler&lt;/code&gt; components can also be nested to measure different components within the same subtree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc64e9219fbd2d98085de711a35c090291ff1ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PropTypes&lt;/code&gt; exports a range of validators that can be used to make sure the data you receive is valid. In this example, we&amp;rsquo;re using &lt;code&gt;PropTypes.string&lt;/code&gt;. When an invalid value is provided for a prop, a warning will be shown in the JavaScript console. For performance reasons, &lt;code&gt;propTypes&lt;/code&gt; is only checked in development mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7433c619e1feef93841473f073fe57946d546b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Children.only()&lt;/code&gt; does not accept the return value of &lt;a href=&quot;#reactchildrenmap&quot;&gt;&lt;code&gt;React.Children.map()&lt;/code&gt;&lt;/a&gt; because it is an array rather than a React element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f33ecc6e1fa8a4fb53220f221a88fd97f9222c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Children.toArray()&lt;/code&gt; changes keys to preserve the semantics of nested arrays when flattening lists of children. That is, &lt;code&gt;toArray&lt;/code&gt; prefixes each key in the returned array so that each element&amp;rsquo;s key is scoped to the input array containing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c08083eb996286312bfeec14c446492e6409fb5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Children&lt;/code&gt; provides utilities for dealing with the &lt;code&gt;this.props.children&lt;/code&gt; opaque data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018109caa5a7750f42f534d290130aa5ba7f1575" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Component&lt;/code&gt; is the base class for React components when they are defined using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 classes&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1cd67a9840c43ed56a80ec7fe993b83656c3558" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PropTypes&lt;/code&gt; has moved into a different package since React v15.5. Please use &lt;a href=&quot;https://www.npmjs.com/package/prop-types&quot;&gt;the &lt;code&gt;prop-types&lt;/code&gt; library instead&lt;/a&gt; to define &lt;code&gt;contextTypes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17765e95c09179d1a95a33445f4c103ce3e81d08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PropTypes&lt;/code&gt; has moved into a different package since React v15.5. Please use &lt;a href=&quot;https://www.npmjs.com/package/prop-types&quot;&gt;the &lt;code&gt;prop-types&lt;/code&gt; library instead&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e47fb792a667b98cb29e172a0434b512bebe3c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PureComponent&lt;/code&gt; is similar to &lt;a href=&quot;#reactcomponent&quot;&gt;&lt;code&gt;React.Component&lt;/code&gt;&lt;/a&gt;. The difference between them is that &lt;a href=&quot;#reactcomponent&quot;&gt;&lt;code&gt;React.Component&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t implement &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;React.PureComponent&lt;/code&gt; implements it with a shallow prop and state comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5830b5c8c2f558edfa97e94aca64c2af14fc9e12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.PureComponent&lt;/code&gt;&amp;rsquo;s &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; only shallowly compares the objects. If these contain complex data structures, it may produce false-negatives for deeper differences. Only extend &lt;code&gt;PureComponent&lt;/code&gt; when you expect to have simple props and state, or use &lt;a href=&quot;react-component#forceupdate&quot;&gt;&lt;code&gt;forceUpdate()&lt;/code&gt;&lt;/a&gt; when you know deep data structures have changed. Or, consider using &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;immutable objects&lt;/a&gt; to facilitate fast comparisons of nested data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ae44fbe5544ebea07424d1801e6b09421fc455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Suspense&lt;/code&gt; lets you specify the loading indicator in case some components in the tree below it are not yet ready to render. Today, lazy loading components is the &lt;strong&gt;only&lt;/strong&gt; use case supported by &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf12260a4d1986fe548b7810036d6f89476f037" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.cloneElement()&lt;/code&gt; is almost equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df454f22d5923251d189f07fbd28b56e61571dff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.createElement()&lt;/code&gt; performs a few checks to help you write bug-free code but essentially it creates an object like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a541b1aa2e0e5adb6bae8f98abbd479633f37ffb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.createRef&lt;/code&gt; creates a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; that can be attached to React elements via the ref attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9470bd7cce89bd9b552d1800bb64522b645d38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.forwardRef&lt;/code&gt; accepts a render function. React DevTools uses this function to determine what to display for the ref forwarding component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b305dfd057aa13a5b67ab3715db62a57fee6b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.forwardRef&lt;/code&gt; accepts a rendering function as an argument. React will call this function with &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; as two arguments. This function should return a React node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5cdd473870d55755460b2032f82f8197284441" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.forwardRef&lt;/code&gt; creates a React component that forwards the &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; attribute it receives to another component below in the tree. This technique is not very common but is particularly useful in two scenarios:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d938930a6dc525df60638ade414c3cc420a5e7a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy()&lt;/code&gt; and &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; are not yet supported by &lt;code&gt;ReactDOMServer&lt;/code&gt;. This is a known limitation that will be resolved in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc934f42399b1985220d1173b8db1839de195a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy()&lt;/code&gt; lets you define a component that is loaded dynamically. This helps reduce the bundle size to delay loading components that aren&amp;rsquo;t used during the initial render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5578f0ee78405460ecdf6cc8a4e6b079c3e56038" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy&lt;/code&gt; and Suspense are not yet available for server-side rendering. If you want to do code-splitting in a server rendered app, we recommend &lt;a href=&quot;https://github.com/gregberge/loadable-components&quot;&gt;Loadable Components&lt;/a&gt;. It has a nice &lt;a href=&quot;https://loadable-components.com/docs/server-side-rendering/&quot;&gt;guide for bundle splitting with server-side rendering&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2cad079d46e6ccdc27029a5fb3af33ccc454b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy&lt;/code&gt; currently only supports default exports. If the module you want to import uses named exports, you can create an intermediate module that reexports it as the default. This ensures that tree shaking keeps working and that you don&amp;rsquo;t pull in unused components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4700ecfe3a1cff452d92f397192e719da048b8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.lazy&lt;/code&gt; takes a function that must call a dynamic &lt;code&gt;import()&lt;/code&gt;. This must return a &lt;code&gt;Promise&lt;/code&gt; which resolves to a module with a &lt;code&gt;default&lt;/code&gt; export containing a React component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1290b39eae5fe11f9950b57588fb97ad5431dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.memo&lt;/code&gt; doesn&amp;rsquo;t compare state because there is no single state object to compare. But you can make children pure too, or even &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;optimize individual children with &lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66970190886b14b2c94f1ed78940166904931843" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.memo&lt;/code&gt; is a &lt;a href=&quot;higher-order-components&quot;&gt;higher order component&lt;/a&gt;. It&amp;rsquo;s similar to &lt;a href=&quot;#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt; but for function components instead of classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ccf91e6ecdbd40744e7e90f5f7170b3011bafa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.memo&lt;/code&gt; only affects props changes. If your function component wrapped in &lt;code&gt;React.memo&lt;/code&gt; has a &lt;a href=&quot;hooks-state&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;hooks-reference#usecontext&quot;&gt;&lt;code&gt;useContext&lt;/code&gt;&lt;/a&gt; Hook in its implementation, it will still rerender when state or context change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91643c882bd9cf17080a88dd543c08f704be877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React&lt;/code&gt; also provides a component for rendering multiple elements without a wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae43399d30647f75931bc2d52220896440d778a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React&lt;/code&gt; is the entry point to the React library. If you load React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, these top-level APIs are available on the &lt;code&gt;React&lt;/code&gt; global. If you use ES6 with npm, you can write &lt;code&gt;import React from 'react'&lt;/code&gt;. If you use ES5 with npm, you can write &lt;code&gt;var React = require('react')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3615ce490a38501b5360b29feca2783c841a8758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React&lt;/code&gt; provides several APIs for manipulating elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7e3ecfcf94508081f0ca1cf574d0e0e6d68290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactDOM.render()&lt;/code&gt; controls the contents of the container node you pass in. Any existing DOM elements inside are replaced when first called. Later calls use React&amp;rsquo;s DOM diffing algorithm for efficient updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f4db9c76d599ded6bfea76a35e0173f2582126" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactDOM.render()&lt;/code&gt; currently returns a reference to the root &lt;code&gt;ReactComponent&lt;/code&gt; instance. However, using this return value is legacy and should be avoided because future versions of React may render components asynchronously in some cases. If you need a reference to the root &lt;code&gt;ReactComponent&lt;/code&gt; instance, the preferred solution is to attach a &lt;a href=&quot;refs-and-the-dom#the-ref-callback-attribute&quot;&gt;callback ref&lt;/a&gt; to the root element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83e4204803e18af5dd3272048dc8dba0c732a8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactDOM.render()&lt;/code&gt; does not modify the container node (only modifies the children of the container). It may be possible to insert a component to an existing DOM node without overwriting the existing children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f7dde00d003271a0091e8b41dbc64eae6d5e284" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReactTestUtils&lt;/code&gt; makes it easy to test React components in the testing framework of your choice. At Facebook we use &lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt; for painless JavaScript testing. Learn how to get started with Jest through the Jest website&amp;rsquo;s &lt;a href=&quot;https://jestjs.io/docs/tutorial-react&quot;&gt;React Tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd2b659f315e86293bf644a22ac16f387ac0277f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Simulate&lt;/code&gt; has a method for &lt;a href=&quot;events#supported-events&quot;&gt;every event that React understands&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9b366d2fde5d1534fe678bffb7dc6cbc1913da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StrictMode&lt;/code&gt; currently helps with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b45b72193b0a444ab87433ca3e645c1e2c176e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StrictMode&lt;/code&gt; is a tool for highlighting potential problems in an application. Like &lt;code&gt;Fragment&lt;/code&gt;, &lt;code&gt;StrictMode&lt;/code&gt; does not render any visible UI. It activates additional checks and warnings for its descendants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69072622222cfc87d353eb0706836314f01d7e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Suspense&lt;/code&gt; lets your components &amp;ldquo;wait&amp;rdquo; for something before they can render, showing a fallback while waiting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f13097fb272439581958cc937f5a594b5ae6f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Suspense&lt;/code&gt; takes two props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b3b188f6719c719354021035ef95073139c0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SuspenseList&lt;/code&gt; helps coordinate many components that can suspend by orchestrating the order in which these components are revealed to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fdc3ef578f32bfcee8d8a256db89f9b702e93d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SuspenseList&lt;/code&gt; takes two props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2909efd08bf4d421275bca9913266c684a9919bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillMount()&lt;/code&gt; is invoked just before mounting occurs. It is called before &lt;code&gt;render()&lt;/code&gt;, therefore calling &lt;code&gt;setState()&lt;/code&gt; synchronously in this method will not trigger an extra rendering. Generally, we recommend using the &lt;code&gt;constructor()&lt;/code&gt; instead for initializing state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fac26e669294deda8052265a59dbbd3e0d2d0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; is invoked before a mounted component receives new props. If you need to update the state in response to prop changes (for example, to reset it), you may compare &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;nextProps&lt;/code&gt; and perform state transitions using &lt;code&gt;this.setState()&lt;/code&gt; in this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24708bd58e5d92536bc16cf465af7ca7d3258012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; is invoked just before rendering when new props or state are being received. Use this as an opportunity to perform preparation before an update occurs. This method is not called for the initial render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9053039459a28cc028d2bd242aa4a8da6683d06b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; will not be invoked if &lt;a href=&quot;#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; returns false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db107fda1b4fb89320d3e59daead35226448eda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_.debounce&lt;/code&gt;, &lt;code&gt;_.throttle&lt;/code&gt; and &lt;code&gt;raf-schd&lt;/code&gt; provide a &lt;code&gt;cancel&lt;/code&gt; method to cancel delayed callbacks. You should either call this method from &lt;code&gt;componentWillUnmount&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; check to ensure that the component is still mounted within the delayed function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b02b4a29b18cb40844cb7baeef47a37a699a301" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collapsed&lt;/code&gt; shows only the next fallback in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa3bf49a9ddfa68a52bb154390b6f8a8c59db92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidCatch()&lt;/code&gt; is called during the &amp;ldquo;commit&amp;rdquo; phase, so side-effects are permitted. It should be used for things like logging errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5902bc84c401394fad8d18dcfdf9467b9ed46981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidCatch&lt;/code&gt; and &lt;code&gt;getDerivedStateFromError&lt;/code&gt;: There are no Hook equivalents for these methods yet, but they will be added soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9026acf47b96f019c2e814ca4ee8b05ee56c356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidMount()&lt;/code&gt; is invoked immediately after a component is mounted (inserted into the tree). Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8013ba07d24f78b57a23033656a37bdb683b608c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, &lt;code&gt;componentWillUnmount&lt;/code&gt;: The &lt;a href=&quot;hooks-reference#useeffect&quot;&gt;&lt;code&gt;useEffect&lt;/code&gt; Hook&lt;/a&gt; can express all combinations of these (including &lt;a href=&quot;#can-i-skip-an-effect-on-updates&quot;&gt;less&lt;/a&gt;&lt;a href=&quot;#can-i-run-an-effect-only-on-updates&quot;&gt;common&lt;/a&gt; cases).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e953f1e280950f4dff6ff23d43d803da07aae1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidUpdate()&lt;/code&gt; is invoked immediately after updating occurs. This method is not called for the initial render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1021b8fbfb1f2dfff035033fe2ef06292f3a9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentDidUpdate()&lt;/code&gt; will not be invoked if &lt;a href=&quot;#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; returns false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b6a217fa03e2afc4c419430cc58c93197eef2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillMount&lt;/code&gt; (or &lt;code&gt;UNSAFE_componentWillMount&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7468a85c1a852ccb4f5225df141dbe0cd5ab4dd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillReceiveProps&lt;/code&gt; (or &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c01ec29848b94c784bbae7ff49b6a351fedc4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillUnmount()&lt;/code&gt; is invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in &lt;code&gt;componentDidMount()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e47f2b0f2fa0b85ff172c0843f6c6150e121e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;componentWillUpdate&lt;/code&gt; (or &lt;code&gt;UNSAFE_componentWillUpdate&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aefd85a43dcaec0da5d78e959fcc0b9a9aa260a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constructor&lt;/code&gt;: Function components don&amp;rsquo;t need a constructor. You can initialize the state in the &lt;a href=&quot;hooks-reference#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; call. If computing the initial state is expensive, you can pass a function to &lt;code&gt;useState&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45deb296fef4519fcc0542b074d18d944e4180d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; is React&amp;rsquo;s replacement for using &lt;code&gt;innerHTML&lt;/code&gt; in the browser DOM. In general, setting HTML from code is risky because it&amp;rsquo;s easy to inadvertently expose your users to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;cross-site scripting (XSS)&lt;/a&gt; attack. So, you can set HTML directly from React, but you have to type out &lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; and pass an object with a &lt;code&gt;__html&lt;/code&gt; key, to remind yourself that it&amp;rsquo;s dangerous. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430c1db279092a6ceec141825e72881e9801f973" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultProps&lt;/code&gt; can be defined as a property on the component class itself, to set the default props for the class. This is used for undefined props, but not for null props. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baaec778616719a973e43c85a2f93b67ab0ec035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt; - The error that was thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a29285db43f7e7b976068b67906d8783d2803d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; are valid children. They simply don&amp;rsquo;t render. These JSX expressions will all render to the same thing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc0689b7d39b7f885a456fa37204e2e07d66eaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; can also be used on class components but this was breaking abstraction levels by allowing a parent to demand that certain children was rendered. It creates a refactoring hazard where you can&amp;rsquo;t change the implementation details of a component because a parent might be reaching into its DOM node. &lt;code&gt;findDOMNode&lt;/code&gt; only returns the first child, but with the use of Fragments, it is possible for a component to render multiple DOM nodes. &lt;code&gt;findDOMNode&lt;/code&gt; is a one time read API. It only gave you an answer when you asked for it. If a child component renders a different node, there is no way to handle this change. Therefore &lt;code&gt;findDOMNode&lt;/code&gt; only worked if components always return a single DOM node that never changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c18ed32176ecaf70319c68a1b1509b378bab1d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; cannot be used on function components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31959247d4b241bc62fdc356b0b41fcb230a4ce0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; is an escape hatch used to access the underlying DOM node. In most cases, use of this escape hatch is discouraged because it pierces the component abstraction. &lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt;It has been deprecated in &lt;code&gt;StrictMode&lt;/code&gt;.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad0438abf0344830b83e67adfda87c9220640615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findDOMNode&lt;/code&gt; only works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like calling &lt;code&gt;findDOMNode()&lt;/code&gt; in &lt;code&gt;render()&lt;/code&gt; on a component that has yet to be created) an exception will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510bd08ba17ba9f9ccbd8c7c0709f1c0cd79ad6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getDerivedStateFromError()&lt;/code&gt; is called during the &amp;ldquo;render&amp;rdquo; phase, so side-effects are not permitted. For those use cases, use &lt;code&gt;componentDidCatch()&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910e1f30e33802fcc6bf71e017f3abfa8bddc166" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getDerivedStateFromProps&lt;/code&gt; is invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or null to update nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a7ee6f8147159dabadfc4df519d03042e8b215" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getDerivedStateFromProps&lt;/code&gt;: Schedule an update &lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;while rendering&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fee8f10f7ad4d0d11f67d09d125311a4fc53fa2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; is invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle will be passed as a parameter to &lt;code&gt;componentDidUpdate()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb01ea8f67b656757e4c3ff85c79d0e4a1e35264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hidden&lt;/code&gt; doesn&amp;rsquo;t show any unloaded items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31610744ea2dac7d5f0f6319b25a18fe35b35153" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;for&lt;/code&gt; loops are not expressions in JavaScript, so they can&amp;rsquo;t be used in JSX directly. Instead, you can put these in the surrounding code. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce6bd3f9452511f9ae589ccbb20dfb78385fba7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;info&lt;/code&gt; - An object with a &lt;code&gt;componentStack&lt;/code&gt; key containing &lt;a href=&quot;error-boundaries#component-stack-traces&quot;&gt;information about which component threw the error&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1551fdcffd2297ae4cbb5750a781ab5971e41725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPending&lt;/code&gt; is a boolean. It&amp;rsquo;s React telling us whether that transition is ongoing at the moment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7456c23ecf41341dc15c4ef99e0dd0c03049a234" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPending&lt;/code&gt; is a boolean. It&amp;rsquo;s React&amp;rsquo;s way of informing us whether we&amp;rsquo;re waiting for the transition to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fede57a744a8aa811decdcac1eaedf9d4039297" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; is the only attribute that can be passed to &lt;code&gt;Fragment&lt;/code&gt;. In the future, we may add support for additional attributes, such as event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc74e733d90a9b1105f5a84d7df17789075e7de4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mockComponent()&lt;/code&gt; is a legacy API. We recommend using &lt;a href=&quot;https://facebook.github.io/jest/docs/en/tutorial-react-native.html#mock-native-modules-using-jestmock&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a00f6e0c85948cf8b75fbf2486fb9d35f5ecb1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;npx&lt;/code&gt; is not a typo &amp;mdash; it&amp;rsquo;s a &lt;a href=&quot;https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b&quot;&gt;package runner tool that comes with npm 5.2+&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb448c06ef207192f6960e58083b2f60ad706ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;npx&lt;/code&gt; on the first line is not a typo &amp;mdash; it&amp;rsquo;s a &lt;a href=&quot;https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b&quot;&gt;package runner tool that comes with npm 5.2+&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b629a67eb08da14b4cfec6bc10dfa3539aec592a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onRender&lt;/code&gt; Callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6833d94c5fdd052aae681c7af8babb363ae7dc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props.children&lt;/code&gt; is available on every component. It contains the content between the opening and closing tags of a component. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a6d4bfe3d0a553f9a325a8d8d7895eb240fba9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props&lt;/code&gt; are inputs to a React component. They are data passed down from a parent component to a child component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8276da0d1612607c2cc59c2ee7061fdd95306d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-dom&lt;/code&gt; 16.5+ and &lt;code&gt;react-native&lt;/code&gt; 0.57+ provide enhanced profiling capabilities in DEV mode with the React DevTools Profiler. An overview of the Profiler can be found in the blog post &lt;a href=&quot;https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html&quot;&gt;&amp;ldquo;Introducing the React Profiler&amp;rdquo;&lt;/a&gt;. A video walkthrough of the profiler is also &lt;a href=&quot;https://www.youtube.com/watch?v=nySib7ipZdk&quot;&gt;available on YouTube&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2a0dc772da5e7cdc0f38957f9993d3616b5a1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render()&lt;/code&gt; will not be invoked if &lt;a href=&quot;#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; returns false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4f56d7302d0967a7240bb18080cef54c794107" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt;: This is the function component body itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50d17a24cb4b08149dc01cd820c7781be44969a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requestAnimationFrame&lt;/code&gt; throttling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25ec040456e9920edfe2988e28f1b81d3beb06c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; does not always immediately update the component. It may batch or defer the update until later. This makes reading &lt;code&gt;this.state&lt;/code&gt; right after calling &lt;code&gt;setState()&lt;/code&gt; a potential pitfall. Instead, use &lt;code&gt;componentDidUpdate&lt;/code&gt; or a &lt;code&gt;setState&lt;/code&gt; callback (&lt;code&gt;setState(updater, callback)&lt;/code&gt;), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the &lt;code&gt;updater&lt;/code&gt; argument below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890278a6f325117472c160479b342fb7dd806205" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; enqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. This is the primary method you use to update the user interface in response to event handlers and server responses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f4ea7b18a07d4971cdabfc70d9ff5a0f5cfb0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; schedules an update to a component&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; object. When state changes, the component responds by re-rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78edf8a5be7cd4938da4a8930c26b921ca6ea710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState()&lt;/code&gt; will always lead to a re-render unless &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. If mutable objects are being used and conditional rendering logic cannot be implemented in &lt;code&gt;shouldComponentUpdate()&lt;/code&gt;, calling &lt;code&gt;setState()&lt;/code&gt; only when the new state differs from the previous state will avoid unnecessary re-renders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd73fd61fb3b7bdbb5b066ca0f0dac0e6ba13ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setState&lt;/code&gt; updater functions (the first argument)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68a2611b9905d44a6f35aa9f1a6cfae46d103e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shallowRenderer.render()&lt;/code&gt; is similar to &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; but it doesn&amp;rsquo;t require DOM and only renders a single level deep. This means you can test components isolated from how their children are implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d56fb96a210704f6b7e526afe89f7d4ad2516a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate()&lt;/code&gt; is invoked before rendering when new props or state are being received. Defaults to &lt;code&gt;true&lt;/code&gt;. This method is not called for the initial render or when &lt;code&gt;forceUpdate()&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814748f3c2c1758f2ff0aca465c42a2dc55dcfcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate&lt;/code&gt;: See &lt;code&gt;React.memo&lt;/code&gt;&lt;a href=&quot;#how-do-i-implement-shouldcomponentupdate&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66bddd2497b3b200c22e5281d6e552a7e20a6da9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startTransition&lt;/code&gt; is a function that takes a callback. We can use it to tell React which state we want to defer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34051d51bc03f3b73ca1f25cdb8ab0dda54436eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startTransition&lt;/code&gt; is a function. We&amp;rsquo;ll use it to tell React &lt;em&gt;which&lt;/em&gt; state update we want to defer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8ddfb17b43b6d22d0295ba402dabbf671d09bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; is a reference to the component state at the time the change is being applied. It should not be directly mutated. Instead, changes should be represented by building a new object based on the input from &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt;. For instance, suppose we wanted to increment a value in state by &lt;code&gt;props.step&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f536549f1bb22cb3c08a39e8b050827fd1a8b128" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props&lt;/code&gt; contains the props that were defined by the caller of this component. See &lt;a href=&quot;components-and-props&quot;&gt;Components and Props&lt;/a&gt; for an introduction to props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63898df1efb2729c524b163f95229e38f97f586" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;together&lt;/code&gt; reveals &lt;em&gt;all&lt;/em&gt; of them when they&amp;rsquo;re ready instead of one by one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1505b4fe4f872f374d4ceb82f8e0d44ecbce73a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; is great but it only works for imperative code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042cebd03ee57a7edf6c149d64815a55aa39ccbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updateColorMap&lt;/code&gt; now returns a new object, rather than mutating the old one. &lt;code&gt;Object.assign&lt;/code&gt; is in ES6 and requires a polyfill.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667e5f15380b289f60e9fc5beed758d4b2d95df0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useCallback(fn, deps)&lt;/code&gt; is equivalent to &lt;code&gt;useMemo(() =&amp;gt; fn, deps)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b729b36b0c56e0724013363ba045f69a97ca22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useContext(MyContext)&lt;/code&gt; only lets you &lt;em&gt;read&lt;/em&gt; the context and subscribe to its changes. You still need a &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; above in the tree to &lt;em&gt;provide&lt;/em&gt; the value for this context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0ce9627a3e8428d2ed75cf429dda0b5cf0efc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useDebugValue&lt;/code&gt; can be used to display a label for custom hooks in React DevTools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f01ff030e160362e003ee4592bd149e10adf2f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useDeferredValue&lt;/code&gt; accepts an &lt;strong&gt;optional Suspense Config&lt;/strong&gt; with a &lt;code&gt;timeoutMs&lt;/code&gt;. This timeout (in milliseconds) tells React how long the deferred value is allowed to lag behind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd43fc126f648e879919e1de0da7c29467f3009f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useImperativeHandle&lt;/code&gt; customizes the instance value that is exposed to parent components when using &lt;code&gt;ref&lt;/code&gt;. As always, imperative code using refs should be avoided in most cases. &lt;code&gt;useImperativeHandle&lt;/code&gt; should be used with &lt;code&gt;forwardRef&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75640695dabcf32a2fdcd720b4d4ec21abee912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useMemo&lt;/code&gt; lets you &lt;a href=&quot;#how-to-memoize-calculations&quot;&gt;memoize an expensive calculation&lt;/a&gt; if the dependencies are the same. However, it only serves as a hint, and doesn&amp;rsquo;t &lt;em&gt;guarantee&lt;/em&gt; the computation won&amp;rsquo;t re-run. But sometimes you need to be sure an object is only created once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21395d3ffac3dda05d22d2fc2a8cc5403f396bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useReducer&lt;/code&gt; is usually preferable to &lt;code&gt;useState&lt;/code&gt; when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. &lt;code&gt;useReducer&lt;/code&gt; also lets you optimize performance for components that trigger deep updates because &lt;a href=&quot;hooks-faq#how-to-avoid-passing-callbacks-down&quot;&gt;you can pass &lt;code&gt;dispatch&lt;/code&gt; down instead of callbacks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6f646cfddeee6391c8a8ad43840ba9e4d83e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useRef&lt;/code&gt; returns a mutable ref object whose &lt;code&gt;.current&lt;/code&gt; property is initialized to the passed argument (&lt;code&gt;initialValue&lt;/code&gt;). The returned object will persist for the full lifetime of the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05a76668c8cfeec08e22711a9f90eaf01569527" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useRef&lt;/code&gt;&lt;strong&gt;does not&lt;/strong&gt; accept a special function overload like &lt;code&gt;useState&lt;/code&gt;. Instead, you can write your own function that creates and sets it lazily:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d4904731beb3c9febbd66670ff49cd7239a70c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useTransition&lt;/code&gt; accepts an &lt;strong&gt;optional Suspense Config&lt;/strong&gt; with a &lt;code&gt;timeoutMs&lt;/code&gt;. This timeout (in milliseconds) tells React how long to wait before showing the next state (the new Profile Page in the above example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39bc8d81d24ae97c5c3b83282412fd1cb3865a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useTransition&lt;/code&gt; allows components to avoid undesirable loading states by waiting for content to load before &lt;strong&gt;transitioning to the next screen&lt;/strong&gt;. It also allows components to defer slower, data fetching updates until subsequent renders so that more crucial updates can be rendered immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33ad06c93f0f029735d7bb14e5c7b373077b091" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Hooks&lt;/em&gt; are a new addition in React 16.8. They let you use state and other React features without writing a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace15fac5994029e1bcc72e771948fe804db95ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Hooks&lt;/em&gt; are a new addition in React 16.8. They let you use state and other React features without writing a class. Hooks have a &lt;a href=&quot;hooks-intro&quot;&gt;dedicated docs section&lt;/a&gt; and a separate API reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b83b7254bd7bfd5409460ac4494fa9808b9ebd6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that this functionality is not a part of React, but provided by third-party libraries.&lt;/em&gt; React does not have an opinion about how styles are defined; if in doubt, a good starting point is to define your styles in a separate &lt;code&gt;*.css&lt;/code&gt; file as usual and refer to them using &lt;a href=&quot;dom-elements#classname&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828dff12c9f333e498d192f940f8b0eb28323123" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What?!&lt;/em&gt; If you break it apart, it&amp;rsquo;s easier to see what&amp;rsquo;s going on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ec2e59f42ad4113b0701443f929bb729a9f39b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;uarr;&amp;uarr;&amp;uarr; Each section ends with a yellow box like this.&lt;/strong&gt; They link to detailed explanations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6058bfb8c2501dc09f533cb2be1f11424e6fa6ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;100% backwards-compatible.&lt;/strong&gt; Hooks don&amp;rsquo;t contain any breaking changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d653e9534724609f30ed266eec251a4fe8bfbe5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#adoption-strategy&quot;&gt;Adoption Strategy&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1ea47830ec1b43539be85bbdbf82f2c6ee8e57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#from-classes-to-hooks&quot;&gt;From Classes to Hooks&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b436fdc2511c163c3273395084964e4d03501da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#performance-optimizations&quot;&gt;Performance Optimizations&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c21e7807e574623dbbadef2f70311d29959382f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#under-the-hood&quot;&gt;Under the Hood&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb654d35da7c6a936b5cf39e562ac926e13ca93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codepen.io/gaearon/pen/ozqNOV?editors=0010&quot;&gt;Try it on CodePen&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0595fbb3b923b63dd343c6c487f004d0dbfc3506" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/adoring-goodall-8wbn7&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329decde42bb77dc0aae1fcec57bb050fb807cc8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/black-wind-byilt&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b4eecff73da876324208868ee639fd6117e97d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1a26535dcdb04c4f5421047cbda7504a77fef6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/brave-villani-ypxvf&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8490c7804a31bef203e102c3ac25a6e48cba2d5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/condescending-shape-s6694&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a98911496de2c11fb59ee0de57606b03b010d0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/currying-violet-5jsiy&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d744e65c52fc16ba9669af6e8d07aa1b1756282" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/floral-thunder-iy826&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8b1763e5fa89194b3eb2dc4597ac0861cc4ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/focused-mountain-uhkzg&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c392c02183e5fbc5bbca731955b286f4e7976de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/fragrant-glade-8huj6&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4941c0c6861dbc52540681ff425e2e53c977742" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f563e8f5edba2a989496a45b5a274a82553a5905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/gallant-spence-l6wbk&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2bea63b2bb76db4afe3cf5d2217f8cc9e9c79a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/infallible-dewdney-9fkv9&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091eda1000749c6dfb3e82a144500745b0a90feb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d14d74d223723c252aefae84799136180eddbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637995a9c0c8459f49104bf507f43701e9464ef5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/lively-smoke-fdf93&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e719ca37c04b81dbb27b7f6d477c89d07a7b725" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/modest-ritchie-iufrh&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aeecf2df582bbc41f958e939795d22ce6f082bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5fe033d012b748ca1ec08d81aec177e6e64dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/nervous-glade-b5sel&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e6f9b60d7ed92e746159eda59cd8f053370e96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/pensive-shirley-wkp46&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c4c35182e0486398109c99693cb980f8a4320b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/proud-tree-exg5t&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd41d12444d64b9f2867f260beeb8ea9b17e58af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/sleepy-field-mohzb&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a97ab6d64c40ba1724f28cf13f4e9399eeb97f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/trusting-clarke-8twuq&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075c6dbd104d3818936cfa43cc825d4a5758c0c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/vigorous-keller-3ed2b&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232874044ef8bc2516d2563ef607a5f8d6242c42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/wandering-morning-ev6r0&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b349e00ae7d86801b5b37e836ec25981964a4ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://codesandbox.io/s/zen-keldysh-rifos&quot;&gt;Try it on CodeSandbox&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58219f56881b30fdf5d4564dbe6229eab4fbbb3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt;&lt;/strong&gt; is a JavaScript test runner that lets you access the DOM via &lt;a href=&quot;testing-environments#mocking-a-rendering-surface&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt;. While jsdom is only an approximation of how the browser works, it is often good enough for testing React components. Jest provides a great iteration speed combined with powerful features like mocking &lt;a href=&quot;testing-environments#mocking-modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;testing-environments#mocking-timers&quot;&gt;timers&lt;/a&gt; so you can have more control over how the code executes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a5e69cee64ce8afda69e9a00e86814ef1d876b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605&quot;&gt;View the full example source code&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a908caf9cc6624102d1a77f24ae42e9bc9b21828" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;Download the full example (2KB zipped)&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993a7c72473bd27f839485ede4b2ce6e44dcbdfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;&lt;/strong&gt; - DefinitelyTyped is a huge repository of declarations for libraries that don&amp;rsquo;t bundle a declaration file. The declarations are crowd-sourced and managed by Microsoft and open source contributors. React for example doesn&amp;rsquo;t bundle its own declaration file. Instead we can get it from DefinitelyTyped. To do so enter this command in your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3fd7d9bed7d33685c6833c223188f4224ff4def" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/jaredpalmer/razzle&quot;&gt;Razzle&lt;/a&gt;&lt;/strong&gt; is a server-rendering framework that doesn&amp;rsquo;t require any configuration, but offers more flexibility than Next.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56e9cf8532603158b73eeb2fc003ab13c7e9437" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://neutrinojs.org/&quot;&gt;Neutrino&lt;/a&gt;&lt;/strong&gt; combines the power of &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; with the simplicity of presets, and includes a preset for &lt;a href=&quot;https://neutrinojs.org/packages/react/&quot;&gt;React apps&lt;/a&gt; and &lt;a href=&quot;https://neutrinojs.org/packages/react-components/&quot;&gt;React components&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c35e787c3cbc73032d50cb4528984ae519f235" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://parceljs.org/&quot;&gt;Parcel&lt;/a&gt;&lt;/strong&gt; is a fast, zero configuration web application bundler that &lt;a href=&quot;https://parceljs.org/recipes.html#react&quot;&gt;works with React&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60d72c48cae6c4966b5f08f6b2a563b5217b568" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt;&lt;/strong&gt; is a set of helpers that let you test React components without relying on their implementation details. This approach makes refactoring a breeze and also nudges you towards best practices for accessibility. Although it doesn&amp;rsquo;t provide a way to &amp;ldquo;shallowly&amp;rdquo; render a component without its children, a test runner like Jest lets you do this by &lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt;mocking&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2eefe2167a5535f7edb84693440268a866537b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;FilterableProductTable&lt;/code&gt; (orange):&lt;/strong&gt; contains the entirety of the example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6740581ede97860916dd8404f3c10005704058d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ProductCategoryRow&lt;/code&gt; (turquoise):&lt;/strong&gt; displays a heading for each &lt;em&gt;category&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e457034b9e3d496464cda366c118141b017a04" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ProductRow&lt;/code&gt; (red):&lt;/strong&gt; displays a row for each &lt;em&gt;product&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b4f2e8e25a7232d34a52a0e7e3bc9a214dad62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ProductTable&lt;/code&gt; (green):&lt;/strong&gt; displays and filters the &lt;em&gt;data collection&lt;/em&gt; based on &lt;em&gt;user input&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2dabde044e0d7f4af6b8b8921b77160774ee57c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;SearchBar&lt;/code&gt; (blue):&lt;/strong&gt; receives all &lt;em&gt;user input&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d83cdff912b9e15f8b1e0d697a44e96c59fb175" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;actualDuration: number&lt;/code&gt;&lt;/strong&gt; - Time spent rendering the &lt;code&gt;Profiler&lt;/code&gt; and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. &lt;a href=&quot;react-api#reactmemo&quot;&gt;&lt;code&gt;React.memo&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hooks-reference#usememo&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hooks-faq#how-do-i-implement-shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate&lt;/code&gt;&lt;/a&gt;). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c220a4c8bfdd12160e6afea8488b326d96cde385" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;baseDuration: number&lt;/code&gt;&lt;/strong&gt; - Duration of the most recent &lt;code&gt;render&lt;/code&gt; time for each individual component within the &lt;code&gt;Profiler&lt;/code&gt; tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97cccde8bcd492d0664a6e9b93ed149497f0ad18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;commitTime: number&lt;/code&gt;&lt;/strong&gt; - Timestamp when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f19be3985cb5babcd265822a9667d2170dee26" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;componentDidMount()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;componentDidMount()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a508f9a3232de158e10b1e3c1772259a5ac1977" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8bbd97e3f4e32bd784498eb21c219e93b36c747" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;componentWillUnmount()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;componentWillUnmount()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aacf0222e59d57af4a111eb929c26406c66048aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;constructor()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;constructor()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c2e3b29217438c02bda61a9de8a154d47db8351" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;id: string&lt;/code&gt;&lt;/strong&gt; - The &lt;code&gt;id&lt;/code&gt; prop of the &lt;code&gt;Profiler&lt;/code&gt; tree that has just committed. This can be used to identify which part of the tree was committed if you are using multiple profilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ce4c1d4832bb0e43d034cbaa0662eefda596ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;interactions: Set&lt;/code&gt;&lt;/strong&gt; - Set of &lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;&amp;ldquo;interactions&amp;rdquo;&lt;/a&gt; that were being traced the update was scheduled (e.g. when &lt;code&gt;render&lt;/code&gt; or &lt;code&gt;setState&lt;/code&gt; were called).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045d410e2d948cdb96f4239b6311b1d732f52f31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;phase: &quot;mount&quot; | &quot;update&quot;&lt;/code&gt;&lt;/strong&gt; - Identifies whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571cedd0a0dc5c8805c27c4c6caaf4bb4c1e12d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b0fd3e9bec3e312d2cb1960e60192785f42cc2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt; throttling&lt;/strong&gt;: sample changes based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/a&gt; (eg &lt;a href=&quot;https://github.com/alexreardon/raf-schd&quot;&gt;&lt;code&gt;raf-schd&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76173ffd5f59ad48d911dbf15184f902718fa903" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;startTime: number&lt;/code&gt;&lt;/strong&gt; - Timestamp when React began rendering the current update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8734e53ac0cf459890de4ee35290687bc530b58d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A custom Hook is a JavaScript function whose name starts with &amp;rdquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo; and that may call other Hooks.&lt;/strong&gt; For example, &lt;code&gt;useFriendStatus&lt;/code&gt; below is our first custom Hook:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4cdb60967a51938f2f25c9f126e16acf3aad29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;APIs starting with &lt;code&gt;unstable_&lt;/code&gt;.&lt;/strong&gt; These are provided as experimental features whose APIs we are not yet confident in. By releasing these with an &lt;code&gt;unstable_&lt;/code&gt; prefix, we can iterate faster and get to a stable API sooner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27b0bcf635fa2c2f9c4e5f35ea52c9731dba3fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;After:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c78cb87233869c91e558e7c266ddcae814f875e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All React components must act like pure functions with respect to their props.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7b86d446e9bf407e47a462807b03c155a6c2f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Alpha and canary versions of React.&lt;/strong&gt; We provide alpha versions of React as a way to test new features early, but we need the flexibility to make changes based on what we learn in the alpha period. If you use these versions, note that APIs may change before the stable release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0528360d2c4b02352330a33a1653ceb3d395264" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;App:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;App:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c144641667df7bb33364c9017474aea77fbba896" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays and fragments.&lt;/strong&gt; Let you return multiple elements from render. See the documentation on &lt;a href=&quot;fragments&quot;&gt;fragments&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa6bc0a302e6610000befe2d96dad38929fde7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As more data streams in, React will retry rendering, and each time it might be able to progress &amp;ldquo;deeper&amp;rdquo;.&lt;/strong&gt; When &lt;code&gt;resource.user&lt;/code&gt; is fetched, the &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; component will render successfully and we&amp;rsquo;ll no longer need the &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt; fallback. Eventually, we&amp;rsquo;ll get all the data, and there will be no fallbacks on the screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9954cf985840ab38b252982d386ed46ce940abce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available now.&lt;/strong&gt; Hooks are now available with the release of v16.8.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2595afb4d0118de17abae3f582f8bf9e4a43ca84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid copying props into state! This is a common mistake:&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d96324ef9248f7dc600e7558815b0ce0707fd64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Before:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="118cd2ca1ad0a4ea488c9cd88cacff2eedc873fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Blocking Mode:&lt;/strong&gt;&lt;code&gt;ReactDOM.createBlockingRoot(rootNode).render(&amp;lt;App /&amp;gt;)&lt;/code&gt;. It is currently experimental. It is intended as a first migration step for apps that want to get a subset of Concurrent Mode features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418a9a858502073bdd408d533c2dcd9fc1ea650e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Booleans or &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt;. Render nothing. (Mostly exists to support &lt;code&gt;return test &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; pattern, where &lt;code&gt;test&lt;/code&gt; is boolean.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14feed13e2d6b88199143da24c9f63c351a347e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bundle:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Bundle:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c39f68088cc6ea0f96f4c6bf7b6102044e4e4fd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bundled&lt;/strong&gt; - The library bundles its own declaration file. This is great for us, since all we need to do is install the library, and we can use it right away. To check if a library has bundled types, look for an &lt;code&gt;index.d.ts&lt;/code&gt; file in the project. Some libraries will have it specified in their &lt;code&gt;package.json&lt;/code&gt; under the &lt;code&gt;typings&lt;/code&gt; or &lt;code&gt;types&lt;/code&gt; field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d0f72b90ece3ead56ba6ecac303bbd8a5ee230" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But how can two versions of the same component exist at the same time?&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abcc8763b490e6bfaa3caa0e4aaf22dee67e939a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But what happens if the &lt;code&gt;friend&lt;/code&gt; prop changes&lt;/strong&gt; while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0c08721b7a9c57e2fe6c6f0fa5e81549efe634" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;By itself, this code doesn&amp;rsquo;t do anything yet.&lt;/strong&gt; We will need to use this Hook&amp;rsquo;s return values to set up our state transition. There are two values returned from &lt;code&gt;useTransition&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9caf5fa30d746db8e19d1be289bffadc70552f0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Changing the value of an input field and then pressing ENTER.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f922480363722c3d315fe73dc6146bcb65ff0f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Clicking an element&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="664d55b0b70eda79fe17e0e576dbb285c10897d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complete:&lt;/strong&gt; You will see the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component with no fallbacks inside. Everything was fetched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431d7e11a94ec8347fc0d53336c7d13234d7a0f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Completely opt-in.&lt;/strong&gt; You can try Hooks in a few components without rewriting any existing code. But you don&amp;rsquo;t have to learn or use Hooks right now if you don&amp;rsquo;t want to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b61b75094f835769117a08ebb5de039406be1ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Concurrent Mode fixes this fundamental limitation by making rendering interruptible.&lt;/strong&gt; This means when the user presses another key, React doesn&amp;rsquo;t need to block the browser from updating the text input. Instead, it can let the browser paint an update to the input, and then continue rendering the updated list &lt;em&gt;in memory&lt;/em&gt;. When the rendering is finished, React updates the DOM, and changes are reflected on the screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7530a2da53c5c616bbb7d31b3305f43795be943" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Concurrent Mode:&lt;/strong&gt;&lt;code&gt;ReactDOM.createRoot(rootNode).render(&amp;lt;App /&amp;gt;)&lt;/code&gt;. It is currently experimental. In the future, after it stabilizes, we intend to make it the default React mode. This mode enables &lt;em&gt;all&lt;/em&gt; the new features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9aec2ee7c42a70823e6f966d4b552beac2d79ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Correct:&lt;/strong&gt;&lt;code&gt;useContext(MyContext)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Correct:&lt;/strong&gt;&lt;code&gt;useContext(MyContext)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0629c87821b72707236c22ec926f99e314eaad6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Crucially, Hooks work side-by-side with existing code so you can adopt them gradually.&lt;/strong&gt; There is no rush to migrate to Hooks. We recommend avoiding any &amp;ldquo;big rewrites&amp;rdquo;, especially for existing, complex class components. It takes a bit of a mindshift to start &amp;ldquo;thinking in Hooks&amp;rdquo;. In our experience, it&amp;rsquo;s best to practice using Hooks in new and non-critical components first, and ensure that everybody on your team feels comfortable with them. After you give Hooks a try, please feel free to &lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;send us feedback&lt;/a&gt;, positive or negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca1a3dfa4c9d12963ce5931770052fd5b8dae25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Development warnings.&lt;/strong&gt; Since these don&amp;rsquo;t affect production behavior, we may add new warnings or modify existing warnings in between major versions. In fact, this is what allows us to reliably warn about upcoming breaking changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be365c38740fc02085ea0c7b28b61ebbe29465cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do I have to name my custom Hooks starting with &amp;ldquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo;?&lt;/strong&gt; Please do. This convention is very important. Without it, we wouldn&amp;rsquo;t be able to automatically check for violations of &lt;a href=&quot;hooks-rules&quot;&gt;rules of Hooks&lt;/a&gt; because we couldn&amp;rsquo;t tell if a certain function contains calls to Hooks inside of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="840f3f4e52f32ec07ea665effb626bd2bae907bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not use prereleases in user-facing applications.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02042712a60d18416fd5dbb8583b8cccba7ac107" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do two components using the same Hook share state?&lt;/strong&gt; No. Custom Hooks are a mechanism to reuse &lt;em&gt;stateful logic&lt;/em&gt; (such as setting up a subscription and remembering the current value), but every time you use a custom Hook, all state and effects inside of it are fully isolated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbcd181433e3ca93055c4d885d5d7e398339a98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Does &lt;code&gt;useEffect&lt;/code&gt; run after every render?&lt;/strong&gt; Yes! By default, it runs both after the first render &lt;em&gt;and&lt;/em&gt; after every update. (We will later talk about &lt;a href=&quot;#tip-optimizing-performance-by-skipping-effects&quot;&gt;how to customize this&lt;/a&gt;.) Instead of thinking in terms of &amp;ldquo;mounting&amp;rdquo; and &amp;ldquo;updating&amp;rdquo;, you might find it easier to think that effects happen &amp;ldquo;after render&amp;rdquo;. React guarantees the DOM has been updated by the time it runs the effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea922f8145451905b9a5d999e9a337afcfb4d6cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don&amp;rsquo;t call Hooks from regular JavaScript functions.&lt;/strong&gt; Instead, you can:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadbf266b12dada567bc226186d3f5cc315d669c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don&amp;rsquo;t call Hooks inside loops, conditions, or nested functions.&lt;/strong&gt; Instead, always use Hooks at the top level of your React function. By following this rule, you ensure that Hooks are called in the same order each time a component renders. That&amp;rsquo;s what allows React to correctly preserve the state of Hooks between multiple &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt; calls. (If you&amp;rsquo;re curious, we&amp;rsquo;ll explain this in depth &lt;a href=&quot;#explanation&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd9092daac9a6a45cd5c86bb1fb41b93498ec98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example: Correct Key Usage&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8021b79242adc1726ab15211d7b813debb54040" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example: Incorrect Key Usage&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5652355f3887cb50adc3da97751628a89b3ee64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Experimental releases will have frequent breaking changes.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cebb6589caedc0e9cc806fb2dc5c7c45386f412" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetch-on-render (for example, &lt;code&gt;fetch&lt;/code&gt; in &lt;code&gt;useEffect&lt;/code&gt;):&lt;/strong&gt; Start rendering components. Each of these components may trigger data fetching in their effects and lifecycle methods. This approach often leads to &amp;ldquo;waterfalls&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74dec7e02dc04a3faaa06cd94aa96d34daafe356" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetch-then-render (for example, Relay without Suspense):&lt;/strong&gt; Start fetching all the data for the next screen as early as possible. When the data is ready, render the new screen. We can&amp;rsquo;t do anything until the data arrives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585dde52ce326d7e2bc859a3fa881f00e44a228e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Finish fetching&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6940807aaa96966443fccbfb4d6ae087c006f191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For an in-depth look at deferring values, you can read &lt;a href=&quot;concurrent-mode-patterns#deferring-a-value&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e9e1fc0a7430e63de513e52d657e3039c0f737" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For an in-depth look at transitions, you can read &lt;a href=&quot;concurrent-mode-patterns#transitions&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2571822852d3a9ebbbaa834420b3872f3e2ce9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hooks don&amp;rsquo;t replace your knowledge of React concepts.&lt;/strong&gt; Instead, Hooks provide a more direct API to the React concepts you already know: props, state, context, refs, and lifecycle. As we will show later, Hooks also offer a new powerful way to combine them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d1277bf6af10d314a996d3f9d38556128194b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hooks let us split the code based on what it is doing&lt;/strong&gt; rather than a lifecycle method name. React will apply &lt;em&gt;every&lt;/em&gt; effect used by the component, in the order they were specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549222869a6579d68c4394b9ddc13d3055187ac5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a custom Hook get isolated state?&lt;/strong&gt; Each &lt;em&gt;call&lt;/em&gt; to a Hook gets isolated state. Because we call &lt;code&gt;useFriendStatus&lt;/code&gt; directly, from React&amp;rsquo;s point of view our component just calls &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt;. And as we &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;learned&lt;/a&gt;&lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;earlier&lt;/a&gt;, we can call &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt; many times in one component, and they will be completely independent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97feece5ad10ef5e36e71d8a8b7a15c910ed1d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How much to mock:&lt;/strong&gt; With components, the distinction between a &amp;ldquo;unit&amp;rdquo; and &amp;ldquo;integration&amp;rdquo; test can be blurry. If you&amp;rsquo;re testing a form, should its test also test the buttons inside of it? Or should a button component have its own test suite? Should refactoring a button ever break the form test?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8752a3833c91c9228ddd47ee17949d93770114" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Idiomatic code using Hooks doesn&amp;rsquo;t need the deep component tree nesting&lt;/strong&gt; that is prevalent in codebases that use higher-order components, render props, and context. With smaller component trees, React has less work to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe82d913b37ed43a6c3776e244ba7ee19a96d552" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If for some reason you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; move a function inside an effect, there are a few more options:&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91ee3f1da4fcb123fe1add1e900abb64b204513" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If some feature isn&amp;rsquo;t a vital part of the next screen, wrap it in &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; and let it load lazily.&lt;/strong&gt; This ensures we can show the rest of the content as soon as possible. Conversely, if a screen is &lt;em&gt;not worth showing&lt;/em&gt; without some component, such as &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; in our example, do &lt;em&gt;not&lt;/em&gt; wrap it in &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;. Then the transitions will &amp;ldquo;wait&amp;rdquo; for it to be ready.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d17462d8c3ce399e59474b343b454f198283b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If some state update causes a component to suspend, that state update should be wrapped in a transition.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743d61fffa9c9762bcfdbc0ba719dc7d754a16c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you don&amp;rsquo;t initialize state and you don&amp;rsquo;t bind methods, you don&amp;rsquo;t need to implement a constructor for your React component.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010e5a638b8e2853191ee4c9f9a95021e00f0621" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you feel like you have a decent grasp on how the Effect Hook works, or if you feel overwhelmed, you can jump to the &lt;a href=&quot;hooks-rules&quot;&gt;next page about Rules of Hooks&lt;/a&gt; now.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199cd21f9753c5e277848634a7461c4cdf76fb99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you just want to start learning Hooks, feel free to &lt;a href=&quot;hooks-overview&quot;&gt;jump directly to the next page!&lt;/a&gt;&lt;/strong&gt; You can also keep reading this page to learn more about why we&amp;rsquo;re adding Hooks, and how we&amp;rsquo;re going to start using them without rewriting our applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b3458601d6435e4a97c86c14b547e64c6f09e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you only want to avoid passing some props through many levels, &lt;a href=&quot;composition-vs-inheritance&quot;&gt;component composition&lt;/a&gt; is often a simpler solution than context.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0339780254d445749b17fc47c897244b665cc6ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you&amp;rsquo;re not sure which channel you should use, it&amp;rsquo;s Latest.&lt;/strong&gt; If you&amp;rsquo;re a React developer, this is what you&amp;rsquo;re already using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19499e8a5ad3525f0986cfd12f3f1c87b2c9ac0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Importing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Importing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4519202455f803715d2c9c3afdc889b2e6855dac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Consumer)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Consumer)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06e6e8a38c6b7b9f76acbde123862702d9f0c4a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Provider)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Incorrect:&lt;/strong&gt;&lt;code&gt;useContext(MyContext.Provider)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ca533f91c4be178a816d4659286281e4dfaef37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Is this code equivalent to the original examples?&lt;/strong&gt; Yes, it works in exactly the same way. If you look closely, you&amp;rsquo;ll notice we didn&amp;rsquo;t make any changes to the behavior. All we did was to extract some common code between two functions into a separate function. &lt;strong&gt;Custom Hooks are a convention that naturally follows from the design of Hooks, rather than a React feature.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c4fce55098e2a2ebd95626d9fa1bb7e1c2898e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It does not couple data fetching to the view layer.&lt;/strong&gt; It helps orchestrate displaying the loading states in your UI, but it doesn&amp;rsquo;t tie your network logic to React components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0fe04b299a5f88513f5a561bfab0e4736efecd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It helps you avoid race conditions.&lt;/strong&gt; Even with &lt;code&gt;await&lt;/code&gt;, asynchronous code is often error-prone. Suspense feels more like reading data &lt;em&gt;synchronously&lt;/em&gt; &amp;mdash; as if it was already loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d518f34e17861e9ce1674fe13c1ad692812b5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It is not a data fetching implementation.&lt;/strong&gt; It does not assume that you use GraphQL, REST, or any other particular data format, library, transport, or protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81110995ca89b565002106a4272820cb696b44a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It is not a ready-to-use client.&lt;/strong&gt; You can&amp;rsquo;t &amp;ldquo;replace&amp;rdquo; &lt;code&gt;fetch&lt;/code&gt; or Relay with Suspense. But you can use a library that&amp;rsquo;s integrated with Suspense (for example, &lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference&quot;&gt;new Relay APIs&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b19fe11cf700d76b6edd744f65d9b1eaa1700eab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It lets data fetching libraries deeply integrate with React.&lt;/strong&gt; If a data fetching library implements Suspense support, using it from React components feels very natural.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90b929484e402b7aff9864ea9f233f51dddd6c80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It lets you orchestrate intentionally designed loading states.&lt;/strong&gt; It doesn&amp;rsquo;t say &lt;em&gt;how&lt;/em&gt; the data is fetched, but it lets you closely control the visual loading sequence of your app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f3fa111b3d223edc7fd94673d0beee8feb9c94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iteration speed vs Realistic environment:&lt;/strong&gt; Some tools offer a very quick feedback loop between making a change and seeing the result, but don&amp;rsquo;t model the browser behavior precisely. Other tools might use a real browser environment, but reduce the iteration speed and are flakier on a continuous integration server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a65bff48ac7042efb756481adec3a54e902c07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Legacy Mode:&lt;/strong&gt;&lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt;. This is what React apps use today. There are no plans to remove the legacy mode in the observable future &amp;mdash; but it won&amp;rsquo;t be able to support these new features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0dd6bf0667b49653f91c6663edcfebbb17079dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Line 1:&lt;/strong&gt; We import the &lt;code&gt;useState&lt;/code&gt; Hook from React. It lets us keep local state in a function component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7270df719cea370558248bcad77f01151d78491a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Line 4:&lt;/strong&gt; Inside the &lt;code&gt;Example&lt;/code&gt; component, we declare a new state variable by calling the &lt;code&gt;useState&lt;/code&gt; Hook. It returns a pair of values, to which we give names. We&amp;rsquo;re calling our variable &lt;code&gt;count&lt;/code&gt; because it holds the number of button clicks. We initialize it to zero by passing &lt;code&gt;0&lt;/code&gt; as the only &lt;code&gt;useState&lt;/code&gt; argument. The second returned item is itself a function. It lets us update the &lt;code&gt;count&lt;/code&gt; so we&amp;rsquo;ll name it &lt;code&gt;setCount&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a7a3cc60d64235f4e5261dec996d75336798f05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Line 9:&lt;/strong&gt; When the user clicks, we call &lt;code&gt;setCount&lt;/code&gt; with a new value. React will then re-render the &lt;code&gt;Example&lt;/code&gt; component, passing the new &lt;code&gt;count&lt;/code&gt; value to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b8b1b4f4a5584b72a18b8e95852b80cc54dae7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Local Declarations&lt;/strong&gt; Sometimes the package that you want to use doesn&amp;rsquo;t bundle declarations nor is it available on DefinitelyTyped. In that case, we can have a local declaration file. To do this, create a &lt;code&gt;declarations.d.ts&lt;/code&gt; file in the root of your source directory. A simple declaration could look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f793f7bc3a3b26158670d850e29dc82da802b138" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that you don&amp;rsquo;t need to worry about this problem if you use the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;provided lint rule&lt;/a&gt;.&lt;/strong&gt; But now you also know &lt;em&gt;why&lt;/em&gt; Hooks work this way, and which issues the rule is preventing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8b0d2688bd8d9824e88dddab53f35391775595" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This is a Community Preview and not the final stable version. There will likely be future changes to these APIs. Use at your own risk!&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593aeb4f3f89c3bf5c24e17ee45fd1910b17c41a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: We recommend that you share Suspense Config between different modules.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65dcf051b0f8d4d6b70a92dd10d98dbbb05e7cdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7040828fb921d37b8a31bfaf2e1a2f9a6c1276dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Always start component names with a capital letter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cd00a05c4e51c80b150666326157914820525e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d42e7216099fe728d8bbe239adf85181892c6883" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now let&amp;rsquo;s continue by &lt;a href=&quot;hooks-effect&quot;&gt;learning the next Hook: &lt;code&gt;useEffect&lt;/code&gt;.&lt;/a&gt;&lt;/strong&gt; It lets you perform side effects in components, and is similar to lifecycle methods in classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd938635ddd8b87a65f9ab1b71b41e5ec17b909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only use this pattern if you intentionally want to ignore prop updates.&lt;/strong&gt; In that case, it makes sense to rename the prop to be called &lt;code&gt;initialColor&lt;/code&gt; or &lt;code&gt;defaultColor&lt;/code&gt;. You can then force a component to &amp;ldquo;reset&amp;rdquo; its internal state by &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;changing its &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; when necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d5100e65eb19f31c6edf66c706e6d482f60c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Portals&lt;/strong&gt;. Let you render children into a different DOM subtree. See the documentation on &lt;a href=&quot;portals&quot;&gt;portals&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c15d6ed99d7816203985bf165b9f9821f25c61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preferred: &lt;a href=&quot;https://codesandbox.io/s/focused-snow-xbkvl&quot;&gt;Pending &amp;rarr; Skeleton &amp;rarr; Complete&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9839ea062ed4fa5a43488dd71d11ee1954444366" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Putting it together with Context.Provider&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3138e5aa6164999b8c6225f3fdf7820352fe882" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React elements.&lt;/strong&gt; Typically created via &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt;. For example, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;MyComponent /&amp;gt;&lt;/code&gt; are React elements that instruct React to render a DOM node, or another user-defined component, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2006364502f1d68dcba23768a1e62a0554187259" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React&lt;/strong&gt; is a JavaScript library for building user interfaces. Learn what React is all about on &lt;a href=&quot;https://reactjs.org/&quot;&gt;our homepage&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;in the tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c899298f272c1fdfbeb117f62d7e014d25aa5a16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Receded&lt;/strong&gt;: For a second, you will see the &lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt; fallback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd10ab8f0a3c7b84b26dd6034b22ed4a81bbc1c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ref forwarding is an opt-in feature that lets some components take a &lt;code&gt;ref&lt;/code&gt; they receive, and pass it further down (in other words, &amp;ldquo;forward&amp;rdquo; it) to a child.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c51dd38b8fbdcddbfb44c5d79e9cc74de7e4e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Render-as-you-fetch (for example, Relay with Suspense):&lt;/strong&gt; Start fetching all the required data for the next screen as early as possible, and start rendering the new screen &lt;em&gt;immediately &amp;mdash; before we get a network response&lt;/em&gt;. As data streams in, React retries rendering components that still need data until they&amp;rsquo;re all ready.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59875a596212e2630b1312f26132c57404e3b897" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rendering component trees&lt;/strong&gt; in a simplified test environment and asserting on their output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8e6a01172699bc5f0e6bf87921f99d01a5d5b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Running a complete app&lt;/strong&gt; in a realistic browser environment (also known as &amp;ldquo;end-to-end&amp;rdquo; tests).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1d7f873fc7d86183877a294288c695908975d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Skeleton:&lt;/strong&gt; You will see the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component with &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; inside.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf6928b68eec4860f3c701c962c2c5c91504b48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Start rendering&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0371cc9bcdb0694f3886267bfe248a16d117874e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1:&lt;/strong&gt; Run &lt;code&gt;npm init -y&lt;/code&gt; (if it fails, &lt;a href=&quot;https://gist.github.com/gaearon/246f6380610e262f8a648e3e51cad40d&quot;&gt;here&amp;rsquo;s a fix&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f716f702f35af4f753d17675302facfc3c2cc56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2:&lt;/strong&gt; Run &lt;code&gt;npm install babel-cli@6 babel-preset-react-app@3&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5517d6c3afae89c3d0e1c021b59dbb96b412cbe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String and numbers.&lt;/strong&gt; These are rendered as text nodes in the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81c33b7be05b010f25ae0f331129783763b119d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR: There are no plans to remove classes from React.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e63816b1ae56ff8db5359421b2c8504cffc8456" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The code demos on this page use a &amp;ldquo;fake&amp;rdquo; API implementation rather than Relay.&lt;/strong&gt; This makes them easier to understand if you&amp;rsquo;re not familiar with GraphQL, but they won&amp;rsquo;t tell you the &amp;ldquo;right way&amp;rdquo; to build an app with Suspense. This page is more conceptual and is intended to help you see &lt;em&gt;why&lt;/em&gt; Suspense works in a certain way, and which problems it solves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b1010c4b7176541b267d2c7954f323616622e2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The first common use case is when creating the initial state is expensive:&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e675dad06f70c50575272302659644553554d66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The only officially supported release channel for user-facing applications is Latest&lt;/strong&gt;. Next and Experimental releases are provided for testing purposes only, and we provide no guarantees that behavior won&amp;rsquo;t change between releases. They do not follow the semver protocol that we use for releases from Latest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833be86e96773e99b79bcbd6beed6db864061c08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The recommended fix is to move that function &lt;em&gt;inside&lt;/em&gt; of your effect&lt;/strong&gt;. That makes it easy to see which props or state your effect uses, and to ensure they&amp;rsquo;re all declared:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ec0e2e1f610466ed7ccdbe7507befa86725218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are no plans to remove classes from React.&lt;/strong&gt; You can read more about the gradual adoption strategy for Hooks in the &lt;a href=&quot;#gradual-adoption-strategy&quot;&gt;bottom section&lt;/a&gt; of this page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d948783029575274087a10b2b166d5f5e2e50fbf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are no semantic versioning guarantees for the experimental builds.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c80b00bd6df490cfa29bc2d05f84fb6423f5bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is why Hooks must be called on the top level of our components.&lt;/strong&gt; If we want to run an effect conditionally, we can put that condition &lt;em&gt;inside&lt;/em&gt; our Hook:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457992c4bac0fe2813cedca6bef0b7429569609e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This will enable Concurrent Mode for the whole &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; tree:&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f76348ba946b3228eb0c7261268bf29f416bb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tip:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tip:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf7022720600576290837b09f637a4cbc813dc32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To explain Concurrent Mode, we&amp;rsquo;ll use version control as a metaphor.&lt;/strong&gt; If you work on a team, you probably use a version control system like Git and work on branches. When a branch is ready, you can merge your work into master so that other people can pull it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab520ae66b9b186e3a45be812567a1f64882757" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Try it on CodePen&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbb893f7bb44a32f19ac7257b622e9045611025" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Undocumented APIs and internal data structures.&lt;/strong&gt; If you access internal property names like &lt;code&gt;__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED&lt;/code&gt; or &lt;code&gt;__reactInternalInstance$uk43rzhitjg&lt;/code&gt;, there is no warranty. You are on your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251436bcf1a85c83d8711b39296fe259fc9d0256" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3315a151135342e4109a199297933204d1615fae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We also found numerous issues in codebases using mixins, &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;and don&amp;rsquo;t recommend using them in the new code&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe850f519c6af191610d343cf20a694dc8e3c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We strongly recommend against creating your own base component classes.&lt;/strong&gt; In React components, &lt;a href=&quot;composition-vs-inheritance&quot;&gt;code reuse is primarily achieved through composition rather than inheritance&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb8066b79ef2fb681d3c517cb7fabd60caf3330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What do we pass to &lt;code&gt;useState&lt;/code&gt; as an argument?&lt;/strong&gt; The only argument to the &lt;code&gt;useState()&lt;/code&gt; Hook is the initial state. Unlike with classes, the state doesn&amp;rsquo;t have to be an object. We can keep a number or a string if that&amp;rsquo;s all we need. In our example, we just want a number for how many times the user clicked, so pass &lt;code&gt;0&lt;/code&gt; as initial state for our variable. (If we wanted to store two different values in state, we would call &lt;code&gt;useState()&lt;/code&gt; twice.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08cc1b1443b10924f9c311035a0c2b2fbd0c6aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does &lt;code&gt;useEffect&lt;/code&gt; do?&lt;/strong&gt; By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we&amp;rsquo;ll refer to it as our &amp;ldquo;effect&amp;rdquo;), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cf393c888af0299ee4ba4fa1c61899ebde2820" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does &lt;code&gt;useState&lt;/code&gt; return?&lt;/strong&gt; It returns a pair of values: the current state and a function that updates it. This is why we write &lt;code&gt;const [count, setCount] = useState()&lt;/code&gt;. This is similar to &lt;code&gt;this.state.count&lt;/code&gt; and &lt;code&gt;this.setState&lt;/code&gt; in a class, except you get them in a pair. If you&amp;rsquo;re not familiar with the syntax we used, we&amp;rsquo;ll come back to it &lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;at the bottom of this page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354dbe01dc555e8df6bfd26b70a9485c432f5145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does calling &lt;code&gt;useState&lt;/code&gt; do?&lt;/strong&gt; It declares a &amp;ldquo;state variable&amp;rdquo;. Our variable is called &lt;code&gt;count&lt;/code&gt; but we could call it anything else, like &lt;code&gt;banana&lt;/code&gt;. This is a way to &amp;ldquo;preserve&amp;rdquo; some values between the function calls &amp;mdash; &lt;code&gt;useState&lt;/code&gt; is a new way to use the exact same capabilities that &lt;code&gt;this.state&lt;/code&gt; provides in a class. Normally, variables &amp;ldquo;disappear&amp;rdquo; when the function exits but state variables are preserved by React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b30a539485d9441d425ec2b3084bed953a6014" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Hook?&lt;/strong&gt; A Hook is a special function that lets you &amp;ldquo;hook into&amp;rdquo; React features. For example, &lt;code&gt;useState&lt;/code&gt; is a Hook that lets you add React state to function components. We&amp;rsquo;ll learn other Hooks later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d1323a7f8fa9d21c7047d996ddcd7eff22d6128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When exactly does React clean up an effect?&lt;/strong&gt; React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React &lt;em&gt;also&lt;/em&gt; cleans up effects from the previous render before running the effects next time. We&amp;rsquo;ll discuss &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;why this helps avoid bugs&lt;/a&gt; and &lt;a href=&quot;#tip-optimizing-performance-by-skipping-effects&quot;&gt;how to opt out of this behavior in case it creates performance issues&lt;/a&gt; later below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde62d7c7740df72ba1511cc47dfdde7083bb226" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When would I use a Hook?&lt;/strong&gt; If you write a function component and realize you need to add some state to it, previously you had to convert it to a class. Now you can use a Hook inside the existing function component. We&amp;rsquo;re going to do that right now!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77e9a40ceae40917829155eaf3e70dcfc6d5018" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When you start using &lt;code&gt;forwardRef&lt;/code&gt; in a component library, you should treat it as a breaking change and release a new major version of your library.&lt;/strong&gt; This is because your library likely has an observably different behavior (such as what refs get assigned to, and what types are exported), and this can break apps and other libraries that depend on the old behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b061fc322314c21cd70363d5878e9efe3d1bc85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why did we return a function from our effect?&lt;/strong&gt; This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They&amp;rsquo;re part of the same effect!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ee54aaf8bb63d623d0a66010f960ccc989763a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is &lt;code&gt;useEffect&lt;/code&gt; called inside a component?&lt;/strong&gt; Placing &lt;code&gt;useEffect&lt;/code&gt; inside the component lets us access the &lt;code&gt;count&lt;/code&gt; state variable (or any props) right from the effect. We don&amp;rsquo;t need a special API to read it &amp;mdash; it&amp;rsquo;s already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55112c588a6b25d6c0aac03c1dacd1196aed574f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With Suspense, we don&amp;rsquo;t wait for the response to come back before we start rendering.&lt;/strong&gt; In fact, we start rendering &lt;em&gt;pretty much immediately&lt;/em&gt; after kicking off the network request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4117ea3d6710579e11068515fbe72df2387680c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can skip to the next page explaining how to write &lt;a href=&quot;hooks-custom&quot;&gt;your own Hooks&lt;/a&gt; now.&lt;/strong&gt; On this page, we&amp;rsquo;ll continue by explaining the reasoning behind these rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0df7a56cf2c82421e1d3a1858affb8c698d3d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can start learning Hooks &lt;a href=&quot;hooks-overview&quot;&gt;on the next page&lt;/a&gt;.&lt;/strong&gt; On this page, we&amp;rsquo;ll continue by explaining why we&amp;rsquo;re adding Hooks to React and how they can help you write great applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27b3a573e5be9d1bc32968e23c562ddb2f82c8cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can try moving that function outside of your component&lt;/strong&gt;. In that case, the function is guaranteed to not reference any props or state, and also doesn&amp;rsquo;t need to be in the list of dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a932ee6c57456f06d1bc9f032661d04172ebf2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You may not use the &lt;code&gt;ref&lt;/code&gt; attribute on function components&lt;/strong&gt; because they don&amp;rsquo;t have instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac60cacb0879e4c86951058b8760f2aae663d1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You may rely on &lt;code&gt;useMemo&lt;/code&gt; as a performance optimization, not as a semantic guarantee.&lt;/strong&gt; In the future, React may choose to &amp;ldquo;forget&amp;rdquo; some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without &lt;code&gt;useMemo&lt;/code&gt; &amp;mdash; and then add it to optimize performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b66c43e435b31f16f17afdeb55bafbbc36cbfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You may rely on &lt;code&gt;useMemo&lt;/code&gt; as a performance optimization, not as a semantic guarantee.&lt;/strong&gt; In the future, React may choose to &amp;ldquo;forget&amp;rdquo; some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without &lt;code&gt;useMemo&lt;/code&gt; &amp;mdash; and then add it to optimize performance. (For rare cases when a value must &lt;em&gt;never&lt;/em&gt; be recomputed, you can &lt;a href=&quot;#how-to-create-expensive-objects-lazily&quot;&gt;lazily initialize&lt;/a&gt; a ref.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fbfbf8015919f25ca15b9ef6450f01458edeeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You might also occasionally want to avoid re-creating the &lt;code&gt;useRef()&lt;/code&gt; initial value.&lt;/strong&gt; For example, maybe you want to ensure some imperative class instance only gets created once:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c92774ebded9b58a09fe3b3e5ebcdde0dc9b25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df3c1d271fd9a73acaa1ffa338f3130b66489579" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;debouncing&lt;/strong&gt;: publish changes after a period of inactivity (eg &lt;a href=&quot;https://lodash.com/docs#debounce&quot;&gt;&lt;code&gt;_.debounce&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a50caee20c00784555dd9a1adc5ebe8b987a31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fallback&lt;/strong&gt; takes a loading indicator. The fallback is shown until all of the children of the &lt;code&gt;Suspense&lt;/code&gt; component have finished rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2daf8e726ce9e46ec9eba873d089bc1299edffa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;revealOrder (forwards, backwards, together)&lt;/strong&gt; defines the order in which the &lt;code&gt;SuspenseList&lt;/code&gt; children should be revealed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a94bf5c1efb78639d8a6038fccdfa0588e24e404" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tail (collapsed, hidden)&lt;/strong&gt; dictates how unloaded items in a &lt;code&gt;SuspenseList&lt;/code&gt; is shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd849d720c770d8612b3f4538015dad929400340" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;theme-context.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;theme-context.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a02cb450d909fd579e5b2ae0fd1763e854cafb38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;theme-toggler-button.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;theme-toggler-button.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a52ff82a2242c204ebc842f2305e63bb53f8de27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;themed-button.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;themed-button.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68f4a9ea77788f2d5ab469332cdd45c9f826549b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;throttling&lt;/strong&gt;: sample changes based on a time based frequency (eg &lt;a href=&quot;https://lodash.com/docs#throttle&quot;&gt;&lt;code&gt;_.throttle&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b9f4e1bd226ee0dfc7502a4ce092999cc7357e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unstable_avoidThisFallback&lt;/strong&gt; takes a boolean. It tells React whether to &amp;ldquo;skip&amp;rdquo; revealing this boundary during the initial load. This API will likely be removed in a future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4396e0866aedabc957f13f58ab2a121c46fb5df" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;key&amp;rdquo; is a special string attribute you need to include when creating arrays of elements. Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside an array to give the elements a stable identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5507391adb53c909f54923d498a12d34d2604e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Parent&lt;/code&gt; component in &lt;code&gt;#app-root&lt;/code&gt; would be able to catch an uncaught, bubbling event from the sibling node &lt;code&gt;#modal-root&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4c644e46603eb49da231fabb3aba4672633975" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Profiler&lt;/code&gt; can be added anywhere in a React tree to measure the cost of rendering that part of the tree. It requires two props: an &lt;code&gt;id&lt;/code&gt; (string) and an &lt;code&gt;onRender&lt;/code&gt; callback (function) which React calls any time a component within the tree &amp;ldquo;commits&amp;rdquo; an update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c1768f3dce908aee0bd93c6ee78eb216e2dd9d" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;bundler&lt;/strong&gt;, such as &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; or &lt;a href=&quot;https://parceljs.org/&quot;&gt;Parcel&lt;/a&gt;. It lets you write modular code and bundle it together into small packages to optimize load time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6cf7b6e755026fcd351344960113414c207b074" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;compiler&lt;/strong&gt; such as &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;. It lets you write modern JavaScript code that still works in older browsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19def0eea706ffad262477b4a7266b48bc58b1f7" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;package manager&lt;/strong&gt;, such as &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;. It lets you take advantage of a vast ecosystem of third-party packages, and easily install or update them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96235b0ccc55b6e0f1b884d0362152d81c4afc7c" translate="yes" xml:space="preserve">
          <source>A Brief Interlude: Props vs State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f56c1cd7ae520f69ddd496d0b3b3f84a4ce199" translate="yes" xml:space="preserve">
          <source>A JavaScript build toolchain typically consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2ff8c4a07995be5a094f31a6fa10ae8186c90c" translate="yes" xml:space="preserve">
          <source>A JavaScript compiler takes JavaScript code, transforms it and returns JavaScript code in a different format. The most common use case is to take ES6 syntax and transform it into syntax that older browsers are capable of interpreting. &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; is the compiler most commonly used with React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba094cb88b0d39ff6d72e4edcee7588dec33ab9" translate="yes" xml:space="preserve">
          <source>A JavaScript error in a part of the UI shouldn&amp;rsquo;t break the whole app. To solve this problem for React users, React 16 introduces a new concept of an &amp;ldquo;error boundary&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3b93719c6a8e6d9963a816d3528e59fa4d5652" translate="yes" xml:space="preserve">
          <source>A React component can also return an array of elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e891be46d04c0877782b77916e5618821ec4a760" translate="yes" xml:space="preserve">
          <source>A React component that subscribes to context changes. This lets you subscribe to a context within a &lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;function component&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9982b82aa59906a97608a00f88f8eee9e247b7fb" translate="yes" xml:space="preserve">
          <source>A class component becomes an error boundary if it defines either (or both) of the lifecycle methods &lt;a href=&quot;react-component#static-getderivedstatefromerror&quot;&gt;&lt;code&gt;static getDerivedStateFromError()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;react-component#componentdidcatch&quot;&gt;&lt;code&gt;componentDidCatch()&lt;/code&gt;&lt;/a&gt;. Use &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; to render a fallback UI after an error has been thrown. Use &lt;code&gt;componentDidCatch()&lt;/code&gt; to log error information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85946ad755462c6c51d3003b0b5ca19b87d38d55" translate="yes" xml:space="preserve">
          <source>A class component becomes an error boundary if it defines either (or both) of the lifecycle methods &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; or &lt;code&gt;componentDidCatch()&lt;/code&gt;. Updating state from these lifecycles lets you capture an unhandled JavaScript error in the below tree and display a fallback UI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d7fd44264f048dd94bcae57b891f7bc6c4c24c" translate="yes" xml:space="preserve">
          <source>A common pattern in React is for a component to return multiple elements. Fragments let you group a list of children without adding extra nodes to the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3fb50c201a6d66a5fcbfd9121e149c289c8e81" translate="yes" xml:space="preserve">
          <source>A common pattern in older web applications is to describe chunks of the DOM as a string and insert it into the DOM like so: &lt;code&gt;$el.html(htmlString)&lt;/code&gt;. These points in a codebase are perfect for introducing React. Just rewrite the string based rendering as a React component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6050d5add6fcce04dd500fe62b6c7f840b515f88" translate="yes" xml:space="preserve">
          <source>A common pattern is for a component to return a list of children. Take this example React snippet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d043fa25657a2dd048fe1f4a69d7cea6fdb937" translate="yes" xml:space="preserve">
          <source>A common use case is to access a child imperatively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ac97e10cda00357023f8dac7efaa9d43739b09" translate="yes" xml:space="preserve">
          <source>A common way to do it is to use a pair of &lt;code&gt;beforeEach&lt;/code&gt; and &lt;code&gt;afterEach&lt;/code&gt; blocks so that they&amp;rsquo;ll always run and isolate the effects of a test to itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1463f438d6ad9ac7e893664c5d8497426b352e6d" translate="yes" xml:space="preserve">
          <source>A common way to fetch data in React apps today is to use an effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1123c7526ebd12d2e2469e1d65f5bf044f401d" translate="yes" xml:space="preserve">
          <source>A common way to work around the stutter is to &amp;ldquo;debounce&amp;rdquo; the input. When debouncing, we only update the list &lt;em&gt;after&lt;/em&gt; the user stops typing. However, it can be frustrating that the UI doesn&amp;rsquo;t update while we&amp;rsquo;re typing. As an alternative, we could &amp;ldquo;throttle&amp;rdquo; the input, and update the list with a certain maximum frequency. But then on lower-powered devices we&amp;rsquo;d still end up with stutter. Both debouncing and throttling create a suboptimal user experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ef2bdd655361b4730c3f316a3739e3cdb6810b" translate="yes" xml:space="preserve">
          <source>A component calling &lt;code&gt;useContext&lt;/code&gt; will always re-render when the context value changes. If re-rendering the component is expensive, you can &lt;a href=&quot;https://github.com/facebook/react/issues/15156#issuecomment-474590693&quot;&gt;optimize it by using memoization&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670684fa7013fe74073182e631f8d2bda028e63c" translate="yes" xml:space="preserve">
          <source>A component may choose to pass its state down as props to its child components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4d88745cc6194329485bff9e02c89f8a50c7dc" translate="yes" xml:space="preserve">
          <source>A component needs &lt;code&gt;state&lt;/code&gt; when some data associated with it changes over time. For example, a &lt;code&gt;Checkbox&lt;/code&gt; component might need &lt;code&gt;isChecked&lt;/code&gt; in its state, and a &lt;code&gt;NewsFeed&lt;/code&gt; component might want to keep track of &lt;code&gt;fetchedPosts&lt;/code&gt; in its state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5680a8ed7702957f0d8c7a32c2820f18801e887" translate="yes" xml:space="preserve">
          <source>A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d339685bcb53b536cbeb52aaf1e134ce78fd82" translate="yes" xml:space="preserve">
          <source>A good example of this is a text input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad565e1d57c268501a85ceb82a25578cbd7079c2" translate="yes" xml:space="preserve">
          <source>A good place to start is with routes. Most people on the web are used to page transitions taking some amount of time to load. You also tend to be re-rendering the entire page at once so your users are unlikely to be interacting with other elements on the page at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fc89c86f8b8cd8ae7b62e2eecafed4be041ae4" translate="yes" xml:space="preserve">
          <source>A good rule of thumb is that elements inside the &lt;code&gt;map()&lt;/code&gt; call need keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c920ca7b5409f13069c873e9b3dbdd7e928674aa" translate="yes" xml:space="preserve">
          <source>A great focus management example is the &lt;a href=&quot;https://github.com/davidtheclark/react-aria-modal&quot;&gt;react-aria-modal&lt;/a&gt;. This is a relatively rare example of a fully accessible modal window. Not only does it set initial focus on the cancel button (preventing the keyboard user from accidentally activating the success action) and trap keyboard focus inside the modal, it also resets focus back to the element that initially triggered the modal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16d4c651998deba160cdf7ab4093d2cc3465f8b4" translate="yes" xml:space="preserve">
          <source>A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React&amp;rsquo;s compositional nature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9eb78cca71516797afe39b05e7c09ace93db87" translate="yes" xml:space="preserve">
          <source>A large portion of UI tests can be written with the above setup: using Jest as a test runner, rendered to jsdom, with user interactions specified as sequences of browser events, powered by the &lt;code&gt;act()&lt;/code&gt; helper &lt;a href=&quot;testing-recipes&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;. For example, a lot of React&amp;rsquo;s own tests are written with this combination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9828e8b0570a46bbb628eb1843e24e00e08488cc" translate="yes" xml:space="preserve">
          <source>A more complex example with dynamic values for the theme:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5050724b4013a51ee3210911524a3fbc93ef6d92" translate="yes" xml:space="preserve">
          <source>A more complex user experience should not mean a less accessible one. Whereas accessibility is most easily achieved by coding as close to HTML as possible, even the most complex widget can be coded accessibly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd665d7b5af176ea3255d7fb95c76e58c2f84dc" translate="yes" xml:space="preserve">
          <source>A note on cross-browser support:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd2634152fa67a25351b7d726c729a45da4f302" translate="yes" xml:space="preserve">
          <source>A number of tools exist that can run accessibility audits on web pages in your browser. Please use them in combination with other accessibility checks mentioned here as they can only test the technical accessibility of your HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0244350f6de38a5bb3e053c6127bf4b17603558d" translate="yes" xml:space="preserve">
          <source>A polyfilled environment for React 16 using core-js to support older browsers might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50abdf7665198c561d0675f2148253aad1a8c9c" translate="yes" xml:space="preserve">
          <source>A production profiling bundle of &lt;code&gt;react-dom&lt;/code&gt; is also available as &lt;code&gt;react-dom/profiling&lt;/code&gt;. Read more about how to use this bundle at &lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me/react-profiling&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc07c0b0ea027a3e2155dfb9949fef8dfe3aa7e" translate="yes" xml:space="preserve">
          <source>A project that uses this workflow is Next.js. (No pun intended! Seriously!) You can refer to their &lt;a href=&quot;https://github.com/zeit/next.js/blob/c0a1c0f93966fe33edd93fb53e5fafb0dcd80a9e/.circleci/config.yml&quot;&gt;CircleCI configuration&lt;/a&gt; as an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ca2093a95d59cfef3f519caef447c5f809ef57" translate="yes" xml:space="preserve">
          <source>A single-page application is an application that loads a single HTML page and all the necessary assets (such as JavaScript and CSS) required for the application to run. Any interactions with the page or subsequent pages do not require a round trip to the server which means the page is not reloaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4745128a18352cf4e73b00ea8cdbbe7e834740bc" translate="yes" xml:space="preserve">
          <source>A snapshot value (or &lt;code&gt;null&lt;/code&gt;) should be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc736c6f1365f15c2d720e8ca595629db1d676a" translate="yes" xml:space="preserve">
          <source>A typical use case for portals is when a parent component has an &lt;code&gt;overflow: hidden&lt;/code&gt; or &lt;code&gt;z-index&lt;/code&gt; style, but you need the child to visually &amp;ldquo;break out&amp;rdquo; of its container. For example, dialogs, hovercards, and tooltips.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac896ed983bf97bf8e6cfe4fffcba80cd461b7c" translate="yes" xml:space="preserve">
          <source>A11yProject - What is Color Contrast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec50041532b6a570e0d54267dbf63dccf5fcedac" translate="yes" xml:space="preserve">
          <source>AJAX and APIs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06b24442f3c9004ce865f2104ae68d66222a2a3" translate="yes" xml:space="preserve">
          <source>APIs may be added, changed, or removed with any &lt;code&gt;@experimental&lt;/code&gt; release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e59a72fe177aa09a24bcbd1834483a033559649" translate="yes" xml:space="preserve">
          <source>Accepts a &lt;code&gt;value&lt;/code&gt; prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809825dbb77b26dacea934e8e859ee68b7aaa208" translate="yes" xml:space="preserve">
          <source>Accepts a context object (the value returned from &lt;code&gt;React.createContext&lt;/code&gt;) and returns the current context value for that context. The current context value is determined by the &lt;code&gt;value&lt;/code&gt; prop of the nearest &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; above the calling component in the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd58f0030532c86f9b111bbb1e2cefd63bc42fb" translate="yes" xml:space="preserve">
          <source>Accepts a function that contains imperative, possibly effectful code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d660049bc1f2f54fc0e3f4ace6fa5eb205f2f1e0" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Accessibility</target>
        </trans-unit>
        <trans-unit id="4d1b559d0d1263d16fa61d462038757b2e5ce98b" translate="yes" xml:space="preserve">
          <source>Accessibility inspectors and the Accessibility Tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d8de3d81a99aab854c5a4634ff2db60206331c" translate="yes" xml:space="preserve">
          <source>Accessible Forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6ddd1e049241e0a3eda93f2e449bea87390614" translate="yes" xml:space="preserve">
          <source>Accessible Landmarks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42784ddbf707ebeafc069514648e2a2236dbf6ba" translate="yes" xml:space="preserve">
          <source>Accessing Refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b4fc7744dc987988ba047f2f64f8573ee1f968" translate="yes" xml:space="preserve">
          <source>Add Flow to your project as a dependency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c991518e214addabd69c929b69c15f5ffa78384" translate="yes" xml:space="preserve">
          <source>Add JSX to a Project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086d017a0d48c2e97016b21c91028b329027d930" translate="yes" xml:space="preserve">
          <source>Add React in One Minute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb35e825a1124c1b826eac67bd47b533d7350da0" translate="yes" xml:space="preserve">
          <source>Add React to a Website</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809cad31dc04417ec8929388ee064bf53fbe23d9" translate="yes" xml:space="preserve">
          <source>Add TypeScript as a dependency to your project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25346a9b833f19f08e98c87e8bd05d06f4819742" translate="yes" xml:space="preserve">
          <source>Add a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor&quot;&gt;class constructor&lt;/a&gt; that assigns the initial &lt;code&gt;this.state&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed3ba4ae4e3ada698740a033115bb4fdc3841f1" translate="yes" xml:space="preserve">
          <source>Add a single empty method to it called &lt;code&gt;render()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547d9540d79afaae7eb80ed44e3ca7fea58f3419" translate="yes" xml:space="preserve">
          <source>Add definitions for libraries you use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc65929a02821d71ec2e2df3b6a57e8e6f0cfd17" translate="yes" xml:space="preserve">
          <source>Add type annotations and run Flow to check them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a550467b7342d7bbe3954c6ad4e1e9089274ef12" translate="yes" xml:space="preserve">
          <source>Adding Flow Type Annotations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587d11acd4c747cc91558c0741bc1f8fece6e060" translate="yes" xml:space="preserve">
          <source>Adding Flow to a Project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18aadea57b9df0a2d9c35cf35667510817c802a" translate="yes" xml:space="preserve">
          <source>Adding JSX to a project doesn&amp;rsquo;t require complicated tools like a bundler or a development server. Essentially, adding JSX &lt;strong&gt;is a lot like adding a CSS preprocessor.&lt;/strong&gt; The only requirement is to have &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; installed on your computer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ccc3606ed0935928cc00e815d1ab4ed09206bd4" translate="yes" xml:space="preserve">
          <source>Adding Lifecycle Methods to a Class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575c269353f1f093313046756c09d3f3fae275b7" translate="yes" xml:space="preserve">
          <source>Adding Local State to a Class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4864a2e1ec0ba08f3b6af6c32e74a09d035420cc" translate="yes" xml:space="preserve">
          <source>Adding TypeScript to a Project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91087561482eeaaac2d6c9f8be7d0f3e02611c1b" translate="yes" xml:space="preserve">
          <source>Adding a Pending Indicator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2767d8da201f51979a038ce62beeb570e562f6a" translate="yes" xml:space="preserve">
          <source>Adding a Ref to a Class Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4717a3f0cfb3f09b7e4a1e21b3a4c4d185091936" translate="yes" xml:space="preserve">
          <source>Adding a Ref to a DOM Element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b255da4a4843e46bc1afb50e64e3897e12611a4" translate="yes" xml:space="preserve">
          <source>Adding a Second Input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a4c7231b2d630925037cb061d866d786c9d008" translate="yes" xml:space="preserve">
          <source>Additional Hooks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e246a0bab77ff9b9d3f757e4016354d8a0e9c21" translate="yes" xml:space="preserve">
          <source>Additional functionality will be added with future releases of React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e467b2b452848db9e10c52adb4d9a045097dc1cf" translate="yes" xml:space="preserve">
          <source>Additionally, React has been out for about five years, and we want to make sure it stays relevant in the next five years. As &lt;a href=&quot;https://svelte.dev/&quot;&gt;Svelte&lt;/a&gt;, &lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt;, &lt;a href=&quot;https://glimmerjs.com/&quot;&gt;Glimmer&lt;/a&gt;, and others show, &lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;ahead-of-time compilation&lt;/a&gt; of components has a lot of future potential. Especially if it&amp;rsquo;s not limited to templates. Recently, we&amp;rsquo;ve been experimenting with &lt;a href=&quot;https://github.com/facebook/react/issues/7323&quot;&gt;component folding&lt;/a&gt; using &lt;a href=&quot;https://prepack.io/&quot;&gt;Prepack&lt;/a&gt;, and we&amp;rsquo;ve seen promising early results. However, we found that class components can encourage unintentional patterns that make these optimizations fall back to a slower path. Classes present issues for today&amp;rsquo;s tools, too. For example, classes don&amp;rsquo;t minify very well, and they make hot reloading flaky and unreliable. We want to present an API that makes it more likely for code to stay on the optimizable path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e528bf2d8f58658ae937110a5ddeddfe98188b0f" translate="yes" xml:space="preserve">
          <source>Additionally, it renders the &lt;code&gt;BoilingVerdict&lt;/code&gt; for the current input value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d8af2ce2c7a89382928343c6066e863feed9a5" translate="yes" xml:space="preserve">
          <source>Addressing the issues identified by strict mode &lt;em&gt;now&lt;/em&gt; will make it easier for you to take advantage of async rendering in future releases of React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22954472d775b0b1be14e3fcc04208797ed42abf" translate="yes" xml:space="preserve">
          <source>Adopting Concurrent Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="962c4a36d76f10153e37a64bc3586ceaab6fcab5" translate="yes" xml:space="preserve">
          <source>Adopting Concurrent Mode (Experimental)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27bd5da322edd19f0435864f00932a75456ddca" translate="yes" xml:space="preserve">
          <source>Adoption Strategy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa07c56f702314b63d39c0b7e492104e367c9eb" translate="yes" xml:space="preserve">
          <source>Advanced Concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5218ce8b68960a0c1d0ca0b0cb45a6b0b89b75de" translate="yes" xml:space="preserve">
          <source>Advanced Guides</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc61b397b6be13c2ea83cc7838ff1f6e887b7709" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;shallowRenderer.render()&lt;/code&gt; has been called, you can use &lt;code&gt;shallowRenderer.getRenderOutput()&lt;/code&gt; to get the shallowly rendered output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634b8416814c1a4eebfe7f04d710ecbda6b5fcce" translate="yes" xml:space="preserve">
          <source>After &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;the starter code&lt;/a&gt;&lt;/strong&gt;, add two lines to the bottom of &lt;code&gt;like_button.js&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb9663be8297e0f777fa61a8597c8a63787b7a1" translate="yes" xml:space="preserve">
          <source>After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6377d667974c26a5fe1b3c181bb04235faf147a9" translate="yes" xml:space="preserve">
          <source>After handling the DOM node, React then recurses on the children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3704d1e6e1604e443e390d03ccd77e9457ac24a3" translate="yes" xml:space="preserve">
          <source>After the click, React started rendering the next screen:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899a132c7131f8da48059337d05ef25041d4c75e" translate="yes" xml:space="preserve">
          <source>Again, notice that &lt;strong&gt;we&amp;rsquo;re not waiting for the response to set the state. It&amp;rsquo;s the other way around: we set the state (and start rendering) immediately after kicking off a request&lt;/strong&gt;. As soon as we have more data, React &amp;ldquo;fills in&amp;rdquo; the content inside &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01d83d5f47cb6f8ccd677b6c6bb8955308e6113" translate="yes" xml:space="preserve">
          <source>All Supported HTML Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="576e625f6a5bb19b6dc10a4685b4b3c255437e88" translate="yes" xml:space="preserve">
          <source>All changes to React go through extensive internal testing before they are released to the public. However, there are a myriad of environments and configurations used throughout the React ecosystem, and it&amp;rsquo;s not possible for us to test against every single one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc3903d35e829b702ef8fd5ee160caf3e73123c" translate="yes" xml:space="preserve">
          <source>All consumers that are descendants of a Provider will re-render whenever the Provider&amp;rsquo;s &lt;code&gt;value&lt;/code&gt; prop changes. The propagation from Provider to its descendant consumers (including &lt;a href=&quot;#classcontexttype&quot;&gt;&lt;code&gt;.contextType&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;hooks-reference#usecontext&quot;&gt;&lt;code&gt;useContext&lt;/code&gt;&lt;/a&gt;) is not subject to the &lt;code&gt;shouldComponentUpdate&lt;/code&gt; method, so the consumer is updated even when an ancestor component skips an update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e24a43b87d7f7bc0f02a784b5dc9b38b5a810c" translate="yes" xml:space="preserve">
          <source>All releases are published to npm, but only Latest uses &lt;a href=&quot;faq-versioning&quot;&gt;semantic versioning&lt;/a&gt;. Prereleases (those in the Next and Experimental channels) have versions generated from a hash of their contents, e.g. &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt; for Next and &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt; for Experimental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c6cd0a0f578763ad3da70088a5eca15dd6f467" translate="yes" xml:space="preserve">
          <source>Also note that this pattern might cause problems in the &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;concurrent mode&lt;/a&gt;. We plan to provide more ergonomic alternatives in the future, but the safest solution right now is to always invalidate the callback if some value it depends on changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0881d750700961baeb728e809bf3abda69b5b1" translate="yes" xml:space="preserve">
          <source>Also use landmark elements and roles, such as &lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;, to demarcate page regions as assistive technology allow the user to quickly navigate to these sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa429502a4c88c485e04e07f1fc75825c4110db" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;setState()&lt;/code&gt; automatically &lt;a href=&quot;state-and-lifecycle#state-updates-are-merged&quot;&gt;merges a partial state into the current state&lt;/a&gt;, we only needed to call it with the changed parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e283c1957a3a5f491d12bdc54dc942cfec4b5eac" translate="yes" xml:space="preserve">
          <source>Alternately, you can use DOM APIs to store data needed for event handlers. Consider this approach if you need to optimize a large number of elements or have a render tree that relies on React.PureComponent equality checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04eaa8332063237a2339350c634f6fd5fc3a9b6" translate="yes" xml:space="preserve">
          <source>Alternatively, Airbnb has released a testing utility called &lt;a href=&quot;https://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;, which makes it easy to assert, manipulate, and traverse your React Components&amp;rsquo; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546503387b42bc8b3ddf6e6f4ff8abd001a0e9b7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can refer to community projects such as &lt;a href=&quot;https://github.com/mlmorg/react-hyperscript&quot;&gt;&lt;code&gt;react-hyperscript&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/ohanhi/hyperscript-helpers&quot;&gt;&lt;code&gt;hyperscript-helpers&lt;/code&gt;&lt;/a&gt; which offer a terser syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c6438cd5d3f55950518120d03416c1ee83616f" translate="yes" xml:space="preserve">
          <source>Alternatives to Controlled Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241369d96a24458352ce7d2c48c3c51b72b2b9a0" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;Profiler&lt;/code&gt; is a light-weight component, it should be used only when necessary; each use adds some CPU and memory overhead to an application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd44ae5ccfed12b1c010994f28d7531e039e164" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;useEffect&lt;/code&gt; is deferred until after the browser has painted, it&amp;rsquo;s guaranteed to fire before any new renders. React will always flush a previous render&amp;rsquo;s effects before starting a new update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7532ae36812091fdbaff1778d045a73e3cf53a3" translate="yes" xml:space="preserve">
          <source>Although React is commonly used at startup to load a single root React component into the DOM, &lt;code&gt;ReactDOM.render()&lt;/code&gt; can also be called multiple times for independent parts of the UI which can be as small as a button, or as large as an app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4423d4d7befa33ec5f29f735ed0d62afa44ee6e2" translate="yes" xml:space="preserve">
          <source>Although it&amp;rsquo;s technically doable, Suspense is &lt;strong&gt;not&lt;/strong&gt; currently intended as a way to start fetching data when a component renders. Rather, it lets components express that they&amp;rsquo;re &amp;ldquo;waiting&amp;rdquo; for data that is &lt;em&gt;already being fetched&lt;/em&gt;. &lt;strong&gt;&lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;Building Great User Experiences with Concurrent Mode and Suspense&lt;/a&gt; describes why this matters and how to implement this pattern in practice.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd17f9d9908f716e52a6bed18c0ec0f584b692a5" translate="yes" xml:space="preserve">
          <source>Although such encapsulation is desirable for application-level components like &lt;code&gt;FeedStory&lt;/code&gt; or &lt;code&gt;Comment&lt;/code&gt;, it can be inconvenient for highly reusable &amp;ldquo;leaf&amp;rdquo; components like &lt;code&gt;FancyButton&lt;/code&gt; or &lt;code&gt;MyTextInput&lt;/code&gt;. These components tend to be used throughout the application in a similar manner as a regular DOM &lt;code&gt;button&lt;/code&gt; and &lt;code&gt;input&lt;/code&gt;, and accessing their DOM nodes may be unavoidable for managing focus, selection, or animations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b87fc4ac59367232ee26438ecc79c94e4a3e5b" translate="yes" xml:space="preserve">
          <source>Although the examples above use &lt;code&gt;render&lt;/code&gt;, we could just as easily use the &lt;code&gt;children&lt;/code&gt; prop!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80247c2365054862000d6aeb603ca72df0fe159" translate="yes" xml:space="preserve">
          <source>Although these standard HTML practices can be directly used in React, note that the &lt;code&gt;for&lt;/code&gt; attribute is written as &lt;code&gt;htmlFor&lt;/code&gt; in JSX:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868104f6e8953f806f4afbb3a838af8b565d552f" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;uncontrolled component&lt;/em&gt; works like form elements do outside of React. When a user inputs data into a form field (an input box, dropdown, etc) the updated information is reflected without React needing to do anything. However, this also means that you can&amp;rsquo;t force the field to have a certain value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a57cc8c9dc9df0ab903aaab7f338a14894c9aab" translate="yes" xml:space="preserve">
          <source>An API like &lt;code&gt;useTransition&lt;/code&gt; lets you focus on the desired user experience, and not think about the mechanics of how it&amp;rsquo;s implemented. Still, it can be a helpful metaphor to imagine that updates wrapped in &lt;code&gt;startTransition&lt;/code&gt; happen &amp;ldquo;on a branch&amp;rdquo; or &amp;ldquo;in a different world&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68140fb4e688bc64196283497d2bdb8b7794a042" translate="yes" xml:space="preserve">
          <source>An alternative to &lt;a href=&quot;#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt;. Accepts a reducer of type &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;, and returns the current state paired with a &lt;code&gt;dispatch&lt;/code&gt; method. (If you&amp;rsquo;re familiar with Redux, you already know how this works.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34de2ea3a7b2ff60cffeaba53955ef350c113c02" translate="yes" xml:space="preserve">
          <source>An element describes what you want to see on the screen:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332df723151107dc7a32c730fbc52b2b3b2e4d33" translate="yes" xml:space="preserve">
          <source>An input form element whose value is controlled by React is called a &lt;em&gt;controlled component&lt;/em&gt;. When a user enters data into a controlled component a change event handler is triggered and your code decides whether the input is valid (by re-rendering with the updated value). If you do not re-render then the form element will remain unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2996e0fe23009f56c38d7488a07be4ff07b9dfa" translate="yes" xml:space="preserve">
          <source>An update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df4d5ef123c895ff771594316c92afb17ff67a0" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt;&lt;/a&gt; lets you manage local state of complex components with a reducer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988a0414af267dcb188783148f4aa2483606d30e" translate="yes" xml:space="preserve">
          <source>And That&amp;rsquo;s It</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf3a1adfcc066838ee4661dcceb95d7378bb404" translate="yes" xml:space="preserve">
          <source>And remember, the &lt;code&gt;children&lt;/code&gt; prop doesn&amp;rsquo;t actually need to be named in the list of &amp;ldquo;attributes&amp;rdquo; in your JSX element. Instead, you can put it directly &lt;em&gt;inside&lt;/em&gt; the element!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c34616e84009712cba18fa581c98ede1b9aafd" translate="yes" xml:space="preserve">
          <source>And that&amp;rsquo;s it! The wrapped component receives all the props of the container, along with a new prop, &lt;code&gt;data&lt;/code&gt;, which it uses to render its output. The HOC isn&amp;rsquo;t concerned with how or why the data is used, and the wrapped component isn&amp;rsquo;t concerned with where the data came from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7f513a00353c61bc6f044dde142a57fe3f51b1" translate="yes" xml:space="preserve">
          <source>And then we can put it anywhere in the tree to catch errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="093dae0b59674686c00fe05ce3246b47a82b8ed8" translate="yes" xml:space="preserve">
          <source>Animation Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a1bc05c0329ca7661aa6145724626817c52e4c" translate="yes" xml:space="preserve">
          <source>Another difference is that you cannot return &lt;code&gt;false&lt;/code&gt; to prevent default behavior in React. You must call &lt;code&gt;preventDefault&lt;/code&gt; explicitly. For example, with plain HTML, to prevent the default link behavior of opening a new page, you can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e1e6e124b4dd25605ccf99d61371ca60ae4a4d" translate="yes" xml:space="preserve">
          <source>Another method for conditionally rendering elements inline is to use the JavaScript conditional operator &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator&quot;&gt;&lt;code&gt;condition ? true : false&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e45886ae3796dc23d86371bad5e1054b434557" translate="yes" xml:space="preserve">
          <source>Another option is &lt;code&gt;useReducer&lt;/code&gt;, which is more suited for managing state objects that contain multiple sub-values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47edf6d669b78899eccfabccdd7096df09b3073" translate="yes" xml:space="preserve">
          <source>Another popular way to structure projects is to group similar files together, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc7dff748d08032efe0c8a8ab8b07a5cd5920fb" translate="yes" xml:space="preserve">
          <source>Another possible solution is to export the static method separately from the component itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f4bbcd06c44cfc2ee6c4cc092fadfdc2aca1bf" translate="yes" xml:space="preserve">
          <source>Any child in the tree inside &lt;code&gt;TodosApp&lt;/code&gt; can use the &lt;code&gt;dispatch&lt;/code&gt; function to pass actions up to &lt;code&gt;TodosApp&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a522a53bfc9303f9b72ce1b553651f8aca9c580" translate="yes" xml:space="preserve">
          <source>Any components below the root will also get unmounted and have their state destroyed. For example, when diffing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aedd7b8dff3cf1f14d47f7c7329445ee2f4b2d58" translate="yes" xml:space="preserve">
          <source>Any function inside a component, including event handlers and effects, &amp;ldquo;sees&amp;rdquo; the props and state from the render it was created in. For example, consider code like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f49546959e051bb64df05e2a2293656f5786f3f" translate="yes" xml:space="preserve">
          <source>Anything inside the &lt;code&gt;&amp;lt;FancyBorder&amp;gt;&lt;/code&gt; JSX tag gets passed into the &lt;code&gt;FancyBorder&lt;/code&gt; component as a &lt;code&gt;children&lt;/code&gt; prop. Since &lt;code&gt;FancyBorder&lt;/code&gt; renders &lt;code&gt;{props.children}&lt;/code&gt; inside a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, the passed elements appear in the final output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa299e264f5e76931f8cb209b83fffb45816f24" translate="yes" xml:space="preserve">
          <source>Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e6fb77ae739da9f6502ec7db3988c4619fa8bd" translate="yes" xml:space="preserve">
          <source>Approach 1: Fetch-on-Render (not using Suspense)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9feb99ab74114b1088328de56c35767ffbd3cd9" translate="yes" xml:space="preserve">
          <source>Approach 2: Fetch-Then-Render (not using Suspense)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c57781f77789ad80982aaf7935538da556bc2f" translate="yes" xml:space="preserve">
          <source>Approach 3: Render-as-You-Fetch (using Suspense)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34def147d0a0b705dc77cd5a742d57d852d3d9a5" translate="yes" xml:space="preserve">
          <source>Are Hooks slow because of creating functions in render?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafcd4680a5bb029c409d8d4661e70bb2bd0f99f" translate="yes" xml:space="preserve">
          <source>Are inline styles bad?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157b87629fda27d802b1137877c75e1f56290070" translate="yes" xml:space="preserve">
          <source>Arrow Function in Render</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111abfdd524656d236b279d85e69e3213edf5777" translate="yes" xml:space="preserve">
          <source>As a bonus, this also lets you use modern JavaScript syntax features like classes without worrying about breaking older browsers. The tool we just used is called Babel, and you can learn more about it from &lt;a href=&quot;https://babeljs.io/docs/en/babel-cli/&quot;&gt;its documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72221537c40418d03696ee3da06de3c59bffbfb" translate="yes" xml:space="preserve">
          <source>As a first pass, you might try rendering the &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt;&lt;em&gt;inside &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt;&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method&lt;/em&gt;, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3480fd67c41d681c4c73b565f4148607a8cf72ab" translate="yes" xml:space="preserve">
          <source>As a last resort, if you want something like &lt;code&gt;this&lt;/code&gt; in a class, you can &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;use a ref&lt;/a&gt; to hold a mutable variable. Then you can write and read to it. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab419ab7a7f9da60b42781bc4f2d7c44971ae520" translate="yes" xml:space="preserve">
          <source>As a last resort, you can &lt;strong&gt;add a function to effect dependencies but &lt;em&gt;wrap its definition&lt;/em&gt;&lt;/strong&gt; into the &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; Hook. This ensures it doesn&amp;rsquo;t change on every render unless &lt;em&gt;its own&lt;/em&gt; dependencies also change:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5485bb52f0ad6f3a9fdf0a95e59fa17727d5e7" translate="yes" xml:space="preserve">
          <source>As a last resort, you can pass an item&amp;rsquo;s index in the array as a key. This can work well if the items are never reordered, but reorders will be slow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ce72b0e79de038d3533652e10d45dd26b90126" translate="yes" xml:space="preserve">
          <source>As a reminder, function components in React look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7100670830cae6e122121b9df4b95c4bad9043" translate="yes" xml:space="preserve">
          <source>As a result, after React attaches the ref, &lt;code&gt;ref.current&lt;/code&gt; will point directly to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOM element instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe17b7bf9e2fae7dcd0fad9fb69936347ae61374" translate="yes" xml:space="preserve">
          <source>As a result, clicking &amp;ldquo;Next&amp;rdquo; doesn&amp;rsquo;t perform an immediate state transition to an &amp;ldquo;undesirable&amp;rdquo; loading state, but instead stays on the previous screen and communicates progress there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5b42d938372321ac9f225b3a2bb1df4ed68810" translate="yes" xml:space="preserve">
          <source>As defined in the &lt;a href=&quot;https://www.w3.org/TR/pointerevents/&quot;&gt;W3 spec&lt;/a&gt;, pointer events extend &lt;a href=&quot;#mouse-events&quot;&gt;Mouse Events&lt;/a&gt; with the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818f1373ccb0dd1f7001d028a458845e63ef8b97" translate="yes" xml:space="preserve">
          <source>As explained &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;in this blog post&lt;/a&gt;, certain legacy lifecycle methods are unsafe for use in async React applications. However, if your application uses third party libraries, it can be difficult to ensure that these lifecycles aren&amp;rsquo;t being used. Fortunately, strict mode can help with this!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618759a907e7cf1f51fefba731539d10be79d41a" translate="yes" xml:space="preserve">
          <source>As explained in the previous section, React intentionally &amp;ldquo;waits&amp;rdquo; until all components call &lt;code&gt;setState()&lt;/code&gt; in their event handlers before starting to re-render. This boosts performance by avoiding unnecessary re-renders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd9c9857788846b2c841d045df4cafad143d07d6" translate="yes" xml:space="preserve">
          <source>As long as the order of the Hook calls is the same between renders, React can associate some local state with each of them. But what happens if we put a Hook call (for example, the &lt;code&gt;persistForm&lt;/code&gt; effect) inside a condition?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31c654a2d76de2824154c42119bc22661141b6e" translate="yes" xml:space="preserve">
          <source>As of React 16, &lt;code&gt;componentDidUpdate&lt;/code&gt; no longer receives &lt;code&gt;prevContext&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033173c312336a96f266a1dac29b328cbd27cc83" translate="yes" xml:space="preserve">
          <source>As of React 16, any standard &lt;a href=&quot;https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html&quot;&gt;or custom&lt;/a&gt; DOM attributes are fully supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403350f5a4f73b11b9b9e7843a5d0bc9230d2ed0" translate="yes" xml:space="preserve">
          <source>As of v0.14, returning &lt;code&gt;false&lt;/code&gt; from an event handler will no longer stop event propagation. Instead, &lt;code&gt;e.stopPropagation()&lt;/code&gt; or &lt;code&gt;e.preventDefault()&lt;/code&gt; should be triggered manually, as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ad1d16798f383be75cfa787bea2e38fd43fe07" translate="yes" xml:space="preserve">
          <source>As projects grow larger, they often use a mix of both of the above approaches in practice. So choosing the &amp;ldquo;right&amp;rdquo; one in the beginning isn&amp;rsquo;t very important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00113438ae91984d6aba1a6753e5b2b4f2f519a1" translate="yes" xml:space="preserve">
          <source>As the cursor moves around the screen, the component displays its (x, y) coordinates in a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8366d6776409ee82e022219e951f753575da678f" translate="yes" xml:space="preserve">
          <source>As we &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;learned earlier&lt;/a&gt;, we can use multiple State or Effect Hooks in a single component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764b7a52100f17ee3b43966a190ebeb6ecb97870" translate="yes" xml:space="preserve">
          <source>As we change React over time, we try to minimize the effort required to take advantage of new features. When possible, we&amp;rsquo;ll keep an older API working, even if that means putting it in a separate package. For example, &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;mixins have been discouraged for years&lt;/a&gt; but they&amp;rsquo;re supported to this day &lt;a href=&quot;react-without-es6#mixins&quot;&gt;via create-react-class&lt;/a&gt; and many codebases continue to use them in stable, legacy code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d83cd2ccd3ae3931db4245677908d70eb63547" translate="yes" xml:space="preserve">
          <source>As we learned from the &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense walkthrough&lt;/a&gt;, any component can &amp;ldquo;suspend&amp;rdquo; any time if some data it needs is not ready yet. We can strategically place &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundaries in different parts of the tree to handle this, but it won&amp;rsquo;t always be enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0c1ee1f2dae62b2799c090905f42ef24209ca8" translate="yes" xml:space="preserve">
          <source>As we load more data, React will retry rendering, and &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; can render successfully. Finally, we&amp;rsquo;re in the &lt;strong&gt;Skeleton&lt;/strong&gt; state. We see the new page with missing parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832019f9a5b2be6cc5ba14b337bebb38d050ddb6" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, if some state update causes a component to suspend, that state update should be wrapped in a transition. Let&amp;rsquo;s add &lt;code&gt;useTransition&lt;/code&gt; to our component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc9c124f33b4d8a034d36e6d329f82371149ffa" translate="yes" xml:space="preserve">
          <source>As your app grows, you can catch a lot of bugs with typechecking. For some applications, you can use JavaScript extensions like &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; or &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; to typecheck your whole application. But even if you don&amp;rsquo;t use those, React has some built-in typechecking abilities. To run typechecking on the props for a component, you can assign the special &lt;code&gt;propTypes&lt;/code&gt; property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39df56b20aa1f511f60e5016cdd8dacda9f05264" translate="yes" xml:space="preserve">
          <source>As your application grows, you might want to consider a more integrated setup. There are several JavaScript toolchains we recommend for larger applications. Each of them can work with little to no configuration and lets you take full advantage of the rich React ecosystem. &lt;a href=&quot;create-a-new-react-app&quot;&gt;Learn how.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2d1c125db60a3ed69387c5dd6f32c2090c8a05" translate="yes" xml:space="preserve">
          <source>Asynchronous code (e.g. &lt;code&gt;setTimeout&lt;/code&gt; or &lt;code&gt;requestAnimationFrame&lt;/code&gt; callbacks)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc5bf90f358060e968febaa39d904a8cfea7f0c" translate="yes" xml:space="preserve">
          <source>At Facebook, so far we have only used the Relay integration with Suspense in production. &lt;strong&gt;If you&amp;rsquo;re looking for a practical guide to get started today, &lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;check out the Relay Guide&lt;/a&gt;!&lt;/strong&gt; It demonstrates patterns that have already worked well for us in production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6d9081fe7eb7ee0d370f5453d055df7593e98f" translate="yes" xml:space="preserve">
          <source>At Facebook, we use React in thousands of components, and we haven&amp;rsquo;t found any use cases where we would recommend creating component inheritance hierarchies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7302e3429aa52da228df9adeaf52381981fec228" translate="yes" xml:space="preserve">
          <source>At React Conf 2018, Sophie Alpert and Dan Abramov introduced Hooks, followed by Ryan Florence demonstrating how to refactor an application to use them. Watch the video here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="562ffc6d5d4c2b54a60539bae99dd32ecf6ac12b" translate="yes" xml:space="preserve">
          <source>At first glance, this code might not seem problematic. But if &lt;code&gt;SharedApplicationState.recordEvent&lt;/code&gt; is not &lt;a href=&quot;https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning&quot;&gt;idempotent&lt;/a&gt;, then instantiating this component multiple times could lead to invalid application state. This sort of subtle bug might not manifest during development, or it might do so inconsistently and so be overlooked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26383eadb177782413aa518c405bb97fbb4ce3d4" translate="yes" xml:space="preserve">
          <source>At the end of this step, you&amp;rsquo;ll have a library of reusable components that render your data model. The components will only have &lt;code&gt;render()&lt;/code&gt; methods since this is a static version of your app. The component at the top of the hierarchy (&lt;code&gt;FilterableProductTable&lt;/code&gt;) will take your data model as a prop. If you make a change to your underlying data model and call &lt;code&gt;ReactDOM.render()&lt;/code&gt; again, the UI will be updated. You can see how your UI is updated and where to make changes. React&amp;rsquo;s &lt;strong&gt;one-way data flow&lt;/strong&gt; (also called &lt;em&gt;one-way binding&lt;/em&gt;) keeps everything modular and fast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e0bba770e87968ab26b848711abfb803e1c0f7" translate="yes" xml:space="preserve">
          <source>At the very end, we have the &lt;strong&gt;Complete&lt;/strong&gt; state. That&amp;rsquo;s where we want to eventually get to. It represents the moment when the next screen is fully rendered and isn&amp;rsquo;t loading more data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5105254b950ac5e7e4446016356e7930719e71d9" translate="yes" xml:space="preserve">
          <source>At this point you might be questioning how Hooks work. How can React know which &lt;code&gt;useState&lt;/code&gt; call corresponds to which state variable between re-renders? How does React &amp;ldquo;match up&amp;rdquo; previous and next effects on every update? &lt;strong&gt;On the next page we will learn about the &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt; &amp;mdash; they&amp;rsquo;re essential to making Hooks work.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e39c486abc649f7d406023b110351f1fdad529" translate="yes" xml:space="preserve">
          <source>Autobinding</source>
          <target state="translated">Autobinding</target>
        </trans-unit>
        <trans-unit id="7b94f520dbb3d9f5f6fda5d519ac3d2d646365b5" translate="yes" xml:space="preserve">
          <source>Automatic batching of multiple setStates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7991af76c55eda34a6c01f9d6c116afce98b121" translate="yes" xml:space="preserve">
          <source>Avoid Reconciliation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e69b1251a4645e4fe693144ad0d39b96d5a86e" translate="yes" xml:space="preserve">
          <source>Avoid introducing any side-effects or subscriptions in the constructor. For those use cases, use &lt;code&gt;componentDidMount()&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d24bc0df81c7d22eed18963eb1d9624a35b8cb7" translate="yes" xml:space="preserve">
          <source>Avoid introducing any side-effects or subscriptions in this method. For those use cases, use &lt;code&gt;componentDidMount()&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fca525db1716e6a4bcd310f1d426c924d3708ce" translate="yes" xml:space="preserve">
          <source>Avoid too much nesting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee809aaec4799cc78442a3c9e58c07254689d1a6" translate="yes" xml:space="preserve">
          <source>Avoid using refs for anything that can be done declaratively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="68719a521ce64ee99b472a32090730e97b03a0bd" translate="yes" xml:space="preserve">
          <source>Babel compiles JSX down to &lt;code&gt;React.createElement()&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="914c83643b2be4f506bd8959464e1bd675ef315d" translate="yes" xml:space="preserve">
          <source>Babel, JSX, and Build Steps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7b7da33082bcecbc995c1e674c7c8aa270d35b" translate="yes" xml:space="preserve">
          <source>Bailing out of a dispatch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135d9cb156a9487640dc85edc375539a96f482ba" translate="yes" xml:space="preserve">
          <source>Bailing out of a state update</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8fd52172de461f29c3a89d176e6d0e6ed5d6119" translate="yes" xml:space="preserve">
          <source>Baking Transitions Into the Design System</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0ce5afffc4308d702fd2d099aaafaa74b72325" translate="yes" xml:space="preserve">
          <source>Basic Hooks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99942a359054b0aad74f6a2e0e9656460e19cbb3" translate="yes" xml:space="preserve">
          <source>Basic List Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536f63c62210e606c0473c51969c2b54474aeeef" translate="yes" xml:space="preserve">
          <source>Be careful when using Render Props with React.PureComponent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952ce7ad0378eb55b86bd553bf802d759d4491d0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; may be updated asynchronously, you should not rely on their values for calculating the next state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0514856166ee495c557a4ac04e3b999ac49d2fcf" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;withSubscription&lt;/code&gt; is a normal function, you can add as many or as few arguments as you like. For example, you may want to make the name of the &lt;code&gt;data&lt;/code&gt; prop configurable, to further isolate the HOC from the wrapped component. Or you could accept an argument that configures &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, or one that configures the data source. These are all possible because the HOC has full control over how the component is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3fcd85e0dbb2ed68b4581e1ffe0327ac0f12f77" translate="yes" xml:space="preserve">
          <source>Because React relies on heuristics, if the assumptions behind them are not met, performance will suffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1695654a25412ec23a92b4da904f1d5da03ee426" translate="yes" xml:space="preserve">
          <source>Because context uses reference identity to determine when to re-render, there are some gotchas that could trigger unintentional renders in consumers when a provider&amp;rsquo;s parent re-renders. For example, the code below will re-render all consumers every time the Provider re-renders because a new object is always created for &lt;code&gt;value&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783b65ac0879142e03482c962fd5b17c0404d5e7" translate="yes" xml:space="preserve">
          <source>Because its value is read-only, it is an &lt;strong&gt;uncontrolled&lt;/strong&gt; component in React. It is discussed together with other uncontrolled components &lt;a href=&quot;uncontrolled-components#the-file-input-tag&quot;&gt;later in the documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6834a012393a7506dbe08e3c25a07f88133bd28e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;useState&lt;/code&gt; Hook call gives us the latest value of the &lt;code&gt;recipientID&lt;/code&gt; state variable, we can pass it to our custom &lt;code&gt;useFriendStatus&lt;/code&gt; Hook as an argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ff48f11dbd74f3d79aff032eb482ce7d1b7fe8" translate="yes" xml:space="preserve">
          <source>Because the above methods might be called more than once, it&amp;rsquo;s important that they do not contain side-effects. Ignoring this rule can lead to a variety of problems, including memory leaks and invalid application state. Unfortunately, it can be difficult to detect these problems as they can often be &lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;non-deterministic&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3571671a5e1639faebc1c823c32a5cadb3bcaafb" translate="yes" xml:space="preserve">
          <source>Before You Use Context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8cfd2c717528576c9d11598e3196f395280cbed" translate="yes" xml:space="preserve">
          <source>Before deploying your website to production, be mindful that unminified JavaScript can significantly slow down the page for your users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="040170e2405edee8c93a45941ebf02a1c10a5f1c" translate="yes" xml:space="preserve">
          <source>Before diving into the changes in the &lt;code&gt;Calculator&lt;/code&gt;, let&amp;rsquo;s recap our changes to the &lt;code&gt;TemperatureInput&lt;/code&gt; component. We have removed the local state from it, and instead of reading &lt;code&gt;this.state.temperature&lt;/code&gt;, we now read &lt;code&gt;this.props.temperature&lt;/code&gt;. Instead of calling &lt;code&gt;this.setState()&lt;/code&gt; when we want to make a change, we now call &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt;, which will be provided by the &lt;code&gt;Calculator&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf57eb0650f409bbc5c970415d2cfcbb8a2a10f" translate="yes" xml:space="preserve">
          <source>Before version control existed, the development workflow was very different. There was no concept of branches. If you wanted to edit some files, you had to tell everyone not to touch those files until you&amp;rsquo;ve finished your work. You couldn&amp;rsquo;t even start working on them concurrently with that person &amp;mdash; you were literally &lt;em&gt;blocked&lt;/em&gt; by them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a8dd8247a7da7ad888e1dbb5ad92ff53dcdd84" translate="yes" xml:space="preserve">
          <source>Before we continue, note that Hooks are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5c13cd58e6b7adc6f8db48c50ae3b58895a388" translate="yes" xml:space="preserve">
          <source>Before you build components with an API similar to this, consider if there are cleaner alternatives. For example, you can pass entire React components as props if you&amp;rsquo;d like to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a81ad8d9cf9cfee67865d8f6f11aeb7feedca5fd" translate="yes" xml:space="preserve">
          <source>Below, we loop through the &lt;code&gt;numbers&lt;/code&gt; array using the JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; function. We return a &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element for each item. Finally, we assign the resulting array of elements to &lt;code&gt;listItems&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600febdf3065222e268db7a6433b505e78f78df3" translate="yes" xml:space="preserve">
          <source>Below, we will create a Backbone view called &lt;code&gt;ParagraphView&lt;/code&gt;. It will override Backbone&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; function to render a React &lt;code&gt;&amp;lt;Paragraph&amp;gt;&lt;/code&gt; component into the DOM element provided by Backbone (&lt;code&gt;this.el&lt;/code&gt;). Here, too, we are using &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547e99fc0bf895cd16cd891408908780f2697664" translate="yes" xml:space="preserve">
          <source>Bind in Constructor (ES2015)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915ea487cc3b39a7adc8a9e625171040ae3bf235" translate="yes" xml:space="preserve">
          <source>Bind in Render</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e569b3d8c05d2c4868ac39c7f6ad05cecc38bc" translate="yes" xml:space="preserve">
          <source>Bind methods in the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd51dbb8bb35b2a59d6adbf6c050dc5843aa17f1" translate="yes" xml:space="preserve">
          <source>Binding &lt;a href=&quot;handling-events&quot;&gt;event handler&lt;/a&gt; methods to an instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31510573bcbe544079b9ddf410c0de8e9afe5ec8" translate="yes" xml:space="preserve">
          <source>Binding methods helps ensure that the second snippet works the same way as the first one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f2ebc2d6a92580d8b1336c1e75a33c854dce24" translate="yes" xml:space="preserve">
          <source>Blocking Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db618e237590bc242942196c81d7170abbb33772" translate="yes" xml:space="preserve">
          <source>Blocking Mode only contains a small subset of Concurrent Mode features and is intended as an intermediary migration step for apps that are unable to migrate directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed57d00f5e5dced888a9218f9ad79a68850bd18" translate="yes" xml:space="preserve">
          <source>Blocking vs Interruptible Rendering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593cf8333034572ec33f064b1bc2b4ffe160093e" translate="yes" xml:space="preserve">
          <source>Booleans, Null, and Undefined Are Ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70c82e35eccc055c5ed05e9e43b64b55ddaacea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; need data to render, so they suspend:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c3135a23f4c6c803e268b564382bb3f6d56077" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt; received by the updater function are guaranteed to be up-to-date. The output of the updater is shallowly merged with &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f8d1fc7b82e36a68e9d0047d23afa00eafc0ea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useReducer&lt;/code&gt; Hooks &lt;a href=&quot;hooks-reference#bailing-out-of-a-state-update&quot;&gt;bail out of updates&lt;/a&gt; if the next value is the same as the previous one. Mutating state in place and calling &lt;code&gt;setState&lt;/code&gt; will not cause a re-render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8363bce31adc44778f01714744541a7deed996" translate="yes" xml:space="preserve">
          <source>Both React and ReactDOM are available over a CDN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2330211501f9f5b88000d1ad778e502a3efda72f" translate="yes" xml:space="preserve">
          <source>Both putting all state in a single &lt;code&gt;useState&lt;/code&gt; call, and having a &lt;code&gt;useState&lt;/code&gt; call per each field can work. Components tend to be most readable when you find a balance between these two extremes, and group related state into a few independent state variables. If the state logic becomes complex, we recommend &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;managing it with a reducer&lt;/a&gt; or a custom Hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1266309444291ef2747fd8db6fb75c9fa22d40d" translate="yes" xml:space="preserve">
          <source>Both the aXe and WAVE tools mentioned below also include color contrast tests and will report on contrast errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29604ed4c392a3cd09654b8ef0d3dc61f5d45c88" translate="yes" xml:space="preserve">
          <source>Breaking changes are inconvenient for everyone, so we try to minimize the number of major releases &amp;ndash; for example, React 15 was released in April 2016 and React 16 was released in September 2017; React 17 isn&amp;rsquo;t expected until 2019.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a8c960030f2f9457b2f49cecd3b0e346163641" translate="yes" xml:space="preserve">
          <source>Browser Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed81754147c265a661af47b5f96c56bae653c0d7" translate="yes" xml:space="preserve">
          <source>Browserify</source>
          <target state="translated">Browserify</target>
        </trans-unit>
        <trans-unit id="2cd0b835cf9277cb4f1eeb472cef193a26204fa8" translate="yes" xml:space="preserve">
          <source>Brunch</source>
          <target state="translated">Brunch</target>
        </trans-unit>
        <trans-unit id="252a02556e2e6dfccb3d4546230735cc62300a37" translate="yes" xml:space="preserve">
          <source>Building Your Own Hooks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801624525b70cf0c1e363814c966a45e726332b7" translate="yes" xml:space="preserve">
          <source>Building your own Hooks lets you extract component logic into reusable functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b95c67ea8c62ea338acaa3ab52d037eed3d3d37" translate="yes" xml:space="preserve">
          <source>Bundlers</source>
          <target state="translated">Bundlers</target>
        </trans-unit>
        <trans-unit id="61c4e91324c0e358214e2aefb4dcb8f12b9c66b7" translate="yes" xml:space="preserve">
          <source>Bundlers take JavaScript and CSS code written as separate modules (often hundreds of them), and combine them together into a few files better optimized for the browsers. Some bundlers commonly used in React applications include &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="95bc601b586c2c7743bfe7dc0ae3037683e3f885" translate="yes" xml:space="preserve">
          <source>Bundling is great, but as your app grows, your bundle will grow too. Especially if you are including large third-party libraries. You need to keep an eye on the code you are including in your bundle so that you don&amp;rsquo;t accidentally make it so large that your app takes a long time to load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="340e52d34ce7741273105f426520d1a718cdd2d4" translate="yes" xml:space="preserve">
          <source>But before our screen can be Complete, we might need to load some data or code. When we&amp;rsquo;re on the next screen, but some parts of it are still loading, we call that a &lt;strong&gt;Skeleton&lt;/strong&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe393ab8011453c8fff65077d0e7c7a078bbbef6" translate="yes" xml:space="preserve">
          <source>But how do you know what should be its own component? Use the same techniques for deciding if you should create a new function or object. One such technique is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;single responsibility principle&lt;/a&gt;, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4002e235631449f2ad3ed8865ba272950edad071" translate="yes" xml:space="preserve">
          <source>But what is a Hook?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63aebb97dd257c4ba024f7f8d622fd2f3c2ead2" translate="yes" xml:space="preserve">
          <source>By adding &lt;code&gt;childContextTypes&lt;/code&gt; and &lt;code&gt;getChildContext&lt;/code&gt; to &lt;code&gt;MessageList&lt;/code&gt; (the context provider), React passes the information down automatically and any component in the subtree (in this case, &lt;code&gt;Button&lt;/code&gt;) can access it by defining &lt;code&gt;contextTypes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a38ad0a770cf395a928bd96b4b28770666edf3" translate="yes" xml:space="preserve">
          <source>By comparing these two elements, React knows to only modify the &lt;code&gt;className&lt;/code&gt; on the underlying DOM node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2a2d61ba0b6800612c77121ae46d0499703856" translate="yes" xml:space="preserve">
          <source>By default it will only shallowly compare complex objects in the props object. If you want control over the comparison, you can also provide a custom comparison function as the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1ac0f6c8b53390d8382186e5c3b232ba4fda16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;SuspenseList&lt;/code&gt; will show all fallbacks in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4153024f7b260481eccaf5b1c744b88ec28ecd31" translate="yes" xml:space="preserve">
          <source>By default, &lt;strong&gt;you may not use the &lt;code&gt;ref&lt;/code&gt; attribute on function components&lt;/strong&gt; because they don&amp;rsquo;t have instances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3928b9ef8d6d202d79b0190a10bc6653b909e33" translate="yes" xml:space="preserve">
          <source>By default, Flow only checks the files that include this annotation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5be072c86160481c917656cc53270b05bd27346" translate="yes" xml:space="preserve">
          <source>By default, React DOM &lt;a href=&quot;https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html&quot;&gt;escapes&lt;/a&gt; any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that&amp;rsquo;s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS (cross-site-scripting)&lt;/a&gt; attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e2022d31bee1bdbaf6abdb0b23ef50d12acc56" translate="yes" xml:space="preserve">
          <source>By default, React always renders a consistent UI. Consider code like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449fb3e80b766c4a1a364e3d0dfbcf560387a6b4" translate="yes" xml:space="preserve">
          <source>By default, React includes many helpful warnings. These warnings are very useful in development. However, they make React larger and slower so you should make sure to use the production version when you deploy the app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48bb58e45e1f538d4137553558f70ce76bbfed18" translate="yes" xml:space="preserve">
          <source>By default, effects run after every completed render, but you can choose to fire them &lt;a href=&quot;#conditionally-firing-an-effect&quot;&gt;only when certain values have changed&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c423b89d02a892510754488b2f34e98c538c1e8d" translate="yes" xml:space="preserve">
          <source>By default, our loading sequence is Receded &amp;rarr; Skeleton &amp;rarr; Complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b45cc73c2029a9cd6bb59406302967cf1876ef" translate="yes" xml:space="preserve">
          <source>By default, when recursing on the children of a DOM node, React just iterates over both lists of children at the same time and generates a mutation whenever there&amp;rsquo;s a difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7254bbb62790d0326da6f1e08d05223e3e28bcd4" translate="yes" xml:space="preserve">
          <source>By default, when your component&amp;rsquo;s state or props change, your component will re-render. If your &lt;code&gt;render()&lt;/code&gt; method depends on some other data, you can tell React that the component needs re-rendering by calling &lt;code&gt;forceUpdate()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbabc1da5915813efd358a159900222057c873db" translate="yes" xml:space="preserve">
          <source>By far the easiest and also one of the most important checks is to test if your entire website can be reached and used with the keyboard alone. Do this by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a10d22e535e79dc550a3e6a110a7d6e3d60d34" translate="yes" xml:space="preserve">
          <source>By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3501f060fe67386a08f58c0aa7df54c202ed340f" translate="yes" xml:space="preserve">
          <source>By intentionally double-invoking methods like the component constructor, strict mode makes patterns like this easier to spot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70659365a618fa5e538cab7a7ed3a779ea0f2ed" translate="yes" xml:space="preserve">
          <source>By now we have discussed all of the different visual states that an update may go through. In this section, we will give them names and talk about the progression between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8849355bd377f311a68b820b724041ac13174588" translate="yes" xml:space="preserve">
          <source>By passing down some information from the &lt;code&gt;Router&lt;/code&gt; component, each &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Route&lt;/code&gt; can communicate back to the containing &lt;code&gt;Router&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6543d3a2a9fdfe69d3907c809e5fe72730cb6152" translate="yes" xml:space="preserve">
          <source>By publishing prereleases to the same registry that we use for stable releases, we are able to take advantage of the many tools that support the npm workflow, like &lt;a href=&quot;https://unpkg.com&quot;&gt;unpkg&lt;/a&gt; and &lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b9c90ff13fa64fdfb73b185d7c4f7467924e61" translate="yes" xml:space="preserve">
          <source>By the end of this page, you should have a rough idea of what problems Hooks are solving, but many details are probably unclear. Don&amp;rsquo;t worry! &lt;strong&gt;Let&amp;rsquo;s now go to &lt;a href=&quot;hooks-overview&quot;&gt;the next page&lt;/a&gt; where we start learning about Hooks by example.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b6c4b8addee6f0bec9b64fdc066f75fd594e81" translate="yes" xml:space="preserve">
          <source>CDN</source>
          <target state="translated">CDN</target>
        </trans-unit>
        <trans-unit id="0cb89bdc76c5795134a2459b160420669da6ffee" translate="yes" xml:space="preserve">
          <source>CDN Links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473aefd14700a14991eab282d99beba7a986855b" translate="yes" xml:space="preserve">
          <source>CDN stands for Content Delivery Network. CDNs deliver cached, static content from a network of servers across the globe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7025e6eaddc16640f999ef6fa8996ea4bc1f03fd" translate="yes" xml:space="preserve">
          <source>CSS classes are generally better for performance than inline styles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f08332dc09d930e7bbd5e60a0ce85c9b8c230b52" translate="yes" xml:space="preserve">
          <source>Callback Refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f561c648f624045fd004dc5b4b78923e5e8ddc" translate="yes" xml:space="preserve">
          <source>Callback refs will continue to be supported in addition to the new &lt;code&gt;createRef&lt;/code&gt; API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b324bae986165b1cd5e20961c947433abdcaa8" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;forceUpdate()&lt;/code&gt; will cause &lt;code&gt;render()&lt;/code&gt; to be called on the component, skipping &lt;code&gt;shouldComponentUpdate()&lt;/code&gt;. This will trigger the normal lifecycle methods for child components, including the &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; method of each child. React will still only update the DOM if the markup changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2d5d9b462bef88cc3e6ecec70f1f6eb5fdac81" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;setState&lt;/code&gt; are asynchronous - don&amp;rsquo;t rely on &lt;code&gt;this.state&lt;/code&gt; to reflect the new value immediately after calling &lt;code&gt;setState&lt;/code&gt;. Pass an updater function instead of an object if you need to compute values based on the current state (see below for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41d5ffe9daa0185ffc53035fc127e196975da11" translate="yes" xml:space="preserve">
          <source>Calls to Hooks are either inside a &lt;code&gt;PascalCase&lt;/code&gt; function (assumed to be a component) or another &lt;code&gt;useSomething&lt;/code&gt; function (assumed to be a custom Hook).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0fb965bf90315219e83def6638a42c25d67bb9" translate="yes" xml:space="preserve">
          <source>Can I do animations in React?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592eed8e66509a1a99a368df6d3300451076b895" translate="yes" xml:space="preserve">
          <source>Can I make a ref to a function component?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a0edbd02b3f7f4f83753bc16933ee61ae6323d" translate="yes" xml:space="preserve">
          <source>Can I run an effect only on updates?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa41f6b0727bc187c1b93b3700c7aa5f30c011d" translate="yes" xml:space="preserve">
          <source>Can I skip an effect on updates?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7c8e9b874b8d15ca221b52d750e20fac44ca71" translate="yes" xml:space="preserve">
          <source>Can I use inline styles?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc1494bdebde800b93a7e1e6398d587710939fe" translate="yes" xml:space="preserve">
          <source>Can Proxies help express lazy-loaded APIs without inserting &lt;code&gt;read()&lt;/code&gt; calls everywhere?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d5be07f96ef2179314db3e0573821bfd2d2fa9" translate="yes" xml:space="preserve">
          <source>Can you compute it based on any other state or props in your component? If so, it isn&amp;rsquo;t state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4cfac05bf4b7fb87c23c141fcc58c48668bb07b" translate="yes" xml:space="preserve">
          <source>Capitalized types indicate that the JSX tag is referring to a React component. These tags get compiled into a direct reference to the named variable, so if you use the JSX &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; expression, &lt;code&gt;Foo&lt;/code&gt; must be in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3e2f961f45bb1a06529f15bbd3ad553ff58fba" translate="yes" xml:space="preserve">
          <source>Catching an event bubbling up from a portal in a parent component allows the development of more flexible abstractions that are not inherently reliant on portals. For example, if you render a &lt;code&gt;&amp;lt;Modal /&amp;gt;&lt;/code&gt; component, the parent can capture its events regardless of whether it&amp;rsquo;s implemented using portals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b399bd413c8dfe8688f37d0df1a1c1d399fe2a" translate="yes" xml:space="preserve">
          <source>Caution:</source>
          <target state="translated">Caution:</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="c31196d8e650a9b9fc79de9f3fa43c1c31cecaf3" translate="yes" xml:space="preserve">
          <source>Caveats with callback refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5097b05dacd2aac1b01af27496feca5ace3900" translate="yes" xml:space="preserve">
          <source>Changes are determined by comparing the new and old values using the same algorithm as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948a11fe049667413c1ebccf85193e5ad0c865a0" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;https://codepen.io/gaearon/pen/wqvxGa?editors=0010&quot;&gt;this example of declaring and using an error boundary&lt;/a&gt; with &lt;a href=&quot;https://reactjs.org/blog/2017/09/26/react-v16.0.html&quot;&gt;React 16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514d3cf1f7b7bd35468b03e35f683e983fece33f" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;this small demo&lt;/a&gt; and &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; to learn more about data fetching with Hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb20a1f16d9d9e886462739015ded52cceb62c1" translate="yes" xml:space="preserve">
          <source>Check out the next sections for more tips on integrating React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c356556be82839c784cc294b64ca1776f78a50" translate="yes" xml:space="preserve">
          <source>Checklist from The A11Y Project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788ea0524b831f8a725084df293beea295bdc0cb" translate="yes" xml:space="preserve">
          <source>Children in JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7833c9a80ea34dfa62e1fc00ddfe3ca1f24f8846" translate="yes" xml:space="preserve">
          <source>Children passed to a custom component can be anything, as long as that component transforms them into something React can understand before rendering. This usage is not common, but it works if you want to stretch what JSX is capable of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524053a45c83a82145b2826ea841021f62f2eca9" translate="yes" xml:space="preserve">
          <source>Choosing the Type at Runtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed520503e6b810c6b447d0d61fb33cc587bd886" translate="yes" xml:space="preserve">
          <source>Chosen&amp;rsquo;s documentation suggests that we can use jQuery &lt;code&gt;trigger()&lt;/code&gt; API to notify it about changes to the original DOM element. We will let React take care of updating &lt;code&gt;this.props.children&lt;/code&gt; inside &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;, but we will also add a &lt;code&gt;componentDidUpdate()&lt;/code&gt; lifecycle method that notifies Chosen about changes in the children list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da54e825685d4347402587467044fe401034bb0" translate="yes" xml:space="preserve">
          <source>Chrome Browser Extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e721a027f935b8971974b1c6919474075787ba" translate="yes" xml:space="preserve">
          <source>ChromeVox Classic Keyboard Shortcuts Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2ef5e0cd8877a9fd5fb814d30d6b360f56b5ce" translate="yes" xml:space="preserve">
          <source>ChromeVox in Google Chrome</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce80736a23f07ec5379dd12c4e62a76fe4c9654" translate="yes" xml:space="preserve">
          <source>Class Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e056366f04de2cab39d2cee2ccd99cf321dc0d1" translate="yes" xml:space="preserve">
          <source>Class Properties (Stage 3 Proposal)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26feb612e21f929366469e12ea57924bf0e68946" translate="yes" xml:space="preserve">
          <source>Class component &lt;code&gt;constructor&lt;/code&gt; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35adea707ef390317beb571e365f0c45b1558a38" translate="yes" xml:space="preserve">
          <source>Class components should always call the base constructor with &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf28dbaca27f177b67bd4d8c242c6ba8196c774" translate="yes" xml:space="preserve">
          <source>Class.contextType</source>
          <target state="translated">Class.contextType</target>
        </trans-unit>
        <trans-unit id="317a231b0609e8171e8ccd831d16d1f01d3e282b" translate="yes" xml:space="preserve">
          <source>Classes confuse both people and machines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df956550f910b614ba52561dd8a120763eead57" translate="yes" xml:space="preserve">
          <source>Classes have some additional features that we will discuss in the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next sections&lt;/a&gt;. Until then, we will use function components for their conciseness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3dd60e3aff73678cd482872275e8a9396606b21" translate="yes" xml:space="preserve">
          <source>Cleaning up an effect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4758520a494d2064d93ffa9165dd034d4d6fdc" translate="yes" xml:space="preserve">
          <source>Clearly, both &amp;ldquo;versions&amp;rdquo; of &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; exist at the same time. We know the old one exists because we see it on the screen and even display a progress indicator on it. And we know the new version also exists &lt;em&gt;somewhere&lt;/em&gt;, because it&amp;rsquo;s the one that we&amp;rsquo;re waiting for!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da2856d241d6b8e03d34e8bd789ba5cc2d485c8" translate="yes" xml:space="preserve">
          <source>Click the link above to open an online editor. Feel free to make some changes, and see how they affect the output. Most pages in this guide will have editable examples like this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b365b3f0f1a9ce1f1f16399418c096e7b8a503bc" translate="yes" xml:space="preserve">
          <source>Clipboard Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b54baa5ba7bdc6fb8f058345854fc083692bdf" translate="yes" xml:space="preserve">
          <source>Clone and return a new React element using &lt;code&gt;element&lt;/code&gt; as the starting point. The resulting element will have the original element&amp;rsquo;s props with the new props merged in shallowly. New children will replace existing children. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; from the original element will be preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a989ae1369e4b664454339de990449f6d5be39" translate="yes" xml:space="preserve">
          <source>Code Splitting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452894bc81807d851d45c6cab4b7a49a9952b836" translate="yes" xml:space="preserve">
          <source>Code written with &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt; will be converted to use &lt;code&gt;React.createElement()&lt;/code&gt;. You will not typically invoke &lt;code&gt;React.createElement()&lt;/code&gt; directly if you are using JSX. See &lt;a href=&quot;react-without-jsx&quot;&gt;React Without JSX&lt;/a&gt; to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d830d4bd5b85e6cbc7cadd95b182af8a0782d0" translate="yes" xml:space="preserve">
          <source>Code-Splitting</source>
          <target state="translated">Code-Splitting</target>
        </trans-unit>
        <trans-unit id="4288c2984091655ae5fc926db1f916d24686a3fd" translate="yes" xml:space="preserve">
          <source>Code-splitting your app can help you &amp;ldquo;lazy-load&amp;rdquo; just the things that are currently needed by the user, which can dramatically improve the performance of your app. While you haven&amp;rsquo;t reduced the overall amount of code in your app, you&amp;rsquo;ve avoided loading code that the user may never need, and reduced the amount of code needed during the initial load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6a4ad5c28d4237a3c9fce8881b1854847ef4dd" translate="yes" xml:space="preserve">
          <source>Color contrast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccdabf4161bdc7de274f4b5b5280d0885aab475f" translate="yes" xml:space="preserve">
          <source>Commitment to Stability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445032c4df4e7271e1f347bbc2ba4f9b91fac35c" translate="yes" xml:space="preserve">
          <source>Common testing patterns for React components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba992810876b27f169da76d8892757d1ac6c389" translate="yes" xml:space="preserve">
          <source>Commonly Used Lifecycle Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47ab08f55f92afe16678b0d26789b0f9db88a542" translate="yes" xml:space="preserve">
          <source>Commonly Used Screen Readers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab67e4584d46107bd80ff84184a6ba14b35583dc" translate="yes" xml:space="preserve">
          <source>Commonly, you might want to display React components in multiple places on the HTML page. Here is an example that displays the &amp;ldquo;Like&amp;rdquo; button three times and passes some data to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1db7f0906384a202b07a0ed5f149a2ff7cd64627" translate="yes" xml:space="preserve">
          <source>Commonly, you might want to test whether a component renders correctly for given props. Consider a simple component that renders a message based on a prop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1be83a7756a5bb6c9b11d838efbdc2b010f2edd" translate="yes" xml:space="preserve">
          <source>Compilers</source>
          <target state="translated">Compilers</target>
        </trans-unit>
        <trans-unit id="ecb8003c55e2a97e8832e9daab973ed2bb0b4c30" translate="yes" xml:space="preserve">
          <source>Complex components become hard to understand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0667e102ccc5eb4b77124d0b6e69cb444fd7d8a" translate="yes" xml:space="preserve">
          <source>Component Elements Of The Same Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c982cf9a76b7b4a01c2933400406bc78bbefad7" translate="yes" xml:space="preserve">
          <source>Component Stack Traces</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9dab4c62b723eaa7141297314b9677796ffeea" translate="yes" xml:space="preserve">
          <source>Component State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d8963e298236728ce3600faad72c67a3779b02" translate="yes" xml:space="preserve">
          <source>Component names displayed in the stack traces depend on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name&quot;&gt;&lt;code&gt;Function.name&lt;/code&gt;&lt;/a&gt; property. If you support older browsers and devices which may not yet provide this natively (e.g. IE 11), consider including a &lt;code&gt;Function.name&lt;/code&gt; polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/JamesMGreene/Function.name&quot;&gt;&lt;code&gt;function.name-polyfill&lt;/code&gt;&lt;/a&gt;. Alternatively, you may explicitly set the &lt;a href=&quot;react-component#displayname&quot;&gt;&lt;code&gt;displayName&lt;/code&gt;&lt;/a&gt; property on all your components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="5b900f3314804ddfe0c68be1b21bafcf15049dec" translate="yes" xml:space="preserve">
          <source>Components and Props</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea42a84e60a676f2853bf66aa9e71316099a0d2d" translate="yes" xml:space="preserve">
          <source>Components are the primary unit of code reuse in React, but it&amp;rsquo;s not always obvious how to share the state or behavior that one component encapsulates to other components that need that same state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf21630472b655008598f546f0ae8540e9eb363" translate="yes" xml:space="preserve">
          <source>Components are the primary unit of code reuse in React. However, you&amp;rsquo;ll find that some patterns aren&amp;rsquo;t a straightforward fit for traditional components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9eda6a288584eb3b7660e0273162ffe2fbd651" translate="yes" xml:space="preserve">
          <source>Components can also be ES6 classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b98ff4285b5af72ab07a10e59ca94da7eccff155" translate="yes" xml:space="preserve">
          <source>Components can be broken down into distinct pieces of functionality and used within other components. Components can return other components, arrays, strings and numbers. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be a reusable component. Component names should also always start with a capital letter (&lt;code&gt;&amp;lt;Wrapper/&amp;gt;&lt;/code&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;&amp;lt;wrapper/&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;components-and-props#rendering-a-component&quot;&gt;this documentation&lt;/a&gt; for more information on rendering components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8ce35b76721e042b6254071ed1780b1b067f70" translate="yes" xml:space="preserve">
          <source>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9548fb4b1e7326eeb04d1fb7f4871d039f635a4f" translate="yes" xml:space="preserve">
          <source>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. This page provides an introduction to the idea of components. You can find a &lt;a href=&quot;react-component&quot;&gt;detailed component API reference here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="003062ae0cc8b0b04c1a544a38c743d90aa46c94" translate="yes" xml:space="preserve">
          <source>Components might be using time-based functions like &lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, or &lt;code&gt;Date.now&lt;/code&gt;. In testing environments, it can be helpful to mock these functions out with replacements that let you manually &amp;ldquo;advance&amp;rdquo; time. This is great for making sure your tests run fast! Tests that are dependent on timers would still resolve in order, but quicker &lt;a href=&quot;testing-recipes#timers&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;. Most frameworks, including &lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;Jest&lt;/a&gt;, &lt;a href=&quot;https://sinonjs.org/releases/v7.3.2/fake-timers/&quot;&gt;sinon&lt;/a&gt; and &lt;a href=&quot;https://github.com/sinonjs/lolex&quot;&gt;lolex&lt;/a&gt;, let you mock timers in your tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5bd7c2e2f2da7429280ddf7205af915e3844671" translate="yes" xml:space="preserve">
          <source>Components responsible for rendering models would listen to &lt;code&gt;'change'&lt;/code&gt; events, while components responsible for rendering collections would listen for &lt;code&gt;'add'&lt;/code&gt; and &lt;code&gt;'remove'&lt;/code&gt; events. In both cases, call &lt;a href=&quot;react-component#forceupdate&quot;&gt;&lt;code&gt;this.forceUpdate()&lt;/code&gt;&lt;/a&gt; to rerender the component with the new data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701adbc3566e773a7ef736ead752213877c9e24a" translate="yes" xml:space="preserve">
          <source>Composing Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6e1b699d64dbae00096ea5053b1e52924dbf2a" translate="yes" xml:space="preserve">
          <source>Composition Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3bb3f5861eb173e759c1e484131da5669201dc" translate="yes" xml:space="preserve">
          <source>Composition vs Inheritance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b341fa71196d99f719bfddbccd90c93c12138eb" translate="yes" xml:space="preserve">
          <source>Composition works equally well for components defined as classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaea795653ffb1f62d576e1558d5bec326d7d883" translate="yes" xml:space="preserve">
          <source>Conceptually, React does work in two phases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6f098afd8b98b26fd7a56a1017d47f83ce5847" translate="yes" xml:space="preserve">
          <source>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called &amp;ldquo;props&amp;rdquo;) and return React elements describing what should appear on the screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1694788f449187fffb09e184087fbad62e9f353" translate="yes" xml:space="preserve">
          <source>Conceptually, you can think of refs as similar to instance variables in a class. Unless you&amp;rsquo;re doing &lt;a href=&quot;#how-to-create-expensive-objects-lazily&quot;&gt;lazy initialization&lt;/a&gt;, avoid setting refs during rendering &amp;mdash; this can lead to surprising behavior. Instead, typically you want to modify refs in event handlers and effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57505dca41b5f346bafb38cef7d36319b3ff259" translate="yes" xml:space="preserve">
          <source>Conceptually, you can think of this as React preparing every update &amp;ldquo;on a branch&amp;rdquo;. Just like you can abandon work in branches or switch between them, React in Concurrent Mode can interrupt an ongoing update to do something more important, and then come back to what it was doing earlier. This technique might also remind you of &lt;a href=&quot;https://wiki.osdev.org/Double_Buffering&quot;&gt;double buffering&lt;/a&gt; in video games.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22fda27ebc954f7f4402caca1cf5289d586e251" translate="yes" xml:space="preserve">
          <source>Concretely, &lt;strong&gt;a higher-order component is a function that takes a component and returns a new component.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec390bfae82ff5b921e55c4ae832ef41eb12f05" translate="yes" xml:space="preserve">
          <source>Concurrency</source>
          <target state="translated">Concurrency</target>
        </trans-unit>
        <trans-unit id="ca01db7215deb4076fca62d84daf3eae9616a7af" translate="yes" xml:space="preserve">
          <source>Concurrent Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b96093c95b817298d9cb20e5b0bce04174743e2" translate="yes" xml:space="preserve">
          <source>Concurrent Mode (Experimental)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4081b3599040f8aaebf073472ee211558b7387b" translate="yes" xml:space="preserve">
          <source>Concurrent Mode API Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878fcbe7d5ea50af7b133ed62070a99136683731" translate="yes" xml:space="preserve">
          <source>Concurrent Mode API Reference (Experimental)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edae5795f747881fc262da51c417bf58f166fd1" translate="yes" xml:space="preserve">
          <source>Concurrent Mode APIs such as &lt;code&gt;createRoot&lt;/code&gt; only exist in the experimental builds of React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ab22e83b598a8ed18897acc3509011b895edf9" translate="yes" xml:space="preserve">
          <source>Concurrent Mode is a set of new features that help React apps stay responsive and gracefully adjust to the user&amp;rsquo;s device capabilities and network speed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742bebde7560a77faee1a9bd110debab7248dcca" translate="yes" xml:space="preserve">
          <source>Concurrent Mode is different. It introduces semantic changes to how React works. Otherwise, the &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;new features&lt;/a&gt; enabled by it &lt;em&gt;wouldn&amp;rsquo;t be possible&lt;/em&gt;. This is why they&amp;rsquo;re grouped into a new &amp;ldquo;mode&amp;rdquo; rather than released one by one in isolation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c585cad9f5f72f26033dfd27b6afae87de9fa710" translate="yes" xml:space="preserve">
          <source>Concurrent Mode is only available in the &lt;a href=&quot;https://reactjs.org/blog/2019/10/22/react-release-channels.html#experimental-channel&quot;&gt;experimental builds&lt;/a&gt; of React. To install them, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c377403fcf4a1e570b1ab1632cc59da79933283" translate="yes" xml:space="preserve">
          <source>Concurrent Mode offers a powerful UI programming model and a set of new composable primitives to help you orchestrate delightful user experiences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac41fa82ad1eaecb7d0f14d53085140b1d9b1bb" translate="yes" xml:space="preserve">
          <source>Concurrent Mode techniques reduce the need for debouncing and throttling in UI. Because rendering is interruptible, React doesn&amp;rsquo;t need to artificially &lt;em&gt;delay&lt;/em&gt; work to avoid stutter. It can start rendering right away, but interrupt this work when needed to keep the app responsive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53417584d59bf95fc7febd4b8d8f415dca7cce44" translate="yes" xml:space="preserve">
          <source>Concurrent UI Patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d4fdda5f562ed8698f706655ed62e3ce272950" translate="yes" xml:space="preserve">
          <source>Concurrent UI Patterns (Experimental)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9a4bba446372af01e0eb85f26e0ec3d5f7469e" translate="yes" xml:space="preserve">
          <source>Conditional Rendering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84a8b581ff1d2c10bdf276f2b7406dcdfbe471a" translate="yes" xml:space="preserve">
          <source>Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator&quot;&gt;conditional operator&lt;/a&gt; to create elements representing the current state, and let React update the UI to match them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199403f202001274d577cd822710fe3cc32c4b8a" translate="yes" xml:space="preserve">
          <source>Conditionally applying &lt;code&gt;React.forwardRef&lt;/code&gt; when it exists is also not recommended for the same reasons: it changes how your library behaves and can break your users&amp;rsquo; apps when they upgrade React itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48508561fdd435136ec1d37487fd8f61312286d4" translate="yes" xml:space="preserve">
          <source>Conditionally firing an effect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae13d3daebd49b458224df13eda9d0943a64d8b" translate="yes" xml:space="preserve">
          <source>Configure the TypeScript compiler options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504272518eee464b9351a8f9dfa5318f53b167f7" translate="yes" xml:space="preserve">
          <source>Configuring the TypeScript Compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0cd36dad9889e7827176814d13b8658d3652a6" translate="yes" xml:space="preserve">
          <source>Congrats! You&amp;rsquo;ve installed the latest version of TypeScript into your project. Installing TypeScript gives us access to the &lt;code&gt;tsc&lt;/code&gt; command. Before configuration, let&amp;rsquo;s add &lt;code&gt;tsc&lt;/code&gt; to the &amp;ldquo;scripts&amp;rdquo; section in our &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc73f73a6669c50d8572f5f02e2446e75c6d9af5" translate="yes" xml:space="preserve">
          <source>Congratulations! This was a long page, but hopefully by the end most of your questions about effects were answered. You&amp;rsquo;ve learned both the State Hook and the Effect Hook, and there is a &lt;em&gt;lot&lt;/em&gt; you can do with both of them combined. They cover most of the use cases for classes &amp;mdash; and where they don&amp;rsquo;t, you might find the &lt;a href=&quot;hooks-reference&quot;&gt;additional Hooks&lt;/a&gt; helpful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d9a753b489028ce282c353568f3094da12baff" translate="yes" xml:space="preserve">
          <source>Congratulations! You just added a &lt;strong&gt;production-ready JSX setup&lt;/strong&gt; to your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220d6f56856674c1b7704909679e2651f54143de" translate="yes" xml:space="preserve">
          <source>Consider a &lt;code&gt;Contact&lt;/code&gt; component that embeds a third-party &lt;code&gt;GoogleMap&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed702f8a4cb8d8616a59f948b0139cdd0797b5f" translate="yes" xml:space="preserve">
          <source>Consider a &lt;code&gt;FancyButton&lt;/code&gt; component that renders the native &lt;code&gt;button&lt;/code&gt; DOM element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad84e0a45cb8ebe1269d7786a21f6a962f13e1ac" translate="yes" xml:space="preserve">
          <source>Consider a filterable product list. Have you ever typed into a list filter and felt that it stutters on every key press? Some of the work to update the product list might be unavoidable, such as creating new DOM nodes or the browser performing layout. However, &lt;em&gt;when&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; we perform that work plays a big role.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7ff8a56cce6aaa1998237c428102a30a0e6d16" translate="yes" xml:space="preserve">
          <source>Consider the ticking clock example from &lt;a href=&quot;rendering-elements#updating-the-rendered-element&quot;&gt;one of the previous sections&lt;/a&gt;. In &lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;Rendering Elements&lt;/a&gt;, we have only learned one way to update the UI. We call &lt;code&gt;ReactDOM.render()&lt;/code&gt; to change the rendered output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9fe294908a1f3d183b9663d08d2005bf90c1cd" translate="yes" xml:space="preserve">
          <source>Consider these &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926638824610c5e33a93e368f63b4675cf27e758" translate="yes" xml:space="preserve">
          <source>Consider these two components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e524f8ce0b534b04dc257b42d4b2e50934d485b" translate="yes" xml:space="preserve">
          <source>Consider these two new components representing Logout and Login buttons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565e25b1be863570aa48357d4e37a3cb9b1014a4" translate="yes" xml:space="preserve">
          <source>Consider this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b2068f767223efe926590be9badd2493687a5a" translate="yes" xml:space="preserve">
          <source>Consider this ticking clock example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3372e992297117ea2f39b7ce44914f204c2e54" translate="yes" xml:space="preserve">
          <source>Consider this variable declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddeae47880c23e5adfbcbcbdba23da6d1e1666cb" translate="yes" xml:space="preserve">
          <source>Constructor is the only place where you should assign &lt;code&gt;this.state&lt;/code&gt; directly. In all other methods, you need to use &lt;code&gt;this.setState()&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e06f3595df6e25bc9e778e558d8c46f700f16ccd" translate="yes" xml:space="preserve">
          <source>Consuming Multiple Contexts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4378934eb83df73dbc84b219479fa9e29d94690f" translate="yes" xml:space="preserve">
          <source>Containment</source>
          <target state="translated">Containment</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="e17a7e250baad687ac6e52558b3e61ed3c83723c" translate="yes" xml:space="preserve">
          <source>Context can also let you build an API where parents and children communicate. For example, one library that works this way is &lt;a href=&quot;https://reacttraining.com/react-router&quot;&gt;React Router V4&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ca1e00af75ef3a845f699d61f100ec13a84366" translate="yes" xml:space="preserve">
          <source>Context is designed to share data that can be considered &amp;ldquo;global&amp;rdquo; for a tree of React components, such as the current authenticated user, theme, or preferred language. For example, in the code below we manually thread through a &amp;ldquo;theme&amp;rdquo; prop in order to style the Button component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21071418c4fc7c14e094a551aed1dea86ba6cb7" translate="yes" xml:space="preserve">
          <source>Context is primarily used when some data needs to be accessible by &lt;em&gt;many&lt;/em&gt; components at different nesting levels. Apply it sparingly because it makes component reuse more difficult.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1117c27d0f8aaf201a96126a238a39ef170325f0" translate="yes" xml:space="preserve">
          <source>Context object accepts a &lt;code&gt;displayName&lt;/code&gt; string property. React DevTools uses this string to determine what to display for the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a9e57ea34d268d9527e923e5e2b6dee640de64" translate="yes" xml:space="preserve">
          <source>Context provides a way to pass data through the component tree without having to pass props down manually at every level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139697d486fc71e559fa9593fcefa43c9121c6a1" translate="yes" xml:space="preserve">
          <source>Context.Consumer</source>
          <target state="translated">Context.Consumer</target>
        </trans-unit>
        <trans-unit id="c6c4c029104cc05bbdc71541dd9edcaca30bed6f" translate="yes" xml:space="preserve">
          <source>Context.Provider</source>
          <target state="translated">Context.Provider</target>
        </trans-unit>
        <trans-unit id="4e4bac3657dd000930aa8125059a7cbf3e87d121" translate="yes" xml:space="preserve">
          <source>Context.displayName</source>
          <target state="translated">Context.displayName</target>
        </trans-unit>
        <trans-unit id="dface495c8ecca08b41dfd753afcb70644dfe335" translate="yes" xml:space="preserve">
          <source>Controlled Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4cfe4d40b8af3759ad07934d0e0feb2d6452f32" translate="yes" xml:space="preserve">
          <source>Controlled Input Null Value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4872f4ca134b21b78a1039f88f5f5646a7140446" translate="yes" xml:space="preserve">
          <source>Controlled vs. Uncontrolled Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62399a9d6e56980ca713041c283d89bfe9a83db7" translate="yes" xml:space="preserve">
          <source>Conveniently, &lt;code&gt;useMemo&lt;/code&gt; also lets you skip an expensive re-render of a child:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e33dd502823238199f7e3a997f49b17dab06cb9" translate="yes" xml:space="preserve">
          <source>Convention: Maximizing Composability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfcb9e71a4081a5cff37e37aed3a64842b154ee2" translate="yes" xml:space="preserve">
          <source>Convention: Pass Unrelated Props Through to the Wrapped Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841ebb2907df3a45769552f67c617a219b677a7d" translate="yes" xml:space="preserve">
          <source>Convention: Wrap the Display Name for Easy Debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0869a72ac23582f5ce01a5b79d647020a1817b5f" translate="yes" xml:space="preserve">
          <source>Conversely, if you want a value like &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; to appear in the output, you have to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion&quot;&gt;convert it to a string&lt;/a&gt; first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2250c6dfbb932a62df15caf0ed27800db97ccebc" translate="yes" xml:space="preserve">
          <source>Converting a Function to a Class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c37808516fd7d3f500437fa5c7a806dd41a7d4" translate="yes" xml:space="preserve">
          <source>Cool, so we&amp;rsquo;ve decided that our state lives in &lt;code&gt;FilterableProductTable&lt;/code&gt;. First, add an instance property &lt;code&gt;this.state = {filterText: '', inStockOnly: false}&lt;/code&gt; to &lt;code&gt;FilterableProductTable&lt;/code&gt;&amp;rsquo;s &lt;code&gt;constructor&lt;/code&gt; to reflect the initial state of your application. Then, pass &lt;code&gt;filterText&lt;/code&gt; and &lt;code&gt;inStockOnly&lt;/code&gt; to &lt;code&gt;ProductTable&lt;/code&gt; and &lt;code&gt;SearchBar&lt;/code&gt; as a prop. Finally, use these props to filter the rows in &lt;code&gt;ProductTable&lt;/code&gt; and set the values of the form fields in &lt;code&gt;SearchBar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2118ffbd3d6a89bb3b29c916ac2cbe2fe26af7c9" translate="yes" xml:space="preserve">
          <source>Cooperative Multitasking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d8b1686c9450f38df6ec567189c88fa8e65f62" translate="yes" xml:space="preserve">
          <source>Create React App</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c024f9a49db2f62e45ea51a2a8667dbe0d51bef4" translate="yes" xml:space="preserve">
          <source>Create React App doesn&amp;rsquo;t handle backend logic or databases; it just creates a frontend build pipeline, so you can use it with any backend you want. Under the hood, it uses &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;, but you don&amp;rsquo;t need to know anything about them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d73eab1062bc3b789613ff260ffbb6f0e6f0c2" translate="yes" xml:space="preserve">
          <source>Create React App supports TypeScript out of the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588a6c3de29f085354e63ba8a8734778892f1b67" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;TestRenderer&lt;/code&gt; instance with the passed React element. It doesn&amp;rsquo;t use the real DOM, but it still fully renders the component tree into memory so you can make assertions about it. Returns a &lt;a href=&quot;#testrenderer-instance&quot;&gt;TestRenderer instance&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c411124515381d7ff723f5204c8cfba7c7ccb7" translate="yes" xml:space="preserve">
          <source>Create a New React App</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daa02edf781723c84899e7b1361e0026d75adaf" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;like_button.js&lt;/code&gt; next to your HTML page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318a0c4ebb95d0a043c4e3bf1428eba585376291" translate="yes" xml:space="preserve">
          <source>Create a folder called &lt;code&gt;src&lt;/code&gt; and run this terminal command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af66300c87946b474f051e5d7eff067c9d2b871d" translate="yes" xml:space="preserve">
          <source>Create an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 class&lt;/a&gt;, with the same name, that extends &lt;code&gt;React.Component&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23818a295d7f6c07e63b708758b36fa1190384fe" translate="yes" xml:space="preserve">
          <source>Create and return a new &lt;a href=&quot;rendering-elements&quot;&gt;React element&lt;/a&gt; of the given type. The type argument can be either a tag name string (such as &lt;code&gt;'div'&lt;/code&gt; or &lt;code&gt;'span'&lt;/code&gt;), a &lt;a href=&quot;components-and-props&quot;&gt;React component&lt;/a&gt; type (a class or a function), or a &lt;a href=&quot;#reactfragment&quot;&gt;React fragment&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162f5baa73eecaebf75f161ba1ad46cb2e80e270" translate="yes" xml:space="preserve">
          <source>Creates a Context object. When React renders a component that subscribes to this Context object it will read the current context value from the closest matching &lt;code&gt;Provider&lt;/code&gt; above it in the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968171522707ca5ac4670b7701c8384829388dca" translate="yes" xml:space="preserve">
          <source>Creates a portal. Portals provide a way to &lt;a href=&quot;portals&quot;&gt;render children into a DOM node that exists outside the hierarchy of the DOM component&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c5afa7af329e017f3fc8bded91f50997ffaa42" translate="yes" xml:space="preserve">
          <source>Creating React Elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd13970869588e53abc8f1259c28e723accf22bf" translate="yes" xml:space="preserve">
          <source>Creating Refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6445a9716e552ab696b8d76403765cdf028ab8" translate="yes" xml:space="preserve">
          <source>Creating a Toolchain from Scratch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524625f5c3038581049d9461158c1bc8b36669eb" translate="yes" xml:space="preserve">
          <source>Currently Chrome, Edge, and IE are the only browsers supporting this feature, but we use the standard &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API&quot;&gt;User Timing API&lt;/a&gt; so we expect more browsers to add support for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81747a03ff6dbb3bebdf52d7cd7d4a6873dc9363" translate="yes" xml:space="preserve">
          <source>Currently, &lt;code&gt;setState&lt;/code&gt; is asynchronous inside event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="894cc533c835e2352748fd904216939ee8e04201" translate="yes" xml:space="preserve">
          <source>Currently, both &lt;code&gt;TemperatureInput&lt;/code&gt; components independently keep their values in the local state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ee82909063d4ec2cbdd6059cdffa12c000df92" translate="yes" xml:space="preserve">
          <source>Currently, if &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, then &lt;a href=&quot;#unsafe_componentwillupdate&quot;&gt;&lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#componentdidupdate&quot;&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;&lt;/a&gt; will not be invoked. In the future React may treat &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; as a hint rather than a strict directive, and returning &lt;code&gt;false&lt;/code&gt; may still result in a re-rendering of the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf281e2f643467c2ac1872e15c49c4c6401ca6e" translate="yes" xml:space="preserve">
          <source>Currently, you can do it manually &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;with a ref&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0ad5578c57029da6b1cabae76f360b29b0cf4e" translate="yes" xml:space="preserve">
          <source>Custom Hooks are more of a convention than a feature. If a function&amp;rsquo;s name starts with &amp;rdquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo; and it calls other Hooks, we say it is a custom Hook. The &lt;code&gt;useSomething&lt;/code&gt; naming convention is how our linter plugin is able to find bugs in the code using Hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889b2d1572ec5a606ea5829eed1474ec8e9eefc3" translate="yes" xml:space="preserve">
          <source>Custom Hooks offer the flexibility of sharing logic that wasn&amp;rsquo;t possible in React components before. You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven&amp;rsquo;t considered. What&amp;rsquo;s more, you can build Hooks that are just as easy to use as React&amp;rsquo;s built-in features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="806b2ff53cd2bfa7527e0fceb87c041ecaccb1f3" translate="yes" xml:space="preserve">
          <source>DOM Elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a7bdfdc71786e8ffa96fbd33bfaaf81c8d3211" translate="yes" xml:space="preserve">
          <source>DOM Elements Of The Same Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890e1257a40dfb0f216d69df75d9cda18023d0bb" translate="yes" xml:space="preserve">
          <source>Data Fetching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68110e796c1686a52b96a567a54626fca49dcd8f" translate="yes" xml:space="preserve">
          <source>Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you&amp;rsquo;re used to calling these operations &amp;ldquo;side effects&amp;rdquo; (or just &amp;ldquo;effects&amp;rdquo;), you&amp;rsquo;ve likely performed them in your components before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba25d0847d81dc2070dc7517ad59c0bcd4bf477c" translate="yes" xml:space="preserve">
          <source>Debounce</source>
          <target state="translated">Debounce</target>
        </trans-unit>
        <trans-unit id="975961a279b1dd24f6702faebb928875d7ef593f" translate="yes" xml:space="preserve">
          <source>Debouncing ensures that a function will not be executed until after a certain amount of time has passed since it was last called. This can be useful when you have to perform some expensive calculation in response to an event that might dispatch rapidly (eg scroll or keyboard events). The example below debounces text input with a 250ms delay.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146ed1da84909e0ea7f2d57fc232a7cbe7f4120b" translate="yes" xml:space="preserve">
          <source>Deciding where in your app to introduce code splitting can be a bit tricky. You want to make sure you choose places that will split bundles evenly, but won&amp;rsquo;t disrupt the user experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a03c6db2907a02d02ac307742b16337e3ff60e" translate="yes" xml:space="preserve">
          <source>Declaring Default Props</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0395678e0e22a6dfbc50b32cd02fcc261ee323" translate="yes" xml:space="preserve">
          <source>Declaring a State Variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cdd342581e6300cc5e618f8e8cd327ddd9921e" translate="yes" xml:space="preserve">
          <source>Declaring multiple state variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9058ac69fc8a219b519e2124a921de745c1a0be1" translate="yes" xml:space="preserve">
          <source>Declaring state variables as a pair of &lt;code&gt;[something, setSomething]&lt;/code&gt; is also handy because it lets us give &lt;em&gt;different&lt;/em&gt; names to different state variables if we want to use more than one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b234421a34f058ad2f90d3be643d5a186deef121" translate="yes" xml:space="preserve">
          <source>Default Prop Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e853e380fbb256af90f1b6701ddb337a923884" translate="yes" xml:space="preserve">
          <source>Default Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68796229e1e55180b39f38c9f451eec72c979663" translate="yes" xml:space="preserve">
          <source>Default: &lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;Receded &amp;rarr; Skeleton &amp;rarr; Complete&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5efe2d80cf803387680dd016966ba97cdf2d9337" translate="yes" xml:space="preserve">
          <source>Default: Receded &amp;rarr; Skeleton &amp;rarr; Complete</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f732e68208a84ef73cfc0f28ac3eb5f0731e140" translate="yes" xml:space="preserve">
          <source>Defer formatting debug values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ed983b9d4ba5f079bb82c431e13ac78f1dba5df" translate="yes" xml:space="preserve">
          <source>Deferring a Value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f41de7d2358c19aa7ef2a1f2eb537bdc4b3aee" translate="yes" xml:space="preserve">
          <source>Delaying a Pending Indicator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f432560febd7a6cfa286da25ce642df6ffc81c56" translate="yes" xml:space="preserve">
          <source>Delete the remaining empty function declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee6d94594da4652399765313750e40cd7546349" translate="yes" xml:space="preserve">
          <source>Depending on your use case, there are a few more options described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fd990fa21b2940e7bad622902554f04b6cce1a" translate="yes" xml:space="preserve">
          <source>Deque - JAWS Keyboard Shortcuts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff29b77b17a5e1b7f16179d7e152cb915e6fb8d" translate="yes" xml:space="preserve">
          <source>Deque - NVDA Keyboard Shortcuts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3feae5e9f2aea785939f2ec478ba637643b658b0" translate="yes" xml:space="preserve">
          <source>Deque - VoiceOver for OS X Keyboard Shortcuts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98426dc2662537644ef697f9c4ef75147194e6dc" translate="yes" xml:space="preserve">
          <source>Deque - VoiceOver for iOS Shortcuts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b0305f7edcae9d72e4e52c23585f04c171dad9" translate="yes" xml:space="preserve">
          <source>Deque Systems offers &lt;a href=&quot;https://github.com/dequelabs/axe-core&quot;&gt;aXe-core&lt;/a&gt; for automated and end-to-end accessibility tests of your applications. This module includes integrations for Selenium.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac6f20f6e437032f7fa8d1419781d59e9c49f94" translate="yes" xml:space="preserve">
          <source>Deriving state leads to verbose code and makes your components difficult to think about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca6b2f29bf0e683cffc5bfdaa2638ab6df0be0b" translate="yes" xml:space="preserve">
          <source>Detailed Explanation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c440623df9231008fa4aec05857622d76ad2dc" translate="yes" xml:space="preserve">
          <source>Detecting common mistakes early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002d16a2c26ad8258dc7aa2e6dbbd126a2131438" translate="yes" xml:space="preserve">
          <source>Detecting legacy context API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc603c2cdbb04454bb06990e1bb1ab194e369eb" translate="yes" xml:space="preserve">
          <source>Detecting unexpected side effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80bb7ae4a9c5b6cdd027c90cafab3084c75da073" translate="yes" xml:space="preserve">
          <source>Development and Testing Tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b129fde3a74d991036c7795e38a42e732b1f1540" translate="yes" xml:space="preserve">
          <source>Development assistance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608815b4fabeb7ef2bd85ed5eee44fb34c710644" translate="yes" xml:space="preserve">
          <source>Development builds of React include many helpful warnings. Whenever possible, we add warnings in preparation for future breaking changes. That way, if your app has no warnings on the latest release, it will be compatible with the next major release. This allows you to upgrade your apps one component at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a450d63f7b35b9bbe04b8cc991bfbd556077e4d" translate="yes" xml:space="preserve">
          <source>Development warnings won&amp;rsquo;t affect the runtime behavior of your app. That way, you can feel confident that your app will behave the same way between the development and production builds &amp;mdash; the only differences are that the production build won&amp;rsquo;t log the warnings and that it is more efficient. (If you ever notice otherwise, please file an issue.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43b5cb3e5aa836cc97a21472f20853a66861f12" translate="yes" xml:space="preserve">
          <source>Differences In Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4780d7e67194e9f01b5b4900cc7a7ae5aa8624" translate="yes" xml:space="preserve">
          <source>Different DOM events and their properties are described in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MDN&lt;/a&gt;. Note that you need to pass &lt;code&gt;{ bubbles: true }&lt;/code&gt; in each event you create for it to reach the React listener because React automatically delegates events to the document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59ef28ca43dd885ebc992e2f08d12a8a570ac26" translate="yes" xml:space="preserve">
          <source>Different answers may work for different teams and products.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e84cce8c01530948fa5956c83d6e4827a31df0b" translate="yes" xml:space="preserve">
          <source>Disconnecting your mouse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e7d50c6a577134133dd3d463145950993f1200" translate="yes" xml:space="preserve">
          <source>Displaying a custom name in DevTools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a86777fdb8e09a6f2376de469c51cc7cd3d091" translate="yes" xml:space="preserve">
          <source>Do Hooks cover all use cases for classes?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1c8f25cb8a3e0e3f5a04c09f0970001f331d60" translate="yes" xml:space="preserve">
          <source>Do Hooks replace render props and higher-order components?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c919201b016ef81644c8f878d23f772ba373c1e0" translate="yes" xml:space="preserve">
          <source>Do Hooks work with static typing?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b6f82ff66e0cbd4e8061b2598cb67ae0d1d9ee" translate="yes" xml:space="preserve">
          <source>Do I need to rewrite all my class components?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c589c15fec428e101dd14c9e090c76f321dbce" translate="yes" xml:space="preserve">
          <source>Do I need to use ES6 (+) with React?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034f4c97581ab0eac5aa7ae45a3b714d8a461e85" translate="yes" xml:space="preserve">
          <source>Do I need to use JSX with React?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aef54c26cc1b5ae4c6b4cca79bc678f64db5d2f" translate="yes" xml:space="preserve">
          <source>Do Not Modify State Directly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05f09c2bb5d6ffbc40e21d1d4c099d8c14f3da1" translate="yes" xml:space="preserve">
          <source>Does it remain unchanged over time? If so, it probably isn&amp;rsquo;t state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7fc32cc155bdd52c62d75009e1d7dd18126b172" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t Mutate the Original Component. Use Composition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e478a98f6ff6cce2b292836e72c385afa0b9b73d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t Overuse Refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a270ea743c78a97d5c1f6ae9ca996de5c74e53" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t Use HOCs Inside the render Method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b1cca8627a4cbb02d1603d085e83041d60189d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be afraid to split components into smaller components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb0bb795b27da6d04288eaf3f089a6a6a68afdd" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t do it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f98fbcb97546add9b1f8fce5b03b25dce6bd0b1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget that dispatching DOM events only works when the DOM container is added to the &lt;code&gt;document&lt;/code&gt;. You can use a library like &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; to reduce the boilerplate code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26224844080a9b572cfd5fd397e5b1b87f5c85b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget that the argument to &lt;code&gt;useContext&lt;/code&gt; must be the &lt;em&gt;context object itself&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6f6fde291af71d3a9dee9d6672044fcc6b1fc3" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget to ensure your custom toolchain &lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;is correctly set up for production&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064df9c71e29f2a4d64cc895e0516ae37dd7064c" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t overthink it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6d64cafa513443888db568d47ebbcd225ba78a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t pass something like &lt;code&gt;Math.random()&lt;/code&gt; to keys. It is important that keys have a &amp;ldquo;stable identity&amp;rdquo; across re-renders so that React can determine when items are added, removed, or re-ordered. Ideally, keys should correspond to unique and stable identifiers coming from your data, such as &lt;code&gt;post.id&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029d0bffb207ca201dbd99502815b3fffb1ac0d0" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t put quotes around curly braces when embedding a JavaScript expression in an attribute. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616191245cc3b00cac1020020fee84e2a825242d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t wait for it to finish &amp;mdash; this command starts an automated watcher for JSX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92e3588b7283d2cdfb591d81364cb5b78c52b54" translate="yes" xml:space="preserve">
          <source>Download the full example (2KB zipped)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="434d5f91d6854e7dd8d91ecc3709ed83558566c9" translate="yes" xml:space="preserve">
          <source>During subsequent re-renders, the first value returned by &lt;code&gt;useState&lt;/code&gt; will always be the most recent state after applying updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95f9e3b12e8c050ccfcb91be022da7394d6e807" translate="yes" xml:space="preserve">
          <source>During the initial render, the returned state (&lt;code&gt;state&lt;/code&gt;) is the same as the value passed as the first argument (&lt;code&gt;initialState&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5f30b1a67d05410070e44d9f02ac7015b9824e" translate="yes" xml:space="preserve">
          <source>Dynamic Context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fa969ce45771386032b3a5d64cd9f951a77ee4" translate="yes" xml:space="preserve">
          <source>ES6 launched without any mixin support. Therefore, there is no support for mixins when you use React with ES6 classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae826ab563f75944404f34eae00d4d7c8c62f10c" translate="yes" xml:space="preserve">
          <source>ES6 supports a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;spread syntax&lt;/a&gt; for arrays which can make this easier. If you&amp;rsquo;re using Create React App, this syntax is available by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67810097a566468ba0a428297e19c0305506c6f5" translate="yes" xml:space="preserve">
          <source>ES6, ES2015, ES2016, etc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6026fcf7eb58fe23b617131c7f37496a090383ce" translate="yes" xml:space="preserve">
          <source>ESLint Plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9698e9ce5aaa0c0aae4725e256404ade5ccc99" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;Clock&lt;/code&gt; sets up its own timer and updates independently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d152cdb59389824fd5396d8d5d6cdf14575f6b" translate="yes" xml:space="preserve">
          <source>Each JSX element is just syntactic sugar for calling &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt;. So, anything you can do with JSX can also be done with just plain JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7b886ed2f99f6eee6ecf2bac5b9c869982764a" translate="yes" xml:space="preserve">
          <source>Each component also provides some other APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1f5c645de170e0672c34df4eaa7d02ffc47c28" translate="yes" xml:space="preserve">
          <source>Each component has several &amp;ldquo;lifecycle methods&amp;rdquo; that you can override to run code at particular times in the process. &lt;strong&gt;You can use &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; as a cheat sheet.&lt;/strong&gt; In the list below, commonly used lifecycle methods are marked as &lt;strong&gt;bold&lt;/strong&gt;. The rest of them exist for relatively rare use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0176ed7424152ff8ab0392dc7dd67eec9651185e" translate="yes" xml:space="preserve">
          <source>Each of React&amp;rsquo;s release channels is designed for a distinct use case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3304595495de8d302d926a41fd1baa5284df6967" translate="yes" xml:space="preserve">
          <source>Each type of widget has a specific design pattern and is expected to function in a certain way by users and user agents alike:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4b173e6d772999aba238dbbf21e762264e11e3" translate="yes" xml:space="preserve">
          <source>Eagle-eyed readers may notice that this example also needs a &lt;code&gt;componentDidUpdate&lt;/code&gt; method to be fully correct. We&amp;rsquo;ll ignore this for now but will come back to it in a &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;later section&lt;/a&gt; of this page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df144c1f5470b38dbff15fd68b81897120c2fdd" translate="yes" xml:space="preserve">
          <source>Earlier on this page, we introduced a &lt;code&gt;FriendStatus&lt;/code&gt; component that calls the &lt;code&gt;useState&lt;/code&gt; and &lt;code&gt;useEffect&lt;/code&gt; Hooks to subscribe to a friend&amp;rsquo;s online status. Let&amp;rsquo;s say we also want to reuse this subscription logic in another component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce320e4c6ff9a6a9b9a62001b3d3f5a450f5418d" translate="yes" xml:space="preserve">
          <source>Earlier, we looked at how to express side effects that don&amp;rsquo;t require any cleanup. However, some effects do. For example, &lt;strong&gt;we might want to set up a subscription&lt;/strong&gt; to some external data source. In that case, it is important to clean up so that we don&amp;rsquo;t introduce a memory leak! Let&amp;rsquo;s compare how we can do it with classes and with Hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0db10be720c4542dc812212fd4b92347db83913" translate="yes" xml:space="preserve">
          <source>Effects Without Cleanup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57804dbde08f38b28a414aabc784a7e90ffe5a58" translate="yes" xml:space="preserve">
          <source>Effects may also optionally specify how to &amp;ldquo;clean up&amp;rdquo; after them by returning a function. For example, this component uses an effect to subscribe to a friend&amp;rsquo;s online status, and cleans up by unsubscribing from it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067af3767b2d83fcee477226ef073ed88d3308ef" translate="yes" xml:space="preserve">
          <source>Effects with Cleanup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe263051dda9256ae9ab5d63ace0547c7ae0286" translate="yes" xml:space="preserve">
          <source>Either the common owner or another component higher up in the hierarchy should own the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12618059a59ed49359f6cb25531e3ed82d82948" translate="yes" xml:space="preserve">
          <source>Element Variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a563972e807d43617dfb0a4b0398984476c03544" translate="yes" xml:space="preserve">
          <source>Elements</source>
          <target state="translated">Elements</target>
        </trans-unit>
        <trans-unit id="dd7c7a5711e5252900f3896e5898b67e774127ee" translate="yes" xml:space="preserve">
          <source>Elements Of Different Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fad1ea61da1a1549221602c09dee579a5c3b9f8" translate="yes" xml:space="preserve">
          <source>Elements are the smallest building blocks of React apps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a984f808a95efb06c05b0ad060717183d6f03a5" translate="yes" xml:space="preserve">
          <source>Embedding Expressions in JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fa1768c7e543a2e6ed6c6cc94c404ff2f04bd5" translate="yes" xml:space="preserve">
          <source>Embedding React in a Backbone View</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacb1baf7df238a26a446d18f763426c30713b51" translate="yes" xml:space="preserve">
          <source>Embedding map() in JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9fdec9eb68d951dfbaff3b0bc88dfafff1b31b" translate="yes" xml:space="preserve">
          <source>Enabling Concurrent Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f6463c153c032ec57c13a6815c6707e987c657" translate="yes" xml:space="preserve">
          <source>End-to-end tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618d5c30b42f17cd59a0b44bf98961d419481e3c" translate="yes" xml:space="preserve">
          <source>End-to-end tests are used for testing longer flows across multiple pages, and require a &lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;different setup&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ff0e989a1887a8b6193684dcee81bdb671d4fb" translate="yes" xml:space="preserve">
          <source>End-to-end tests are useful for testing longer workflows, especially when they&amp;rsquo;re critical to your business (such as payments or signups). For these tests, you&amp;rsquo;d probably want to test how a real browser renders the whole app, fetches data from the real API endpoints, uses sessions and cookies, navigates between different links. You might also likely want to make assertions not just on the DOM state, but on the backing data as well (e.g. to verify whether the updates have been persisted to the database).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5843a84a4b8862585b36101bef81f0d8280f045" translate="yes" xml:space="preserve">
          <source>Ensure that Flow syntax is stripped from the compiled code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51cf02d9d35abf8266d4450b71ee590a50a53972" translate="yes" xml:space="preserve">
          <source>Ensure that all functionality exposed through a mouse or pointer event can also be accessed using the keyboard alone. Depending only on the pointer device will lead to many cases where keyboard users cannot use your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fdec0dd152000afa7d243170296b25bac2fcd3" translate="yes" xml:space="preserve">
          <source>Ensure that all readable text on your website has sufficient color contrast to remain maximally readable by users with low vision:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e14358a65b55cdbc91557cae723551902738cd" translate="yes" xml:space="preserve">
          <source>Ensure that your web application can be fully operated with the keyboard only:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="c27b6077f641637b35de9622914726dc00b525d8" translate="yes" xml:space="preserve">
          <source>Equivalent Class Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e313459b257b5def2c0095882b1a2ca4c257446e" translate="yes" xml:space="preserve">
          <source>Error Boundaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2e786d909fab53638b47aa2712c732c26c75ee" translate="yes" xml:space="preserve">
          <source>Error boundaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03152f355d4a7b27375ca08203950d26f97e75f9" translate="yes" xml:space="preserve">
          <source>Error boundaries &lt;strong&gt;do not&lt;/strong&gt; catch errors inside event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af7f5bac8d79dc1bd8bd3b1474a63f22115b8fa" translate="yes" xml:space="preserve">
          <source>Error boundaries are React components that &lt;strong&gt;catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI&lt;/strong&gt; instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39dd3e6e86473b72348512586d611a8ba2b1e4a8" translate="yes" xml:space="preserve">
          <source>Error boundaries do &lt;strong&gt;not&lt;/strong&gt; catch errors for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da91143355e2bfa5c28fa5a3e89aaf38272149c" translate="yes" xml:space="preserve">
          <source>Error boundaries only catch errors in the components &lt;strong&gt;below&lt;/strong&gt; them in the tree. An error boundary can&amp;rsquo;t catch an error within itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248b6ba22edd7984eab15c29276a446063ab0aff" translate="yes" xml:space="preserve">
          <source>Error boundaries preserve the declarative nature of React, and behave as you would expect. For example, even if an error occurs in a &lt;code&gt;componentDidUpdate&lt;/code&gt; method caused by a &lt;code&gt;setState&lt;/code&gt; somewhere deep in the tree, it will still correctly propagate to the closest error boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411c6161162d374478de2da829feb52753d31c43" translate="yes" xml:space="preserve">
          <source>Error boundaries work like a JavaScript &lt;code&gt;catch {}&lt;/code&gt; block, but for components. Only class components can be error boundaries. In practice, most of the time you&amp;rsquo;ll want to declare an error boundary component once and use it throughout your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd059244f14954e007f3b6cfacf808b82d7ce7d4" translate="yes" xml:space="preserve">
          <source>Error situations need to be understood by all users. The following link shows us how to expose error texts to screen readers as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35443072fb1b4b2e5833169fce316e0027876ff0" translate="yes" xml:space="preserve">
          <source>Errors thrown in the error boundary itself (rather than its children)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f674a480e681e853c6cf688edcbab6c3feddf9d0" translate="yes" xml:space="preserve">
          <source>Essentially, &lt;code&gt;useRef&lt;/code&gt; is like a &amp;ldquo;box&amp;rdquo; that can hold a mutable value in its &lt;code&gt;.current&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8ea1020f1d75f7199278f4580a82b25ad798a7" translate="yes" xml:space="preserve">
          <source>Essentially, this package makes it easy to grab a snapshot of the platform view hierarchy (similar to a DOM tree) rendered by a React DOM or React Native component without using a browser or &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92165cf4b8634704f3dd64e1f8f473a86a3dfc88" translate="yes" xml:space="preserve">
          <source>Even though React only updates the changed DOM nodes, re-rendering still takes some time. In many cases it&amp;rsquo;s not a problem, but if the slowdown is noticeable, you can speed all of this up by overriding the lifecycle function &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, which is triggered before the re-rendering process starts. The default implementation of this function returns &lt;code&gt;true&lt;/code&gt;, leaving React to perform the update:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924f0e891475199a8affc9523b77fbd74b8922e4" translate="yes" xml:space="preserve">
          <source>Even though a portal can be anywhere in the DOM tree, it behaves like a normal React child in every other way. Features like context work exactly the same regardless of whether the child is a portal, as the portal still exists in the &lt;em&gt;React tree&lt;/em&gt; regardless of position in the &lt;em&gt;DOM tree&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c234d806af4f9b93ae1c3343e0c37520ad7b27b8" translate="yes" xml:space="preserve">
          <source>Even though there is an improvement in responsiveness, this example isn&amp;rsquo;t as compelling yet because Concurrent Mode is missing some crucial optimizations for this use case. Still, it is interesting to see that features like &lt;code&gt;useDeferredValue&lt;/code&gt; (or &lt;code&gt;useTransition&lt;/code&gt;) are useful regardless of whether we&amp;rsquo;re waiting for network or for computational work to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0feec935c5e1e4103deb1b038015f52b4ea92e" translate="yes" xml:space="preserve">
          <source>Even though we create an element describing the whole UI tree on every tick, only the text node whose contents has changed gets updated by React DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df1474813d930819981e65a532a43e94f18614f" translate="yes" xml:space="preserve">
          <source>Event Bubbling Through Portals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8ceaea6e54f53ca7606e2b231356ee7e352e59" translate="yes" xml:space="preserve">
          <source>Event Pooling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f93781ab58d940daeeab4fa2ec6ce635c2bb68" translate="yes" xml:space="preserve">
          <source>Event handlers (&lt;a href=&quot;#how-about-event-handlers&quot;&gt;learn more&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61d8939222566ff94f9b0d2a3a735bb6bb39811" translate="yes" xml:space="preserve">
          <source>Event names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="c868e98d442bceb6d6a31a9193b8883b3cf64c2c" translate="yes" xml:space="preserve">
          <source>Events emitted by a Web Component may not properly propagate through a React render tree. You will need to manually attach event handlers to handle these events within your React components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe83c627adaf007c6dfbb261d61277ba4166113" translate="yes" xml:space="preserve">
          <source>Eventually, they load too, and we get to the &lt;strong&gt;Complete&lt;/strong&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bc576ea3a8cb04a164577963ea58a853e3afac" translate="yes" xml:space="preserve">
          <source>Every Context object comes with a Provider React component that allows consuming components to subscribe to context changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a709b81de0a69becea1cb5a5514e9bdc3d2b1412" translate="yes" xml:space="preserve">
          <source>Every HTML form control, such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, needs to be labeled accessibly. We need to provide descriptive labels that are also exposed to screen readers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3a16f46419ddc7fc52c28781265c7d2e286f41" translate="yes" xml:space="preserve">
          <source>Every chapter in this guide builds on the knowledge introduced in earlier chapters. &lt;strong&gt;You can learn most of React by reading the &amp;ldquo;Main Concepts&amp;rdquo; guide chapters in the order they appear in the sidebar.&lt;/strong&gt; For example, &lt;a href=&quot;introducing-jsx&quot;&gt;&amp;ldquo;Introducing JSX&amp;rdquo;&lt;/a&gt; is the next chapter after this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e16346b19291f6f8c5eadf2f6c0c265401d9a1" translate="yes" xml:space="preserve">
          <source>Every second the browser calls the &lt;code&gt;tick()&lt;/code&gt; method. Inside it, the &lt;code&gt;Clock&lt;/code&gt; component schedules a UI update by calling &lt;code&gt;setState()&lt;/code&gt; with an object containing the current time. Thanks to the &lt;code&gt;setState()&lt;/code&gt; call, React knows the state has changed, and calls the &lt;code&gt;render()&lt;/code&gt; method again to learn what should be on the screen. This time, &lt;code&gt;this.state.date&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method will be different, and so the render output will include the updated time. React updates the DOM accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca789e554144152f7db135502a37ee6272fdac89" translate="yes" xml:space="preserve">
          <source>Every update goes through the same steps so the inputs stay in sync.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f10b7b1d08963082b3b0438a8cee95484cda1b0" translate="yes" xml:space="preserve">
          <source>Everything About Color Contrast And Why You Should Rethink It</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="a7a6308ad44891ddf6909929d40496f9e973e4d3" translate="yes" xml:space="preserve">
          <source>Example Using Classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544356c9967d3974c81e67f45b423c412bb7d269" translate="yes" xml:space="preserve">
          <source>Example Using Hooks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34b5aab0e2defa2c691dfe943707a88581e4bc4" translate="yes" xml:space="preserve">
          <source>Example of code that will &lt;em&gt;not&lt;/em&gt; behave as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="ac26e2fb063dce87621ddf37c84bee42bd05cd61" translate="yes" xml:space="preserve">
          <source>Example: Passing params using arrow functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1534aebdb3554e45f79006431dd0cdaca898df7b" translate="yes" xml:space="preserve">
          <source>Example: Passing params using data-attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4dfb53af8b594cf4d30b3c3be001d98033a8e66" translate="yes" xml:space="preserve">
          <source>Example: Using AJAX results to set local state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="6a7545676e7ab4f24a631ecbbad43ce7fccaad5c" translate="yes" xml:space="preserve">
          <source>Experienced JavaScript developers might notice that the function passed to &lt;code&gt;useEffect&lt;/code&gt; is going to be different on every render. This is intentional. In fact, this is what lets us read the &lt;code&gt;count&lt;/code&gt; value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a &lt;em&gt;different&lt;/em&gt; effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result &amp;mdash; each effect &amp;ldquo;belongs&amp;rdquo; to a particular render. We will see more clearly why this is useful &lt;a href=&quot;#explanation-why-effects-run-on-each-update&quot;&gt;later on this page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2831ba29ffe2492200b0f4890460a562dd66bd6b" translate="yes" xml:space="preserve">
          <source>Experimental Channel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1691fa49296bc2c4bc77c3e42c64fba2a29ea9fb" translate="yes" xml:space="preserve">
          <source>Experimental features are ones that are not ready to be released to the wider public, and may change drastically before they are finalized. Some experiments may never be finalized &amp;mdash; the reason we have experiments is to test the viability of proposed changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16bbe54f4338869e513550bc6e7bec3deb89f284" translate="yes" xml:space="preserve">
          <source>Experimental features may or may not be documented. Usually, experiments aren&amp;rsquo;t documented until they are close to shipping in Next or Stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7419ab25c67c5d7fdae34ae9794a8a69a072dfb1" translate="yes" xml:space="preserve">
          <source>Experimental releases may be significantly different than releases to Next and Latest. &lt;strong&gt;Do not use Experimental releases in user-facing applications.&lt;/strong&gt; You should expect frequent breaking changes between releases in the Experimental channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="55a90e8035a82de0d93f1c9a3c7f341af3106c00" translate="yes" xml:space="preserve">
          <source>Explanation: Why Effects Run on Each Update</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262ee9d29af39ff552e4c59e7fda03780ccb25a1" translate="yes" xml:space="preserve">
          <source>Exposing DOM Refs to Parent Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e3b02c6073db5722a2445db289eed3bc30f1df" translate="yes" xml:space="preserve">
          <source>Extracting Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3ad8ee661c9841c42e93cfe58a6f4283443a37" translate="yes" xml:space="preserve">
          <source>Extracting Components with Keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a7f2eb5a5056a20dc5cf476d802afcad85ef47" translate="yes" xml:space="preserve">
          <source>Extracting Data from Backbone Models</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ddc74504155a0221350a8de09769a873178d902" translate="yes" xml:space="preserve">
          <source>Extracting a Custom Hook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238fe11258ea53623c0e9f18b2d4fa180b9ce41e" translate="yes" xml:space="preserve">
          <source>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (&lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Panel&lt;/code&gt;, &lt;code&gt;Avatar&lt;/code&gt;), or is complex enough on its own (&lt;code&gt;App&lt;/code&gt;, &lt;code&gt;FeedStory&lt;/code&gt;, &lt;code&gt;Comment&lt;/code&gt;), it is a good candidate to be a reusable component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="d7ca52e8a67912bc341fe3a3cf2185f9f12fe00b" translate="yes" xml:space="preserve">
          <source>Feature Comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31683b71129689222166ae6fa094345d3274ca8" translate="yes" xml:space="preserve">
          <source>Fetching early can be cumbersome to express. How do we make it easier to avoid waterfalls?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0de66d5acebdbcad2664d79de96d44cd22b0450" translate="yes" xml:space="preserve">
          <source>Fiber is the new reconciliation engine in React 16. Its main goal is to enable incremental rendering of the virtual DOM. &lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot;&gt;Read more&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f29e7621a1a9119ef236e19e00448244df7422" translate="yes" xml:space="preserve">
          <source>File Structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373ecfdf236324d2c0d2c0966daa4376bd84ecc7" translate="yes" xml:space="preserve">
          <source>File extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78e8a4f64ac4a4b1fabdf7e14799f6b58765746" translate="yes" xml:space="preserve">
          <source>Finally, another possible reason you&amp;rsquo;re seeing stale props or state is if you use the &amp;ldquo;dependency array&amp;rdquo; optimization but didn&amp;rsquo;t correctly specify all the dependencies. For example, if an effect specifies &lt;code&gt;[]&lt;/code&gt; as the second argument but reads &lt;code&gt;someProp&lt;/code&gt; inside, it will keep &amp;ldquo;seeing&amp;rdquo; the initial value of &lt;code&gt;someProp&lt;/code&gt;. The solution is to either remove the dependency array, or to fix it. Here&amp;rsquo;s &lt;a href=&quot;#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how you can deal with functions&lt;/a&gt;, and here&amp;rsquo;s &lt;a href=&quot;#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;other common strategies&lt;/a&gt; to run effects less often without incorrectly skipping dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba0489d65d2d3fc21a360081711a99ffee70891" translate="yes" xml:space="preserve">
          <source>Finally, don&amp;rsquo;t miss the &lt;a href=&quot;hooks-intro&quot;&gt;introduction page&lt;/a&gt; which explains &lt;em&gt;why&lt;/em&gt; we&amp;rsquo;re adding Hooks and how we&amp;rsquo;ll start using them side by side with classes &amp;mdash; without rewriting our apps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8438bc41cca4e743aa12124ae77341500cac594" translate="yes" xml:space="preserve">
          <source>Finally, run one of the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2aa8b54c68956359dcc663aff9d9037284022e" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt;&lt;/a&gt; Hook reduces the need to pass callbacks deeply, as explained below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570ce262c8a7066abc6b8bb5f403e6fb557d261e" translate="yes" xml:space="preserve">
          <source>Finally, the resulting bundle is piped to &lt;a href=&quot;https://github.com/terser-js/terser&quot;&gt;&lt;code&gt;terser&lt;/code&gt;&lt;/a&gt; for mangling (&lt;a href=&quot;https://github.com/hughsk/uglifyify#motivationusage&quot;&gt;read why&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd077e06c84210a2fb3afbe0a686af0ac5ca973" translate="yes" xml:space="preserve">
          <source>Finally, there are two primary ways that lead us to the Skeleton state. We will illustrate the difference between them with a concrete example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0fdc61c51d5713eda8f9ef73a39353026b49e9" translate="yes" xml:space="preserve">
          <source>Finally, there is one more thing left to do. In React, props can change over time. For example, the &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; component can get different children if parent component&amp;rsquo;s state changes. This means that at integration points it is important that we manually update the DOM in response to prop updates, since we no longer let React manage the DOM for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30e9cf8ac0b76207bda3245cb2182efdc414b1f" translate="yes" xml:space="preserve">
          <source>Finally, we will implement a method called &lt;code&gt;tick()&lt;/code&gt; that the &lt;code&gt;Clock&lt;/code&gt; component will run every second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6bdf360c9cdf4666af396e6a18cf67ced3bdb2" translate="yes" xml:space="preserve">
          <source>Finally, we&amp;rsquo;ll use it inside the &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb106579ba6a556d0a0faef0bd385b5a54b87e0" translate="yes" xml:space="preserve">
          <source>Finally, we&amp;rsquo;re ready to learn about &lt;a href=&quot;hooks-custom&quot;&gt;writing your own Hooks&lt;/a&gt;! Custom Hooks let you combine Hooks provided by React into your own abstractions, and reuse common stateful logic between different components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75a0e987111ecd887671fc8a3f5587a3940db9a" translate="yes" xml:space="preserve">
          <source>Find a common owner component (a single component above all the components that need the state in the hierarchy).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd10529f86faad367b294935f883fa7a473c8344" translate="yes" xml:space="preserve">
          <source>Find a single descendant test instance for which &lt;code&gt;test(testInstance)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;test(testInstance)&lt;/code&gt; does not return &lt;code&gt;true&lt;/code&gt; for exactly one test instance, it will throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ac958640059feca8470fa66a87c6d3058fbecd" translate="yes" xml:space="preserve">
          <source>Find a single descendant test instance with the provided &lt;code&gt;props&lt;/code&gt;. If there is not exactly one test instance with the provided &lt;code&gt;props&lt;/code&gt;, it will throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6291a33bd325f2205732a5ed9112fb0250cc2b5f" translate="yes" xml:space="preserve">
          <source>Find a single descendant test instance with the provided &lt;code&gt;type&lt;/code&gt;. If there is not exactly one test instance with the provided &lt;code&gt;type&lt;/code&gt;, it will throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9dd365ea82c943b75891a6b85a9d37f3912fb9" translate="yes" xml:space="preserve">
          <source>Find all descendant test instances for which &lt;code&gt;test(testInstance)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b1b8ea5fee48f3e121adffde346749520e47d8" translate="yes" xml:space="preserve">
          <source>Find all descendant test instances with the provided &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82fa4047ac4e7196ebe8d99bde1ec943590d7a8" translate="yes" xml:space="preserve">
          <source>Find all descendant test instances with the provided &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba889b4c3d1075d33e079e5839e918035baac30a" translate="yes" xml:space="preserve">
          <source>Finds all DOM elements of components in the rendered tree that are DOM components with the class name matching &lt;code&gt;className&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2d40e5f01e49ec1f9ca6614adadd74d8e448f3" translate="yes" xml:space="preserve">
          <source>Finds all DOM elements of components in the rendered tree that are DOM components with the tag name matching &lt;code&gt;tagName&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139948e94d3c318e819b31e3e063cdea8779f65d" translate="yes" xml:space="preserve">
          <source>Finds all instances of components with type equal to &lt;code&gt;componentClass&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002074b73eeeb01130c3e9603a19fd6ea3c3b0a9" translate="yes" xml:space="preserve">
          <source>Finish fetching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5279683987b6110a5f734ea482017a9f1707bf60" translate="yes" xml:space="preserve">
          <source>Firefox Browser Extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22dd4f6d06a701148f78aeafd7d59690258e6f2" translate="yes" xml:space="preserve">
          <source>First Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31edf6c539183fae836c95a3e043736312850de" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s look at what Chosen does to the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4734953a720148d9b4e3f52cf3651d1bbef61893" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s review how you transform lists in JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f571561a4179c80fd11057f8db1c01d30c7afe66" translate="yes" xml:space="preserve">
          <source>First, navigate to your project directory in the terminal. You will need to run the following command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d50e931cf3ca82296d09451cd9e2a2c6a5f606" translate="yes" xml:space="preserve">
          <source>First, open the HTML page you want to edit. Add an empty &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; tag to mark the spot where you want to display something with React. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbb2b7c606daedd24bb97a26330b095e5c91a30" translate="yes" xml:space="preserve">
          <source>First, we will create an empty component with a &lt;code&gt;render()&lt;/code&gt; method where we return &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; wrapped in a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850899e6c789ecbc9390ccff1b8f1d62d2eb090c" translate="yes" xml:space="preserve">
          <source>First, we will extract &lt;code&gt;Avatar&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd17a20ab6e5091412cc2bc0981f871fb3aad8d5" translate="yes" xml:space="preserve">
          <source>First, we will replace &lt;code&gt;this.state.temperature&lt;/code&gt; with &lt;code&gt;this.props.temperature&lt;/code&gt; in the &lt;code&gt;TemperatureInput&lt;/code&gt; component. For now, let&amp;rsquo;s pretend &lt;code&gt;this.props.temperature&lt;/code&gt; already exists, although we will need to pass it from the &lt;code&gt;Calculator&lt;/code&gt; in the future:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38547d143eab30914dc1542d30d6ffa38489126" translate="yes" xml:space="preserve">
          <source>First, we will write two functions to convert from Celsius to Fahrenheit and back:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0546090bdf17503734b68ca5ca7f42c8f59803ba" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll define an error boundary component to use across our project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d1c98f23da83b26247d219f11d4dcf023bfb97" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll extract this logic into a custom Hook called &lt;code&gt;useFriendStatus&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d75bcb6ad1a92ca508ad7a4f4e1f23b6c2a443d" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll make sure that we&amp;rsquo;re actually using Concurrent Mode. We&amp;rsquo;ll talk more about &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;adopting Concurrent Mode&lt;/a&gt; later, but for now it&amp;rsquo;s sufficient to know that we need to use &lt;code&gt;ReactDOM.createRoot()&lt;/code&gt; rather than &lt;code&gt;ReactDOM.render()&lt;/code&gt; for this feature to work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7995484b8387f581a4be55b38ff4d9e3aca31d06" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll try a version of our original &amp;ldquo;fetch in effect&amp;rdquo; example. We&amp;rsquo;ll modify it to pass an &lt;code&gt;id&lt;/code&gt; parameter from the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; props to &lt;code&gt;fetchUser(id)&lt;/code&gt; and &lt;code&gt;fetchPosts(id)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74806b2e8c725d56528386985317d5d032f055a2" translate="yes" xml:space="preserve">
          <source>Firstly, let&amp;rsquo;s arrange our project structure like this. We&amp;rsquo;ll place all our source code in the &lt;code&gt;src&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86eff8eb789b097ddca83f2c9c4617ed23605105" translate="yes" xml:space="preserve">
          <source>Flow</source>
          <target state="translated">Flow</target>
        </trans-unit>
        <trans-unit id="e2ce5d47a8c1aa7433f3dabcacbd9eba1847b52a" translate="yes" xml:space="preserve">
          <source>Flow Documentation: Editors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a935a1a622003f2b9a59950756441e7a987c0aa" translate="yes" xml:space="preserve">
          <source>Flow Documentation: React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388960a5ef923123e15f51a7c912a585a0d7bab9" translate="yes" xml:space="preserve">
          <source>Flow Documentation: Type Annotations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb5e0b12f5cf50d3b0f98f6128b892d7e35d600" translate="yes" xml:space="preserve">
          <source>Flow does not require the &lt;code&gt;react&lt;/code&gt; preset, but they are often used together. Flow itself understands JSX syntax out of the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b011dafddca02cf4d31d7f3eed20fb2a60901be6" translate="yes" xml:space="preserve">
          <source>Flow extends the JavaScript language with a special syntax for type annotations. However, browsers aren&amp;rsquo;t aware of this syntax, so we need to make sure it doesn&amp;rsquo;t end up in the compiled JavaScript bundle that is sent to the browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd15cc47d7683e059370f427aad3fd5f6a94f39" translate="yes" xml:space="preserve">
          <source>Focus Control</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c6e47ced4689fc9b50ffb6c5d899c6c3458d6a" translate="yes" xml:space="preserve">
          <source>Focus Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186d8edb88541264714b7fdfd864c5d337ce64bf" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;MyComponent&lt;/code&gt;, the value of &lt;code&gt;props.foo&lt;/code&gt; will be &lt;code&gt;10&lt;/code&gt; because the expression &lt;code&gt;1 + 2 + 3 + 4&lt;/code&gt; gets evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43a105c56e84bdfc291537517481c1e8fc3a3cd" translate="yes" xml:space="preserve">
          <source>For C1 and C3, &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;true&lt;/code&gt;, so React had to go down to the leaves and check them. For C6 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;true&lt;/code&gt;, and since the rendered elements weren&amp;rsquo;t equivalent React had to update the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5d4978ec88fcf2eae32559987a0c7fe9031866b" translate="yes" xml:space="preserve">
          <source>For CPU-bound updates (such as creating DOM nodes and running component code), concurrency means that a more urgent update can &amp;ldquo;interrupt&amp;rdquo; rendering that has already started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456da7f75c50e18b116caf077221012f7b10d367" translate="yes" xml:space="preserve">
          <source>For IO-bound updates (such as fetching code or data from the network), concurrency means that React can start rendering in memory even before all the data arrives, and skip showing jarring empty loading states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52411992a5ea90e7a22ab937f331633f14633056" translate="yes" xml:space="preserve">
          <source>For Library Authors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295506224e5dfd3bc5a2f5a949671a335a57d51c" translate="yes" xml:space="preserve">
          <source>For a complete setup example &lt;a href=&quot;https://gist.github.com/Rich-Harris/cb14f4bc0670c47d00d191565be36bf0&quot;&gt;see this gist&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679fe92462c39504c9ff9773ae608eb7389ffc9e" translate="yes" xml:space="preserve">
          <source>For a more concrete example of these concepts, let&amp;rsquo;s write a minimal wrapper for the plugin &lt;a href=&quot;https://harvesthq.github.io/chosen/&quot;&gt;Chosen&lt;/a&gt;, which augments &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02416dec32f4ac14f5c635f846c95b0b1f3e149" translate="yes" xml:space="preserve">
          <source>For a more detailed walkthrough, check out &lt;a href=&quot;https://calibreapp.com/blog/react-performance-profiling-optimization&quot;&gt;this article by Ben Schwarz&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6742712e3a4c00cde6cec63fd4e900f882182503" translate="yes" xml:space="preserve">
          <source>For components defined as classes, use &lt;code&gt;this.props.children&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0460aa967c08b3c0359b521985038ac48561d5" translate="yes" xml:space="preserve">
          <source>For each particular piece of changing data, there should be just one component that &amp;ldquo;owns&amp;rdquo; it in its state. Don&amp;rsquo;t try to synchronize states of two different components. Instead, &lt;a href=&quot;lifting-state-up&quot;&gt;lift it up&lt;/a&gt; to their closest shared ancestor, and pass it down as props to both of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647bc53c804dc25be5b4801130ef3922760422b8" translate="yes" xml:space="preserve">
          <source>For each piece of state in your application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4657ab12168f0360582ae377c9a3fb4c69201085" translate="yes" xml:space="preserve">
          <source>For each test, we usually want to render our React tree to a DOM element that&amp;rsquo;s attached to &lt;code&gt;document&lt;/code&gt;. This is important so that it can receive DOM events. When the test ends, we want to &amp;ldquo;clean up&amp;rdquo; and unmount the tree from the &lt;code&gt;document&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2f11c83d765d839676e4e232e576ddbe2a1a64" translate="yes" xml:space="preserve">
          <source>For example a custom Hook that returned a &lt;code&gt;Date&lt;/code&gt; value could avoid calling the &lt;code&gt;toDateString&lt;/code&gt; function unnecessarily by passing the following formatter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ccd00019fe7c93727e1ee7af34a30096debfa1c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;class&lt;/code&gt; becomes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/className&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt; in JSX, and &lt;code&gt;tabindex&lt;/code&gt; becomes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex&quot;&gt;&lt;code&gt;tabIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="257bf267f4accf76b8a71c8a6fc907d879bb3b3b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;tryConvert('abc', toCelsius)&lt;/code&gt; returns an empty string, and &lt;code&gt;tryConvert('10.22', toFahrenheit)&lt;/code&gt; returns &lt;code&gt;'50.396'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86da3811ff28fce969e656a6a27c26d72c389972" translate="yes" xml:space="preserve">
          <source>For example, Facebook Messenger wraps content of the sidebar, the info panel, the conversation log, and the message input into separate error boundaries. If some component in one of these UI areas crashes, the rest of them remain interactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d8139b3a5725d0dbe39a1d636583f71febc457" translate="yes" xml:space="preserve">
          <source>For example, both of the imports are necessary in this code, even though &lt;code&gt;React&lt;/code&gt; and &lt;code&gt;CustomButton&lt;/code&gt; are not directly referenced from JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390fb39992645b6398deff562b8f840081098a97" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;Page&lt;/code&gt; component that passes a &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt; prop several levels down so that deeply nested &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Avatar&lt;/code&gt; components can read it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0f37544377fd4ba88f4814137f0c59e828e67d" translate="yes" xml:space="preserve">
          <source>For example, consider a filterable list like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672d122436eb70d444bbe9b6d5a7454eb80d94df" translate="yes" xml:space="preserve">
          <source>For example, consider the &lt;code&gt;useFriendStatus&lt;/code&gt; custom Hook described in &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;Building Your Own Hooks&amp;rdquo;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897f4de2b32102497cc28727717c94d918135994" translate="yes" xml:space="preserve">
          <source>For example, consider the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9050062cc798394f53d6e8b1ff9014a2612f33bb" translate="yes" xml:space="preserve">
          <source>For example, consider this &lt;code&gt;Comment&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c300f11b425a9fc05f0c1272d1583ab4603762" translate="yes" xml:space="preserve">
          <source>For example, continuing with our &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component from above, if &lt;code&gt;Mouse&lt;/code&gt; were to extend &lt;code&gt;React.PureComponent&lt;/code&gt; instead of &lt;code&gt;React.Component&lt;/code&gt;, our example would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ed488706a8a3ad440cf53c3eca5d4c4ed1ad07" translate="yes" xml:space="preserve">
          <source>For example, if the Experimental channel had existed when we announced Hooks, we would have released Hooks to the Experimental channel weeks before they were available in Latest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72386049d7fd0a4d1be43f2f6774c74af5948367" translate="yes" xml:space="preserve">
          <source>For example, if we enter 37 into the Celsius input, the state of the &lt;code&gt;Calculator&lt;/code&gt; component will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9993ee38514320027480d338484992ca1feb5c6" translate="yes" xml:space="preserve">
          <source>For example, if we switch from one page to another, and none of the code or data for the next screen has loaded yet, it might be frustrating to immediately see a blank page with a loading indicator. We might prefer to stay longer on the previous screen. Implementing this pattern has historically been difficult in React. Concurrent Mode offers a new set of tools to do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65295b13b97c2a6ed8a939287bfe094925fc31cc" translate="yes" xml:space="preserve">
          <source>For example, if we want to make the previous example log the name when it is submitted, we can write the form as a controlled component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90b29303f730a5e659074ca0cb511ba946d5117" translate="yes" xml:space="preserve">
          <source>For example, if you &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract&lt;/a&gt; a &lt;code&gt;ListItem&lt;/code&gt; component, you should keep the key on the &lt;code&gt;&amp;lt;ListItem /&amp;gt;&lt;/code&gt; elements in the array rather than on the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element in the &lt;code&gt;ListItem&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f472461a434d14b304ba318506b6c2b7dd4f729" translate="yes" xml:space="preserve">
          <source>For example, if you have the following component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9af7a91451dd9ae9a9996fb7f391bbc16ec6a4" translate="yes" xml:space="preserve">
          <source>For example, instead of exposing &lt;code&gt;open()&lt;/code&gt; and &lt;code&gt;close()&lt;/code&gt; methods on a &lt;code&gt;Dialog&lt;/code&gt; component, pass an &lt;code&gt;isOpen&lt;/code&gt; prop to it.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
