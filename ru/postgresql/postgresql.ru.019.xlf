<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="2c1cd79ab101e360e9a13e652ea38bf6edc2d76e" translate="yes" xml:space="preserve">
          <source>Use an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt; to enforce the rule that a cage at a zoo can contain only one kind of animal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed495ec2e832a44d27151818dc3a53eb05f6485b" translate="yes" xml:space="preserve">
          <source>Use checksums on data pages to help detect corruption by the I/O system that would otherwise be silent. Enabling checksums may incur a noticeable performance penalty. If set, checksums are calculated for all objects, in all databases. All checksum failures will be reported in the &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce023d8439552305d2edc6e2bf4149ad204ec26c" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d755e67717cdd34225a86cde8e3134de7095e52a" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop databases and other objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723b15fd565cd7b73cc4c9f69508e6bb65d787d0" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) when cleaning database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8dc23b011f6f1a62e695d4c31ea4636fb489dcc" translate="yes" xml:space="preserve">
          <source>Use efficient file cloning (also known as &amp;ldquo;reflinks&amp;rdquo; on some systems) instead of copying files to the new cluster. This can result in near-instantaneous copying of the data files, giving the speed advantages of &lt;code&gt;-k&lt;/code&gt;/&lt;code&gt;--link&lt;/code&gt; while leaving the old cluster untouched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717457386c7410d1c0caadadb8bcf5cee9b94ef2" translate="yes" xml:space="preserve">
          <source>Use genetic query optimization to plan queries with at least this many &lt;code&gt;FROM&lt;/code&gt; items involved. (Note that a &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; construct counts as only one &lt;code&gt;FROM&lt;/code&gt; item.) The default is 12. For simpler queries it is usually best to use the regular, exhaustive-search planner, but for queries with many tables the exhaustive search takes too long, often longer than the penalty of executing a suboptimal plan. Thus, a threshold on the size of the query is a convenient way to manage use of GEQO.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0976de4de13332a56e83de88d1173b0054dd784" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;INHERITS&lt;/code&gt; creates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e4eb26aa371684361e3e419e078890b371282ac" translate="yes" xml:space="preserve">
          <source>Use of most of these functions requires PostgreSQL to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c68e27d415e6287dfc4c6988546eee3d268cda34" translate="yes" xml:space="preserve">
          <source>Use of symbolic references is enabled in a particular catalog column by attaching &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; to the column's definition, where &lt;code&gt;lookuprule&lt;/code&gt; is the name of the referenced catalog, e.g. &lt;code&gt;pg_proc&lt;/code&gt;. &lt;code&gt;BKI_LOOKUP&lt;/code&gt; can be attached to columns of type &lt;code&gt;Oid&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;oidvector&lt;/code&gt;, or &lt;code&gt;Oid[]&lt;/code&gt;; in the latter two cases it implies performing a lookup on each element of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7de245d3c3aa0bf5e90f594f4cb93e3038943a92" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;RETURNING&lt;/code&gt; clause requires &lt;code&gt;SELECT&lt;/code&gt; privilege on all columns mentioned in &lt;code&gt;RETURNING&lt;/code&gt;. If you use the &lt;code&gt;query&lt;/code&gt; clause to insert rows from a query, you of course need to have &lt;code&gt;SELECT&lt;/code&gt; privilege on any table or column used in the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa84cc2dc2791298c5a401376b7bb182eec75e7" translate="yes" xml:space="preserve">
          <source>Use real data for experimentation. Using test data for setting up indexes will tell you what indexes you need for the test data, but that is all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740a1a424b9afbaad4fd5f97eac328593356e696" translate="yes" xml:space="preserve">
          <source>Use semicolon followed by two newlines, rather than just newline, as the command entry terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493672dde3eb1e21802c93c463663707684dc28f" translate="yes" xml:space="preserve">
          <source>Use separate session key. Public-key encryption always uses a separate session key; this option is for symmetric-key encryption, which by default uses the S2K key directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c526253accc03345c125a338a69425d93d7a5c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt; statement to drop views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8fcf6d0e2c0c387fa9db23f6382b953340061f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option. See &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e85f329c30105292985206289324c8f90af224" translate="yes" xml:space="preserve">
          <source>Use the alternative column-list syntax to do the same update:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae2307b8f401e6a987e3d05544bf2939cd859f9" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_COLLATE&lt;/code&gt; locale category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a394e7b9e61f2a206b4b6967eab6c67d2c7b7c" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2aa6b91b4c4ba84fa390b2a6da37aa75a60894a" translate="yes" xml:space="preserve">
          <source>Use the specified synchronized snapshot when making a dump of the database (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.87&lt;/a&gt; for more details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee78ab2ce0e01deb66fa480713a33b2c2b35d2ab" translate="yes" xml:space="preserve">
          <source>Use the specified value of &lt;code&gt;extra_float_digits&lt;/code&gt; when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4516f566a55d94c31709c01f556432e3bd7291" translate="yes" xml:space="preserve">
          <source>Use the specified value of extra_float_digits when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f31da9aa85cb07454372ac17645a52a84247324" translate="yes" xml:space="preserve">
          <source>Use this sequence in an &lt;code&gt;INSERT&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29370364d5a3aa7edfb47c0679c084d535a999d7" translate="yes" xml:space="preserve">
          <source>Used to allow inference of partial unique indexes. Any indexes that satisfy the predicate (which need not actually be partial indexes) can be inferred. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on any column appearing within &lt;code&gt;index_predicate&lt;/code&gt; is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfbb286795d184b793a60a1094e6c47b8ed4218" translate="yes" xml:space="preserve">
          <source>Useful values for production work probably range from a small number of hours to a few days. Small values (such as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1min&lt;/code&gt;) are only allowed because they may sometimes be useful for testing. While a setting as high as &lt;code&gt;60d&lt;/code&gt; is allowed, please note that in many workloads extreme bloat or transaction ID wraparound may occur in much shorter time frames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa9c997122e493dfcfb31ff0542b184a558e6ef" translate="yes" xml:space="preserve">
          <source>User Name Maps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657c8b98d31db02ca6e2f49846863d392059fe65" translate="yes" xml:space="preserve">
          <source>User bypasses every row level security policy, see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a367250b51dc731bdf8cbd166e2c6618238172" translate="yes" xml:space="preserve">
          <source>User can create databases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd638046cbfe5c1f3e3cd84a3d83b310d114f21" translate="yes" xml:space="preserve">
          <source>User can initiate streaming replication and put the system in and out of backup mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ff3be7aa18f82b61ae56cce7156698ab778283" translate="yes" xml:space="preserve">
          <source>User is a superuser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0381065a82fe9d6c10d8cd3e9089f5c14f9312b8" translate="yes" xml:space="preserve">
          <source>User mapping specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0966c5e99e856745941e09bf863b1894eaa04766" translate="yes" xml:space="preserve">
          <source>User name for the user to run the service as. For domain users, use the format &lt;code&gt;DOMAIN\username&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae03b2f53e94d67697836cc9ddba3d24303f1bd3" translate="yes" xml:space="preserve">
          <source>User name maps are defined in the ident map file, which by default is named &lt;code&gt;pg_ident.conf&lt;/code&gt; and is stored in the cluster's data directory. (It is possible to place the map file elsewhere, however; see the &lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;ident_file&lt;/a&gt; configuration parameter.) The ident map file contains lines of the general form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c83bd5ba1faee58ca4dfcad77ca8603bcdb897" translate="yes" xml:space="preserve">
          <source>User name of the mapping. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. &lt;code&gt;PUBLIC&lt;/code&gt; is used to match all present and future user names in the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f782be03fcdc443b383e428fe084103c7519032" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to create).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a48e5ec3f1ddd8734180ce7a8bcf7ce3e61813" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to drop).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7c5d855fc83ff64eb10669f8523b7d11212f01" translate="yes" xml:space="preserve">
          <source>User name to connect as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104f2eb40da0056ec5533c282848e3fce154c0c2" translate="yes" xml:space="preserve">
          <source>User name to connect as. Defaults to current operating system user name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d47cce93b040f97f45693a064d2ec0fe0d47cbfa" translate="yes" xml:space="preserve">
          <source>User-defined constraint triggers (created with &lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt;) also give rise to an entry in this table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ef205df825ba4213dcb43cc225636454550c49" translate="yes" xml:space="preserve">
          <source>User-defined types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a19bf7678e0c925ef7e00adabbc0a5965212bf" translate="yes" xml:space="preserve">
          <source>Users (roles) that are to be added to or removed from the group. The users must already exist; &lt;code&gt;ALTER GROUP&lt;/code&gt; does not create or drop users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c368e154de403e348ebf85b5c480f63c95e940b6" translate="yes" xml:space="preserve">
          <source>Users accustomed to working with other SQL database management systems might be disappointed by the performance of the &lt;code&gt;count&lt;/code&gt; aggregate when it is applied to the entire table. A query like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec14cfda8b568c538e7a2b35ec4764216fe766a6" translate="yes" xml:space="preserve">
          <source>Users can define their own range types. The most common reason to do this is to use ranges over subtypes not provided among the built-in range types. For example, to define a new range type of subtype &lt;code&gt;float8&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4944fa9df06f02dea3273ddeb97bb2eab5830741" translate="yes" xml:space="preserve">
          <source>Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of user names means that there cannot be different users named, say, &lt;code&gt;joe&lt;/code&gt; in two databases in the same cluster; but the system can be configured to allow &lt;code&gt;joe&lt;/code&gt; access to only some of the databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655defefcbd5cf77a94fb403c6b891d5f809540a" translate="yes" xml:space="preserve">
          <source>Users should be clear that tables that are regularly and heavily updated on the primary server will quickly cause cancellation of longer running queries on the standby. In such cases the setting of a finite value for &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; can be considered similar to setting &lt;code&gt;statement_timeout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc34515c6a1d7984b3e11718da650ce1ef5ed348" translate="yes" xml:space="preserve">
          <source>Users sometimes try to declare operators applying just to a domain type. This is possible but is not nearly as useful as it might seem, because the operator resolution rules are designed to select operators applying to the domain's base type. As an example consider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1772f82727e2e70cce145a14908f76eba9dee789" translate="yes" xml:space="preserve">
          <source>Users sometimes wonder why host names are handled in this seemingly complicated way, with two name resolutions including a reverse lookup of the client's IP address. This complicates use of the feature in case the client's reverse DNS entry is not set up or yields some undesirable host name. It is done primarily for efficiency: this way, a connection attempt requires at most two resolver lookups, one reverse and one forward. If there is a resolver problem with some address, it becomes only that client's problem. A hypothetical alternative implementation that only did forward lookups would have to resolve every host name mentioned in &lt;code&gt;pg_hba.conf&lt;/code&gt; during every connection attempt. That could be quite slow if many names are listed. And if there is a resolver problem with one of the host names, it becomes everyone's problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4adcca052990f33f0c6c8200c5c596110e4cd88f" translate="yes" xml:space="preserve">
          <source>Users will be able to tell whether their session is read-only by issuing &lt;code&gt;SHOW transaction_read_only&lt;/code&gt;. In addition, a set of functions (&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt;) allow users to access information about the standby server. These allow you to write programs that are aware of the current state of the database. These can be used to monitor the progress of recovery, or to allow you to write complex programs that restore the database to particular states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e2bf0df748000aab563d6b102d035c272f7dd2" translate="yes" xml:space="preserve">
          <source>Users will stop waiting if a fast shutdown is requested. However, as when using asynchronous replication, the server will not fully shutdown until all outstanding WAL records are transferred to the currently connected standby servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00379b69f39e7e2d3d7c05f05b12ede542302d0d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; on an object additionally requires &lt;code&gt;relabelfrom&lt;/code&gt; permission for the object in conjunction with its old security label and &lt;code&gt;relabelto&lt;/code&gt; permission for the object in conjunction with its new security label. (In cases where multiple label providers are installed and the user tries to set a security label, but it is not managed by SELinux, only &lt;code&gt;setattr&lt;/code&gt; should be checked here. This is currently not done due to implementation restrictions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba7d6f6db215ecebd0a0dd010a3ef4d72762c57" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; on this view, specifically updating the &lt;code&gt;setting&lt;/code&gt; column, is the equivalent of issuing &lt;code&gt;SET&lt;/code&gt; commands. For example, the equivalent of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4a279994eeee7b66ef6f4b6c4072e3efe337a2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ALL&lt;/code&gt; for a policy means that it will apply to all commands, regardless of the type of command. If an &lt;code&gt;ALL&lt;/code&gt; policy exists and more specific policies exist, then both the &lt;code&gt;ALL&lt;/code&gt; policy and the more specific policy (or policies) will be applied. Additionally, &lt;code&gt;ALL&lt;/code&gt; policies will be applied to both the selection side of a query and the modification side, using the &lt;code&gt;USING&lt;/code&gt; expression for both cases if only a &lt;code&gt;USING&lt;/code&gt; expression has been defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1caa6904d1b2e3c70cf23410fccedf2e858e4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;DELETE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;DELETE&lt;/code&gt; commands. Only rows that pass this policy will be seen by a &lt;code&gt;DELETE&lt;/code&gt; command. There can be rows that are visible through a &lt;code&gt;SELECT&lt;/code&gt; that are not available for deletion, if they do not pass the &lt;code&gt;USING&lt;/code&gt; expression for the &lt;code&gt;DELETE&lt;/code&gt; policy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba736c87dfcbb2c8e16a4a5fbcf41dc4d34ae6e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;INSERT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;INSERT&lt;/code&gt; commands. Rows being inserted that do not pass this policy will result in a policy violation error, and the entire &lt;code&gt;INSERT&lt;/code&gt; command will be aborted. An &lt;code&gt;INSERT&lt;/code&gt; policy cannot have a &lt;code&gt;USING&lt;/code&gt; expression, as it only applies in cases where records are being added to the relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4584b8b01123eb82dc7847c4d9677c40b0e5bba4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ONLY&lt;/code&gt; to add or drop a constraint on only the partitioned table is supported as long as there are no partitions. Once partitions exist, using &lt;code&gt;ONLY&lt;/code&gt; will result in an error as adding or dropping constraints on only the partitioned table, when partitions exist, is not supported. Instead, constraints on the partitions themselves can be added and (if they are not present in the parent table) dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9191967f0b2195c21483c93a60dfe19fe3e18ef8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;. If the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; is defined in the client's environment, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de75f251dab5b0ad3801e8b63609c603b9f339f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SELECT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;SELECT&lt;/code&gt; queries and whenever &lt;code&gt;SELECT&lt;/code&gt; permissions are required on the relation the policy is defined for. The result is that only those records from the relation that pass the &lt;code&gt;SELECT&lt;/code&gt; policy will be returned during a &lt;code&gt;SELECT&lt;/code&gt; query, and that queries that require &lt;code&gt;SELECT&lt;/code&gt; permissions, such as &lt;code&gt;UPDATE&lt;/code&gt;, will also only see those records that are allowed by the &lt;code&gt;SELECT&lt;/code&gt; policy. A &lt;code&gt;SELECT&lt;/code&gt; policy cannot have a &lt;code&gt;WITH CHECK&lt;/code&gt; expression, as it only applies in cases where records are being retrieved from the relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea11f118aea185625aef767542a580e19f76285" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SET client_encoding TO&lt;/code&gt;. Setting the client encoding can be done with this SQL command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e9a2e659e09abe2efa2c5be22d40b62c3aee16" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Type=notify&lt;/code&gt; requires that the server binary was built with &lt;code&gt;configure --with-systemd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f17447546dfac5a3cba43658b86d3ae11e9f49a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;UPDATE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands, as well as auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clauses of &lt;code&gt;INSERT&lt;/code&gt; commands. Since &lt;code&gt;UPDATE&lt;/code&gt; involves pulling an existing record and replacing it with a new modified record, &lt;code&gt;UPDATE&lt;/code&gt; policies accept both a &lt;code&gt;USING&lt;/code&gt; expression and a &lt;code&gt;WITH CHECK&lt;/code&gt; expression. The &lt;code&gt;USING&lt;/code&gt; expression determines which records the &lt;code&gt;UPDATE&lt;/code&gt; command will see to operate against, while the &lt;code&gt;WITH CHECK&lt;/code&gt; expression defines which modified rows are allowed to be stored back into the relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4872b905960b3b0bb609a1d1f16d8a8085172d7f" translate="yes" xml:space="preserve">
          <source>Using WAL results in a significantly reduced number of disk writes, because only the log file needs to be flushed to disk to guarantee that a transaction is committed, rather than every data file changed by the transaction. The log file is written sequentially, and so the cost of syncing the log is much less than the cost of flushing the data pages. This is especially true for servers handling many small transactions touching different parts of the data store. Furthermore, when the server is processing many small concurrent transactions, one &lt;code&gt;fsync&lt;/code&gt; of the log file may suffice to commit many transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e62e4e51350449dc0eec4f1e12ec4aa76a1f3f9" translate="yes" xml:space="preserve">
          <source>Using a separate script file is advisable any time you want to use more than a single command in the archiving process. This allows all complexity to be managed within the script, which can be written in a popular scripting language such as bash or perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28cc95da9f9c8ec1f9441e5caff1c654ea239b4" translate="yes" xml:space="preserve">
          <source>Using a simple integer &lt;code&gt;offset&lt;/code&gt; is preferred when defining an abbreviation whose offset from UTC has never changed, as such abbreviations are much cheaper to process than those that require consulting a time zone definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d159535298801ecd67e86d11daf24d3f29bae4e5" translate="yes" xml:space="preserve">
          <source>Using a table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a7d609ae1fc837ff854c4a8fe8b3cbd1349e8b" translate="yes" xml:space="preserve">
          <source>Using an existing graphical frontend tool like pgAdmin or an office suite with ODBC or JDBC support to create and manipulate a database. These possibilities are not covered in this tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0ce3043e87fd971bf85082c10b3ea412051c05" translate="yes" xml:space="preserve">
          <source>Using filter expressions at different nesting levels is also allowed. The following example first filters all segments by location, and then returns high heart rate values for these segments, if available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f87542d489a5d09a003c3d32c1fdd090240fb1a" translate="yes" xml:space="preserve">
          <source>Using huge pages reduces overhead when using large contiguous chunks of memory, as PostgreSQL does, particularly when using large values of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;. To use this feature in PostgreSQL you need a kernel with &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; and &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt;. You will also have to adjust the kernel setting &lt;code&gt;vm.nr_hugepages&lt;/code&gt;. To estimate the number of huge pages needed, start PostgreSQL without huge pages enabled and check the postmaster's anonymous shared memory segment size, as well as the system's huge page size, using the &lt;code&gt;/proc&lt;/code&gt; file system. This might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f4579fb33ddb8969cb60774c58272e5c781549" translate="yes" xml:space="preserve">
          <source>Using just common sense, it appears more convenient to store such data as intervals, rather than pairs of numbers. In practice, it even turns out more efficient in most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8fc95773ce3956bab8c2e8bf2027d9e849d1b1f" translate="yes" xml:space="preserve">
          <source>Using psql on a recently vacuumed or analyzed database, you can issue queries to see the disk usage of any table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65181e02239e5820a5b7c0dec699536af98e9eef" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command recurse to objects owned by other users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3919689ac7e30c1a7b51bdbeb0b298903ed7b06" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command remove objects in other schemas besides the one(s) named.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d956f8965b7e70f75d823768214bbad6a425210" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;\encoding&lt;/code&gt; command in psql. &lt;code&gt;\encoding&lt;/code&gt; allows you to change client encoding on the fly. For example, to change the encoding to &lt;code&gt;SJIS&lt;/code&gt;, type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce95ab1950e8fbb1a63e8b189b58b6a856d611e2" translate="yes" xml:space="preserve">
          <source>Using the configuration variable &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt;. If the &lt;code&gt;client_encoding&lt;/code&gt; variable is set, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b44d852d97da519564a9d99f8e49c858203cdb6" translate="yes" xml:space="preserve">
          <source>Using the operators &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, and &lt;code&gt;EXCEPT&lt;/code&gt;, the output of more than one &lt;code&gt;SELECT&lt;/code&gt; statement can be combined to form a single result set. The &lt;code&gt;UNION&lt;/code&gt; operator returns all rows that are in one or both of the result sets. The &lt;code&gt;INTERSECT&lt;/code&gt; operator returns all rows that are strictly in both result sets. The &lt;code&gt;EXCEPT&lt;/code&gt; operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless &lt;code&gt;ALL&lt;/code&gt; is specified. The noise word &lt;code&gt;DISTINCT&lt;/code&gt; can be added to explicitly specify eliminating duplicate rows. Notice that &lt;code&gt;DISTINCT&lt;/code&gt; is the default behavior here, even though &lt;code&gt;ALL&lt;/code&gt; is the default for &lt;code&gt;SELECT&lt;/code&gt; itself. (See &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;&lt;code&gt;UNION&lt;/code&gt; Clause&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;&lt;code&gt;INTERSECT&lt;/code&gt; Clause&lt;/a&gt;, and &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;&lt;code&gt;EXCEPT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345d4ccffce95dcf05491c18eea8197735fd71fd" translate="yes" xml:space="preserve">
          <source>Using this command, it is possible to either add privileges or restrict one's privileges. If the session user role has the &lt;code&gt;INHERIT&lt;/code&gt; attribute, then it automatically has all the privileges of every role that it could &lt;code&gt;SET ROLE&lt;/code&gt; to; in this case &lt;code&gt;SET ROLE&lt;/code&gt; effectively drops all the privileges assigned directly to the session user and to the other roles it is a member of, leaving only the privileges available to the named role. On the other hand, if the session user role has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, &lt;code&gt;SET ROLE&lt;/code&gt; drops the privileges assigned directly to the session user and instead acquires the privileges available to the named role.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf3833196f5808681a4549e6dae3e11c17ff7d14" translate="yes" xml:space="preserve">
          <source>Using this option is subtly different from writing &lt;code&gt;psql &amp;lt; filename&lt;/code&gt;. In general, both will do what you expect, but using &lt;code&gt;-f&lt;/code&gt; enables some nice features such as error messages with line numbers. There is also a slight chance that using this option will reduce the start-up overhead. On the other hand, the variant using the shell's input redirection is (in theory) guaranteed to yield exactly the same output you would have received had you entered everything by hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb94658d71fedbd45e9091422be0f40e3960ad97" translate="yes" xml:space="preserve">
          <source>Usually, a row reflecting an incorrect entry will have values for only the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615ff5ce2e5448f0eae82299f9e03df2b83f7a7d" translate="yes" xml:space="preserve">
          <source>VACUUM &amp;mdash; garbage-collect and optionally analyze a database</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2bb4ebd8bb3d86c6acc1d3b34b4607a8278459" translate="yes" xml:space="preserve">
          <source>VALUES &amp;mdash; compute a set of rows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df605145d9028810fbbd6bb82ba2cbbdf49fe2f6" translate="yes" xml:space="preserve">
          <source>VALUES Lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49310dbe4a27690da5f29db4c406ef0b0e02e27a" translate="yes" xml:space="preserve">
          <source>Vacuum all databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78bc05489ae0681fdd181a90fe2d3af72c88331" translate="yes" xml:space="preserve">
          <source>Vacuum all four standard tables before running the test. With neither &lt;code&gt;-n&lt;/code&gt; nor &lt;code&gt;-v&lt;/code&gt;, pgbench will vacuum the &lt;code&gt;pgbench_tellers&lt;/code&gt; and &lt;code&gt;pgbench_branches&lt;/code&gt; tables, and will truncate &lt;code&gt;pgbench_history&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558c7ef6cec7040888bc23237bf5bc10ac6c115d" translate="yes" xml:space="preserve">
          <source>Vacuum also allows removal of old files from the &lt;code&gt;pg_xact&lt;/code&gt; subdirectory, which is why the default is a relatively low 200 million transactions. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4af123f2e65a46f53e9a9ee64ca03a1079be929" translate="yes" xml:space="preserve">
          <source>Vacuum maintains a &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; for each table to keep track of which pages contain only tuples that are known to be visible to all active transactions (and all future transactions, until the page is again modified). This has two purposes. First, vacuum itself can skip such pages on the next run, since there is nothing to clean up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb0ba1bca8b404cfdbdb7679f9f4d296fc6f1fa" translate="yes" xml:space="preserve">
          <source>Vacuuming multixacts also allows removal of old files from the &lt;code&gt;pg_multixact/members&lt;/code&gt; and &lt;code&gt;pg_multixact/offsets&lt;/code&gt; subdirectories, which is why the default is a relatively low 400 million multixacts. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac19d033655fd012b97b53639462b257da978e6a" translate="yes" xml:space="preserve">
          <source>Valid Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e5f1bbc3dc93b5ff6072a3bc81757a3ed075d7" translate="yes" xml:space="preserve">
          <source>Valid input for the time stamp types consists of the concatenation of a date and a time, followed by an optional time zone, followed by an optional &lt;code&gt;AD&lt;/code&gt; or &lt;code&gt;BC&lt;/code&gt;. (Alternatively, &lt;code&gt;AD&lt;/code&gt;/&lt;code&gt;BC&lt;/code&gt; can appear before the time zone, but this is not the preferred ordering.) Thus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3fd0054c277594413eaed1c75df986510128d67" translate="yes" xml:space="preserve">
          <source>Valid input for these types consists of a time of day followed by an optional time zone. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;Table 8.11&lt;/a&gt; and &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;Table 8.12&lt;/a&gt;.) If a time zone is specified in the input for &lt;code&gt;time without time zone&lt;/code&gt;, it is silently ignored. You can also specify a date but it will be ignored, except when you use a time zone name that involves a daylight-savings rule, such as &lt;code&gt;America/New_York&lt;/code&gt;. In this case specifying the date is required in order to determine whether standard or daylight-savings time applies. The appropriate time zone offset is recorded in the &lt;code&gt;time with time zone&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844edfde8ce5da216439f5cc862b141254fb9d4a" translate="yes" xml:space="preserve">
          <source>Valid memory units are &lt;code&gt;B&lt;/code&gt; (bytes), &lt;code&gt;kB&lt;/code&gt; (kilobytes), &lt;code&gt;MB&lt;/code&gt; (megabytes), &lt;code&gt;GB&lt;/code&gt; (gigabytes), and &lt;code&gt;TB&lt;/code&gt; (terabytes). The multiplier for memory units is 1024, not 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239bf25206857881980ea876d3982e5ae2994831" translate="yes" xml:space="preserve">
          <source>Valid starting points for standby queries are generated at each checkpoint on the master. If the standby is shut down while the master is in a shutdown state, it might not be possible to re-enter Hot Standby until the primary is started up, so that it generates further starting points in the WAL logs. This situation isn't a problem in the most common situations where it might happen. Generally, if the primary is shut down and not available anymore, that's likely due to a serious failure that requires the standby being converted to operate as the new primary anyway. And in situations where the primary is being intentionally taken down, coordinating to make sure the standby becomes the new primary smoothly is also standard procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d562c59f538b4cf6287a1bc49b7023b220600a" translate="yes" xml:space="preserve">
          <source>Valid time units are &lt;code&gt;us&lt;/code&gt; (microseconds), &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), &lt;code&gt;min&lt;/code&gt; (minutes), &lt;code&gt;h&lt;/code&gt; (hours), and &lt;code&gt;d&lt;/code&gt; (days).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfda311a4ab9af803299c88d82467b20a4636196" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;field&lt;/code&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e71de8159ccd805dfaf84c4abe0cc37c7fd0bef" translate="yes" xml:space="preserve">
          <source>Valid variable names can contain letters, digits, and underscores. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below for details. Variable names are case-sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6495bdc388499bc5f8ab2cec7e4d413da357e199" translate="yes" xml:space="preserve">
          <source>Validate the catalog entries for the specified operator class, so far as the access method can reasonably do that. For example, this might include testing that all required support functions are provided. The &lt;code&gt;amvalidate&lt;/code&gt; function must return false if the opclass is invalid. Problems should be reported with &lt;code&gt;ereport&lt;/code&gt; messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89711f6e0ac15ee4534c22e657dbb299816df29f" translate="yes" xml:space="preserve">
          <source>Validates an invalid number (clears the invalid flag)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a914a2300c495dde9a239ee72a952fef70648b1b" translate="yes" xml:space="preserve">
          <source>Value Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892634b1322b72a29145754cdb909390816e79df" translate="yes" xml:space="preserve">
          <source>Value Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b69a17e345014c4860d42b3ea12bfd1d74a98205" translate="yes" xml:space="preserve">
          <source>Value Expressions: Aggregate Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62258d667ea100846bebdafcf33e6ba0d80bc0cf" translate="yes" xml:space="preserve">
          <source>Value Expressions: Array Constructors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538d0773b42800a1dced9ebd66981d039270223a" translate="yes" xml:space="preserve">
          <source>Value Expressions: Collation Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b3d5a6d9bce4eae0f96433329fd2780b515b1d" translate="yes" xml:space="preserve">
          <source>Value Expressions: Column References</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5899e3893a9e71da04384ff81d2b0668b66cce" translate="yes" xml:space="preserve">
          <source>Value Expressions: Expression Evaluation Rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a33243a5a764268dbc19c7b5d5ffb815f2b2494" translate="yes" xml:space="preserve">
          <source>Value Expressions: Field Selection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2734409ea30f439f8007a816c89fd5d4964498" translate="yes" xml:space="preserve">
          <source>Value Expressions: Function Calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ab5a8d541c803b5a6f5f5baa72444250b7d0c9" translate="yes" xml:space="preserve">
          <source>Value Expressions: Operator Invocations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f7f7098e87803a977afb22b3e716623af90f8e" translate="yes" xml:space="preserve">
          <source>Value Expressions: Positional Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58f459ac2b52cf9d74d05fef53f0cf74dcac929" translate="yes" xml:space="preserve">
          <source>Value Expressions: Row Constructors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c538998fa55638c7ded3a8a283b8e9feb0bd885" translate="yes" xml:space="preserve">
          <source>Value Expressions: Scalar Subqueries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da69c14dd40700afb2c0a8abd86f7b740450e6f" translate="yes" xml:space="preserve">
          <source>Value Expressions: Subscripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cccb4f69d3a8cb038ef6a413bb2c663923cd9fc0" translate="yes" xml:space="preserve">
          <source>Value Expressions: Type Casts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3715da19fdcfeeba7fe50bb93e020a8b25f6a530" translate="yes" xml:space="preserve">
          <source>Value Expressions: Window Function Calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4f8a0decbb4b4fd4371821f1c74ba9a1594ce9" translate="yes" xml:space="preserve">
          <source>Value Storage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2977eb7ab7cb1230619c6002ed4cbbc6cc756fa6" translate="yes" xml:space="preserve">
          <source>Value expressions are used in a variety of contexts, such as in the target list of the &lt;code&gt;SELECT&lt;/code&gt; command, as new column values in &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;, or in search conditions in a number of commands. The result of a value expression is sometimes called a &lt;em&gt;scalar&lt;/em&gt;, to distinguish it from the result of a table expression (which is a table). Value expressions are therefore also called &lt;em&gt;scalar expressions&lt;/em&gt; (or even simply &lt;em&gt;expressions&lt;/em&gt;). The expression syntax allows the calculation of values from primitive parts using arithmetic, logical, set, and other operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114f96aeed1ddb1f81a693ccadc122b00691f706" translate="yes" xml:space="preserve">
          <source>Value that &lt;code&gt;RESET&lt;/code&gt; would reset the parameter to in the current session</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c18b9457473dab8964985ffc208f4a1973292c" translate="yes" xml:space="preserve">
          <source>Value to be assigned to the parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84541e98210f793e8890e82c64afbe27a9c9a73" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;false&lt;/code&gt; literal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f129faa853bacb07b12134ac4fd986301a263b11" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;null&lt;/code&gt; value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a792873148b2fe92c538941fe93212a85f960e9" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;true&lt;/code&gt; literal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8086792911df062e24caa3131a5135743c9b16c" translate="yes" xml:space="preserve">
          <source>Value/Predicate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1cb2e6759dab2334119644e8cf129ac32ce11d" translate="yes" xml:space="preserve">
          <source>Values are stored internally as 64-bit floating point numbers. This means that numbers with more than about 16 significant digits will be truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7efb522647e3ca74917dae6abd528277b3ab9e" translate="yes" xml:space="preserve">
          <source>Values needed to run one PostgreSQL instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d380e11f26f75eaba033d74818adbe55ddca1de" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; data types can be cast to &lt;code&gt;money&lt;/code&gt;. Conversion from the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; data types can be done by casting to &lt;code&gt;numeric&lt;/code&gt; first, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a94b34531e2a116d1ab90afc1f71919f7dc0067" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;pg_mcv_list&lt;/code&gt; can be obtained only from the &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b87bdbb02446940728e896c08b8825bde2b21b0" translate="yes" xml:space="preserve">
          <source>Values of this domain are allowed to be null. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29119abb7de6b63218065ed67e351db8dc51728" translate="yes" xml:space="preserve">
          <source>Values of this domain are prevented from being null (but see notes below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d30cecbfdbc76e7857e49ac92bd25f13ef34d9b" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;character&lt;/code&gt; are physically padded with spaces to the specified width &lt;code&gt;n&lt;/code&gt;, and are stored and displayed that way. However, trailing spaces are treated as semantically insignificant and disregarded when comparing two values of type &lt;code&gt;character&lt;/code&gt;. In collations where whitespace is significant, this behavior can produce unexpected results; for example &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; returns true, even though &lt;code&gt;C&lt;/code&gt; locale would consider a space to be greater than a newline. Trailing spaces are removed when converting a &lt;code&gt;character&lt;/code&gt; value to one of the other string types. Note that trailing spaces &lt;em&gt;are&lt;/em&gt; semantically significant in &lt;code&gt;character varying&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; values, and when using pattern matching, that is &lt;code&gt;LIKE&lt;/code&gt; and regular expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0e8ddc497a1b9c951f5949c5d9e1b70b9a22cd" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;path&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80b51f9c7fc6e7a8b7e3fe299274555e9a2ae02" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;polygon&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a16467bfe399e24f49eb7fdb667ccec5d8723e" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER DATABASE&lt;/code&gt; and &lt;code&gt;ALTER ROLE&lt;/code&gt; are applied only when starting a fresh database session. They override values obtained from the configuration files or server command line, and constitute defaults for the rest of the session. Note that some settings cannot be changed after server start, and so cannot be set with these commands (or the ones listed below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818a4a9f523da08f985a8d7bb8387b916781ef1a" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER SYSTEM&lt;/code&gt; will be effective after the next server configuration reload, or after the next server restart in the case of parameters that can only be changed at server start. A server configuration reload can be commanded by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, running &lt;code&gt;pg_ctl reload&lt;/code&gt;, or sending a SIGHUP signal to the main server process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2a94acd55e77d304a8881179a17d08010c723b" translate="yes" xml:space="preserve">
          <source>Values to be inserted into a table are converted to the destination column's data type according to the following steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543a387448ddbbf661178992c3adaa7b069168fb" translate="yes" xml:space="preserve">
          <source>Values: 0 - Without salt. Dangerous! 1 - With salt but with fixed iteration count. 3 - Variable iteration count. Default: 3 Applies to: pgp_sym_encrypt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85fa17c91ce0d6924e2ed0119f352ea3f8fb549" translate="yes" xml:space="preserve">
          <source>Values: 0 - no compression 1 - ZIP compression 2 - ZLIB compression (= ZIP plus meta-data and block CRCs) Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52218ba89357173a5dfb8618986a1e8fdfb757a3" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922303e052dbc79ebb5e801b79cffb9186efe35c" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe411494b7a8541ba3eda983d9fa94b6f7dde40" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f52252bc49eca143f466418a46bf231d397765" translate="yes" xml:space="preserve">
          <source>Values: 0, 1-9 Default: 6 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631bb9d3f376659e6d97cddb0d8676370c2c08b3" translate="yes" xml:space="preserve">
          <source>Values: bf, aes, aes128, aes192, aes256 Default: use cipher-algo Applies to: pgp_sym_encrypt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d1d35bfb5be3f756eb7a018b33d9e394f847ba" translate="yes" xml:space="preserve">
          <source>Values: bf, aes128, aes192, aes256 (OpenSSL-only: &lt;code&gt;3des&lt;/code&gt;, &lt;code&gt;cast5&lt;/code&gt;) Default: aes128 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777af837f1de8927748898b65d1060bc773bad7b" translate="yes" xml:space="preserve">
          <source>Values: md5, sha1 Default: sha1 Applies to: pgp_sym_encrypt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b72534c52ce05719721c1bfff6524b4aef3cf8" translate="yes" xml:space="preserve">
          <source>Variable interpolation will not be performed within quoted SQL literals and identifiers. Therefore, a construction such as &lt;code&gt;':foo'&lt;/code&gt; doesn't work to produce a quoted literal from a variable's value (and it would be unsafe if it did work, since it wouldn't correctly handle quotes embedded in the value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20578601408732c8ea02e8d928be3d22ba16637" translate="yes" xml:space="preserve">
          <source>Variables that control psql's behavior generally cannot be unset or set to invalid values. An &lt;code&gt;\unset&lt;/code&gt; command is allowed but is interpreted as setting the variable to its default value. A &lt;code&gt;\set&lt;/code&gt; command without a second argument is interpreted as setting the variable to &lt;code&gt;on&lt;/code&gt;, for control variables that accept that value, and is rejected for others. Also, control variables that accept the values &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt; will also accept other common spellings of Boolean values, such as &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d1d14c3d8bef73e900f87a2c49118ec1795b0b" translate="yes" xml:space="preserve">
          <source>Various other settings related to &amp;ldquo;semaphore undo&amp;rdquo;, such as &lt;code&gt;SEMMNU&lt;/code&gt; and &lt;code&gt;SEMUME&lt;/code&gt;, do not affect PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6240cba4fe3aa73d43764309d30fb6d3d037a4" translate="yes" xml:space="preserve">
          <source>Various parameters have been mentioned above in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt; and &lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;Section 26.5.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5b3325956fac55ce90bb38fba311678783c4a5a" translate="yes" xml:space="preserve">
          <source>Verification is performed using the same procedures as those used by index scans themselves, which may be user-defined operator class code. For example, B-Tree index verification relies on comparisons made with one or more B-Tree support function 1 routines. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details of operator class support functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875530bb85a9bc9a572c1b81ee549fe16ccb6d4b" translate="yes" xml:space="preserve">
          <source>Version and Platform Compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9929f1f28bbd8834745a088bfee2450b12d5d8" translate="yes" xml:space="preserve">
          <source>Version name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2597e3332e662024a1086db859f74acc32e53a21" translate="yes" xml:space="preserve">
          <source>Version name for the extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29156f5ef29fca0492cf46682a435025e1953ccd" translate="yes" xml:space="preserve">
          <source>Version number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637ea0ea7f40808c77700c1c4f68ba0087e0490c" translate="yes" xml:space="preserve">
          <source>Version of SSL in use, or NULL if SSL is not in use on this connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a77b4ce23e6a598792ebba9c5fa53b934c43a3" translate="yes" xml:space="preserve">
          <source>Version of the server (optional)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2002aefc5b11f637b7466ee1a13c20a9e6171391" translate="yes" xml:space="preserve">
          <source>Vertical tab (ASCII 11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe85f9993f6a26e677373400348d89af1072a3c" translate="yes" xml:space="preserve">
          <source>Very long-lived write transactions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f98f07baa783307d6eeb3e956be798331b0ca1" translate="yes" xml:space="preserve">
          <source>Victor Wagner &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Cryptocom LTD</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d6b8a691f0d907efa971075035a145a937381ac" translate="yes" xml:space="preserve">
          <source>Vietnamese</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0400b0f3aafc0bb49249e45dc8694f8cdb7fdb" translate="yes" xml:space="preserve">
          <source>View Name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ef89bbb476e8982fc98b280a43e4c9b99ae10c" translate="yes" xml:space="preserve">
          <source>View all the locks currently outstanding, all the locks on relations in a particular database, all the locks on a particular relation, or all the locks held by a particular PostgreSQL session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe38ed5293f170b37453ef21637367ceda0f0b8" translate="yes" xml:space="preserve">
          <source>View definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f66a08ed3a699a66860df21a573d573a238197" translate="yes" xml:space="preserve">
          <source>Viewing Locks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43c0cfc302cb10077693176e5e074e56b5aa3e7" translate="yes" xml:space="preserve">
          <source>Views can be used in almost any place a real table can be used. Building views upon other views is not uncommon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e39d0decda3838416b25ba5106b0efbe06c4023" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction targeted by the lock, or null if the target is not a virtual transaction ID</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811a0b30888086bd25c748477319220487f25d50" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction that is holding or awaiting this lock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4ba211a7e69b2432d26b396c51c526655c765b" translate="yes" xml:space="preserve">
          <source>Virtual transaction ID (backendID/localXID)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588c142955d93338aefe3c6dd59baf541f7f60c7" translate="yes" xml:space="preserve">
          <source>WAL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1c95a48c1cec72e7cde457f1faf1b2311bbdfd" translate="yes" xml:space="preserve">
          <source>WAL Configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc7b27e2b628547b61cdbe01ad5b4d44572d2c25" translate="yes" xml:space="preserve">
          <source>WAL Internals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd824454d5f714596ff079dcd401902ac18dd100" translate="yes" xml:space="preserve">
          <source>WAL also makes it possible to support on-line backup and point-in-time recovery, as described in &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;. By archiving the WAL data we can support reverting to any time instant covered by the available WAL data: we simply install a prior physical backup of the database, and replay the WAL log just as far as the desired time. What's more, the physical backup doesn't have to be an instantaneous snapshot of the database state &amp;mdash; if it is made over some period of time, then replaying the WAL log for that period will fix any internal inconsistencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4adb460b94535160dc5514c2f3243fad9448dc8" translate="yes" xml:space="preserve">
          <source>WAL file control commands will not work during recovery, e.g. &lt;code&gt;pg_start_backup&lt;/code&gt;, &lt;code&gt;pg_switch_wal&lt;/code&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2801865ae804dc7013c1520108c058b7f6c30a" translate="yes" xml:space="preserve">
          <source>WAL is automatically enabled; no action is required from the administrator except ensuring that the disk-space requirements for the WAL logs are met, and that any necessary tuning is done (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c356b4888573bfd6af6c126f717a43c96a7d21b4" translate="yes" xml:space="preserve">
          <source>WAL location at which to start reading. The default is to start reading the first valid log record found in the earliest file found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4873b80cfe4fe4ff618ed5cd62f9b47043675a98" translate="yes" xml:space="preserve">
          <source>WAL logs are stored in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory, as a set of segment files, normally each 16 MB in size (but the size can be changed by altering the &lt;code&gt;--wal-segsize&lt;/code&gt; initdb option). Each segment is divided into pages, normally 8 kB each (this size can be changed via the &lt;code&gt;--with-wal-blocksize&lt;/code&gt; configure option). The log record headers are described in &lt;code&gt;access/xlogrecord.h&lt;/code&gt;; the record content is dependent on the type of event that is being logged. Segment files are given ever-increasing numbers as names, starting at &lt;code&gt;000000010000000000000000&lt;/code&gt;. The numbers do not wrap, but it will take a very, very long time to exhaust the available stock of numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa55cdd1f960e02b270cbf81d5d051cfdadab50" translate="yes" xml:space="preserve">
          <source>WAL record construction can be canceled between any of the above steps by calling &lt;code&gt;GenericXLogAbort(state)&lt;/code&gt;. This will discard all changes to the page image copies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0756aa72f12460643a103d61be69d319455e3e" translate="yes" xml:space="preserve">
          <source>WAL records are appended to the WAL logs as each new record is written. The insert position is described by a Log Sequence Number (LSN) that is a byte offset into the logs, increasing monotonically with each new record. LSN values are returned as the datatype &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt;. Values can be compared to calculate the volume of WAL data that separates them, so they are used to measure the progress of replication and recovery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85207d0ebcdb97d98e8f6e4d0d99438888bd2967" translate="yes" xml:space="preserve">
          <source>WAL segments that cannot be found in the archive will be sought in &lt;code&gt;pg_wal/&lt;/code&gt;; this allows use of recent un-archived segments. However, segments that are available from the archive will be used in preference to files in &lt;code&gt;pg_wal/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670936924f36e223ed7101a5577c1a95fc54d46f" translate="yes" xml:space="preserve">
          <source>WIDE Project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c238a027f49a7325c81b6fcad74df656598a8d1" translate="yes" xml:space="preserve">
          <source>WITH Queries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c72223105cadaf945f1907d7cca51ac5e11a9a" translate="yes" xml:space="preserve">
          <source>WITH Queries: Data-Modifying Statements in WITH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a33ebe9b068dc28117b34d20aebb31ffcc15d4" translate="yes" xml:space="preserve">
          <source>WITH Queries: SELECT in WITH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c1b6ed1901fdc76c7650d703ade5c43c418ba9" translate="yes" xml:space="preserve">
          <source>Wait Event Name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfecc9a9e7dbc0650b752c6d733646645d5d3acd" translate="yes" xml:space="preserve">
          <source>Wait Event Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1dd06a2c6e4048cfa872860c567be1efcd7c2b" translate="yes" xml:space="preserve">
          <source>Wait event name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d176395064480d6a06595b0b0b2f5082eb7376" translate="yes" xml:space="preserve">
          <source>Wait event type name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d814f74425edb745c0f36dde73fdb494bc74e548" translate="yes" xml:space="preserve">
          <source>Wait for the operation to complete. This is supported for the modes &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;restart&lt;/code&gt;, &lt;code&gt;promote&lt;/code&gt;, and &lt;code&gt;register&lt;/code&gt;, and is the default for those modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd618adedec17e6469d06a5651fc5072c2cb8b33" translate="yes" xml:space="preserve">
          <source>Waiting a new WAL segment created by copying an existing one to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b263c588c8a9b03696257b8f7a21247383c1982" translate="yes" xml:space="preserve">
          <source>Waiting during base backup when throttling activity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62ddea7d6b1ce8c2e8479d95982f02c6ba59204" translate="yes" xml:space="preserve">
          <source>Waiting for I/O a subtransaction buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b267052de8e5af8879f9629c8e82adc667c91f" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a clog (transaction status) buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbc9325a896b8fd7a70abd45c23e5faa43a813b" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a data page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a704e423e485baf39382a4b61985268bdbe9816" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact offset buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567d45c24a3c7adfee8a01424ebb678b04e38b31" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact_member buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5580fedd445b2fc16dfac5701d5e862d784f551" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a replication slot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eda0ee8cd8803033853db58b70b41cefa970a11" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an async (notify) buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abba94e34c19d07b07ce80f08b906e7d03736163" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an oldserxid buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89be09a6258d69b36b9e65eae64f0556be147bdd" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on commit timestamp buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4c5fd8e7b43af2a409040c541ebf56ba090a42" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage during a checkpoint or database shutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a795b2d3551897df90d4dc06b1de18f13711e4ef" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage following a page write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f43eca07331b8b4d48d83deb11f1187e3222c57" translate="yes" xml:space="preserve">
          <source>Waiting for SSL while attempting connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea499b505dfbcd4c53729e4e78e2f60a5e0dfa9" translate="yes" xml:space="preserve">
          <source>Waiting for TBM shared iterator lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f5fe1f96a90cf6f89027f31d1f8fff440aadd4" translate="yes" xml:space="preserve">
          <source>Waiting for WAL buffers to be written to disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f443781f65a70ffb9eadd8d00b62bec73ed570" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from a stream at recovery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0b3cbfc2a21133aecfeb0025076a64608b1920" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from any kind of source (local, archive or stream) at recovery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d04b47f170d0a017b5a8840ab7fd732b861077" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to be flushed in WAL sender process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35934124d45c41b66cac20041da4f7acc6c09234" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to reach stable storage during bootstrapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2347bde945d2a1ac488cc00b97f03eb25edf886c" translate="yes" xml:space="preserve">
          <source>Waiting for a WAL file to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b64554949a794fe8845162525251d4f832f615ae" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe85ec49696086b315ad919340a19fe4137e208" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86020a20952ecd2adfecfb302ee0a5d59b93de9" translate="yes" xml:space="preserve">
          <source>Waiting for a newly created timeline history file to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe40708f510b2425a56df962113c332035d1ebb" translate="yes" xml:space="preserve">
          <source>Waiting for a newly initialized WAL file to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99635b6aefa182932d6d8ac35e0fadee6f58362" translate="yes" xml:space="preserve">
          <source>Waiting for a read during a file copy operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b1c7ee0bc940e8ff954a9dc21e088de25e160e7" translate="yes" xml:space="preserve">
          <source>Waiting for a read during recheck of the data directory lock file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae33919f01ffd845bcfe367fc1ce42274883982" translate="yes" xml:space="preserve">
          <source>Waiting for a read during reorder buffer management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b0b22bdd6995f4c8facc815a7958bc78a4df11" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0a57a09d41e3dd4b6c43069589a550983cdfbc" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a buffered file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d7f43727962110ab0f659fc3569b92c09e1e4c3" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a relation data file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5434d2dc36bc6e479cf33762dac4cdbbad013ab" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a replication slot control file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8e0677108348e6cb25c6439df96979d79370b4" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a timeline history file during walsender timeline command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb87f9075b737550478460fe92ea81d5a8e44f1b" translate="yes" xml:space="preserve">
          <source>Waiting for a read from the control file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13a29b976f4d9243fad247169f0d2821ffe4aa3" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a logical mapping during reorder buffer management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94303f5f840422428a360dcb8cf874ed8d7188d8" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a serialized historical catalog snapshot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab04c92d0fda0e18fe65ce97ed4f4a6278c8bda" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a timeline history file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e334fe7275467445ed31f445bb0d89fc42ea11" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a two phase state file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f5541db52af4f2f83a5aff926cb570ad37ea9a" translate="yes" xml:space="preserve">
          <source>Waiting for a read of an SLRU page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3bd50798c846431f5c99cd295ac155af5c3628" translate="yes" xml:space="preserve">
          <source>Waiting for a read of the relation map file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653fed415a1560b6108907354641e1d02603af7f" translate="yes" xml:space="preserve">
          <source>Waiting for a read when creating a new WAL segment by copying an existing one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b50fdc4779713a2250434752ac096729a9b9e3d" translate="yes" xml:space="preserve">
          <source>Waiting for a read while adding a line to the data directory lock file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764d5f916fab0f4117b0be0cbd2e731f54a839fb" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be extended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4550cc931e0694f7888372505856f6d3c09005" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196784ad8df1886187ea3f9758445468708682d5" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6dd21f72774436bf4201a14e0bef224865f318" translate="yes" xml:space="preserve">
          <source>Waiting for a replication origin to become inactive to be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51efea4b8a37a030875e22581e67a71b2c0b921b" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage while restoring it to memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3360d7e3a23f4e402f25182926d976cf44db39f3" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199501dcba57d5c5271ac74b95e191bf236cb733" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot to become inactive to be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863f50afd3c1563b85fb65b1a42b5b1ae705dfb7" translate="yes" xml:space="preserve">
          <source>Waiting for a serialized historical catalog snapshot to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66c979e7938ef913ce663fc865d33095c21de87" translate="yes" xml:space="preserve">
          <source>Waiting for a snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e483dd61b2e17583a1594dcda6e591f3ac3e513f" translate="yes" xml:space="preserve">
          <source>Waiting for a timeline history file received via streaming replication to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2853dc0fde120da340c58317ae296218c97a1c94" translate="yes" xml:space="preserve">
          <source>Waiting for a transaction to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157ed476e7697e7a1cadb6976248a98472434e0a" translate="yes" xml:space="preserve">
          <source>Waiting for a two phase state file to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a6ffd0d68eb37b547774e0919378d07b939300" translate="yes" xml:space="preserve">
          <source>Waiting for a write during a file copy operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32492adb76e65f3fe0a6e72f8951521baef55fec" translate="yes" xml:space="preserve">
          <source>Waiting for a write during reorder buffer management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba450cd205c3dd8e5640b537d57ff27410f1253d" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a WAL page during bootstrapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8705f070fa23d795eb616cd9e31b50566ca67cc3" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a newly created timeline history file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1760404310ebeadc931ff2c4124968d47b107a" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a serialized historical catalog snapshot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37297f957be6d38118691421e743bea3d403b7c" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a timeline history file received via streaming replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be49d8c0c1b4685519fdd85850348ecd44be9749" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a two phase state file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53aeb8cdb283bc1d47f777ad7b24ec161b846ee7" translate="yes" xml:space="preserve">
          <source>Waiting for a write of an SLRU page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1465353979b7faf0b115892be0b212bb41254cd5" translate="yes" xml:space="preserve">
          <source>Waiting for a write of logical rewrite mappings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262bd0eebb54ede821d500429e0af687cc713958" translate="yes" xml:space="preserve">
          <source>Waiting for a write of mapping data during a logical rewrite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9bd51d9cae106255dd99b45134793e8fe5ca42" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251086a074c439cbe743d7c3bb152d463c21bb7b" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a buffered file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b47e588513cf133674bba56df9090d2883dd101" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a relation data file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299b50c23e70d2d279fbb4a9694963e890bfee88" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a replication slot control file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26411046b5f9c53b1644f439224f22b40020be7" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the control file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75228f5ef22ab61abd11733484809e768dbf43c" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the relation map file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4dc5be0a61a88b12bee2628ecf09d1b773c4c35" translate="yes" xml:space="preserve">
          <source>Waiting for a write to update the control file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610d140534d98776f4ceaac82401a792839d1b45" translate="yes" xml:space="preserve">
          <source>Waiting for a write when creating a new WAL segment by copying an existing one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e6f804ba2f5656426f9c3ccd5ba5ebd95a87d4" translate="yes" xml:space="preserve">
          <source>Waiting for a write while adding a line to the data directory lock file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0696197c3d3d4067137d8fe428f74da050d0c268" translate="yes" xml:space="preserve">
          <source>Waiting for a write while creating the data directory lock file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa5fc8fd5be1292b1cb40d3c83b93e702c367e3" translate="yes" xml:space="preserve">
          <source>Waiting for a write while initializing a new WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734b565bcfa5ca2fc97c773bf856a02689576213" translate="yes" xml:space="preserve">
          <source>Waiting for action on logical replication worker to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1613179ffe75070217dd36a5f12906b74afc2ab" translate="yes" xml:space="preserve">
          <source>Waiting for activity from child process when executing &lt;code&gt;Gather&lt;/code&gt; node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6126b8aaccca6a7a91b7220ca50f325ae2373721" translate="yes" xml:space="preserve">
          <source>Waiting for an asynchronous prefetch from a relation data file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ceade57b19a1c5eb1845d4c821b850186cc2839" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate a hash table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae35732e2bfced9301c45c422a5bb06a774ed38" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate more batches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb366154c77101be0d76ea7c08df266aa7b65be9" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate the initial hash table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf1c258cd35461c3f1727fa0a9eacebdd04769c" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to decide on future batch growth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07635fd669dda3c946a486e6f1b23b449441353e" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to finish allocating more buckets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e246fb175c5f149773d0331209040875fd42182" translate="yes" xml:space="preserve">
          <source>Waiting for an immediate synchronization of a relation data file to stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d64a2fc217b281e035d77c750609359d54019d" translate="yes" xml:space="preserve">
          <source>Waiting for an update to the control file to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf18468a43ecee10b4dea21dad9d1ae0888b697" translate="yes" xml:space="preserve">
          <source>Waiting for any activity when processing replies from WAL receiver in WAL sender process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bad1ed6561f03baa1813e29bc1d6a9f97d039b" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to shut down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b78b2404a9c8efe7417660102cb11bcbc99fa4" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to start up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121ce51ab6e249cf929aa9e0635dd5196c724d55" translate="yes" xml:space="preserve">
          <source>Waiting for changes to a relation data file to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aedff25c55dbcd34ea828efe5df0cac10c04231" translate="yes" xml:space="preserve">
          <source>Waiting for confirmation from remote server during synchronous replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e096887a303519506fcd67516869ace11ad3e59e" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while adding a line to the data directory lock file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0ab1a16e2329bfa52c27e76aa50ab788d415cf" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while assigning WAL sync method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a67fcfeb93618a5687879b86795e36261b23961" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while creating the data directory lock file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f817023f7f1aeed83afe73b277506f04bbf5f51" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to clear transaction id at transaction end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad12c44c511affe8e5b28dfe797e5442cb69ba2" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to update transaction status at transaction end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6303bec3edc9303d1de1e17ffbef9d10deeb2ec7" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to change state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a171ef7b847c02147b5330baa42032a3b728b099" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to send data for initial table synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1252663514ce3e310a8ccaa53abc308558932c1" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage during a checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754897ce0cd2e99fe42e75806589d9d45f48b612" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcc4581e90866cae66b033e94adc36e9d35b43d" translate="yes" xml:space="preserve">
          <source>Waiting for mapping data to reach stable storage during a logical rewrite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8552e94ff493c563b97bc367629ad56d62866bf" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish hashing the inner relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11479178e59844fd7fe15f1ce4eb490d0773d60" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish inserting tuples into new buckets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c11b60c1a40d4f8d29e90353a8affe9075ec7f0" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish loading a hash table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5413b25ebacbf60f6298ddfd13544237708b4afd" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish partitioning the outer relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ddf8230dce1afc618c7942a19d13a4e06fbab65" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finishing repartitioning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ddcd3a1c9792343c59de081cc3c348d37cc1494" translate="yes" xml:space="preserve">
          <source>Waiting for other process to be attached in shared message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1e4d605c6dfe012718f5d6b6342a2c1167a5ba" translate="yes" xml:space="preserve">
          <source>Waiting for parallel &lt;code&gt;CREATE INDEX&lt;/code&gt; workers to finish heap scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0e5b890525a78c621a8bd9247fc1bb58a1d9d0" translate="yes" xml:space="preserve">
          <source>Waiting for parallel bitmap scan to become initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d8ebcdd8df7afcbc1ca990a46b504e44b8711d" translate="yes" xml:space="preserve">
          <source>Waiting for parallel query dynamic shared memory allocation lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2ad8cbb3533dbd2f7a9b18414fee3c1da25764" translate="yes" xml:space="preserve">
          <source>Waiting for parallel workers to finish computing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d884014cf602749f289dbc7c7fc61acad84fa09d" translate="yes" xml:space="preserve">
          <source>Waiting for standby promotion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb227e761e8b1bc97dcd2f57c98b273168fa6eb" translate="yes" xml:space="preserve">
          <source>Waiting for startup process to send initial data for streaming replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de10813baf47bfe4c27cf4c7969243299b919ed" translate="yes" xml:space="preserve">
          <source>Waiting for the control file to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681bd23f805b6da445bd3d82fc4a46addc600e13" translate="yes" xml:space="preserve">
          <source>Waiting for the page number needed to continue a parallel B-tree scan to become available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c939d0ba9c27dac2f7d8824016725fedd49ef586" translate="yes" xml:space="preserve">
          <source>Waiting for the relation map file to reach stable storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7be20b27094dae3303ee1fadc67011cd3751be8" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to establish connection to remote server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6df6362589c923614f910bed59cf34ff945324" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to receive data from remote server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb83e82efa5858b6db8ad5949e98eced2a90463a" translate="yes" xml:space="preserve">
          <source>Waiting in an extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb270e93605e72d07d6bcedd0737f5a39e22df0" translate="yes" xml:space="preserve">
          <source>Waiting in background writer process, hibernating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88eefbfbae399c6feea1548c69357a5e9736f5ab" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL receiver process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375265f881add8dd9c33130678344167b52a9588" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL sender process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e173311caac73154fc23d76aed32502c099d08" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL writer process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7acb76585737d883d007ddb658d4cfd89597eb50" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of autovacuum launcher process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6e41b3df7e89238ff4283ef4198a69ebe76109" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of background writer process background worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d193be75953171ebbce3b3db2cde50e60c132491" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of checkpointer process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db02418c7eb01a5eb05765091cb30a31f71aa88d" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical apply process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a745dd84bf90f7ae367a6c7dc035147ac68293" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical launcher process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0772397293bff630517da7bd7ffb1ab81b17f5" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of syslogger process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f59b1a36db7407d20232e85176d4c1a23692f4" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the archiver process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212f0884ddfbc91689a2a97c09aafbcd3f389116" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the statistics collector process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4ceca9ff1b34dd3a21d5a1be2bf8a9aa711a70" translate="yes" xml:space="preserve">
          <source>Waiting in process that called &lt;code&gt;pg_sleep&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0184a02009f44f4d2a88cbd98d9dfe8231fceb5e" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of finished serializable transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453521c4c18069faa9fd0afad3d83ca7731d1096" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a non-relation database object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e200aae0e4f2353a2c19cd08c7d6ee7ce7f912" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf9078aaa0a5a46ce631268ce4c46ea2cb0e198" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d61e9ac29e8e57ca0786825f9ae212af87d782" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on page of a relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60529117b6f828f517a439e0152cfca12a03780e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a pin on a buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dff15d412549524e8b05e08b4e658a978321307" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a speculative insertion lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1d92a10ff6e0f42c232bac9cd39b9515b5e1f1" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a user lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feee645b171eddc5255ea3172e0b6eaae2f3531e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a virtual xid lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cff112c15e1e7f938ee8722e01003e541c3a9b9" translate="yes" xml:space="preserve">
          <source>Waiting to acquire an advisory user lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b782a596b50a85963931c1ce8ff87a36ab9e82" translate="yes" xml:space="preserve">
          <source>Waiting to add a message in shared invalidation queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30c5b64b9088c9bea1b788c2d9cad490d0feadc" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine locks for backends, or waiting to join or exit a locking group (used by parallel query).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4234f3768471935481a7a5ac70e216c3b3196d0a" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine predicate lock information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922ece807fb5d0e3eca745374502101b8e2f9883" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign a transaction id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df1187e247ec9e3885764b731ccac5a81693366" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign an OID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e78f99b93b8582ddda9533616d35bad0cb3435" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or exchange a chunk of memory or update counters during Parallel Hash plan execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea0084a8686cdd126b6dc0b70e3bb510372f940" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or free a replication slot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392b0fcbf6923b50ad00d9bcdf711922567f010a" translate="yes" xml:space="preserve">
          <source>Waiting to apply WAL at recovery because it is delayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417e2e4d470ba2ea215e899c1f2f47a808b6cd1d" translate="yes" xml:space="preserve">
          <source>Waiting to associate a data block with a buffer in the buffer pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5eba1b1476e67df8c9026fe8a8423164cbbbaf" translate="yes" xml:space="preserve">
          <source>Waiting to choose the next subplan during Parallel Append plan execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11402cb956b4c4ad7b4f3ee48f5957e1d0e2837b" translate="yes" xml:space="preserve">
          <source>Waiting to create or drop the tablespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef13562f4466bb31b5bf871e5d3f767784c48032" translate="yes" xml:space="preserve">
          <source>Waiting to ensure that the table it has selected for a vacuum still needs vacuuming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2e90490a1d7b7d270317787f40bff2e1d72ee9" translate="yes" xml:space="preserve">
          <source>Waiting to execute &lt;code&gt;txid_status&lt;/code&gt; or update the oldest transaction id available to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905b59818613073e2e260c6b0fb7d68bf3c39843" translate="yes" xml:space="preserve">
          <source>Waiting to extend a relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b7f54188ceea3dc5def955dc47ae1f28373839" translate="yes" xml:space="preserve">
          <source>Waiting to find or allocate space in shared memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb53c073cc374cfb75fd8b826e6b4d7eb6cc9003" translate="yes" xml:space="preserve">
          <source>Waiting to get a snapshot or clearing a transaction id at transaction end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e384d346b49ba85024e06c032fcf3ccf1737b636" translate="yes" xml:space="preserve">
          <source>Waiting to get the start location of a scan on a table for synchronized scans.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6beee315605623099d06c2371ae56da6b46cc7" translate="yes" xml:space="preserve">
          <source>Waiting to insert WAL into a memory buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4ce59b2db271f1abfb91f4099370c7dcadc0ae" translate="yes" xml:space="preserve">
          <source>Waiting to manage fsync requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3141c5d05c342451c8644a34df11be83dd434ad" translate="yes" xml:space="preserve">
          <source>Waiting to manage space allocation in shared memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97c8584b996285f48aeab64ef02658839acbba9" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a list of locks held by serializable transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8589a1b8c66d6f8e4debafdd099f1a4b71a5b13" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a serializable transaction in a parallel query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ade432e382335fbb1d6fb86bda4500ee8c2cbb" translate="yes" xml:space="preserve">
          <source>Waiting to perform checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1908bfbabea7a0ab1bbde739ebc0330fc7517b79" translate="yes" xml:space="preserve">
          <source>Waiting to read data from the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dd640e8c1d54ebf01054c0befd12ca4f14b63e" translate="yes" xml:space="preserve">
          <source>Waiting to read or record conflicting serializable transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0afe38ebe7d995583b3d1a5cd94b6fbc8cf1b845" translate="yes" xml:space="preserve">
          <source>Waiting to read or truncate multixact information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a018a1a15593b5af23414939d50aec3fcb48c5cb" translate="yes" xml:space="preserve">
          <source>Waiting to read or update background worker state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea27617060567594092b7422c38330bfc2e5ee2" translate="yes" xml:space="preserve">
          <source>Waiting to read or update dynamic shared memory state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b94e34a6c9a38b9de8ddbf38266ea41569caa0e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about synchronous replicas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be479f3c24eeb847b5e44a9bf4f341c29d1834b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact member mappings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548a78a89a3c004e9ad475a70fb6f1bb50c1151e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact offset mappings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed18ac469b6f870e80be0efbf5c76a4d5c79b754" translate="yes" xml:space="preserve">
          <source>Waiting to read or update notification messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d4dfb568ccc6112df58f601dc5c426ad5d62a8" translate="yes" xml:space="preserve">
          <source>Waiting to read or update old snapshot control information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce0cc66a076e07f94b764161b2bddd57ada2509" translate="yes" xml:space="preserve">
          <source>Waiting to read or update replication slot state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff67315163276ff44c96c0a78a1830dd666732b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared multixact state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79ef3c6f580409e99c1e495bc8e24c202fbe7ed" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared notification state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af64ba8ecf87cac9594cd6dc3c61c2e7ddf060d1" translate="yes" xml:space="preserve">
          <source>Waiting to read or update sub-transaction information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb0edf32466a645cdde40c21227abb2a0bb1f30" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the control file or creation of a new WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221da797b029fb896c5fbaed99fd507a4ef2a941" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the fast-path lock information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9baf36ef5d66bb0ea1e99230d14314cf70bc406" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the last value set for the transaction timestamp.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f6ffef563dec9ba786a7f233d5003f5ed45d14" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the replication progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="defd9a9d465fec9edd19efb8c557ca9acbf7364b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the state of prepared transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc7e6836006d3d5cbb7a9151c1a348063bbcc88" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction commit timestamps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22fb7890af933754ae7b2b3d81b6bd6e23c2cc52" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1691bd5ffa74ce0764d59f613b874fce42907700" translate="yes" xml:space="preserve">
          <source>Waiting to read or update vacuum-related information for a B-tree index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7909f678b84800f1b2a16328d0f20ff93a738a0c" translate="yes" xml:space="preserve">
          <source>Waiting to read or write a data page in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3f3c6d87b25a2add5f41dc054490a6748416d8" translate="yes" xml:space="preserve">
          <source>Waiting to read or write relation cache initialization file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e29e2fa37b4e49226f461d31f27cc492afa177" translate="yes" xml:space="preserve">
          <source>Waiting to read while creating the data directory lock file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22b6a17e9f6b4570d83c86bfc0b1331afbfa69c0" translate="yes" xml:space="preserve">
          <source>Waiting to receive bytes from a shared message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce53a35add68653a7082475749be3845de4e91c" translate="yes" xml:space="preserve">
          <source>Waiting to replace a page in WAL buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b17dffde0ea5035f1032f34d22df0ea10ab951" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or remove messages from shared invalidation queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f507f65bfda2fa748e9dfb44f6b949cbab52bf9" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or store information about serializable transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9928fb30a8b9bafde30f4c1a7932ab2be3ad802" translate="yes" xml:space="preserve">
          <source>Waiting to send bytes to a shared message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352defc191b1b37d8d934ce574b79689999451d7" translate="yes" xml:space="preserve">
          <source>Waiting to setup, drop or use replication origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b1822a05f8be538a4edd0d27d811178799d3aa" translate="yes" xml:space="preserve">
          <source>Waiting to update the &lt;code&gt;postgresql.auto.conf&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7ad4b1674906a82b48581d682f5005d47dd119" translate="yes" xml:space="preserve">
          <source>Waiting to update the relation map file used to store catalog to filenode mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc204f5803f3077a290dca7bb374395f034529e" translate="yes" xml:space="preserve">
          <source>Waiting to write a protocol message to a shared message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0728d153f9f18004a22e4fb271924454b6a556" translate="yes" xml:space="preserve">
          <source>Waiting to write data to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a1974782cb646a2959736cb6599731cefd99f2" translate="yes" xml:space="preserve">
          <source>Waiting to write zero bytes to a dynamic shared memory backing file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0929df55dd9f72fd6c1d910f07bdae3bd6e941bb" translate="yes" xml:space="preserve">
          <source>Warm and hot standby servers can be kept current by reading a stream of write-ahead log (WAL) records. If the main server fails, the standby contains almost all of the data of the main server, and can be quickly made the new master database server. This can be synchronous or asynchronous and can only be done for the entire database server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a016c375864acf9c142cbb1359e053c54d4d9438" translate="yes" xml:space="preserve">
          <source>We already saw that &lt;code&gt;ORDER BY&lt;/code&gt; can be omitted if the ordering of rows is not important. It is also possible to omit &lt;code&gt;PARTITION BY&lt;/code&gt;, in which case there is a single partition containing all rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836ee2eeb6e7ae6444006848acb871065ea3b213" translate="yes" xml:space="preserve">
          <source>We already saw the MCV information for &lt;code&gt;stringu1&lt;/code&gt;, and here is its histogram:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4916a888ae7040005cd716f2c3e28e1930fe1e1c" translate="yes" xml:space="preserve">
          <source>We also want a guarantee that once a transaction is completed and acknowledged by the database system, it has indeed been permanently recorded and won't be lost even if a crash ensues shortly thereafter. For example, if we are recording a cash withdrawal by Bob, we do not want any chance that the debit to his account will disappear in a crash just after he walks out the bank door. A transactional database guarantees that all the updates made by a transaction are logged in permanent storage (i.e., on disk) before the transaction is reported complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6743dd465747bd2e107f6841f4c88e12a10fdc63" translate="yes" xml:space="preserve">
          <source>We can also access arbitrary rectangular slices of an array, or subarrays. An array slice is denoted by writing &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; for one or more array dimensions. For example, this query retrieves the first item on Bill's schedule for the first two days of the week:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d5e00c2932aa021f71e1c7987bbc84382d9b85" translate="yes" xml:space="preserve">
          <source>We can also choose to return &lt;code&gt;NULL&lt;/code&gt;, instead of the lower-cased word, if it is not found in the stop words file. This behavior is selected by setting the dictionary's &lt;code&gt;Accept&lt;/code&gt; parameter to &lt;code&gt;false&lt;/code&gt;. Continuing the example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfd312f5fc4d67101d851237062bdba159c0ec59" translate="yes" xml:space="preserve">
          <source>We can also join a table against itself. This is called a &lt;em&gt;self join&lt;/em&gt;. As an example, suppose we wish to find all the weather records that are in the temperature range of other weather records. So we need to compare the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of each &lt;code&gt;weather&lt;/code&gt; row to the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of all other &lt;code&gt;weather&lt;/code&gt; rows. We can do this with the following query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc6beb3b0e1bef62d183184143ea3d3ef810b4c" translate="yes" xml:space="preserve">
          <source>We can change the rewriting rules just by updating the table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2618785314089b8d336377e9a207db9405d3b4" translate="yes" xml:space="preserve">
          <source>We can create a GIN index (&lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;) to speed up text searches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7821bbb704a2ac952eb9690616bfdd424400d47" translate="yes" xml:space="preserve">
          <source>We can do inheritance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91685339d290a8a5e3f0243e992defd515e095f" translate="yes" xml:space="preserve">
          <source>We can then see that an administrator connecting over a network will not see any records, due to the restrictive policy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7ee16addc76bca0dc0a634456700165327da1e" translate="yes" xml:space="preserve">
          <source>We can update an individual subfield of a composite column:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbaecdebc4248cd30d99181acc6ee4648ce55281" translate="yes" xml:space="preserve">
          <source>We choose not to index or search some token types that the built-in configuration does handle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68910847b8b293ecced82107bbdb7c9e86be5f0" translate="yes" xml:space="preserve">
          <source>We could also have written:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af074a97ee1433a54eef949ce0f504465ee61b0" translate="yes" xml:space="preserve">
          <source>We could simplify this by creating a SQL function that inserts a label at a specified position in a path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ed1bedde4f0b0f00a9838d665bf3bd179f0836" translate="yes" xml:space="preserve">
          <source>We define the synonym dictionary like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d488cdbcb41070244eeea7399c07a12ab608b66e" translate="yes" xml:space="preserve">
          <source>We do not need a perfectly consistent file system backup as the starting point. Any internal inconsistency in the backup will be corrected by log replay (this is not significantly different from what happens during crash recovery). So we do not need a file system snapshot capability, just tar or a similar archiving tool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9a8fa7a3f06527b3bcf2908ca8717c376647ee" translate="yes" xml:space="preserve">
          <source>We have already discussed constants in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The following sections discuss the remaining options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ef9ac43045748116a115e49374f363a8ba372f" translate="yes" xml:space="preserve">
          <source>We know that most queries will access just the last week's, month's or quarter's data, since the main use of this table will be to prepare online reports for management. To reduce the amount of old data that needs to be stored, we decide to only keep the most recent 3 years worth of data. At the beginning of each month we will remove the oldest month's data. In this situation we can use partitioning to help us meet all of our different requirements for the measurements table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a993aca05617d8df040114000bd6876b7a6bbb8" translate="yes" xml:space="preserve">
          <source>We know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd1ca25954ba7db5e426cd93dec87fb2f18cad3" translate="yes" xml:space="preserve">
          <source>We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt;, and so the command will be rejected before the rule can be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668bafcded25fc8a525c39fc8ba11f8e8e98aa03" translate="yes" xml:space="preserve">
          <source>We might want to insert data and have the server automatically locate the child table into which the row should be added. We could do this with a more complex trigger function, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa4d9dcdf43d5b53cef629cb08b1cf507249faa" translate="yes" xml:space="preserve">
          <source>We must redefine the trigger function each month so that it always points to the current child table. The trigger definition does not need to be updated, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1597c32eb07ab6cca066ebab3e65392f57896307" translate="yes" xml:space="preserve">
          <source>We recommend that active production databases be vacuumed frequently (at least nightly), in order to remove dead rows. After adding or deleting a large number of rows, it might be a good idea to issue a &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; command for the affected table. This will update the system catalogs with the results of all recent changes, and allow the PostgreSQL query planner to make better choices in planning queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e67abf5ade818ba6d22ea4bc6d74fa648515393" translate="yes" xml:space="preserve">
          <source>We reject the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command across the board, because any module loaded could easily circumvent security policy enforcement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977603731abefa85626583cf9841c1f7f86bb5c7" translate="yes" xml:space="preserve">
          <source>We require the index access method to apply these tests itself, which means that it must reach into the heap to check the commit status of any row that is shown to have a duplicate key according to the index contents. This is without a doubt ugly and non-modular, but it saves redundant work: if we did a separate probe then the index lookup for a conflicting row would be essentially repeated while finding the place to insert the new row's index entry. What's more, there is no obvious way to avoid race conditions unless the conflict check is an integral part of insertion of the new index entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61809ffaa1e9bec3b74e00f63e536c6b27a9b1ac" translate="yes" xml:space="preserve">
          <source>We say that in this situation the orders table is the &lt;em&gt;referencing&lt;/em&gt; table and the products table is the &lt;em&gt;referenced&lt;/em&gt; table. Similarly, there are referencing and referenced columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926fa8d618ecd63d98d203881339877369fb9e8a" translate="yes" xml:space="preserve">
          <source>We say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. (PostgreSQL doesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ad12c01cac6b9fd7b6ff658816ff5bf8b904a2" translate="yes" xml:space="preserve">
          <source>We store these documents in a table named &lt;code&gt;api&lt;/code&gt;, in a &lt;code&gt;jsonb&lt;/code&gt; column named &lt;code&gt;jdoc&lt;/code&gt;. If a GIN index is created on this column, queries like the following can make use of the index:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00287a4e7374c9957df5b25550d2f8b5bf2d466" translate="yes" xml:space="preserve">
          <source>We use the following terms below: The &lt;em&gt;precision&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the total count of significant digits in the whole number, that is, the number of digits to both sides of the decimal point. The &lt;em&gt;scale&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the count of decimal digits in the fractional part, to the right of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4. Integers can be considered to have a scale of zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22e103a166cab5bebeb6c6bf8216ec0f41d1ce6" translate="yes" xml:space="preserve">
          <source>We use the same &lt;code&gt;measurement&lt;/code&gt; table we used above. To implement partitioning using inheritance, use the following steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bb5356e299e65f3820ac3133d7b4e088f6bde2" translate="yes" xml:space="preserve">
          <source>We use the word &lt;em&gt;item&lt;/em&gt; to refer to a composite value that is to be indexed, and the word &lt;em&gt;key&lt;/em&gt; to refer to an element value. GIN always stores and searches for keys, not item values per se.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaac10448fb5e7278bf16580755bd9621bfb54f1" translate="yes" xml:space="preserve">
          <source>We want our application to be able to say &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; and have the data be redirected into the appropriate child table. We can arrange that by attaching a suitable trigger function to the master table. If data will be added only to the latest child, we can use a very simple trigger function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc05935dfdf1c41e4dbff177f8b502be331c045" translate="yes" xml:space="preserve">
          <source>We will use a PostgreSQL-specific synonym list and store it in &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt;. The file contents look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="963adbfe40be253cf091e436ca27447ef3a470bc" translate="yes" xml:space="preserve">
          <source>Wed, Weds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d75266a53b99ce4d80d337862ea1edd8ba1b1a1" translate="yes" xml:space="preserve">
          <source>Weeks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdeddc33f6adb1db2fc6d6142f8a57019f70774f" translate="yes" xml:space="preserve">
          <source>Weights are typically used to reflect document structure, for example by marking title words differently from body words. Text search ranking functions can assign different priorities to the different weight markers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="683c9370be61bfcd03e58355d7c86c6e1369d2d9" translate="yes" xml:space="preserve">
          <source>Western European</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82bc7cf6e54b2e4257e788dff104c1e42da4e0b" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d446878c466219c122696ab7b32c54ff789d87e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Inlining</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca44cc7300ef1dcac2b672637a01e3b0a0da90f7" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: JIT Accelerated Operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760d95b57cc4647ff2722b6cf5ee7f34082cc25e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Optimization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6026d88e883e805146a8bbfee4583738ccfd77d8" translate="yes" xml:space="preserve">
          <source>What Is the &amp;ldquo;Transaction&amp;rdquo; Actually Performed in pgbench?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8a97eccbb7e55f60d7659738855ee30c65e97d" translate="yes" xml:space="preserve">
          <source>What has really happened here is that the two unknown literals are resolved to &lt;code&gt;text&lt;/code&gt; by default, allowing the &lt;code&gt;||&lt;/code&gt; operator to be resolved as &lt;code&gt;text&lt;/code&gt; concatenation. Then the &lt;code&gt;text&lt;/code&gt; result of the operator is converted to &lt;code&gt;bpchar&lt;/code&gt; (&amp;ldquo;blank-padded char&amp;rdquo;, the internal name of the &lt;code&gt;character&lt;/code&gt; data type) to match the target column type. (Since the conversion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;bpchar&lt;/code&gt; is binary-coercible, this conversion does not insert any real function call.) Finally, the sizing function &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; is found in the system catalog and applied to the operator's result and the stored column length. This type-specific function performs the required length check and addition of padding spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfcede4e6134968fca6be5ab22337a4021df7d2f" translate="yes" xml:space="preserve">
          <source>What is a &amp;ldquo;system user&amp;rdquo; is determined at systemd compile time from the &lt;code&gt;SYS_UID_MAX&lt;/code&gt; setting in &lt;code&gt;/etc/login.defs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b062bdc5b358d8bc1d0ea5b87500675ecf488c" translate="yes" xml:space="preserve">
          <source>What is essentially happening here is a join between &lt;code&gt;films&lt;/code&gt; and &lt;code&gt;producers&lt;/code&gt;, with all successfully joined &lt;code&gt;films&lt;/code&gt; rows being marked for deletion. This syntax is not standard. A more standard way to do it is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6eec3dfd99f17e2a6e53d2f854ed352bd2c2826" translate="yes" xml:space="preserve">
          <source>What locales are available on your system under what names depends on what was provided by the operating system vendor and what was installed. On most Unix systems, the command &lt;code&gt;locale -a&lt;/code&gt; will provide a list of available locales. Windows uses more verbose locale names, such as &lt;code&gt;German_Germany&lt;/code&gt; or &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt;, but the principles are the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40680439c20fb6866bd543023ba55a7dbd37c92b" translate="yes" xml:space="preserve">
          <source>What this does is to record the links created by pg_upgrade's link mode that connect files in the old and new clusters on the primary server. It then finds matching files in the standby's old cluster and creates links for them in the standby's new cluster. Files that were not linked on the primary are copied from the primary to the standby. (They are usually small.) This provides rapid standby upgrades. Unfortunately, rsync needlessly copies files associated with temporary and unlogged tables because these files don't normally exist on standby servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a446c8d9e480b9f0f6cbcd76fef7e2bcda6c700b" translate="yes" xml:space="preserve">
          <source>What's more, when you load data into a table with existing foreign key constraints, each new row requires an entry in the server's list of pending trigger events (since it is the firing of a trigger that checks the row's foreign key constraint). Loading many millions of rows can cause the trigger event queue to overflow available memory, leading to intolerable swapping or even outright failure of the command. Therefore it may be &lt;em&gt;necessary&lt;/em&gt;, not just desirable, to drop and re-apply foreign keys when loading large amounts of data. If temporarily removing the constraint isn't acceptable, the only other recourse may be to split up the load operation into smaller transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0604f8d2119324fb427a16a8668c529701bc1a2" translate="yes" xml:space="preserve">
          <source>Whatever data was in the column disappears. Table constraints involving the column are dropped, too. However, if the column is referenced by a foreign key constraint of another table, PostgreSQL will not silently drop that constraint. You can authorize dropping everything that depends on the column by adding &lt;code&gt;CASCADE&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60fe559ad2643627bd47ea3eceb6f63037101eb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits&lt;/a&gt; is set, this parameter also determines the amount of time to wait before a log message is issued about the lock wait. If you are trying to investigate locking delays you might want to set a shorter than normal &lt;code&gt;deadlock_timeout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e37b6a94a28e9acbd6287be1d60c38f8541fd8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1854281aa73e4f5b1f721e95b9f05123b0ade134" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-n&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected schema(s) might depend upon. Therefore, there is no guarantee that the results of a specific-schema dump can be successfully restored by themselves into a clean database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fef81c501efe3e088f4b73c9a697af2561cb6dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that the results of a specific-table dump can be successfully restored by themselves into a clean database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c86589858bd9989813c8435013ddbc1a41c69f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_restore makes no attempt to restore any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that a specific-table restore into a clean database will succeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd3feb588f68391e70d37037327ad64b7721fd7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ALTER&lt;/code&gt; command is executed, &lt;code&gt;setattr&lt;/code&gt; will be checked on the object being modified for each object types, except for subsidiary objects such as the indexes or triggers of a table, where permissions are instead checked on the parent object. In some cases, additional permissions are required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ea06756271ccb08739b45bacb4e5cf14e003e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE INDEX&lt;/code&gt; is invoked on a partitioned table, the default behavior is to recurse to all partitions to ensure they all have matching indexes. Each partition is first checked to determine whether an equivalent index already exists, and if so, that index will become attached as a partition index to the index being created, which will become its parent index. If no matching index exists, a new index will be created and automatically attached; the name of the new index in each partition will be determined as if no index name had been specified in the command. If the &lt;code&gt;ONLY&lt;/code&gt; option is specified, no recursion is done, and the index is marked invalid. (&lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; marks the index valid, once all partitions acquire matching indexes.) Note, however, that any partition that is created in the future using &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; will automatically have a matching index, regardless of whether &lt;code&gt;ONLY&lt;/code&gt; is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c15e2e86d36f47a57239a8f802301f2d222dbb6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; is used to replace an existing function, the ownership and permissions of the function do not change. All other function properties are assigned the values specified or implied in the command. You must own the function to replace it (this includes being a member of the owning role).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db55d63efcb8b5298291fde068a29837b503dfcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; is used to replace an existing procedure, the ownership and permissions of the procedure do not change. All other procedure properties are assigned the values specified or implied in the command. You must own the procedure to replace it (this includes being a member of the owning role).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b7e02139c0fd56fa0d0c0d7e02cacf1863b7dd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; is used on an existing view, only the view's defining SELECT rule is changed. Other view properties, including ownership, permissions, and non-SELECT rules, remain unchanged. You must own the view to replace it (this includes being a member of the owning role).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b68d33a4076adb362da4bb710ac3317fb09cf8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DROP&lt;/code&gt; command is executed, &lt;code&gt;drop&lt;/code&gt; will be checked on the object being removed. Permissions will be also checked for objects dropped indirectly via &lt;code&gt;CASCADE&lt;/code&gt;. Deletion of objects contained within a particular schema (tables, views, sequences and procedures) additionally requires &lt;code&gt;remove_name&lt;/code&gt; on the schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47c9d6dc4a8942d1dd522d4978fe59346f8ad48" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GROUP BY&lt;/code&gt; is present, or any aggregate functions are present, it is not valid for the &lt;code&gt;SELECT&lt;/code&gt; list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61a8feeb668ae119fbcd691b6fc8464f954d0c9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NOTIFY&lt;/code&gt; is used to signal the occurrence of changes to a particular table, a useful programming technique is to put the &lt;code&gt;NOTIFY&lt;/code&gt; in a statement trigger that is triggered by table updates. In this way, notification happens automatically when the table is changed, and the application programmer cannot accidentally forget to do it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d946d891d853517e02080ffe41ee5e79e55c40" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. This is unlike the normal behavior of &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt;. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt;; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd38b054f6c38892cf4b53376368a92afaa9614" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; changes the mode of a constraint from &lt;code&gt;DEFERRED&lt;/code&gt; to &lt;code&gt;IMMEDIATE&lt;/code&gt;, the new mode takes effect retroactively: any outstanding data modifications that would have been checked at the end of the transaction are instead checked during the execution of the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; command. If any such constraint is violated, the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; fails (and does not change the constraint mode). Thus, &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; can be used to force checking of constraints to occur at a specific point in a transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b169cb5b7cb17bff71441e629815508752132d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VALUES&lt;/code&gt; is used in &lt;code&gt;INSERT&lt;/code&gt;, the values are all automatically coerced to the data type of the corresponding destination column. When it's used in other contexts, it might be necessary to specify the correct data type. If the entries are all quoted literal constants, coercing the first is sufficient to determine the assumed type for all:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ae9ff8fa95f77c4ea16390adcefafbd4f890d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;ANALYZE&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f1458fcf796362f90bd6b53ff757eaee1e2939" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;VACUUM&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54823d23e5df73c9472414a7a83e6ba082b1ce2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\ef&lt;/code&gt;, or &lt;code&gt;\ev&lt;/code&gt; is used with a line number argument, this variable specifies the command-line argument used to pass the starting line number to the user's editor. For editors such as Emacs or vi, this is a plus sign. Include a trailing space in the value of the variable if there needs to be space between the option name and the line number. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880bf87755564e46a3f310f5734ab8ac6764465b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;archive_mode&lt;/code&gt; is enabled, completed WAL segments are sent to archive storage by setting &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. In addition to &lt;code&gt;off&lt;/code&gt;, to disable, there are two modes: &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;always&lt;/code&gt;. During normal operation, there is no difference between the two modes, but when set to &lt;code&gt;always&lt;/code&gt; the WAL archiver is enabled also during archive recovery or standby mode. In &lt;code&gt;always&lt;/code&gt; mode, all files restored from the archive or streamed with streaming replication will be archived (again). See &lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;Section 26.2.9&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46cdaf5a9c68bb7dda3e95a7d23c6fce30bcf59a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;commit_delay&lt;/code&gt; is set to zero (the default), it is still possible for a form of group commit to occur, but each group will consist only of sessions that reach the point where they need to flush their commit records during the window in which the previous flush operation (if any) is occurring. At higher client counts a &amp;ldquo;gangway effect&amp;rdquo; tends to occur, so that the effects of group commit become significant even when &lt;code&gt;commit_delay&lt;/code&gt; is zero, and thus explicitly setting &lt;code&gt;commit_delay&lt;/code&gt; tends to help less. Setting &lt;code&gt;commit_delay&lt;/code&gt; can only help when (1) there are some concurrently committing transactions, and (2) throughput is limited to some degree by commit rate; but with high rotational latency this setting can be effective in increasing transaction throughput with as few as two clients (that is, a single committing client with one sibling transaction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639e6544c619e9aa79e7a25d85adc789836438b5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;default_tablespace&lt;/code&gt; is set to anything but an empty string, it supplies an implicit &lt;code&gt;TABLESPACE&lt;/code&gt; clause for &lt;code&gt;CREATE TABLE&lt;/code&gt; and &lt;code&gt;CREATE INDEX&lt;/code&gt; commands that do not have an explicit one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b9fcc2ea9102afd846d23d5a3d7acf06ea6fcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extractQuery&lt;/code&gt; returns a null key in &lt;code&gt;queryKeys[]&lt;/code&gt;, the corresponding &lt;code&gt;check[]&lt;/code&gt; element is true if the indexed item contains a null key; that is, the semantics of &lt;code&gt;check[]&lt;/code&gt; are like &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt;. The &lt;code&gt;consistent&lt;/code&gt; function can examine the corresponding &lt;code&gt;nullFlags[]&lt;/code&gt; element if it needs to tell the difference between a regular value match and a null match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e521d3acb4576333ab5bee010106dc1a1c2bc018" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28ef38bf9e5530ece862031c842201d36ddd349" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the directory in which log files will be created. It can be specified as an absolute path, or relative to the cluster data directory. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;log&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3acb8f6d64e7dee8bb588e16430447375cec4a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum amount of time to use an individual log file, after which a new log file will be created. If this value is specified without units, it is taken as minutes. The default is 24 hours. Set to zero to disable time-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba6806c5a61bd0e7df256b20d72936b6dfff344" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum size of an individual log file. After this amount of data has been emitted into a log file, a new log file will be created. If this value is specified without units, it is taken as kilobytes. The default is 10 megabytes. Set to zero to disable size-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d04df6ccc65336486b417a686759bd20169c58" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt;-escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt;-escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt;-escapes are similar to those listed in the Open Group's &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912a8bc2db1f94954749b8b7569bc346c69e11ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter will cause PostgreSQL to truncate (overwrite), rather than append to, any existing log file of the same name. However, truncation will occur only when a new file is being opened due to time-based rotation, not during server startup or size-based rotation. When off, pre-existing files will be appended to in all cases. For example, using this setting in combination with a &lt;code&gt;log_filename&lt;/code&gt; like &lt;code&gt;postgresql-%H.log&lt;/code&gt; would result in generating twenty-four hourly log files and then cyclically overwriting them. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2a30741ea2b8dcb498e785772cf2a514f01258" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;on&lt;/code&gt; (the default), each SQL command is automatically committed upon successful completion. To postpone commit in this mode, you must enter a &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt; SQL command. When &lt;code&gt;off&lt;/code&gt; or unset, SQL commands are not committed until you explicitly issue &lt;code&gt;COMMIT&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;. The autocommit-off mode works by issuing an implicit &lt;code&gt;BEGIN&lt;/code&gt; for you, just before any command that is not already in a transaction block and is not itself a &lt;code&gt;BEGIN&lt;/code&gt; or other transaction-control command, nor a command that cannot be executed inside a transaction block (such as &lt;code&gt;VACUUM&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85a8f652ce31ff087a3b7cc628918aedc0afe36" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pg_stat_statements&lt;/code&gt; is loaded, it tracks statistics across all databases of the server. To access and manipulate these statistics, the module provides a view, &lt;code&gt;pg_stat_statements&lt;/code&gt;, and the utility functions &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; and &lt;code&gt;pg_stat_statements&lt;/code&gt;. These are not available globally but can be enabled for a specific database with &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c48693eca5bd4dca7f7f71afdfbb3d41be3ea38" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;postgres_fdw&lt;/code&gt; encounters a join between foreign tables on the same foreign server, it sends the entire join to the foreign server, unless for some reason it believes that it will be more efficient to fetch rows from each table individually, or unless the table references involved are subject to different user mappings. While sending the &lt;code&gt;JOIN&lt;/code&gt; clauses, it takes the same precautions as mentioned above for the &lt;code&gt;WHERE&lt;/code&gt; clauses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8497bbbc5c881081d121fdf01a588723979b05" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;program&lt;/code&gt; is specified, &lt;code&gt;command&lt;/code&gt; is executed by psql and the data passed from or to &lt;code&gt;command&lt;/code&gt; is routed between the server and the client. Again, the execution privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6840df87dd751c0fab0c6f46649358f6b34c5849" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;slot_name&lt;/code&gt; is set to &lt;code&gt;NONE&lt;/code&gt;, there will be no replication slot associated with the subscription. This can be used if the replication slot will be created later manually. Such subscriptions must also have both &lt;code&gt;enabled&lt;/code&gt; and &lt;code&gt;create_slot&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3788a4cfcb030ae27460c4ddd94f0d92885c664" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;temp_tablespaces&lt;/code&gt; is set interactively, specifying a nonexistent tablespace is an error, as is specifying a tablespace for which the user does not have &lt;code&gt;CREATE&lt;/code&gt; privilege. However, when using a previously set value, nonexistent tablespaces are ignored, as are tablespaces for which the user lacks &lt;code&gt;CREATE&lt;/code&gt; privilege. In particular, this rule applies when using a value set in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c068d98cbad8e288e90e4c1dd972e7c59abbaa3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;tgconstraint&lt;/code&gt; is nonzero, &lt;code&gt;tgconstrrelid&lt;/code&gt;, &lt;code&gt;tgconstrindid&lt;/code&gt;, &lt;code&gt;tgdeferrable&lt;/code&gt;, and &lt;code&gt;tginitdeferred&lt;/code&gt; are largely redundant with the referenced &lt;code&gt;pg_constraint&lt;/code&gt; entry. However, it is possible for a non-deferrable trigger to be associated with a deferrable constraint: foreign key constraints can have some deferrable and some non-deferrable triggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d575b88117ece85c7a87c6ea7ead5a6532b19a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trust&lt;/code&gt; authentication is specified, PostgreSQL assumes that anyone who can connect to the server is authorized to access the database with whatever database user name they specify (even superuser names). Of course, restrictions made in the &lt;code&gt;database&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt; columns still apply. This method should only be used when there is adequate operating-system-level protection on connections to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966280f7c40171987c3cbc983291b38e3a71017e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use_remote_estimate&lt;/code&gt; is true, &lt;code&gt;postgres_fdw&lt;/code&gt; obtains row count and cost estimates from the remote server and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. When &lt;code&gt;use_remote_estimate&lt;/code&gt; is false, &lt;code&gt;postgres_fdw&lt;/code&gt; performs local row count and cost estimation and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. This local estimation is unlikely to be very accurate unless local copies of the remote table's statistics are available. Running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the foreign table is the way to update the local statistics; this will perform a scan of the remote table and then calculate and store statistics just as though the table were local. Keeping local statistics can be a useful way to reduce per-query planning overhead for a remote table &amp;mdash; but if the remote table is frequently updated, the local statistics will soon be obsolete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04447293cfe5a43fce5bd6f976cc350e753a232" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; some SQL commands are optimized to avoid WAL logging, as described in &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;. If archiving or streaming replication were turned on during execution of one of these statements, WAL would not contain enough information for archive recovery. (Crash recovery is unaffected.) For this reason, &lt;code&gt;wal_level&lt;/code&gt; can only be changed at server start. However, &lt;code&gt;archive_command&lt;/code&gt; can be changed with a configuration file reload. If you wish to temporarily stop archiving, one way to do it is to set &lt;code&gt;archive_command&lt;/code&gt; to the empty string (&lt;code&gt;''&lt;/code&gt;). This will cause WAL files to accumulate in &lt;code&gt;pg_wal/&lt;/code&gt; until a working &lt;code&gt;archive_command&lt;/code&gt; is re-established.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc54463c4a91042c587b320f65f275bd091c2193" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed, there is generally a greatly increased chance of detecting single-bit errors, since strict binary equality is tested, and the indexed attributes within the heap are tested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668fe437dfa47692f950b23dc7849bfb4637dcda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; is greater than one, the returned numbers should be averages expected for any one scan of the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ef5495d24b79877e9b0ce1d70303e79e6501c2" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is positive, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is greater than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Conversely, when &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is negative, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is less than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Zero rows are also returned for &lt;code&gt;NULL&lt;/code&gt; inputs. It is an error for &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; to be zero. Some examples follow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1d230678ad6398ea1b726af7844a229cc8f13e" translate="yes" xml:space="preserve">
          <source>When Can Parallel Query Be Used?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5a55e381f3b4b99fc5f9dc03b78c3fc758ed84" translate="yes" xml:space="preserve">
          <source>When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt;. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt;&lt;code&gt;whatever&lt;/code&gt;. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (&lt;code&gt;POSTGRES&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb176371849755f8e3fddd6c5c7996731ba8719c" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_archive_delay&lt;/code&gt; applies when WAL data is being read from WAL archive (and is therefore not current). If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec8116773102304d6d7b1390f1e98f30e3bb2ff" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; applies when WAL data is being received via streaming replication. If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0d78fac0ffb73c1a9e09c7cc14d11764cc7556" translate="yes" xml:space="preserve">
          <source>When PostgreSQL maps SQL data values to XML (as in &lt;code&gt;xmlelement&lt;/code&gt;), or XML to SQL (as in the output columns of &lt;code&gt;xmltable&lt;/code&gt;), except for a few cases treated specially, PostgreSQL simply assumes that the XML data type's XPath 1.0 string form will be valid as the text-input form of the SQL datatype, and conversely. This rule has the virtue of simplicity while producing, for many data types, results similar to the mappings specified in the standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4181958cdfd24c8fd1ab7073c5b2ff83fa0a559f" translate="yes" xml:space="preserve">
          <source>When SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user name that the client sends in the &lt;code&gt;client-first-message&lt;/code&gt;. The user name that was already sent in the startup message is used instead. PostgreSQL supports multiple character encodings, while SCRAM dictates UTF-8 to be used for the user name, so it might be impossible to represent the PostgreSQL user name in UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd20efcfa95fdaaa37532258734ec47bc3eda12" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_list&lt;/code&gt;, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a80d67f6221f67e848e31748e5e7aded5d6746e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; item contains &lt;code&gt;LATERAL&lt;/code&gt; cross-references, evaluation proceeds as follows: for each row of the &lt;code&gt;FROM&lt;/code&gt; item providing the cross-referenced column(s), or set of rows of multiple &lt;code&gt;FROM&lt;/code&gt; items providing the columns, the &lt;code&gt;LATERAL&lt;/code&gt; item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9131be6a2fce2c0e060d15eb98b8c743d3328da0" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint is not deferrable, PostgreSQL checks for uniqueness immediately whenever a row is inserted or modified. The SQL standard says that uniqueness should be enforced only at the end of the statement; this makes a difference when, for example, a single command updates multiple key values. To obtain standard-compliant behavior, declare the constraint as &lt;code&gt;DEFERRABLE&lt;/code&gt; but not deferred (i.e., &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;). Be aware that this can be significantly slower than immediate uniqueness checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7633f6759da586e80f43626088973d06a48ea56" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;pg_cast&lt;/code&gt; entry has different source and target types and a function that takes more than one argument, it represents converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f0e69da747f3bb16cb53c469a234fbf587434e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;timestamp with time zone&lt;/code&gt; value is output, it is always converted from UTC to the current &lt;code&gt;timezone&lt;/code&gt; zone, and displayed as local time in that zone. To see the time in another time zone, either change &lt;code&gt;timezone&lt;/code&gt; or use the &lt;code&gt;AT TIME ZONE&lt;/code&gt; construct (see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;Section 9.9.3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27629e4b11182354bc4cc1d2c2660d2bd8a7f20c" translate="yes" xml:space="preserve">
          <source>When a cast has different source and target types and a function that takes more than one argument, it supports converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two cast steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49788d41c6b6cbdafb9c157dde66cc21e7ad5c8d" translate="yes" xml:space="preserve">
          <source>When a cast is applied to a value expression of a known type, it represents a run-time type conversion. The cast will succeed only if a suitable type conversion operation has been defined. Notice that this is subtly different from the use of casts with constants, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;. A cast applied to an unadorned string literal represents the initial assignment of a type to a literal constant value, and so it will succeed for any type (if the contents of the string literal are acceptable input syntax for the data type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5e183edf65b04ea968b8cbec71c03d82d34814" translate="yes" xml:space="preserve">
          <source>When a character string value is cast to or from type &lt;code&gt;xml&lt;/code&gt; without going through &lt;code&gt;XMLPARSE&lt;/code&gt; or &lt;code&gt;XMLSERIALIZE&lt;/code&gt;, respectively, the choice of &lt;code&gt;DOCUMENT&lt;/code&gt; versus &lt;code&gt;CONTENT&lt;/code&gt; is determined by the &amp;ldquo;XML option&amp;rdquo;  session configuration parameter, which can be set using the standard command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fc13aa34e4743bab6d0037fe542f1b13a66649" translate="yes" xml:space="preserve">
          <source>When a column is added with &lt;code&gt;ADD COLUMN&lt;/code&gt; and a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; is specified, the default is evaluated at the time of the statement and the result stored in the table's metadata. That value will be used for the column for all existing rows. If no &lt;code&gt;DEFAULT&lt;/code&gt; is specified, NULL is used. In neither case is a rewrite of the table required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4617ca746c05eccbac9e1250d759f5bd44319fcd" translate="yes" xml:space="preserve">
          <source>When a conflicting query is short, it's typically desirable to allow it to complete by delaying WAL application for a little bit; but a long delay in WAL application is usually not desirable. So the cancel mechanism has parameters, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;, that define the maximum allowed delay in WAL application. Conflicting queries will be canceled once it has taken longer than the relevant delay setting to apply any newly-received WAL data. There are two parameters so that different delay values can be specified for the case of reading WAL data from an archive (i.e., initial recovery from a base backup or &amp;ldquo;catching up&amp;rdquo; a standby server that has fallen far behind) versus reading WAL data via streaming replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9942af75508e96643f23b2bb2b19c3cb29a5d8" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind anonymously (since &lt;code&gt;ldapbinddn&lt;/code&gt; was not specified) to the LDAP server, perform a search for &lt;code&gt;(uid=someuser)&lt;/code&gt; under the specified base DN. If an entry is found, it will then attempt to bind using that found information and the password supplied by the client. If that second connection succeeds, the database access is granted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48781ec5a4acd4a7481b8c8839149e95712b5009" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind to the LDAP server using the DN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; and the password provided by the client. If that connection succeeds, the database access is granted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c225436eedb2c4fcd16a275b1ddffc50962ab028" translate="yes" xml:space="preserve">
          <source>When a constant's value has been ignored for purposes of matching the query to other queries, the constant is replaced by a parameter symbol, such as &lt;code&gt;$1&lt;/code&gt;, in the &lt;code&gt;pg_stat_statements&lt;/code&gt; display. The rest of the query text is that of the first query that had the particular &lt;code&gt;queryid&lt;/code&gt; hash value associated with the &lt;code&gt;pg_stat_statements&lt;/code&gt; entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb409e448668771f827d8fbf0e7974aed415eec" translate="yes" xml:space="preserve">
          <source>When a data-only dump is chosen and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_dump emits commands to disable triggers on user tables before inserting the data, and then commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb4292f30931b17f0bc254f84df53dc22a84368" translate="yes" xml:space="preserve">
          <source>When a direct database connection is specified using the &lt;code&gt;-d&lt;/code&gt; option, pg_restore internally executes SQL statements. If you have problems running pg_restore, make sure you are able to select information from the database using, for example, &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b0a551bd1d82e60af1e6e20328604ac27e04a2" translate="yes" xml:space="preserve">
          <source>When a domain has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested in alphabetical order by name. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ae6b8670e18414fb24938a0f2cc8a6d1070788" translate="yes" xml:space="preserve">
          <source>When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt;, a &lt;code&gt;bigint&lt;/code&gt; column is appended to the output which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5d8fb3f4d70c3c0f1dea589130a29e4dae23e6" translate="yes" xml:space="preserve">
          <source>When a heap entry is to be deleted (by &lt;code&gt;VACUUM&lt;/code&gt;), all its index entries must be removed first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00af93fe8454ff02af34b94554824196fc81e8fc" translate="yes" xml:space="preserve">
          <source>When a locking clause appears at the top level of a &lt;code&gt;SELECT&lt;/code&gt; query, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If a &lt;code&gt;LIMIT&lt;/code&gt; is used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over by &lt;code&gt;OFFSET&lt;/code&gt; will get locked). Similarly, if a locking clause is used in a cursor's query, only rows actually fetched or stepped past by the cursor will be locked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef95b8a60ebd804a0c28a2e00cab45258a43a0d6" translate="yes" xml:space="preserve">
          <source>When a locking clause appears in a sub-&lt;code&gt;SELECT&lt;/code&gt;, the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc7a3d97debfcf5d558fe06d1809283c70c4abd" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;GRANT&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will grant only those privileges for which the user has grant options. The &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d5be09265c0f260930da66e4dbc18e249c5a52" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;REVOKE&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will revoke only those privileges for which the user has grant options. The &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fc5d42be5663314dba2e99345c9e9036540107" translate="yes" xml:space="preserve">
          <source>When a password is specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; or &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, this parameter determines the algorithm to use to encrypt the password. The default value is &lt;code&gt;md5&lt;/code&gt;, which stores the password as an MD5 hash (&lt;code&gt;on&lt;/code&gt; is also accepted, as alias for &lt;code&gt;md5&lt;/code&gt;). Setting this parameter to &lt;code&gt;scram-sha-256&lt;/code&gt; will encrypt the password with SCRAM-SHA-256.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a045ad36bdf763a5564eafc812cd1f70e538ac02" translate="yes" xml:space="preserve">
          <source>When a query involves multiple window functions, it is possible to write out each one with a separate &lt;code&gt;OVER&lt;/code&gt; clause, but this is duplicative and error-prone if the same windowing behavior is wanted for several functions. Instead, each windowing behavior can be named in a &lt;code&gt;WINDOW&lt;/code&gt; clause and then referenced in &lt;code&gt;OVER&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b051ff28261e8c6e18971fa6cb50736f0add4f7" translate="yes" xml:space="preserve">
          <source>When a query only involves two or three tables, there aren't many join orders to worry about. But the number of possible join orders grows exponentially as the number of tables expands. Beyond ten or so input tables it's no longer practical to do an exhaustive search of all the possibilities, and even for six or seven tables planning might take an annoyingly long time. When there are too many input tables, the PostgreSQL planner will switch from exhaustive search to a &lt;em&gt;genetic&lt;/em&gt; probabilistic search through a limited number of possibilities. (The switch-over threshold is set by the &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; run-time parameter.) The genetic search takes less time, but it won't necessarily find the best possible plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a265f5fc62979fde73128f8ace62054feb152e" translate="yes" xml:space="preserve">
          <source>When a schema-qualified operator name is used in the &lt;code&gt;OPERATOR&lt;/code&gt; syntax, as for example in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d688620d10b715a262026cbd31ef1489999e7d" translate="yes" xml:space="preserve">
          <source>When a sequential scan and sort is used, a temporary sort file is also created, so that the peak temporary space requirement is as much as double the table size, plus the index sizes. This method is often faster than the index scan method, but if the disk space requirement is intolerable, you can disable this choice by temporarily setting &lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0770f15e6049d266a12140bc7f33a5609b9c35a" translate="yes" xml:space="preserve">
          <source>When a single element is pushed onto either the beginning or end of a one-dimensional array, the result is an array with the same lower bound subscript as the array operand. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80cd58c4f6747cdabdfc227aecb194029c6f93d" translate="yes" xml:space="preserve">
          <source>When a standby first attaches to the primary, it will not yet be properly synchronized. This is described as &lt;code&gt;catchup&lt;/code&gt; mode. Once the lag between standby and primary reaches zero for the first time we move to real-time &lt;code&gt;streaming&lt;/code&gt; state. The catch-up duration may be long immediately after the standby has been created. If the standby is shut down, then the catch-up period will increase according to the length of time the standby has been down. The standby is only able to become a synchronous standby once it has reached &lt;code&gt;streaming&lt;/code&gt; state. This state can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5c61ffccbfb5effcfe0a2c8686ec7385263d29" translate="yes" xml:space="preserve">
          <source>When a subscription is dropped and recreated, the synchronization information is lost. This means that the data has to be resynchronized afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46a9ad23681ef38bc14d25148f1365c37846a4e" translate="yes" xml:space="preserve">
          <source>When a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriate &lt;code&gt;CHECK&lt;/code&gt; constraint is present. Also like the scan of the new partition, it is always skipped when the default partition is a foreign table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152306185769e157a52b3f97557867eb083f11a7" translate="yes" xml:space="preserve">
          <source>When a table has an existing &lt;code&gt;DEFAULT&lt;/code&gt; partition and a new partition is added to it, the default partition must be scanned to verify that it does not contain any rows which properly belong in the new partition. If the default partition contains a large number of rows, this may be slow. The scan will be skipped if the default partition is a foreign table or if it has a constraint which proves that it cannot contain rows which should be placed in the new partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b2ea07826933a7c581c975e04300af317cf31d" translate="yes" xml:space="preserve">
          <source>When a table has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested for each row in alphabetical order by name, after checking &lt;code&gt;NOT NULL&lt;/code&gt; constraints. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082c9f9ffee26ce9be34e1d589e0da24d6b1e31a" translate="yes" xml:space="preserve">
          <source>When a table is being clustered, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock is acquired on it. This prevents any other database operations (both reads and writes) from operating on the table until the &lt;code&gt;CLUSTER&lt;/code&gt; is finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4eb9118baea2c47a40ccbe4939e2face5ca64c" translate="yes" xml:space="preserve">
          <source>When a table is clustered, PostgreSQL remembers which index it was clustered by. The form &lt;code&gt;CLUSTER table_name&lt;/code&gt; reclusters the table using the same index as before. You can also use the &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; forms of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to set the index to be used for future cluster operations, or to clear any previous setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb320e131f3533a19b92cb04f708af68aba5d79" translate="yes" xml:space="preserve">
          <source>When a table is clustered, it is physically reordered based on the index information. Clustering is a one-time operation: when the table is subsequently updated, the changes are not clustered. That is, no attempt is made to store new or updated rows according to their index order. (If one wishes, one can periodically recluster by issuing the command again. Also, setting the table's &lt;code&gt;fillfactor&lt;/code&gt; storage parameter to less than 100% can aid in preserving cluster ordering during updates, since updated rows are kept on the same page if enough space is available there.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a3d5e22ae2844ff5c06f47ba492689eb79f5ba" translate="yes" xml:space="preserve">
          <source>When a table is created, it contains no data. The first thing to do before a database can be of much use is to insert data. Data is conceptually inserted one row at a time. Of course you can also insert more than one row, but there is no way to insert less than one row. Even if you know only some column values, a complete row must be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85bad0d57dfc672246f13e6ad8d8a435cc923083" translate="yes" xml:space="preserve">
          <source>When a table or index exceeds 1 GB, it is divided into gigabyte-sized &lt;em&gt;segments&lt;/em&gt;. The first segment's file name is the same as the filenode; subsequent segments are named filenode.1, filenode.2, etc. This arrangement avoids problems on platforms that have file size limitations. (Actually, 1 GB is just the default segment size. The segment size can be adjusted using the configuration option &lt;code&gt;--with-segsize&lt;/code&gt; when building PostgreSQL.) In principle, free space map and visibility map forks could require multiple segments as well, though this is unlikely to happen in practice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a45cc60012ed72f0453155b208d80983750321" translate="yes" xml:space="preserve">
          <source>When a table reference names a table that is the parent of a table inheritance hierarchy, the table reference produces rows of not only that table but all of its descendant tables, unless the key word &lt;code&gt;ONLY&lt;/code&gt; precedes the table name. However, the reference produces only the columns that appear in the named table &amp;mdash; any columns added in subtables are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238107619ce9861ed394df0ebec618f90c2d4272" translate="yes" xml:space="preserve">
          <source>When a typed table is created, then the data types of the columns are determined by the underlying composite type and are not specified by the &lt;code&gt;CREATE TABLE&lt;/code&gt; command. But the &lt;code&gt;CREATE TABLE&lt;/code&gt; command can add defaults and constraints to the table and can specify storage parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ca1a4315d7efd053d1772d2a1868caf568479c" translate="yes" xml:space="preserve">
          <source>When a value is to be used as an SQL literal or identifier, it is safest to arrange for it to be quoted. To quote the value of a variable as an SQL literal, write a colon followed by the variable name in single quotes. To quote the value as an SQL identifier, write a colon followed by the variable name in double quotes. These constructs deal correctly with quotes and other special characters embedded within the variable value. The previous example would be more safely written this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55eaed5a13493b2841925c6347f0f009f1c69d52" translate="yes" xml:space="preserve">
          <source>When a view is locked, all relations appearing in the view definition query are also locked recursively with the same lock mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0731d9c33a2135d592b4234920022cbe73ac4232" translate="yes" xml:space="preserve">
          <source>When acquiring locks automatically for commands that reference tables, PostgreSQL always uses the least restrictive lock mode possible. &lt;code&gt;LOCK TABLE&lt;/code&gt; provides for cases when you might need more restrictive locking. For example, suppose an application runs a transaction at the &lt;code&gt;READ COMMITTED&lt;/code&gt; isolation level and needs to ensure that data in a table remains stable for the duration of the transaction. To achieve this you could obtain &lt;code&gt;SHARE&lt;/code&gt; lock mode over the table before querying. This will prevent concurrent data changes and ensure subsequent reads of the table see a stable view of committed data, because &lt;code&gt;SHARE&lt;/code&gt; lock mode conflicts with the &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; lock acquired by writers, and your &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; statement will wait until any concurrent holders of &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode locks commit or roll back. Thus, once you obtain the lock, there are no uncommitted writes outstanding; furthermore none can begin until you release the lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a870f6af21f8dafd4cc733a991bd99fd9d13ef" translate="yes" xml:space="preserve">
          <source>When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt;. For example, with the session time zone set to &lt;code&gt;CST7CDT&lt;/code&gt;, &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; will produce &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt;, while adding &lt;code&gt;interval '24 hours'&lt;/code&gt; to the same initial &lt;code&gt;timestamp with time zone&lt;/code&gt; produces &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt;, as there is a change in daylight saving time at &lt;code&gt;2005-04-03 02:00&lt;/code&gt; in time zone &lt;code&gt;CST7CDT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1434d3ccf06b603b0c31a66fe4b553e885790f9" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;Append&lt;/code&gt; node is used in a parallel plan, each process will execute the child plans in the order in which they appear, so that all participating processes cooperate to execute the first child plan until it is complete and then move to the second plan at around the same time. When a &lt;code&gt;Parallel Append&lt;/code&gt; is used instead, the executor will instead spread out the participating processes as evenly as possible across its child plans, so that multiple child plans are executed simultaneously. This avoids contention, and also avoids paying the startup cost of a child plan in those processes that never execute it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4864e701f86b03083b18f6c388ffa7cee629fe" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;INSERT&lt;/code&gt; command has an auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause, if the &lt;code&gt;UPDATE&lt;/code&gt; path is taken, the row to be updated is first checked against the &lt;code&gt;USING&lt;/code&gt; expressions of any &lt;code&gt;UPDATE&lt;/code&gt; policies, and then the new updated row is checked against the &lt;code&gt;WITH CHECK&lt;/code&gt; expressions. Note, however, that unlike a standalone &lt;code&gt;UPDATE&lt;/code&gt; command, if the existing row does not pass the &lt;code&gt;USING&lt;/code&gt; expressions, an error will be thrown (the &lt;code&gt;UPDATE&lt;/code&gt; path will &lt;em&gt;never&lt;/em&gt; be silently avoided).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ddde61a4b6e8647a9abfe81db27fb6ec9b4388" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;N&lt;/code&gt;-dimensional array is pushed onto the beginning or end of an &lt;code&gt;N+1&lt;/code&gt;-dimensional array, the result is analogous to the element-array case above. Each &lt;code&gt;N&lt;/code&gt;-dimensional sub-array is essentially an element of the &lt;code&gt;N+1&lt;/code&gt;-dimensional array's outer dimension. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31260cf4fd42afa924c8ee13fbb974bf90d187b0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; command affects an inheritance hierarchy, the output might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c47d72e8415ae2214a0b4c8ffca096b8ee4f7c5" translate="yes" xml:space="preserve">
          <source>When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d2b87c80e1af3054e4c9d4d3c71d80a5607eb6" translate="yes" xml:space="preserve">
          <source>When an aggregate function is used as a window function, it aggregates over the rows within the current row's window frame. An aggregate used with &lt;code&gt;ORDER BY&lt;/code&gt; and the default window frame definition produces a &amp;ldquo;running sum&amp;rdquo; type of behavior, which may or may not be what's wanted. To obtain aggregation over the whole partition, omit &lt;code&gt;ORDER BY&lt;/code&gt; or use &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt;. Other frame specifications can be used to obtain other effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b60eb6cf1570c88f1c1631b3c6e4c5824a2f8b" translate="yes" xml:space="preserve">
          <source>When an alias is applied to the output of a &lt;code&gt;JOIN&lt;/code&gt; clause, the alias hides the original name(s) within the &lt;code&gt;JOIN&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0151521ad4c1bed3dd275586a7870760908f04a0" translate="yes" xml:space="preserve">
          <source>When an application receives this error message, it should abort the current transaction and retry the whole transaction from the beginning. The second time through, the transaction will see the previously-committed change as part of its initial view of the database, so there is no logical conflict in using the new version of the row as the starting point for the new transaction's update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee9b3bf4967c5d2fb0d054d753f418145337cf0" translate="yes" xml:space="preserve">
          <source>When an enum type is created, its members are assigned sort-order positions 1..&lt;code&gt;n&lt;/code&gt;. But members added later might be given negative or fractional values of &lt;code&gt;enumsortorder&lt;/code&gt;. The only requirement on these values is that they be correctly ordered and unique within each enum type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0950043f7233c157a718d379ee2b34585d4ee731" translate="yes" xml:space="preserve">
          <source>When an index is declared unique, multiple table rows with equal indexed values are not allowed. Null values are not considered equal. A multicolumn unique index will only reject cases where all indexed columns are equal in multiple rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa9424b6df0026312433f3f9260dd9161451961" translate="yes" xml:space="preserve">
          <source>When an index page split is necessary, this function decides which entries on the page are to stay on the old page, and which are to move to the new page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d21498c252827ceaa7947111042a06bc38a5a5" translate="yes" xml:space="preserve">
          <source>When an index scan is used, a temporary copy of the table is created that contains the table data in the index order. Temporary copies of each index on the table are created as well. Therefore, you need free space on disk at least equal to the sum of the table size and the index sizes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad624a33f1e64269d27c153de83dc5212addec4" translate="yes" xml:space="preserve">
          <source>When an object is created, it is assigned an owner. The owner is normally the role that executed the creation statement. For most kinds of objects, the initial state is that only the owner (or a superuser) can do anything with the object. To allow other roles to use it, &lt;em&gt;privileges&lt;/em&gt; must be granted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016db50c093e11f2c3975978fc13dbb74ccca023" translate="yes" xml:space="preserve">
          <source>When an operator or function of the underlying type is applied to a domain value, the domain is automatically down-cast to the underlying type. Thus, for example, the result of &lt;code&gt;mytable.id - 1&lt;/code&gt; is considered to be of type &lt;code&gt;integer&lt;/code&gt; not &lt;code&gt;posint&lt;/code&gt;. We could write &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; to cast the result back to &lt;code&gt;posint&lt;/code&gt;, causing the domain's constraints to be rechecked. In this case, that would result in an error if the expression had been applied to an &lt;code&gt;id&lt;/code&gt; value of 1. Assigning a value of the underlying type to a field or variable of the domain type is allowed without writing an explicit cast, but the domain's constraints will be checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d220c80b589197cba0d859444da322b0880222c" translate="yes" xml:space="preserve">
          <source>When archiving WAL data, we need to capture the contents of each segment file once it is filled, and save that data somewhere before the segment file is recycled for reuse. Depending on the application and the available hardware, there could be many different ways of &amp;ldquo;saving the data somewhere&amp;rdquo;: we could copy the segment files to an NFS-mounted directory on another machine, write them onto a tape drive (ensuring that you have a way of identifying the original name of each file), or batch them together and burn them onto CDs, or something else entirely. To provide the database administrator with flexibility, PostgreSQL tries not to make any assumptions about how the archiving will be done. Instead, PostgreSQL lets the administrator specify a shell command to be executed to copy a completed segment file to wherever it needs to go. The command could be as simple as a &lt;code&gt;cp&lt;/code&gt;, or it could invoke a complex shell script &amp;mdash; it's all up to you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d93c6ecb33c6eb94db27d2fba2d265ff994790" translate="yes" xml:space="preserve">
          <source>When autosummarization is enabled, each time a page range is filled a request is sent to autovacuum for it to execute a targeted summarization for that range, to be fulfilled at the end of the next worker run on the same database. If the request queue is full, the request is not recorded and a message is sent to the server log:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f660851bc52c800a20554ffeb6a7df92726f03b4" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-b&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are given, the behavior is to output large objects, when data is being dumped, see the &lt;code&gt;-b&lt;/code&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad45f5349fac03bd7966e305b187db06383f5ed7" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given for the same schema name, the &lt;code&gt;-N&lt;/code&gt; switch wins and the schema is excluded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede3b8af7caafd954943fe5f04f3a1cc429ba018" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given, the behavior is to dump just the schemas that match at least one &lt;code&gt;-n&lt;/code&gt; switch but no &lt;code&gt;-N&lt;/code&gt; switches. If &lt;code&gt;-N&lt;/code&gt; appears without &lt;code&gt;-n&lt;/code&gt;, then schemas matching &lt;code&gt;-N&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031547c5dfb59556734ca49134f210c68e4c5520" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-t&lt;/code&gt; and &lt;code&gt;-T&lt;/code&gt; are given, the behavior is to dump just the tables that match at least one &lt;code&gt;-t&lt;/code&gt; switch but no &lt;code&gt;-T&lt;/code&gt; switches. If &lt;code&gt;-T&lt;/code&gt; appears without &lt;code&gt;-t&lt;/code&gt;, then tables matching &lt;code&gt;-T&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e63ae1dfc17974e0be483ba0ff638bbea32a3b3" translate="yes" xml:space="preserve">
          <source>When casting from &lt;code&gt;EAN13&lt;/code&gt; to another type, there is a run-time check that the value is within the domain of the other type, and an error is thrown if not. The other casts are simply relabelings that will always succeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b112e4a8b6a5ae3071dcef7339526c0bc3d3e45" translate="yes" xml:space="preserve">
          <source>When changing this value, consider also adjusting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;, and &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db437265a89a8152322953823332b5732e1c0d00" translate="yes" xml:space="preserve">
          <source>When choosing OIDs for a patch that is not expected to be committed immediately, best practice is to use a group of more-or-less consecutive OIDs starting with some random choice in the range 8000&amp;mdash;9999. This minimizes the risk of OID collisions with other patches being developed concurrently. To keep the 8000&amp;mdash;9999 range free for development purposes, after a patch has been committed to the master git repository its OIDs should be renumbered into available space below that range. Typically, this will be done near the end of each development cycle, moving all OIDs consumed by patches committed in that cycle at the same time. The script &lt;code&gt;renumber_oids.pl&lt;/code&gt; can be used for this purpose. If an uncommitted patch is found to have OID conflicts with some recently-committed patch, &lt;code&gt;renumber_oids.pl&lt;/code&gt; may also be useful for recovering from that situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9881b7b2a51c119b916b26c12b2f50a595bc868b" translate="yes" xml:space="preserve">
          <source>When compiled with OpenSSL, there will be more algorithms available. Also public-key encryption functions will be faster as OpenSSL has more optimized BIGNUM functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2a4f35ae5e876b04f4e8702b5ef942899c0855" translate="yes" xml:space="preserve">
          <source>When compiled with zlib, PGP encryption functions are able to compress data before encrypting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4526356cc9d2b5524d1c0613a2cac8e5545975fc" translate="yes" xml:space="preserve">
          <source>When compiling the preprocessed C code files, the compiler needs to be able to find the ECPG header files in the PostgreSQL include directory. Therefore, you might have to use the &lt;code&gt;-I&lt;/code&gt; option when invoking the compiler (e.g., &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cfdda77ce1539f64bc346b96c3160b7466725a" translate="yes" xml:space="preserve">
          <source>When computing the selectivity for a query involving functionally dependent columns, the planner adjusts the per-condition selectivity estimates using the dependency coefficients so as not to produce an underestimate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ea042e28fa2362fa9c26ca7e49e9bd0ec5e906" translate="yes" xml:space="preserve">
          <source>When connecting to the database make sure you have a ticket for a principal matching the requested database user name. For example, for database user name &lt;code&gt;fred&lt;/code&gt;, principal &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; would be able to connect. To also allow principal &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt;, use a user name map, as described in &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb2d529ca9e4c06995d0fca116b867907b7f0d6" translate="yes" xml:space="preserve">
          <source>When connecting to the database server, a client must specify in its connection request the name of the database it wants to connect to. It is not possible to access more than one database per connection. However, an application is not restricted in the number of connections it opens to the same or other databases. Databases are physically separated and access control is managed at the connection level. If one PostgreSQL server instance is to house projects or users that should be separate and for the most part unaware of each other, it is therefore recommended to put them into separate databases. If the projects or users are interrelated and should be able to use each other's resources, they should be put in the same database but possibly into separate schemas. Schemas are a purely logical structure and who can access what is managed by the privilege system. More information about managing schemas is in &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d0d4ecddcc515b05d012f2d76c53d27fb85b80" translate="yes" xml:space="preserve">
          <source>When continuous WAL archiving is used in a standby, there are two different scenarios: the WAL archive can be shared between the primary and the standby, or the standby can have its own WAL archive. When the standby has its own WAL archive, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;always&lt;/code&gt;, and the standby will call the archive command for every WAL segment it receives, whether it's by restoring from the archive or by streaming replication. The shared archive can be handled similarly, but the &lt;code&gt;archive_command&lt;/code&gt; must test if the file being archived exists already, and if the existing file has identical contents. This requires more care in the &lt;code&gt;archive_command&lt;/code&gt;, as it must be careful to not overwrite an existing file with different contents, but return success if the exactly same file is archived twice. And all that must be done free of race conditions, if two servers attempt to archive the same file at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206b825e98c6a586acace075380fd147e6696a55" translate="yes" xml:space="preserve">
          <source>When converting textual JSON input into &lt;code&gt;jsonb&lt;/code&gt;, the primitive types described by RFC 7159 are effectively mapped onto native PostgreSQL types, as shown in &lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;Table 8.23&lt;/a&gt;. Therefore, there are some minor additional constraints on what constitutes valid &lt;code&gt;jsonb&lt;/code&gt; data that do not apply to the &lt;code&gt;json&lt;/code&gt; type, nor to JSON in the abstract, corresponding to limits on what can be represented by the underlying data type. Notably, &lt;code&gt;jsonb&lt;/code&gt; will reject numbers that are outside the range of the PostgreSQL &lt;code&gt;numeric&lt;/code&gt; data type, while &lt;code&gt;json&lt;/code&gt; will not. Such implementation-defined restrictions are permitted by RFC 7159. However, in practice such problems are far more likely to occur in other implementations, as it is common to represent JSON's &lt;code&gt;number&lt;/code&gt; primitive type as IEEE 754 double precision floating point (which RFC 7159 explicitly anticipates and allows for). When using JSON as an interchange format with such systems, the danger of losing numeric precision compared to data originally stored by PostgreSQL should be considered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e063ec55d6b5085c54d075810d580142922489d3" translate="yes" xml:space="preserve">
          <source>When creating a comment on a constraint, a trigger, a rule or a policy these parameters specify the name of the table or domain on which that object is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696e17ed5a7d60938c1cece83fb1d6b1c0903390" translate="yes" xml:space="preserve">
          <source>When creating a hash partition, a modulus and remainder must be specified. The modulus must be a positive integer, and the remainder must be a non-negative integer less than the modulus. Typically, when initially setting up a hash-partitioned table, you should choose a modulus equal to the number of partitions and assign every table the same modulus and a different remainder (see examples, below). However, it is not required that every partition have the same modulus, only that every modulus which occurs among the partitions of a hash-partitioned table is a factor of the next larger modulus. This allows the number of partitions to be increased incrementally without needing to move all the data at once. For example, suppose you have a hash-partitioned table with 8 partitions, each of which has modulus 8, but find it necessary to increase the number of partitions to 16. You can detach one of the modulus-8 partitions, create two new modulus-16 partitions covering the same portion of the key space (one with a remainder equal to the remainder of the detached partition, and the other with a remainder equal to that value plus 8), and repopulate them with data. You can then repeat this -- perhaps at a later time -- for each modulus-8 partition until none remain. While this may still involve a large amount of data movement at each step, it is still better than having to create a whole new table and move all the data at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc592c55de3b2852cc094ece1e21e03a790645cd" translate="yes" xml:space="preserve">
          <source>When creating a list partition, &lt;code&gt;NULL&lt;/code&gt; can be specified to signify that the partition allows the partition key column to be null. However, there cannot be more than one such list partition for a given parent table. &lt;code&gt;NULL&lt;/code&gt; cannot be specified for range partitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959c4be92ae7a89cd93733c9fb53bfb204d0cf54" translate="yes" xml:space="preserve">
          <source>When creating a range partition involving more than one column, it can also make sense to use &lt;code&gt;MAXVALUE&lt;/code&gt; as part of the lower bound, and &lt;code&gt;MINVALUE&lt;/code&gt; as part of the upper bound. For example, a partition defined using &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; allows any rows where the first partition key column is greater than 0 and less than or equal to 10. Similarly, a partition defined using &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; allows any rows where the first partition key column starts with &quot;a&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57bc08d42f10eaae11d2af1199ad3605b863277f" translate="yes" xml:space="preserve">
          <source>When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt;, a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt;, &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812122c3d99be13340fb205c1949bf12eabae44b" translate="yes" xml:space="preserve">
          <source>When creating a replication slot (the default behavior), &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de7cd6bf9e49c5d84cc8863ddd6e1c17c3e9e579" translate="yes" xml:space="preserve">
          <source>When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005a2c498e4cc6e0542ca9414edc2d0ef17812bb" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the remote host is not reachable or in an unclear state. In that case, the subscription can be created using the &lt;code&gt;connect = false&lt;/code&gt; option. The remote host will then not be contacted at all. This is what pg_dump uses. The remote replication slot will then have to be created manually before the subscription can be activated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ca2fb6b711dd16e241f960cfce7ef591df396f" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the replication slot already exists. In that case, the subscription can be created using the &lt;code&gt;create_slot = false&lt;/code&gt; option to associate with the existing slot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16abed6745cbdfc58355b822cc58590cd4574664" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the number of partitions on which the index has been completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf84112606c62d754e9e14623f4cabe94d1c440" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the total number of partitions on which the index is to be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f225feca5ba0ff2fa1c5fa9fb76ca1ce05ad30d" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, a &lt;code&gt;choose&lt;/code&gt; result of &lt;code&gt;spgMatchNode&lt;/code&gt; is interpreted to mean that the new value can be assigned to any of the equivalent nodes; the core code will ignore the supplied &lt;code&gt;nodeN&lt;/code&gt; value and descend into one of the nodes at random (so as to keep the tree balanced). It is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since that would make the nodes not all equivalent; the &lt;code&gt;spgSplitTuple&lt;/code&gt; action must be used if the value to be inserted doesn't match the existing nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc81dfaf2529806492d6926ee92f707f3d6c4c1b" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, the &lt;code&gt;inner_consistent&lt;/code&gt; function should return either all or none of the nodes as targets for continuing the index search, since they are all equivalent. This may or may not require any special-case code, depending on how much the &lt;code&gt;inner_consistent&lt;/code&gt; function normally assumes about the meaning of the nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32b90019e8bbf81fee22cbcc2778aa7cfddfd6c" translate="yes" xml:space="preserve">
          <source>When dealing with multiple-argument aggregate functions, note that the &lt;code&gt;ORDER BY&lt;/code&gt; clause goes after all the aggregate arguments. For example, write this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8f5c244f8f3ee5e69ba2a3cc1d82f9a3714553" translate="yes" xml:space="preserve">
          <source>When dealing with outer joins, you might see join plan nodes with both &amp;ldquo;Join Filter&amp;rdquo; and plain &amp;ldquo;Filter&amp;rdquo; conditions attached. Join Filter conditions come from the outer join's &lt;code&gt;ON&lt;/code&gt; clause, so a row that fails the Join Filter condition could still get emitted as a null-extended row. But a plain Filter condition is applied after the outer-join rules and so acts to remove rows unconditionally. In an inner join there is no semantic difference between these types of filters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4bff252219a510e2ce0b73debb16a2f8ba45f1" translate="yes" xml:space="preserve">
          <source>When deciding what is a longer or shorter match, match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example: &lt;code&gt;bb*&lt;/code&gt; matches the three middle characters of &lt;code&gt;abbbc&lt;/code&gt;; &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; matches all ten characters of &lt;code&gt;weeknights&lt;/code&gt;; when &lt;code&gt;(.*).*&lt;/code&gt; is matched against &lt;code&gt;abc&lt;/code&gt; the parenthesized subexpression matches all three characters; and when &lt;code&gt;(a*)*&lt;/code&gt; is matched against &lt;code&gt;bc&lt;/code&gt; both the whole RE and the parenthesized subexpression match an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51f30bba3581f1e69eb69eac04311486d90890a" translate="yes" xml:space="preserve">
          <source>When defining the path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similar to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359ea83f4fdb1b7fa655731f901be35273bbf743" translate="yes" xml:space="preserve">
          <source>When dropping a subscription that is associated with a replication slot on the remote host (the normal state), &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will connect to the remote host and try to drop the replication slot as part of its operation. This is necessary so that the resources allocated for the subscription on the remote host are released. If this fails, either because the remote host is not reachable or because the remote replication slot cannot be dropped or does not exist or never existed, the &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; command will fail. To proceed in this situation, disassociate the subscription from the replication slot by executing &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt;. After that, &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will no longer attempt any actions on a remote host. Note that if the remote replication slot still exists, it should then be dropped manually; otherwise it will continue to reserve WAL and might eventually cause the disk to fill up. See also &lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;Section 30.2.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b8b09fc04797b1f4bd77cb938d65220f3c98d4" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the remote host is not reachable. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription. If the remote database instance no longer exists, no further action is then necessary. If, however, the remote database instance is just unreachable, the replication slot should then be dropped manually; otherwise it would continue to reserve WAL and might eventually cause the disk to fill up. Such cases should be carefully investigated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef261ef51923658a5c92b355545488277ab638d" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the replication slot should be kept. This could be useful when the subscriber database is being moved to a different host and will be activated from there. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7012bb7adb09426a92f880209bcb563fe9379138" translate="yes" xml:space="preserve">
          <source>When dumping data for a table partition, make the &lt;code&gt;COPY&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt; statements target the root of the partitioning hierarchy that contains it, rather than the partition itself. This causes the appropriate partition to be re-determined for each row when the data is loaded. This may be useful when reloading data on a server where rows do not always fall into the same partitions as they did on the original server. That could happen, for example, if the partitioning column is of type text and the two systems have different definitions of the collation used to sort the partitioning column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c4665e18254fa2583d0b9a6ca4200ef73e4faf" translate="yes" xml:space="preserve">
          <source>When dumping logical replication subscriptions, pg_dump will generate &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; commands that use the &lt;code&gt;connect = false&lt;/code&gt; option, so that restoring the subscription does not make remote connections for creating a replication slot or for initial table copy. That way, the dump can be restored without requiring network access to the remote servers. It is then up to the user to reactivate the subscriptions in a suitable way. If the involved hosts have changed, the connection information might have to be changed. It might also be appropriate to truncate the target tables before initiating a new full table copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edeac7aa265daa84ac15a79b57465693d865b8ff" translate="yes" xml:space="preserve">
          <source>When either stderr or csvlog are included, the file &lt;code&gt;current_logfiles&lt;/code&gt; is created to record the location of the log file(s) currently in use by the logging collector and the associated logging destination. This provides a convenient way to find the logs currently in use by the instance. Here is an example of this file's content:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf7e84c79ef7d8674ff36f5bd69afa904df5b94" translate="yes" xml:space="preserve">
          <source>When encrypting with a public key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8c4c4accb682e67b5f8b1813c77704fe93cbcb0" translate="yes" xml:space="preserve">
          <source>When encrypting with a symmetric key (i.e., a password):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0cd6f3816a8188a89deee57f710a1baaa98cf3" translate="yes" xml:space="preserve">
          <source>When entering &lt;code&gt;bytea&lt;/code&gt; values in escape format, octets of certain values &lt;em&gt;must&lt;/em&gt; be escaped, while all octet values &lt;em&gt;can&lt;/em&gt; be escaped. In general, to escape an octet, convert it into its three-digit octal value and precede it by a backslash. Backslash itself (octet decimal value 92) can alternatively be represented by double backslashes. &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; shows the characters that must be escaped, and gives the alternative escape sequences where applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b723af7e86ecb6fa9f1f4fcf436b5692ddd09fd" translate="yes" xml:space="preserve">
          <source>When establishing a unique constraint for a multi-level partition hierarchy, all the columns in the partition key of the target partitioned table, as well as those of all its descendant partitioned tables, must be included in the constraint definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5828ba22818bd784c0d1de682badc9fdcf5283f1" translate="yes" xml:space="preserve">
          <source>When estimating the selectivity, the planner applies all the conditions on items in the MCV list, and then sums the frequencies of the matching ones. See &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; in &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716da7567a674fa423040a77262890c91b3b1491" translate="yes" xml:space="preserve">
          <source>When estimating with functional dependencies, the planner assumes that conditions on the involved columns are compatible and hence redundant. If they are incompatible, the correct estimate would be zero rows, but that possibility is not considered. For example, given a query like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064d226f0b61cda9a60ca08881b4d97cee01ca7a" translate="yes" xml:space="preserve">
          <source>When executed on a primary, the function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt;, the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. The return value is the backup's ending write-ahead log location (which again can be ignored). After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b575c812fb039c331ed73bad6b9599e79ed09b9b" translate="yes" xml:space="preserve">
          <source>When executed, the example D script gives output such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9cbbd3bd8e290879a575143872c711e1071acb" translate="yes" xml:space="preserve">
          <source>When executing a parallel plan, you can use &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; to display per-worker statistics for each plan node. This may be useful in determining whether the work is being evenly distributed between all plan nodes and more generally in understanding the performance characteristics of the plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c9db9afb12cc927dcae6f85bc0fefc8f88ecba" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion so as its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45578e8de56cf79c1bab7717b9b7f3794e4ce080" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source, a role having sufficient permissions to execute the functions used by pg_rewind on the source cluster can be used instead of a superuser. Here is how to create such a role, named &lt;code&gt;rewind_user&lt;/code&gt; here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8da664aa55aa1d9ba572665740c9977324d898" translate="yes" xml:space="preserve">
          <source>When false, the command will not try to refresh table information. &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; should then be executed separately. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12b7ebd6720c102addd509acf7a1b3a9bca1905" translate="yes" xml:space="preserve">
          <source>When host names are specified in &lt;code&gt;pg_hba.conf&lt;/code&gt;, you should make sure that name resolution is reasonably fast. It can be of advantage to set up a local name resolution cache such as &lt;code&gt;nscd&lt;/code&gt;. Also, you may wish to enable the configuration parameter &lt;code&gt;log_hostname&lt;/code&gt; to see the client's host name instead of the IP address in the log.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b7c985f760c5c9e2832f32ef829164b2539557" translate="yes" xml:space="preserve">
          <source>When ident is specified for a local (non-TCP/IP) connection, peer authentication (see &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt;) will be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c1aa17a38d25550246efe2b31fe8f5cb3b0dba" translate="yes" xml:space="preserve">
          <source>When indexes are not used, it can be useful for testing to force their use. There are run-time parameters that can turn off various plan types (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;). For instance, turning off sequential scans (&lt;code&gt;enable_seqscan&lt;/code&gt;) and nested-loop joins (&lt;code&gt;enable_nestloop&lt;/code&gt;), which are the most basic plans, will force the system to use a different plan. If the system still chooses a sequential scan or nested-loop join then there is probably a more fundamental reason why the index is not being used; for example, the query condition does not match the index. (What kind of query can use what kind of index is explained in the previous sections.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e50d0004d8680329345366b2774f5ebb4ad654f" translate="yes" xml:space="preserve">
          <source>When inserting a lot of data at the same time, consider using the &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. It is not as flexible as the &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; command, but is more efficient. Refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt; for more information on improving bulk loading performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb95bd9b76a1aa6b1bb1f21c135d8d5ba87cb03" translate="yes" xml:space="preserve">
          <source>When issuing queries in a database where some users mistrust other users, observe security precautions from &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt; when writing function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed9176dec0c08e99a6d40ec733c0b7bac5bbcf2" translate="yes" xml:space="preserve">
          <source>When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.17&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43ae9852bbd4e7fca0407119c0359f8ae17da03" translate="yes" xml:space="preserve">
          <source>When loading large amounts of data into an installation that uses WAL archiving or streaming replication, it might be faster to take a new base backup after the load has completed than to process a large amount of incremental WAL data. To prevent incremental WAL logging while loading, disable archiving and streaming replication, by setting &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; to &lt;code&gt;minimal&lt;/code&gt;, &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;, and &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; to zero. But note that changing these settings requires a server restart.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a320947bd6f8b1714ed336d766e812f876be824d" translate="yes" xml:space="preserve">
          <source>When logging to event log is enabled, this parameter determines the program name used to identify PostgreSQL messages in the log. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688b202e83ca61ee5187e2a33b6d2092af8c2739" translate="yes" xml:space="preserve">
          <source>When logging to syslog and this is on (the default), then each message will be prefixed by an increasing sequence number (such as &lt;code&gt;[2]&lt;/code&gt;). This circumvents the &amp;ldquo;--- last message repeated N times ---&amp;rdquo; suppression that many syslog implementations perform by default. In more modern syslog implementations, repeated message suppression can be configured (for example, &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; in rsyslog), so this might not be necessary. Also, you could turn this off if you actually want to suppress repeated messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8a396481d44a42fb2aa24b4ad06150638300e9" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines how messages are delivered to syslog. When on (the default), messages are split by lines, and long lines are split so that they will fit into 1024 bytes, which is a typical size limit for traditional syslog implementations. When off, PostgreSQL server log messages are delivered to the syslog service as is, and it is up to the syslog service to cope with the potentially bulky messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ff0840aef3199452ea4eb2990b10a8d1c55939" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the program name used to identify PostgreSQL messages in syslog logs. The default is &lt;code&gt;postgres&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985b03993881f4457d8f0c3b34d9b7b01342f4d8" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the syslog &amp;ldquo;facility&amp;rdquo; to be used. You can choose from &lt;code&gt;LOCAL0&lt;/code&gt;, &lt;code&gt;LOCAL1&lt;/code&gt;, &lt;code&gt;LOCAL2&lt;/code&gt;, &lt;code&gt;LOCAL3&lt;/code&gt;, &lt;code&gt;LOCAL4&lt;/code&gt;, &lt;code&gt;LOCAL5&lt;/code&gt;, &lt;code&gt;LOCAL6&lt;/code&gt;, &lt;code&gt;LOCAL7&lt;/code&gt;; the default is &lt;code&gt;LOCAL0&lt;/code&gt;. See also the documentation of your system's syslog daemon. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30985843aab3e94f2bd3bce331e8a5523cabcbb" translate="yes" xml:space="preserve">
          <source>When more than one expression is specified, the later values are used to sort rows that are equal according to the earlier values. Each expression can be followed by an optional &lt;code&gt;ASC&lt;/code&gt; or &lt;code&gt;DESC&lt;/code&gt; keyword to set the sort direction to ascending or descending. &lt;code&gt;ASC&lt;/code&gt; order is the default. Ascending order puts smaller values first, where &amp;ldquo;smaller&amp;rdquo; is defined in terms of the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. Similarly, descending order is determined with the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11912d8e839cffb71f2e5fc45344859e046a9cbc" translate="yes" xml:space="preserve">
          <source>When more than one row is specified, all the rows must have the same number of elements. The data types of the resulting table's columns are determined by combining the explicit or inferred types of the expressions appearing in that column, using the same rules as for &lt;code&gt;UNION&lt;/code&gt; (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcff81a7a0194a63301c74dc5ce189cffc265222" translate="yes" xml:space="preserve">
          <source>When multiple policies apply to a given query, they are combined using either &lt;code&gt;OR&lt;/code&gt; (for permissive policies, which are the default) or using &lt;code&gt;AND&lt;/code&gt; (for restrictive policies). This is similar to the rule that a given role has the privileges of all roles that they are a member of. Permissive vs. restrictive policies are discussed further below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269b9ef4adee76f3240604e5767201bc6ee01e71" translate="yes" xml:space="preserve">
          <source>When multiple policies of different command types apply to the same command (for example, &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; policies applied to an &lt;code&gt;UPDATE&lt;/code&gt; command), then the user must have both types of permissions (for example, permission to select rows from the relation as well as permission to update them). Thus the expressions for one type of policy are combined with the expressions for the other type of policy using the &lt;code&gt;AND&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556057cb09a8742cb36bd19c1657e03ac61a815b" translate="yes" xml:space="preserve">
          <source>When multiple policies of the same command type apply to the same command, then there must be at least one &lt;code&gt;PERMISSIVE&lt;/code&gt; policy granting access to the relation, and all of the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policies must pass. Thus all the &lt;code&gt;PERMISSIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;OR&lt;/code&gt;, all the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;AND&lt;/code&gt;, and the results are combined using &lt;code&gt;AND&lt;/code&gt;. If there are no &lt;code&gt;PERMISSIVE&lt;/code&gt; policies, then access is denied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6d15be5ddf45a51b853b506d5d1a1d2068106c" translate="yes" xml:space="preserve">
          <source>When multiple window functions are used, all the window functions having syntactically equivalent &lt;code&gt;PARTITION BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; clauses in their window definitions are guaranteed to be evaluated in a single pass over the data. Therefore they will see the same sort ordering, even if the &lt;code&gt;ORDER BY&lt;/code&gt; does not uniquely determine an ordering. However, no guarantees are made about the evaluation of functions having different &lt;code&gt;PARTITION BY&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; specifications. (In such cases a sort step is typically required between the passes of window function evaluations, and the sort is not guaranteed to preserve ordering of rows that its &lt;code&gt;ORDER BY&lt;/code&gt; sees as equivalent.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f31d5224ac605a926f4e92907e12ec5add9474" translate="yes" xml:space="preserve">
          <source>When multiple workers are running, the autovacuum cost delay parameters (see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;Section 19.4.4&lt;/a&gt;) are &amp;ldquo;balanced&amp;rdquo; among all the running workers, so that the total I/O impact on the system is the same regardless of the number of workers actually running. However, any workers processing tables whose per-table &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; or &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; storage parameters have been set are not considered in the balancing algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84f11ff5e7225ec364ea450b05da5b31bd525923" translate="yes" xml:space="preserve">
          <source>When no final &lt;code&gt;ELSE&lt;/code&gt; clause is provided to a &lt;code&gt;CASE&lt;/code&gt;, the default value is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2d002b299026c6a8e3abc29ae594e572a6b112" translate="yes" xml:space="preserve">
          <source>When non-serializable writes are possible, to ensure the current validity of a row and protect it against concurrent updates one must use &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or an appropriate &lt;code&gt;LOCK TABLE&lt;/code&gt; statement. (&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; lock just the returned rows against concurrent updates, while &lt;code&gt;LOCK TABLE&lt;/code&gt; locks the whole table.) This should be taken into account when porting applications to PostgreSQL from other environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5d4ed5a8f5b52f15315d7a651b9128c1d498f8" translate="yes" xml:space="preserve">
          <source>When not all owned objects are to be transferred to the same successor owner, it's best to handle the exceptions manually and then perform the above steps to mop up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8afcb65f27d90b88c36a924e96931352e55b61" translate="yes" xml:space="preserve">
          <source>When not using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, the &lt;code&gt;column_definition&lt;/code&gt; list replaces the column alias list that could otherwise be attached to the &lt;code&gt;FROM&lt;/code&gt; item; the names in the column definitions serve as column aliases. When using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, a &lt;code&gt;column_definition&lt;/code&gt; list can be attached to each member function separately; or if there is only one member function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause, a &lt;code&gt;column_definition&lt;/code&gt; list can be written in place of a column alias list following &lt;code&gt;ROWS FROM()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c266fb8eeefdc22c382f51ddfa36d2cdf3fd08" translate="yes" xml:space="preserve">
          <source>When objects are created without specifying a particular target schema, they will be placed in the first valid schema named in &lt;code&gt;search_path&lt;/code&gt;. An error is reported if the search path is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ff2ff0bf302907b157207503609b9e0138a5a9" translate="yes" xml:space="preserve">
          <source>When on, a warning is issued if a backslash (&lt;code&gt;\&lt;/code&gt;) appears in an ordinary string literal (&lt;code&gt;'...'&lt;/code&gt; syntax) and &lt;code&gt;standard_conforming_strings&lt;/code&gt; is off. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a39a26ef7d5c306f15cfec242fa1908a71ae3775" translate="yes" xml:space="preserve">
          <source>When on, expressions of the form &lt;code&gt;expr = NULL&lt;/code&gt; (or &lt;code&gt;NULL = expr&lt;/code&gt;) are treated as &lt;code&gt;expr IS NULL&lt;/code&gt;, that is, they return true if &lt;code&gt;expr&lt;/code&gt; evaluates to the null value, and false otherwise. The correct SQL-spec-compliant behavior of &lt;code&gt;expr = NULL&lt;/code&gt; is to always return null (unknown). Therefore this parameter defaults to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd83814e734e8771d44c1de9842876866f19a1c6" translate="yes" xml:space="preserve">
          <source>When on, the parser will emit a warning for any construct that might have changed meanings since PostgreSQL 9.4 as a result of changes in operator precedence. This is useful for auditing applications to see if precedence changes have broken anything; but it is not meant to be kept turned on in production, since it will warn about some perfectly valid, standard-compliant SQL code. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61f3e69afe30c64a291d60390d7c29326445c47" translate="yes" xml:space="preserve">
          <source>When operators and support functions are added to a family with &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt;, they are not part of any specific operator class within the family, but are just &amp;ldquo;loose&amp;rdquo; within the family. This indicates that these operators and functions are compatible with the family's semantics, but are not required for correct functioning of any specific index. (Operators and functions that are so required should be declared as part of an operator class, instead; see &lt;a href=&quot;sql-createopclass&quot;&gt;CREATE OPERATOR CLASS&lt;/a&gt;.) PostgreSQL will allow loose members of a family to be dropped from the family at any time, but members of an operator class cannot be dropped without dropping the whole class and any indexes that depend on it. Typically, single-data-type operators and functions are part of operator classes because they are needed to support an index on that specific data type, while cross-data-type operators and functions are made loose members of the family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f2ad4b5a54137b2f0c70ae82420f67c0b1b6ea3" translate="yes" xml:space="preserve">
          <source>When queries or updates access a large percentage of a single partition, performance can be improved by taking advantage of sequential scan of that partition instead of using an index and random access reads scattered across the whole table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2540d43e50d1abeb1a847d9db340690266815c23" translate="yes" xml:space="preserve">
          <source>When relying on Serializable transactions to prevent anomalies, it is important that any data read from a permanent user table not be considered valid until the transaction which read it has successfully committed. This is true even for read-only transactions, except that data read within a &lt;em&gt;deferrable&lt;/em&gt; read-only transaction is known to be valid as soon as it is read, because such a transaction waits until it can acquire a snapshot guaranteed to be free from such problems before starting to read any data. In all other cases applications must not depend on results read during a transaction that later aborted; instead, they should retry the transaction until it succeeds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f545c1f8d440a6a74e5e5cae7b49a8321ce778e" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE FUNCTION&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63cb3d013e86db6ef5ef57500326cdf863814f3a" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b358e9fc6a1b297fd0b37a45eac263be99236636" translate="yes" xml:space="preserve">
          <source>When replacing an existing definition, the argument types, result type, and number of direct arguments may not be changed. Also, the new definition must be of the same kind (ordinary aggregate, ordered-set aggregate, or hypothetical-set aggregate) as the old one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf16a952f545e26cfee0e603603bfd07e12cf881" translate="yes" xml:space="preserve">
          <source>When replacing an existing function with &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt;, there are restrictions on changing parameter names. You cannot change the name already assigned to any input parameter (although you can add names to parameters that had none before). If there is more than one output parameter, you cannot change the names of the output parameters, because that would change the column names of the anonymous composite type that describes the function's result. These restrictions are made to ensure that existing calls of the function do not stop working when it is replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80773f67cc3b08f5dcb6c36638c7da08b5a16582" translate="yes" xml:space="preserve">
          <source>When requesting synchronous replication, each commit of a write transaction will wait until confirmation is received that the commit has been written to the write-ahead log on disk of both the primary and standby server. The only possibility that data can be lost is if both the primary and the standby suffer crashes at the same time. This can provide a much higher level of durability, though only if the sysadmin is cautious about the placement and management of the two servers. Waiting for confirmation increases the user's confidence that the changes will not be lost in the event of server crashes but it also necessarily increases the response time for the requesting transaction. The minimum wait time is the round-trip time between primary to standby.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cbfd2d18fb6178afa3088b0725b2bc3fcdf04fe" translate="yes" xml:space="preserve">
          <source>When restoring data to a pre-existing table and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_restore emits commands to disable triggers on user tables before inserting the data, then emits commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade7c8c975218ba23dcef154671330d11fa5728d" translate="yes" xml:space="preserve">
          <source>When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt;, but the behavior is similar. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68adac31376cf57c26d631be30fdfc9650022d2" translate="yes" xml:space="preserve">
          <source>When revoking privileges on a table, the corresponding column privileges (if any) are automatically revoked on each column of the table, as well. On the other hand, if a role has been granted privileges on a table, then revoking the same privileges from individual columns will have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="300dad807edac8d993f28c0997a914c75b99f4bc" translate="yes" xml:space="preserve">
          <source>When rounding values, the &lt;code&gt;numeric&lt;/code&gt; type rounds ties away from zero, while (on most machines) the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; types round ties to the nearest even number. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f76f7c7b77ca49ded558a0639a8d27cc09a3811" translate="yes" xml:space="preserve">
          <source>When row security is enabled on a table (with &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY&lt;/a&gt;), all normal access to the table for selecting rows or modifying rows must be allowed by a row security policy. (However, the table's owner is typically not subject to row security policies.) If no policy exists for the table, a default-deny policy is used, meaning that no rows are visible or can be modified. Operations that apply to the whole table, such as &lt;code&gt;TRUNCATE&lt;/code&gt; and &lt;code&gt;REFERENCES&lt;/code&gt;, are not subject to row security.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226f5e12ea7fb1c629a76bb1b3cc1943cd4502fc" translate="yes" xml:space="preserve">
          <source>When running a long test on hardware that can handle a lot of transactions, the log files can become very large. The &lt;code&gt;--sampling-rate&lt;/code&gt; option can be used to log only a random sample of transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4051fc47591e058546d74bee2aa79ca3ea360af8" translate="yes" xml:space="preserve">
          <source>When running a standby server, you must set this parameter to the same or higher value than on the master server. Otherwise, queries will not be allowed in the standby server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0becdbc99cfe7674fb7d475f00ec87ca3a5a28cc" translate="yes" xml:space="preserve">
          <source>When running at the &lt;code&gt;serializable&lt;/code&gt; isolation level, a deferrable read-only SQL transaction may be delayed before it is allowed to proceed. However, once it begins executing it does not incur any of the overhead required to ensure serializability; so serialization code will have no reason to force it to abort because of concurrent updates, making this option suitable for long-running read-only transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a67057ea54f0f16f47cefbf38d78344e7ecca6" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;on&lt;/code&gt;, if a statement in a transaction block generates an error, the error is ignored and the transaction continues. When set to &lt;code&gt;interactive&lt;/code&gt;, such errors are only ignored in interactive sessions, and not when reading script files. When set to &lt;code&gt;off&lt;/code&gt; (the default), a statement in a transaction block that generates an error aborts the entire transaction. The error rollback mode works by issuing an implicit &lt;code&gt;SAVEPOINT&lt;/code&gt; for you, just before each command that is in a transaction block, and then rolling back to the savepoint if the command fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e9cba78fc8dadeb25eba89d19fc5d8c6ee61b8" translate="yes" xml:space="preserve">
          <source>When set to off, which is the default, PostgreSQL will raise a PANIC-level error on failure to flush modified data files to the file system. This causes the database server to crash. This parameter can only be set at server start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cbaca794cc78ed3c2b124781f712501c0ff4934" translate="yes" xml:space="preserve">
          <source>When set to on, which is the default, PostgreSQL will automatically reinitialize after a backend crash. Leaving this value set to on is normally the best way to maximize the availability of the database. However, in some circumstances, such as when PostgreSQL is being invoked by clusterware, it may be useful to disable the restart so that the clusterware can gain control and take any actions it deems appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b55871d6d7b3f171d441751dee834b0868dec6" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;debug_pretty_print&lt;/code&gt; indents the messages produced by &lt;code&gt;debug_print_parse&lt;/code&gt;, &lt;code&gt;debug_print_rewritten&lt;/code&gt;, or &lt;code&gt;debug_print_plan&lt;/code&gt;. This results in more readable but much longer output than the &amp;ldquo;compact&amp;rdquo; format used when it is off. It is on by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9655c6cce4ab0fb89202aa42165255e7c2310c07" translate="yes" xml:space="preserve">
          <source>When setting any of these parameters, a relative path will be interpreted with respect to the directory in which &lt;code&gt;postgres&lt;/code&gt; is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cba5ccebd44827dbe97e5c58205ecd19cd5549" translate="yes" xml:space="preserve">
          <source>When several data types share near-identical sorting semantics, their operator classes can be grouped into an operator family. Doing so is advantageous because it allows the planner to make deductions about cross-type comparisons. Each operator class within the family should contain the single-type operators (and associated support functions) for its input data type, while cross-type comparison operators and support functions are &amp;ldquo;loose&amp;rdquo; in the family. It is recommendable that a complete set of cross-type operators be included in the family, thus ensuring that the planner can represent any comparison conditions that it deduces from transitivity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb221d1e490779006a131832600e7b4ca11a22c2" translate="yes" xml:space="preserve">
          <source>When showing progress (option &lt;code&gt;-P&lt;/code&gt;), use a timestamp (Unix epoch) instead of the number of seconds since the beginning of the run. The unit is in seconds, with millisecond precision after the dot. This helps compare logs generated by various tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc026cecf0c9d705d368f497265f6e7182739df8" translate="yes" xml:space="preserve">
          <source>When sorting &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; data types, IPv4 addresses will always sort before IPv6 addresses, including IPv4 addresses encapsulated or mapped to IPv6 addresses, such as ::10.2.3.4 or ::ffff:10.4.3.2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00112c1a0dfb2756ee57aac0f953ab1b28e8aa6b" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use a particular collation in order to be matched during inference. Typically this is omitted, as collations usually do not affect whether or not a constraint violation occurs. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ab9aed56a17743958b35c4487c001e52ad9448" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use particular operator class in order to be matched during inference. Typically this is omitted, as the &lt;em&gt;equality&lt;/em&gt; semantics are often equivalent across a type's operator classes anyway, or because it's sufficient to trust that the defined unique indexes have the pertinent definition of equality. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47b14844e6f65e1969fe664f76645a83ada8978" translate="yes" xml:space="preserve">
          <source>When specifying the &lt;code&gt;program&lt;/code&gt; option, keep in mind that the option string is executed by the shell. If you need to pass any arguments to the command that come from an untrusted source, you must be careful to strip or escape any characters that might have special meaning to the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86f4916e3e42d9bf0f446f6ed8f6c9365f0b9b8" translate="yes" xml:space="preserve">
          <source>When starting a client session via libpq, parameter settings can be specified using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable. Settings established in this way constitute defaults for the life of the session, but do not affect other sessions. For historical reasons, the format of &lt;code&gt;PGOPTIONS&lt;/code&gt; is similar to that used when launching the &lt;code&gt;postgres&lt;/code&gt; command; specifically, the &lt;code&gt;-c&lt;/code&gt; flag must be specified. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80810b3a36d5394cd36078211fe98f572205f903" translate="yes" xml:space="preserve">
          <source>When suitable, query results can be shown in a crosstab representation with the &lt;code&gt;\crosstabview&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46f34ffb8c110010cfd3fe050b49b5689c1e534" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, it is the user's responsibility to unpack each tar file before starting the PostgreSQL server. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c7d99e4e21933c48e46c135fcf1d89d1aca09e" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bf3c4060b6a548c1c5420c5acc0dd3edcdfdfa" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11ae7cfc9d8e7c9709340ffb2024d1b68d62efb" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; parameter is set to true on a standby server, it will begin accepting connections once the recovery has brought the system to a consistent state. All such connections are strictly read-only; not even temporary tables may be written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7959e96ecaba15e9d39e3fc41cafc94b8dcfae7f" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CONSTRAINT&lt;/code&gt; option is specified, this command creates a &lt;em&gt;constraint trigger&lt;/em&gt;. This is the same as a regular trigger except that the timing of the trigger firing can be adjusted using &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;. Constraint triggers must be &lt;code&gt;AFTER ROW&lt;/code&gt; triggers on plain tables (not foreign tables). They can be fired either at the end of the statement causing the triggering event, or at the end of the containing transaction; in the latter case they are said to be &lt;em&gt;deferred&lt;/em&gt;. A pending deferred-trigger firing can also be forced to happen immediately by using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;. Constraint triggers are expected to raise an exception when the constraints they implement are violated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5c7d4a7ad0b452626a13ac455de82c0906adea" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;SELECT&lt;/code&gt; is one arm of a &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) construct, or when it appears within &lt;code&gt;INSERT ... SELECT&lt;/code&gt;, this rule is not applied since rules given in preceding sections take precedence. The type of an unspecified-type literal can be taken from the other &lt;code&gt;UNION&lt;/code&gt; arm in the first case, or from the destination column in the second case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2ffb48d56de0e4aaa18bb9efa3e04da4e9e279" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;WHERE&lt;/code&gt; clause is present, a &lt;em&gt;partial index&lt;/em&gt; is created. A partial index is an index that contains entries for only a portion of a table, usually a portion that is more useful for indexing than the rest of the table. For example, if you have a table that contains both billed and unbilled orders where the unbilled orders take up a small fraction of the total table and yet that is an often used section, you can improve performance by creating an index on just that portion. Another possible application is to use &lt;code&gt;WHERE&lt;/code&gt; with &lt;code&gt;UNIQUE&lt;/code&gt; to enforce uniqueness over a subset of a table. See &lt;a href=&quot;indexes-partial&quot;&gt;Section 11.8&lt;/a&gt; for more discussion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c185ac9497904ca6d14d82c8dc0a0e1690d4901" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ampredlocks&lt;/code&gt; flag is not set, any scan using that index access method within a serializable transaction will acquire a nonblocking predicate lock on the full index. This will generate a read-write conflict with the insert of any tuple into that index by a concurrent serializable transaction. If certain patterns of read-write conflicts are detected among a set of concurrent serializable transactions, one of those transactions may be canceled to protect data integrity. When the flag is set, it indicates that the index access method implements finer-grained predicate locking, which will tend to reduce the frequency of such transaction cancellations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c110466857121d054324f74c8a38f9bb5212e4" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;border&lt;/code&gt; setting is greater than zero, the &lt;code&gt;linestyle&lt;/code&gt; option also determines the characters with which the border lines are drawn. Plain ASCII characters work everywhere, but Unicode characters look nicer on displays that recognize them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d6a0dfb20c2e25ada6bca76d0486b409be8ef1" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;off&lt;/code&gt;, the pager program is not used. When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;on&lt;/code&gt;, the pager is used when appropriate, i.e., when the output is to a terminal and will not fit on the screen. The &lt;code&gt;pager&lt;/code&gt; option can also be set to &lt;code&gt;always&lt;/code&gt;, which causes the pager to be used for all terminal output regardless of whether it fits on the screen. &lt;code&gt;\pset pager&lt;/code&gt; without a &lt;code&gt;value&lt;/code&gt; toggles pager use on and off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a140433737ca4c23a575624ce695fcc511dede" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_buffercache&lt;/code&gt; view is accessed, internal buffer manager locks are taken for long enough to copy all the buffer state data that the view will display. This ensures that the view produces a consistent set of results, while not blocking normal buffer activity longer than necessary. Nonetheless there could be some impact on database performance if this view is read often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd60a2856753e705f8fe475e92d422e142a5a733" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_prepared_xacts&lt;/code&gt; view is accessed, the internal transaction manager data structures are momentarily locked, and a copy is made for the view to display. This ensures that the view produces a consistent set of results, while not blocking normal operations longer than necessary. Nonetheless there could be some impact on database performance if this view is frequently accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee8be71b9dbdb6fe9839b8abd30a5d0ca45b722" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;text&lt;/code&gt; format is used, the data read or written is a text file with one line per table row. Columns in a row are separated by the delimiter character. The column values themselves are strings generated by the output function, or acceptable to the input function, of each attribute's data type. The specified null string is used in place of columns that are null. &lt;code&gt;COPY FROM&lt;/code&gt; will raise an error if any line of the input file contains more or fewer columns than are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4c47cbbcff114da7b14a508ba7d65a0b19eac7" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; argument to verification functions is &lt;code&gt;true&lt;/code&gt;, an additional phase of verification is performed against the table associated with the target index relation. This consists of a &amp;ldquo;dummy&amp;rdquo;&lt;code&gt;CREATE INDEX&lt;/code&gt; operation, which checks for the presence of all hypothetical new index tuples against a temporary, in-memory summarizing structure (this is built when needed during the basic first phase of verification). The summarizing structure &amp;ldquo;fingerprints&amp;rdquo; every tuple found within the target index. The high level principle behind &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is that a new index that is equivalent to the existing, target index must only have entries that can be found in the existing structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4898e6eb712c6c928410a4432225d77730464bb" translate="yes" xml:space="preserve">
          <source>When the backup is in tar mode, and the directory is specified as &lt;code&gt;-&lt;/code&gt; (dash), the tar file will be written to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf62b247e8d0c8ddb36cb4a11374b1155c5b650" translate="yes" xml:space="preserve">
          <source>When the client application uses the &amp;ldquo;extended query&amp;rdquo; protocol to issue a &lt;code&gt;FETCH&lt;/code&gt; command, the Bind protocol message specifies whether data is to be retrieved in text or binary format. This choice overrides the way that the cursor is defined. The concept of a binary cursor as such is thus obsolete when using extended query protocol &amp;mdash; any cursor can be treated as either text or binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef2bc6393c8c4a9107edf2302ecf0f071877452" translate="yes" xml:space="preserve">
          <source>When the connection to the server is lost, do not retry in a loop, just exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8229aa8ad36a0b0c5e6146511e976844f24d945" translate="yes" xml:space="preserve">
          <source>When the database generates SQL, force all identifiers to be quoted, even if they are not (currently) keywords. This will affect the output of &lt;code&gt;EXPLAIN&lt;/code&gt; as well as the results of functions like &lt;code&gt;pg_get_viewdef&lt;/code&gt;. See also the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option of &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; and &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2bc8f44657321dd80c423b48806c42005dbc7a" translate="yes" xml:space="preserve">
          <source>When the database system has to perform an ordering or a character classification, it uses the collation of the input expression. This happens, for example, with &lt;code&gt;ORDER BY&lt;/code&gt; clauses and function or operator calls such as &lt;code&gt;&amp;lt;&lt;/code&gt;. The collation to apply for an &lt;code&gt;ORDER BY&lt;/code&gt; clause is simply the collation of the sort key. The collation to apply for a function or operator call is derived from the arguments, as described below. In addition to comparison operators, collations are taken into account by functions that convert between lower and upper case letters, such as &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, and &lt;code&gt;initcap&lt;/code&gt;; by pattern matching operators; and by &lt;code&gt;to_char&lt;/code&gt; and related functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf20c03f9a438d0f6675629396820f040d752814" translate="yes" xml:space="preserve">
          <source>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt;, &lt;code&gt;PGHOST&lt;/code&gt;, &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58644d348761a861122023ab84e086a5de61b1bd" translate="yes" xml:space="preserve">
          <source>When the input value is +/-Infinity, &lt;code&gt;extract&lt;/code&gt; returns +/-Infinity for monotonically-increasing fields (&lt;code&gt;epoch&lt;/code&gt;, &lt;code&gt;julian&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;isoyear&lt;/code&gt;, &lt;code&gt;decade&lt;/code&gt;, &lt;code&gt;century&lt;/code&gt;, and &lt;code&gt;millennium&lt;/code&gt;). For other fields, NULL is returned. PostgreSQL versions before 9.6 returned zero for all cases of infinite input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7b95a2bfd76e66a3b9a3c283932ae7ceb9d1f3" translate="yes" xml:space="preserve">
          <source>When the input value is of type &lt;code&gt;timestamp with time zone&lt;/code&gt;, the truncation is performed with respect to a particular time zone; for example, truncation to &lt;code&gt;day&lt;/code&gt; produces a value that is midnight in that zone. By default, truncation is done with respect to the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting, but the optional &lt;code&gt;time_zone&lt;/code&gt; argument can be provided to specify a different time zone. The time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb992423a64d9af4e9c24a6d03361c5985029c38" translate="yes" xml:space="preserve">
          <source>When the node at the top of the parallel portion of the plan is &lt;code&gt;Gather Merge&lt;/code&gt; rather than &lt;code&gt;Gather&lt;/code&gt;, it indicates that each process executing the parallel portion of the plan is producing tuples in sorted order, and that the leader is performing an order-preserving merge. In contrast, &lt;code&gt;Gather&lt;/code&gt; reads tuples from the workers in whatever order is convenient, destroying any sort order that may have existed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8d54f7450d49b82cd5a8da77194f4c25e5cdb1" translate="yes" xml:space="preserve">
          <source>When the operating system sends a write request to the storage hardware, there is little it can do to make sure the data has arrived at a truly non-volatile storage area. Rather, it is the administrator's responsibility to make certain that all storage components ensure integrity for both data and file-system metadata. Avoid disk controllers that have non-battery-backed write caches. At the drive level, disable write-back caching if the drive cannot guarantee the data will be written before shutdown. If you use SSDs, be aware that many of these do not honor cache flush commands by default. You can test for reliable I/O subsystem behavior using &lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt;&lt;code&gt;diskchecker.pl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d33bb04f73c12f42af37757660638f7bf07dd0c" translate="yes" xml:space="preserve">
          <source>When the optimizer determines that parallel query is the fastest execution strategy for a particular query, it will create a query plan which includes a &lt;em&gt;Gather&lt;/em&gt; or &lt;em&gt;Gather Merge&lt;/em&gt; node. Here is a simple example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b643d7a7954ad91561b8c24a008664f59d15dd" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. The parenthesized syntax was added in PostgreSQL 11; the unparenthesized syntax is deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abee5df8a890efa75529bd092cf02d64e5f74e41" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. Without parentheses, options must be specified in exactly the order shown above. The parenthesized syntax was added in PostgreSQL 9.0; the unparenthesized syntax is deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9dc738f4097cde58c9e8bf1cce2f13a3e0faff" translate="yes" xml:space="preserve">
          <source>When the query executor is running a statement using &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;, individual operations are timed as well as showing a summary. The overhead of your system can be checked by counting rows with the psql program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4efc71382094156bb1e14ebb8922c4bbfee26e8" translate="yes" xml:space="preserve">
          <source>When the query involves more than two relations, the final result must be built up by a tree of join steps, each with two inputs. The planner examines different possible join sequences to find the cheapest one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91c3e21cf6bd9480dad3eeeece86758f55a90e3" translate="yes" xml:space="preserve">
          <source>When the query involves outer joins, the planner has less freedom than it does for plain (inner) joins. For example, consider:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d57a11c26095ca3bee53a6ad82668d9cd1b948" translate="yes" xml:space="preserve">
          <source>When the replication client of pg_receivewal is configured on the server as a synchronous standby, then using a replication slot will report the flush position to the server, but only when a WAL file is closed. Therefore, that configuration will cause transactions on the primary to wait for a long time and effectively not work satisfactorily. The option &lt;code&gt;--synchronous&lt;/code&gt; (see below) must be specified in addition to make this work correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e97e877617ee50758f9c1ed0038c82401b37ff4" translate="yes" xml:space="preserve">
          <source>When the server finds an entry in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog for the given language name, it will use the catalog data even if the command includes language parameters. This behavior simplifies loading of old dump files, which are likely to contain out-of-date information about language support functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5acf91c2009ea693cf720914c5dcc7ec25263a3f" translate="yes" xml:space="preserve">
          <source>When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a walreceiver process in the standby, and a corresponding walsender process in the primary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eedf68c3267fbf09aabeff8e3149a2fc6e02e4a5" translate="yes" xml:space="preserve">
          <source>When the system is forced to combine multiple page-level predicate locks into a single relation-level predicate lock because the predicate lock table is short of memory, an increase in the rate of serialization failures may occur. You can avoid this by increasing &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt;, &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt;, and/or &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5d69b735badff5a43514c3f20c29f9fa27a5a4" translate="yes" xml:space="preserve">
          <source>When the target server is started for the first time after running pg_rewind, it will go into recovery mode and replay all WAL generated in the source server after the point of divergence. If some of the WAL was no longer available in the source server when pg_rewind was run, and therefore could not be copied by the pg_rewind session, it must be made available when the target server is started. This can be done by creating a &lt;code&gt;recovery.signal&lt;/code&gt; file in the target data directory and configuring suitable &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d8ca3256e28b3a76b80a636c768a65a62af8f1" translate="yes" xml:space="preserve">
          <source>When the token is a number or number field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13de437cb552624377cc1efe8012608874203a3b" translate="yes" xml:space="preserve">
          <source>When there are &lt;code&gt;OUT&lt;/code&gt; or &lt;code&gt;INOUT&lt;/code&gt; parameters, the &lt;code&gt;RETURNS&lt;/code&gt; clause can be omitted. If present, it must agree with the result type implied by the output parameters: &lt;code&gt;RECORD&lt;/code&gt; if there are multiple output parameters, or the same type as the single output parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086da7e4c8252cf99eea2a26d212bfca20a89638" translate="yes" xml:space="preserve">
          <source>When there are no &lt;code&gt;GIN_MAYBE&lt;/code&gt; values in the &lt;code&gt;check&lt;/code&gt; vector, a &lt;code&gt;GIN_MAYBE&lt;/code&gt; return value is the equivalent of setting the &lt;code&gt;recheck&lt;/code&gt; flag in the Boolean &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d0ae32f2046467b15848b335dcbaffbcaf195f8" translate="yes" xml:space="preserve">
          <source>When this command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01a63b618f24f934c421a450096ebe3b2d3fb7a" translate="yes" xml:space="preserve">
          <source>When this feature is enabled, freed space at the end of a relation cannot be released to the operating system, since that could remove information needed to detect the &amp;ldquo;snapshot too old&amp;rdquo; condition. All space allocated to a relation remains associated with that relation for reuse only within that relation unless explicitly freed (for example, with &lt;code&gt;VACUUM FULL&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edeb5910da7722ed71fd344bba96eef32a3f6641" translate="yes" xml:space="preserve">
          <source>When this happens, the range will be summarized normally during the next regular vacuum of the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4570af0f67cc29537d90c659afba5db93e8b7f0" translate="yes" xml:space="preserve">
          <source>When this is enabled, the backup will start by enumerating the size of the entire database, and then go back and send the actual contents. This may make the backup take slightly longer, and in particular it will take longer before the first data is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c1776ab93887297f059584c258d507675ecdfe" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469c5b3c25ebc28298d0a68f767fa4e6b9232f83" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3757e4ca86742c07911d6404be9ee33ce2c815" translate="yes" xml:space="preserve">
          <source>When this option is used, psql will connect to the database &lt;code&gt;postgres&lt;/code&gt;, unless a different database is named on the command line (option &lt;code&gt;-d&lt;/code&gt; or non-option argument, possibly via a service entry, but not via an environment variable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc222201723d0a9f83d166df5e42c7cf99836b6" translate="yes" xml:space="preserve">
          <source>When this option is used, the database named with &lt;code&gt;-d&lt;/code&gt; is used only to issue the initial &lt;code&gt;DROP DATABASE&lt;/code&gt; and &lt;code&gt;CREATE DATABASE&lt;/code&gt; commands. All data is restored into the database name that appears in the archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3390cee1b88ac1d254da2a22a816a53421d2e870" translate="yes" xml:space="preserve">
          <source>When this parameter allows it for a particular table, the planner compares query conditions with the table's &lt;code&gt;CHECK&lt;/code&gt; constraints, and omits scanning tables for which the conditions contradict the constraints. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70be33b4f92d88452bcc535d531cf8223b72afbc" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server compresses a full page image written to WAL when &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is on or during a base backup. A compressed page image will be decompressed during WAL replay. The default value is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095a2e6ccc43e3049250993f0343788b4a6a861a" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint, even for non-critical modifications of so-called hint bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff47b09b0654ad59cedec7d15e17e9fba55f3e2b" translate="yes" xml:space="preserve">
          <source>When this parameter is on, &lt;code&gt;sepgsql&lt;/code&gt; functions in permissive mode, even if SELinux in general is working in enforcing mode. This parameter is primarily useful for testing purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b664e492ac1b6b5bd7bf06b57282c7f341a60102" translate="yes" xml:space="preserve">
          <source>When this parameter is on, per-plan-node timing occurs for all statements executed, whether or not they run long enough to actually get logged. This can have an extremely negative impact on performance. Turning off &lt;code&gt;auto_explain.log_timing&lt;/code&gt; ameliorates the performance cost, at the price of obtaining less information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e134d46721d701b088fe76d2d53da371f96514" translate="yes" xml:space="preserve">
          <source>When this parameter is on, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint. This is needed because a page write that is in process during an operating system crash might be only partially completed, leading to an on-disk page that contains a mix of old and new data. The row-level change data normally stored in WAL will not be enough to completely restore such a page during post-crash recovery. Storing the full page image guarantees that the page can be correctly restored, but at the price of increasing the amount of data that must be written to WAL. (Because WAL replay always starts from a checkpoint, it is sufficient to do this during the first change of each page after a checkpoint. Therefore, one way to reduce the cost of full-page writes is to increase the checkpoint interval parameters.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1902b314fccc53fa419bb9d1c5d0a54674b4cd" translate="yes" xml:space="preserve">
          <source>When this variable is set to &lt;code&gt;on&lt;/code&gt; and a backslash command queries the database, the query is first shown. This feature helps you to study PostgreSQL internals and provide similar functionality in your own programs. (To select this behavior on program start-up, use the switch &lt;code&gt;-E&lt;/code&gt;.) If you set this variable to the value &lt;code&gt;noexec&lt;/code&gt;, the queries are just shown but are not actually sent to the server and executed. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a31ece5bfbb183043ca04edf566185c4d24f24d" translate="yes" xml:space="preserve">
          <source>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e. the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a5ce62fea33e48d7ca4dcdb6fc1d49b58833f9" translate="yes" xml:space="preserve">
          <source>When throttling is used (&lt;code&gt;--rate=...&lt;/code&gt;), transactions that lag behind schedule by more than &lt;code&gt;limit&lt;/code&gt; ms, and thus have no hope of meeting the latency limit, are not sent to the server at all. They are counted and reported separately as &lt;em&gt;skipped&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0431d629c5fa2195a09522dc9eddb52b7d7ef5d" translate="yes" xml:space="preserve">
          <source>When to JIT?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c212a8c30b6a166bd84fdfc048fb956853e7ba65" translate="yes" xml:space="preserve">
          <source>When two arrays with an equal number of dimensions are concatenated, the result retains the lower bound subscript of the left-hand operand's outer dimension. The result is an array comprising every element of the left-hand operand followed by every element of the right-hand operand. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09c4eb9b4b598594720766db600d02893739065" translate="yes" xml:space="preserve">
          <source>When used as a standalone program all WAL files logically preceding the &lt;code&gt;oldestkeptwalfile&lt;/code&gt; will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. In this mode, if you specify a &lt;code&gt;.partial&lt;/code&gt; or &lt;code&gt;.backup&lt;/code&gt; file name, then only the file prefix will be used as the &lt;code&gt;oldestkeptwalfile&lt;/code&gt;. This treatment of &lt;code&gt;.backup&lt;/code&gt; file name allows you to remove all WAL files archived prior to a specific base backup without error. For example, the following example will remove all files older than WAL file name &lt;code&gt;000000010000003700000010&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f92bbabc1b26d77780494bcd623901f19d77be" translate="yes" xml:space="preserve">
          <source>When used with one of the archive file formats and combined with pg_restore, pg_dump provides a flexible archival and transfer mechanism. pg_dump can be used to backup an entire database, then pg_restore can be used to examine the archive and/or select which parts of the database are to be restored. The most flexible output file formats are the &amp;ldquo;custom&amp;rdquo; format (&lt;code&gt;-Fc&lt;/code&gt;) and the &amp;ldquo;directory&amp;rdquo; format (&lt;code&gt;-Fd&lt;/code&gt;). They allow for selection and reordering of all archived items, support parallel restoration, and are compressed by default. The &amp;ldquo;directory&amp;rdquo; format is the only format that supports parallel dumps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe14a6b317961785cf4d152bc27d49064bcda5a" translate="yes" xml:space="preserve">
          <source>When used within &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;, all WAL files logically preceding the value of the &lt;code&gt;%r&lt;/code&gt; argument will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. This minimizes the number of files that need to be retained, while preserving crash-restart capability. Use of this parameter is appropriate if the &lt;code&gt;archivelocation&lt;/code&gt; is a transient staging area for this particular standby server, but &lt;em&gt;not&lt;/em&gt; when the &lt;code&gt;archivelocation&lt;/code&gt; is intended as a long-term WAL archive area, or when multiple standby servers are recovering from the same archive location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7051b09dcb61945ea4e0d3beb1e52e65c9014732" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;COPY FROM&lt;/code&gt;, any data item that matches this string will be stored as a null value, so you should make sure that you use the same string as you used with &lt;code&gt;COPY TO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b5d7a27b46e73dc32c1b851c7dfef0ad7fe8a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is a good idea to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows &amp;mdash; you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481c23a58e8db851baee87afbfd06f8aa525bda9" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is important to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85dc3be9cb7f009d076c5eedd8386addcb8b584" translate="yes" xml:space="preserve">
          <source>When using Kerberos authentication, SSPI works the same way GSSAPI does; see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc80b0e9ed4294e8911057b0a0a50261a196de62" translate="yes" xml:space="preserve">
          <source>When using POSIX semaphores, the number of semaphores needed is the same as for System V, that is one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;). On the platforms where this option is preferred, there is no specific kernel limit on the number of POSIX semaphores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d87a93d2de1be22dab32dcbbc5446297da3c6d5" translate="yes" xml:space="preserve">
          <source>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt;, and include parameters for &lt;code&gt;user name&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt;. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this server with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt;. There is no support for RADIUS accounting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1ce6f4ba5a71b98d3f24da1f9c50898361216d" translate="yes" xml:space="preserve">
          <source>When using System V semaphores, PostgreSQL uses one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;), in sets of 16. Each such set will also contain a 17th semaphore which contains a &amp;ldquo;magic number&amp;rdquo;, to detect collision with semaphore sets used by other applications. The maximum number of semaphores in the system is set by &lt;code&gt;SEMMNS&lt;/code&gt;, which consequently must be at least as high as &lt;code&gt;max_connections&lt;/code&gt; plus &lt;code&gt;autovacuum_max_workers&lt;/code&gt; plus &lt;code&gt;max_wal_senders&lt;/code&gt;, plus &lt;code&gt;max_worker_processes&lt;/code&gt;, plus one extra for each 16 allowed connections plus workers (see the formula in &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;Table 18.1&lt;/a&gt;). The parameter &lt;code&gt;SEMMNI&lt;/code&gt; determines the limit on the number of semaphore sets that can exist on the system at one time. Hence this parameter must be at least &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt;. Lowering the number of allowed connections is a temporary workaround for failures, which are usually confusingly worded &amp;ldquo;No space left on device&amp;rdquo;, from the function &lt;code&gt;semget&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8382eef968bcd1841af0a45f03df20722ebed18" translate="yes" xml:space="preserve">
          <source>When using a replication setup with tools which perform direct copies of relation file blocks (for example &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt;), enabling or disabling checksums can lead to page corruptions in the shape of incorrect checksums if the operation is not done consistently across all nodes. When enabling or disabling checksums in a replication setup, it is thus recommended to stop all the clusters before switching them all consistently. Destroying all standbys, performing the operation on the primary and finally recreating the standbys from scratch is also safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac93956f94fd1f4ae45bb87df2631e194bcbe28" translate="yes" xml:space="preserve">
          <source>When using a separate column to store the &lt;code&gt;tsvector&lt;/code&gt; representation of your documents, it is necessary to create a trigger to update the &lt;code&gt;tsvector&lt;/code&gt; column when the document content columns change. Two built-in trigger functions are available for this, or you can write your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9150f1a85447666f80a11e9912230df80685449c" translate="yes" xml:space="preserve">
          <source>When using an &lt;code&gt;archive_command&lt;/code&gt; script, it's desirable to enable &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt;. Any messages written to stderr from the script will then appear in the database server log, allowing complex configurations to be diagnosed easily if they fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953b500ebbfdd4983d6d154f36b232db63c79506" translate="yes" xml:space="preserve">
          <source>When using an external authentication system such as Ident or GSSAPI, the name of the operating system user that initiated the connection might not be the same as the database user (role) that is to be used. In this case, a user name map can be applied to map the operating system user name to a database user. To use user name mapping, specify &lt;code&gt;map&lt;/code&gt;=&lt;code&gt;map-name&lt;/code&gt; in the options field in &lt;code&gt;pg_hba.conf&lt;/code&gt;. This option is supported for all authentication methods that receive external user names. Since different mappings might be needed for different connections, the name of the map to be used is specified in the &lt;code&gt;map-name&lt;/code&gt; parameter in &lt;code&gt;pg_hba.conf&lt;/code&gt; to indicate which map to use for each individual connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492838d017254285805f7e847c1bb4763dffb265" translate="yes" xml:space="preserve">
          <source>When using binary mode to pass query parameters to the server and query results back to the client, no encoding conversion is performed, so the situation is different. In this case, an encoding declaration in the XML data will be observed, and if it is absent, the data will be assumed to be in UTF-8 (as required by the XML standard; note that PostgreSQL does not support UTF-16). On output, data will have an encoding declaration specifying the client encoding, unless the client encoding is UTF-8, in which case it will be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56607247aff04e4e074b7797ef04095046172c94" translate="yes" xml:space="preserve">
          <source>When using collations provided by the ICU library, the ICU-specific version of the collator is recorded in the system catalog when the collation object is created. When the collation is used, the current version is checked against the recorded version, and a warning is issued when there is a mismatch, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5896493e8d94d607ede6725d8b75b29f2f0f82" translate="yes" xml:space="preserve">
          <source>When using cost-based vacuuming, appropriate values for &lt;code&gt;vacuum_cost_delay&lt;/code&gt; are usually quite small, perhaps less than 1 millisecond. While &lt;code&gt;vacuum_cost_delay&lt;/code&gt; can be set to fractional-millisecond values, such delays may not be measured accurately on older platforms. On such platforms, increasing &lt;code&gt;VACUUM&lt;/code&gt;'s throttled resource consumption above what you get at 1ms will require changing the other vacuum cost parameters. You should, nonetheless, keep &lt;code&gt;vacuum_cost_delay&lt;/code&gt; as small as your platform will consistently measure; large delays are not helpful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75aee5f97d42018467b21311d706aa5a647707a9" translate="yes" xml:space="preserve">
          <source>When using exclusive backup mode, it is absolutely imperative to ensure that &lt;code&gt;pg_stop_backup&lt;/code&gt; completes successfully at the end of the backup. Even if the backup itself fails, for example due to lack of disk space, failure to call &lt;code&gt;pg_stop_backup&lt;/code&gt; will leave the server in backup mode indefinitely, causing future backups to fail and increasing the risk of a restart failure during the time that &lt;code&gt;backup_label&lt;/code&gt; exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec73be80732f41a040847bc00566e73f63c25a96" translate="yes" xml:space="preserve">
          <source>When using link mode, standby servers can be quickly upgraded using rsync. To accomplish this, from a directory on the primary server that is above the old and new database cluster directories, run this on the &lt;em&gt;primary&lt;/em&gt; for each standby server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1e98ef020032cfb9faf29c2d74acac7b1c192c" translate="yes" xml:space="preserve">
          <source>When using multiple &lt;code&gt;INSERT&lt;/code&gt;s, turn off autocommit and just do one commit at the end. (In plain SQL, this means issuing &lt;code&gt;BEGIN&lt;/code&gt; at the start and &lt;code&gt;COMMIT&lt;/code&gt; at the end. Some client libraries might do this behind your back, in which case you need to make sure the library does it when you want it done.) If you allow each insertion to be committed separately, PostgreSQL is doing a lot of work for each row that is added. An additional benefit of doing all insertions in one transaction is that if the insertion of one row were to fail then the insertion of all rows inserted up to that point would be rolled back, so you won't be stuck with partially loaded data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8692847b55239c8542d72c31d947ca1f69e8f98c" translate="yes" xml:space="preserve">
          <source>When using pg_receivewal instead of &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; as the main WAL backup method, it is strongly recommended to use replication slots. Otherwise, the server is free to recycle or remove write-ahead log files before they are backed up, because it does not have any information, either from &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; or the replication slots, about how far the WAL stream has been archived. Note, however, that a replication slot will fill up the server's disk space if the receiver does not keep up with fetching the WAL data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7805e078bb69ca14f943ca44e9ff4b57cc0c775e" translate="yes" xml:space="preserve">
          <source>When using search+bind mode, the search can be performed using a single attribute specified with &lt;code&gt;ldapsearchattribute&lt;/code&gt;, or using a custom search filter specified with &lt;code&gt;ldapsearchfilter&lt;/code&gt;. Specifying &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; is equivalent to specifying &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt;. If neither option is specified the default is &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf2c531c08aa10ba699a8b190067e047b3e70bf" translate="yes" xml:space="preserve">
          <source>When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this timeframe. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcdbf5154b4eb280778c5288af6f89414cb4462" translate="yes" xml:space="preserve">
          <source>When using systemd, you can use the following service unit file (e.g., at &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4f4b5954d77c90199a922670870bbe00993316" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd246a1d45857b9944b119a71ad8342fdd069e69" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. A column definition list can be placed after the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; construct only if there's just a single function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b68f1005505d22ba3f1b802a0a0796977dd397" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;extensions&lt;/code&gt; option, &lt;em&gt;it is the user's responsibility&lt;/em&gt; that the listed extensions exist and behave identically on both the local and remote servers. Otherwise, remote queries may fail or behave unexpectedly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e797775100fdafb459cefc34e37395f8e226c9b6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;libc&lt;/code&gt; collation provider, the locale must be applicable to the current database encoding. See &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; for the precise rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33347a458dabb91eee87e22ef8743db48a2953ba" translate="yes" xml:space="preserve">
          <source>When using the statistics to monitor collected data, it is important to realize that the information does not update instantaneously. Each individual server process transmits new statistical counts to the collector just before going idle; so a query or transaction still in progress does not affect the displayed totals. Also, the collector itself emits a new report at most once per &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; milliseconds (500 ms unless altered while building the server). So the displayed information lags behind actual activity. However, current-query information collected by &lt;code&gt;track_activities&lt;/code&gt; is always up-to-date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="869040936f3cd63714aedfeb674cbbcb51ecde9f" translate="yes" xml:space="preserve">
          <source>When using this option together with &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;, the text of statements that are logged because of &lt;code&gt;log_statement&lt;/code&gt; will not be repeated in the duration log message. If you are not using syslog, it is recommended that you log the PID or session ID using &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; so that you can link the statement message to the later duration message using the process ID or session ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56584dae166e0f5d41c03bae8959fb67da882b7" translate="yes" xml:space="preserve">
          <source>When using this technique, it will avoid creating an unnecessary burden for application programmers if the application software goes through a framework which automatically retries transactions which are rolled back with a serialization failure. It may be a good idea to set &lt;code&gt;default_transaction_isolation&lt;/code&gt; to &lt;code&gt;serializable&lt;/code&gt;. It would also be wise to take some action to ensure that no other transaction isolation level is used, either inadvertently or to subvert integrity checks, through checks of the transaction isolation level in triggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e33ed6ffb66e09afb90b2aa31b40f235c917227" translate="yes" xml:space="preserve">
          <source>When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda53778d06f68bfde32b3023f6347b2be67790d" translate="yes" xml:space="preserve">
          <source>When waiting, &lt;code&gt;pg_ctl&lt;/code&gt; repeatedly checks the server's PID file, sleeping for a short amount of time between checks. Startup is considered complete when the PID file indicates that the server is ready to accept connections. Shutdown is considered complete when the server removes the PID file. &lt;code&gt;pg_ctl&lt;/code&gt; returns an exit code based on the success of the startup or shutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="319a6ac32ba7d37c93ad8b3aed41a7b25d9cd283" translate="yes" xml:space="preserve">
          <source>When we speak of inheriting the locale from the execution environment, this means the following on most operating systems: For a given locale category, say the collation, the following environment variables are consulted in this order until one is found to be set: &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_COLLATE&lt;/code&gt; (or the variable corresponding to the respective category), &lt;code&gt;LANG&lt;/code&gt;. If none of these environment variables are set then the locale defaults to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09870d0ba2815a6a474afa8adde88701322779a5" translate="yes" xml:space="preserve">
          <source>When we write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f55fad869d686971a61de9989dadab77ae5eb95" translate="yes" xml:space="preserve">
          <source>When working with an inner tuple having unlabeled nodes, it is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since the set of nodes is supposed to be fixed in such cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513c84ce8934fc59619703510a7a572aaca0c319" translate="yes" xml:space="preserve">
          <source>When working with multiple tables, it can also be useful to ask for all the columns of a particular table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f387116d6a98de65f13445ebf4c25f94df15576" translate="yes" xml:space="preserve">
          <source>When working with non-SQL-standard operator names, you will usually need to separate adjacent operators with spaces to avoid ambiguity. For example, if you have defined a left unary operator named &lt;code&gt;@&lt;/code&gt;, you cannot write &lt;code&gt;X*@Y&lt;/code&gt;; you must write &lt;code&gt;X* @Y&lt;/code&gt; to ensure that PostgreSQL reads it as two operator names not one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3a2849e7e7665d1ef0586b393970fa38e06c50" translate="yes" xml:space="preserve">
          <source>When working with recursive queries it is important to be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. Sometimes, using &lt;code&gt;UNION&lt;/code&gt; instead of &lt;code&gt;UNION ALL&lt;/code&gt; can accomplish this by discarding rows that duplicate previous output rows. However, often a cycle does not involve output rows that are completely duplicate: it may be necessary to check just one or a few fields to see if the same point has been reached before. The standard method for handling such situations is to compute an array of the already-visited values. For example, consider the following query that searches a table &lt;code&gt;graph&lt;/code&gt; using a &lt;code&gt;link&lt;/code&gt; field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5718cfeb2fe2d91286009aaf2e77c006f835bbe" translate="yes" xml:space="preserve">
          <source>When writing an interval constant with a &lt;code&gt;fields&lt;/code&gt; specification, or when assigning a string to an interval column that was defined with a &lt;code&gt;fields&lt;/code&gt; specification, the interpretation of unmarked quantities depends on the &lt;code&gt;fields&lt;/code&gt;. For example &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; is read as 1 year, whereas &lt;code&gt;INTERVAL '1'&lt;/code&gt; means 1 second. Also, field values &amp;ldquo;to the right&amp;rdquo; of the least significant field allowed by the &lt;code&gt;fields&lt;/code&gt; specification are silently discarded. For example, writing &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; results in dropping the seconds field, but not the day field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988ef8be5d9c8af4c97d0fc59910f990922134e4" translate="yes" xml:space="preserve">
          <source>When you create a table and you realize that you made a mistake, or the requirements of the application change, you can drop the table and create it again. But this is not a convenient option if the table is already filled with data, or if the table is referenced by other database objects (for instance a foreign key constraint). Therefore PostgreSQL provides a family of commands to make modifications to existing tables. Note that this is conceptually distinct from altering the data contained in the table: here we are interested in altering the definition, or structure, of the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a09c13346cb20d8d1dd7186def1b2a2f01cbc1" translate="yes" xml:space="preserve">
          <source>When you create complex database structures involving many tables with foreign key constraints, views, triggers, functions, etc. you implicitly create a net of dependencies between the objects. For instance, a table with a foreign key constraint depends on the table it references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a5344aa581794cb8d710e210bdb65e511f2134" translate="yes" xml:space="preserve">
          <source>When you create many interrelated tables it is wise to choose a consistent naming pattern for the tables and columns. For instance, there is a choice of using singular or plural nouns for table names, both of which are favored by some theorist or other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593e96c33f6f0aab676c4ca184c4ca854f13bc97" translate="yes" xml:space="preserve">
          <source>When you insert invalid numbers in a table using the weak mode, the number will be inserted with the corrected check digit, but it will be displayed with an exclamation mark (&lt;code&gt;!&lt;/code&gt;) at the end, for example &lt;code&gt;0-11-000322-5!&lt;/code&gt;. This invalid marker can be checked with the &lt;code&gt;is_valid&lt;/code&gt; function and cleared with the &lt;code&gt;make_valid&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf59c49779a368d436367de404fed33cad74dcd" translate="yes" xml:space="preserve">
          <source>When you query JSON data, the path expression may not match the actual JSON data structure. An attempt to access a non-existent member of an object or element of an array results in a structural error. SQL/JSON path expressions have two modes of handling structural errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3780caf73c39bd4ac2d31b375fc0dd6e1923bd0" translate="yes" xml:space="preserve">
          <source>When you write the argument of a sequence function as an unadorned literal string, it becomes a constant of type &lt;code&gt;regclass&lt;/code&gt;. Since this is really just an OID, it will track the originally identified sequence despite later renaming, schema reassignment, etc. This &amp;ldquo;early binding&amp;rdquo; behavior is usually desirable for sequence references in column defaults and views. But sometimes you might want &amp;ldquo;late binding&amp;rdquo; where the sequence reference is resolved at run time. To get late-binding behavior, force the constant to be stored as a &lt;code&gt;text&lt;/code&gt; constant instead of &lt;code&gt;regclass&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2507ec70331a5deab93cd40d826b1bdba44ecbc3" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; view will contain a row for each backend that is currently running either command. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b73a7d0ff3b39db66ff19d5f58e0f20613bb45" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; view will contain one row for each backend that is currently creating indexes. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da2e4c266065ef5b47dc244d1142646be363723" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d664025546cdeafdfe0701b9fa38130d919c75" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; scans any part of a table, it will replace any multixact ID it encounters which is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; by a different value, which can be the zero value, a single transaction ID, or a newer multixact ID. For each table, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; stores the oldest possible multixact ID still appearing in any tuple of that table. If this value is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;, an aggressive vacuum is forced. As discussed in the previous section, an aggressive vacuum means that only those pages which are known to be all-frozen will be skipped. &lt;code&gt;mxid_age()&lt;/code&gt; can be used on &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; to find its age.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f844cc225201cbe85cbdde3d905d07e347e61a8" translate="yes" xml:space="preserve">
          <source>Whenever PostgreSQL needs to combine rows from multiple sources into a single result set, it uses an &lt;code&gt;Append&lt;/code&gt; or &lt;code&gt;MergeAppend&lt;/code&gt; plan node. This commonly happens when implementing &lt;code&gt;UNION ALL&lt;/code&gt; or when scanning a partitioned table. Such nodes can be used in parallel plans just as they can in any other plan. However, in a parallel plan, the planner may instead use a &lt;code&gt;Parallel Append&lt;/code&gt; node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e82d59ea38cfaea7777dbbbcc2b327247984a8" translate="yes" xml:space="preserve">
          <source>Whenever a command is executed, psql also polls for asynchronous notification events generated by &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; and &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe283c15f98e1d6878cfeeadd5bbfd6c5078c552" translate="yes" xml:space="preserve">
          <source>Whenever a user-defined type is created, PostgreSQL automatically creates an associated array type, whose name consists of the element type's name prepended with an underscore, and truncated if necessary to keep it less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long. (If the name so generated collides with an existing type name, the process is repeated until a non-colliding name is found.) This implicitly-created array type is variable length and uses the built-in input and output functions &lt;code&gt;array_in&lt;/code&gt; and &lt;code&gt;array_out&lt;/code&gt;. The array type tracks any changes in its element type's owner or schema, and is dropped if the element type is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c317e2f18ac74c5065186374d831c55658598512" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by a single backend, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;0&lt;/code&gt;, i.e., no forced writeback. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the maximum value scales proportionally to it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de89b6016c756123d6b9441e22d55848a32a9ab3" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;512kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41035af23763d236bc43d7713084261d3a812120" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written while performing a checkpoint, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of the checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;256kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafdfe0e40c272ef5695922c2a975f51df9e1cea" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;code&gt;pattern&lt;/code&gt; parameter is omitted completely, the &lt;code&gt;\d&lt;/code&gt; commands display all objects that are visible in the current schema search path &amp;mdash; this is equivalent to using &lt;code&gt;*&lt;/code&gt; as the pattern. (An object is said to be &lt;em&gt;visible&lt;/em&gt; if its containing schema is in the search path and no object of the same kind and name appears earlier in the search path. This is equivalent to the statement that the object can be referenced by name without explicit schema qualification.) To see all objects in the database regardless of visibility, use &lt;code&gt;*.*&lt;/code&gt; as the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dffd7d6d50f37b1f139649fc2afe46f33411c06" translate="yes" xml:space="preserve">
          <source>Whenever the command &lt;code&gt;NOTIFY channel&lt;/code&gt; is invoked, either by this session or another one connected to the same database, all the sessions currently listening on that notification channel are notified, and each will in turn notify its connected client application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464c9a84b9274c416e8217076cf62d6ce77919b2" translate="yes" xml:space="preserve">
          <source>Whenever the role subsequently starts a new session, the specified value becomes the session default, overriding whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. This only happens at login time; executing &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; or &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; does not cause new configuration values to be set. Settings set for all databases are overridden by database-specific settings attached to a role. Settings for specific databases or specific roles override settings for all roles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb07a399aec26555c15e193c16effe1e79f48af" translate="yes" xml:space="preserve">
          <source>Whenever you create a table, a composite type is also automatically created, with the same name as the table, to represent the table's row type. For example, had we said:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72417af150626f41547b564cc2af3102889d282f" translate="yes" xml:space="preserve">
          <source>Whenever you have significantly altered the distribution of data within a table, running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; is strongly recommended. This includes bulk loading large amounts of data into the table. Running &lt;code&gt;ANALYZE&lt;/code&gt; (or &lt;code&gt;VACUUM ANALYZE&lt;/code&gt;) ensures that the planner has up-to-date statistics about the table. With no statistics or obsolete statistics, the planner might make poor decisions during query planning, leading to poor performance on any tables with inaccurate or nonexistent statistics. Note that if the autovacuum daemon is enabled, it might run &lt;code&gt;ANALYZE&lt;/code&gt; automatically; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70267c330cb08a0ff5a2a298e316262a59a144c4" translate="yes" xml:space="preserve">
          <source>Where interoperability with other systems is a concern, for some data types, it may be necessary to use data type formatting functions (such as those in &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) explicitly to produce the standard mappings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de87765a2f74958f3598da9f1ae5cd4df124304a" translate="yes" xml:space="preserve">
          <source>Where the command omits database name, user, host, or port, the new connection can reuse values from the previous connection. By default, values from the previous connection are reused except when processing a &lt;code&gt;conninfo&lt;/code&gt; string. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. When the command neither specifies nor reuses a particular parameter, the libpq default is used. Specifying any of &lt;code&gt;dbname&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; as &lt;code&gt;-&lt;/code&gt; is equivalent to omitting that parameter. If &lt;code&gt;hostaddr&lt;/code&gt; was specified in the original connection's &lt;code&gt;conninfo&lt;/code&gt;, that address is reused for the new connection (disregarding any other host specification).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b1968453a400f5fd07425f7b52ed24d9c6b52b" translate="yes" xml:space="preserve">
          <source>Where the current standard provides a family of XML data types to hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo; in untyped or XML Schema-typed variants, and a type &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; to hold arbitrary pieces of XML content, PostgreSQL provides the single &lt;code&gt;xml&lt;/code&gt; type, which can hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo;. There is no equivalent of the standard's &amp;ldquo;sequence&amp;rdquo; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be0ce89e49423198dedc7c03fd710b9a77c7468" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;pgstattuple&lt;/code&gt; always performs a full-table scan and returns an exact count of live and dead tuples (and their sizes) and free space, &lt;code&gt;pgstattuple_approx&lt;/code&gt; tries to avoid the full-table scan and returns exact dead tuple statistics along with an approximation of the number and size of live tuples and free space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec341d8bc6b0b4825eb80f0ff91c4f3ae8eee3b" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;aggfinalfn&lt;/code&gt; modifies the transition state value: &lt;code&gt;r&lt;/code&gt; if it is read-only, &lt;code&gt;s&lt;/code&gt; if the &lt;code&gt;aggtransfn&lt;/code&gt; cannot be applied after the &lt;code&gt;aggfinalfn&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; if it writes on the value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63ddfd6a1548ba35d00a888f441158a5e09419b" translate="yes" xml:space="preserve">
          <source>Whether an RE is greedy or not is determined by the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a052d21cc109877e0a34f6fceb8177147b8e054e" translate="yes" xml:space="preserve">
          <source>Whether the sequence cycles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099ca603e257bb42c8d0080a36e8a200732df4c1" translate="yes" xml:space="preserve">
          <source>Whether to convert &lt;code&gt;\n&lt;/code&gt; into &lt;code&gt;\r\n&lt;/code&gt; when encrypting and &lt;code&gt;\r\n&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt; when decrypting. RFC 4880 specifies that text data should be stored using &lt;code&gt;\r\n&lt;/code&gt; line-feeds. Use this to get fully RFC-compliant behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a913bec72a9d1cd9190d3ca3274a90d4c381b09" translate="yes" xml:space="preserve">
          <source>Whether to convert textual data from database internal encoding to UTF-8 and back. If your database already is UTF-8, no conversion will be done, but the message will be tagged as UTF-8. Without this option it will not be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0908bbd26e431175b3928caa067e2b55410af7" translate="yes" xml:space="preserve">
          <source>Which S2K algorithm to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b435ac17c99f4ed78933b5d05d5b47d3dfdd820" translate="yes" xml:space="preserve">
          <source>Which cipher algorithm to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4215d6c5a786cf08cc1b93732554ac25c2ba7716" translate="yes" xml:space="preserve">
          <source>Which cipher to use for encrypting separate session key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c9643312802b96a36d211d4bd8a2d4fbec5df7d" translate="yes" xml:space="preserve">
          <source>Which compression algorithm to use. Only available if PostgreSQL was built with zlib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36178694d36e0d8b9b4d6953d14f4cb84f698946" translate="yes" xml:space="preserve">
          <source>Which digest algorithm to use in S2K calculation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9d8c9d7eb5636216a755086b48fa5a8cd067ff" translate="yes" xml:space="preserve">
          <source>Which one of these you use is mainly a matter of style. The &lt;code&gt;JOIN&lt;/code&gt; syntax in the &lt;code&gt;FROM&lt;/code&gt; clause is probably not as portable to other SQL database management systems, even though it is in the SQL standard. For outer joins there is no choice: they must be done in the &lt;code&gt;FROM&lt;/code&gt; clause. The &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;USING&lt;/code&gt; clause of an outer join is &lt;em&gt;not&lt;/em&gt; equivalent to a &lt;code&gt;WHERE&lt;/code&gt; condition, because it results in the addition of rows (for unmatched input rows) as well as the removal of rows in the final result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f207dff92fd241726ec3f780d5ff085d75648337" translate="yes" xml:space="preserve">
          <source>Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8189028b5d12d59cd50147d702e5a513253a68c3" translate="yes" xml:space="preserve">
          <source>Which row(s) to update</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a5e55dc1620d200691892efc7a7c676cbd8264" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;CREATE INDEX&lt;/code&gt; with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option supports parallel builds without special restrictions, only the first table scan is actually performed in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714b73638a1ef948dee8dfe7820683df70955357" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;UNIQUE&lt;/code&gt; is a natural constraint for scalar values, it is usually unsuitable for range types. Instead, an exclusion constraint is often more appropriate (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE&lt;/a&gt;). Exclusion constraints allow the specification of constraints such as &amp;ldquo;non-overlapping&amp;rdquo; on a range type. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9577e86cf0dfccc12f0ecf60188a3b6040e454" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;pg_resetwal&lt;/code&gt; will set the WAL starting address beyond the latest existing WAL segment file, some segment size changes can cause previous WAL file names to be reused. It is recommended to use &lt;code&gt;-l&lt;/code&gt; together with this option to manually set the WAL starting address if WAL file name overlap will cause problems with your archiving strategy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01708a73847573f321d3d2da0f455cb9f949df75" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;to_date&lt;/code&gt; will reject a mixture of Gregorian and ISO week-numbering date fields, &lt;code&gt;to_char&lt;/code&gt; will not, since output format specifications like &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; can be useful. But avoid writing something like &lt;code&gt;IYYY-MM-DD&lt;/code&gt;; that would yield surprising results near the start of the year. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt; for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e362e9f328b5aa2d887a4c59191ea1b7f9721dc4" translate="yes" xml:space="preserve">
          <source>While C-style block comments are passed to the server for processing and removal, SQL-standard comments are removed by psql.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d725442e0975d9459afb2abfae7302730928d6f" translate="yes" xml:space="preserve">
          <source>While PostgreSQL's Serializable transaction isolation level only allows concurrent transactions to commit if it can prove there is a serial order of execution that would produce the same effect, it doesn't always prevent errors from being raised that would not occur in true serial execution. In particular, it is possible to see unique constraint violations caused by conflicts with overlapping Serializable transactions even after explicitly checking that the key isn't present before attempting to insert it. This can be avoided by making sure that &lt;em&gt;all&lt;/em&gt; Serializable transactions that insert potentially conflicting keys explicitly check if they can do so first. For example, imagine an application that asks the user for a new key and then checks that it doesn't exist already by trying to select it first, or generates a new key by selecting the maximum existing key and adding one. If some Serializable transactions insert new keys directly without following this protocol, unique constraints violations might be reported even in cases where they could not occur in a serial execution of the concurrent transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594dab457c5441b59c42227020751df6f6f62a48" translate="yes" xml:space="preserve">
          <source>While XQuery/XPath provides all of the types defined in XML Schema and many operators and functions over those types, XPath 1.0 has only node-sets and the three atomic types &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a627fd0ca096f765ec57a0f53e97d18839b3a4e" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;LIKE&lt;/code&gt; clause exists in the SQL standard, many of the options that PostgreSQL accepts for it are not in the standard, and some of the standard's options are not implemented by PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcdd2fd3f430f1ca01d2b3670c0f594bdee786bb" translate="yes" xml:space="preserve">
          <source>While a Repeatable Read transaction has a stable view of the data throughout its execution, there is a subtle issue with using MVCC snapshots for data consistency checks, involving something known as &lt;em&gt;read/write conflicts&lt;/em&gt;. If one transaction writes data and a concurrent transaction attempts to read the same data (whether before or after the write), it cannot see the work of the other transaction. The reader then appears to have executed first regardless of which started first or which committed first. If that is as far as it goes, there is no problem, but if the reader also writes data which is read by a concurrent transaction there is now a transaction which appears to have run before either of the previously mentioned transactions. If the transaction which appears to have executed last actually commits first, it is very easy for a cycle to appear in a graph of the order of execution of the transactions. When such a cycle appears, integrity checks will not work correctly without some help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a87fa7f9afe44920c1e825c81201c0429df3a1c" translate="yes" xml:space="preserve">
          <source>While a self-signed certificate can be used for testing, a certificate signed by a certificate authority (CA) (usually an enterprise-wide root CA) should be used in production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc31b216171332e350cb9df34dfb0418ab3630e" translate="yes" xml:space="preserve">
          <source>While designing your archiving setup, consider what will happen if the archive command fails repeatedly because some aspect requires operator intervention or the archive runs out of space. For example, this could occur if you write to tape without an autochanger; when the tape fills, nothing further can be archived until the tape is swapped. You should ensure that any error condition or request to a human operator is reported appropriately so that the situation can be resolved reasonably quickly. The &lt;code&gt;pg_wal/&lt;/code&gt; directory will continue to fill with WAL segment files until the situation is resolved. (If the file system containing &lt;code&gt;pg_wal/&lt;/code&gt; fills up, PostgreSQL will do a PANIC shutdown. No committed transactions will be lost, but the database will remain offline until you free some space.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed48d255fcc854a30e92ea66bfc2714ea9b2abf4" translate="yes" xml:space="preserve">
          <source>While forcing data to the disk platters periodically might seem like a simple operation, it is not. Because disk drives are dramatically slower than main memory and CPUs, several layers of caching exist between the computer's main memory and the disk platters. First, there is the operating system's buffer cache, which caches frequently requested disk blocks and combines disk writes. Fortunately, all operating systems give applications a way to force writes from the buffer cache to disk, and PostgreSQL uses those features. (See the &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; parameter to adjust how this is done.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae2f9725af5b866105aef02d826c3c21674b82a5" translate="yes" xml:space="preserve">
          <source>While it is possible to obtain information about which processes block which other processes by joining &lt;code&gt;pg_locks&lt;/code&gt; against itself, this is very difficult to get right in detail. Such a query would have to encode knowledge about which lock modes conflict with which others. Worse, the &lt;code&gt;pg_locks&lt;/code&gt; view does not expose information about which processes are ahead of which others in lock wait queues, nor information about which processes are parallel workers running on behalf of which other client sessions. It is better to use the &lt;code&gt;pg_blocking_pids()&lt;/code&gt; function (see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;Table 9.63&lt;/a&gt;) to identify which process(es) a waiting process is blocked behind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d114999ab92dc3c41f0deae7314e26f77d91d6" translate="yes" xml:space="preserve">
          <source>While most regular-expression searches can be executed very quickly, regular expressions can be contrived that take arbitrary amounts of time and memory to process. Be wary of accepting regular-expression search patterns from hostile sources. If you must do so, it is advisable to impose a statement timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4544bbaee7531ef45a0e42c59e09a0908293364f" translate="yes" xml:space="preserve">
          <source>While most timezone abbreviations represent fixed offsets from UTC, there are some that have historically varied in value (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt; for more information). In such cases this view presents their current meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e20acb9a4d1b2d1994838c4133180e7c30312a" translate="yes" xml:space="preserve">
          <source>While not required, it is recommended that you continue to follow this old convention of naming cast implementation functions after the target data type. Many users are used to being able to cast data types using a function-style notation, that is &lt;code&gt;typename&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;). This notation is in fact nothing more nor less than a call of the cast implementation function; it is not specially treated as a cast. If your conversion functions are not named to support this convention then you will have surprised users. Since PostgreSQL allows overloading of the same function name with different argument types, there is no difficulty in having multiple conversion functions from different types that all use the target type's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3fedf4b54ce85919b4142394d398f5b611a696" translate="yes" xml:space="preserve">
          <source>While policies will be applied for explicit queries against tables in the database, they are not applied when the system is performing internal referential integrity checks or validating constraints. This means there are indirect ways to determine that a given value exists. An example of this is attempting to insert a duplicate value into a column that is a primary key or has a unique constraint. If the insert fails then the user can infer that the value already exists. (This example assumes that the user is permitted by policy to insert records which they are not allowed to see.) Another example is where a user is allowed to insert into a table which references another, otherwise hidden table. Existence can be determined by the user inserting values into the referencing table, where success would indicate that the value exists in the referenced table. These issues can be addressed by carefully crafting policies to prevent users from being able to insert, delete, or update records at all which might possibly indicate a value they are not otherwise able to see, or by using generated values (e.g., surrogate keys) instead of keys with external meanings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbe4c0896d37fe14f081d1ac25be59617f075b0" translate="yes" xml:space="preserve">
          <source>While recovery is paused no further database changes are applied. If in hot standby, all new queries will see the same consistent snapshot of the database, and no further query conflicts will be generated until recovery is resumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67bee53c255823e86d8c23b4190b410627254abc" translate="yes" xml:space="preserve">
          <source>While rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7158e641e335f398bdfc35c274f36a1760cfa0bc" translate="yes" xml:space="preserve">
          <source>While running pg_dump, one should examine the output for any warnings (printed on standard error), especially in light of the limitations listed below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891b0584891eb2794e238a1971ed31f1c215e841" translate="yes" xml:space="preserve">
          <source>While that doesn't look all that bad by itself, it's still oversimplified. A far more complicated sub-select would be needed to select the right OID if there are multiple tables named &lt;code&gt;mytable&lt;/code&gt; in different schemas. The &lt;code&gt;regclass&lt;/code&gt; input converter handles the table lookup according to the schema path setting, and so it does the &amp;ldquo;right thing&amp;rdquo; automatically. Similarly, casting a table's OID to &lt;code&gt;regclass&lt;/code&gt; is handy for symbolic display of a numeric OID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d982cd814f64616912cda4d88166e9a69d28b85b" translate="yes" xml:space="preserve">
          <source>While that particular example might seem silly, related cases that don't obviously involve constants can occur in queries executed within functions, since the values of function arguments and local variables can be inserted into queries as constants for planning purposes. Within PL/pgSQL functions, for example, using an &lt;code&gt;IF&lt;/code&gt;-&lt;code&gt;THEN&lt;/code&gt;-&lt;code&gt;ELSE&lt;/code&gt; statement to protect a risky computation is much safer than just nesting it in a &lt;code&gt;CASE&lt;/code&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfcd6cf6959e988635a363ac7fbe48c4622cc9ea" translate="yes" xml:space="preserve">
          <source>While the built-in declarative partitioning is suitable for most common use cases, there are some circumstances where a more flexible approach may be useful. Partitioning can be implemented using table inheritance, which allows for several features not supported by declarative partitioning, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f761cf19de1d987297c4bdb87e576a9e8ef5e265" translate="yes" xml:space="preserve">
          <source>While the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations is retained, &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; does not order the generated rows based on this property. If you want the data to be ordered upon generation, you must use an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the backing query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bb80c5dc369e5a7b8dcef839df901e5b397bf5" translate="yes" xml:space="preserve">
          <source>While the details of the new type's internal representation are only known to the I/O functions and other functions you create to work with the type, there are several properties of the internal representation that must be declared to PostgreSQL. Foremost of these is &lt;code&gt;internallength&lt;/code&gt;. Base data types can be fixed-length, in which case &lt;code&gt;internallength&lt;/code&gt; is a positive integer, or variable-length, indicated by setting &lt;code&gt;internallength&lt;/code&gt; to &lt;code&gt;VARIABLE&lt;/code&gt;. (Internally, this is represented by setting &lt;code&gt;typlen&lt;/code&gt; to -1.) The internal representation of all variable-length types must start with a 4-byte integer giving the total length of this value of the type. (Note that the length field is often encoded, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;; it's unwise to access it directly.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915068b5c9a0a4207ecd95ee0a72471b7e35a59c" translate="yes" xml:space="preserve">
          <source>While the examples for these functions use constants, the typical use would be to reference a table in the &lt;code&gt;FROM&lt;/code&gt; clause and use one of its &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; columns as an argument to the function. Extracted key values can then be referenced in other parts of the query, like &lt;code&gt;WHERE&lt;/code&gt; clauses and target lists. Extracting multiple values in this way can improve performance over extracting them separately with per-key operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c09c1945f14d262f5a989a6b1b7f78a8869fb1b" translate="yes" xml:space="preserve">
          <source>While the server is running, it is not possible for a malicious user to take the place of the normal database server. However, when the server is down, it is possible for a local user to spoof the normal server by starting their own server. The spoof server could read passwords and queries sent by clients, but could not return any data because the &lt;code&gt;PGDATA&lt;/code&gt; directory would still be secure because of directory permissions. Spoofing is possible because any user can start a database server; a client cannot identify an invalid server unless it is specially configured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b90c7536148bdec5e290019a51b2379ecb8d63" translate="yes" xml:space="preserve">
          <source>While the server is running, its PID is stored in the file &lt;code&gt;postmaster.pid&lt;/code&gt; in the data directory. This is used to prevent multiple server instances from running in the same data directory and can also be used for shutting down the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03c807444bf3594110c4d388ec7b0a59f62a431" translate="yes" xml:space="preserve">
          <source>While the standard syntax for specifying string constants is usually convenient, it can be difficult to understand when the desired string contains many single quotes or backslashes, since each of those must be doubled. To allow more readable queries in such situations, PostgreSQL provides another way, called &amp;ldquo;dollar quoting&amp;rdquo;, to write string constants. A dollar-quoted string constant consists of a dollar sign (&lt;code&gt;$&lt;/code&gt;), an optional &amp;ldquo;tag&amp;rdquo; of zero or more characters, another dollar sign, an arbitrary sequence of characters that makes up the string content, a dollar sign, the same tag that began this dollar quote, and a dollar sign. For example, here are two different ways to specify the string &amp;ldquo;Dianne's horse&amp;rdquo; using dollar quoting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a03d15b6274d3b06d93b14cfe041b66ef2af72" translate="yes" xml:space="preserve">
          <source>While this function is more complex than the single-month case, it doesn't need to be updated as often, since branches can be added in advance of being needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb917c6d1ba7f34837342b8b023d8fdc99add536" translate="yes" xml:space="preserve">
          <source>While this is the only way to convert character strings into XML values according to the SQL standard, the PostgreSQL-specific syntaxes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b118c29b5eac33252cf8f05a41900068035eae" translate="yes" xml:space="preserve">
          <source>While transition table names for &lt;code&gt;AFTER&lt;/code&gt; triggers are specified using the &lt;code&gt;REFERENCING&lt;/code&gt; clause in the standard way, the row variables used in &lt;code&gt;FOR EACH ROW&lt;/code&gt; triggers may not be specified in a &lt;code&gt;REFERENCING&lt;/code&gt; clause. They are available in a manner that is dependent on the language in which the trigger function is written, but is fixed for any one language. Some languages effectively behave as though there is a &lt;code&gt;REFERENCING&lt;/code&gt; clause containing &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0775e3a82644839414e547fda3c53cda5989eee1" translate="yes" xml:space="preserve">
          <source>While turning off &lt;code&gt;fsync&lt;/code&gt; is often a performance benefit, this can result in unrecoverable data corruption in the event of a power failure or system crash. Thus it is only advisable to turn off &lt;code&gt;fsync&lt;/code&gt; if you can easily recreate your entire database from external data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9f7345f5e4a9cecb1d3a73e9e82a30d0080279" translate="yes" xml:space="preserve">
          <source>White space (i.e., spaces, tabs, and newlines) can be used freely in SQL commands. That means you can type the command aligned differently than above, or even all on one line. Two dashes (&amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo;) introduce comments. Whatever follows them is ignored up to the end of the line. SQL is case insensitive about key words and identifiers, except when identifiers are double-quoted to preserve the case (not done above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58bd91fff64a844973a8238af97e34efc8a5c324" translate="yes" xml:space="preserve">
          <source>White space is ignored on input, so &lt;code&gt;[(x),(y)]&lt;/code&gt; is the same as &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac41fe428645044123abfe95a020b4d162465d70" translate="yes" xml:space="preserve">
          <source>Whitespace is allowed before and after the range value, but any whitespace between the parentheses or brackets is taken as part of the lower or upper bound value. (Depending on the element type, it might or might not be significant.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc40c3d855977fc828d35a4c20284c43f252dc0" translate="yes" xml:space="preserve">
          <source>Why would you want to use the weak mode? Well, it could be that you have a huge collection of ISBN numbers, and that there are so many of them that for weird reasons some have the wrong check digit (perhaps the numbers were scanned from a printed list and the OCR got the numbers wrong, perhaps the numbers were manually captured... who knows). Anyway, the point is you might want to clean the mess up, but you still want to be able to have all the numbers in your database and maybe use an external tool to locate the invalid numbers in the database so you can verify the information and validate it more easily; so for example you'd want to select all the invalid numbers in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a7ce99eb76502ad0a6210d94039f0b40c3419d" translate="yes" xml:space="preserve">
          <source>Wildcard array element accessor that returns all array elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd2106ae04d09a5386f20710a015aa4219dc3f6c" translate="yes" xml:space="preserve">
          <source>Wildcard member accessor that returns the values of all members located at the top level of the current object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01267df331f99498a90196b34760cb7aa229a46d" translate="yes" xml:space="preserve">
          <source>Window function calls are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c367a920e4a4ea3efbe3a1a798085a3a023e6741" translate="yes" xml:space="preserve">
          <source>Window functions are described in detail in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f451b621911f3a41da7c18da4aff7cdb55589c1" translate="yes" xml:space="preserve">
          <source>Window functions are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query. They are forbidden elsewhere, such as in &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses. This is because they logically execute after the processing of those clauses. Also, window functions execute after non-window aggregate functions. This means it is valid to include an aggregate function call in the arguments of a window function, but not vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e789d251d694ff69667eed3b6a1eef1b73bc73" translate="yes" xml:space="preserve">
          <source>Window: cume_dist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7f6a60bbd5fd2e82c3412bbb88bea212c4bdb7" translate="yes" xml:space="preserve">
          <source>Window: dense_rank</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d36b418003a8b9c0e9b2dd2a6f2bff70e5a8ac" translate="yes" xml:space="preserve">
          <source>Window: first_value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f178a106cd7cba1da80bdc71ec514eea37f26d" translate="yes" xml:space="preserve">
          <source>Window: lag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabaa17e6490da4ec5451b3b47ee388b70cf91b0" translate="yes" xml:space="preserve">
          <source>Window: last_value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994efd60b559fadbd405573c301089b7cf18f884" translate="yes" xml:space="preserve">
          <source>Window: lead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="757db4a854089f2de8d98fd39c8889ef5116458d" translate="yes" xml:space="preserve">
          <source>Window: nth_value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f90d6e0544bf0f16ab443f5e02ee4cd6fe42bc" translate="yes" xml:space="preserve">
          <source>Window: ntile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb901cf4a6350aa408d137094086445ef7a0cf50" translate="yes" xml:space="preserve">
          <source>Window: percent_rank</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ecbc78e1223c489bcdc839303f81579d301dbd" translate="yes" xml:space="preserve">
          <source>Window: rank</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c13454a2137d228d57d97a95bb16f2559129e2" translate="yes" xml:space="preserve">
          <source>Window: row_number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb3a4bfc7eab0371f71e7828e71cca0cb17b3c3" translate="yes" xml:space="preserve">
          <source>Windows CP1250</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2c00b8e44a047e41a03f1caab3a7b4b6689695" translate="yes" xml:space="preserve">
          <source>Windows CP1251</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9d69428625d1ff5f15b6e3dcde936a0fd1f094" translate="yes" xml:space="preserve">
          <source>Windows CP1252</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc78a0c32f91f66c55ae633ccbcefebb486eb07a" translate="yes" xml:space="preserve">
          <source>Windows CP1253</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f231ed423cb65bf660816b30028087f1a8e8ce5" translate="yes" xml:space="preserve">
          <source>Windows CP1254</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23b534f177679e438c10751dd8cd9af7ceda942" translate="yes" xml:space="preserve">
          <source>Windows CP1255</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6790dc03b7d5b6e6f32fcb36c60e23323fb868ac" translate="yes" xml:space="preserve">
          <source>Windows CP1256</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de6d342a6a1f91fe73d1aed1c38e985a216e16e" translate="yes" xml:space="preserve">
          <source>Windows CP1257</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640bb2a94fe66a43ea03427875c71fa7af756764" translate="yes" xml:space="preserve">
          <source>Windows CP1258</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95532249be79aa59a141ea1dc6d988132a7c104" translate="yes" xml:space="preserve">
          <source>Windows CP866</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69925dc2d1afa064badeb7131e0815ad04126da3" translate="yes" xml:space="preserve">
          <source>Windows CP874</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d589f8c6c9e727468855e6a54c0d6dfb5cce47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, pg_restore also restores the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also restored, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fdece12f1fb080c2dbfd8709cabeca4afb1d172" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, the output also includes the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also dumped, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f453a9fafc8b310f8a3de3fda65ed4c38e9ca283" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;join_collapse_limit&lt;/code&gt; = 1, this forces the planner to join A to B before joining them to other tables, but doesn't constrain its choices otherwise. In this example, the number of possible join orders is reduced by a factor of 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe49ef2ae18f846d2f24144892dcb7436b22edbb" translate="yes" xml:space="preserve">
          <source>With ICU, it is not sensible to enumerate all possible locale names. ICU uses a particular naming system for locales, but there are many more ways to name a locale than there are actually distinct locales. &lt;code&gt;initdb&lt;/code&gt; uses the ICU APIs to extract a set of distinct locales to populate the initial set of collations. Collations provided by ICU are created in the SQL environment with names in BCP 47 language tag format, with a &amp;ldquo;private use&amp;rdquo; extension &lt;code&gt;-x-icu&lt;/code&gt; appended, to distinguish them from libc locales.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0ce6e945d75c0e017cd4582a6ce07fb85c72b6" translate="yes" xml:space="preserve">
          <source>With OpenSSL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa1343fb87dfb28347c1e7e66e33ba69c59c2ca" translate="yes" xml:space="preserve">
          <source>With SSL support compiled in, the PostgreSQL server can be started with SSL enabled by setting the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. The server will listen for both normal and SSL connections on the same TCP port, and will negotiate with any connecting client on whether to use SSL. By default, this is at the client's option; see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about how to set up the server to require use of SSL for some or all connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d13ab27fd57668592221b667df2e40b0bb1e2e4" translate="yes" xml:space="preserve">
          <source>With a cluster distributed across multiple geographic locations, using different values per location brings more flexibility in the cluster management. A smaller value is useful for faster failure detection with a standby having a low-latency network connection, and a larger value helps in judging better the health of a standby if located on a remote location, with a high-latency network connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2817eb5fe50b4283e89c69a97c63500ae24da2d7" translate="yes" xml:space="preserve">
          <source>With a parameter, turns displaying of how long each SQL statement takes on or off. Without a parameter, toggles the display between on and off. The display is in milliseconds; intervals longer than 1 second are also shown in minutes:seconds format, with hours and days fields added if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862b8683e39578b4e7d997552333b9aad19243ce" translate="yes" xml:space="preserve">
          <source>With constraint exclusion enabled, this &lt;code&gt;SELECT&lt;/code&gt; will not scan &lt;code&gt;child1000&lt;/code&gt; at all, improving performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281288184f75c730f93254833c37347e0fc29fe4" translate="yes" xml:space="preserve">
          <source>With data warehouse type workloads, it can make sense to use a larger number of partitions than with an OLTP type workload. Generally, in data warehouses, query planning time is less of a concern as the majority of processing time is spent during query execution. With either of these two types of workload, it is important to make the right decisions early, as re-partitioning large quantities of data can be painfully slow. Simulations of the intended workload are often beneficial for optimizing the partitioning strategy. Never assume that more partitions are better than fewer partitions and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3766650cc974cf1ed93fe99df3e842788c554914" translate="yes" xml:space="preserve">
          <source>With no advance preparation, the system would have to scan the entire &lt;code&gt;test1&lt;/code&gt; table, row by row, to find all matching entries. If there are many rows in &lt;code&gt;test1&lt;/code&gt; and only a few rows (perhaps zero or one) that would be returned by such a query, this is clearly an inefficient method. But if the system has been instructed to maintain an index on the &lt;code&gt;id&lt;/code&gt; column, it can use a more efficient method for locating matching rows. For instance, it might only have to walk a few levels deep into a search tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d718f6eccff45185b0a45095de6fde081eea1bba" translate="yes" xml:space="preserve">
          <source>With no argument, escapes to a sub-shell; psql resumes when the sub-shell exits. With an argument, executes the shell command &lt;code&gt;command&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9514950fe011b56b473f75097880ade2b163bceb" translate="yes" xml:space="preserve">
          <source>With statement-based replication middleware, a program intercepts every SQL query and sends it to one or all servers. Each server operates independently. Read-write queries must be sent to all servers, so that every server receives any changes. But read-only queries can be sent to just one server, allowing the read workload to be distributed among them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4094d09ba0d0f0a9849aa3ea46bb7d77a767e980" translate="yes" xml:space="preserve">
          <source>With synchronous replication options specified at the application level (on the primary) we can offer synchronous replication for the most important changes, without slowing down the bulk of the total workload. Application level options are an important and practical tool for allowing the benefits of synchronous replication for high performance applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e625f82083935e0517f3c7cf1a804070d41f41f5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--aggregate-interval&lt;/code&gt; option, a different format is used for the log files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c13395c6ff50aca429bd803e2b410319037881" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-l&lt;/code&gt; option (but without the &lt;code&gt;--aggregate-interval&lt;/code&gt; option), pgbench writes information about each transaction to a log file. The log file will be named &lt;code&gt;prefix.nnn&lt;/code&gt;, where &lt;code&gt;prefix&lt;/code&gt; defaults to &lt;code&gt;pgbench_log&lt;/code&gt;, and &lt;code&gt;nnn&lt;/code&gt; is the PID of the pgbench process. The prefix can be changed by using the &lt;code&gt;--log-prefix&lt;/code&gt; option. If the &lt;code&gt;-j&lt;/code&gt; option is 2 or higher, so that there are multiple worker threads, each will have its own log file. The first worker will use the same name for its log file as in the standard single worker case. The additional log files for the other workers will be named &lt;code&gt;prefix.nnn.mmm&lt;/code&gt;, where &lt;code&gt;mmm&lt;/code&gt; is a sequential number for each worker starting with 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea12aa8ce2a4f9481a6f03ad5ce52c7d1882b2a" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-r&lt;/code&gt; option, pgbench collects the elapsed transaction time of each statement executed by every client. It then reports an average of those values, referred to as the latency for each statement, after the benchmark has finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d0adcb9fc8fc9dddac0cfadc06d179ba840172" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;, it is only useful to place a &lt;code&gt;simple&lt;/code&gt; dictionary at the end of a list of dictionaries, since it will never pass on any token to a following dictionary. Conversely, &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; is only useful when there is at least one following dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1679a02524be37201556be412a6d701fa1ad4ae3" translate="yes" xml:space="preserve">
          <source>With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt; and read the rest of this chapter later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37674f638cca87d9f8a3c6dc8d132c3743ff6b7c" translate="yes" xml:space="preserve">
          <source>With this parameter enabled, you can still create ordinary global users. Simply append &lt;code&gt;@&lt;/code&gt; when specifying the user name in the client, e.g. &lt;code&gt;joe@&lt;/code&gt;. The &lt;code&gt;@&lt;/code&gt; will be stripped off before the user name is looked up by the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de39e9b44ca28bac2cf5d078925f7311c5e84abb" translate="yes" xml:space="preserve">
          <source>With this preparation, a backup can be taken using a script like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d93925105d3192c92e0036610fccacd28a3de6" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;, the special table names &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt; can be used to refer to values in the referenced table. &lt;code&gt;NEW&lt;/code&gt; is valid in &lt;code&gt;ON INSERT&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; rules to refer to the new row being inserted or updated. &lt;code&gt;OLD&lt;/code&gt; is valid in &lt;code&gt;ON UPDATE&lt;/code&gt; and &lt;code&gt;ON DELETE&lt;/code&gt; rules to refer to the existing row being updated or deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7c7983937789ea59f666ccaa3b6dc10f18e4489" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;tsquery&lt;/code&gt;, the &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) operator specifies that both its arguments must appear in the document to have a match. Similarly, the &lt;code&gt;|&lt;/code&gt; (OR) operator specifies that at least one of its arguments must appear, while the &lt;code&gt;!&lt;/code&gt; (NOT) operator specifies that its argument must &lt;em&gt;not&lt;/em&gt; appear in order to have a match. For example, the query &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; matches documents that contain &lt;code&gt;fat&lt;/code&gt; but not &lt;code&gt;rat&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2368cc4cb5a919d014b1e03cda4cf0d9819b781" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element (a character, a multiple-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt; stands for the sequence of characters of that collating element. The sequence is treated as a single element of the bracket expression's list. This allows a bracket expression containing a multiple-character collating element to match more than one character, e.g., if the collating sequence includes a &lt;code&gt;ch&lt;/code&gt; collating element, then the RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; matches the first five characters of &lt;code&gt;chchcc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1fe750b2061555e551fa7ddfd0d60d1ac81517" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element enclosed in &lt;code&gt;[=&lt;/code&gt; and &lt;code&gt;=]&lt;/code&gt; is an &lt;em&gt;equivalence class&lt;/em&gt;, standing for the sequences of characters of all collating elements equivalent to that one, including itself. (If there are no other equivalent collating elements, the treatment is as if the enclosing delimiters were &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt;.) For example, if &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt; are the members of an equivalence class, then &lt;code&gt;[[=o=]]&lt;/code&gt;, &lt;code&gt;[[=^=]]&lt;/code&gt;, and &lt;code&gt;[o^]&lt;/code&gt; are all synonymous. An equivalence class cannot be an endpoint of a range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb82d076f25a7be9aee0f56365d178b74a1a2ff" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, the name of a character class enclosed in &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; stands for the list of all characters belonging to that class. A character class cannot be used as an endpoint of a range. The POSIX standard defines these character class names: &lt;code&gt;alnum&lt;/code&gt; (letters and numeric digits), &lt;code&gt;alpha&lt;/code&gt; (letters), &lt;code&gt;blank&lt;/code&gt; (space and tab), &lt;code&gt;cntrl&lt;/code&gt; (control characters), &lt;code&gt;digit&lt;/code&gt; (numeric digits), &lt;code&gt;graph&lt;/code&gt; (printable characters except space), &lt;code&gt;lower&lt;/code&gt; (lower-case letters), &lt;code&gt;print&lt;/code&gt; (printable characters including space), &lt;code&gt;punct&lt;/code&gt; (punctuation), &lt;code&gt;space&lt;/code&gt; (any white space), &lt;code&gt;upper&lt;/code&gt; (upper-case letters), and &lt;code&gt;xdigit&lt;/code&gt; (hexadecimal digits). The behavior of these standard character classes is generally consistent across platforms for characters in the 7-bit ASCII set. Whether a given non-ASCII character is considered to belong to one of these classes depends on the &lt;em&gt;collation&lt;/em&gt; that is used for the regular-expression function or operator (see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;), or by default on the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting (see &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;). The classification of non-ASCII characters can vary across platforms even in similarly-named locales. (But the &lt;code&gt;C&lt;/code&gt; locale never considers any non-ASCII characters to belong to any of these classes.) In addition to these standard character classes, PostgreSQL defines the &lt;code&gt;ascii&lt;/code&gt; character class, which contains exactly the 7-bit ASCII set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35bef27a0203dd6547cf96a8cb6d957c5595d5c" translate="yes" xml:space="preserve">
          <source>Within a pattern, &lt;code&gt;*&lt;/code&gt; matches any sequence of characters (including no characters) and &lt;code&gt;?&lt;/code&gt; matches any single character. (This notation is comparable to Unix shell file name patterns.) For example, &lt;code&gt;\dt int*&lt;/code&gt; displays tables whose names begin with &lt;code&gt;int&lt;/code&gt;. But within double quotes, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; lose these special meanings and are just matched literally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323b9b12ce6cec030c2782c77172b386cffa6487" translate="yes" xml:space="preserve">
          <source>Within an argument, text that is enclosed in backquotes (&lt;code&gt;`&lt;/code&gt;) is taken as a command line that is passed to the shell. The output of the command (with any trailing newline removed) replaces the backquoted text. Within the text enclosed in backquotes, no special quoting or other processing occurs, except that appearances of &lt;code&gt;:variable_name&lt;/code&gt; where &lt;code&gt;variable_name&lt;/code&gt; is a psql variable name are replaced by the variable's value. Also, appearances of &lt;code&gt;:'variable_name'&lt;/code&gt; are replaced by the variable's value suitably quoted to become a single shell command argument. (The latter form is almost always preferable, unless you are very sure of what is in the variable.) Because carriage return and line feed characters cannot be safely quoted on all platforms, the &lt;code&gt;:'variable_name'&lt;/code&gt; form prints an error message and does not substitute the variable value when such characters appear in the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02446a7929ab10f300f87f18642a172ae6a7fbfe" translate="yes" xml:space="preserve">
          <source>Within any particular database, only collations that use that database's encoding are of interest. Other entries in &lt;code&gt;pg_collation&lt;/code&gt; are ignored. Thus, a stripped collation name such as &lt;code&gt;de_DE&lt;/code&gt; can be considered unique within a given database even though it would not be unique globally. Use of the stripped collation names is recommended, since it will make one less thing you need to change if you decide to change to another database encoding. Note however that the &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; collations can be used regardless of the database encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a80b578691f1b5a7af0065fe86a5cb4aa2ce86a" translate="yes" xml:space="preserve">
          <source>Within bracket expressions, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; lose their outer brackets, and &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt; are illegal. (So, for example, &lt;code&gt;[a-c\d]&lt;/code&gt; is equivalent to &lt;code&gt;[a-c[:digit:]]&lt;/code&gt;. Also, &lt;code&gt;[a-c\D]&lt;/code&gt;, which is equivalent to &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt;, is illegal.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2542957abf2f09b64545fb48b800de1036c8c62f" translate="yes" xml:space="preserve">
          <source>Within each FSM page is a binary tree, stored in an array with one byte per node. Each leaf node represents a heap page, or a lower level FSM page. In each non-leaf node, the higher of its children's values is stored. The maximum value in the leaf nodes is therefore stored at the root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8d6e1ae92682e55948b9d998dc41d07bd4d9ee" translate="yes" xml:space="preserve">
          <source>Within each catalog row, write comma-separated &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The allowed &lt;code&gt;key&lt;/code&gt;s are the names of the catalog's columns, plus the metadata keys &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt;. (The use of &lt;code&gt;oid&lt;/code&gt; and &lt;code&gt;oid_symbol&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;Section 69.2.2&lt;/a&gt; below, while &lt;code&gt;array_type_oid&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;Section 69.2.4&lt;/a&gt;. &lt;code&gt;descr&lt;/code&gt; supplies a description string for the object, which will be inserted into &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_shdescription&lt;/code&gt; as appropriate.) While the metadata keys are optional, the catalog's defined columns must all be provided, except when the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for the column. (In the example above, the &lt;code&gt;datdba&lt;/code&gt; field has been omitted because &lt;code&gt;pg_database.h&lt;/code&gt; supplies a suitable default value for it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b70f85093aa93c4bd37783889d55ab04e575f61" translate="yes" xml:space="preserve">
          <source>Within each pair of curly braces, the metadata fields &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt; (if present) come first, in that order, then the catalog's own fields appear in their defined order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7877c1484b515b178eb13d5365bc7aee43c3498f" translate="yes" xml:space="preserve">
          <source>Within larger commands, &lt;code&gt;VALUES&lt;/code&gt; is syntactically allowed anywhere that &lt;code&gt;SELECT&lt;/code&gt; is. Because it is treated like a &lt;code&gt;SELECT&lt;/code&gt; by the grammar, it is possible to use the &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt; (or equivalently &lt;code&gt;FETCH FIRST&lt;/code&gt;), and &lt;code&gt;OFFSET&lt;/code&gt; clauses with a &lt;code&gt;VALUES&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b2c20b975865db54e88c092240735063656bf9" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;ANALYZE&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to analyze. With a list, &lt;code&gt;ANALYZE&lt;/code&gt; processes only those table(s). It is further possible to give a list of column names for a table, in which case only the statistics for those columns are collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd2342b55fa6fe36f0fd7dea1e8abcfbe35286d" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;VACUUM&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to vacuum. With a list, &lt;code&gt;VACUUM&lt;/code&gt; processes only those table(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2564642da39c57e6f0da0af32cec7b221b00e6cf" translate="yes" xml:space="preserve">
          <source>Without a qualification, &lt;code&gt;DELETE&lt;/code&gt; will remove &lt;em&gt;all&lt;/em&gt; rows from the given table, leaving it empty. The system will not request confirmation before doing this!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fcdcc5d8356bd3ccce31a7a0f56d4a3af85303" translate="yes" xml:space="preserve">
          <source>Without functional-dependency statistics, the planner would assume that the two &lt;code&gt;WHERE&lt;/code&gt; conditions are independent, and would multiply their selectivities together to arrive at a much-too-small row count estimate. With such statistics, the planner recognizes that the &lt;code&gt;WHERE&lt;/code&gt; conditions are redundant and does not underestimate the row count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc783547ace7f2e9e22e7b50a67f3d97784d6474" translate="yes" xml:space="preserve">
          <source>Without partition pruning, the above query would scan each of the partitions of the &lt;code&gt;measurement&lt;/code&gt; table. With partition pruning enabled, the planner will examine the definition of each partition and prove that the partition need not be scanned because it could not contain any rows meeting the query's &lt;code&gt;WHERE&lt;/code&gt; clause. When the planner can prove this, it excludes (&lt;em&gt;prunes&lt;/em&gt;) the partition from the query plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23034486b72d6e700160ee9f0facdf636985eee4" translate="yes" xml:space="preserve">
          <source>Without quotes, &lt;code&gt;to_tsquery&lt;/code&gt; will generate a syntax error for tokens that are not separated by an AND, OR, or FOLLOWED BY operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1c012acaa571247fa7393ff98695c754cfacba" translate="yes" xml:space="preserve">
          <source>Without the extra parentheses, this will generate a syntax error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3003268a98f289ec381313920f30367739bc175f" translate="yes" xml:space="preserve">
          <source>Without the third rule, it is possible for an index reader to see an index entry just before it is removed by &lt;code&gt;VACUUM&lt;/code&gt;, and then to arrive at the corresponding heap entry after that was removed by &lt;code&gt;VACUUM&lt;/code&gt;. This creates no serious problems if that item number is still unused when the reader reaches it, since an empty item slot will be ignored by &lt;code&gt;heap_fetch()&lt;/code&gt;. But what if a third backend has already re-used the item slot for something else? When using an MVCC-compliant snapshot, there is no problem because the new occupant of the slot is certain to be too new to pass the snapshot test. However, with a non-MVCC-compliant snapshot (such as &lt;code&gt;SnapshotAny&lt;/code&gt;), it would be possible to accept and return a row that does not in fact match the scan keys. We could defend against this scenario by requiring the scan keys to be rechecked against the heap row in all cases, but that is too expensive. Instead, we use a pin on an index page as a proxy to indicate that the reader might still be &amp;ldquo;in flight&amp;rdquo; from the index entry to the matching heap entry. Making &lt;code&gt;ambulkdelete&lt;/code&gt; block on such a pin ensures that &lt;code&gt;VACUUM&lt;/code&gt; cannot delete the heap entry before the reader is done with it. This solution costs little in run time, and adds blocking overhead only in the rare cases where there actually is a conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdba0729d7141c4dc983525f28420a370b378b16" translate="yes" xml:space="preserve">
          <source>Without this clause, it is an error to specify an explicit value (other than &lt;code&gt;DEFAULT&lt;/code&gt;) for an identity column defined as &lt;code&gt;GENERATED ALWAYS&lt;/code&gt;. This clause overrides that restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de5c631615b4050dbf3abcb11bda852949d1d49" translate="yes" xml:space="preserve">
          <source>Word, all ASCII letters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd638519c2bb50f94881c41d59edcf0f4b988187" translate="yes" xml:space="preserve">
          <source>Word, all letters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d929261f89fb5edc0a55361dccd5a42cfafc1e28" translate="yes" xml:space="preserve">
          <source>Word, letters and digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c821c5f35490070199526bcafeccdc95331fb80" translate="yes" xml:space="preserve">
          <source>Work is still needed to improve the genetic algorithm parameter settings. In file &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt;, routines &lt;code&gt;gimme_pool_size&lt;/code&gt; and &lt;code&gt;gimme_number_generations&lt;/code&gt;, we have to find a compromise for the parameter settings to satisfy two competing demands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae6871c604e1194dadbdf1baf868fa3278d7cc4" translate="yes" xml:space="preserve">
          <source>Write Ahead Log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9793b6786fb282a995505c49ca5c8dab4849b1" translate="yes" xml:space="preserve">
          <source>Write a message to the server log if checkpoints caused by the filling of WAL segment files happen closer together than this amount of time (which suggests that &lt;code&gt;max_wal_size&lt;/code&gt; ought to be raised). If this value is specified without units, it is taken as seconds. The default is 30 seconds (&lt;code&gt;30s&lt;/code&gt;). Zero disables the warning. No warnings will be generated if &lt;code&gt;checkpoint_timeout&lt;/code&gt; is less than &lt;code&gt;checkpoint_warning&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f29b256742ae32a7ee610c6c80dec55fe4bb44" translate="yes" xml:space="preserve">
          <source>Write all query output into file &lt;code&gt;filename&lt;/code&gt;, in addition to the normal output destination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced9f94f9040a73c60549d122b831459c11a3fbf" translate="yes" xml:space="preserve">
          <source>Write information about each transaction to a log file. See below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33b6c1a70b5c50c6203011bb22d6394a5061934" translate="yes" xml:space="preserve">
          <source>Write received and decoded transaction data into this file. Use &lt;code&gt;-&lt;/code&gt; for stdout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660438e8219803d5c64d3c38fd0601dbee576ac1" translate="yes" xml:space="preserve">
          <source>Write the output as plain files, with the same layout as the current data directory and tablespaces. When the cluster has no additional tablespaces, the whole database will be placed in the target directory. If the cluster contains additional tablespaces, the main data directory will be placed in the target directory, but all other tablespaces will be placed in the same absolute path as they have on the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc92c3f4b6de8494f22f127e95dec8313f91169" translate="yes" xml:space="preserve">
          <source>Write the output as tar files in the target directory. The main data directory will be written to a file named &lt;code&gt;base.tar&lt;/code&gt;, and all other tablespaces will be named after the tablespace OID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12aba288e98df3f05ebad1cf7143b1a4df822af8" translate="yes" xml:space="preserve">
          <source>Write, or append to, a text file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73694598d4f6dd9ae50f65c44a8d5357103fbda0" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32219ea741aab08cd4b2cc75491ff92cd882b3c1" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log Shipping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674bcf8c81a59458958b21d0660da76f6ba332b5" translate="yes" xml:space="preserve">
          <source>Writes the current query buffer to the file &lt;code&gt;filename&lt;/code&gt; or pipes it to the shell command &lt;code&gt;command&lt;/code&gt;. If the current query buffer is empty, the most recently executed query is written instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84228914215a42dbe6fe7e926dad3ab9b4cf367" translate="yes" xml:space="preserve">
          <source>Writes the generated LLVM IR out to the file system, inside &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;. This is only useful for working on the internals of the JIT implementation. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be changed by a superuser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5af6404c7f764d57f9d5c62315cdf9f310e1309" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;*&lt;/code&gt; is not necessary, since this behavior is always the default. However, this syntax is still supported for compatibility with older releases where the default could be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6151e701c60f047c7b832b2686813d1310a12fca" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;ALL&lt;/code&gt; in place of a specific privilege grants all privileges that are relevant for the object type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43277b6f1b770dadde2ceed80f27334202f924f" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;SECURITY DEFINER&lt;/code&gt; Functions Safely</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbf328be37b139670f7ef37c6af175473c5c705" translate="yes" xml:space="preserve">
          <source>Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5165fc57d1f9a5e5c5994fec1932df3a128a9e" translate="yes" xml:space="preserve">
          <source>Writing the actual numeric value of any OID in C code is considered very bad form; always use a macro, instead. Direct references to &lt;code&gt;pg_proc&lt;/code&gt; OIDs are common enough that there's a special mechanism to create the necessary macros automatically; see &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt;. Similarly &amp;mdash; but, for historical reasons, not done the same way &amp;mdash; there's an automatic method for creating macros for &lt;code&gt;pg_type&lt;/code&gt; OIDs. &lt;code&gt;oid_symbol&lt;/code&gt; entries are therefore not necessary in those two catalogs. Likewise, macros for the &lt;code&gt;pg_class&lt;/code&gt; OIDs of system catalogs and indexes are set up automatically. For all other system catalogs, you have to manually specify any macros you need via &lt;code&gt;oid_symbol&lt;/code&gt; entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5409f1461aa5b5298ee6d5c93002f7a27e50654" translate="yes" xml:space="preserve">
          <source>XID</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fc167721857c5174dbbe545fe597100e840cd6" translate="yes" xml:space="preserve">
          <source>XID for VACUUM operation moving a row version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dbc2e3a95bd424284a60fab71bfd99ecc6aa480" translate="yes" xml:space="preserve">
          <source>XML Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677fbcd727fb96243fff280b768de17534da204d" translate="yes" xml:space="preserve">
          <source>XML Limits and Conformance to SQL/XML</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1200e7280e074bb09cc29b489d7736fa9c3b13" translate="yes" xml:space="preserve">
          <source>XML Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f6e6e18c4cf2cdf2736a3171665401b5f531b0" translate="yes" xml:space="preserve">
          <source>XML data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc2b7976718250ab1463410139c7c00b0f2e7ce" translate="yes" xml:space="preserve">
          <source>XML declarations, if present, are combined as follows. If all argument values have the same XML version declaration, that version is used in the result, else no version is used. If all argument values have the standalone declaration value &amp;ldquo;yes&amp;rdquo;, then that value is used in the result. If all argument values have a standalone declaration value and at least one is &amp;ldquo;no&amp;rdquo;, then that is used in the result. Else the result will have no standalone declaration. If the result is determined to require a standalone declaration but no version declaration, a version declaration with version 1.0 will be used because XML requires an XML declaration to contain a version declaration. Encoding declarations are ignored and removed in all cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93db77a518a3a65df06b8910ae3df05493323aa8" translate="yes" xml:space="preserve">
          <source>XML entity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d948a6e01de6c3d4845c4fb6a9cd77bb4a345f" translate="yes" xml:space="preserve">
          <source>XML format is left as an exercise for the reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c648229e46576f92e57966e5bb6a169947ab07af" translate="yes" xml:space="preserve">
          <source>XML tag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b6740d5d3d1f4067adb9c002cd0cc814ec4855" translate="yes" xml:space="preserve">
          <source>XML: IS DOCUMENT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863fe78f50c66a6f7d93b18bf787a5d0aa670b5c" translate="yes" xml:space="preserve">
          <source>XML: IS NOT DOCUMENT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="708b35917f64aea4aecf43902f9f6861b388f0a3" translate="yes" xml:space="preserve">
          <source>XML: XMLEXISTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aea648b2b4e07c316d48e040a2dfe07aea119ed" translate="yes" xml:space="preserve">
          <source>XML: xml_is_well_formed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eca7373df1b8e0c5ed4c506c73dcc360d0c1000" translate="yes" xml:space="preserve">
          <source>XML: xmlagg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31986b6f48c236780bb28b6f7a97cd2e7fe2fbbc" translate="yes" xml:space="preserve">
          <source>XML: xmlcomment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3336319324aa48adbaa76e0cbbf9934042dd41f7" translate="yes" xml:space="preserve">
          <source>XML: xmlconcat</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c269b1860c6e177984dcd77f1f2f9180f500a7b1" translate="yes" xml:space="preserve">
          <source>XML: xmlelement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f6cd60dad73c2efa2b22421846170fa537daf4" translate="yes" xml:space="preserve">
          <source>XML: xmlforest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c3ab3b44e0a9d5e8cf4d618e5fb213a70446ae" translate="yes" xml:space="preserve">
          <source>XML: xmlpi</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb9abaad07f3be72c6b803b64719f6ad9373b8b" translate="yes" xml:space="preserve">
          <source>XML: xmlroot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1c1afeea56eb4d61a6d5854b178d21b29bd194" translate="yes" xml:space="preserve">
          <source>XML: xmltable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943bcc21921946abacf747784b147601338c43bb" translate="yes" xml:space="preserve">
          <source>XML: xpath</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112eb0200c63c2f0de87632cdeab3a1c8a706831" translate="yes" xml:space="preserve">
          <source>XML: xpath_exists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a417f6430ccc4b644617c160b0d4f1b2c80cd5e2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 blurs the distinction between &lt;em&gt;value comparisons&lt;/em&gt; and &lt;em&gt;general comparisons&lt;/em&gt; as XQuery/XPath define them. Both &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; and &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; are existentially quantified comparisons, true if there is any &lt;code&gt;sale&lt;/code&gt; with the given value for the attribute, but &lt;code&gt;sale/@taxable = false()&lt;/code&gt; is a value comparison to the &lt;em&gt;effective boolean value&lt;/em&gt; of a whole node-set. It is true only if no &lt;code&gt;sale&lt;/code&gt; has a &lt;code&gt;taxable&lt;/code&gt; attribute at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37617c0d5dc43deba6ebd523a1e7daa408818b2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 does not specify an order for nodes in a node-set, so code that relies on a particular order of the results will be implementation-dependent. Details can be found in &lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;Section D.3.1.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccec9b819d48fea6e95ee65b1f2c2363e5212016" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no conditional operator. An XQuery/XPath expression such as &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; has no XPath 1.0 equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575a5727a0aaf2dc929963572ab31f3a07d3b31b" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no ordering comparison operator for strings. Both &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; and &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; are false, because each is a numeric comparison of two &lt;code&gt;NaN&lt;/code&gt;s. In contrast, &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; do compare the strings as strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4149ee47a54aa2c037b2786d8549ef1627ad8e" translate="yes" xml:space="preserve">
          <source>XQuery allows declaration and use of local functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818970bcffceb4be8cc185fddd03719babd24f42" translate="yes" xml:space="preserve">
          <source>XQuery character class elements using &lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; or the inverse &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9675f91b1bee552c1436f5af897518b9d66036" translate="yes" xml:space="preserve">
          <source>XQuery character class shorthands &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\i&lt;/code&gt;, and &lt;code&gt;\I&lt;/code&gt; are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05d40877e991191e09256daf83989a5f47e5557" translate="yes" xml:space="preserve">
          <source>XQuery character class subtraction is not supported. An example of this feature is using the following to match only English consonants: &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ba7fb2ffaaf928a3568f9854442e7071379dc9" translate="yes" xml:space="preserve">
          <source>XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41577214ab7c5c54db475c958675a49fbb00b4a6" translate="yes" xml:space="preserve">
          <source>XQuery does not support the &lt;code&gt;[:name:]&lt;/code&gt; syntax for character classes within bracket expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0c3c6ff5da1ba3d8311b799d1cf51c7385d7c2" translate="yes" xml:space="preserve">
          <source>XQuery expressions can construct and return new XML nodes, in addition to all possible XPath values. XPath can create and return values of the atomic types (numbers, strings, and so on) but can only return XML nodes that were already present in documents supplied as input to the expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d07dea26dd7592af4147bb1ae9d21c709ece2a7" translate="yes" xml:space="preserve">
          <source>XQuery has control constructs for iteration, sorting, and grouping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9add350a4eb532be8a2c9c9d393be8bd03cceb66" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;s&lt;/code&gt; (allow dot to match newline) and &lt;code&gt;m&lt;/code&gt; (allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines) flags provide access to the same behaviors as POSIX's &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; flags, but they do &lt;em&gt;not&lt;/em&gt; match the behavior of POSIX's &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; flags. Note in particular that dot-matches-newline is the default behavior in POSIX but not XQuery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fbdf61430816231b42e0b59499fabbec39b5ae3" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;x&lt;/code&gt; (ignore whitespace in pattern) flag is noticeably different from POSIX's expanded-mode flag. POSIX's &lt;code&gt;x&lt;/code&gt; flag also allows &lt;code&gt;#&lt;/code&gt; to begin a comment in the pattern, and POSIX will not ignore a whitespace character after a backslash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb29757e458776404c0d0c4f5c75b0740d559b1c" translate="yes" xml:space="preserve">
          <source>Year and day of year: for example &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; also returns &lt;code&gt;2006-10-19&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5a18c267810c3dc6c5d4fdd0b02c9e146fd0f1" translate="yes" xml:space="preserve">
          <source>Year, week number, and weekday: for example &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; returns the date &lt;code&gt;2006-10-19&lt;/code&gt;. If you omit the weekday it is assumed to be 1 (Monday).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abdb2567a06fc713cd1d6b57e90f634441b367e" translate="yes" xml:space="preserve">
          <source>Year-Month Interval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f997bcecb36502ed4b296a795f72aff9d6bfe7" translate="yes" xml:space="preserve">
          <source>Years</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfd5c7e576642a9c9f3bbe4db929041cea0177f" translate="yes" xml:space="preserve">
          <source>Years in the 1900s are in the second millennium. The third millennium started January 1, 2001.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd15150afde3fb668c9c37b5570c9f350a42483" translate="yes" xml:space="preserve">
          <source>You can (and, for most purposes, probably should) increase the number of rows by using the &lt;code&gt;-s&lt;/code&gt; (scale factor) option. The &lt;code&gt;-F&lt;/code&gt; (fillfactor) option might also be used at this point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145c00d5953681c62f21c82b058caafeee2a8310" translate="yes" xml:space="preserve">
          <source>You can adapt this module to your needs by changing the source code. For example, you can use &lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt; to check passwords &amp;mdash; this only requires uncommenting two lines in the &lt;code&gt;Makefile&lt;/code&gt; and rebuilding the module. (We cannot include CrackLib by default for license reasons.) Without CrackLib, the module enforces a few simple rules for password strength, which you can modify or extend as you see fit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dae3ce662983a3720ca411f5e625f764893bf1" translate="yes" xml:space="preserve">
          <source>You can add whitespace before a left brace or after a right brace. You can also add whitespace before or after any individual item string. In all of these cases the whitespace will be ignored. However, whitespace within double-quoted elements, or surrounded on both sides by non-whitespace characters of an element, is not ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569893ff6c39724a565a145b8a3ad3a0b9606463" translate="yes" xml:space="preserve">
          <source>You can adjust the ordering of a B-tree index by including the options &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, and/or &lt;code&gt;NULLS LAST&lt;/code&gt; when creating the index; for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7d9d02889a217be36bf8f71750c721f9d62b3a" translate="yes" xml:space="preserve">
          <source>You can also control the order in which rows are processed by window functions using &lt;code&gt;ORDER BY&lt;/code&gt; within &lt;code&gt;OVER&lt;/code&gt;. (The window &lt;code&gt;ORDER BY&lt;/code&gt; does not even have to match the order in which the rows are output.) Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8031e0a82c5477e58a31c17656bff548035b193" translate="yes" xml:space="preserve">
          <source>You can also create databases with other names. PostgreSQL allows you to create any number of databases at a given site. Database names must have an alphabetic first character and are limited to 63 bytes in length. A convenient choice is to create a database with the same name as your current user name. Many tools assume that database name as the default, so it can save you some typing. To create that database, simply type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2855332ddeec7909c633615734e0f09916910215" translate="yes" xml:space="preserve">
          <source>You can also define constraints on the column at the same time, using the usual syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1e40e96d3d99c788ff89c86039beb4c7ae5ad3" translate="yes" xml:space="preserve">
          <source>You can also force the insertion of invalid numbers even when not in the weak mode, by appending the &lt;code&gt;!&lt;/code&gt; character at the end of the number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92dd9f79aa93357545022991d035db8fa3c697a" translate="yes" xml:space="preserve">
          <source>You can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0e733bb8f77339cb0554d27f0faf1999d777b7" translate="yes" xml:space="preserve">
          <source>You can also nest filter expressions within each other:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540c7cc55f43958519f25aa973c9e5a2c6dcb66b" translate="yes" xml:space="preserve">
          <source>You can also search an array using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator, which checks whether the left operand overlaps with the right operand. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7317ad78770ade20f7fc205d1692cc3871b32860" translate="yes" xml:space="preserve">
          <source>You can also search for specific values in an array using the &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt; functions. The former returns the subscript of the first occurrence of a value in an array; the latter returns an array with the subscripts of all occurrences of the value in the array. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72011efb5669336e4615ad697b69c64d57f8e812" translate="yes" xml:space="preserve">
          <source>You can also shorten the above command to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362c18912cf35df18fb18daa4743d6a04f75f78b" translate="yes" xml:space="preserve">
          <source>You can also write &lt;code&gt;all&lt;/code&gt; to match any IP address, &lt;code&gt;samehost&lt;/code&gt; to match any of the server's own IP addresses, or &lt;code&gt;samenet&lt;/code&gt; to match any address in any subnet that the server is directly connected to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81719f677a0ec0af21aab7f90315c40b111bfbd1" translate="yes" xml:space="preserve">
          <source>You can also write the table name with a trailing &lt;code&gt;*&lt;/code&gt; to explicitly specify that descendant tables are included:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5703517ac040c492127e1fb49e5ced3da0debc99" translate="yes" xml:space="preserve">
          <source>You can ask for all fields of a composite value by writing &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc07d5e0044a9e8829c097c35614fb4ad2ee919" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a foreign key constraint, in the usual way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78537f8a74bec7b625797355864a6e8b33eb27d6" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a unique constraint, in the usual way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e4029bdb8227766d867d39118fde7beadbd5eab" translate="yes" xml:space="preserve">
          <source>You can avoid always having to write out a &lt;code&gt;FROM&lt;/code&gt; clause to define the output columns, by setting up a custom crosstab function that has the desired output row type wired into its definition. This is described in the next section. Another possibility is to embed the required &lt;code&gt;FROM&lt;/code&gt; clause in a view definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564b000e3befed57b182cb04e1dbb1e1574bf5b5" translate="yes" xml:space="preserve">
          <source>You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas. Default privileges that are specified per-schema are added to whatever the global default privileges are for the particular object type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce7b82cbd1c40e5d5b3f5f38a6fd3d98a532714" translate="yes" xml:space="preserve">
          <source>You can combine these approaches by setting up logrotate to collect log files produced by PostgreSQL built-in logging collector. In this case, the logging collector defines the names and location of the log files, while logrotate periodically archives these files. When initiating log rotation, logrotate must ensure that the application sends further output to the new file. This is commonly done with a &lt;code&gt;postrotate&lt;/code&gt; script that sends a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the application, which then reopens the log file. In PostgreSQL, you can run &lt;code&gt;pg_ctl&lt;/code&gt; with the &lt;code&gt;logrotate&lt;/code&gt; option instead. When the server receives this command, the server either switches to a new log file or reopens the existing file, depending on the logging configuration (see &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Section 19.8.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0f94e4408c19791436a634fd6c150fbb5fd164" translate="yes" xml:space="preserve">
          <source>You can construct an empty array, but since it's impossible to have an array with no type, you must explicitly cast your empty array to the desired type. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769ef112866ecb5c170f43630a2adb624d294a3a" translate="yes" xml:space="preserve">
          <source>You can convert an epoch value back to a time stamp with &lt;code&gt;to_timestamp&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea1e38b69360026f2565a2133b9cc41f674fbe6" translate="yes" xml:space="preserve">
          <source>You can create a new table by specifying the table name, along with all column names and their types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2293b489a80bd69ba669dbf459fa76acfff7a213" translate="yes" xml:space="preserve">
          <source>You can create a replication slot like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3025b62033e69c38fff841b12fa1dec6f73605a" translate="yes" xml:space="preserve">
          <source>You can create predefined functions to avoid having to write out the result column names and types in each query. See the examples in the previous section. The underlying C function for this form of &lt;code&gt;crosstab&lt;/code&gt; is named &lt;code&gt;crosstab_hash&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05fb579365a5f238d0a6df67c0b79ce59d0a29c6" translate="yes" xml:space="preserve">
          <source>You can create the illusion of an updatable view by defining &lt;code&gt;ON INSERT&lt;/code&gt;, &lt;code&gt;ON UPDATE&lt;/code&gt;, and &lt;code&gt;ON DELETE&lt;/code&gt; rules (or any subset of those that's sufficient for your purposes) to replace update actions on the view with appropriate updates on other tables. If you want to support &lt;code&gt;INSERT RETURNING&lt;/code&gt; and so on, then be sure to put a suitable &lt;code&gt;RETURNING&lt;/code&gt; clause into each of these rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fd26f2da3bc0e528eb70dd91043a00be53f7e3" translate="yes" xml:space="preserve">
          <source>You can define a cast as an &lt;em&gt;I/O conversion cast&lt;/em&gt; by using the &lt;code&gt;WITH INOUT&lt;/code&gt; syntax. An I/O conversion cast is performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type. In many common cases, this feature avoids the need to write a separate cast function for conversion. An I/O conversion cast acts the same as a regular function-based cast; only the implementation is different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986b5339acb3c76e9d88ad629ad134c8af474edf" translate="yes" xml:space="preserve">
          <source>You can display tables in different ways by using the &lt;code&gt;\pset&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16683852e12279f72c19abb8cc240108de7e38a2" translate="yes" xml:space="preserve">
          <source>You can do the same thing more verbosely with an explicitly named composite type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647bf3e05906b80225fe1b4782288902652983a3" translate="yes" xml:space="preserve">
          <source>You can easily display index sizes, too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a376faf67a062024c4f071a8c440875731b4314a" translate="yes" xml:space="preserve">
          <source>You can enter this into &lt;code&gt;psql&lt;/code&gt; with the line breaks. &lt;code&gt;psql&lt;/code&gt; will recognize that the command is not terminated until the semicolon.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
