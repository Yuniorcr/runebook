<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="72ffbd722c89aeb2c836acf3f0c44afff50be407" translate="yes" xml:space="preserve">
          <source>CommentMap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75531c33f09b6698d805430cabdb3a738714d38" translate="yes" xml:space="preserve">
          <source>Comments returns the list of comment groups in the comment map. The result is sorted in source order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75dbcaa738947f57e870bbe9a0b593ed1429157b" translate="yes" xml:space="preserve">
          <source>Commit commits the transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead23952f81edf09bb71f62ad1b348959ed375c9" translate="yes" xml:space="preserve">
          <source>Common HTTP methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d67b2df02a2b0f12c80994d6833df71942c623" translate="yes" xml:space="preserve">
          <source>Common durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184f39007c639489786070aa25bca08ce4764bc0" translate="yes" xml:space="preserve">
          <source>CommonType holds elements of all types. It is a historical artifact, kept for binary compatibility and exported only for the benefit of the package's encoding of type descriptors. It is not intended for direct use by clients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd58ee3a270f3a931009900e1008d549bbd7453" translate="yes" xml:space="preserve">
          <source>Community</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41102eb4b9de6b7bae3f5e306780351400ba6cc" translate="yes" xml:space="preserve">
          <source>Compact appends to dst the JSON-encoded src with insignificant space characters elided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1b7e3488c6acd7e9ce9eb7f6b22d083ee3ad86" translate="yes" xml:space="preserve">
          <source>Comparable reports whether values of type T are comparable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d105cf44d3926289e65c1c83d8e37cb23fd049e" translate="yes" xml:space="preserve">
          <source>Compare</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87372512a9a5360900cc7c5a33b6e3e93e823d3" translate="yes" xml:space="preserve">
          <source>Compare (Search)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad63be5eee8e54dee7704f35acb0ba003f3c69ff" translate="yes" xml:space="preserve">
          <source>Compare is included only for symmetry with package bytes. It is usually clearer and always faster to use the built-in string comparison operators ==, &amp;lt;, &amp;gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80addebf328bcb3bd2c3c1645d4d89e7132d58cd" translate="yes" xml:space="preserve">
          <source>Compare returns an integer comparing two byte slices lexicographically. The result will be 0 if a==b, -1 if a &amp;lt; b, and +1 if a &amp;gt; b. A nil argument is equivalent to an empty slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df35de4203e8da0393ad78d4e9938f7d7d27e38" translate="yes" xml:space="preserve">
          <source>Compare returns an integer comparing two strings lexicographically. The result will be 0 if a==b, -1 if a &amp;lt; b, and +1 if a &amp;gt; b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e32b8f4321d2754d7b192fb3758e3b419a9f9c" translate="yes" xml:space="preserve">
          <source>Compare returns the result of the comparison x op y. The comparison must be defined for the operands. If one of the operands is Unknown, the result is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910ec23407bde52c30ee4b60de00ef973b43f80f" translate="yes" xml:space="preserve">
          <source>CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d6c43b2c49df7ae06cb50a00c7e8b8915268cf" translate="yes" xml:space="preserve">
          <source>CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d6539a495248c2ad93b44c9b160da516bc7385" translate="yes" xml:space="preserve">
          <source>CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b11a167dff4b888f467bc21d9300ca565d08f6" translate="yes" xml:space="preserve">
          <source>CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65fd9c97eea0a869d816095871991bfeac0d5f9" translate="yes" xml:space="preserve">
          <source>CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd8ad0ca49f8af09303cdda4c902f6a9b14029ce" translate="yes" xml:space="preserve">
          <source>CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e46ab4b32fa2f629f5362ccdb0c33a816b4b7aef" translate="yes" xml:space="preserve">
          <source>Compatibility: Any future changes to hash or crypto packages will endeavor to maintain compatibility with state encoded using previous versions. That is, any released versions of the packages should be able to decode data written with any previously released version, subject to issues such as security fixes. See the Go compatibility document for background: &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;https://golang.org/doc/go1compat&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954806623263eec83965435d4b03d56697b9e46d" translate="yes" xml:space="preserve">
          <source>Compatibility: Any future changes to the package will endeavor to maintain compatibility with streams encoded using previous versions. That is, any released version of this package should be able to decode data written with any previously released version, subject to issues such as security fixes. See the Go compatibility document for background: &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;https://golang.org/doc/go1compat&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0baebc95c01171c0c52e34f8d0b193a89bd2a16d" translate="yes" xml:space="preserve">
          <source>Compile compiles the regexp into a program to be executed. The regexp should have been simplified already (returned from re.Simplify).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebbdcb3f12368feddbe44f5bdd110e3044ea9e4" translate="yes" xml:space="preserve">
          <source>Compile parses a regular expression and returns, if successful, a Regexp object that can be used to match against text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee12e4c020c15df0e0265d183f5996a7256de50" translate="yes" xml:space="preserve">
          <source>CompilePOSIX is like Compile but restricts the regular expression to POSIX ERE (egrep) syntax and changes the match semantics to leftmost-longest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e03d68306e0c19856edf7366f977bbbed7ddfc9" translate="yes" xml:space="preserve">
          <source>Compiler is the name of the compiler toolchain that built the running binary. Known toolchains are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22f98d93ae817ec1259f4d4b7bb21830ff51f40" translate="yes" xml:space="preserve">
          <source>Complete computes the interface's method set. It must be called by users of NewInterfaceType and NewInterface after the interface's embedded types are fully defined and before using the interface type in any way other than to form other types. Complete returns the receiver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f7244e495625b4cee683d43e3d4155851069d0" translate="yes" xml:space="preserve">
          <source>Complex returns v's underlying value, as a complex128. It panics if v's Kind is not Complex64 or Complex128</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5c0a1accf821336b517c8f9a6d139c6eec6f93" translate="yes" xml:space="preserve">
          <source>ComplexType is here for the purposes of documentation only. It is a stand-in for either complex type: complex64 or complex128.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0393f2fc81c87a0dafffd5b2077e514e08d44e60" translate="yes" xml:space="preserve">
          <source>Composites:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6330cf629c30461620e73f64161faf03c4f6bc05" translate="yes" xml:space="preserve">
          <source>Compression methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd07f0f2be8ef65d73e0d3b0811ef58ea8daca19" translate="yes" xml:space="preserve">
          <source>Cond implements a condition variable, a rendezvous point for goroutines waiting for or announcing the occurrence of an event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d15477b0af65c5951b32f8d79c3115615594d0" translate="yes" xml:space="preserve">
          <source>Config (KeyLogWriter)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e807e5a6200a3f39396feeb57c8d54139d104a3" translate="yes" xml:space="preserve">
          <source>Config holds an image's color model and dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b74bd988d5a3ea14e1b3df314b2481dce7147bf" translate="yes" xml:space="preserve">
          <source>Conj returns the complex conjugate of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9aeb439eaab9aac64aeb1a4cefd295f624e1753" translate="yes" xml:space="preserve">
          <source>Conn is a connection to a database. It is not used concurrently by multiple goroutines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b1029621a91138c59ede0769c17c76de3d476a1" translate="yes" xml:space="preserve">
          <source>Conn is a generic stream-oriented network connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0742e4736e59fa33890eb7f9409476b2970b8342" translate="yes" xml:space="preserve">
          <source>Conn is assumed to be stateful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cb8b53c681806d63b63016497ea6a71f949b9d" translate="yes" xml:space="preserve">
          <source>Conn is implemented by some types in the net and os packages to provide access to the underlying file descriptor or handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e466ea632370cac21d90b7f4f09fae73dc2ed1" translate="yes" xml:space="preserve">
          <source>Conn represents a single database connection rather than a pool of database connections. Prefer running queries from DB unless there is a specific need for a continuous single database connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d452c612a33917a07ea957a4e2e63fa7d35e0f" translate="yes" xml:space="preserve">
          <source>Conn returns a single connection by either opening a new connection or returning an existing connection from the connection pool. Conn will block until either a connection is returned or ctx is canceled. Queries run on the same Conn will be run in the same database session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6c492eb2dd2d9a3974d02d68dfa500550dd3dd" translate="yes" xml:space="preserve">
          <source>Conn, a convenient packaging of Reader, Writer, and Pipeline for use with a single network connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85591a22c37013bf743fa31976eceaaa6316c3f2" translate="yes" xml:space="preserve">
          <source>Conn.BeginTx</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf5eb76abc574b7772bf9ab1e8c6d4fea476438" translate="yes" xml:space="preserve">
          <source>Conn.ExecContext</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c158ecf9ec2479e6846915d8cb9fe6d3cbd4ca47" translate="yes" xml:space="preserve">
          <source>ConnBeginTx enhances the Conn interface with context and TxOptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1ce7b126fb8c452695e0fb899404e6512c196b" translate="yes" xml:space="preserve">
          <source>ConnPrepareContext enhances the Conn interface with context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0a434e24a3e815d5fcde63b2103c735bf86e75" translate="yes" xml:space="preserve">
          <source>ConnectionState records basic TLS details about the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4590fa3842e170ce672f8a3f9663ce18f220b4" translate="yes" xml:space="preserve">
          <source>ConnectionState returns basic TLS details about the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3382413c31457bfa590d655f61e74261287ccc28" translate="yes" xml:space="preserve">
          <source>Constant folding computes the exact constant value (constant.Value) for every expression (ast.Expr) that is a compile-time constant. Use Info.Types[expr].Value for the results of constant folding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834dc3729f5137013cad26135140ed953b36f94d" translate="yes" xml:space="preserve">
          <source>ConstantTimeByteEq returns 1 if x == y and 0 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3558d9d7a00f451a48ef2972f41f8686803a0e24" translate="yes" xml:space="preserve">
          <source>ConstantTimeCompare returns 1 if the two slices, x and y, have equal contents and 0 otherwise. The time taken is a function of the length of the slices and is independent of the contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88c252edbf2eca3cb91bb29e951cb5ca95bae6aa" translate="yes" xml:space="preserve">
          <source>ConstantTimeCopy copies the contents of y into x (a slice of equal length) if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v takes any other value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7a225b92c492d7dc1f43d3aec5a53c49890771" translate="yes" xml:space="preserve">
          <source>ConstantTimeEq returns 1 if x == y and 0 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6cda7519c219248a0508d2822b6c702c671a99" translate="yes" xml:space="preserve">
          <source>ConstantTimeLessOrEq returns 1 if x &amp;lt;= y and 0 otherwise. Its behavior is undefined if x or y are negative or &amp;gt; 2**31 - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8097a05c2ae8e15642a918a2dfd5de0ec4d3229d" translate="yes" xml:space="preserve">
          <source>ConstantTimeSelect returns x if v == 1 and y if v == 0. Its behavior is undefined if v takes any other value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fcb5061de485a74f3977289cc41179ec8ab431f" translate="yes" xml:space="preserve">
          <source>Constants describing the Accuracy of a Float.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046dff50bc71ac1e0509d7f6f6e5ffad1fc87642" translate="yes" xml:space="preserve">
          <source>Constants to identify various tar formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555424611e16923e575afc6f5fc122e1c2a19159" translate="yes" xml:space="preserve">
          <source>ConstraintViolationError results when a requested usage is not permitted by a certificate. For example: checking a signature when the public key isn't a certificate signing key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e15d008d511f3101566a2e25203ef2a3f605a0" translate="yes" xml:space="preserve">
          <source>Contains</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e044f963947fee78187d2c8a9c3fc9f40ab582e" translate="yes" xml:space="preserve">
          <source>Contains reports whether pos is within the scope's extent. The result is guaranteed to be valid only if the type-checked AST has complete position information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b64d04b858878f66705aa586f7fa9e41fa1f23" translate="yes" xml:space="preserve">
          <source>Contains reports whether subslice is within b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e18f046f19b6a654d4cf4ca8d98e9f26e42d9b0" translate="yes" xml:space="preserve">
          <source>Contains reports whether substr is within s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6abdd6add896a729ee1aad307b9af57bdd6cad51" translate="yes" xml:space="preserve">
          <source>Contains reports whether the network includes ip.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7cae610cac616dec3e9ae05c0c03197e4d666b4" translate="yes" xml:space="preserve">
          <source>ContainsAny</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877abb973dc781a3c8fa066aa0b824607b6f8b34" translate="yes" xml:space="preserve">
          <source>ContainsAny reports whether any Unicode code points in chars are within s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6caee33a35e9d91f330ffd6a91207ad4b9338f0d" translate="yes" xml:space="preserve">
          <source>ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7debe6ccf4ad9133e2542cad231bda0c85355b" translate="yes" xml:space="preserve">
          <source>ContainsRune</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a6dc8ca3b6d8a1950b7ae7f379f764b29d9034" translate="yes" xml:space="preserve">
          <source>ContainsRune reports whether the Unicode code point r is within s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1ff477a4e2194cf3761b5cdca699f501e9f919" translate="yes" xml:space="preserve">
          <source>ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08542aeb2bfc8fbad4f388086aa29696fcb3614" translate="yes" xml:space="preserve">
          <source>Context returns the request's context. To change the context, use WithContext.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca89f9f2a2036011eb5b4d2c57c4771153bb83e" translate="yes" xml:space="preserve">
          <source>Context's methods may be called by multiple goroutines simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c161cba0ca1d50bd8851cc88a3794c809cbe6fbe" translate="yes" xml:space="preserve">
          <source>ContextClientTrace returns the ClientTrace associated with the provided context. If none, it returns nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049c25129edc0e21a3c2b9240307623c8b16b3e6" translate="yes" xml:space="preserve">
          <source>Contexts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb055ddaa6fd827855b9a19519a485e47403121" translate="yes" xml:space="preserve">
          <source>Conversion between RGB and Y'CbCr is lossy and there are multiple, slightly different formulae for converting between the two. This package follows the JFIF specification at &lt;a href=&quot;https://www.w3.org/Graphics/JPEG/jfif3.pdf&quot;&gt;https://www.w3.org/Graphics/JPEG/jfif3.pdf&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b24506d2330c3e5aaf3eed9ee049df2b2edfc2e" translate="yes" xml:space="preserve">
          <source>Conversion of a uintptr back to Pointer is not valid in general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b30242b973b465aec017dbe20811af00636e0e2" translate="yes" xml:space="preserve">
          <source>Convert returns the palette color closest to c in Euclidean R,G,B space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c65e78e2cfee0137de5015d96d98123ad8d7b4a" translate="yes" xml:space="preserve">
          <source>Convert returns the value v converted to type t. If the usual Go conversion rules do not allow conversion of the value v to type t, Convert panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60c6764e20f1ce7accef0e79715fc6de73a21bc" translate="yes" xml:space="preserve">
          <source>ConvertibleTo reports whether a value of type V is convertible to a value of type T.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483087e44afa8d5285f534d77323c3706428debe" translate="yes" xml:space="preserve">
          <source>Converting a Pointer to a uintptr produces the memory address of the value pointed at, as an integer. The usual use for such a uintptr is to print it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0018fef4e5fd6fb8ccad98bd3a6b012fe3ed5ae1" translate="yes" xml:space="preserve">
          <source>Cookie returns the named cookie provided in the request or ErrNoCookie if not found. If multiple cookies match the given name, only one cookie will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6444e3dab3b536b14d051c8ddab84942f9d59bd8" translate="yes" xml:space="preserve">
          <source>Cookies implements the Cookies method of the http.CookieJar interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26998c84ce084428cbc2c95f6c5034ef7327f4b6" translate="yes" xml:space="preserve">
          <source>Cookies parses and returns the HTTP cookies sent with the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ee61025f9549bad8b3c189b6b5351e6c5ca43e" translate="yes" xml:space="preserve">
          <source>Cookies parses and returns the cookies set in the Set-Cookie headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af74f7c5362aaee985bf8cda3dd75fc80751ce51" translate="yes" xml:space="preserve">
          <source>Copy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb7d87db9d906cbb94fdddddfd16ebd8200101e" translate="yes" xml:space="preserve">
          <source>Copy copies from src to dst until either EOF is reached on src or an error occurs. It returns the number of bytes copied and the first error encountered while copying, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0205f10e265d450db71d0231c94dcdd7ee2bcc22" translate="yes" xml:space="preserve">
          <source>Copy copies the contents of src into dst until either dst has been filled or src has been exhausted. It returns the number of elements copied. Dst and src each must have kind Slice or Array, and dst and src must have the same element type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25087d7936e391bf0bd9a9677daefa0a23fe1f1" translate="yes" xml:space="preserve">
          <source>Copy creates a new copy of CharData.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2399aedb628cc2f8d794a248d5f004528fd643" translate="yes" xml:space="preserve">
          <source>Copy creates a new copy of Comment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5521199a98d40388c239495432fdbee20e2c5e5a" translate="yes" xml:space="preserve">
          <source>Copy creates a new copy of Directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214634d191d287336b71314070bded70f76703ef" translate="yes" xml:space="preserve">
          <source>Copy creates a new copy of ProcInst.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac561e70b5c6132e566c02dab0a7d6e620b7ddf" translate="yes" xml:space="preserve">
          <source>Copy creates a new copy of StartElement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348b21aa3d99a8eb531490f0d789fa2d48407193" translate="yes" xml:space="preserve">
          <source>Copy returns a copy of the Tree. Any parsing state is discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b348613df7330d48a6b69a341a32bc0c4d80dfdd" translate="yes" xml:space="preserve">
          <source>Copy returns a new Regexp object copied from re. Calling Longest on one copy does not affect another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6ad9f4b7202c4d4aa702fa0d11e6e42c64f298" translate="yes" xml:space="preserve">
          <source>Copy sets z to x, with the same precision, rounding mode, and accuracy as x, and returns z. x is not changed even if z and x are the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c9b724b033d22904dbdaaf4685127002553b21" translate="yes" xml:space="preserve">
          <source>CopyBuffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c080972ed295a6ebb4d7b3256e9d876139134f56" translate="yes" xml:space="preserve">
          <source>CopyBuffer is identical to Copy except that it stages through the provided buffer (if one is required) rather than allocating a temporary one. If buf is nil, one is allocated; otherwise if it has zero length, CopyBuffer panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a2ca5d029e1c6970f41b82af47bb9334769ec9" translate="yes" xml:space="preserve">
          <source>CopyBytesToGo copies bytes from the Uint8Array src to dst. It returns the number of bytes copied, which will be the minimum of the lengths of src and dst. CopyBytesToGo panics if src is not an Uint8Array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="573547021c7d36d69889e15a8a5f480e4cd25fc9" translate="yes" xml:space="preserve">
          <source>CopyBytesToJS copies bytes from src to the Uint8Array dst. It returns the number of bytes copied, which will be the minimum of the lengths of src and dst. CopyBytesToJS panics if dst is not an Uint8Array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f366d8412f678e42a26af03a84764a3832b915" translate="yes" xml:space="preserve">
          <source>CopyN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13eabe7df064bd68331ec1a12076fce45e9a8949" translate="yes" xml:space="preserve">
          <source>CopyN copies n bytes (or until an error) from src to dst. It returns the number of bytes copied and the earliest error encountered while copying. On return, written == n if and only if err == nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea8264f41296a8535f3b62b02085fb7501b655e" translate="yes" xml:space="preserve">
          <source>CopyToken returns a copy of a Token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e28ad46ee857280975524037035d0acdc5ccadd" translate="yes" xml:space="preserve">
          <source>Copysign returns a value with the magnitude of x and the sign of y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b49c2102dc476ebba131d7df167779ccb26544" translate="yes" xml:space="preserve">
          <source>Cos</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17b655c0904cccb87f841850df53a8ab3c54287" translate="yes" xml:space="preserve">
          <source>Cos returns the cosine of the radian argument x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29bcf5033d335ce37060453688404db858a88c0" translate="yes" xml:space="preserve">
          <source>Cos returns the cosine of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5b1efaa30aed45f32d083d3a9f4d02f9581898" translate="yes" xml:space="preserve">
          <source>Cosh</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aea87b623bfac6726a31f524f1570268bf8bb6a" translate="yes" xml:space="preserve">
          <source>Cosh returns the hyperbolic cosine of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3751692394bf977f68d6c8a2af76f83b39dcbe23" translate="yes" xml:space="preserve">
          <source>Cot returns the cotangent of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e12969c225cc6d65e18210488acb826eba907e" translate="yes" xml:space="preserve">
          <source>Count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edea34aa8c9a40389f9082a08e14e29cd4eba14" translate="yes" xml:space="preserve">
          <source>Count counts the number of non-overlapping instances of sep in s. If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7abecb94f08682b3b62e7992cd7849a1d85d24" translate="yes" xml:space="preserve">
          <source>Count counts the number of non-overlapping instances of substr in s. If substr is an empty string, Count returns 1 + the number of Unicode code points in s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ab0173ab585bf8ee18604bba14b3111d20d350" translate="yes" xml:space="preserve">
          <source>Count returns the number of execution stacks currently in the profile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c837e82670670080ba36b5dc5750591cb43079" translate="yes" xml:space="preserve">
          <source>Cover records information about test coverage checking. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3f9c856b47a0e2f143dc72ed2fd31648da50af" translate="yes" xml:space="preserve">
          <source>CoverBlock records the coverage data for a single basic block. The fields are 1-indexed, as in an editor: The opening line of the file is number 1, for example. Columns are measured in bytes. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8612ba9657742f096cb1c88efe53acf35604d3" translate="yes" xml:space="preserve">
          <source>CoverMode reports what the test coverage mode is set to. The values are &quot;set&quot;, &quot;count&quot;, or &quot;atomic&quot;. The return value will be empty if test coverage is not enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b80d4e5292251354aefa94b883cdce6faedc160" translate="yes" xml:space="preserve">
          <source>Coverage reports the current code coverage as a fraction in the range [0, 1]. If coverage is not enabled, Coverage returns 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be357b2b552293d3974bb945edcdd3d1f19d288" translate="yes" xml:space="preserve">
          <source>Create adds a file to the zip file using the provided name. It returns a Writer to which the file contents should be written. The file contents will be compressed using the Deflate method. The name must be a relative path: it must not start with a drive letter (e.g. C:) or leading slash, and only forward slashes are allowed. To create a directory instead of a file, add a trailing slash to the name. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ad0c9c5822dfd8e33287f85e0053746b9a1d8c" translate="yes" xml:space="preserve">
          <source>Create creates or truncates the named file. If the file already exists, it is truncated. If the file does not exist, it is created with mode 0666 (before umask). If successful, methods on the returned File can be used for I/O; the associated file descriptor has mode O_RDWR. If there is an error, it will be of type *PathError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b465234e2012ae44b3245299f320c50140d6940" translate="yes" xml:space="preserve">
          <source>CreateCRL returns a DER encoded CRL, signed by this Certificate, that contains the given list of revoked certificates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8628c9b06db422c5fa609b650cab7ab2c9d7d80" translate="yes" xml:space="preserve">
          <source>CreateCertificate creates a new X.509v3 certificate based on a template. The following members of template are used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c01ccfb480001ffa3c411d49610d7de6487d44" translate="yes" xml:space="preserve">
          <source>CreateCertificateRequest creates a new certificate request based on a template. The following members of template are used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c10d1e701a1ded06204ed87d7c168c5ecc136a8" translate="yes" xml:space="preserve">
          <source>CreateFormField calls CreatePart with a header using the given field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53037004a6a76e3b70492980878a44bda2d363cb" translate="yes" xml:space="preserve">
          <source>CreateFormFile is a convenience wrapper around CreatePart. It creates a new form-data header with the provided field name and file name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1649722dbb1b219b1b7b37cdfc28c7f3c99574" translate="yes" xml:space="preserve">
          <source>CreateHeader adds a file to the zip archive using the provided FileHeader for the file metadata. Writer takes ownership of fh and may mutate its fields. The caller must not modify fh after calling CreateHeader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3285ffa2e28574fc6f309813b4ff68aff6bdde1e" translate="yes" xml:space="preserve">
          <source>CreatePart creates a new multipart section with the provided header. The body of the part should be written to the returned Writer. After calling CreatePart, any previous part may no longer be written to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a50bbc334f201429fba3c65d621a9109ba53dd" translate="yes" xml:space="preserve">
          <source>Credential holds user and group identities to be assumed by a child process started by StartProcess.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2387616d5263d298421004495f585b27c0b5f292" translate="yes" xml:space="preserve">
          <source>Crit logs a message with severity LOG_CRIT, ignoring the severity passed to New.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00b9e8f709739fdb419a61ad788ae6cd5c543db" translate="yes" xml:space="preserve">
          <source>Ctz32 counts trailing (low-order) zeroes, and if all are zero, then 32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b80f5eb281e63bbdd5e4cb006c6e407851c617" translate="yes" xml:space="preserve">
          <source>Ctz64 counts trailing (low-order) zeroes, and if all are zero, then 64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f360a645e3031852f77e3ee38c6b9e9ae5132853" translate="yes" xml:space="preserve">
          <source>Ctz8 returns the number of trailing zero bits in x; the result is 8 for x == 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186a4ac4b5e83e7a09290593db86c1ac147b44e3" translate="yes" xml:space="preserve">
          <source>Current returns the current user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046f17348f9f906b4db2ced159222fabbc9be2e8" translate="yes" xml:space="preserve">
          <source>Currently only the responder role is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc0402f7a41556c97834c86c42fb8d452886c5f" translate="yes" xml:space="preserve">
          <source>Currently plugins are only supported on Linux and macOS. Please report any issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba7859fdac5d2aff950209f094dd563445b9cf8" translate="yes" xml:space="preserve">
          <source>CurveID is the type of a TLS identifier for an elliptic curve. See &lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="446785414e4504abe5ec1c9315a5bfdfeeaa65b9" translate="yes" xml:space="preserve">
          <source>CurveParams contains the parameters of an elliptic curve and also provides a generic, non-constant time implementation of Curve.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854ee953a12f6750d2f08f38118ba7df90d83bdc" translate="yes" xml:space="preserve">
          <source>DB is a database handle representing a pool of zero or more underlying connections. It's safe for concurrent use by multiple goroutines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3438f449cf114423437931b85b59a20310743baa" translate="yes" xml:space="preserve">
          <source>DB.ExecContext</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aef1f529992ef7bd420a755b7f2a4dc07114a5a" translate="yes" xml:space="preserve">
          <source>DB.PingContext</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014f16301351fe7114ed2958ee3525ac47050c48" translate="yes" xml:space="preserve">
          <source>DB.Prepare</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1974d7b34d29bc8a688d9f9e7d5ec7d48b32785" translate="yes" xml:space="preserve">
          <source>DB.Query (MultipleResultSets)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fac6432252b873f3e946e93a10e5043368270d0" translate="yes" xml:space="preserve">
          <source>DB.QueryContext</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09ea214d64b802519f42c1121ca2d585ae10183" translate="yes" xml:space="preserve">
          <source>DB.QueryRowContext</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062f2d0e3b266bc2766487d180f93108c3093e01" translate="yes" xml:space="preserve">
          <source>DBStats contains database statistics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22c78e263cb9da0783e024b9041b95e30c3fd7e" translate="yes" xml:space="preserve">
          <source>DEFLATE is suitable for transmitting compressed data across the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af7313c68e1a507942c8bee4f518b61d590aa88" translate="yes" xml:space="preserve">
          <source>DES is cryptographically broken and should not be used for secure applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c0828ff50d909531c4a019b63724f3f819cb6e" translate="yes" xml:space="preserve">
          <source>DNSConfigError represents an error reading the machine's DNS configuration. (No longer used; kept for compatibility.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df21b6b932ef4553f314a2223c92a1fd8610f2a" translate="yes" xml:space="preserve">
          <source>DNSDoneInfo contains information about the results of a DNS lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc71ea6ab70a230a454b764448619c3ce8a1b674" translate="yes" xml:space="preserve">
          <source>DNSError represents a DNS lookup error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e565458ee90bae74c1103c0b4dba206d05e11b0c" translate="yes" xml:space="preserve">
          <source>DNSStartInfo contains information about a DNS request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1616e9afd3f1b8cb1bc3466e944671742326c0" translate="yes" xml:space="preserve">
          <source>DT_FLAGS values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9fd8102c5656418aee4dc0dab53238b17f6eec" translate="yes" xml:space="preserve">
          <source>DWARF returns the DWARF debug information for the Mach-O file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e21ef2fb7f3aeea7da384ee4026d7b21cfb109" translate="yes" xml:space="preserve">
          <source>DWARF version 4 distinguishes attribute value classes more finely than previous versions of DWARF. The reader will disambiguate coarser classes from earlier versions of DWARF into the appropriate DWARF 4 class. For example, DWARF 2 uses &quot;constant&quot; for constants as well as all types of section offsets, but the reader will canonicalize attributes in DWARF 2 files that refer to section offsets to one of the Class*Ptr classes, even though these classes were only defined in DWARF 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1c6592f23da912c4adb4e08b65b073609bb89a" translate="yes" xml:space="preserve">
          <source>Data is found in Header.Ident[EI_DATA] and Header.Data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ca24289e70a941b8b696bdff0abf87b99534a8" translate="yes" xml:space="preserve">
          <source>Data issues a DATA command to the server and returns a writer that can be used to write the mail headers and body. The caller should close the writer before calling any more methods on c. A call to Data must be preceded by one or more calls to Rcpt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93ed1b3e1e4d4276c13585e691d22da36a26d7d" translate="yes" xml:space="preserve">
          <source>Data reads and returns the contents of the ELF section. Even if the section is stored compressed in the ELF file, Data returns uncompressed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb762c577e910ca34f7f6a619fca3236b8e65a78" translate="yes" xml:space="preserve">
          <source>Data reads and returns the contents of the Mach-O section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cd1191853d4999e06b3841282ce1e62b05ad52" translate="yes" xml:space="preserve">
          <source>Data reads and returns the contents of the PE section s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d131a5630dfb89ad0914d47cac99e85517e0f18" translate="yes" xml:space="preserve">
          <source>Data reads and returns the contents of the Plan 9 a.out section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4adf3b85e43c16f7986aa10f34f35072f6eea1" translate="yes" xml:space="preserve">
          <source>Data reads and returns the contents of the segment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f79ddac999330fab22c9a79fd22e8012029e050" translate="yes" xml:space="preserve">
          <source>Data represents the DWARF debugging information loaded from an executable file (for example, an ELF or Mach-O executable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bc8adab78b04c6b3688d1e1ff626160d863530" translate="yes" xml:space="preserve">
          <source>DataErrReader changes the way errors are handled by a Reader. Normally, a Reader returns an error (typically EOF) from the first Read call after the last piece of data is read. DataErrReader wraps a Reader and changes its behavior so the final error is returned along with the final data, instead of in the first call after the final data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb9616bdfbeffc11e87fe7230443e52f6bea614" translate="yes" xml:space="preserve">
          <source>DataOffset returns the offset of the file's possibly-compressed data, relative to the beginning of the zip file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09d2f8039589d9ae6e6561e5dcd42da64f6928d" translate="yes" xml:space="preserve">
          <source>Database drivers may implement DriverContext for access to contexts and to parse the name only once for a pool of connections, instead of once per connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73570fc5828e9254e320eeb24fbd8b1ead4beb2e" translate="yes" xml:space="preserve">
          <source>DatabaseTypeName returns the database system name of the column type. If an empty string is returned the driver type name is not supported. Consult your driver documentation for a list of driver data types. Length specifiers are not included. Common type include &quot;VARCHAR&quot;, &quot;TEXT&quot;, &quot;NVARCHAR&quot;, &quot;DECIMAL&quot;, &quot;BOOL&quot;, &quot;INT&quot;, &quot;BIGINT&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9a4bc1c0c153e4e4b042a79113b815b7e3021d" translate="yes" xml:space="preserve">
          <source>Date</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159c09d3aeadb72b1f5514f38a813eb4c5b0683a" translate="yes" xml:space="preserve">
          <source>Date panics if loc is nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ae8791f875e5c0659aa843bd5208912c32d54d" translate="yes" xml:space="preserve">
          <source>Date parses the Date header field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d0982177e2a17b0a887ab4e3c2bcc10514bc3a0" translate="yes" xml:space="preserve">
          <source>Date returns the Time corresponding to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19811d3575925e21d39da4f63d5d36e7f8d5e6a6" translate="yes" xml:space="preserve">
          <source>Date returns the year, month, and day in which t occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51777aaad416543ccd0b64993945fa0970cfeed2" translate="yes" xml:space="preserve">
          <source>Day returns the day of the month specified by t.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b4ce5abf04cac4f6b56fb7b5ca2f32ee8f6950" translate="yes" xml:space="preserve">
          <source>DeadlineExceeded is the error returned by Context.Err when the context's deadline passes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00dbeaa14d4aaefd27f0b729c8572efea591c54d" translate="yes" xml:space="preserve">
          <source>Debug logs a message with severity LOG_DEBUG, ignoring the severity passed to New.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbfaca68a329233bc04528ed643e96af823c8d1" translate="yes" xml:space="preserve">
          <source>Debugging support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290f9cdf409ce3485bc3ebf61922e97b96ab6dba" translate="yes" xml:space="preserve">
          <source>DecimalSize returns the scale and precision of a decimal type. If not applicable or if not supported ok is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df50d3b937b66b95438db0baeefd22f2c1fa73b6" translate="yes" xml:space="preserve">
          <source>Decode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2191bd1edaed1f948c446e5e5051b352674263c5" translate="yes" xml:space="preserve">
          <source>Decode decodes an RFC 2047 encoded-word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c663a98c9ac4bdfaf7570d06109ce1220330af72" translate="yes" xml:space="preserve">
          <source>Decode decodes an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec- specific package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2862aea68bddc3797cc61a25b04a065153d058" translate="yes" xml:space="preserve">
          <source>Decode decodes src into DecodedLen(len(src)) bytes, returning the actual number of bytes written to dst.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9459e2df37f9d7b79d9c22b47888407d5cae69bd" translate="yes" xml:space="preserve">
          <source>Decode decodes src into dst, returning both the number of bytes written to dst and the number consumed from src. If src contains invalid ascii85 data, Decode will return the number of bytes successfully written and a CorruptInputError. Decode ignores space and control characters in src. Often, ascii85-encoded data is wrapped in &amp;lt;~ and ~&amp;gt; symbols. Decode expects these to have been stripped by the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e08a18b5e0596336160230bc4fa0088423d426" translate="yes" xml:space="preserve">
          <source>Decode decodes src using the encoding enc. It writes at most DecodedLen(len(src)) bytes to dst and returns the number of bytes written. If src contains invalid base32 data, it will return the number of bytes successfully written and CorruptInputError. New line characters (\r and \n) are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49467dca1e0d0001bc71fa1ac5e9147e30acd4c0" translate="yes" xml:space="preserve">
          <source>Decode decodes src using the encoding enc. It writes at most DecodedLen(len(src)) bytes to dst and returns the number of bytes written. If src contains invalid base64 data, it will return the number of bytes successfully written and CorruptInputError. New line characters (\r and \n) are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f1335189afa4a7c6f3ae9a3d92e18b92bfef1e8" translate="yes" xml:space="preserve">
          <source>Decode expects that src contains only hexadecimal characters and that src has even length. If the input is malformed, Decode returns the number of bytes decoded before the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800876565052483ae20792dbb4cd593c7c3b8846" translate="yes" xml:space="preserve">
          <source>Decode reads a GIF image from r and returns the first embedded image as an image.Image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbac39d9a826fbc5afe7154ac34bd2df498566b4" translate="yes" xml:space="preserve">
          <source>Decode reads a JPEG image from r and returns it as an image.Image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e54593218bc1af392b920a78974a97581bf2c1c" translate="yes" xml:space="preserve">
          <source>Decode reads a PNG image from r and returns it as an image.Image. The type of Image returned depends on the PNG contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5abcbefea9089a4ce5a4a52a242638dfec04e7" translate="yes" xml:space="preserve">
          <source>Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1df86160a0f777c4ef84d3e5e05362d86ed78c" translate="yes" xml:space="preserve">
          <source>Decode reads the next value from the input stream and stores it in the data represented by the empty interface value. If e is nil, the value will be discarded. Otherwise, the value underlying e must be a pointer to the correct type for the next data item received. If the input is at EOF, Decode returns io.EOF and does not modify e.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fe9f25ab1a2483c4e260dc7fcba6455fbea3ba" translate="yes" xml:space="preserve">
          <source>Decode returns the Unicode code point sequence represented by the UTF-16 encoding s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00520e26a1f23f03c003d00547bb432a3a235dc" translate="yes" xml:space="preserve">
          <source>Decode will find the next PEM formatted block (certificate, private key etc) in the input. It returns that block and the remainder of the input. If no PEM data is found, p is nil and the whole of the input is returned in rest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b302987dc20b61b9749892b479e69a5e336abe4" translate="yes" xml:space="preserve">
          <source>Decode works like Unmarshal, except it reads the decoder stream to find the start element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e37be960ab676eab0d765515fe1771dae55149" translate="yes" xml:space="preserve">
          <source>DecodeAll reads a GIF image from r and returns the sequential frames and timing information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e7173f24924751aa452948d7c6dfbb2edeac9e" translate="yes" xml:space="preserve">
          <source>DecodeConfig decodes the color model and dimensions of an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec-specific package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9adb0fd972eb06c032b93d684f65d570cdcabda" translate="yes" xml:space="preserve">
          <source>DecodeConfig returns the color model and dimensions of a JPEG image without decoding the entire image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a5c1fae5c349d3734ae4489d6aecc2426c5ac7" translate="yes" xml:space="preserve">
          <source>DecodeConfig returns the color model and dimensions of a PNG image without decoding the entire image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf91fca372aef697adf69e21434c0270fdba345" translate="yes" xml:space="preserve">
          <source>DecodeConfig returns the global color model and dimensions of a GIF image without decoding the entire image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1eb5cc06614fd4437a26a4a1653271c12295a5e" translate="yes" xml:space="preserve">
          <source>DecodeElement works like Unmarshal except that it takes a pointer to the start XML element to decode into v. It is useful when a client reads some raw XML tokens itself but also wants to defer to Unmarshal for some elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16713e78705fc06f8e05be74c5067eb69b310b90" translate="yes" xml:space="preserve">
          <source>DecodeHeader decodes all encoded-words of the given string. It returns an error if and only if CharsetReader of d returns an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e172ef50e9276e57b5335bf4faa51bee2741d8" translate="yes" xml:space="preserve">
          <source>DecodeLastRune</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae3ba953157b1585814d3fce39e0a50852e7948" translate="yes" xml:space="preserve">
          <source>DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc57e376dc0f134c4bfab7438a8b69c1e50c7e0" translate="yes" xml:space="preserve">
          <source>DecodeLastRuneInString</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a8169059d7047067fb3a3b04fe37855654bbaa" translate="yes" xml:space="preserve">
          <source>DecodeLastRuneInString is like DecodeLastRune but its input is a string. If s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c840a2944c7b78051c2f4d24c001bb3db7586d2" translate="yes" xml:space="preserve">
          <source>DecodeRune</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe1a4295199ea56faf52e25cbf7c1b995fb5581" translate="yes" xml:space="preserve">
          <source>DecodeRune returns the UTF-16 decoding of a surrogate pair. If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns the Unicode replacement code point U+FFFD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf3960cee32acc9ec4f47da069c9ab188d23f22" translate="yes" xml:space="preserve">
          <source>DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88cfb2ee82f7d9405832cfa50700196812107d51" translate="yes" xml:space="preserve">
          <source>DecodeRuneInString</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4647dc4c9636993df78e7b7af6c3ed7bc1b87f" translate="yes" xml:space="preserve">
          <source>DecodeRuneInString is like DecodeRune but its input is a string. If s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745e8eb6ad128aef996ff9d7b991cd3156884887" translate="yes" xml:space="preserve">
          <source>DecodeString</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2995ec38a1c149f49a43c3725e4ad8ab6ccd917" translate="yes" xml:space="preserve">
          <source>DecodeString expects that src contains only hexadecimal characters and that src has even length. If the input is malformed, DecodeString returns the bytes decoded before the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b43cb23d14fc7963d139c1d5ae99c19fcc2059" translate="yes" xml:space="preserve">
          <source>DecodeString returns the bytes represented by the base32 string s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0c084f0da6a7f9bfbaeea805ea061f148fa74e" translate="yes" xml:space="preserve">
          <source>DecodeString returns the bytes represented by the base64 string s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ca5d4a132d23d7b5bfe286e9414cf1733e1fd7" translate="yes" xml:space="preserve">
          <source>DecodeString returns the bytes represented by the hexadecimal string s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673f927f28506c494b47dc9326f68e21fe962028" translate="yes" xml:space="preserve">
          <source>DecodeValue reads the next value from the input stream. If v is the zero reflect.Value (v.Kind() == Invalid), DecodeValue discards the value. Otherwise, it stores the value into v. In that case, v must represent a non-nil pointer to data or be an assignable reflect.Value (v.CanSet()) If the input is at EOF, DecodeValue returns io.EOF and does not modify v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee37cdba307bd5c5065d5683f7caa610723e58f" translate="yes" xml:space="preserve">
          <source>DecodedLen returns the length of a decoding of x source bytes. Specifically, it returns x / 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be5f0b99888068a2482a86b50382454ef22b14f5" translate="yes" xml:space="preserve">
          <source>DecodedLen returns the maximum length in bytes of the decoded data corresponding to n bytes of base32-encoded data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6813385272ace1ce0fb064215644848699dad2c" translate="yes" xml:space="preserve">
          <source>DecodedLen returns the maximum length in bytes of the decoded data corresponding to n bytes of base64-encoded data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be2f0f143224d91c1d79bb0d11cb4d0a2c69cde" translate="yes" xml:space="preserve">
          <source>Decoder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996bd0771aab35e5131c87bd200dc9468eb01de6" translate="yes" xml:space="preserve">
          <source>Decoder.Decode (Stream)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf9a389ba774205e867958c9afe08f731ca89bb" translate="yes" xml:space="preserve">
          <source>Decoder.Token</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7ab43dcdcfcb47bfa27b64166db401a89736c7" translate="yes" xml:space="preserve">
          <source>DecodingError represents an error during the decoding of the symbol table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48dcf05d5aa284e84069d30f83d263bbffd81d4e" translate="yes" xml:space="preserve">
          <source>Decrypt decrypts ciphertext with priv. If opts is nil or of type *PKCS1v15DecryptOptions then PKCS#1 v1.5 decryption is performed. Otherwise opts must have type *OAEPOptions and OAEP decryption is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8fb78d92446f4f89c55adea7b4c51873a0fe712" translate="yes" xml:space="preserve">
          <source>DecryptOAEP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd489336e048225cfa022050936a5c58e2960d4" translate="yes" xml:space="preserve">
          <source>DecryptOAEP decrypts ciphertext using RSA-OAEP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32272700b3ba6f69208e5dfe18a0bcc77bf36bf3" translate="yes" xml:space="preserve">
          <source>DecryptPEMBlock takes a password encrypted PEM block and the password used to encrypt it and returns a slice of decrypted DER encoded bytes. It inspects the DEK-Info header to determine the algorithm used for decryption. If no DEK-Info header is present, an error is returned. If an incorrect password is detected an IncorrectPasswordError is returned. Because of deficiencies in the encrypted-PEM format, it's not always possible to detect an incorrect password. In these cases no error will be returned but the decrypted DER bytes will be random noise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ec5d72084471d9fb9aaf2dccd71a7a1ffbaa60" translate="yes" xml:space="preserve">
          <source>DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5. If rand != nil, it uses RSA blinding to avoid timing side-channel attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1723fb53bff3596074c056ebc7f6bdfb8a16cfcd" translate="yes" xml:space="preserve">
          <source>DecryptPKCS1v15SessionKey</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5034a4dbba2441d68b5bba30749025b8a62d6758" translate="yes" xml:space="preserve">
          <source>DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5. If rand != nil, it uses RSA blinding to avoid timing side-channel attacks. It returns an error if the ciphertext is the wrong length or if the ciphertext is greater than the public modulus. Otherwise, no error is returned. If the padding is valid, the resulting plaintext message is copied into key. Otherwise, key is unchanged. These alternatives occur in constant time. It is intended that the user of this function generate a random session key beforehand and continue the protocol with the resulting value. This will remove any possibility that an attacker can learn any information about the plaintext. See &amp;ldquo;Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS #1&amp;rdquo;, Daniel Bleichenbacher, Advances in Cryptology (Crypto '98).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a6dfe4c2e189c8de29f15cddcf7cf9dba25238" translate="yes" xml:space="preserve">
          <source>Decrypter is an interface for an opaque private key that can be used for asymmetric decryption operations. An example would be an RSA key kept in a hardware module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ae957644bea42b7ff65d51f99ce49cb83fd388" translate="yes" xml:space="preserve">
          <source>DeepEqual reports whether x and y are &amp;ldquo;deeply equal,&amp;rdquo; defined as follows. Two values of identical type are deeply equal if one of the following cases applies. Values of distinct types are never deeply equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88594116663c9d491607d208f07eaf0d91b8568" translate="yes" xml:space="preserve">
          <source>DefPredeclaredTestFuncs defines the assert and trace built-ins. These built-ins are intended for debugging and testing of this package only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a034168ac1ac48bea6ed331fcaa43cff83c78c4c" translate="yes" xml:space="preserve">
          <source>Default behavior of signals in Go programs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5930ff9b687f979b109248d33bd87544c6441a" translate="yes" xml:space="preserve">
          <source>Default is the default Context for builds. It uses the GOARCH, GOOS, GOROOT, and GOPATH environment variables if set, or else the compiled code's GOARCH, GOOS, and GOROOT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e5e6d9fc404c78f1caf70dbc4a96064e7c0a25" translate="yes" xml:space="preserve">
          <source>Default returns an Importer for the compiler that built the running binary. If available, the result implements types.ImporterFrom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9d9531a88729b86031d49234703db1873e5fde" translate="yes" xml:space="preserve">
          <source>Default returns the default &quot;typed&quot; type for an &quot;untyped&quot; type; it returns the incoming type for all other types. The default type for untyped nil is untyped nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32a9ab63a855b6d134feb2b19c4b8ed98d5511f" translate="yes" xml:space="preserve">
          <source>DefaultClient is the default Client and is used by Get, Head, and Post.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa23924b211ce5cb27ec1d2387da0f7a6637db67" translate="yes" xml:space="preserve">
          <source>DefaultMask returns the default IP mask for the IP address ip. Only IPv4 addresses have default masks; DefaultMask returns nil if ip is not a valid IPv4 address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e06a50030e5f43ee5b24b6931b868b3e071ca071" translate="yes" xml:space="preserve">
          <source>DefaultMaxHeaderBytes is the maximum permitted size of the headers in an HTTP request. This can be overridden by setting Server.MaxHeaderBytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636a0952f2f8473680d4e7cc7eb53279b90ac029" translate="yes" xml:space="preserve">
          <source>DefaultMaxIdleConnsPerHost is the default value of Transport's MaxIdleConnsPerHost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b44788c36bdae15408049002f004c79915e5e4d" translate="yes" xml:space="preserve">
          <source>DefaultParameterConverter is the default implementation of ValueConverter that's used when a Stmt doesn't implement ColumnConverter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eacc041065f99c81cc8f5fd899b6fc82a35c5b3" translate="yes" xml:space="preserve">
          <source>DefaultParameterConverter returns its argument directly if IsValue(arg). Otherwise, if the argument implements Valuer, its Value method is used to return a Value. As a fallback, the provided argument's underlying type is used to convert it to a Value: underlying integer types are converted to int64, floats to float64, bool, string, and []byte to themselves. If the argument is a nil pointer, ConvertValue returns a nil Value. If the argument is a non-nil pointer, it is dereferenced and ConvertValue is called recursively. Other types are an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f213734fb7e3669ea6cde1adb844c4352398832" translate="yes" xml:space="preserve">
          <source>DefaultQuality is the default quality encoding parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d9675d6a9519fefbcc46ae56e43608c28aa568" translate="yes" xml:space="preserve">
          <source>DefaultRemoteAddr is the default remote address to return in RemoteAddr if an explicit DefaultRemoteAddr isn't set on ResponseRecorder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee5c05653051c51f271a77afcb53f5d1e6c059a" translate="yes" xml:space="preserve">
          <source>DefaultResolver is the resolver used by the package-level Lookup functions and by Dialers without a specified Resolver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ebe0e1b713e364b784eb80c7a317d8d294f9a0" translate="yes" xml:space="preserve">
          <source>DefaultServeMux is the default ServeMux used by Serve.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e263e8bc5cd83dd3c4b95718e56ae0981b0cc5d2" translate="yes" xml:space="preserve">
          <source>DefaultServer is the default instance of *Server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372f5d0502fa7b598a3ec0b732f37219d19fac76" translate="yes" xml:space="preserve">
          <source>DefaultTransport is the default implementation of Transport and is used by DefaultClient. It establishes network connections as needed and caches them for reuse by subsequent calls. It uses HTTP proxies as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy) environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd8250a6d786e6fc36b7943762248db8114871c" translate="yes" xml:space="preserve">
          <source>Define flags using flag.String(), Bool(), Int(), etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59702ad1f8b86127487509bba28cce815f45cb43" translate="yes" xml:space="preserve">
          <source>DefinedTemplates returns a string listing the defined templates, prefixed by the string &quot;; defined templates are: &quot;. If there are none, it returns the empty string. For generating an error message here and in html/template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef9206feec84a2fab3e1d763ed437ba19bc8059" translate="yes" xml:space="preserve">
          <source>DefinedTemplates returns a string listing the defined templates, prefixed by the string &quot;; defined templates are: &quot;. If there are none, it returns the empty string. Used to generate an error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb57645975348dea1039fb97dc2b2b89c0be776d" translate="yes" xml:space="preserve">
          <source>Del deletes the values associated with key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857c30a3f9faee13278e31d18a439b577b3f1737" translate="yes" xml:space="preserve">
          <source>Del deletes the values associated with key. The key is case insensitive; it is canonicalized by CanonicalHeaderKey.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344d7532f4d066a3be32162f19300bafca7e706e" translate="yes" xml:space="preserve">
          <source>Delete deletes the given key from the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0084056bfddcb6daf1843876f6cd9d7b3ea00fa3" translate="yes" xml:space="preserve">
          <source>Delete deletes the value for a key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5efbe5b092d83811fac07a9464c08df78f1c725" translate="yes" xml:space="preserve">
          <source>Delims sets the action delimiters to the specified strings, to be used in subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0d4298e3ba9dd9990445a4ef4e8a6cd12c5f4f" translate="yes" xml:space="preserve">
          <source>Denom returns the denominator of x; it is always &amp;gt; 0. The result is a reference to x's denominator; it may change if a new value is assigned to x, and vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8eeb4cd02c6a77b7f55a05d7bd3c8acc59c71d" translate="yes" xml:space="preserve">
          <source>Denom returns the denominator of x; x must be Int, Float, or Unknown. If x is Unknown, or if it is too large or small to represent as a fraction, the result is Unknown. Otherwise the result is an Int &amp;gt;= 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02dfda4f203755036a797366a5e270c14beadf5b" translate="yes" xml:space="preserve">
          <source>Depending on the HTTP client software, HTTP protocol version, and any intermediaries between the client and the Go server, it may not be possible to read from the Request.Body after writing to the ResponseWriter. Cautious handlers should read the Request.Body first, and then reply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ff8b9c366b37de75e0a219f6054e295296daec" translate="yes" xml:space="preserve">
          <source>Deprecated: Drivers should implement ExecerContext instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d3a3d65ddeed121ddbee894f4a71e4f38ef5f4" translate="yes" xml:space="preserve">
          <source>Deprecated: Drivers should implement NamedValueChecker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c65d9b0a5c2499f69091385e530d0488f264354" translate="yes" xml:space="preserve">
          <source>Deprecated: Drivers should implement QueryerContext instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd55ed21fcef6e8036c179ed17978a5eb1bc511c" translate="yes" xml:space="preserve">
          <source>Deprecated: HasPrefix does not respect path boundaries and does not ignore case when required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6314119e2a70e822325ecc07d6f3bcf87fad5a" translate="yes" xml:space="preserve">
          <source>Deprecated: In earlier releases, when using a Regexp in multiple goroutines, giving each goroutine its own copy helped to avoid lock contention. As of Go 1.12, using Copy is no longer necessary to avoid lock contention. Copy may still be appropriate if the reason for its use is to make two copies with different Longest settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9637414855ddbc727fc7477deb59945461f257c8" translate="yes" xml:space="preserve">
          <source>Deprecated: No longer returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd839aca1062d0406d212ed9c29a708a99c5ae4" translate="yes" xml:space="preserve">
          <source>Deprecated: No longer used; kept for compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3790917f28a2ba29e0716702d6e5bf036726c8" translate="yes" xml:space="preserve">
          <source>Deprecated: Not all errors in the http package related to protocol errors are of type ProtocolError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490458aa5011ab7b075523616154746f03267643" translate="yes" xml:space="preserve">
          <source>Deprecated: Reader is not used by the image/jpeg package and should not be used by others. It is kept for compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58781567b2fb92c443f90638b4d662c4329af403" translate="yes" xml:space="preserve">
          <source>Deprecated: Reset can't guarantee that the key will be entirely removed from the process's memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ac2e35f199dfb76444834868effa77e8fa4427" translate="yes" xml:space="preserve">
          <source>Deprecated: Use BytePtrFromString instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51efd02191b9f71984ba76cbf148870f02e1d8c6" translate="yes" xml:space="preserve">
          <source>Deprecated: Use ByteSliceFromString instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4b3efcc65217311972673c02ffe9a5cb88dfaf" translate="yes" xml:space="preserve">
          <source>Deprecated: Use Client or Transport in package net/http instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6270f7239a09518438a88d37dad394b15480fb8" translate="yes" xml:space="preserve">
          <source>Deprecated: Use EmbeddedType which is not restricted to defined (*Named) types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc19f31fefb5069bf157150b156e0dbda6a5cff" translate="yes" xml:space="preserve">
          <source>Deprecated: Use ForCompiler, which populates a FileSet with the positions of objects created by the importer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea355e8883ce226aad79e4df0b17269bf068a57" translate="yes" xml:space="preserve">
          <source>Deprecated: Use Modified instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd51e4444ff9f93d6d490f4c8fbbe80d17a8f7ed" translate="yes" xml:space="preserve">
          <source>Deprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types to be embedded. This is necessary for interfaces that embed alias type names referring to non-defined (literal) interface types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a0a87c06d3b24ae7ba083e47038c07c1ec8a45" translate="yes" xml:space="preserve">
          <source>Deprecated: Use Request.WithContext to create a request with a cancelable context instead. CancelRequest cannot cancel HTTP/2 requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5afbed661568f02f17be5136af0d00c63dacdf0f" translate="yes" xml:space="preserve">
          <source>Deprecated: Use SlicePtrFromStrings instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9307fd6cc4683ebcdd10ed61846d3a8429d1b79d" translate="yes" xml:space="preserve">
          <source>Deprecated: Use Table's LineToPC method instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5050bfb6e04ec77adc6d71cc882c7de1e14526" translate="yes" xml:space="preserve">
          <source>Deprecated: Use Table's PCToLine method instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cf9f471d6e42edcc6f260a374bb70bfa7adebe" translate="yes" xml:space="preserve">
          <source>Deprecated: Use a literal image.Point{} instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7397111f5533c968cd65f5e2523d33d9faff03a" translate="yes" xml:space="preserve">
          <source>Deprecated: Use a literal image.Rectangle{} instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9937088a55d8dc88ef8ad92ad476b97d1a2fb40f" translate="yes" xml:space="preserve">
          <source>Deprecated: Use golang.org/x/net/bpf instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010b83223f03b61cbd0b1c78b7f4b00afcddc45f" translate="yes" xml:space="preserve">
          <source>Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0648b8785f1680a3e97220e8e055c5d37df0480e" translate="yes" xml:space="preserve">
          <source>Deprecated: Use the Client or Transport in package net/http instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53617ac7890494a0c834838f0476b520d4862ac" translate="yes" xml:space="preserve">
          <source>Deprecated: Use the Server in package net/http instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987c7abf6daadd7b7fb6e6f3bb5e77607927d16a" translate="yes" xml:space="preserve">
          <source>Deprecated: Use the runtime/pprof package, or the handlers in the net/http/pprof package, or the testing package's -test.cpuprofile flag instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5826c738c43e68ce8820a4cf4d6fa1df350e65a6" translate="yes" xml:space="preserve">
          <source>Deprecated: the CloseNotifier interface predates Go's context package. New code should use Request.Context instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2a5b2d0ed3d2503d1117d6b88d116db1a5c733" translate="yes" xml:space="preserve">
          <source>Deprecated: this package is locked down. Callers should use the corresponding package in the golang.org/x/sys repository instead. That is also where updates required by new systems or versions should be applied. See &lt;a href=&quot;https://golang.org/s/go1.4-syscall&quot;&gt;https://golang.org/s/go1.4-syscall&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f97aa680aa5a60014104f440129ac907153497" translate="yes" xml:space="preserve">
          <source>DetectContentType implements the algorithm described at &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;https://mimesniff.spec.whatwg.org/&lt;/a&gt; to determine the Content-Type of the given data. It considers at most the first 512 bytes of data. DetectContentType always returns a valid MIME type: if it cannot determine a more specific one, it returns &quot;application/octet-stream&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367a791e4c8a0aab798febfdd40fb481c8e6a937" translate="yes" xml:space="preserve">
          <source>DevNull is the name of the operating system's &amp;ldquo;null device.&amp;rdquo; On Unix-like systems, it is &quot;/dev/null&quot;; on Windows, &quot;NUL&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646a9a5d7a2127190c66269d0c3f2e8f50421ce8" translate="yes" xml:space="preserve">
          <source>Dial</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3245bf7894677b66fa0f65579149d4be55a013bd" translate="yes" xml:space="preserve">
          <source>Dial connects to a JSON-RPC server at the specified network address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c54da882e49624393be65dcafa09fa8930a181" translate="yes" xml:space="preserve">
          <source>Dial connects to an RPC server at the specified network address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8126f72193c0616ba2ad5a2d20b0d0af08ee30f4" translate="yes" xml:space="preserve">
          <source>Dial connects to the address on the named network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501b84f9fa1edcd3533366e2dba0373c80935d15" translate="yes" xml:space="preserve">
          <source>Dial connects to the given address on the given network using net.Dial and then returns a new Conn for the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23287419cc64eb396429ad69a3f427b7d7d40ed6" translate="yes" xml:space="preserve">
          <source>Dial connects to the given network address using net.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Dial interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555b7c0fb1e8bb60be8d6c97d4ce69eaf35fb532" translate="yes" xml:space="preserve">
          <source>Dial establishes a connection to a log daemon by connecting to address raddr on the specified network. Each write to the returned writer sends a log message with the facility and severity (from priority) and tag. If tag is empty, the os.Args[0] is used. If network is empty, Dial will connect to the local syslog server. Otherwise, see the documentation for net.Dial for valid values of network and raddr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916c7b288099112169b38ebc1753110c3b18e4dd" translate="yes" xml:space="preserve">
          <source>Dial returns a new Client connected to an SMTP server at addr. The addr must include a port, as in &quot;mail.example.com:smtp&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c336c24a8e7cb3e6692055b20290d453c602efca" translate="yes" xml:space="preserve">
          <source>DialContext connects to the address on the named network using the provided context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fc387cd20218ed3d2f01c35c59633f45a5f29c" translate="yes" xml:space="preserve">
          <source>DialHTTP connects to an HTTP RPC server at the specified network address listening on the default HTTP RPC path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166f35fbbfb2abc139813e788b55c8bb3893b155" translate="yes" xml:space="preserve">
          <source>DialHTTPPath connects to an HTTP RPC server at the specified network address and path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054234eb6c33ff43797ebf07806d1abf2116d2cd" translate="yes" xml:space="preserve">
          <source>DialIP acts like Dial for IP networks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f40280b1c83bdee5b7b3218861565670c7b947" translate="yes" xml:space="preserve">
          <source>DialTCP acts like Dial for TCP networks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77aaf097ede2da3e55ab000126fc5ce2b944418" translate="yes" xml:space="preserve">
          <source>DialTimeout acts like Dial but takes a timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723db5642572fd8814d20074653b8583436a95be" translate="yes" xml:space="preserve">
          <source>DialUDP acts like Dial for UDP networks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1188516daa0242a5dee9e07a8ce04b8dfddd6c9" translate="yes" xml:space="preserve">
          <source>DialUnix acts like Dial for Unix networks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d97dd8e372e50745923f0e793e9a1ea3377bd43" translate="yes" xml:space="preserve">
          <source>DialWithDialer connects to the given network address using dialer.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Any timeout or deadline given in the dialer apply to connection and TLS handshake as a whole.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d0c73b173305efd4d7c731d37276a56782e447" translate="yes" xml:space="preserve">
          <source>DialWithDialer interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5180c70f6c14847253e8a19f2d62329e26995c8f" translate="yes" xml:space="preserve">
          <source>Dim returns the maximum of x-y or 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c6b9acefa0f4f9e57b58581d5a75e315eb3f2d" translate="yes" xml:space="preserve">
          <source>Dir</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3878a27be08b90f79ff7ead675653eced9d5fc" translate="yes" xml:space="preserve">
          <source>Dir returns all but the last element of path, typically the path's directory. After dropping the final element using Split, the path is Cleaned and trailing slashes are removed. If the path is empty, Dir returns &quot;.&quot;. If the path consists entirely of slashes followed by non-slash bytes, Dir returns a single slash. In any other case, the returned path does not end in a slash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0f5615772352273bc79d68b22a60277288ae87" translate="yes" xml:space="preserve">
          <source>Dir returns all but the last element of path, typically the path's directory. After dropping the final element, Dir calls Clean on the path and trailing slashes are removed. If the path is empty, Dir returns &quot;.&quot;. If the path consists entirely of separators, Dir returns a single separator. The returned path does not end in a separator unless it is the root directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a478722b7b31bb4fb26d02a9daa9b39abbff8e70" translate="yes" xml:space="preserve">
          <source>Dir returns the direction of channel c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a5a91e72d8cd7ecd875b2fde5f18520f1865d0" translate="yes" xml:space="preserve">
          <source>DisallowUnknownFields causes the Decoder to return an error when the destination is a struct and the input contains object keys which do not match any non-ignored, exported fields in the destination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9e638c9210f5f7c0d1bf542f9e88607a9db164" translate="yes" xml:space="preserve">
          <source>Discard is an io.Writer on which all Write calls succeed without doing anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3151e5b42c76f7786c34b10ee6b91843bc323edd" translate="yes" xml:space="preserve">
          <source>Discard skips the next n bytes, returning the number of bytes discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ce0f4b9310f95ee6e03e8cc37d8051d56938ac" translate="yes" xml:space="preserve">
          <source>Discussion:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc629db1dfea7dd1d7478cd49f0d67c695a2f09" translate="yes" xml:space="preserve">
          <source>Disposal Methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec7907f27bd994c3fb8583301b913b0b6813a3a" translate="yes" xml:space="preserve">
          <source>Div returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div panics for y == 0 (division by zero) or y &amp;lt;= hi (quotient overflow).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc57c9c02ed421c232712ba11343274d994963e" translate="yes" xml:space="preserve">
          <source>Div returns the vector p/k.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="426cf990e0000e9ee258d2aab672481be1e61f9f" translate="yes" xml:space="preserve">
          <source>Div sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Div implements Euclidean division (unlike Go); see DivMod for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6969f247b499f527d10065936434631c47245711" translate="yes" xml:space="preserve">
          <source>Div32 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div32 panics for y == 0 (division by zero) or y &amp;lt;= hi (quotient overflow).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a140393f99aaa8275c3c523c2f0109eb59db32" translate="yes" xml:space="preserve">
          <source>Div64 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div64 panics for y == 0 (division by zero) or y &amp;lt;= hi (quotient overflow).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ee7e85e1219c9b6dd08a952c5d23488d8e580c" translate="yes" xml:space="preserve">
          <source>DivMod implements Euclidean division and modulus (unlike Go):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b680c8f7a354b5f639fb527648d9d63d8ccda98" translate="yes" xml:space="preserve">
          <source>DivMod sets z to the quotient x div y and m to the modulus x mod y and returns the pair (z, m) for y != 0. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421c2fc2a2b84517678db9c2f442e9b0eb047ffd" translate="yes" xml:space="preserve">
          <source>Do calls f for each entry in the map. The map is locked during the iteration, but existing entries may be concurrently updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344fdccb01551fd2cf446ded60ac44948ea45c54" translate="yes" xml:space="preserve">
          <source>Do calls f for each exported variable. The global variable map is locked during the iteration, but existing entries may be concurrently updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73df66c109e56751b22dc4bded18343160cef6a4" translate="yes" xml:space="preserve">
          <source>Do calls f with a copy of the parent context with the given labels added to the parent's label map. Goroutines spawned while executing f will inherit the augmented label-set. Each key/value pair in labels is inserted into the label map in the order provided, overriding any previous value for the same key. The augmented label map will be set for the duration of the call to f and restored once f returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59f412ffbd80005134f93bcc238950f4b573d7d" translate="yes" xml:space="preserve">
          <source>Do calls function f on each element of the ring, in forward order. The behavior of Do is undefined if f changes *r.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aae39793ad1559304a62b480983270ecdafd252" translate="yes" xml:space="preserve">
          <source>Do calls the function f if and only if Do is being called for the first time for this instance of Once. In other words, given</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc83ea5ac46597554232c0c42033d14a7416d33" translate="yes" xml:space="preserve">
          <source>Do is convenience method that writes a request and reads a response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ae63c0144eed839424d121a195436a02591450" translate="yes" xml:space="preserve">
          <source>Do is intended for initialization that must be run exactly once. Since f is niladic, it may be necessary to use a function literal to capture the arguments to a function to be invoked by Do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171db7265264382a4470c716c800cfeaf865b910" translate="yes" xml:space="preserve">
          <source>Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403473243ae753314d3e7c6e5efb971fec3919ed" translate="yes" xml:space="preserve">
          <source>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7779aca2e90b3ef06e0e59e88b36b9294187c5a" translate="yes" xml:space="preserve">
          <source>Do sends an HTTP request and returns an HTTP response, following policy (such as redirects, cookies, auth) as configured on the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a040ce848c0973a1eaf2705fea9e3c16c10f29" translate="yes" xml:space="preserve">
          <source>Done decrements the WaitGroup counter by one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8a8a3c5fe2e401e493c36ab14b008c0145b4a3" translate="yes" xml:space="preserve">
          <source>Dot encoding is a common framing used for data blocks in text protocols such as SMTP. The data consists of a sequence of lines, each of which ends in &quot;\r\n&quot;. The sequence itself ends at a line containing just a dot: &quot;.\r\n&quot;. Lines beginning with a dot are escaped with an additional dot to avoid looking like the end of the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa5cb276f9495e5d4c9e33568c4e7fe494cb1c1" translate="yes" xml:space="preserve">
          <source>DotNode holds the special identifier '.'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d81c0de8e57188c73733729e426e2cc8e21bc9" translate="yes" xml:space="preserve">
          <source>DotReader returns a new Reader that satisfies Reads using the decoded text of a dot-encoded block read from r. The returned Reader is only valid until the next call to a method on r.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f12978969ba09aae6377b8a8b1e656b9e301cf7" translate="yes" xml:space="preserve">
          <source>DotWriter returns a writer that can be used to write a dot-encoding to w. It takes care of inserting leading dots when necessary, translating line-ending \n into \r\n, and adding the final .\r\n line when the DotWriter is closed. The caller should close the DotWriter before the next call to a method on w.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34df04156d8c13982c47017e9978f653e9f12cc7" translate="yes" xml:space="preserve">
          <source>Draw calls DrawMask with a nil mask.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5e532be0920a0453cdc54d04b9169084ccdf0e" translate="yes" xml:space="preserve">
          <source>Draw implements the Drawer interface by calling the Draw function with this Op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095366335bb273e4a2ea61cb6fd7f32f8d19f685" translate="yes" xml:space="preserve">
          <source>DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r in dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69353508254d7fc67f1bc0d561821973e8541c4b" translate="yes" xml:space="preserve">
          <source>Drawer (FloydSteinberg)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8253364d6d713de9b550787176c132b382c33930" translate="yes" xml:space="preserve">
          <source>Drawer contains the Draw method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca04bd4da9fe0c03ee57c4703ae1e82be8d6e722" translate="yes" xml:space="preserve">
          <source>Driver is the interface that must be implemented by a database driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f645d42b5568aea825206b8e697ea66dab57c60" translate="yes" xml:space="preserve">
          <source>Driver returns the database's underlying driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a00d50aef5aea9e2710b9f36a21127df22306c7" translate="yes" xml:space="preserve">
          <source>Drivers returns a sorted list of the names of the registered drivers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abae0c55704de2aa26c34322b4e8c275aa1bc7c" translate="yes" xml:space="preserve">
          <source>Drivers that do not support context cancellation will not return until after the query is completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d218c02974bb1de20e1d664e3a90526498d120" translate="yes" xml:space="preserve">
          <source>Dump</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1efe71a094bc514414a290528c9e86553e7520b4" translate="yes" xml:space="preserve">
          <source>Dump returns a string that contains a hex dump of the given data. The format of the hex dump matches the output of `hexdump -C` on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b283785980f70b0d4303b4bc4c441375213c3f" translate="yes" xml:space="preserve">
          <source>DumpRequest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de7dbfc307f5235c1d6b683c171950e7f1ffd23" translate="yes" xml:space="preserve">
          <source>DumpRequest returns the given request in its HTTP/1.x wire representation. It should only be used by servers to debug client requests. The returned representation is an approximation only; some details of the initial request are lost while parsing it into an http.Request. In particular, the order and case of header field names are lost. The order of values in multi-valued headers is kept intact. HTTP/2 requests are dumped in HTTP/1.x form, not in their original binary representations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8617a69fd95544d86b25db256370774190ace264" translate="yes" xml:space="preserve">
          <source>DumpRequestOut</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f5ce4e85d9829f54cc4eca908b5ee3db848cc0" translate="yes" xml:space="preserve">
          <source>DumpRequestOut is like DumpRequest but for outgoing client requests. It includes any headers that the standard http.Transport adds, such as User-Agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab002c74edbf53a695bff854b73691ee5ff49db" translate="yes" xml:space="preserve">
          <source>DumpResponse</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5cb2fa3b185da1849224df819e33e22048bed0a" translate="yes" xml:space="preserve">
          <source>DumpResponse is like DumpRequest but dumps a response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6f5764b6bb205859885185dfc165c84ecff79a" translate="yes" xml:space="preserve">
          <source>Dumper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d77075aac1401c0e2be5db28c0ababd2d200f0f" translate="yes" xml:space="preserve">
          <source>Dumper returns a WriteCloser that writes a hex dump of all written data to w. The format of the dump matches the output of `hexdump -C` on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1370004da76fa4f3b7a5180fd5436065ef4c7d5b" translate="yes" xml:space="preserve">
          <source>Duration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d39bc61f4df92670a47d7dbb0340a26919244359" translate="yes" xml:space="preserve">
          <source>Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5195f3e65af1376bff8d2aff52391b3e64e72714" translate="yes" xml:space="preserve">
          <source>Duration flags accept any input valid for time.ParseDuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5d634713acf3a5ece781c540b83969479fdedd" translate="yes" xml:space="preserve">
          <source>Duration.Hours</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767678f246489f2d369059f5a4e433ba83f27dc4" translate="yes" xml:space="preserve">
          <source>Duration.Minutes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15796e7613718dc9316e8a9259c9d1872dc9d2c5" translate="yes" xml:space="preserve">
          <source>Duration.Nanoseconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1621f40b95946ff6207b9c656512e487ad66ce32" translate="yes" xml:space="preserve">
          <source>Duration.Round</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6557fa3a9db485bd65efba25bd2fc6fec3d0de9b" translate="yes" xml:space="preserve">
          <source>Duration.Seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f06d8a52e2242c2cad632dade4de2fcd473e3a" translate="yes" xml:space="preserve">
          <source>Duration.String</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565c13e1bc7186cba22a3e856369e0913d16cff5" translate="yes" xml:space="preserve">
          <source>Duration.Truncate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a5653f95d5c0243363897afbc01308538ab04d" translate="yes" xml:space="preserve">
          <source>DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96fcaca56da697a54efbf68b6f544825c513abfd" translate="yes" xml:space="preserve">
          <source>During a particular build, the following words are satisfied:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfb7cfcb687419a46176f2be1f3191cd5d7b4b4" translate="yes" xml:space="preserve">
          <source>During execution functions are found in two function maps: first in the template, then in the global function map. By default, no functions are defined in the template but the Funcs method can be used to add them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df0b06929972c9b30315986c52f79ebdf35f7e8" translate="yes" xml:space="preserve">
          <source>Dx returns r's width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41c6da4d6741acc126c0422196933be598f6153" translate="yes" xml:space="preserve">
          <source>Dy returns r's height.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b6bc7918b98bfd40dd37e996810216132462b9" translate="yes" xml:space="preserve">
          <source>Dyn.Tag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5222f10256a08491c36be3639e64bc2ebff12623" translate="yes" xml:space="preserve">
          <source>DynString returns the strings listed for the given tag in the file's dynamic section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db202bdad98e296b9a3563abcfa107dc6f7dc00b" translate="yes" xml:space="preserve">
          <source>DynamicSymbols returns the dynamic symbol table for f. The symbols will be listed in the order they appear in f.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c378c0dd0f7970369ff718ef4a5dbb0ea2f5ff7" translate="yes" xml:space="preserve">
          <source>ELF32 Compression header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9805c8c21043a51a02b54b3aeec72a98f35ab90" translate="yes" xml:space="preserve">
          <source>ELF32 Dynamic structure. The &quot;.dynamic&quot; section contains an array of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01cfc9c73c1836df918dbdb1ff394e536b5e750e" translate="yes" xml:space="preserve">
          <source>ELF32 File header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95b78b9e8d26713e54bc7d6dbf4a94c300ad3cc" translate="yes" xml:space="preserve">
          <source>ELF32 Program header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2562dbbf0dcee0f2e54eb9f48338f7def8b4bbc4" translate="yes" xml:space="preserve">
          <source>ELF32 Relocations that don't need an addend field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794563b14439e28188bc640bdadb9bb63d680d95" translate="yes" xml:space="preserve">
          <source>ELF32 Relocations that need an addend field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd616263209dd900d196fadf9047398dfd2521b2" translate="yes" xml:space="preserve">
          <source>ELF32 Section header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8a6d1fbb884fcd546a737b6627f180033dfe18" translate="yes" xml:space="preserve">
          <source>ELF32 Symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e34cade68c612b8b31a15c7b0be30ee7d2c449" translate="yes" xml:space="preserve">
          <source>ELF64 Compression header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bff0b09a1d753cf9e7269a9f278d58013217bfa" translate="yes" xml:space="preserve">
          <source>ELF64 Dynamic structure. The &quot;.dynamic&quot; section contains an array of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53643c180d85eb5f05c20f66f7443ee9f9d2d90" translate="yes" xml:space="preserve">
          <source>ELF64 Program header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53dc77020d82faf2a8fb56ce571eac7a4c406fd" translate="yes" xml:space="preserve">
          <source>ELF64 Section header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b38ac0b54bc34aaae042028741c36e4940cce07" translate="yes" xml:space="preserve">
          <source>ELF64 file header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429907c0b3e6b47962dd713a0f45efbc999d98d2" translate="yes" xml:space="preserve">
          <source>ELF64 relocations that don't need an addend field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6ddbd3dc62aa9dd229b61e1dbcf4930eb356c0" translate="yes" xml:space="preserve">
          <source>ELF64 relocations that need an addend field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8185d8c0b42b58b3e2cb27fd3b6a714d1ecb3d6b" translate="yes" xml:space="preserve">
          <source>ELF64 symbol table entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ef067c48898a4eb1b2ec281361b9d7232d849b" translate="yes" xml:space="preserve">
          <source>EOF is the error returned by Read when no more input is available. Functions should return EOF only to signal a graceful end of input. If the EOF occurs unexpectedly in a structured data stream, the appropriate error is either ErrUnexpectedEOF or some other error giving more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b211da674bf7d5d2d22532b4017302669c9ac7" translate="yes" xml:space="preserve">
          <source>Each Cond has an associated Locker L (often a *Mutex or *RWMutex), which must be held when changing the condition and when calling the Wait method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ce2a7553dfc359fede4c116e264e25c2fea211" translate="yes" xml:space="preserve">
          <source>Each Float value also has a precision, rounding mode, and accuracy. The precision is the maximum number of mantissa bits available to represent the value. The rounding mode specifies how a result should be rounded to fit into the mantissa bits, and accuracy describes the rounding error with respect to the exact result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22b6da18b15dfcb152711437d1c5b6b668025fa" translate="yes" xml:space="preserve">
          <source>Each Profile has a unique name. A few profiles are predefined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27822f6c94a0fc0349a0c96e70c540078b10e05" translate="yes" xml:space="preserve">
          <source>Each Time has associated with it a Location, consulted when computing the presentation form of the time, such as in the Format, Hour, and Year methods. The methods Local, UTC, and In return a Time with a specific location. Changing the location in this way changes only the presentation; it does not change the instant in time being denoted and therefore does not affect the computations described in earlier paragraphs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b4e64eee2924ca83b54ba5d82d34968349afb6" translate="yes" xml:space="preserve">
          <source>Each directory listed in the Go path must have a prescribed structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a47e0b159e036354bb03ab8fec410aa5efbc37" translate="yes" xml:space="preserve">
          <source>Each span of unindented non-blank lines is converted into a single paragraph. There is one exception to the rule: a span that consists of a single line, is followed by another paragraph span, begins with a capital letter, and contains no punctuation other than parentheses and commas is formatted as a heading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b283319794ff9f90a2b889c357e1eadff02062" translate="yes" xml:space="preserve">
          <source>Each subtest and sub-benchmark has a unique name: the combination of the name of the top-level test and the sequence of names passed to Run, separated by slashes, with an optional trailing sequence number for disambiguation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64692308609e7cd9aa6b965c0976bf09ca797d9" translate="yes" xml:space="preserve">
          <source>Each template is named by a string specified when it is created. Also, each template is associated with zero or more other templates that it may invoke by name; such associations are transitive and form a name space of templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe068281c7912e37aff13438f1165b9cae6281c" translate="yes" xml:space="preserve">
          <source>Each write is written to each listed writer, one at a time. If a listed writer returns an error, that overall write operation stops and returns the error; it does not continue down the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fea9dce2cfc1e5514afba8c4f79122c1f6660c7" translate="yes" xml:space="preserve">
          <source>Edge cases for s and sep (for example, empty strings) are handled as described in the documentation for Split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37e08f3d79b0b879d0cbc05f9e597346cc0a476" translate="yes" xml:space="preserve">
          <source>Edge cases for s and sep (for example, empty strings) are handled as described in the documentation for SplitAfter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b526e2f1b563d78f9affc599c0f080c53c3770" translate="yes" xml:space="preserve">
          <source>Elem returns element type of array a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8688004f9a6c08c6f8b553e5f27b9522194baf" translate="yes" xml:space="preserve">
          <source>Elem returns the element type for the given pointer p.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8af3898701d186c1b2aa25d7c01ba7a6c647ba" translate="yes" xml:space="preserve">
          <source>Elem returns the element type of channel c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06df7045855a339d28ddf7bceaed3a18eca395ea" translate="yes" xml:space="preserve">
          <source>Elem returns the element type of map m.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9476b48442b612f54821e3019f01f37bd352c7" translate="yes" xml:space="preserve">
          <source>Elem returns the element type of slice s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3b30426371820daeb94800f4f247d67b378492" translate="yes" xml:space="preserve">
          <source>Elem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not Interface or Ptr. It returns the zero Value if v is nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362386365af358238b7934a96826d937830ebf3a" translate="yes" xml:space="preserve">
          <source>Element is an element of a linked list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d304236b20204aaee01a3be7e8fa030c924f00d" translate="yes" xml:space="preserve">
          <source>Elements omitted from the value are assumed to be zero or, when zero is impossible, one, so parsing &quot;3:04pm&quot; returns the time corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is 0, this time is before the zero Time). Years must be in the range 0000..9999. The day of the week is checked for syntax but it is otherwise ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714dc931f98b9f53a323ada665f744f785f104e3" translate="yes" xml:space="preserve">
          <source>Embedded reports whether the variable is an embedded field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a91fd75faca93aa3f92e6209ae4a04b05729483" translate="yes" xml:space="preserve">
          <source>Embedded returns the i'th embedded defined (*Named) type of interface t for 0 &amp;lt;= i &amp;lt; t.NumEmbeddeds(). The result is nil if the i'th embedded type is not a defined type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad1755ca44b573afbc8198d2b54e334f6a6b246" translate="yes" xml:space="preserve">
          <source>EmbeddedType returns the i'th embedded type of interface t for 0 &amp;lt;= i &amp;lt; t.NumEmbeddeds().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbca94fd7fa6bc879ff012dca165d33cc17634f8" translate="yes" xml:space="preserve">
          <source>Emerg logs a message with severity LOG_EMERG, ignoring the severity passed to New.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208dc8efabe1038228cedca52f60b871bf5c8251" translate="yes" xml:space="preserve">
          <source>Empty reports whether t is the empty interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6164cdafbad9c2d77fab44868057e1a865dab256" translate="yes" xml:space="preserve">
          <source>Empty reports whether the rectangle contains no points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1a82640541370ae1891158035802a1ac918358" translate="yes" xml:space="preserve">
          <source>Empty strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0a04a02a4b36d462dfbd7a50f1ba95ab97db02" translate="yes" xml:space="preserve">
          <source>EmptyOpContext returns the zero-width assertions satisfied at the position between the runes r1 and r2. Passing r1 == -1 indicates that the position is at the beginning of the text. Passing r2 == -1 indicates that the position is at the end of the text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782e817cf07d938d62f7f0517e130f19ec6b4cf1" translate="yes" xml:space="preserve">
          <source>Encode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28107c7a586749b6433a5733b287757fb842042a" translate="yes" xml:space="preserve">
          <source>Encode calls Flush before returning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8075b5e09ea3f63f78c89a2ddc490859d0c31bf8" translate="yes" xml:space="preserve">
          <source>Encode encodes src into EncodedLen(len(src)) bytes of dst. As a convenience, it returns the number of bytes written to dst, but this value is always EncodedLen(len(src)). Encode implements hexadecimal encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad1f060c6238760ff000a670071a44f8806160b" translate="yes" xml:space="preserve">
          <source>Encode encodes src into at most MaxEncodedLen(len(src)) bytes of dst, returning the actual number of bytes written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb047c3c3d4f31e4290959040afdbcc1d45c6483" translate="yes" xml:space="preserve">
          <source>Encode encodes src using the encoding enc, writing EncodedLen(len(src)) bytes to dst.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37cb8fb5926768be9ba7db2b847e6b4f7e61df93" translate="yes" xml:space="preserve">
          <source>Encode encodes the values into &amp;ldquo;URL encoded&amp;rdquo; form (&quot;bar=baz&amp;amp;foo=quux&quot;) sorted by key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cacdbbc19179ef246a49e3b221538113b7b2aea" translate="yes" xml:space="preserve">
          <source>Encode returns the UTF-16 encoding of the Unicode code point sequence s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e733c09d68cd91421a4d1814d8e874c9b899a79" translate="yes" xml:space="preserve">
          <source>Encode returns the encoded-word form of s. If s is ASCII without special characters, it is returned unchanged. The provided charset is the IANA charset name of s. It is case insensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb435f969670ff1e290f4a330dd20e7ada06128c" translate="yes" xml:space="preserve">
          <source>Encode transmits the data item represented by the empty interface value, guaranteeing that all necessary type information has been transmitted first. Passing a nil pointer to Encoder will panic, as they cannot be transmitted by gob.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82052ebc621525b1a00e64a785a78506cb678614" translate="yes" xml:space="preserve">
          <source>Encode writes the Image m to w in GIF format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c9bfb263c03b8e0db64db584d5ef43161f60ee" translate="yes" xml:space="preserve">
          <source>Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given options. Default parameters are used if a nil *Options is passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b163cff27e48e422e82d5a5f5dd2edfa89cd1991" translate="yes" xml:space="preserve">
          <source>Encode writes the Image m to w in PNG format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5cbca07b15679a333d2f3c1093e760dc8fed50b" translate="yes" xml:space="preserve">
          <source>Encode writes the Image m to w in PNG format. Any Image may be encoded, but images that are not image.NRGBA might be encoded lossily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c8d80de5513517293c9312bce84a60a51e18c30" translate="yes" xml:space="preserve">
          <source>Encode writes the JSON encoding of v to the stream, followed by a newline character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3431bd1ddef07774c0075a0d8cf7cdb745dd66d0" translate="yes" xml:space="preserve">
          <source>Encode writes the PEM encoding of b to out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc285ed2b0a9eba61cc91978b1228dfe4899cae1" translate="yes" xml:space="preserve">
          <source>Encode writes the XML encoding of v to the stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1290fb5a5c4f28124f4f2167306908f4b7e3cd0b" translate="yes" xml:space="preserve">
          <source>EncodeAll writes the images in g to w in GIF format with the given loop count and delay between frames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1901b308e73262ddff5a1580f7534a541e698b" translate="yes" xml:space="preserve">
          <source>EncodeElement calls Flush before returning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c581857a42291416b5012a1bfc65819fabcce520" translate="yes" xml:space="preserve">
          <source>EncodeElement writes the XML encoding of v to the stream, using start as the outermost tag in the encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab51517ca16e7a4e5eb7b8d3ac937d2b26f7b298" translate="yes" xml:space="preserve">
          <source>EncodeRune</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f528704d795134046c2e2331ad94b8db1da56a1" translate="yes" xml:space="preserve">
          <source>EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune. If the rune is not a valid Unicode code point or does not need encoding, EncodeRune returns U+FFFD, U+FFFD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8221ae44d390e63454c4282bd9104822f9a4df9" translate="yes" xml:space="preserve">
          <source>EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune. It returns the number of bytes written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5fe709be23ce3bc5ba98960e96ced13416a04d" translate="yes" xml:space="preserve">
          <source>EncodeToMemory returns the PEM encoding of b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324c8a3fb19979327232b44bb8a31c381b37697d" translate="yes" xml:space="preserve">
          <source>EncodeToString</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfcea8813ae6722c184e6e06a17982d9d632f08" translate="yes" xml:space="preserve">
          <source>EncodeToString returns the base32 encoding of src.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc135cc3be76ce5df9e8fd7f905545938abd518" translate="yes" xml:space="preserve">
          <source>EncodeToString returns the base64 encoding of src.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3843839ed2a2f00b8aef2ea4e6ecf9c9ab4e04b" translate="yes" xml:space="preserve">
          <source>EncodeToString returns the hexadecimal encoding of src.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19fcb6484006494d394978f1704e4ed9b4f5539f" translate="yes" xml:space="preserve">
          <source>EncodeToken allows writing a ProcInst with Target set to &quot;xml&quot; only as the first token in the stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c85b7ab7de6f179653955c1c25494b973fd6239" translate="yes" xml:space="preserve">
          <source>EncodeToken does not call Flush, because usually it is part of a larger operation such as Encode or EncodeElement (or a custom Marshaler's MarshalXML invoked during those), and those will call Flush when finished. Callers that create an Encoder and then invoke EncodeToken directly, without using Encode or EncodeElement, need to call Flush when finished to ensure that the XML is written to the underlying writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05059e24e38c8fd05c7837bf618707c5627060c0" translate="yes" xml:space="preserve">
          <source>EncodeToken writes the given XML token to the stream. It returns an error if StartElement and EndElement tokens are not properly matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0947a3c8c9b8bcd8c44bdd10335e323cd1ea461b" translate="yes" xml:space="preserve">
          <source>EncodeValue transmits the data item represented by the reflection value, guaranteeing that all necessary type information has been transmitted first. Passing a nil pointer to EncodeValue will panic, as they cannot be transmitted by gob.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854b241316ad3d39a8ee266c3a44ddee623c1784" translate="yes" xml:space="preserve">
          <source>EncodedLen returns the length in bytes of the base32 encoding of an input buffer of length n.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4f417b33e58db9c0c31f29eff4ddd8669f0b97" translate="yes" xml:space="preserve">
          <source>EncodedLen returns the length in bytes of the base64 encoding of an input buffer of length n.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485a353fee0c882183777b5b5993044af3a1bc75" translate="yes" xml:space="preserve">
          <source>EncodedLen returns the length of an encoding of n source bytes. Specifically, it returns n * 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dca2524a7e133f2714375c509deec12458fd552" translate="yes" xml:space="preserve">
          <source>Encoder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7ddfe809165179e7cd2edadb5a1ced8b769f0f" translate="yes" xml:space="preserve">
          <source>Encoder configures encoding PNG images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea245bab86e7e7cf2fd8d813fc2e95cb74506589" translate="yes" xml:space="preserve">
          <source>EncoderBuffer holds the buffers used for encoding PNG images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc95babeebbbdab367284399ffa521502bf0828" translate="yes" xml:space="preserve">
          <source>EncoderBufferPool is an interface for getting and returning temporary instances of the EncoderBuffer struct. This can be used to reuse buffers when encoding multiple images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2226a4e1fe15dc87148f967dace15e6586e72c4" translate="yes" xml:space="preserve">
          <source>Encoding Details</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca66aaccc75b682fb570d9fde3184c72d629e9c" translate="yes" xml:space="preserve">
          <source>Encoding.DecodeString</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="614b34c455deb2c2a0b4963d69801751d69a4b89" translate="yes" xml:space="preserve">
          <source>Encoding.EncodeToString</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321539e50d8c1a12cfc511582d9e7c710284774f" translate="yes" xml:space="preserve">
          <source>EncryptOAEP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf129deb5a96b559ca75907380b4d67e23a7c95" translate="yes" xml:space="preserve">
          <source>EncryptOAEP encrypts the given message with RSA-OAEP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b690d741feab568e68ed01d4029afb22005c9ca" translate="yes" xml:space="preserve">
          <source>EncryptPEMBlock returns a PEM block of the specified type holding the given DER-encoded data encrypted with the specified algorithm and password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e11b5091381ca592414c841e33cc24a6a12dbfc" translate="yes" xml:space="preserve">
          <source>EncryptPKCS1v15 encrypts the given message with RSA and the padding scheme from PKCS#1 v1.5. The message must be no longer than the length of the public modulus minus 11 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67f8660b6ee6f64ee979595238eebbe3f14e32b1" translate="yes" xml:space="preserve">
          <source>End marks the end of the operation represented by the Task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb51238ae16cda9710b593b0fe1c30e79e170be" translate="yes" xml:space="preserve">
          <source>End marks the end of the traced code region.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4f40a6a53acbe4c60d207d7edd5710b46ca090" translate="yes" xml:space="preserve">
          <source>End returns the corresponding XML end element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1740f46ed43f406a6103daf9f32866a26a80d41" translate="yes" xml:space="preserve">
          <source>EndRequest notifies p that the request with the given id has been sent (or, if this is a server, received).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2e995a27065f521aa0378954a6196f51dbb39f" translate="yes" xml:space="preserve">
          <source>EndResponse notifies p that the response with the given id has been received (or, if this is a server, sent).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fffc0a3145721a08d65aaabc9b277262428177" translate="yes" xml:space="preserve">
          <source>Entry returns the entry address of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68f172a7016b7818d2dab5107eab4fa604b31d7" translate="yes" xml:space="preserve">
          <source>Environ returns a copy of strings representing the environment, in the form &quot;key=value&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045f71994ee68b9a868e51f44a880e8642e83557" translate="yes" xml:space="preserve">
          <source>Eq reports whether p and q are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d543b9a23b302f4f4fb69164e3e63071f6ee7f20" translate="yes" xml:space="preserve">
          <source>Eq reports whether r and s contain the same set of points. All empty rectangles are considered equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a472ce8d19d10484177dabb05deb4ee299058a0c" translate="yes" xml:space="preserve">
          <source>Equal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d008b976622977894ad1256a169eda07f451f5cf" translate="yes" xml:space="preserve">
          <source>Equal compares two MACs for equality without leaking timing information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26406bd3b947d0c8a8751c20420b77c92f9cfb01" translate="yes" xml:space="preserve">
          <source>Equal reports whether a and b are the same length and contain the same bytes. A nil argument is equivalent to an empty slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9338a726f14837219e3f0b5160e801035363d7a6" translate="yes" xml:space="preserve">
          <source>Equal reports whether ip and x are the same IP address. An IPv4 address and that same address in IPv6 form are considered to be equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e236086365a108f382942e0e763834a0bce968eb" translate="yes" xml:space="preserve">
          <source>Equal reports whether oi and other represent the same identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1871b89edc21087f0c972b71d0af0383183bbc" translate="yes" xml:space="preserve">
          <source>Equal reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 CEST and 4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of using == with Time values; most code should use Equal instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901b20b6e47f8875259f27573f49fab5bbd14942" translate="yes" xml:space="preserve">
          <source>Equal reports whether x and y have identical structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acbd072fc0cea3dbceb299edaa5f0267951a317" translate="yes" xml:space="preserve">
          <source>EqualFold</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3cf184644e462de0ae310758745d4172f640f1" translate="yes" xml:space="preserve">
          <source>EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under Unicode case-folding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45c873903030f443476751c44e9df07e6be3d31" translate="yes" xml:space="preserve">
          <source>Erf returns the error function of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0699badf2b941a080ee739ed6ea1875f351847" translate="yes" xml:space="preserve">
          <source>Erfc returns the complementary error function of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18bdc77cc7ccf01894d60882c01638586652a838" translate="yes" xml:space="preserve">
          <source>Erfcinv returns the inverse of Erfc(x).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7f9017bf886c8e3d8bef46625d5e9ffc1f9661" translate="yes" xml:space="preserve">
          <source>Erfinv returns the inverse error function of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd9ef49ac603b471db58d8995717ed1a3762d907" translate="yes" xml:space="preserve">
          <source>Err logs a message with severity LOG_ERR, ignoring the severity passed to New.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5578cd7bcdf826276ecb1f2f28645e2bbb50359e" translate="yes" xml:space="preserve">
          <source>Err returns an error equivalent to this error list. If the list is empty, Err returns nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832f241be017d872e00d3180f6d33f40fd5570e6" translate="yes" xml:space="preserve">
          <source>Err returns the error, if any, that was encountered during iteration. Err may be called after an explicit or implicit Close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4df7d7cbdf62192ee825ad1260a51e02a37a319" translate="yes" xml:space="preserve">
          <source>Err returns the first non-EOF error that was encountered by the Scanner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c28ecb0558af18edf16f6cdb309e8e1c3a8d97" translate="yes" xml:space="preserve">
          <source>ErrAbortHandler is a sentinel panic value to abort a handler. While any panic from ServeHTTP aborts the response to the client, panicking with ErrAbortHandler also suppresses logging of a stack trace to the server's error log.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c93b5da38ab3884dabe8401ec5789cf9954b24e" translate="yes" xml:space="preserve">
          <source>ErrBadConn should be returned by a driver to signal to the sql package that a driver.Conn is in a bad state (such as the server having earlier closed the connection) and the sql package should retry on a new connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b44f0681b8df29aaf90b891286d09878a539aa" translate="yes" xml:space="preserve">
          <source>ErrBadPattern indicates a pattern was malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee1109d6fff6aa1a95dd2ace67b7df2a7334ba3" translate="yes" xml:space="preserve">
          <source>ErrBodyReadAfterClose is returned when reading a Request or Response Body after the body has been closed. This typically happens when the body is read after an HTTP Handler calls WriteHeader or Write on its ResponseWriter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162a55fce73b60c104f7cc8f11a8072e1ddfd29f" translate="yes" xml:space="preserve">
          <source>ErrClosedPipe is the error used for read or write operations on a closed pipe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4639f7f94b9cb5f412fc7548161f523a7e7f666" translate="yes" xml:space="preserve">
          <source>ErrConnClosed is returned by Read when a handler attempts to read the body of a request after the connection to the web server has been closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221637ad516409a2ecb2517d32f79d74a258bc09" translate="yes" xml:space="preserve">
          <source>ErrConnDone is returned by any operation that is performed on a connection that has already been returned to the connection pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bfe6cb80875e0ea2a181d7f7d549f4d0d82aed" translate="yes" xml:space="preserve">
          <source>ErrDecryption represents a failure to decrypt a message. It is deliberately vague to avoid adaptive attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467746adad5f690d7f559fbcf7439e5e4f657411" translate="yes" xml:space="preserve">
          <source>ErrFinalToken is a special sentinel error value. It is intended to be returned by a Split function to indicate that the token being delivered with the error is the last token and scanning should stop after this one. After ErrFinalToken is received by Scan, scanning stops with no error. The value is useful to stop processing early or when it is necessary to deliver a final empty token. One could achieve the same behavior with a custom error value but providing one here is tidier. See the emptyFinalToken example for a use of this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35aae77fc96792e0a9dd68b7fe9b4104a92752c1" translate="yes" xml:space="preserve">
          <source>ErrFormat indicates that decoding encountered an unknown format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8939df51dea8dd69540b21d1442b1df7f644f5" translate="yes" xml:space="preserve">
          <source>ErrHandlerTimeout is returned on ResponseWriter Write calls in handlers which have timed out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1683829261143c7257662e5011cf7aaa6a67fd8d" translate="yes" xml:space="preserve">
          <source>ErrHelp is the error returned if the -help or -h flag is invoked but no such flag is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477f520a57de43c26991dd9257c5ef86e299cbab" translate="yes" xml:space="preserve">
          <source>ErrInvalidMediaParameter is returned by ParseMediaType if the media type value was found but there was an error parsing the optional parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ccacb88c4d1c0e333f4ecd81bc1d3d9c559f2b7" translate="yes" xml:space="preserve">
          <source>ErrInvalidPublicKey results when a public key is not usable by this code. FIPS is quite strict about the format of DSA keys, but other code may be less so. Thus, when using keys which may have been generated by other code, this error must be handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88a127fa27de6b24dcaf66add63be95ef25d2bc" translate="yes" xml:space="preserve">
          <source>ErrLength reports an attempt to decode an odd-length input using Decode or DecodeString. The stream-based Decoder returns io.ErrUnexpectedEOF instead of ErrLength.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c0b0fa96d60cc99b6dbc86bf7d89c3ad78d6c6" translate="yes" xml:space="preserve">
          <source>ErrLineTooLong is returned when reading malformed chunked data with lines that are too long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcde473ed62f7785c3bf6c7d17ee1b065b625a36" translate="yes" xml:space="preserve">
          <source>ErrLineTooLong is returned when reading request or response bodies with malformed chunked encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970c2996a4a5c886310565be53697c5b45faa359" translate="yes" xml:space="preserve">
          <source>ErrMessageTooLarge is returned by ReadForm if the message form data is too large to be processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ebd73e79cdedfe1cacf57c19778bb47d85fc59f" translate="yes" xml:space="preserve">
          <source>ErrMessageTooLong is returned when attempting to encrypt a message which is too large for the size of the public key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f19c673f1a254310103a3c25dcfcd25e3b0451a" translate="yes" xml:space="preserve">
          <source>ErrMissingFile is returned by FormFile when the provided file field name is either not present in the request or not a file field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879d59d2bd412781a3e7f8ffb1ed3e0a6f25ef0a" translate="yes" xml:space="preserve">
          <source>ErrNoCookie is returned by Request's Cookie method when a cookie is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a1cf815e40b87d0d5f8fcbbe42eafeab4e1e2f" translate="yes" xml:space="preserve">
          <source>ErrNoLocation is returned by Response's Location method when no Location header is present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6beea860c8a1449ccac135d4acb1d55a17d0f093" translate="yes" xml:space="preserve">
          <source>ErrNoProgress is returned by some clients of an io.Reader when many calls to Read have failed to return any data or error, usually the sign of a broken io.Reader implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392e43865d190f068ab972465b9d359af1b64f08" translate="yes" xml:space="preserve">
          <source>ErrNoRows is returned by Scan when QueryRow doesn't return a row. In such a case, QueryRow returns a placeholder *Row value that defers this error until a Scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488229e1ec35b45cf4ccfde5a62d823f94c24690" translate="yes" xml:space="preserve">
          <source>ErrNoSymbols is returned by File.Symbols and File.DynamicSymbols if there is no such section in the File.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7533ee8d0b68fb55e112826d6a1c2915f2123d1c" translate="yes" xml:space="preserve">
          <source>ErrNotFat is returned from NewFatFile or OpenFat when the file is not a universal binary but may be a thin binary, based on its magic number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8869522b92bbf57b0f1c062434e0c2d23cc0b5" translate="yes" xml:space="preserve">
          <source>ErrNotFound is the error resulting if a path search failed to find an executable file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a111d069dccbba2d2a3a237c054d532919f96c" translate="yes" xml:space="preserve">
          <source>ErrRange indicates that a value is out of range for the target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fcce22c0e1998899b62846f27fda0ba160dd35" translate="yes" xml:space="preserve">
          <source>ErrRemoveArgument may be returned from NamedValueChecker to instruct the sql package to not pass the argument to the driver query interface. Return when accepting query specific options or structures that aren't SQL query arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037e83f30e9892945c577cf7fa14541b33afb5a6" translate="yes" xml:space="preserve">
          <source>ErrRequestAborted is returned by Read when a handler attempts to read the body of a request that has been aborted by the web server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70ae4f2182147bf876f436b7f75c0552f6c6b60" translate="yes" xml:space="preserve">
          <source>ErrServerClosed is returned by the Server's Serve, ServeTLS, ListenAndServe, and ListenAndServeTLS methods after a call to Shutdown or Close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ebe2c84541d847b1195492aec2d9b2f7a4c010e" translate="yes" xml:space="preserve">
          <source>ErrShortBuffer means that a read required a longer buffer than was provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982fdbcbb882e9752207ac23622fa80a8e4ff13c" translate="yes" xml:space="preserve">
          <source>ErrShortWrite means that a write accepted fewer bytes than requested but failed to return an explicit error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e693fa44dc23f2e964c4c957cddff0c6c414e4de" translate="yes" xml:space="preserve">
          <source>ErrSkip may be returned by some optional interfaces' methods to indicate at runtime that the fast path is unavailable and the sql package should continue as if the optional interface was not implemented. ErrSkip is only supported where explicitly documented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9be2949ec46b11aafe4f6565a64184a6259c6a" translate="yes" xml:space="preserve">
          <source>ErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0984c259498693b4323da793215e73f865780771" translate="yes" xml:space="preserve">
          <source>ErrSyntax indicates that a value does not have the right syntax for the target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e2bf17148743cd6ab904b3de93ecbe65b459aa" translate="yes" xml:space="preserve">
          <source>ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568c0d2bb32eccd175defcb03344b9a16c508bab" translate="yes" xml:space="preserve">
          <source>ErrTxDone is returned by any operation that is performed on a transaction that has already been committed or rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f229a1dfc7838f7986b848144af2ffc585c4245" translate="yes" xml:space="preserve">
          <source>ErrUnexpectedEOF means that EOF was encountered in the middle of reading a fixed-size block or data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe4f94706eef4c62e93268b91a8df4ee481c805" translate="yes" xml:space="preserve">
          <source>ErrUnknownPC is the error returned by LineReader.ScanPC when the seek PC is not covered by any entry in the line table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ccd127227d246ff29c38b3be735853002e0e90" translate="yes" xml:space="preserve">
          <source>ErrUnsupportedAlgorithm results from attempting to perform an operation that involves algorithms that are not currently implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cda7d2974e4a55a6e31e7b06730353820c8cd09" translate="yes" xml:space="preserve">
          <source>ErrUseLastResponse can be returned by Client.CheckRedirect hooks to control how redirects are processed. If returned, the next request is not sent and the most recent response is returned with its body unclosed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71263e34d33b79a9329c92364062be99c3eee17e" translate="yes" xml:space="preserve">
          <source>ErrVerification represents a failure to verify a signature. It is deliberately vague to avoid adaptive attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8d01914ee372bf834727e843061ee1afe40a5a" translate="yes" xml:space="preserve">
          <source>Error describes a problem encountered during template Escaping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e74398cca4fe010a9f1160a55d2897886f3d1e9" translate="yes" xml:space="preserve">
          <source>Error implements the error interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90eef0a8fff1769f0f058ec32118067d335eaa54" translate="yes" xml:space="preserve">
          <source>Error is equivalent to Log followed by Fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f32ee8831e87a9144a1603a0333481dce77381" translate="yes" xml:space="preserve">
          <source>Error is returned by LookPath when it fails to classify a file as an executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db662ec10d72905a869274d663c6b1180e4b7f54" translate="yes" xml:space="preserve">
          <source>Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20fb2871b74c1de6e727401f6fd828785f1c240" translate="yes" xml:space="preserve">
          <source>Error reports an error and the operation and URL that caused it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830c2e692ebb0efc91ade52379d7380987d0d567" translate="yes" xml:space="preserve">
          <source>Error reports any error that has occurred during a previous Write or Flush.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde0e5cd72639f435d3e7e7fe156ee2ed9879da4" translate="yes" xml:space="preserve">
          <source>Error returns an error string formatted as follows: filename:line:column: message</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfee321593df904c4289a896a7927d4777c6a34" translate="yes" xml:space="preserve">
          <source>Error returns the string representation of a ParseError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4df304fede26c34b36b8acbaaecd004589ae2b8" translate="yes" xml:space="preserve">
          <source>Error wraps a JavaScript error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17edc5bbb79fd1e93107557c864f6c73e9e1224" translate="yes" xml:space="preserve">
          <source>Error, which represents a numeric error response from a server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f872a6e0e103dae88045f618b47fc615ea682e89" translate="yes" xml:space="preserve">
          <source>ErrorCode is a code for a kind of error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bfa44b797d3ade2b7a4edbc0e05cd336b90f6a5" translate="yes" xml:space="preserve">
          <source>ErrorContext returns a textual representation of the location of the node in the input text. The receiver is only used when the node does not have a pointer to the tree inside, which can occur in old code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a6e986d714bdcbd3255e42cd49913ead495f07" translate="yes" xml:space="preserve">
          <source>ErrorHandling defines how FlagSet.Parse behaves if the parse fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a58bb2b918c9b5569f8008794279639061de21" translate="yes" xml:space="preserve">
          <source>ErrorHandling returns the error handling behavior of the flag set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c21e41d45c9255229a7163ff53874920a784296" translate="yes" xml:space="preserve">
          <source>ErrorList implements the sort Interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf56558c66e9c3ca353563d687f7c3cd65731f27" translate="yes" xml:space="preserve">
          <source>ErrorList is a list of *Errors. The zero value for an ErrorList is an empty ErrorList ready to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0231916da28ea14cfedf1872fc204b2ae63815" translate="yes" xml:space="preserve">
          <source>Errorf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd0d6f0778f1bf5d95080356d64d20bdae12d81" translate="yes" xml:space="preserve">
          <source>Errorf formats according to a format specifier and returns the string as a value that satisfies error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7da546253e843f1211156126fe7b9153417337c" translate="yes" xml:space="preserve">
          <source>Errorf is equivalent to Logf followed by Fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b5ebe0a47f4e9da35a4772302352a81e9e531f" translate="yes" xml:space="preserve">
          <source>Errors returned by Scanner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4101c3209c725e09b7f9a752ff1e460a3f708b" translate="yes" xml:space="preserve">
          <source>Errors returned from this package may be tested against these errors with errors.Is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a52e06ca8bcf58f3e4f4015d46888503fa4edb2" translate="yes" xml:space="preserve">
          <source>Errors used by the HTTP server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b113dd3f232b8b88d2860ca5e8f37a70242825e5" translate="yes" xml:space="preserve">
          <source>Escape is like EscapeText but omits the error return value. It is provided for backwards compatibility with Go 1.0. Code targeting Go 1.1 or later should use EscapeText.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b96ac1177bd0ab8e6a9ffb4c48e44560500452" translate="yes" xml:space="preserve">
          <source>Escape sequences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7232262c5c0c1b2288a34e3da1ce712bfb760b49" translate="yes" xml:space="preserve">
          <source>EscapeString</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a32d6d4d267bdae71baa4ebb4864da534840bc0" translate="yes" xml:space="preserve">
          <source>EscapeString escapes special characters like &quot;&amp;lt;&quot; to become &quot;&amp;amp;lt;&quot;. It escapes only five such characters: &amp;lt;, &amp;gt;, &amp;amp;, ' and &quot;. UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d03f838319f2b58cce7d4023faf3595f32ebc4a" translate="yes" xml:space="preserve">
          <source>EscapeText writes to w the properly escaped XML equivalent of the plain text data s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16488cf3f3e8d2bcd7180af8373e57e18ef4565" translate="yes" xml:space="preserve">
          <source>EscapedPath returns the escaped form of u.Path. In general there are multiple possible escaped forms of any path. EscapedPath returns u.RawPath when it is a valid escaping of u.Path. Otherwise EscapedPath ignores u.RawPath and computes an escaped form on its own. The String and RequestURI methods use EscapedPath to construct their results. In general, code should call EscapedPath instead of reading u.RawPath directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f139cba9287a2764afe8ce53317ff229147fba" translate="yes" xml:space="preserve">
          <source>Eval returns the type and, if constant, the value for the expression expr, evaluated at position pos of package pkg, which must have been derived from type-checking an AST with complete position information relative to the provided file set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87826c86d178d2561f85e648340af0f4ea8c5e2c" translate="yes" xml:space="preserve">
          <source>EvalSymlinks returns the path name after the evaluation of any symbolic links. If path is relative the result will be relative to the current directory, unless one of the components is an absolute symbolic link. EvalSymlinks calls Clean on the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74e7ce3c8abf4b80ec56864d1aae4c5480b2b01" translate="yes" xml:space="preserve">
          <source>Even if ReadAt returns n &amp;lt; len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, ReadAt blocks until either all the data is available or an error occurs. In this respect ReadAt is different from Read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a0efcd9116915108429249f6aa89cdbb04bf0f" translate="yes" xml:space="preserve">
          <source>Even when enabled, the server may not change its identity between handshakes (i.e. the leaf certificate must be the same). Additionally, concurrent handshake and application data flow is not permitted so renegotiation can only be used with protocols that synchronise with the renegotiation, such as HTTPS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5018b93eece7f2c1a96b6ceca3400cc6e309bc" translate="yes" xml:space="preserve">
          <source>Every Conn must be returned to the database pool after use by calling Conn.Close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28d71b80a20b83e9ae50e1509e418c92187dbf4" translate="yes" xml:space="preserve">
          <source>Every call to Scan, even the first one, must be preceded by a call to Next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5af771da8b361a4e20bdb4283e0ac7caf8c0814" translate="yes" xml:space="preserve">
          <source>Example (AllSignals)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6806ae76e866d9ef5bbaa313ab8f14edf232f6fa" translate="yes" xml:space="preserve">
          <source>Example (Append)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e52ba657e1b1589c7457e9586b538cbfb8d8c4e" translate="yes" xml:space="preserve">
          <source>Example (Autoescaping)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bda2f591e5fdf06e6bb949dbf8645e95567d697" translate="yes" xml:space="preserve">
          <source>Example (Basic)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18996c4947f797f81043a2613612654fc43160d3" translate="yes" xml:space="preserve">
          <source>Example (BinaryMarshaler)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b588f9f28576812b88bb06ca68e301889fa949" translate="yes" xml:space="preserve">
          <source>Example (Block)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486a8544d68d11f1bed88d4bb0fdc87e371d41c9" translate="yes" xml:space="preserve">
          <source>Example (ComplexNumbers)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="433e8e80995b40ab0d35f03a174da56c17e5e244" translate="yes" xml:space="preserve">
          <source>Example (Config)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37ffa9f063e6d5deddd48321eb1adc9ceaf4696" translate="yes" xml:space="preserve">
          <source>Example (Custom)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd768f1c2d0eb858e6c8e62318f88b0d2a37a94" translate="yes" xml:space="preserve">
          <source>Example (CustomMarshalJSON)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd803477953d919a56abf6a7054c61d8b4903e9" translate="yes" xml:space="preserve">
          <source>Example (CustomMarshalXML)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7e7661a541a8aedff29b426a0dd8cee77d6d26" translate="yes" xml:space="preserve">
          <source>Example (DecodeConfig)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5285988ca0c88d03cdaaaa1c0ed6f2b7317d2b93" translate="yes" xml:space="preserve">
          <source>Example (Decrypt)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fab16bc38953ce26f6b67557a190e125af0e87e" translate="yes" xml:space="preserve">
          <source>Example (DescendingOrder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aecf1f00d18e968d03c6704bef266c1e4be5098" translate="yes" xml:space="preserve">
          <source>Example (Dictionary)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae255c02ba68cd1a00c21d5947bde15712ef6e0" translate="yes" xml:space="preserve">
          <source>Example (DotFileHiding)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9d6fa89cbf924c21d5a93c189431a8cd1dde68" translate="yes" xml:space="preserve">
          <source>Example (EConvergents)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4faca1b381d29b5f4b6ce88f79758aa6cf95bb8" translate="yes" xml:space="preserve">
          <source>Example (Elastic)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2232d3397afd70f4f6faa419a87bb103725a6b36" translate="yes" xml:space="preserve">
          <source>Example (EmptyFinalToken)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b210ff3c89e11d54a69e7bd9044e45171fa6c7" translate="yes" xml:space="preserve">
          <source>Example (EncodeDecode)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f49227bc5c8828198ffe23c70506a5f6a14a6c" translate="yes" xml:space="preserve">
          <source>Example (Encrypt)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b7ef7af49d199e71d1b9a202304c0e1dd03579" translate="yes" xml:space="preserve">
          <source>Example (Environment)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e13d7110768fb2adda2eab178cd24782e70e9f" translate="yes" xml:space="preserve">
          <source>Example (Errorf)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda6c202ca36dceb2b8b1d371c82caea78806bb1" translate="yes" xml:space="preserve">
          <source>Example (Escape)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5078acaa6d91c20f1a5940604b3be21cb88297f" translate="yes" xml:space="preserve">
          <source>Example (Fibonacci)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82dc50226403d5da3e74bc047330883ad45a5d00" translate="yes" xml:space="preserve">
          <source>Example (File)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3933078451957ce04020c47152b2a4ae30e2df1" translate="yes" xml:space="preserve">
          <source>Example (FloydSteinberg)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d329cbb08482151d8388b6f96dc57574cc5a00" translate="yes" xml:space="preserve">
          <source>Example (Formats)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e4af16c19b828060331cd71f3957538f43c01d" translate="yes" xml:space="preserve">
          <source>Example (Func)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1803da930d85a7a40a33aabbb44bda9fd29a3f1" translate="yes" xml:space="preserve">
          <source>Example (Get)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa53360ab365a081c7d8e5c13b9d92b709140dc" translate="yes" xml:space="preserve">
          <source>Example (Glob)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0927fdc649164da429d59c70828557b2f212892" translate="yes" xml:space="preserve">
          <source>Example (Helpers)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1cb4393a3dce67d491085d8c93e591a037aa410" translate="yes" xml:space="preserve">
          <source>Example (HttpServer)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc877cc87aa7e57c6e4d6bac364478fe54fd7edc" translate="yes" xml:space="preserve">
          <source>Example (IntHeap)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ea46b6e1ae2d0c7afa15e89076c2e1ef33cfa9" translate="yes" xml:space="preserve">
          <source>Example (Interface)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d4f4103b1fb18ad85139309cb4da67e48bc81b" translate="yes" xml:space="preserve">
          <source>Example (Is)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fafb22a01b61327379ae19ec71339a55898fd95a" translate="yes" xml:space="preserve">
          <source>Example (IsIdentRune)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c67c38b6ae2ba0542052e51c7fa5202c83f63ad" translate="yes" xml:space="preserve">
          <source>Example (KeyLogWriter)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998c85b7ec2d08d9dc6fbaeea75396700152f3e2" translate="yes" xml:space="preserve">
          <source>Example (Lines)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c6690a74615337a8d95f6ad9e2df85db4dc8aa" translate="yes" xml:space="preserve">
          <source>Example (Marshal)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7987a90c2edd7b9efbeddd99750be769396ba11" translate="yes" xml:space="preserve">
          <source>Example (Minimal)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220dbd2f9c761374b94c2985ffb67973ec244f5e" translate="yes" xml:space="preserve">
          <source>Example (Mode)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71eaa954d5eaf1e8a901ae6af51e6ef38075023b" translate="yes" xml:space="preserve">
          <source>Example (Multi)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d3242dd03f86b89326a2d3af5d45c9e4b8df60" translate="yes" xml:space="preserve">
          <source>Example (MultipleResultSets)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67ff39099c16f9727841f2b1d55d6a7d937ca63" translate="yes" xml:space="preserve">
          <source>Example (OpenDBCLI)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6649fceda9c8f47bc7fd24801bfc5e3a67a4b690" translate="yes" xml:space="preserve">
          <source>Example (OpenDBService)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c804c1a3dde5f5d5992fdc8708de4fc1ac6587eb" translate="yes" xml:space="preserve">
          <source>Example (Options)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bcf50c51e83b6b841682aca36a2d5adaab448fa" translate="yes" xml:space="preserve">
          <source>Example (Parsefiles)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31a14315872f7d5ad4b31b0b814af75bcd37346" translate="yes" xml:space="preserve">
          <source>Example (Printers)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76286390b82f9465aa1db504336b58a0882e7789" translate="yes" xml:space="preserve">
          <source>Example (PriorityQueue)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c31a2d546e425660696075602e9c55ede932f9" translate="yes" xml:space="preserve">
          <source>Example (Put)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b68d9bdb509763e088e0d350491fe1ff9bf03c" translate="yes" xml:space="preserve">
          <source>Example (Rand)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2979c4537d222cfc623fbc541e78e448137665" translate="yes" xml:space="preserve">
          <source>Example (ReadMostly)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e59e19171ce2c63c7a8904bd2f9921fb22a142" translate="yes" xml:space="preserve">
          <source>Example (Reader)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d966a83ff5b0a8a61283590badb1a431bd7d77" translate="yes" xml:space="preserve">
          <source>Example (Reset)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b91d630287948e0bfeba35eefba5c01f1107af" translate="yes" xml:space="preserve">
          <source>Example (RetrievePositionInfo)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d421c1f51583522754be7b57506ff4663194c40" translate="yes" xml:space="preserve">
          <source>Example (Roundtrip)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="997ee2d41b2c768a3ff8dd1b07a7450ed4680d2e" translate="yes" xml:space="preserve">
          <source>Example (Search)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c8d95221bd62d1c6dd0e843baad8cbebaa0442" translate="yes" xml:space="preserve">
          <source>Example (Share)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3abb8dfd074ee9afbe60f6cdd246feccb1d11c79" translate="yes" xml:space="preserve">
          <source>Example (Shift)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4341e44bdeed6e7db74742550dcb962bdc52498" translate="yes" xml:space="preserve">
          <source>Example (SlicesInUnison)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b2fe12f7c6e61ddb30325458425fd3d42ba3e7" translate="yes" xml:space="preserve">
          <source>Example (SortKeys)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a161b3dcacaf6f0af657412f43ec2e2697b4a566" translate="yes" xml:space="preserve">
          <source>Example (SortMultiKeys)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c700c72cd356078aa83dc80aa5da8bd42f5ee825" translate="yes" xml:space="preserve">
          <source>Example (SortWrapper)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8bfb7061aa11f61ba7f0066df210a3c29777f98" translate="yes" xml:space="preserve">
          <source>Example (Sqrt2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe403bbbdd2c63efdc5a9bb1601bc9f45a978c6" translate="yes" xml:space="preserve">
          <source>Example (Stream)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbe3138d0178ab55ff211013783fb8af592cb7d" translate="yes" xml:space="preserve">
          <source>Example (StripPrefix)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c16b94480edd0345910083abc5a6c549ce236af" translate="yes" xml:space="preserve">
          <source>Example (Suffix)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15caef05f8ff9c74dc0547060823c024dc99f58" translate="yes" xml:space="preserve">
          <source>Example (Synchronization)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a62f50ab20b1bf896520eb1f4cc5a1db4ed324b5" translate="yes" xml:space="preserve">
          <source>Example (TextMarshalJSON)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd08593ac14b413e0da05c752b1367b5127acc2" translate="yes" xml:space="preserve">
          <source>Example (TextMarshalXML)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5dd403c2a724dfe512bb193bca762b97020dce" translate="yes" xml:space="preserve">
          <source>Example (Trailers)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748d838b8683a8f8d192b01d4d7d3a81f783d636" translate="yes" xml:space="preserve">
          <source>Example (TrailingTab)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00eeea2ab162f08ebf0ba7ecdde22954780f472" translate="yes" xml:space="preserve">
          <source>Example (Unmarshal)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abde4525b91ff7ce0bef5c781d4706ee97ee0b8" translate="yes" xml:space="preserve">
          <source>Example (Whitespace)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbda3fcec0c984c4deccac6441b82d6551be8728" translate="yes" xml:space="preserve">
          <source>Example (Words)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5cf5e438485427250b065bf74fba906e865dd71" translate="yes" xml:space="preserve">
          <source>Example (WriterReader)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30cd049e881e721a3e90310e35fd42bd393ca0d" translate="yes" xml:space="preserve">
          <source>Example demonstrates the use of the trace package to trace the execution of a Go program. The trace output will be written to the file trace.out</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2573490205ec3fa3c52174ceabc13d098ee040e" translate="yes" xml:space="preserve">
          <source>Example functions without output comments are compiled but not executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f9d603e16f8ef16b61cb7dd71733745d6dc774" translate="yes" xml:space="preserve">
          <source>Example use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f8f48cf4d5e9a2b5fdf509e391d114af54249a" translate="yes" xml:space="preserve">
          <source>ExampleExp computes Euler's identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ef84e4017d4e3a3b6e6f5fb063732f932d208e" translate="yes" xml:space="preserve">
          <source>ExampleInfo prints various facts recorded by the type checker in a types.Info struct: definitions of and references to each named object, and the type, value, and mode of every expression in the package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4bbe727d61b7f53c2e2ee56f081e85812a2931" translate="yes" xml:space="preserve">
          <source>ExampleMethodSet prints the method sets of various types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46027e906ab7b86a83cef5107b917049326109ed" translate="yes" xml:space="preserve">
          <source>ExampleMultiKeys demonstrates a technique for sorting a struct type using different sets of multiple fields in the comparison. We chain together &quot;Less&quot; functions, each of which compares a single field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193e8ade5e79f30df0f3c6123d817327cd4b8cce" translate="yes" xml:space="preserve">
          <source>ExampleScope prints the tree of Scopes of a package created from a set of parsed files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c65e0caab54f4a2e226c019adde6010c7ba6016" translate="yes" xml:space="preserve">
          <source>ExampleSortKeys demonstrates a technique for sorting a struct type using programmable sort criteria.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f8a2b98443a4dd938fd26ea0bb96b2061a1486" translate="yes" xml:space="preserve">
          <source>Examples of struct field tags and their meanings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3868550c47675aee1b65322c0a530356bac93476" translate="yes" xml:space="preserve">
          <source>Examples returns the examples found in the files, sorted by Name field. The Order fields record the order in which the examples were encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2139b5f270ff75a838ef994f1a7c0702593e500d" translate="yes" xml:space="preserve">
          <source>Except for reading the body, handlers should not modify the provided Request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d972e775d3ec8bbf70216136812cfc2aa6c6c1f2" translate="yes" xml:space="preserve">
          <source>Except when printed using the verbs %T and %p, special formatting considerations apply for operands that implement certain interfaces. In order of application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663fbbe8a5ab797134d5a3e798a619fc2b622e8a" translate="yes" xml:space="preserve">
          <source>Exec executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e416ff8481c94b506d5f1d3e462de40111511e" translate="yes" xml:space="preserve">
          <source>Exec executes a query that doesn't return rows. For example: an INSERT and UPDATE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c42d65910e9f7b2f5399cc46977eb6b49601aa" translate="yes" xml:space="preserve">
          <source>Exec executes a query without returning any rows. The args are for any placeholder parameters in the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b4576f203991257daca46f8ba57ce5bc9b1e71" translate="yes" xml:space="preserve">
          <source>Exec invokes the execve(2) system call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74f4301002ea9d1c1563f1fa536de299c417471" translate="yes" xml:space="preserve">
          <source>Exec may return ErrSkip.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b927a0c4f27f7c2245dd620e36187bf80c3d0e50" translate="yes" xml:space="preserve">
          <source>ExecContext executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0bd4f3ae9832eb93898d324b87a29a1346fa77" translate="yes" xml:space="preserve">
          <source>ExecContext executes a query that doesn't return rows. For example: an INSERT and UPDATE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcecac057ade8a549a93af9d19f63ed3d3a1e5e8" translate="yes" xml:space="preserve">
          <source>ExecContext executes a query without returning any rows. The args are for any placeholder parameters in the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28385547a6dc992edbb21722af7149817bf1e882" translate="yes" xml:space="preserve">
          <source>ExecError is the custom error type returned when Execute has an error evaluating its template. (If a write error occurs, the actual error is returned; it will not be of type ExecError.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8cd14bc64afac06caa8a1276637b7f9488463ea" translate="yes" xml:space="preserve">
          <source>Execer is an optional interface that may be implemented by a Conn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1ff5cf4051fbd8da0a29e75b0f05215a476e06" translate="yes" xml:space="preserve">
          <source>ExecerContext is an optional interface that may be implemented by a Conn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3be90db73ae31f1fa874b8e8b95f6320af4ec1" translate="yes" xml:space="preserve">
          <source>ExecerContext may return ErrSkip.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="116fbe2364a9d887fc69eaade708bc7fe63a456c" translate="yes" xml:space="preserve">
          <source>ExecerContext must honor the context timeout and return when the context is canceled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b13379f2972a85ae6473933a27341217bb8895b" translate="yes" xml:space="preserve">
          <source>Executable is not supported on nacl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ae4cbb34da99d02173a7dcb28dd93c5dce7f5d" translate="yes" xml:space="preserve">
          <source>Executable returns an absolute path unless an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adec63f8f562d73a545ecff88acb5d043aea120d" translate="yes" xml:space="preserve">
          <source>Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, path/filepath.EvalSymlinks might help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7294a8cb458c8e65f536967bf6b4d79b8c096c55" translate="yes" xml:space="preserve">
          <source>Execute applies a parsed template to the specified data object, and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ab91b77ffead5cde7f6f24acf146ee0201982a" translate="yes" xml:space="preserve">
          <source>Execute applies a parsed template to the specified data object, writing the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa7fd65efa38167472fbe062e9cd8ed9345685c" translate="yes" xml:space="preserve">
          <source>ExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e15a34c9961f0a802784591faae9d82e65ab11" translate="yes" xml:space="preserve">
          <source>Exit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323cb868fc9882809ab8fcf5b777ebf834c84081" translate="yes" xml:space="preserve">
          <source>ExitCode returns the exit code of the exited process, or -1 if the process hasn't exited or was terminated by a signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca7074b049716c77d327197e75adfe965e8630d" translate="yes" xml:space="preserve">
          <source>Exited reports whether the program has exited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5871b8d86fba0af13c05dc83a5e5933bb7903327" translate="yes" xml:space="preserve">
          <source>Exp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510ebbd48ca70ddfb27143ea5c2bad2d44f10597" translate="yes" xml:space="preserve">
          <source>Exp returns e**x, the base-e exponential of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95aa110ed338c85b885ee58002691284514da3af" translate="yes" xml:space="preserve">
          <source>Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z. If m == nil or m == 0, z = x**y unless y &amp;lt;= 0 then z = 1. If m &amp;gt; 0, y &amp;lt; 0, and x and n are not relatively prime, z is unchanged and nil is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1f0ddfdecd3517aad8d1a91705ef531de70942" translate="yes" xml:space="preserve">
          <source>Exp2 returns 2**x, the base-2 exponential of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862a985d8f0da4e95960d25b159f9e9e124d15f5" translate="yes" xml:space="preserve">
          <source>ExpFloat64 returns an exponentially distributed float64 in the range (0, +math.MaxFloat64] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1) from the default Source. To produce a distribution with a different rate parameter, callers can adjust the output using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4e3aea659a15d7397bad8de4e0bdaee5767774" translate="yes" xml:space="preserve">
          <source>ExpFloat64 returns an exponentially distributed float64 in the range (0, +math.MaxFloat64] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1). To produce a distribution with a different rate parameter, callers can adjust the output using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9869e506c38f643f1fe985347c015deace6baa22" translate="yes" xml:space="preserve">
          <source>Expand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b52c66c070329e5def2fa05af7b37abc20b0c6" translate="yes" xml:space="preserve">
          <source>Expand appends template to dst and returns the result; during the append, Expand replaces variables in the template with corresponding matches drawn from src. The match slice should have been returned by FindSubmatchIndex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea00d9e907ef2f65f476a8e5a1f543fd9142d2a2" translate="yes" xml:space="preserve">
          <source>Expand replaces ${var} or $var in the string based on the mapping function. For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b36934002dfcd75585031913256f6e1ddb79f5" translate="yes" xml:space="preserve">
          <source>ExpandEnv</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6389ca0cb471c7cb629f85955e0325ee99607a54" translate="yes" xml:space="preserve">
          <source>ExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92843cc46bc54c2861399f972b67d13993534275" translate="yes" xml:space="preserve">
          <source>ExpandString is like Expand but the template and source are strings. It appends to and returns a byte slice in order to give the calling code control over allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251a582ce62bfefda6c673fcd37e8d59e05a2922" translate="yes" xml:space="preserve">
          <source>Expired connections may be closed lazily before reuse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481e2978ff7b371bd03a0ef6010a75e8c6fd03e9" translate="yes" xml:space="preserve">
          <source>Explicit argument indexes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a560a4789cca42ae8b0ecb7e313e3dc7fdad381d" translate="yes" xml:space="preserve">
          <source>ExplicitMethod returns the i'th explicitly declared method of interface t for 0 &amp;lt;= i &amp;lt; t.NumExplicitMethods(). The methods are ordered by their unique Id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210f18d7d2dca82962d73d77b3cb6405a7e3ec3b" translate="yes" xml:space="preserve">
          <source>Expm1 returns e**x - 1, the base-e exponential of x minus 1. It is more accurate than Exp(x) - 1 when x is near zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fbca60a155d19143993926486ce4e88d6422189" translate="yes" xml:space="preserve">
          <source>Exponent and precision limits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4480a118f418f1021763f928c23e7ee08b91b4bb" translate="yes" xml:space="preserve">
          <source>ExportKeyingMaterial returns length bytes of exported key material in a new slice as defined in RFC 5705. If context is nil, it is not used as part of the seed. If the connection was set to allow renegotiation via Config.Renegotiation, this function will return an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5548a6e6a833cb04c8f11cf10934171fef992a89" translate="yes" xml:space="preserve">
          <source>Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c95f3a80a2e18bac3dc7cc110e89646c904993c" translate="yes" xml:space="preserve">
          <source>ExprString returns the (possibly shortened) string representation for x. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74653975deaee88d4b0d4bc9bd71866d307248ad" translate="yes" xml:space="preserve">
          <source>Ext</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3fed82b4272b5f7259531edfdcd5e9f6c21ba8" translate="yes" xml:space="preserve">
          <source>Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final element of path; it is empty if there is no dot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a89f2dbf1cde287eb428e1ff050f98aebee55f" translate="yes" xml:space="preserve">
          <source>Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final slash-separated element of path; it is empty if there is no dot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c784f4a2ddacb355b9ec53f45e6f9e5b26f8ef62" translate="yes" xml:space="preserve">
          <source>ExtKeyUsage represents an extended set of actions that are valid for a given key. Each of the ExtKeyUsage* constants define a unique action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf85fd048e02a11c54f8e5a543cc54c32a75ac8" translate="yes" xml:space="preserve">
          <source>Extended Key Usage values are enforced down a chain, so an intermediate or root that enumerates EKUs prevents a leaf from asserting an EKU not in that list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d231fb333d7ce02bca636a53ff3662ee9b31d0e" translate="yes" xml:space="preserve">
          <source>Extension reports whether an extension is support by the server. The extension name is case-insensitive. If the extension is supported, Extension also returns a string that contains any parameters the server specifies for the extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace6ecb8af6a3359dd0ee95e26152ccb34af5460" translate="yes" xml:space="preserve">
          <source>Extension represents the ASN.1 structure of the same name. See RFC 5280, section 4.2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31959200e26a22be03bc0bb47ef68bbf9b24bab3" translate="yes" xml:space="preserve">
          <source>Extensions are looked up first case-sensitively, then case-insensitively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cbba6001e28100d482f6a6299792705c6215e5a" translate="yes" xml:space="preserve">
          <source>ExtensionsByType returns the extensions known to be associated with the MIME type typ. The returned extensions will each begin with a leading dot, as in &quot;.html&quot;. When typ has no associated extensions, ExtensionsByType returns an nil slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f92bb33922145bd437972bd7334d66d54fc74c" translate="yes" xml:space="preserve">
          <source>Fail marks the function as having failed but continues execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96da18b07e966a06683f2215098b994edf8d8a8" translate="yes" xml:space="preserve">
          <source>FailNow marks the function as having failed and stops its execution by calling runtime.Goexit (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a2572255742baf72eacb416d97e18b48d912c5" translate="yes" xml:space="preserve">
          <source>Failed reports whether the function has failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="158e2280504673822ca1dd07952532cc4d1da5a7" translate="yes" xml:space="preserve">
          <source>Fatal is equivalent to Log followed by FailNow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59eb8d095a56a5d642425c97f87d097bf1a29e0c" translate="yes" xml:space="preserve">
          <source>Fatal is equivalent to Print() followed by a call to os.Exit(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b648a69f1114f39bd45b11c4cb17246fbb28c1b" translate="yes" xml:space="preserve">
          <source>Fatal is equivalent to l.Print() followed by a call to os.Exit(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821293c77a8a8bf8b0fca5f95004d9fc65b67208" translate="yes" xml:space="preserve">
          <source>Fatalf is equivalent to Logf followed by FailNow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83255ac37e112e05058d8a28ec8b155f3e9d2e47" translate="yes" xml:space="preserve">
          <source>Fatalf is equivalent to Printf() followed by a call to os.Exit(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8571875ef68d4b9deea013c46be5e95e7550519a" translate="yes" xml:space="preserve">
          <source>Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48e9dcadd0241869c65df99078d16d774bed84d" translate="yes" xml:space="preserve">
          <source>Fatalln is equivalent to Println() followed by a call to os.Exit(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df0d59b5e282da60574bc47edaa9526f95c3b6d" translate="yes" xml:space="preserve">
          <source>Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb27ee0cfbf9af89a40e300698ac1dde2642f55" translate="yes" xml:space="preserve">
          <source>FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb72a865b5feb1394b8952b8f15d42e68aa3981b" translate="yes" xml:space="preserve">
          <source>Fd returns the integer Unix file descriptor referencing the open file. The file descriptor is valid only until f.Close is called or f is garbage collected. On Unix systems this will cause the SetDeadline methods to stop working.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61d809eab07312ae05f8f709b84547398d2efdf" translate="yes" xml:space="preserve">
          <source>Field returns the i'th field for 0 &amp;lt;= i &amp;lt; NumFields().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="261d167c68d467f10d820edc6286e66bbb21759b" translate="yes" xml:space="preserve">
          <source>Field returns the i'th field of the struct v. It panics if v's Kind is not Struct or i is out of range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c791e0a7e5bd33b119b2f78289ee593a7501c42" translate="yes" xml:space="preserve">
          <source>FieldByIndex returns the nested field corresponding to index. It panics if v's Kind is not struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8183a55fec39ebd325b9f393dccbc786cb50e104" translate="yes" xml:space="preserve">
          <source>FieldByName and related functions consider struct field names to be equal if the names are equal, even if they are unexported names originating in different packages. The practical effect of this is that the result of t.FieldByName(&quot;x&quot;) is not well defined if the struct type t contains multiple fields named x (embedded from different packages). FieldByName may return one of the fields named x or may report that there are none. See &lt;a href=&quot;https://golang.org/issue/4876&quot;&gt;https://golang.org/issue/4876&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a2508218e09b64bdd0d9e7f24c36121018ee1f" translate="yes" xml:space="preserve">
          <source>FieldByName returns the struct field with the given name. It returns the zero Value if no field was found. It panics if v's Kind is not struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05b4005e71684b698845fc4189a49e33cd3e7f3" translate="yes" xml:space="preserve">
          <source>FieldByNameFunc returns the struct field with a name that satisfies the match function. It panics if v's Kind is not struct. It returns the zero Value if no field was found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c99e9b1642562e3e1353bb454e3388fb902c996" translate="yes" xml:space="preserve">
          <source>FieldNode holds a field (identifier starting with '.'). The names may be chained ('.x.y'). The period is dropped from each ident.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b282c4f43da573ed9235e6d31c0129363fbd6a56" translate="yes" xml:space="preserve">
          <source>Fields interprets s as a sequence of UTF-8-encoded code points. It splits the slice s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning a slice of subslices of s or an empty slice if s contains only white space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11942ab8089728dea08ce9ed92990aab227d9b83" translate="yes" xml:space="preserve">
          <source>Fields splits the string s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an empty slice if s contains only white space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cddbffb0a4099caf5fcbfd9135dbe9cc1348312" translate="yes" xml:space="preserve">
          <source>Fields which start and stop with the quote character &quot; are called quoted-fields. The beginning and ending quote are not part of the field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed084c27b5c1cc1510b75a6eea5cceac8dc8568" translate="yes" xml:space="preserve">
          <source>FieldsFunc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1198e81508f52e5775684dce71da3bd307817aaf" translate="yes" xml:space="preserve">
          <source>FieldsFunc interprets s as a sequence of UTF-8-encoded code points. It splits the slice s at each run of code points c satisfying f(c) and returns a slice of subslices of s. If all code points in s satisfy f(c), or len(s) == 0, an empty slice is returned. FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fef0b1adf312085c03264cc3bf92c0ae08947f" translate="yes" xml:space="preserve">
          <source>FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c) and returns an array of slices of s. If all code points in s satisfy f(c) or the string is empty, an empty slice is returned. FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84f4c98b71a6a2f1e7b377a8676e629c9740fd5f" translate="yes" xml:space="preserve">
          <source>File is an interface to access the file part of a multipart message. Its contents may be either stored in memory or on disk. If stored on disk, the File's underlying concrete type will be an *os.File.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7e7234ecd572c448fdc94c6036d0727036b79d" translate="yes" xml:space="preserve">
          <source>File represents an open file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73835fd64cea7fb721059e67256305a0d198b5ab" translate="yes" xml:space="preserve">
          <source>File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cfa002fa0ca7b105692672f60881822088c5ccd" translate="yes" xml:space="preserve">
          <source>File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a964559e347c1b7accfdbfdb5331a705f9a38368" translate="yes" xml:space="preserve">
          <source>File returns the file that contains the position p. If no such file is found (for instance for p == NoPos), the result is nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8455c6bba2e3b76773e19fb487214e00c0eda43e" translate="yes" xml:space="preserve">
          <source>FileConn returns a copy of the network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22e3976fc002f08d409b21bc3b2057de6ee7bb5" translate="yes" xml:space="preserve">
          <source>FileExports reports whether there are exported declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddddfe5effd9cc3d49c7434638dbf7088ae876d" translate="yes" xml:space="preserve">
          <source>FileExports trims the AST for a Go source file in place such that only exported nodes remain: all top-level identifiers which are not exported and their associated information (such as type, initial value, or function body) are removed. Non-exported fields and methods of exported types are stripped. The File.Comments list is not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30db9abebdd92f5b7518cf1f5bbb9879a131845c" translate="yes" xml:space="preserve">
          <source>FileHeader describes a file within a zip file. See the zip spec for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d421452fb7f6f8f21ef4ba78426b17cbfd53ec7" translate="yes" xml:space="preserve">
          <source>FileInfo returns an os.FileInfo for the FileHeader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3ff5122dc6f633a02486f869c65c492c72e91a" translate="yes" xml:space="preserve">
          <source>FileInfo returns an os.FileInfo for the Header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f4523b7a78ead3725e69f92cdfe5b5d0be7c78" translate="yes" xml:space="preserve">
          <source>FileInfoHeader creates a partially-populated FileHeader from an os.FileInfo. Because os.FileInfo's Name method returns only the base name of the file it describes, it may be necessary to modify the Name field of the returned header to provide the full path name of the file. If compression is desired, callers should set the FileHeader.Method field; it is unset by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bade8efb0bdf22a697f4860acaff901dcdf7cd40" translate="yes" xml:space="preserve">
          <source>FileInfoHeader creates a partially-populated Header from fi. If fi describes a symlink, FileInfoHeader records link as the link target. If fi describes a directory, a slash is appended to the name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e337ae6931880d7e580a328902c201076b51624" translate="yes" xml:space="preserve">
          <source>FileLine returns the file name and line number of the source code corresponding to the program counter pc. The result will not be accurate if pc is not a program counter within f.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b2edf71f3991c324095b35a106fb747b15b499" translate="yes" xml:space="preserve">
          <source>FileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b25eeca51a2e908f97898c9ef3aefb4ac120d01" translate="yes" xml:space="preserve">
          <source>FileMode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6abe93ec8b861e41dbb5d680eb1abac76bc118" translate="yes" xml:space="preserve">
          <source>FileName returns the filename parameter of the Part's Content-Disposition header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab442735e84d773b25b014f5d105c04cedc7c9de" translate="yes" xml:space="preserve">
          <source>FilePacketConn returns a copy of the packet network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93afd50ecd9277958b5e979e54d840040f44f617" translate="yes" xml:space="preserve">
          <source>FileServer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1c6f5fe976e57e9903b48c0ae3364dd14af1bf" translate="yes" xml:space="preserve">
          <source>FileServer (DotFileHiding)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2a840c48e0d07f28c7b78564c1dff9913edbe7" translate="yes" xml:space="preserve">
          <source>FileServer (StripPrefix)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e3e689f0d74cd94b082adc56551c527c3d7331" translate="yes" xml:space="preserve">
          <source>FileServer returns a handler that serves HTTP requests with the contents of the file system rooted at root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05ffc1d15462ca6f99d23dad5504fcb24e01652" translate="yes" xml:space="preserve">
          <source>Filenames containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73595851a6091a7492042c8776979e91c6d3c91f" translate="yes" xml:space="preserve">
          <source>Files checks the provided files as part of the checker's package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2677f06472fc0feb492ada82a2c4649c4e1df36" translate="yes" xml:space="preserve">
          <source>Files containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c30ef34cd44738f2300a9d1c8d2644305bfe659" translate="yes" xml:space="preserve">
          <source>Filter eliminates documentation for names that don't pass through the filter f. TODO(gri): Recognize &quot;Type.Method&quot; as a name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe9542ddb9636eaf7f6d18a2a5c93cd3e032943" translate="yes" xml:space="preserve">
          <source>Filter returns a new comment map consisting of only those entries of cmap for which a corresponding node exists in the AST specified by node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99334f5ff24d09e0e43146c7ab17eed8e9e83ed8" translate="yes" xml:space="preserve">
          <source>FilterDecl reports whether there are any declared names left after filtering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98ad9f1ce33b85f6650faa2d18060284cd00443" translate="yes" xml:space="preserve">
          <source>FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ed367ffc6ba55dd5b60bff81664a2c439a8484" translate="yes" xml:space="preserve">
          <source>FilterFile reports whether there are any top-level declarations left after filtering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9fa766ec80d5d59f245ed962a927a61c070075" translate="yes" xml:space="preserve">
          <source>FilterFile trims the AST for a Go file in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. Import declarations are always removed. The File.Comments list is not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616d0d4a74fcef85e72d4edac004eabd14b32293" translate="yes" xml:space="preserve">
          <source>FilterPackage reports whether there are any top-level declarations left after filtering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc812cc8b170b6479d3dcdf5fdfae2947c9e732a" translate="yes" xml:space="preserve">
          <source>FilterPackage trims the AST for a Go package in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64167db3c8ee867d45eebbc9c53b064e2bb836d4" translate="yes" xml:space="preserve">
          <source>Finalizers are run in dependency order: if A points at B, both have finalizers, and they are otherwise unreachable, only the finalizer for A runs; once A is freed, the finalizer for B can run. If a cyclic structure includes a block with a finalizer, that cycle is not guaranteed to be garbage collected and the finalizer is not guaranteed to run, because there is no ordering that respects the dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c286b7e901d165a790bb4d85625ee624e6c5de" translate="yes" xml:space="preserve">
          <source>Finally, *Int, *Rat, and *Float satisfy the fmt package's Scanner interface for scanning and (except for *Rat) the Formatter interface for formatted printing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ec87dd2b9f83faa210cf241d5b474c8a62da6b" translate="yes" xml:space="preserve">
          <source>Finally, any occurrences of slash are replaced by Separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e283acb4f254ad8296a8a754d3d7b44acc43a52" translate="yes" xml:space="preserve">
          <source>Finally, each message created by a call to Encode is preceded by an encoded unsigned integer count of the number of bytes remaining in the message. After the initial type name, interface values are wrapped the same way; in effect, the interface value acts like a recursive invocation of Encode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26fb85ce34e42f69c76353a6f2b051f404c7f2c9" translate="yes" xml:space="preserve">
          <source>Find returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3939b43a8656fedf8c713b119be8032947dc3ecd" translate="yes" xml:space="preserve">
          <source>FindAll is the 'All' version of Find; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cb8b2ff6a76516bc1c892450ee61ae3139b098" translate="yes" xml:space="preserve">
          <source>FindAllIndex is the 'All' version of FindIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f37301641ba46ce0b020d50232dcdae9f0dad0" translate="yes" xml:space="preserve">
          <source>FindAllIndex returns a sorted list of non-overlapping matches of the regular expression r, where a match is a pair of indices specifying the matched slice of x.Bytes(). If n &amp;lt; 0, all matches are returned in successive order. Otherwise, at most n matches are returned and they may not be successive. The result is nil if there are no matches, or if n == 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de88adfecc3f20e0c2ffdbb0f036f7a79d80f3b" translate="yes" xml:space="preserve">
          <source>FindAllString is the 'All' version of FindString; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f5df0a72b99ef5ef4ba48205043bd703872dd1" translate="yes" xml:space="preserve">
          <source>FindAllStringIndex is the 'All' version of FindStringIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd030004e8ba710e67858c9136cb59800b720d8e" translate="yes" xml:space="preserve">
          <source>FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866672036e7565c5590c34ec3cdc6d2f77a921c5" translate="yes" xml:space="preserve">
          <source>FindAllStringSubmatchIndex is the 'All' version of FindStringSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be6622b78b7a355447dee918503ed5111144cd3" translate="yes" xml:space="preserve">
          <source>FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52ee6c792ee96296da432c07ce6bac841f99f98" translate="yes" xml:space="preserve">
          <source>FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e5b0dfb84ada5e535dcd7bb2807e917d046ce8" translate="yes" xml:space="preserve">
          <source>FindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8a7de41165a099a274921bab815b24b2852407" translate="yes" xml:space="preserve">
          <source>FindProcess looks for a running process by its pid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4911a1ccdd694282d198f0794f5539db98ac7df1" translate="yes" xml:space="preserve">
          <source>FindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the RuneReader. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d35aea7e01a3055400cfb5abc273aa2a48d9a9f" translate="yes" xml:space="preserve">
          <source>FindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the RuneReader, and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a327cf77fbaf9bbe1a604d4bcf583f4d07fb1a" translate="yes" xml:space="preserve">
          <source>FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use FindStringIndex or FindStringSubmatch if it is necessary to distinguish these cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531bff01dd38db5d072dffaff07b7a369f4e48aa" translate="yes" xml:space="preserve">
          <source>FindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a789ded76b89d56fcfc993f95abd7a8461164bf2" translate="yes" xml:space="preserve">
          <source>FindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716a3ff38a9d712fef426438e6f03f83ab81e7b5" translate="yes" xml:space="preserve">
          <source>FindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa69da36fb7ee45dba39b18243a0f710f826bb2" translate="yes" xml:space="preserve">
          <source>FindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7965df00e3cbe474d92d31bb0bd5221f067573f7" translate="yes" xml:space="preserve">
          <source>FindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316c8fcfd0429ed17b8857dd6ccdd403f5640491" translate="yes" xml:space="preserve">
          <source>Fix re-establishes the heap ordering after the element at index i has changed its value. Changing the value of the element at index i and then calling Fix is equivalent to, but less expensive than, calling Remove(h, i) followed by a Push of the new value. The complexity is O(log n) where n = h.Len().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7cfcda1db5ca5e3bcb0a9677bf0dd4d80ac6e4" translate="yes" xml:space="preserve">
          <source>FixedZone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8dd9f2c3ea7d8b26856edf904ee0771c7d5fc47" translate="yes" xml:space="preserve">
          <source>FixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7a643e1bb2320ed4f231588740bf7ac2e291cd" translate="yes" xml:space="preserve">
          <source>Flag parsing stops just before the first non-flag argument (&quot;-&quot; is a non-flag argument) or after the terminator &quot;--&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdd311ef8e9ef566cf48b8fece102302ba2cc48" translate="yes" xml:space="preserve">
          <source>Flags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3386ff8f43c1696f153b0da6ee0a837cb1976a" translate="yes" xml:space="preserve">
          <source>Flags control the behavior of the parser and record information about regexp context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c488a94448ea7f6f8bcea47a1cbbb9b2216fc9" translate="yes" xml:space="preserve">
          <source>Flags may then be used directly. If you're using the flags themselves, they are all pointers; if you bind to variables, they're values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5f3f5f47f0c72df0bc10a5003e3c8534841d99" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the logger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab784ad102a2c124d297f0684145d0588e53e2ce" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the standard logger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49886552d225c91289351966a030fb2ce1479645" translate="yes" xml:space="preserve">
          <source>Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4dce7c8ab9c22a7b9475e937cb3027b98a99140" translate="yes" xml:space="preserve">
          <source>Float (Shift)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e98719e5ce5b2d4401b4abb5dc0f8819be8a88" translate="yes" xml:space="preserve">
          <source>Float is a 64-bit float variable that satisfies the Var interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10efe1f5142078fa491d28fd6eb4b8558bc300d7" translate="yes" xml:space="preserve">
          <source>Float returns the value v as a float64. It panics if v is not a JavaScript number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce5b8413e70edd589cd645e2e4c3403f1aae941" translate="yes" xml:space="preserve">
          <source>Float returns v's underlying value, as a float64. It panics if v's Kind is not Float32 or Float64</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeec2beb5f657aee9f544ee180ec6e738a4d2d1a" translate="yes" xml:space="preserve">
          <source>Float.Add</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad02b5997c5669d53745f3d1c236de0ca407890e" translate="yes" xml:space="preserve">
          <source>Float.Cmp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec48acd5df26f0383b2951f8c9e9ae9c4ff8998" translate="yes" xml:space="preserve">
          <source>Float.Scan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29933c6b53142cadd8d7b922f23fae52793b020" translate="yes" xml:space="preserve">
          <source>Float32 returns the float32 value nearest to x. If x is too small to be represented by a float32 (|x| &amp;lt; math.SmallestNonzeroFloat32), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float32 (|x| &amp;gt; math.MaxFloat32), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d283c114b964a75d4c408e464182f402cb0b18" translate="yes" xml:space="preserve">
          <source>Float32 returns the nearest float32 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float32, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb048248df2600ce9ef5e83d147f9a17ca26adc9" translate="yes" xml:space="preserve">
          <source>Float32 returns, as a float32, a pseudo-random number in [0.0,1.0) from the default Source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="119557e6710e4b086bbd4a2b0b1939505b2ba07f" translate="yes" xml:space="preserve">
          <source>Float32 returns, as a float32, a pseudo-random number in [0.0,1.0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b84b66f83430db58763aa54b8b6d03936e54bbe" translate="yes" xml:space="preserve">
          <source>Float32Val is like Float64Val but for float32 instead of float64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105737d03460ae3ded6de0ef2ecd36f638e30d1b" translate="yes" xml:space="preserve">
          <source>Float32bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position. Float32bits(Float32frombits(x)) == x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6760b22e35a08f8123f6341f83087ea51bc753" translate="yes" xml:space="preserve">
          <source>Float32frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float32frombits(Float32bits(x)) == x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33f8d6b4fe7a74df8d041793f6b8728167aa373" translate="yes" xml:space="preserve">
          <source>Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932e539e33ca068476000955a48af619cccb5721" translate="yes" xml:space="preserve">
          <source>Float64 returns the float64 value nearest to x. If x is too small to be represented by a float64 (|x| &amp;lt; math.SmallestNonzeroFloat64), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float64 (|x| &amp;gt; math.MaxFloat64), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9246cdfb5427d2669759af0d644a975a43bcf09a" translate="yes" xml:space="preserve">
          <source>Float64 returns the nearest float64 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float64, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb72db19ea2b309695153285bf2c38294276e222" translate="yes" xml:space="preserve">
          <source>Float64 returns the number as a float64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e645bfba6b519f6d6f9f504b9c2a836ed66b68" translate="yes" xml:space="preserve">
          <source>Float64 returns, as a float64, a pseudo-random number in [0.0,1.0) from the default Source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39abd5b0f47630ce640acfdfa7a56a26bd48772c" translate="yes" xml:space="preserve">
          <source>Float64 returns, as a float64, a pseudo-random number in [0.0,1.0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653daf75fab3a49fdd7213b2a24c9eb000e8f80b" translate="yes" xml:space="preserve">
          <source>Float64Slice attaches the methods of Interface to []float64, sorting in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5aaf48b420a680701da91064c2099910f7a459" translate="yes" xml:space="preserve">
          <source>Float64Val returns the nearest Go float64 value of x and whether the result is exact; x must be numeric or an Unknown, but not Complex. For values too small (too close to 0) to represent as float64, Float64Val silently underflows to 0. The result sign always matches the sign of x, even for 0. If x is Unknown, the result is (0, false).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f480bc564117c47157609272dad009564b4f9701" translate="yes" xml:space="preserve">
          <source>Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b76d09c27fdfd38a6732c012baed4272833ca08" translate="yes" xml:space="preserve">
          <source>Float64bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position, and Float64bits(Float64frombits(x)) == x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13821cdc42fa2ea9b35bbae95ee0c4f0016322fc" translate="yes" xml:space="preserve">
          <source>Float64frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float64frombits(Float64bits(x)) == x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9528abfae7394b5c9ba7f685b93bd097bf04d6fb" translate="yes" xml:space="preserve">
          <source>Float64s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d807816d1f16d759e0177078b58ba0a3f78cc89" translate="yes" xml:space="preserve">
          <source>Float64s sorts a slice of float64s in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423599a7986fad94bdc1d6990e093d25432d1712" translate="yes" xml:space="preserve">
          <source>Float64sAreSorted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b88d9ca0f421f91022935615e41cacbe0162795" translate="yes" xml:space="preserve">
          <source>Float64sAreSorted tests whether a slice of float64s is sorted in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d47ae20529c410d30f8acaae289ca9d51484938" translate="yes" xml:space="preserve">
          <source>FloatString returns a string representation of x in decimal form with prec digits of precision after the radix point. The last digit is rounded to nearest, with halves rounded away from zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a1f94d542ff10ae04a25aa8e277a76154c76d0" translate="yes" xml:space="preserve">
          <source>FloatType is here for the purposes of documentation only. It is a stand-in for either float type: float32 or float64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062cea8bd0e8167673b6851fa82870b7db8d7c76" translate="yes" xml:space="preserve">
          <source>Floating point, integer, and Number values encode as JSON numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d6ee865f2a29fd1629088910ea491c9698ff5c" translate="yes" xml:space="preserve">
          <source>Floating-point and complex constituents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b844d202032ef470ba06e9916c2c520ac0ae8998" translate="yes" xml:space="preserve">
          <source>Floating-point limit values. Max is the largest finite value representable by the type. SmallestNonzero is the smallest positive, non-zero value representable by the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58315571a008eb8b389dc1e86460decd0968399f" translate="yes" xml:space="preserve">
          <source>Floating-point numbers are always sent as a representation of a float64 value. That value is converted to a uint64 using math.Float64bits. The uint64 is then byte-reversed and sent as a regular unsigned integer. The byte-reversal means the exponent and high-precision part of the mantissa go first. Since the low bits are often zero, this can save encoding bytes. For instance, 17.0 is encoded in only three bytes (FE 31 40).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db82f74092fc3160e6bc0d9e9bd4849c5c06c0f" translate="yes" xml:space="preserve">
          <source>Floor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecdffd0cc36f2aad9aef8da98d7fbdd7cd3a98c8" translate="yes" xml:space="preserve">
          <source>Floor returns the greatest integer value less than or equal to x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563e65b909d8ae6e49711cd799a32c5eb753dc00" translate="yes" xml:space="preserve">
          <source>FloydSteinberg is a Drawer that is the Src Op with Floyd-Steinberg error diffusion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589b0d2e5704bd529f61be95ef5544d324be7a14" translate="yes" xml:space="preserve">
          <source>Flush finishes writing the current file's block padding. The current file must be fully written before Flush can be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843ff9ecc07dad8fd240920fbaff659c8bd3b2af" translate="yes" xml:space="preserve">
          <source>Flush flushes any buffered XML to the underlying writer. See the EncodeToken documentation for details about when it is necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7757e81dddaaa31ce1e5de4d9b235a8f3a0853cd" translate="yes" xml:space="preserve">
          <source>Flush flushes any buffered data to the underlying writer. Calling Flush is not normally necessary; calling Close is sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96dda344b5d691957686f7fdb72b5295f5fa20bb" translate="yes" xml:space="preserve">
          <source>Flush flushes any pending compressed data to the underlying writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5ed753caad4196a8e88cd94331064662192c20" translate="yes" xml:space="preserve">
          <source>Flush flushes any pending data to the underlying writer. It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. Calling Flush when there is no pending data still causes the Writer to emit a sync marker of at least 4 bytes. If the underlying writer returns an error, Flush returns that error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18258ea43eb9026bfa3ba6a07c0a3a31739171f2" translate="yes" xml:space="preserve">
          <source>Flush flushes the Writer to its underlying io.Writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729311d07e8c1334af4a5f862a0dd14b0dd93238" translate="yes" xml:space="preserve">
          <source>Flush implements http.Flusher. To test whether Flush was called, see rw.Flushed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d24f3ea0b3c10e2043b05ee2cd79df1306cedcb" translate="yes" xml:space="preserve">
          <source>Flush should be called after the last call to Write to ensure that any data buffered in the Writer is written to output. Any incomplete escape sequence at the end is considered complete for formatting purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea94514228dc595c44d2b25610d0fa2d54b246e4" translate="yes" xml:space="preserve">
          <source>Flush writes any buffered data to the underlying io.Writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae89e3b744d5bf8ef751ee2c788427617846f85a" translate="yes" xml:space="preserve">
          <source>Flush writes any buffered data to the underlying io.Writer. To check if an error occurred during the Flush, call Error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f472a0c2c904654bddc286404214aebce731987" translate="yes" xml:space="preserve">
          <source>FlushAfterChunkWriter signals from the caller of NewChunkedWriter that each chunk should be followed by a flush. It is used by the http.Transport code to keep the buffering behavior for headers and trailers, but flush out chunks aggressively in the middle for request bodies which may be generated slowly. See Issue 6574.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772a9c77dc26ab2b684cccb97da47b2e2cdf95ac" translate="yes" xml:space="preserve">
          <source>FoldCategory maps a category name to a table of code points outside the category that are equivalent under simple case folding to code points inside the category. If there is no entry for a category name, there are no such points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df43e93d81327f2c6837f681b29802a81ed9d8c" translate="yes" xml:space="preserve">
          <source>FoldScript maps a script name to a table of code points outside the script that are equivalent under simple case folding to code points inside the script. If there is no entry for a script name, there are no such points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a306a62652b9cfbec638f004e0203911d315836" translate="yes" xml:space="preserve">
          <source>For IP networks, the network must be &quot;ip&quot;, &quot;ip4&quot; or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, and the address has the form &quot;host&quot;. The host must be a literal IP address or a literal IPv6 address with zone. It depends on each operating system how the operating system behaves with a non-well known protocol number such as &quot;0&quot; or &quot;255&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a986939ec86bd91233d7b82449d187d316efcfcb" translate="yes" xml:space="preserve">
          <source>For POST, PUT, and PATCH requests, it also parses the request body as a form and puts the results into both r.PostForm and r.Form. Request body parameters take precedence over URL query string values in r.Form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961435f4e8342868021020dbf9e49c6cd0fb855a" translate="yes" xml:space="preserve">
          <source>For TCP and UDP networks, the address has the form &quot;host:port&quot;. The host must be a literal IP address, or a host name that can be resolved to IP addresses. The port must be a literal port number or a service name. If the host is a literal IPv6 address it must be enclosed in square brackets, as in &quot;[2001:db8::1]:80&quot; or &quot;[fe80::1%zone]:80&quot;. The zone specifies the scope of the literal IPv6 address as defined in RFC 4007. The functions JoinHostPort and SplitHostPort manipulate a pair of host and port in this form. When using TCP, and the host resolves to multiple IP addresses, Dial will try each IP address in order until one succeeds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c81916838d3414948e1c22f701e5ce4a3a4855" translate="yes" xml:space="preserve">
          <source>For TCP networks, if the host in the address parameter is empty or a literal unspecified IP address, Listen listens on all available unicast and anycast IP addresses of the local system. To only use IPv4, use network &quot;tcp4&quot;. The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or &quot;0&quot;, as in &quot;127.0.0.1:&quot; or &quot;[::1]:0&quot;, a port number is automatically chosen. The Addr method of Listener can be used to discover the chosen port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc11a7bec3f66f8d391db1eaf65bf359662c3096" translate="yes" xml:space="preserve">
          <source>For TCP, UDP and IP networks, if the host is empty or a literal unspecified IP address, as in &quot;:80&quot;, &quot;0.0.0.0:80&quot; or &quot;[::]:80&quot; for TCP and UDP, &quot;&quot;, &quot;0.0.0.0&quot; or &quot;::&quot; for IP, the local system is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ddf19f5cd72f2d3b549235c60d91767535d03b" translate="yes" xml:space="preserve">
          <source>For UDP and IP networks, if the host in the address parameter is empty or a literal unspecified IP address, ListenPacket listens on all available IP addresses of the local system except multicast IP addresses. To only use IPv4, use network &quot;udp4&quot; or &quot;ip4:proto&quot;. The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or &quot;0&quot;, as in &quot;127.0.0.1:&quot; or &quot;[::1]:0&quot;, a port number is automatically chosen. The LocalAddr method of PacketConn can be used to discover the chosen port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa2c0bd0a7ad04b8f9986a2d00cc56ef314d18a" translate="yes" xml:space="preserve">
          <source>For Unix networks, the address must be a file system path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd90d9b68fe83f1b691af955f9ccbfffd46f969" translate="yes" xml:space="preserve">
          <source>For a description of the testing flags, see &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Testing_flags&quot;&gt;https://golang.org/cmd/go/#hdr-Testing_flags&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73db7630962b7d9bfe80901d992afe02ab8d444e" translate="yes" xml:space="preserve">
          <source>For a more concise way to create NamedArg values, see the Named function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e93a7b63c6c1c22251cdfa7d2125bbcb4c1d807" translate="yes" xml:space="preserve">
          <source>For a study of the facility in action, visit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8b0e15d8c10094163cd876f62393b64628d456" translate="yes" xml:space="preserve">
          <source>For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbed43366f7734c782e1358f999b46beb1e3fca" translate="yes" xml:space="preserve">
          <source>For a tutorial, see &lt;a href=&quot;https://golang.org/s/types-tutorial&quot;&gt;https://golang.org/s/types-tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18ade19ed4a3115a9d9e3c880c80a5a49514530" translate="yes" xml:space="preserve">
          <source>For all requests, ParseForm parses the raw query from the URL and updates r.Form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78bb4acd6502d15dc3957871fac3c0be9d9b00b" translate="yes" xml:space="preserve">
          <source>For an abstract method, Recv returns the enclosing interface either as a *Named or an *Interface. Due to embedding, an interface may contain methods whose receiver type is a different interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e330719ad337b4c9602641929cab60cae09925d" translate="yes" xml:space="preserve">
          <source>For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8c341cebb2371fc4554d9fb0c6e54c2c5900936" translate="yes" xml:space="preserve">
          <source>For base 0, an underscore character &amp;ldquo;_&amp;rdquo; may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number, or the returned digit count. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and thus terminate scanning like any other character that is not a valid radix point or digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5942b37cf590ae4aabd1b760f075ef90fd1c294" translate="yes" xml:space="preserve">
          <source>For base 0, an underscore character &amp;ldquo;_&amp;rdquo; may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and act like any other character that is not a valid digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f1ac8df1f8e77c9fdc27bc0637f8b872484b6a1" translate="yes" xml:space="preserve">
          <source>For base 0, the number prefix determines the actual base: A prefix of &amp;ldquo;0b&amp;rdquo; or &amp;ldquo;0B&amp;rdquo; selects base 2, &amp;ldquo;0o&amp;rdquo; or &amp;ldquo;0O&amp;rdquo; selects base 8, and &amp;ldquo;0x&amp;rdquo; or &amp;ldquo;0X&amp;rdquo; selects base 16. Otherwise, the actual base is 10 and no prefix is accepted. The octal prefix &quot;0&quot; is not supported (a leading &quot;0&quot; is simply considered a &quot;0&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da96f7777bef60314c708eb513a45527fc86e1a" translate="yes" xml:space="preserve">
          <source>For bases &amp;lt;= 36, lower and upper case letters are considered the same: The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35. For bases &amp;gt; 36, the upper case letters 'A' to 'Z' represent the digit values 36 to 61.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cda30f1e34e7fc3ab26bca0abe9bc827de94de0" translate="yes" xml:space="preserve">
          <source>For calls ForCompiler with a new FileSet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7777ccd24b8bd654eee8980ccc52774364f6122b" translate="yes" xml:space="preserve">
          <source>For compatibility with Go 1.0, Symbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3f39afacd60fc39b35ccda1637af8ff2e8c205" translate="yes" xml:space="preserve">
          <source>For compatibility with Symbols, DynamicSymbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceff07027a0562aae7bcfc8fafd438b3054bb3ea" translate="yes" xml:space="preserve">
          <source>For complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b540b6ad368c9fd7ce41d2cd5a4983671593e81" translate="yes" xml:space="preserve">
          <source>For compound objects, the elements are printed using these rules, recursively, laid out like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fb692c25f138c6447e3086029bcccc81bc7da5" translate="yes" xml:space="preserve">
          <source>For compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cab5826d638fdbcb2ad7a5200731c473b3d7274" translate="yes" xml:space="preserve">
          <source>For control over HTTP client headers, redirect policy, and other settings, create a Client:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c2ce00eb37f48324b8088e1562b15a52ee733a" translate="yes" xml:space="preserve">
          <source>For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993c8adfef972ba1b068a5731b030b2c3e0c3fdb" translate="yes" xml:space="preserve">
          <source>For correct printing of source code containing comments (using packages go/format and go/printer), special care must be taken to update comments when a File's syntax tree is modified: For printing, comments are interspersed between tokens based on their position. If syntax tree nodes are removed or moved, relevant comments in their vicinity must also be removed (from the File.Comments list) or moved accordingly (by updating their positions). A CommentMap may be used to facilitate some of these operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483fb4b25526c306ca9ffc7060d999d1af757359" translate="yes" xml:space="preserve">
          <source>For debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8abfac368bfa911449148a175097af24838350b" translate="yes" xml:space="preserve">
          <source>For each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand. Another variant Println inserts blanks between operands and appends a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0691fc88626f896c5b4d0c9d21eb150c4440f732" translate="yes" xml:space="preserve">
          <source>For example, a client might run a HELP command that returns a dot-body by using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c85d01a63eaf87fca388b5018e0aae0a907e1f" translate="yes" xml:space="preserve">
          <source>For example, a plugin defined as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b604de3a3134fd6e14b1dedf12ca2289afcd00f8" translate="yes" xml:space="preserve">
          <source>For example, assume that we decided to froth milk, extract coffee, and mix milk and coffee in separate goroutines. With a task, the trace tool can identify the goroutines involved in a specific cappuccino order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2f502c06edd8d48f9eb402147b9d0d02234fdf" translate="yes" xml:space="preserve">
          <source>For example, consider this input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c08416096093138a9f21f98db3e35296861799a" translate="yes" xml:space="preserve">
          <source>For example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648df35862f0618dac59c24e1f3c2197d967fa5c" translate="yes" xml:space="preserve">
          <source>For example, pre-submit checks that use this package directly would behave differently depending on what Go version each developer uses, causing the check to be inherently fragile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70afa30fe71b5984e96c509da8feab3dc9a6c66" translate="yes" xml:space="preserve">
          <source>For example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b900be25452bfa919448d61bc68d11256350e2d5" translate="yes" xml:space="preserve">
          <source>For floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acb9c872d25848ac32729a8857f27d0fe460ece" translate="yes" xml:space="preserve">
          <source>For forward compatibility, users that retrieve a Header from Reader.Next, mutate it in some ways, and then pass it back to Writer.WriteHeader should do so by creating a new Header and copying the fields that they are interested in preserving.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4409a51b04b7b882dd788481aa8d78b52daf5f6" translate="yes" xml:space="preserve">
          <source>For higher-level HTTP client support (such as handling of cookies and redirects), see Get, Post, and the Client type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf573cb88fa50261bc0cb844250e5c546113d3a" translate="yes" xml:space="preserve">
          <source>For incoming server requests, the context is canceled when the client's connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP method returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc897ff158a8e45243f9b229fc5329d56c63ca4" translate="yes" xml:space="preserve">
          <source>For information about UTF-8 strings in Go, see &lt;a href=&quot;https://blog.golang.org/strings&quot;&gt;https://blog.golang.org/strings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fe9b03e1c707dfe354f7496b7b0ea1047361fe" translate="yes" xml:space="preserve">
          <source>For instance, NewInt(x) returns an *Int set to the value of the int64 argument x, NewRat(a, b) returns a *Rat set to the fraction a/b where a and b are int64 values, and NewFloat(f) returns a *Float initialized to the float64 argument f. More flexibility is provided with explicit setters, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef36fa9bc6685ceb9dbf97a5a5da2cffd6025d4b" translate="yes" xml:space="preserve">
          <source>For instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data[i] &amp;gt;= 23 }) returns the smallest index i such that data[i] &amp;gt;= 23. If the caller wants to find whether 23 is in the slice, it must test data[i] == 23 separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7dfa4cd456b849ced74b774ac752b76885a540c" translate="yes" xml:space="preserve">
          <source>For instance, the arguments for (*Int).Add are named x and y, and because the receiver specifies the result destination, it is called z:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f07f1d3d8e7f6b87f995e34e12a6b2b7256d6aa" translate="yes" xml:space="preserve">
          <source>For instance, when executing the template whose source is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6018681f8b36b5a67b809b220861a7e3eea4cf91" translate="yes" xml:space="preserve">
          <source>For more information about pprof, see &lt;a href=&quot;https://github.com/google/pprof/blob/master/doc/README.md&quot;&gt;https://github.com/google/pprof/blob/master/doc/README.md&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d996431a64b6bd8bf9d3bd0300d40b96d810b5b1" translate="yes" xml:space="preserve">
          <source>For more tolerant parsing, Scan will return a valid token if possible even if a syntax error was encountered. Thus, even if the resulting token sequence contains no illegal tokens, a client may not assume that no error occurred. Instead it must check the scanner's ErrorCount or the number of calls of the error handler, if there was one installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee92c8f279c1f6e92caa92b507d20eceb3f7bf2a" translate="yes" xml:space="preserve">
          <source>For most Unix systems, this package has two internal implementations of resolving user and group ids to names. One is written in pure Go and parses /etc/passwd and /etc/group. The other is cgo-based and relies on the standard C library (libc) routines such as getpwuid_r and getgrnam_r.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4cdb94c601192f951b8e3c2e58421475088397d" translate="yes" xml:space="preserve">
          <source>For most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515255bc358ef4ff5aa5412e1b66dcc8c403a8d9" translate="yes" xml:space="preserve">
          <source>For non-interface types V, or if static is set, V implements T if all methods of T are present in V. Otherwise (V is an interface and static is not set), MissingMethod only checks that methods of T which are also present in V have matching types (e.g., for a type assertion x.(T) where x is of interface type V).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b71be130422309f072d39771550fbade7a681c88" translate="yes" xml:space="preserve">
          <source>For other HTTP methods, or when the Content-Type is not application/x-www-form-urlencoded, the request Body is not read, and r.PostForm is initialized to a non-nil, empty value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fd7feae6eaa72525957265644b35d2d7178aab" translate="yes" xml:space="preserve">
          <source>For outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9dd41b387dea5f2e387ef2638e22692d5781ada" translate="yes" xml:space="preserve">
          <source>For outgoing client requests, the context controls cancellation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a001fc47d27546732ba34a6c50953e3947ee9592" translate="yes" xml:space="preserve">
          <source>For parsing this time format, see ParseTime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f71ccb724292b936b826fde518652933240dfacc" translate="yes" xml:space="preserve">
          <source>For portability, the status code should be in the range [0, 125].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf654bcdb4217ef6a979d8f651f736b1fbda2ae7" translate="yes" xml:space="preserve">
          <source>For random numbers suitable for security-sensitive work, see the crypto/rand package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dac1d0bb1e2323543dc0dee447715c7804fe438" translate="yes" xml:space="preserve">
          <source>For scanning into *bool, the source may be true, false, 1, 0, or string inputs parseable by strconv.ParseBool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a8f63617a1059c9b07e1b34be114b05733ec0f" translate="yes" xml:space="preserve">
          <source>For simpler multi-way equality tests, eq (only) accepts two or more arguments and compares the second and subsequent to the first, returning in effect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a480a0eda63e237a87664c806578f92d694410" translate="yes" xml:space="preserve">
          <source>For simplicity in setup, the connection is defined to understand these types a priori, as well as the basic gob types int, uint, etc. Their ids are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1206bb6c7f79687004103bffb38cbee66ebc60" translate="yes" xml:space="preserve">
          <source>For some arguments, such as a simple array expression, the result can be a constant. See the Go language specification's &quot;Length and capacity&quot; section for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73ee93bdb118cfdcf76b1431924d083213a9b9c" translate="yes" xml:space="preserve">
          <source>For some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification's &quot;Length and capacity&quot; section for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd5303b38861cc1f75ea4005c27f0d0e4bc73ba" translate="yes" xml:space="preserve">
          <source>For strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751d670356e91a449ec7c80c4156cc58a03922ea" translate="yes" xml:space="preserve">
          <source>For such flags, the default value is just the initial value of the variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe319d30e4ff1d3bb9c9679e1d41b020cb9fc422" translate="yes" xml:space="preserve">
          <source>For testing: clients can set this flag to force creation of IPv6 sockets to return EAFNOSUPPORT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0e9615cbad5d104943c88a1e426bb41d0d3626" translate="yes" xml:space="preserve">
          <source>For the compiler to recognize this pattern, the conversion must appear in the argument list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13732a80c7c6067fbd8ddcc6a6ec2963b831f009" translate="yes" xml:space="preserve">
          <source>For the most part, LineTable's methods should be treated as an internal detail of the package; callers should use the methods on Table instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82aa2e5faa1102c849b424650d24e3f7def76f8e" translate="yes" xml:space="preserve">
          <source>For the most part, this package follows the syntax as specified by RFC 5322 and extended by RFC 6532. Notable divergences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dbc53494237ff152fc67f06045073fe509d54b4" translate="yes" xml:space="preserve">
          <source>For the power-of-two exponent formats, the mantissa is printed in normalized form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64016515259f77234a6cb253ce7855821350f37" translate="yes" xml:space="preserve">
          <source>For the synchronous signals and SIGPIPE, the Go runtime will install a signal handler. It will save any existing signal handler. If a synchronous signal arrives while executing non-Go code, the Go runtime will invoke the existing signal handler instead of the Go signal handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee851057097c0db5b5b8a9c0d45d60cedf064a6" translate="yes" xml:space="preserve">
          <source>For these internal escaping functions, if an action pipeline evaluates to a nil interface value, it is treated as though it were an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cdbab58de221c0845a1f0bccdc6ab6b9dfee7c" translate="yes" xml:space="preserve">
          <source>For this trimming, the definition of white space characters is the same as in Go: space, horizontal tab, carriage return, and newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4dda3b24b75ceb8fb66edf8e6d50d204c1750ea" translate="yes" xml:space="preserve">
          <source>For unrecognized or vendor-defined attributes, Class may be ClassUnknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c58c0bacd7ac1887ab982a2597ef55f18dc028" translate="yes" xml:space="preserve">
          <source>For usage examples, see the wiki page at &lt;a href=&quot;https://golang.org/s/sqlwiki&quot;&gt;https://golang.org/s/sqlwiki&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988918abc4e75847a40cae9d31b2ff0b26774a56" translate="yes" xml:space="preserve">
          <source>ForCompiler returns an Importer for importing from installed packages for the compilers &quot;gc&quot; and &quot;gccgo&quot;, or for importing directly from the source if the compiler argument is &quot;source&quot;. In this latter case, importing may fail under circumstances where the exported API is not entirely defined in pure Go source code (if the package API depends on cgo-defined entities, the type checker won't have access to those).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133285841cd925c282a101cb331b225c1c71812e" translate="yes" xml:space="preserve">
          <source>ForLabels invokes f with each label set on the context. The function f should return true to continue iteration or false to stop iteration early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353aeb4085eb053c5afffba4c97380c4860aca38" translate="yes" xml:space="preserve">
          <source>Form is a parsed multipart form. Its File parts are stored either in memory or on disk, and are accessible via the *FileHeader's Open method. Its Value parts are stored as strings. Both are keyed by field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eccde56e16564dc7c7df2c5cc1796440a15f9401" translate="yes" xml:space="preserve">
          <source>FormDataContentType returns the Content-Type for an HTTP multipart/form-data with this Writer's Boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49e5a35587aa21155c47ca684122af3589d1687" translate="yes" xml:space="preserve">
          <source>FormFile returns the first file for the provided form key. FormFile calls ParseMultipartForm and ParseForm if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d5c015330e69759a40946c508bd098ecc8416e4" translate="yes" xml:space="preserve">
          <source>FormName returns the name parameter if p has a Content-Disposition of type &quot;form-data&quot;. Otherwise it returns the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445b64c2c00e9bf0c6abebdbd962d04b7f9f105c" translate="yes" xml:space="preserve">
          <source>FormValue returns the first value for the named component of the query. POST and PUT body parameters take precedence over URL query string values. FormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, FormValue returns the empty string. To access multiple values of the same key, call ParseForm and then inspect Request.Form directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90d813e4920205a13e7a3e3ea46b1033f09615e" translate="yes" xml:space="preserve">
          <source>Format errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd81fbee8cc623aef03682c00bd263e80dddfcaa" translate="yes" xml:space="preserve">
          <source>Format implements fmt.Formatter. It accepts all the regular formats for floating-point numbers ('b', 'e', 'E', 'f', 'F', 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the interpretation of 'p'. The 'v' format is handled like 'g'. Format also supports specification of the minimum precision in digits, the output field width, as well as the format flags '+' and ' ' for sign control, '0' for space or zero padding, and '-' for left or right justification. See the fmt package for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddca00e8215628107f30d61b04b8094c67090fc1" translate="yes" xml:space="preserve">
          <source>Format implements fmt.Formatter. It accepts the formats 'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). Also supported are the full suite of package fmt's format flags for integral types, including '+' and ' ' for sign control, '#' for leading zero in octal and for hexadecimal, a leading &quot;0x&quot; or &quot;0X&quot; for &quot;%#x&quot; and &quot;%#X&quot; respectively, specification of minimum digits precision, output field width, space or zero padding, and '-' for left or right justification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a5476108fadb465e67c178e260599d04ddc2e8" translate="yes" xml:space="preserve">
          <source>Format represents the tar archive format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4885fbdac6d0d14accf79b985b4ce78e6bdd62" translate="yes" xml:space="preserve">
          <source>Format returns a textual representation of the time value formatted according to layout, which defines the format by showing how the reference time, defined to be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ee515426820c27b536513d4c839dfeda89b51d" translate="yes" xml:space="preserve">
          <source>FormatBool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b75ed131650db00babc41765f3ab4d40a495482" translate="yes" xml:space="preserve">
          <source>FormatBool returns &quot;true&quot; or &quot;false&quot; according to the value of b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6afd52cbbbdc2288edb941b965e52c2fc0f3f529" translate="yes" xml:space="preserve">
          <source>FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf02981ef6c41fa3e9a421259a94865e8c2df157" translate="yes" xml:space="preserve">
          <source>FormatError is returned by some operations if the data does not have the correct format for an object file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be4c97132e0f61e257dba73681e0455cf421f26" translate="yes" xml:space="preserve">
          <source>FormatError is unused. The type is retained for compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66155c8335bf85f47e7201829386a88e599875d5" translate="yes" xml:space="preserve">
          <source>FormatFloat</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab806a123a3e3bc36a09fdd9698930a4aafbfb9" translate="yes" xml:space="preserve">
          <source>FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54acac612d12c84fbb587187170a9d2f5002e9e1" translate="yes" xml:space="preserve">
          <source>FormatInt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac942d8c471010cc2511b6465b29a4a4eaf7e487" translate="yes" xml:space="preserve">
          <source>FormatInt returns the string representation of i in the given base, for 2 &amp;lt;= base &amp;lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &amp;gt;= 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffe85b478b1a8a795e300c5a2b13589a4aacd1b" translate="yes" xml:space="preserve">
          <source>FormatMediaType serializes mediatype t and the parameters param as a media type conforming to RFC 2045 and RFC 2616. The type and parameter names are written in lower-case. When any of the arguments result in a standard violation then FormatMediaType returns the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457b9a9d61506e909562e056e83daf32584b6e03" translate="yes" xml:space="preserve">
          <source>FormatUint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e428f2dcc8699c0417730387a64fac7ddd1961" translate="yes" xml:space="preserve">
          <source>FormatUint returns the string representation of i in the given base, for 2 &amp;lt;= base &amp;lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &amp;gt;= 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74de65e787a3b1e89f96cc3e3b260c1d5a19f78c" translate="yes" xml:space="preserve">
          <source>Formatter is the interface implemented by values with a custom formatter. The implementation of Format may call Sprint(f) or Fprint(f) etc. to generate its output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a818c703590da441ab8fb9d8bac8b6144c0764" translate="yes" xml:space="preserve">
          <source>Formatting can be controlled with these flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a6bd1d5df471e18e5ef09488e671afbb943a27" translate="yes" xml:space="preserve">
          <source>Fprint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8522f1e4d59e7911ef9e37ddbccae99dbf77c6" translate="yes" xml:space="preserve">
          <source>Fprint &quot;pretty-prints&quot; an AST node to output for a given configuration cfg. Position information is interpreted relative to the file set fset. The node type must be *ast.File, *CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a539386d013173d33a590058d75eefbdb15fa6" translate="yes" xml:space="preserve">
          <source>Fprint &quot;pretty-prints&quot; an AST node to output. It calls Config.Fprint with default settings. Note that gofmt uses tabs for indentation but spaces for alignment; use format.Node (package go/format) for output that matches gofmt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104c28c9f2550f07e8ce3bfa8162280f3f8c80ca" translate="yes" xml:space="preserve">
          <source>Fprint formats using the default formats for its operands and writes to w. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a536bd9e7bf91ae60cda20d0ea5db515bbd6c7b" translate="yes" xml:space="preserve">
          <source>Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20e1fe41e4983b3d1227303d39b1a75b7115f30" translate="yes" xml:space="preserve">
          <source>Fprintf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13c0d787117a7941cdce4981a12d040db7f0953" translate="yes" xml:space="preserve">
          <source>Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46197102442051b0256d5e8d44d3fa71b3e0ca3a" translate="yes" xml:space="preserve">
          <source>Fprintln</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b390d66055f3fb09a9893ca4c02d4466e93e9f7e" translate="yes" xml:space="preserve">
          <source>Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52284236b3cbc2d437f96673b062717eea95c7a" translate="yes" xml:space="preserve">
          <source>Frame is the information returned by Frames for each call frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e7a3833d19706ebf33b2c3baf8e05deeed7bca" translate="yes" xml:space="preserve">
          <source>Frames</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a32e149e9d6773e4f6967f48bf708bb90588f99" translate="yes" xml:space="preserve">
          <source>Frames may be used to get function/file/line information for a slice of PC values returned by Callers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971e42ae8bcc68c1d3c0b0b0f45fd394dc7d0afe" translate="yes" xml:space="preserve">
          <source>FreeOSMemory forces a garbage collection followed by an attempt to return as much memory to the operating system as possible. (Even if this is not called, the runtime gradually returns memory to the operating system in a background task.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6c189d92419208a8893cd5a97e05687d681927" translate="yes" xml:space="preserve">
          <source>Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f == frac &amp;times; 2**exp, with the absolute value of frac in the interval [&amp;frac12;, 1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa23c274e14dd5cc1e7fa9a8a9b29bf34200b44f" translate="yes" xml:space="preserve">
          <source>FromSlash returns the result of replacing each slash ('/') character in path with a separator character. Multiple slashes are replaced by multiple separators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164e0e9caa51bad7048b8f096c49d9b2c2ab5e89" translate="yes" xml:space="preserve">
          <source>Front returns the first element of list l or nil if the list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c1852fe9f31cf9deb2025a2022f1fc079a5aee" translate="yes" xml:space="preserve">
          <source>Fscan scans text read from r, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554810832552956da9a7da2eee0a73593dca23e7" translate="yes" xml:space="preserve">
          <source>Fscanf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd3b6e023a616305dbe6b056ba1a191e7adb603" translate="yes" xml:space="preserve">
          <source>Fscanf scans text read from r, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ce0d47eda270ec1be1d5faf6933fc84f496fc9" translate="yes" xml:space="preserve">
          <source>Fscanln</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba607f7da03e13291dee0bc0511128cd6a13033" translate="yes" xml:space="preserve">
          <source>Fscanln is similar to Fscan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18339496bb65d9199e22c7756d8d353de7e08bb1" translate="yes" xml:space="preserve">
          <source>FullName finds real name of symbol sym. Normally name is stored in sym.Name, but if it is longer then 8 characters, it is stored in COFF string table st instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7902524eb980d3f158a430d41566b78e54c0f4a8" translate="yes" xml:space="preserve">
          <source>FullName returns the package- or receiver-type-qualified name of function or method obj.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3483c701e937232d5e060b21f7fb965b230aa71" translate="yes" xml:space="preserve">
          <source>FullRune</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81aa0878662ea86cc86d82ed1ab7992029d672d9" translate="yes" xml:space="preserve">
          <source>FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune. An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05115514df90c085c4af490f89158b561b0d92c" translate="yes" xml:space="preserve">
          <source>FullRuneInString</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95812f07b4917317402c5d2167338a188da0ce79" translate="yes" xml:space="preserve">
          <source>FullRuneInString is like FullRune but its input is a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279955fd7d680432dfab90fbe069c9bfd8dc8495" translate="yes" xml:space="preserve">
          <source>Func implements Var by calling the function and formatting the returned value using JSON.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524a0d206f4cbf19e946f5d4ed3f42690d7a8676" translate="yes" xml:space="preserve">
          <source>Func is a wrapped Go function to be called by JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f43fd9d5faa1fad98bda7488e8199738c579a5f" translate="yes" xml:space="preserve">
          <source>Func is the documentation for a func declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1428a5974ab9a5d9bb8050c81e92e9a085606a0b" translate="yes" xml:space="preserve">
          <source>Func values are deeply equal if both are nil; otherwise they are not deeply equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b4c67efe336d8800eb50760aa412d1cd7318a96" translate="yes" xml:space="preserve">
          <source>Func.Release must be called to free up resources when the function will not be used any more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c0844aa92a7c85df75b63db88d3ac85acf1947" translate="yes" xml:space="preserve">
          <source>FuncForPC returns a *Func describing the function that contains the given program counter address, or else nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f873cfa96e723fb817cda8756e298acee836d4d" translate="yes" xml:space="preserve">
          <source>FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) argument evaluates to non-nil during execution, execution terminates and Execute returns that error. FuncMap has the same base type as FuncMap in &quot;text/template&quot;, copied here so clients need not import &quot;text/template&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c663a8fdf1b0c07a4b3a9bf988b2301d91e56916" translate="yes" xml:space="preserve">
          <source>FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) return value evaluates to non-nil during execution, execution terminates and Execute returns that error.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
