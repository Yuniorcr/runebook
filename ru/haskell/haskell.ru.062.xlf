<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="824156b97fa215b3e57f4c35b718839b27b32f4a" translate="yes" xml:space="preserve">
          <source>Handling symbolic link using Win32 API. [Vista of later and desktop app only]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89aab9f219783f5483f9c8a2f555018716574e03" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad2b4d3875aa4ad0be9d5cb9d1098c6ae4770cb" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993d612407c57078184116f64cae6bcafc5ebc5a" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048292f565b5b22828fa076edbb58a73e8cfd5b8" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3affea459771f35ab73628ef32521d013f015828" translate="yes" xml:space="preserve">
          <source>HangupOnClose</source>
          <target state="translated">HangupOnClose</target>
        </trans-unit>
        <trans-unit id="6bfec95216610c8923fdb3b58c6820e2638d7012" translate="yes" xml:space="preserve">
          <source>Hard link name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151f3938abe034f9943c5ceef0c5082df3ebe59c" translate="yes" xml:space="preserve">
          <source>Hard links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfda26ce9011e1d31a770fb6f43ec4f97f72200e" translate="yes" xml:space="preserve">
          <source>HardwareFault</source>
          <target state="translated">HardwareFault</target>
        </trans-unit>
        <trans-unit id="a40e006669de268a9bb2acc2447224d0f6c74cbc" translate="yes" xml:space="preserve">
          <source>HasCallStack</source>
          <target state="translated">HasCallStack</target>
        </trans-unit>
        <trans-unit id="d5a8afb8c704edab0aaea5d1e5ddc323a689f7a5" translate="yes" xml:space="preserve">
          <source>HasCallStack call stacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56fbf4c5db38163d687f59e194a828baa7c9bd2" translate="yes" xml:space="preserve">
          <source>HasField</source>
          <target state="translated">HasField</target>
        </trans-unit>
        <trans-unit id="20dd461a479f96766729c9d640324e99a0d215cb" translate="yes" xml:space="preserve">
          <source>HasJobControl</source>
          <target state="translated">HasJobControl</target>
        </trans-unit>
        <trans-unit id="4932242cd8f456e18307629642a2aa4a2f8e249e" translate="yes" xml:space="preserve">
          <source>HasResolution</source>
          <target state="translated">HasResolution</target>
        </trans-unit>
        <trans-unit id="19eda78b3bcf5dc9a7065d2ad4cee793b2e7eef4" translate="yes" xml:space="preserve">
          <source>HasSavedIDs</source>
          <target state="translated">HasSavedIDs</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="0229c5fae78a9965d4f45ca37d03dc1236ff8fa7" translate="yes" xml:space="preserve">
          <source>Hashes a &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Two &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt;s may hash to the same value, although in practice this is unlikely. The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; returned makes a good hash key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="5901d3877bf9e737aa3e94d79bb4ea0286df3607" translate="yes" xml:space="preserve">
          <source>Haskeline has two ways of interacting with the user:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="065908ba2e214305b72d700a33ff216d049eb661" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 allows for integer literals to be given in decimal, octal (prefixed by &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0O&lt;/code&gt;), or hexadecimal notation (prefixed by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da42c988c0cf83b43592a40a36bf805281eb533" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 define floating literals with the syntax &lt;code&gt;1.2e6&lt;/code&gt;. These literals have the type &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aef0b7881ddce0846355a38d3d56808bc487369" translate="yes" xml:space="preserve">
          <source>Haskell 2010 functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2dfdff50d43589a65e10f3de801e5cd1f3481ad" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add &amp;ldquo;&lt;code&gt;deriving( Eq, Ord )&lt;/code&gt;&amp;rdquo; to a data type declaration, to generate a standard instance declaration for classes specified in the &lt;code&gt;deriving&lt;/code&gt; clause. In Haskell 98, the only classes that may appear in the &lt;code&gt;deriving&lt;/code&gt; clause are the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13a83f3c36a18ef798acce46700a669fd2d9a2f" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add a deriving clause to a data type declaration, to generate a standard instance declaration for specified class. GHC extends this mechanism along several axes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc350c1e6daa1d0a99b5e176fd6627f03f073af" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows you to define a default implementation when declaring a class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdbe3cc69c9d59fa9c998d2ffb90eaf9b74ed7ed" translate="yes" xml:space="preserve">
          <source>Haskell 98 prohibits class method types to mention constraints on the class type variable, thus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da9fcbc717e278cc072c704bc0fb1543efb67d0" translate="yes" xml:space="preserve">
          <source>Haskell 98 regards all four as ambiguous, but with the &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; extension, GHC will accept the former two. The rules are precisely the same as those for instance declarations in Haskell 98, where the method names on the left-hand side of the method bindings in an instance declaration refer unambiguously to the method of that class (provided they are in scope at all), even if there are other variables in scope with the same name. This reduces the clutter of qualified names when you import two records from different modules that use the same field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e37b99ac7bc7b32576c5a86ef921f839207b134" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; never uses the default &quot;6-digit&quot; precision used by C printf.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803931392d9e7f7a42786baf24bd3acbb21d2297" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; prints the exponent of e-format numbers without a gratuitous plus sign, and with the minimum possible number of digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a988b88b57fc6a5015c3bdce6eced1db2e93fb3" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; treats the &quot;precision&quot; specifier as indicating the number of digits after the decimal point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5a761278ad7995ae6ea10eb54d7d46a18911b2" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; will place a zero after a decimal point when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db5bb3ecf93ed4bf68c234dce9b122cc069d4fc" translate="yes" xml:space="preserve">
          <source>Haskell allows datatypes to be given contexts, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba63f358f6ed0e157b0d31998c471fd73b1c809" translate="yes" xml:space="preserve">
          <source>Haskell compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96570b066116767adb53a9bedbb0995cb0718ff" translate="yes" xml:space="preserve">
          <source>Haskell defines operations to read and write characters from and to files, represented by values of type &lt;code&gt;Handle&lt;/code&gt;. Each value of this type is a &lt;em&gt;handle&lt;/em&gt;: a record used by the Haskell run-time system to &lt;em&gt;manage&lt;/em&gt; I/O with file system objects. A handle has at least the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57185b2c62d4c8656c31d0f4760835255a021285" translate="yes" xml:space="preserve">
          <source>Haskell expressions can be typed at the prompt:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b350cda5fbb367cf839d60b51cc0cd72d5f14c" translate="yes" xml:space="preserve">
          <source>Haskell file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9588bea707a1b459133b5d157a94371293bfcc8" translate="yes" xml:space="preserve">
          <source>Haskell identifier, e.g. &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;Baz&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8864d7903427f164a617a184e73202acec74086a" translate="yes" xml:space="preserve">
          <source>Haskell infers the kind of each type variable. Sometimes it is nice to be able to give the kind explicitly as (machine-checked) documentation, just as it is nice to give a type signature for a function. On some occasions, it is essential to do so. For example, in his paper &amp;ldquo;Restricted Data Types in Haskell&amp;rdquo; (Haskell Workshop 1999) John Hughes had to define the data type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03044d4dffb5ba6961d6c201b79e6123773d3291" translate="yes" xml:space="preserve">
          <source>Haskell lexer: returns the lexed string, rather than the lexeme</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6fb7995adcbbff55a20ec28fb0709de06184c0" translate="yes" xml:space="preserve">
          <source>Haskell library authors have a choice. Most should just use Safe inference. Assuming you avoid any unsafe features of the language then your modules will be marked safe. Inferred vs. Explicit has the following trade-offs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3010148ab07280017396fcfee70d4ee8ced651" translate="yes" xml:space="preserve">
          <source>Haskell offers a powerful type system and separation of pure and effectual functions through the &lt;code&gt;IO&lt;/code&gt; monad. However, there are several loop holes in the type system, the most obvious being the &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; function. The safe language dialect of Safe Haskell disallows the use of such functions. This can be useful restriction as it makes Haskell code easier to analyse and reason about. It also codifies the existing culture in the Haskell community of trying to avoid unsafe functions unless absolutely necessary. As such, using the safe language (through the &lt;code&gt;-XSafe&lt;/code&gt; flag) can be thought of as a way of enforcing good style, similar to the function of &lt;code&gt;-Wall&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc620cd7bebfbd449c887c8393ef71a9cb0048a" translate="yes" xml:space="preserve">
          <source>Haskell provides indexable &lt;em&gt;arrays&lt;/em&gt;, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers. Functions restricted in this way can be implemented efficiently; in particular, a programmer may reasonably expect rapid access to the components. To ensure the possibility of such an implementation, arrays are treated as data, not as general functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7368b5caa5272a65112545054af26ecf77386013" translate="yes" xml:space="preserve">
          <source>Haskell representation for &lt;code&gt;errno&lt;/code&gt; values. The implementation is deliberately exposed, to allow users to add their own definitions of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc207680c476b314f16992dfd19a9a9a258a751" translate="yes" xml:space="preserve">
          <source>Haskell representations of &lt;code&gt;errno&lt;/code&gt; values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5341eea214941c8fa9b89302f00f8e694f12278b" translate="yes" xml:space="preserve">
          <source>Haskell source files may be named on the command line, and they will be loaded exactly as in interactive mode. The expression is evaluated in the context of the loaded modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae2da82a38cbe99fd9ff682badbaaec111364bd4" translate="yes" xml:space="preserve">
          <source>Haskell specifies that when compiling module &lt;code&gt;M&lt;/code&gt;, any instance declaration in any module &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; is visible. (Module &lt;code&gt;A&lt;/code&gt; is &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is imported directly by &lt;code&gt;M&lt;/code&gt;, or if &lt;code&gt;A&lt;/code&gt; is below a module that &lt;code&gt;M&lt;/code&gt; imports directly.) In principle, GHC must therefore read the interface files of every module below &lt;code&gt;M&lt;/code&gt;, just in case they contain an instance declaration that matters to &lt;code&gt;M&lt;/code&gt;. This would be a disaster in practice, so GHC tries to be clever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78504a490dcd1a405c09c255b59b6c836880bb83" translate="yes" xml:space="preserve">
          <source>Haskell symbol, e.g. &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;:%&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df367f209bd79c811db4b993c1f851b5f670ca59" translate="yes" xml:space="preserve">
          <source>Haskell threads and Operating System threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e4d1115a8c2e36e70d3db1df85b3ba04c82997" translate="yes" xml:space="preserve">
          <source>Haskell threads can communicate via &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, a kind of synchronised mutable variable (see &lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVar&lt;/a&gt;). Several common concurrency abstractions can be built from &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, and these are provided by the &lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; library. In GHC, threads may also communicate via exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1152cd8067628adcb5244f0c52d2f1ebdecd3c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;FILE&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419c0d47d2c63155c445b3a35a04cad638377266" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;bool&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054a037a3aeec17395419134ad5d32666e879988" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;char&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdab6efef7ff3df329d3bbc78a8616b4cb3989a6" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;clock_t&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86270c6c52b37291a4f83ecf2067e3d22c57c6e" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;double&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0598f733099fb128ae47c1c3166b704c545480c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9783270eb36d4323f4eecfe9fe711bc1dd549c60" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;fpos_t&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3828a73b928783c1ab6b138f30ed4a7fd77963fd" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123f078eb33cc5f8ac71fcc1a58b2e7c9744c67a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;jmp_buf&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a09db76fc4cf39e52e96e84ca7eceffcb2dc6cb" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long long&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc0cd5923376a1c5f20498ef35d8c0014b53573" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e280e77ea88a2a6aea1fcccbe66210a18677d7c4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;ptrdiff_t&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c33de586ddf7a29484efc41926b3029b29a9d4f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;short&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6814ce0babdcf6409207c9d5c62a5d21549d670" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;sig_atomic_t&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc79efb4536a8d15f8e47bcacf02aad5c789afda" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;signed char&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e53c7ba3862ff8361e9698b99ceeef6ee695ac" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;size_t&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b7b2f84ee34dce910b692ae6d7694070d1eec8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;suseconds_t&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da77000fdb42bf1ac5567a3f5f38306a7b9ce31a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51aa5d4ba2ad63bf1d5b193a1d5d1d64e9d7c6d8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa56d97929c4f9c0dd6851175b77e5a237a45c9f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned int&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7478eb320307f22ab3f106029e32684ea1826e3" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long long&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095152341382e5cc99a0893c334b897d9021c542" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482e4215906c2a0c84b2e998c4bb04b882601162" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c48c6e42125f2dcb7f39d4c8e9601abc37dca1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;useconds_t&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47e3f97a5805a43b017fd566e8e3a0455b50952" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d7a20dd1cef70b191b1919721181f45bec4aa1" translate="yes" xml:space="preserve">
          <source>Haskell type signatures are implicitly quantified. When the language option &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is used, the keyword &lt;code&gt;forall&lt;/code&gt; allows us to say exactly what this means. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312958a763351ecbecd34417b742da475b01a5b7" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; (list), &lt;code&gt;ST&lt;/code&gt; (both strict and lazy versions), &lt;code&gt;IO&lt;/code&gt;, and many other monads have &lt;code&gt;MonadFix&lt;/code&gt; instances. On the negative side, the continuation monad, with the signature &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt;, does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286ac067159c9b8667979c69f2ab39f042776595" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s defaulting mechanism (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskell Report, Section 4.3.4&lt;/a&gt;) is extended to cover string literals, when &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is specified. Specifically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c360d83894c7aaa51597c83bb2ca4c5910f6876" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s monomorphism restriction (see &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;Section 4.5.5&lt;/a&gt; of the Haskell Report) can be completely switched off by &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt;&lt;code&gt;NoMonomorphismRestriction&lt;/code&gt;&lt;/a&gt;. Since GHC 7.8.1, the monomorphism restriction is switched off by default in GHCi&amp;rsquo;s interactive options (see &lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a141ab08d985dedb9f98957467226e86a2237bf" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s overloading (using type classes) is elegant, neat, etc., etc., but it is death to performance if left to linger in an inner loop. How can you squash it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dcc270971fff7841b459ba1100736aab53d82ce" translate="yes" xml:space="preserve">
          <source>Haskell2010</source>
          <target state="translated">Haskell2010</target>
        </trans-unit>
        <trans-unit id="8611224d67199ccb4a7a8d4b25bc635c1cfc3a48" translate="yes" xml:space="preserve">
          <source>Haskell98</source>
          <target state="translated">Haskell98</target>
        </trans-unit>
        <trans-unit id="b3c55f7ef7d356d7c9a7ac63331871b50a302e38" translate="yes" xml:space="preserve">
          <source>Haskellish interface to memcpy and memmove</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b408395f7a6c9ad5cc0948fe6c746bdc2863b6c4" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate constraints in a type signature. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb44315e3933ae78ec7b2d4c76e749754a530e44" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate entries in export lists. This is useful information if you maintain large export lists, and want to avoid the continued export of a definition after you&amp;rsquo;ve deleted (one) mention of it in the export list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7ae11dc5a0a8877bcb29fcbae185b9eb38ee9a" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in a type signature. In particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f4f4e6d95b4c6cd8400d7a4c53dd54d2cb85e3" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in type signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba1acc7c9ce9a9b091d8587b0cb7dcc3c4e1695" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b28e1b8588f425f51c4575626ab47cf2ecc0796" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if there are tabs in your source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70054c2390d77cf46a86a1147ea85118a1ef3f99" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell Monomorphism Restriction is applied. If applied silently the MR can give rise to unexpected behaviour, so it can be helpful to have an explicit warning that it is being applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2afe399bfaedad9702ee7fd70b7b7244f971386" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell defaulting mechanism for numeric types kicks in. This is useful information when converting code from a context that assumed one default into one with another, e.g., the &amp;lsquo;default default&amp;rsquo; for Haskell 1.4 caused the otherwise unconstrained value &lt;code&gt;1&lt;/code&gt; to be given the type &lt;code&gt;Int&lt;/code&gt;, whereas Haskell 98 and later defaults it to &lt;code&gt;Integer&lt;/code&gt;. This may lead to differences in performance and behaviour, hence the usefulness of being non-silent about this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5498abf9bbeb2f58bbb844fe2ccb526cf856d105" translate="yes" xml:space="preserve">
          <source>Having compiled the program for profiling, you now need to run it to generate the profile. For example, a simple time profile can be generated by running the program with &lt;code&gt;+RTS -p&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt;), which generates a file named &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; where ⟨prog⟩ is the name of your program (without the &lt;code&gt;.exe&lt;/code&gt; extension, if you are on Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5b0196dfa158a640e0507548062ffac1c9509d" translate="yes" xml:space="preserve">
          <source>Having run the program, we can generate a textual summary of coverage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e7c42bd3113b21fb94871ff334499b878d14a0e" translate="yes" xml:space="preserve">
          <source>Having said that, we &lt;em&gt;can&lt;/em&gt; document exactly what GHC does with respect to the floating point state, so that if you really need to use &lt;code&gt;fenv.h&lt;/code&gt; then you can do so with full knowledge of the pitfalls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf4aec16734a9e97669c90f0df9d922bc22aee2" translate="yes" xml:space="preserve">
          <source>Head and tail of string broken at substring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d7ca754b0a092c3e57740e0999c3698d86bf13" translate="yes" xml:space="preserve">
          <source>Heap fragmentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572f0f8bd257503295a21f9d80fde910db01c38c" translate="yes" xml:space="preserve">
          <source>HeapByCCS</source>
          <target state="translated">HeapByCCS</target>
        </trans-unit>
        <trans-unit id="8c6ad9c60a037be60f4d12e9727ec1dd6fb58d15" translate="yes" xml:space="preserve">
          <source>HeapByClosureType</source>
          <target state="translated">HeapByClosureType</target>
        </trans-unit>
        <trans-unit id="67189d744bb418e35b57f2c375c2f70ffcda9c38" translate="yes" xml:space="preserve">
          <source>HeapByDescr</source>
          <target state="translated">HeapByDescr</target>
        </trans-unit>
        <trans-unit id="ac2ddc42c46684b8a60b44d593d3341dc156883c" translate="yes" xml:space="preserve">
          <source>HeapByLDV</source>
          <target state="translated">HeapByLDV</target>
        </trans-unit>
        <trans-unit id="ab2990dbf6d95e591ed5d567962d304a62d73db5" translate="yes" xml:space="preserve">
          <source>HeapByMod</source>
          <target state="translated">HeapByMod</target>
        </trans-unit>
        <trans-unit id="c5860308e2043941209f92548c297cda091fbd26" translate="yes" xml:space="preserve">
          <source>HeapByRetainer</source>
          <target state="translated">HeapByRetainer</target>
        </trans-unit>
        <trans-unit id="449a4bf1c2c9b0156bb827447b1b70399b9a2bbe" translate="yes" xml:space="preserve">
          <source>HeapByType</source>
          <target state="translated">HeapByType</target>
        </trans-unit>
        <trans-unit id="0a4f1a75f10d18da48ca6030d1af26f2b38bc7d5" translate="yes" xml:space="preserve">
          <source>HeapOverflow</source>
          <target state="translated">HeapOverflow</target>
        </trans-unit>
        <trans-unit id="fba6d5e717ea526f849b6efdaf8193417b738a9d" translate="yes" xml:space="preserve">
          <source>Heaps</source>
          <target state="translated">Heaps</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b912a2c5bb90bae872b79adf45f16133c4fd255" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa871229f3037dd5b17c54f9bd6a24abf6b10e89" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01aa287a9e6ccd271de097c45912c21c3a884f7b" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42aad862bc90fff6991f6294f9c9fa7c57b05312" translate="yes" xml:space="preserve">
          <source>Helpers for &lt;code&gt;RealFloat&lt;/code&gt; type-class operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b3626fe3abd6dd061729bf2a8d1e0b63df13e7" translate="yes" xml:space="preserve">
          <source>Helpers for defining &quot;wrapper&quot; functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b312d08020a7a266d812110fde12a2a83862f68" translate="yes" xml:space="preserve">
          <source>Hence, the original expression must have a type which is an instance of the &lt;code&gt;Show&lt;/code&gt; class, or GHCi will complain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbcb0e424c40d9931c2c7c8b44c33c5f4e12465" translate="yes" xml:space="preserve">
          <source>Here</source>
          <target state="translated">Here</target>
        </trans-unit>
        <trans-unit id="fbb03ee11c282574e4295542c0218f98b1aad7d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;A&lt;/code&gt; imports &lt;code&gt;B&lt;/code&gt;, but &lt;code&gt;B&lt;/code&gt; imports &lt;code&gt;A&lt;/code&gt; with a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma, which breaks the circular dependency. Every loop in the module import graph must be broken by a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import; or, equivalently, the module import graph must be acyclic if &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; imports are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8399ef26432f55f6e29dace236362d3bda6f8aa" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; is ambiguous in the definition of &lt;code&gt;D&lt;/code&gt; but later specified to be &lt;code&gt;Int&lt;/code&gt; using type applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d964c9cfca665c8adcbfb18e361180bdc190f2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are class parameters, but the type is also indexed on a third parameter &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83c105689c8fd61a7dfc1566a878cd9f0c4ca65" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;lsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;lsquo;s type), and so all is well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ef93a85414044a6743aade675856cb8b2404a3" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; is generalised because it has no free variables; and its binding group is unaffected by the monomorphism restriction; and hence &lt;code&gt;f&lt;/code&gt; is closed. The same reasoning applies to &lt;code&gt;g&lt;/code&gt;, except that it has one closed free variable, namely &lt;code&gt;f&lt;/code&gt;. Similarly &lt;code&gt;h&lt;/code&gt; is closed, &lt;em&gt;even though it is not bound at top level&lt;/em&gt;, because its only free variable &lt;code&gt;f&lt;/code&gt; is closed. But &lt;code&gt;k&lt;/code&gt; is not closed, because it mentions &lt;code&gt;x&lt;/code&gt; which is not closed (because it is not let-bound).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b823e1758b1c0ce3297af5a6572a41579e18c99" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; must be updating &lt;code&gt;T&lt;/code&gt; because neither &lt;code&gt;S&lt;/code&gt; nor &lt;code&gt;U&lt;/code&gt; have both fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44e1be2ff74797a08ba2e1197bb693a802bcebd" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;lsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5580273dadf2edf4e8b3e5d2e96253462581e863" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;lsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e74f35f734a03f3bce931bb0f5d5375f57de25" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;tag&lt;/code&gt; is a public field, with a well-typed selector function &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt;. The &lt;code&gt;self&lt;/code&gt; type is hidden from the outside; any attempt to apply &lt;code&gt;_this&lt;/code&gt;, &lt;code&gt;_inc&lt;/code&gt; or &lt;code&gt;_display&lt;/code&gt; as functions will raise a compile-time error. In other words, &lt;em&gt;GHC defines a record selector function only for fields whose type does not mention the existentially-quantified variables&lt;/em&gt;. (This example used an underscore in the fields for which record selectors will not be defined, but that is only programming style; GHC ignores them.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5848d57cf456303e6aaae0111187f76226179d" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; and the pattern binding &lt;code&gt;(y,z)&lt;/code&gt; remain lazy. Reason: there is no good moment to force them, until first use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c889417053878657fe2e9a8e21f6e33d087297" translate="yes" xml:space="preserve">
          <source>Here GHC has translated the expression into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4200822fb94b0bfc0d0b0fd94e6cf82c6d349ff5" translate="yes" xml:space="preserve">
          <source>Here GHC will not solve the constraint &lt;code&gt;(C c Int)&lt;/code&gt; from the top-level instance, because a particular call of &lt;code&gt;g&lt;/code&gt; might instantiate both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; to the same type, which would allow the constraint to be solved in a different way. This latter restriction is principally to make the constraint-solver complete. (Interested folk can read &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; in &lt;code&gt;TcInteract&lt;/code&gt;.) It is easy to avoid: in a type signature avoid a constraint that matches a top-level instance. The flag &lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt;&lt;/a&gt; warns about such signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0cb08091788d9276ad005df64a62df2471916ac" translate="yes" xml:space="preserve">
          <source>Here are a few examples of using the &lt;code&gt;filepath&lt;/code&gt; functions together:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a79e773a9d37344cccecd1e6b27389b6ae9d630" translate="yes" xml:space="preserve">
          <source>Here are some examples of admissible and illegal type instances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25023bd7f5466b38299a82f7530be3c8c581e9e8" translate="yes" xml:space="preserve">
          <source>Here are some examples of how this translation works. The first expression of each sequence is Haskell source; the subsequent ones are Core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53d0f1e137d9d27c69f2dc138fdd7c31d405ef3" translate="yes" xml:space="preserve">
          <source>Here are some examples of using said representation. Consider a few types of the &lt;code&gt;Type&lt;/code&gt; universe encoded like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1938696280e6b5bf3660612c2408006d76611c9a" translate="yes" xml:space="preserve">
          <source>Here are some examples that illustrate the property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">Вот несколько примеров:</target>
        </trans-unit>
        <trans-unit id="7e3cfeff552447efcf37ae18b5959e5301027734" translate="yes" xml:space="preserve">
          <source>Here are some export lists and their meaning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="757e98b8dc27b605d3ba22a718bc090780c91f60" translate="yes" xml:space="preserve">
          <source>Here are some more details:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef4a6f74860fdc9aa02bdcc17602e952e06fa44" translate="yes" xml:space="preserve">
          <source>Here are some other important points in using the recursive-do notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7acccdf9bd48aabe31c92ed0d7e8b5709c940249" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code for &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ba5c6ad5fee6c15536c72e587bdaba386e2b34" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code in each extension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d0fd5666cf351f1559a1cb0f0f5ec8ec9e925e" translate="yes" xml:space="preserve">
          <source>Here are the key definitions, all available from &lt;code&gt;GHC.Exts&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06158caf9a087d2325d1d35545027e3560435152" translate="yes" xml:space="preserve">
          <source>Here are the salient features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5858cb273a5f386866d01967e86562b0221422f8" translate="yes" xml:space="preserve">
          <source>Here follow the properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ba49b7a3494e39c5e9ac6930fb642d56cb237a" translate="yes" xml:space="preserve">
          <source>Here is a brief description of the syntax of this file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5105a9eca2c2d760c9113cca77cea941a304a915" translate="yes" xml:space="preserve">
          <source>Here is a recursive case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18950c0f655cc85f7d1a80526879f141a4d6d368" translate="yes" xml:space="preserve">
          <source>Here is a reduced representation for &lt;code&gt;Tree&lt;/code&gt; with nearly all meta-information removed, for now keeping only the most essential aspects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28fb01aed2be37a9164cef272d31b4a46e6c1038" translate="yes" xml:space="preserve">
          <source>Here is a simple (albeit contrived) example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e51f8f8c6252d41c390512eb60cd71252079ee" translate="yes" xml:space="preserve">
          <source>Here is a simple non-recursive case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d55f3cbfa08c1d6611de1d00732137a0861eda" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;mdo&lt;/code&gt;-expression, and its translation to &lt;code&gt;rec&lt;/code&gt; blocks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3922bbc09781ebd37624e0cd064a9ad42e44e9" translate="yes" xml:space="preserve">
          <source>Here is an example of a program with a couple of SCCs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe44385b028eb6afad10373c4fd9bacc89b3246" translate="yes" xml:space="preserve">
          <source>Here is an example of how one can derive &lt;code&gt;Lift&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c0fbe0a0af6bebfb37d12467531a81c8a76ffa" translate="yes" xml:space="preserve">
          <source>Here is an example of this in action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5870318040b4cbc35ef0a6a189cf2b6b2009b5dc" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level numeric literals to provide a safe interface to a low-level function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae619abf546c35dc2c1fbfcf0f55d35804f8535" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level string literals to simulate simple record operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff9206b7ffb5ba70efe3f04ba78d877b18348c4" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; data type with the &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b381c025413f1d67c38ee5f2502e185d0fb7d3" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom error data type with the &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">Вот пример:</target>
        </trans-unit>
        <trans-unit id="535dae368fdcd63238ee3ab417dc08f09f956a7e" translate="yes" xml:space="preserve">
          <source>Here is an extension of the record access example in &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt; showing how an overloaded label can be used as a record selector:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784d5081f398d0ca7b17da03a0bb36a22a2ccb4a" translate="yes" xml:space="preserve">
          <source>Here is what this example does:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578112844f2ecfeb7d7b37c0671697fae621d8a3" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Eq [a]&lt;/code&gt; in the signature overlaps with the top-level instance for &lt;code&gt;Eq [a]&lt;/code&gt;. GHC goes to some efforts to use the former, but if it should use the latter, it would then have an insoluble &lt;code&gt;Eq a&lt;/code&gt; constraint. Best avoided by instead writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c371834414978339130daf2ead6f2a828c5e1113" translate="yes" xml:space="preserve">
          <source>Here the call to &lt;code&gt;(==)&lt;/code&gt; makes GHC think that the &lt;code&gt;(Eq a)&lt;/code&gt; constraint is needed, so no warning is issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0780d7d3b68e7e37a7a3d46a9b887e1652449c4c" translate="yes" xml:space="preserve">
          <source>Here the definition of &lt;code&gt;id&lt;/code&gt; will be rejected because type variable &lt;code&gt;t&lt;/code&gt; appears only under type family applications and is thus ambiguous. But this code will be accepted if we tell GHC that &lt;code&gt;Id&lt;/code&gt; is injective, which means it will be possible to infer &lt;code&gt;t&lt;/code&gt; at call sites from the type of the argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb28975e9efa83a5c3e0e5ff9c5c0721160939d1" translate="yes" xml:space="preserve">
          <source>Here the signature in the instance declaration is more polymorphic than that required by the instantiated class method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63289520236e8e709917ef260fdeb154c06ebad" translate="yes" xml:space="preserve">
          <source>Here the superclass cycle does terminate but it&amp;rsquo;s not entirely straightforward to see that it does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b4dc560bdf4032142e8540022e116649150a8cf" translate="yes" xml:space="preserve">
          <source>Here the type signature on the expression can be pushed inwards to give a type signature for f. Similarly, and more commonly, one can give a type signature for the function itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36ee31bac07794278327e4cd5b5ef2a73c1d649" translate="yes" xml:space="preserve">
          <source>Here the type variable &lt;code&gt;a&lt;/code&gt; does not appear in the result type of either constructor. Although it is universally quantified in the type of the constructor, such a type variable is often called &amp;ldquo;existential&amp;rdquo;. Indeed, the above declaration declares precisely the same type as the &lt;code&gt;data Foo&lt;/code&gt; in &lt;a href=&quot;#existential-quantification&quot;&gt;Existentially quantified data constructors&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871671537306449b461ce4b0a7359a84ae8901b9" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on Trac #14998.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2389ab12d149719f8b2ae9fd37c6e9f5221e6a85" translate="yes" xml:space="preserve">
          <source>Here we cannot derive the instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ae36999c62764581c349a16fd30283eb606e25" translate="yes" xml:space="preserve">
          <source>Here we do not need to give a type signature to &lt;code&gt;w&lt;/code&gt;, because it is an argument of constructor &lt;code&gt;T1&lt;/code&gt; and that tells GHC all it needs to know.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7e465fc20c2c4537d95dc677ec8ee61bfb8cc2" translate="yes" xml:space="preserve">
          <source>Here we give two data instance declarations, one in which the last parameter is &lt;code&gt;[v]&lt;/code&gt;, and one for which it is &lt;code&gt;Int&lt;/code&gt;. Since you cannot give any &lt;em&gt;subsequent&lt;/em&gt; instances for &lt;code&gt;(GMap Flob ...)&lt;/code&gt;, this facility is most useful when the free indexed parameter is of a kind with a finite number of alternatives (unlike &lt;code&gt;Type&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb8ea8d6762e5ffea3bc702011bc02d989b8554" translate="yes" xml:space="preserve">
          <source>Here we have used the runtime system&amp;rsquo;s &lt;code&gt;-V0&lt;/code&gt; option to disable the RTS&amp;rsquo;s periodic timer which may interfere with our debugging session. Upon breaking into the program &lt;code&gt;gdb&lt;/code&gt; shows us a location in our source program corresponding to the current point of execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3afdf03ab0d6bca83111ae2999d98d94e34ee27" translate="yes" xml:space="preserve">
          <source>Here we make use of the &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a886cd62bbad757f26446c67a18256a063af6b3" translate="yes" xml:space="preserve">
          <source>Here we notice the first bit of the stack trace has many unidentified stack frames at address &lt;code&gt;0x006eb0c0&lt;/code&gt;. If we ask &lt;code&gt;gdb&lt;/code&gt; about this location, we find that these frames are actually STG update closures,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488b44824899a32a3b4c8c755fe86357e03b142e" translate="yes" xml:space="preserve">
          <source>Here we use &lt;code&gt;calculateLength&lt;/code&gt; by making it to pass its result to &lt;code&gt;print&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ec54bf728aec9e4101e212b40848364c009d88" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;a href=&quot;#class-default-signatures&quot;&gt;default signature&lt;/a&gt; to specify that the user does not have to provide an implementation for &lt;code&gt;put&lt;/code&gt;, as long as there is a &lt;code&gt;Generic&lt;/code&gt; instance for the type to instantiate. For the &lt;code&gt;UserTree&lt;/code&gt; type, for instance, the user can just write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbee547f7180c83e7a6749bef178b8c2b89e5ea0" translate="yes" xml:space="preserve">
          <source>Here we used the &lt;code&gt;-g&lt;/code&gt; option to inform GHC that it should add debugging information in the produced binary. There are three levels of debugging output: &lt;code&gt;-g0&lt;/code&gt; (no debugging information, the default), &lt;code&gt;-g1&lt;/code&gt; (sufficient for basic backtraces), &lt;code&gt;-g2&lt;/code&gt; (or just &lt;code&gt;-g&lt;/code&gt; for short; emitting everything GHC knows). Note that this debugging information does not affect the optimizations performed by GHC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e42929be7de1f61c123076ae26c4541b6debae" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a command that takes an argument. It&amp;rsquo;s a re-implementation of &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4acf1f68d1ec65b2583dd0678b0010301a2d55c6" translate="yes" xml:space="preserve">
          <source>Here's a rule of thumb for deciding which catch-style function to use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a4a684360c29ba16a972e43ea2e7da727acaed" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(!:)&lt;/code&gt; is a recursive function that indexes arrays of type &lt;code&gt;Arr e&lt;/code&gt;. Consider a call to &lt;code&gt;(!:)&lt;/code&gt; at type &lt;code&gt;(Int,Int)&lt;/code&gt;. The second specialisation will fire, and the specialised function will be inlined. It has two calls to &lt;code&gt;(!:)&lt;/code&gt;, both at type &lt;code&gt;Int&lt;/code&gt;. Both these calls fire the first specialisation, whose body is also inlined. The result is a type-based unrolling of the indexing function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d758383a9a92043fe5183bea22cf4899f5af4a1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; packages an integer with a function &lt;code&gt;even&lt;/code&gt; that maps an integer to &lt;code&gt;Bool&lt;/code&gt;; and &lt;code&gt;MkFoo 'c'
isUpper&lt;/code&gt; packages a character with a compatible function. These two things are each of type &lt;code&gt;Foo&lt;/code&gt; and can be put in a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5517fa5111843903c7c77f59041df2d9a2ca820f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; is a type-level proxy that does not have any associated values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f15a44a2381b42f996544079219567c930d6553" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Adder&lt;/code&gt; is the name of the root module in the module tree (as mentioned above, there must be a single root module, and hence a single module tree in the DLL). Compile everything up:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53104e9ecb02cbdb4ecf1e67b8e325444d3f1eb" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;C&lt;/code&gt; is a superclass of &lt;code&gt;D&lt;/code&gt;, but it&amp;rsquo;s OK for a class operation &lt;code&gt;op&lt;/code&gt; of &lt;code&gt;C&lt;/code&gt; to mention &lt;code&gt;D&lt;/code&gt;. (It would not be OK for &lt;code&gt;D&lt;/code&gt; to be a superclass of &lt;code&gt;C&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525ca7533aa751d8d94cbfeb12f8015edba62f9e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;a&lt;/code&gt; is imported, and &lt;code&gt;c&lt;/code&gt; is bound at top level, so neither contribute to the expansion of the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo;. The motivation here is that it should be easy for the reader to figure out what the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822db033e370efbb31959c405529a4c4c05b2667" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;g1&lt;/code&gt; are rank-1 types, and can be written in standard Haskell (e.g. &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt;). The &lt;code&gt;forall&lt;/code&gt; makes explicit the universal quantification that is implicitly added by Haskell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d071a90d49169c0a3e8d456b4967a92a718fd1e4" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f2&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt; but not in &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a370b87ed8c118346ca1a94d53f0f726f6b04d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f3&lt;/code&gt; and &lt;code&gt;f4&lt;/code&gt; are identical; putting a bang before a pattern that forces evaluation anyway does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65a0ece61fefd2d00d0da0d24e0dfd8498a8191" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9559bc1d51eb924585ebc31815ff13fbf5ec88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;lookup&lt;/code&gt; is declared &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt;, but it cannot be specialised for type &lt;code&gt;T&lt;/code&gt; at its definition site, because that type does not exist yet. Instead a client module can define &lt;code&gt;T&lt;/code&gt; and then specialise &lt;code&gt;lookup&lt;/code&gt; at that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34766b2e0766ed22f1c9cb7f203525612e940b47" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;m x&lt;/code&gt; depends on the value of &lt;code&gt;x&lt;/code&gt; produced by the first statement, so the expression cannot be translated using &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b4a2ef77ba3c50370d37583f31a5be57b46894" translate="yes" xml:space="preserve">
          <source>Here, a value of type &lt;code&gt;NumInst a&lt;/code&gt; is equivalent to an explicit &lt;code&gt;(Num a)&lt;/code&gt; dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb49fc1ba82e874567baa5a0ecc23830d8c61be" translate="yes" xml:space="preserve">
          <source>Here, after GHC inlines the body of &lt;code&gt;foldl&lt;/code&gt; to a call site, it will perform call-pattern specialisation very aggressively on &lt;code&gt;foldl_loop&lt;/code&gt; due to the use of &lt;code&gt;SPEC&lt;/code&gt; in the argument of the loop body. &lt;code&gt;SPEC&lt;/code&gt; from &lt;code&gt;GHC.Types&lt;/code&gt; is specifically recognised by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a46da6469aa7d877a4dc019b4026c861a1827c" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s kind pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c488bb6442c8bfe3891b456a0f20d4c493678b2" translate="yes" xml:space="preserve">
          <source>Here, it is evident that attempting to use the type &lt;code&gt;T Loop&lt;/code&gt; will throw the typechecker into an infinite loop, as its definition recurses endlessly. In other cases, you might need to enable &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; even if the generated code won&amp;rsquo;t put the typechecker into a loop. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c4e32b86bb284d5a60b6c3cdd6f27f34dd9bca" translate="yes" xml:space="preserve">
          <source>Here, neither &lt;code&gt;D&lt;/code&gt; nor &lt;code&gt;T&lt;/code&gt; is declared in module &lt;code&gt;Orphan&lt;/code&gt;. We call such modules &amp;ldquo;orphan modules&amp;rdquo;. GHC identifies orphan modules, and visits the interface file of every orphan module below the module being compiled. This is usually wasted work, but there is no avoiding it. You should therefore do your best to have as few orphan modules as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e284f329aaa0b1d6c1613a8401892863365a886" translate="yes" xml:space="preserve">
          <source>Here, only &lt;code&gt;b&lt;/code&gt; is levity polymorphic. There are no variables with a levity-polymorphic type. And the code generator has no trouble with this. Indeed, this is the true type of GHC&amp;rsquo;s &lt;code&gt;$&lt;/code&gt; operator, slightly more general than the Haskell 98 version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b5d58882f8e59923897d88bfc5d873faefaaa3" translate="yes" xml:space="preserve">
          <source>Here, the pattern signatures for &lt;code&gt;ys&lt;/code&gt; and &lt;code&gt;zs&lt;/code&gt; are fine, but the one for &lt;code&gt;v&lt;/code&gt; is not because &lt;code&gt;b&lt;/code&gt; is not in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fd0ff1134c3450c4876a8a1789e7f8711d1446" translate="yes" xml:space="preserve">
          <source>Here, the pattern type signature &lt;code&gt;[t::a]&lt;/code&gt; mentions a lexical type variable that is not already in scope. Indeed, it &lt;em&gt;must not&lt;/em&gt; already be in scope, because it is bound by the pattern match. The effect is to bring it into scope, standing for the existentially-bound type variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bdce5ce5dbc2679c8b93240f55e76cb9b685ca9" translate="yes" xml:space="preserve">
          <source>Here, the quantified constraint &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; behaves a bit like a local instance declaration, and makes the instance typeable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c090bb2c03f8b4d1d81b664c6c433e2433be0999" translate="yes" xml:space="preserve">
          <source>Here, the right-hand side of the data instance mentions the type variable &lt;code&gt;d&lt;/code&gt; that does not occur in its left-hand side. We cannot admit such data instances as they would compromise type safety.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4418932eacd33c51523f80d662c6aae5a1a8913" translate="yes" xml:space="preserve">
          <source>Here, the type bound by &lt;code&gt;MkFoo&lt;/code&gt; &amp;ldquo;escapes&amp;rdquo;, because &lt;code&gt;a&lt;/code&gt; is the result of &lt;code&gt;f1&lt;/code&gt;. One way to see why this is wrong is to ask what type &lt;code&gt;f1&lt;/code&gt; has:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ced41f435896f3835e3f3db385a593236b5ec7" translate="yes" xml:space="preserve">
          <source>Here, the type signature &lt;code&gt;forall s. ST s Bool&lt;/code&gt; brings the type variable &lt;code&gt;s&lt;/code&gt; into scope, in the annotated expression &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4651a64ece58d66fdaa4f04e3c286eafc03da8" translate="yes" xml:space="preserve">
          <source>HexFloatLiterals</source>
          <target state="translated">HexFloatLiterals</target>
        </trans-unit>
        <trans-unit id="11a841be90249e5ae1849d3a9dba8043e7e8343e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09789d874bf0321af31ee0c488ee82ce979a4fc" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676e2bd2392778df9648ce9b835686f2ab072c23" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3393a2a683412902536f7d98b83a3d288d91c93" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accee792a95e9e1c8fe72eb8b06937ee9369fa1e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ad5ace69a8a8ba3fb3a937ad28617759385a28" translate="yes" xml:space="preserve">
          <source>Hexadecimal numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b3e0f65de320839723c279978dd47f65d6150a" translate="yes" xml:space="preserve">
          <source>Hidden packages (those for which the &lt;code&gt;exposed&lt;/code&gt; flag is &lt;code&gt;False&lt;/code&gt;) are shown in parentheses in the list of packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6062001c6bab0163b0a4b2529719b8bde4b508" translate="yes" xml:space="preserve">
          <source>Hide all packages by default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feef4327e8cde9c994f26b136ddb595802f03d1c" translate="yes" xml:space="preserve">
          <source>Hide all packages for plugins by default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec916c3e8ddb513e159b7a5e33949a183f39cac6" translate="yes" xml:space="preserve">
          <source>Hide package ⟨pkg⟩</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd735044c33670955e5379d6a592895b1193122" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2e4337cf1098bf05ffcad5c2206b7483c99a77" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="2d84546cb2321a589250e0442876d448b09183af" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e46fa97c09f5c0c83b2e88f3881c7a3e4f4f7c" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="807422feeeae1e65868373709a1281920ada2d92" translate="yes" xml:space="preserve">
          <source>Holding a &lt;code&gt;Weak ThreadId&lt;/code&gt;, on the other hand, will not prevent the thread from receiving &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions. It is still possible to throw an exception to a &lt;code&gt;Weak ThreadId&lt;/code&gt;, but the caller must use &lt;code&gt;deRefWeak&lt;/code&gt; first to determine whether the thread still exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d098c08c4ae6f34d5c4821e087cb66e14f878118" translate="yes" xml:space="preserve">
          <source>Home directory (pw_dir)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca79641b581fd367113ced98f70f47d0abeb2c8" translate="yes" xml:space="preserve">
          <source>Homomorphism</source>
          <target state="translated">Homomorphism</target>
        </trans-unit>
        <trans-unit id="78abe60fa7d802d62efa64043a705bae7407a631" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned decoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c639806398d26813e0fb48c1ebdba5cd82bf177b" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned writes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a0f916e4e9bfcfeeae189f694538c5874f3603" translate="yes" xml:space="preserve">
          <source>Host-specific binary encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7fcd531348b3bb6fd008f425ab3f45a52aad77" translate="yes" xml:space="preserve">
          <source>HotLink</source>
          <target state="translated">HotLink</target>
        </trans-unit>
        <trans-unit id="f9cb8d909445ac44cd2fd5ac585df15ae8f92ebf" translate="yes" xml:space="preserve">
          <source>Hotlinks</source>
          <target state="translated">Hotlinks</target>
        </trans-unit>
        <trans-unit id="24af6649766c375876b6b100497556d3aa591028" translate="yes" xml:space="preserve">
          <source>Hour twelve</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b758819da040d3f055ca34119b72fa2b2d6747" translate="yes" xml:space="preserve">
          <source>Hour zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21e7b28bb4ec8bce45d51234ba921345ac168b2" translate="yes" xml:space="preserve">
          <source>How does the heap residency reported by the heap profiler relate to the actual memory residency of your program when you run it? You might see a large discrepancy between the residency reported by the heap profiler, and the residency reported by tools on your system (eg. &lt;code&gt;ps&lt;/code&gt; or &lt;code&gt;top&lt;/code&gt; on Unix, or the Task Manager on Windows). There are several reasons for this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1927f75bb049c830748f2729f0038bde12efc0c1" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline dictionaries?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a1c6fc2034630838e97a64d94b3af46c9319cd" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline functions?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fb79d40430db562ab3ac45f29bc78e66d5fe1c" translate="yes" xml:space="preserve">
          <source>How long the program has been running (CPU time and elapsed wall clock time).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917d1059c1e62cf270bb88e3227c70dfbd432932" translate="yes" xml:space="preserve">
          <source>How long this garbage collection took (CPU time and elapsed wall clock time).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c6b03bfc8f9cb787a541e4b6548f8ac93d5025" translate="yes" xml:space="preserve">
          <source>How many bytes are currently live.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01af7076602466fb2dd0d00c85e7ba87a68dda6f" translate="yes" xml:space="preserve">
          <source>How many bytes did the program allocate while inside of this cost-centre? This does not include allocations while in child cost-centres.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ee2b37aca604bce9e3efa4a6ecb13d165e0be0" translate="yes" xml:space="preserve">
          <source>How many bytes to read</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce115a90f4bba549deae5cc5d88db46fb3644d7" translate="yes" xml:space="preserve">
          <source>How many bytes we allocated this garbage collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b589f57e5f67f3a65c8a115f4df2b5dfeb110e4" translate="yes" xml:space="preserve">
          <source>How many bytes we copied this garbage collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3e1b1a1b256a5e6dd2b8ae3a5665856b88bb55" translate="yes" xml:space="preserve">
          <source>How many capabilities the program was started with (e.g. using the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option). Note that the number of capabilities may change during execution due to the &lt;code&gt;setNumCapabilities&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9b9ae41e95b919cfc203a74328458cee852026" translate="yes" xml:space="preserve">
          <source>How many page faults occurred since the end of the last garbage collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0ec711a7a2aca8bf80c57d5b99771cc152f07c" translate="yes" xml:space="preserve">
          <source>How many page faults occurred this garbage collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee49e11e7b07eb02b05621505c38a7360c70468d" translate="yes" xml:space="preserve">
          <source>How many profiler &amp;ldquo;ticks&amp;rdquo; elapsed over the course of the program&amp;rsquo;s execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0f356fd0d39a80e2dc0473264e53a3f5be1255" translate="yes" xml:space="preserve">
          <source>How many stack frames in the given &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff13443abfdd5f6196035361c4d9c8b1b84e9e8" translate="yes" xml:space="preserve">
          <source>How many ticks was the program&amp;rsquo;s execution inside of this cost-centre? This does not include child cost-centres.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8938746f1911b57d597b21fb5c265320965f8d" translate="yes" xml:space="preserve">
          <source>How many times was this cost-centre entered?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6758180b138745f6df61fe36255468b563201977" translate="yes" xml:space="preserve">
          <source>How much time between profiler ticks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc67db788a397c6ce747c2f5326f08e707314b58" translate="yes" xml:space="preserve">
          <source>How to determine stderr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dec927eb4441c4b466135f3fe2523a9b41513ff" translate="yes" xml:space="preserve">
          <source>How to determine stdin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c69a711aceee10fc43cfaec8ddc771d114f1fc" translate="yes" xml:space="preserve">
          <source>How to determine stdout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e3b28c9f66467f3782a09db7380eb03a095bea" translate="yes" xml:space="preserve">
          <source>How to handle the sign of a numeric field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d91c4a03978824020eb2d8b5470646f57802ab" translate="yes" xml:space="preserve">
          <source>However if you use &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt;, then GHC instead uses whatever is in scope with the names of &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt;. That is, these functions are rebindable; c.f. &lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6040c9b47e1b3417452306269aaf1ff946d1bdd0" translate="yes" xml:space="preserve">
          <source>However see &lt;a href=&quot;ghci#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt; for the overlap rules in GHCi.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d3f3db18b261148fadac31985fc664c11dd948" translate="yes" xml:space="preserve">
          <source>However take care that the generated definitions are still in the input of &lt;code&gt;typeCheckResultAction&lt;/code&gt;. If your don&amp;rsquo;t take care to filter the typechecked input, the behavior of your tool might be inconsistent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d170d05fd2a443fae748aa5bc3ef7be0adca547e" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc54057c2f535150522eb952fec80397f100d689" translate="yes" xml:space="preserve">
          <source>However using Debug.Trace.trace is alright because it uses Windows debugging output support rather than &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8025ea24ecfecdd0f3e045637833ba460a0d7ea" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; creates a &lt;em&gt;bound&lt;/em&gt; thread, which is necessary if you need to call foreign (non-Haskell) libraries that make use of thread-local state, such as OpenGL (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98e07fdef4dfe8b0cb3689c59c1f96f6cc38a2e" translate="yes" xml:space="preserve">
          <source>However, &lt;em&gt;nested&lt;/em&gt; bangs in a let/where pattern binding behave uniformly with all other forms of pattern matching. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f527eafccf9b322040b38f8d30b103c69e2e35" translate="yes" xml:space="preserve">
          <source>However, apart from these restrictions, many things are allowed, including expressions which are not fully evaluated! Annotation expressions will be evaluated by the compiler just like Template Haskell splices are. So, this annotation is fine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8194ed59efdaf1498fbfe96f3c1af7f347e02a51" translate="yes" xml:space="preserve">
          <source>However, because GHC must &lt;em&gt;infer&lt;/em&gt; the type when part of a type is left out, it is unable to use polymorphic recursion. The same restriction takes place when the type signature is omitted completely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc0cb9f7adb2ad4d1a50c3ef7d1d89e881714f8" translate="yes" xml:space="preserve">
          <source>However, by a simple extension to the type class system of Haskell, we can support dynamic binding. Basically, we express the use of a dynamically bound variable as a constraint on the type. These constraints lead to types of the form &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt;, which says &amp;ldquo;this function uses a dynamically-bound variable &lt;code&gt;?x&lt;/code&gt; of type &lt;code&gt;t'&lt;/code&gt;&amp;rdquo;. For example, the following expresses the type of a sort function, implicitly parameterised by a comparison function named &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a905a90165b9acad9dcb4130ba63d5758f8a8d3c" translate="yes" xml:space="preserve">
          <source>However, consider the following example:</source>
          <target state="translated">Однако,рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="e08e1079e26d8ee5d64f16ab7646e745157e03bd" translate="yes" xml:space="preserve">
          <source>However, enabling the &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension allows the module to compile. Similar errors may occur with a variety of extensions, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8273c78a4e8dc99cc6fb13390e41af1c9b00ab" translate="yes" xml:space="preserve">
          <source>However, for GADTs there is the following additional constraint: every constructor that has a field &lt;code&gt;f&lt;/code&gt; must have the same result type (modulo alpha conversion) Hence, in the above example, we cannot merge the &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt; fields above into a single name. Although their field types are both &lt;code&gt;Term Int&lt;/code&gt;, their selector functions actually have different types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda4519b4ae553699a88736ad05de49408b09efc" translate="yes" xml:space="preserve">
          <source>However, for most applications, it should suffice to just use the &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad986013ad68059837a38c8bd173d49d68173827" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;CProv&lt;/code&gt; is non-empty, while &lt;code&gt;CReq&lt;/code&gt; is, the above pattern type signature for &lt;code&gt;P&lt;/code&gt; must be specified as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d463e6d4a25197f32ed78eb56a6036ea10aebfec" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; ends in a separator, the default databases (i.e. the user and global package databases, in that order) are appended to the path. For example, to augment the usual set of packages with a database of your own, you could say (on Unix):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967aa81a898dabc9a0655eae4604ccf80453bdf1" translate="yes" xml:space="preserve">
          <source>However, if you want to interact with a foreign library that expects your program to use the operating system-supplied thread package, you can do so by using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f6dfd00eff21ddfaf5b9214e0d18073ac349d6" translate="yes" xml:space="preserve">
          <source>However, in all patterns &lt;em&gt;other&lt;/em&gt; than pattern bindings, a pattern type signature may mention a type variable that is not in scope; in this case, &lt;em&gt;the signature brings that type variable into scope&lt;/em&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c24910fabe3813ad18d23c698dd48a88899c66" translate="yes" xml:space="preserve">
          <source>However, it appears that if you add a space at the end of the line, then &lt;code&gt;cpp&lt;/code&gt; (at least GNU &lt;code&gt;cpp&lt;/code&gt; and possibly other &lt;code&gt;cpp&lt;/code&gt;s) leaves the backslash-space pairs alone and the string gap works as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c91a74d73602f60fc3e23aaa16816234c03e5d" translate="yes" xml:space="preserve">
          <source>However, it is possible to perform a bit of &amp;ldquo;backwards&amp;rdquo; evaluation. For example, here is how we could get GHC to compute arbitrary logarithms at the type level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3a4b89e8199e4d733ca299842a306ab859485c" translate="yes" xml:space="preserve">
          <source>However, it is tiresome for the user to have to specify the type, so GHCi extends Haskell&amp;rsquo;s type-defaulting rules (Section 4.3.4 of the Haskell 2010 Report) as follows. The standard rules take each group of constraints &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; for each type variable &lt;code&gt;a&lt;/code&gt;, and defaults the type variable if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a41cd61107bf2e5acee8876cf3ea899f304dcd8" translate="yes" xml:space="preserve">
          <source>However, not all is lost. We can still do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7187323d3950a28b28f87b9f4c602a2796f69d8b" translate="yes" xml:space="preserve">
          <source>However, note that it is reasonable to have a module &lt;code&gt;Main&lt;/code&gt; in a file named &lt;code&gt;foo.hs&lt;/code&gt;, but this only works because GHC never needs to search for the interface for module &lt;code&gt;Main&lt;/code&gt; (because it is never imported). It is therefore possible to have several &lt;code&gt;Main&lt;/code&gt; modules in separate source files in the same directory, and GHC will not get confused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbd4b2fd1492cb8e585fb78fb46502a8ccda050" translate="yes" xml:space="preserve">
          <source>However, regardless of the flag setting, the quantifiers are printed under these circumstances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35326ee19484ea5250a5955bf9162649c5ce6743" translate="yes" xml:space="preserve">
          <source>However, since version 8.4 this is no longer the case: GHC &lt;strong&gt;guarantees&lt;/strong&gt; that garbage collection will never occur during an &lt;code&gt;unsafe&lt;/code&gt; call, even in the bytecode interpreter, and further guarantees that &lt;code&gt;unsafe&lt;/code&gt; calls will be performed in the calling thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3168a5cfff35597637af368edcde71624cd723d0" translate="yes" xml:space="preserve">
          <source>However, sometimes there are no such calls, in which case the pragma can be useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f1896001a515ea20b3107b6872d509be571c338" translate="yes" xml:space="preserve">
          <source>However, standalone deriving differs from a &lt;code&gt;deriving&lt;/code&gt; clause in a number of important ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ba9a199527bbadec33a09879e817a0f6de5758" translate="yes" xml:space="preserve">
          <source>However, starting with &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt;, the default implementation is based on &lt;code&gt;DefaultSignatures&lt;/code&gt; allowing for more accurate auto-derived &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; instances. If you need the previously used exact default &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; method implementation semantics, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7024ade898249c07bcf841caece72369d63586b1" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; axioms both match the wanted constraint &lt;code&gt;C a&lt;/code&gt;. There are several possible approaches for handling these overlapping local axioms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8981ad8f62f6891902d31a96ee844f6c284310" translate="yes" xml:space="preserve">
          <source>However, the instance declaration must still conform to the rules for instance termination: see &lt;a href=&quot;#instance-termination&quot;&gt;Instance termination rules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0881e26d84cd12d8c7fd2b522507d9075fd4696" translate="yes" xml:space="preserve">
          <source>However, the real implemenation uses memcmp to compare the end of the string only, with no reverse required..</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06134ece72c951c7d7c727c39885e4d66b957bb6" translate="yes" xml:space="preserve">
          <source>However, the second law is violated in the presence of undefined operators,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72bbc3e10475e3349a7633255fe25a94534717f" translate="yes" xml:space="preserve">
          <source>However, the two terms are certainly related. By making use of multiple CPUs it is possible to run concurrent threads in parallel, and this is exactly what GHC&amp;rsquo;s SMP parallelism support does. But it is also possible to obtain performance improvements with parallelism on programs that do not use concurrency. This section describes how to use GHC to compile and run parallel programs, in &lt;a href=&quot;parallel#lang-parallel&quot;&gt;Concurrent and Parallel Haskell&lt;/a&gt; we describe the language features that affect parallelism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d7fb9afd1affd6fb2291bb8b2736b5c57061fb" translate="yes" xml:space="preserve">
          <source>However, the unrestricted use of &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; is a problem as an arbitrary module can use it to mark themselves as trusted, yet &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t offer any guarantees about the module, unlike &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. To control the use of trustworthy modules it is recommended to use the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag. This flag adds an extra requirement to the trust check for trustworthy modules. It requires that for a trustworthy modules to be considered trusted, and allowed to be used in &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; compiled code, the client C compiling the code must tell GHC that they trust the package the trustworthy module resides in. This is essentially a way of for C to say, while this package contains trustworthy modules that can be used by untrusted modules compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, I trust the author(s) of this package and trust the modules only expose a safe API. The trust of a package can be changed at any time, so if a vulnerability found in a package, C can declare that package untrusted so that any future compilation against that package would fail. For a more detailed overview of this mechanism see &lt;a href=&quot;#safe-trust&quot;&gt;Trust and Safe Haskell Modes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b532bdc7013089e7dc2ea095365363430246167b" translate="yes" xml:space="preserve">
          <source>However, there are a couple of problems with this approach. The first is that having two exception handlers is inefficient. However, the more serious issue is that the second exception handler will catch exceptions in the first, e.g. in the example above, if &lt;code&gt;handleArith&lt;/code&gt; throws an &lt;code&gt;IOException&lt;/code&gt; then the second exception handler will catch it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ee23f1fd11c8d62aeb9eeee086197709f0be7d" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c11995af9963ba10b5fec5e359b15b835f98697" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef09da657ffc9d4af89d0f416150551e096de936" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36debdedc3fc8b9fe245012b3b2d0f8a8b3e2720" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e5a60e9a91ca4a5044b3e556c3f51ba02637a2" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5fe8ac3752b514477ab6da6483511ccc949a4e" translate="yes" xml:space="preserve">
          <source>However, this quickly gets tedious when defining functions with multiple clauses, or groups of mutually recursive functions, because the complete definition has to be given on a single line, using explicit semicolons instead of layout:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c072dae816d58a4bbbf3253aaac2ff2d7bee49e" translate="yes" xml:space="preserve">
          <source>However, this would not be permitted, because &lt;code&gt;x&lt;/code&gt; is ambiguous:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6a6176295d69c876f06979d7fd1959a45e1552" translate="yes" xml:space="preserve">
          <source>However, type class instances of instances of data families can be defined much like any other data type. For example, we can say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67eb60c225421062cda3e126bd114e249c145db9" translate="yes" xml:space="preserve">
          <source>However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver. Thus the following is ambiguous:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d46b3249f71b533cad63e9708c9fb1563db8ccc" translate="yes" xml:space="preserve">
          <source>However, with &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; set to e.g. &lt;code&gt;1&lt;/code&gt;, it will additionally offer up a list of refinement hole fits, in this case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1c33bc1108d9b6ddb6ca92ba69a2740518cc11" translate="yes" xml:space="preserve">
          <source>HpcHash</source>
          <target state="translated">HpcHash</target>
        </trans-unit>
        <trans-unit id="a360e1a8abea3420612de3ead3619643eba9cb5b" translate="yes" xml:space="preserve">
          <source>HpcPos</source>
          <target state="translated">HpcPos</target>
        </trans-unit>
        <trans-unit id="e4d5ebe01dfadab7c70f17122ef7cd34dd84d2c8" translate="yes" xml:space="preserve">
          <source>Html</source>
          <target state="translated">Html</target>
        </trans-unit>
        <trans-unit id="124fd6e6c83b9f6fb819bac633416da6be7be061" translate="yes" xml:space="preserve">
          <source>Html abbreviations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52dad2394901ae9e2d9331b3f2acf8d98f94c3d" translate="yes" xml:space="preserve">
          <source>Html colors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61902ef6ccfb44a18ca2dc1621601009523e9eaa" translate="yes" xml:space="preserve">
          <source>HtmlAttr</source>
          <target state="translated">HtmlAttr</target>
        </trans-unit>
        <trans-unit id="1a8747bf93f58314ba9284567291634cad2df306" translate="yes" xml:space="preserve">
          <source>HtmlTable</source>
          <target state="translated">HtmlTable</target>
        </trans-unit>
        <trans-unit id="869a30d95c70a8d903e6df744e122731cf7e1681" translate="yes" xml:space="preserve">
          <source>HtmlTree</source>
          <target state="translated">HtmlTree</target>
        </trans-unit>
        <trans-unit id="67e7f16393df9e1a3f34effee9614b452216e036" translate="yes" xml:space="preserve">
          <source>I/O error that is programmer-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be281ef8dae874dacda5f49b4225eb1d24483701" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1a6c7e94bc5323e2b6ac2224ee418279aeb634" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf116efd8157c9a3bd761c2360aee94f0bc67d1a" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments is a single-use resource, which is already being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc128e1a7374671fae3700b7cd3ca03b1ae3b58e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the device is full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f8e3fdaff7cb3366cae3acc6a3cd527d98dbd3" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the end of file has been reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23225f523b6fe0da8418987860224d2674cecc83" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4923b264f73fffadc5e3e140e95a5e90f4234f9e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation is not possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2341b3a2667883fa17fd8660410d5080e25605" translate="yes" xml:space="preserve">
          <source>I/O errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893f42dbf3b6c3880cae0f711ab5e68ed55c84da" translate="yes" xml:space="preserve">
          <source>I/O operations required for implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010704f655d5ffc0ec746349b6abc0e90227f6a7" translate="yes" xml:space="preserve">
          <source>I/O with &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad04b3f0bd847573f914feec3f998fe1fbf5895a" translate="yes" xml:space="preserve">
          <source>I/O with Handles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc124dc3f9258dc88e844ea4ab0c049f8122496" translate="yes" xml:space="preserve">
          <source>I16</source>
          <target state="translated">I16</target>
        </trans-unit>
        <trans-unit id="eee5fb69722aeae0ef4402237b3281ea912a11ad" translate="yes" xml:space="preserve">
          <source>ID of group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a94d7992e803328c642d1ab3fa274462915c38" translate="yes" xml:space="preserve">
          <source>ID of owner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb496c44e36ef77af848cbdb3f2ef6feaf4502e" translate="yes" xml:space="preserve">
          <source>ID of the device on which this file resides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2fe63e5a32cb2596d9f60d2ae271ae4d1c1787" translate="yes" xml:space="preserve">
          <source>INPUT</source>
          <target state="translated">INPUT</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="556d134b3ad4c3f832238864ee9ed1a9fff795e3" translate="yes" xml:space="preserve">
          <source>INT32</source>
          <target state="translated">INT32</target>
        </trans-unit>
        <trans-unit id="c35391cc7b82f6ccca4793a8e8e896ee6abb21d2" translate="yes" xml:space="preserve">
          <source>INT64</source>
          <target state="translated">INT64</target>
        </trans-unit>
        <trans-unit id="68e53a5693c9fc9b9b1250288b7552cd0ff0e2f9" translate="yes" xml:space="preserve">
          <source>INT_PTR</source>
          <target state="translated">INT_PTR</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="221a35a7e847cc97cca77325d3f3ad369c03402f" translate="yes" xml:space="preserve">
          <source>IO functions for serialisation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc004908b1b2245fb78beda6015345ffd34734b1" translate="yes" xml:space="preserve">
          <source>IO-related Exception types and functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e51b2fc5f7179682d0416f025521af63af3bff" translate="yes" xml:space="preserve">
          <source>IOArray</source>
          <target state="translated">IOArray</target>
        </trans-unit>
        <trans-unit id="c6a99f18754ec17dc03dabc42173c7669bade008" translate="yes" xml:space="preserve">
          <source>IOCallback</source>
          <target state="translated">IOCallback</target>
        </trans-unit>
        <trans-unit id="e37f3b10503e6237389797302777a6702097cc50" translate="yes" xml:space="preserve">
          <source>IODevice</source>
          <target state="translated">IODevice</target>
        </trans-unit>
        <trans-unit id="de20e3fa4c9228ace3c0f6bf748ad0bbf5c271d9" translate="yes" xml:space="preserve">
          <source>IODeviceType</source>
          <target state="translated">IODeviceType</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="08d5912d3126b1dfb78f32fc53ee4cb092bb66d6" translate="yes" xml:space="preserve">
          <source>IOErrorType</source>
          <target state="translated">IOErrorType</target>
        </trans-unit>
        <trans-unit id="319a21ad8b671794467e4935946062d4d1e04338" translate="yes" xml:space="preserve">
          <source>IOException</source>
          <target state="translated">IOException</target>
        </trans-unit>
        <trans-unit id="6eeb7a443b8d1cc8717295647ffb6fceb48316d4" translate="yes" xml:space="preserve">
          <source>IOMode</source>
          <target state="translated">IOMode</target>
        </trans-unit>
        <trans-unit id="b772fdda8de2d1e1a2fcd9af43fda137f1082681" translate="yes" xml:space="preserve">
          <source>IORef</source>
          <target state="translated">IORef</target>
        </trans-unit>
        <trans-unit id="268db2ac8f4f524b89d42b5ab6cac600af62f822" translate="yes" xml:space="preserve">
          <source>IORefs</source>
          <target state="translated">IORefs</target>
        </trans-unit>
        <trans-unit id="4c3aab79c94196e8852e03490d73a55b7f5049e7" translate="yes" xml:space="preserve">
          <source>IOUArray</source>
          <target state="translated">IOUArray</target>
        </trans-unit>
        <trans-unit id="e10a87d05825ac01e14764ed94abba63697418fb" translate="yes" xml:space="preserve">
          <source>IQList</source>
          <target state="translated">IQList</target>
        </trans-unit>
        <trans-unit id="820a25194dff0d9c02f82ba8b6ba428cf8fc6422" translate="yes" xml:space="preserve">
          <source>IQNil</source>
          <target state="translated">IQNil</target>
        </trans-unit>
        <trans-unit id="7567d31e648220ce233abc256ecdab6241e5ddca" translate="yes" xml:space="preserve">
          <source>ISO 8601 Ordinal Date format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f822119fe2f0a8362181618c06cbbe9eb1102060" translate="yes" xml:space="preserve">
          <source>ISO 8601 Week Date format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce553dbefd4b35500c8adfaf562f347bd1cffaf1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.3. Omit hyphens and colons. &quot;The basic format should be avoided in plain text.&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b73e3fe248bf6961ea567329e7f53034196b781" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.4. Use hyphens and colons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6af556d4876a2b89f040fff7abb59f4dd0f4c1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65fa90d60515a8ea4b8b6bba5111ddac2a89a577" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(a)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e6c45635e6a6c7b99751a00199842c95a39f56" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(b)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6b8fd39d751d5c0fc381e79557a67b538bd22a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(c)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d58b1b77840944ae450aa457ab0e6e3c750344" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(a)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50049f60c0a8e8cd5b1d15d9787aba4c4ae639f0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(b)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06f9cca67b57ce453f249d30d73e9c7f581681a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(c)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813aaac22f2045f777c991dc639bff2d89abd533" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(d)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72acd19bfc93f68e206e6c0d34917114a1fccd3e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f13144d5ece5d74d8b6f96aa24edc61eeacd8ad" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6b94afc9edd9404ea266217015cf416121eae0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87736cb0c925b16cdeae6f6fe9b3e015c30590f" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcf342f586bebce46006d4c12d16ad8863024f4" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.2, 4.2.2.4(a)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b37624da200ed73cebb71eb0a89339f3a4fba3" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(a), 4.2.2.4(b)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55ad86d1327285d355a307898cd0bcedc64b2e7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(b), 4.2.2.4(c)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f67d771cf395b85785ef48de67f6dffa701c036" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b435b23d42540df0b1bc985f1fa5204e769f0b" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fcc52df4b38af082287f6513b315a63598a3982" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5787fbc9eed85c23b6ba6c14fc91c92443851aa7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12305998507260debe9c8d6034797acfcba06193" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f903f7dfa61fd47c40e96852ca4df55e2a3b30" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bfa7627b1b505b0fc50fefcc1d485389c084e49" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0c4ca61d383b42003623a59e3a979e5caa4b98" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fafc36b5bb91f4fa0ee5d27ebce4e786ca51d48d" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.4.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb017422d2f8d4d41f4efb11d499f43cec2368e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0844a2bf2289652fa3443d5285683e93680df727" translate="yes" xml:space="preserve">
          <source>ISO/IEC 8859-1 (Char8)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ee37c4c15383ecc1c4a02446d911520642fcf8" translate="yes" xml:space="preserve">
          <source>ISO8601</source>
          <target state="translated">ISO8601</target>
        </trans-unit>
        <trans-unit id="c9cf1dd8147dc5d22c7365bdaa07b0903f6de420" translate="yes" xml:space="preserve">
          <source>ITQList</source>
          <target state="translated">ITQList</target>
        </trans-unit>
        <trans-unit id="45da9c6dee9536772c435a75e794212cc011b4e4" translate="yes" xml:space="preserve">
          <source>ITQNil</source>
          <target state="translated">ITQNil</target>
        </trans-unit>
        <trans-unit id="9a1703cf287a1d482c0b2abbe3bb64675ffdbe02" translate="yes" xml:space="preserve">
          <source>Ideally, this type would not exist at all and we would just fix the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1ef819f32725331a936d8af228a9ef343e2ecc" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt;, except that the return value does not include the function which maps keys to vertices. This version of &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; is for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ddee8d84b61e8e7c17a3d7431270c5b54e7630" translate="yes" xml:space="preserve">
          <source>Identity functor and monad. (a non-strict monad)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40415a7e74878f91a4dde01d55fe29e70b542f1" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5736ff9442788a1bd6a07a6f1942f21ee0e0ff" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7460eb65d03a49632f7e5ea228f3d10021c309c4" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036d1bdfa0b3334e329d5335dac94c3cade01124" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a8044f8b5708bc7d69f87f32e2d6115a58e170" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de31daa9296519446ec20ea71e05cfd2b2ffa509" translate="yes" xml:space="preserve">
          <source>IdentityT</source>
          <target state="translated">IdentityT</target>
        </trans-unit>
        <trans-unit id="d55cb59cae5c6bdaf9dd412febcf10b5197dca0f" translate="yes" xml:space="preserve">
          <source>Ids with special behaviour</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="7165d0bd8b8d1acf3a7959ac10d5a5fbeb953852" translate="yes" xml:space="preserve">
          <source>If (D) did not exist then (A) and (C) would still be matched, but neither is most specific. In that case, the program would be rejected, unless &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt; is enabled, in which case it would be accepted and (A) or (C) would be chosen arbitrarily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb8e98916bf04f77cda2ecb54ffffb8aeaffeca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type/kind variables can also be explicitly bound. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9178d1cdaa41cf10a914fbfe9e3f1cc2e99f91" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; is enabled, overloaded labels will be desugared using whatever &lt;code&gt;fromLabel&lt;/code&gt; function is in scope, rather than always using &lt;code&gt;GHC.OverloadedLabels.fromLabel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f41696d0e1b366335f05f546f0074d2d8f5534" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#ghc-flag--fprint-bind-result&quot;&gt;&lt;code&gt;-fprint-bind-result&lt;/code&gt;&lt;/a&gt; is set then GHCi will print the result of a statement if and only if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12298741a44a56544916fcc3d1eeb39ec79ce67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(&amp;gt;&amp;gt;)&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;(&amp;gt;&amp;gt;) = (*&amp;gt;)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d0b772579ed80acd95d06e7921caed2a9f0731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; has been specified, then the object filename is ⟨dir⟩/⟨mod⟩.⟨osuf⟩, where ⟨mod⟩ is the module name with dots replaced by slashes. GHC will silently create the necessary directory structure underneath ⟨dir⟩, if it does not already exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bec439461a8c0d2127d1c99af2a5820ee3a9cf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, each nonblank line returned by &lt;code&gt;getInputLine&lt;/code&gt; will be automatically added to the history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72c7fde1442e5a18545f8980ce1eaec5905c5e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a b&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f b c&lt;/code&gt; are both &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; then so is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94e59d7cf4d9cb8563c18691722ce11c38c079d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; is uninhabited then any &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; that holds only values of type &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; is holding no values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326c4fe588e95cc1235b78af1086ddc7bd85c512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; were not lazy, &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; would look strict in &lt;code&gt;y&lt;/code&gt; which would defeat the whole purpose of &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610f1b238432a44cf8ce8bbb88c3bf824a5dd237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; is used wrongly, then it may be that computations whose result that would otherwise be shared are re-evaluated every time they are used. Otherwise, the use of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; is safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c58158c9223c0688808fab7017305ac888c0083" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b4b2460fe3194b5c1e8e3d5532ed22dd7586f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e320f20c42c7605270530cbc8962daed664fbb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; and the line input is nonblank (i.e., is not all spaces), it will be automatically added to the history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2cf8b46ce5b4adfb311cafcd49d769949e020c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c8bbd7c753a8e36c3603f2de4d4cd2a62cd77c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;em&gt;base&lt;/em&gt;&lt;/code&gt; is a power of 2, the result will be exact. In other cases (e.g. for &lt;code&gt;&lt;em&gt;base&lt;/em&gt; = 10#&lt;/code&gt;), the result &lt;em&gt;may&lt;/em&gt; be 1 digit too large sometimes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a13e850c195084652095c4cca81184cca1bc111" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; imports multiple modules, then there will be multiple lines with &lt;code&gt;M.o&lt;/code&gt; as the target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c19c1db68e46617d35c0326dd5168514a0df2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, block until it becomes full. Then read its contents without modifying the MVar, without possibility of intervention from other threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f91e64cabad1b57cc078065479e2f730107802" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, block until it becomes full. Then remove and return its contents, and set it empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f25de3697afd87eb6d27164088e4e76d5903b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, immediately return with integer 0 and value undefined. Otherwise, return with integer 1 and contents of &lt;code&gt;MVar#&lt;/code&gt;, and set &lt;code&gt;MVar#&lt;/code&gt; empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebfef89b340df038e270ba036f34b0519cbc0ac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, immediately return with integer 0 and value undefined. Otherwise, return with integer 1 and contents of &lt;code&gt;MVar#&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de738ce23865dd45047c99b18298df90a9c1de7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is full, block until it becomes empty. Then store value arg as its new contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0ea9c86d00bfb75f1a61c6b64453776a80bc752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is full, immediately return with integer 0. Otherwise, store value arg as &lt;code&gt;MVar#&lt;/code&gt;'s new contents, and return with integer 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9bf43f23f5bb273c3cc1f6ac0c3d420ae5cb5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c87e13d090df879361d15dfa79e405cd9085828" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c2aadabafad2cf8c71f374eecfaa7c9542d06d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5275bc4d51e6899e6fad22c83eb521ad2006efe4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blk&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WNOHANG&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not. If &lt;code&gt;stopped&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WUNTRACED&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a08b722470ddafe8fb8c09c93deed2c332b705cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c98343bbca185d60c1ee11e55600855a284be984" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a539250d2be5c33120a88a56e298e7c403b47812" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eac9f125314dfa3f7885b5b45714df2e1cf5559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is both &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; then by the time you factor in the laws of each of those classes, it can't actually use its argument in any meaningful capacity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7d12845339fe8cd3cb3ac36c2fb96a946b74fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931888dcad242b41a99c52e3454ca1021c558949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906096b1295440d05beb1594c0fb7469bf723e57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805ac8206a6b088f57d9c958aae524c515330e81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9adf0f8908e10c9f90956ffd3ed4fc92f31eb5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fail&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;fail = Control.Monad.Fail.fail&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15cf615fdb6b04b2196b63a29a9332d038e92d17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hdl&lt;/code&gt; is block- or line-buffered, then seeking to a position which is not in the current buffer will first cause any items in the output buffer to be written to the device, and then cause the input buffer to be discarded. Some handles may not be seekable (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;), or only support a subset of the possible positioning operations (for instance, it may only be possible to seek to the end of a tape, or to a positive offset from the beginning or current position). It is not possible to set a negative I/O position, or for a physical file, an I/O position beyond the current end-of-file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8a6eee3327c93a8398e06086b0787394abd668" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hdl&lt;/code&gt; is block- or line-buffered, then seeking to a position which is not in the current buffer will first cause any items in the output buffer to be written to the device, and then cause the input buffer to be discarded. Some handles may not be seekable (see &lt;code&gt;&lt;a href=&quot;system-io#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;), or only support a subset of the possible positioning operations (for instance, it may only be possible to seek to the end of a tape, or to a positive offset from the beginning or current position). It is not possible to set a negative I/O position, or for a physical file, an I/O position beyond the current end-of-file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0345953305b2b9f4ea94ff39c9fed5b790ac50f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mappend&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;mappend = (Data.Semigroup.&amp;lt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb896d3d56035749898d473a3ff0398ee85a2441" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to begin inside a surrogate pair, the beginning of the suffix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860162bde8907826a2c5a3fcdedbfb920738c4b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to end inside a surrogate pair, the end of the prefix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226e4123ccd5bdaffb4ec80558af633a764b0837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nel&lt;/code&gt; is not defined, this may be built out of other capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d4d1d892b2f78b4eac4a90be4fe3562658fe6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; fails and consumes some input, so does &lt;code&gt;lookAhead&lt;/code&gt;. Combine with &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; if this is undesirable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3537d71db5bdf66b5e84e584bddb563361f13d18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; fails and consumes some input, so does &lt;code&gt;lookAhead&lt;/code&gt;. Combine with &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; if this is undesirable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ee3fdf69deef0295af859365ce7e178691bbfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;return = pure&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df692bac65da2783906b8b3e140d687e86cb3e84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sn1 :: StableName&lt;/code&gt; and &lt;code&gt;sn2 :: StableName&lt;/code&gt; and &lt;code&gt;sn1 == sn2&lt;/code&gt; then &lt;code&gt;sn1&lt;/code&gt; and &lt;code&gt;sn2&lt;/code&gt; were created by calls to &lt;code&gt;makeStableName&lt;/code&gt; on the same object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ad7372f58041f5b2d3a204387a830ce9ae4dd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; is less than zero, then &lt;code&gt;hWaitForInput&lt;/code&gt; waits indefinitely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6557dd6d42d307abdecff79045e463256f2df340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uid&lt;/code&gt; or &lt;code&gt;gid&lt;/code&gt; is specified as -1, then that ID is not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c23a4167afefd24de1f72d0b1f0f0c9e3f11603" translate="yes" xml:space="preserve">
          <source>If Ctrl-C is pressed during the given action, throw an exception of type &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821902f7f945f9df9b4c26649b68c4f807408798" translate="yes" xml:space="preserve">
          <source>If GHC didn&amp;rsquo;t have to compile programs that run in the real world, that would be the end of the story. But representation polymorphism can cause quite a bit of trouble for GHC&amp;rsquo;s code generator. Consider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ef5d466c86ecef8e8961310c403330cf2b508d" translate="yes" xml:space="preserve">
          <source>If GHC persists in being a bad memory citizen, please report it as a bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220d5b83850f635db8c322690e19f967385f577b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; references a file descriptor, attempt to lock contents of the underlying file in appropriate mode. If the file is already locked in incompatible mode, this function blocks until the lock is established. The lock is automatically released upon closing a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378447cdb747f861c2af8b9d9aa5411c32ef8aca" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with GADT syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;em&gt;all&lt;/em&gt; type variables used in the constructor. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4cc18d4c1e7b851b50db0a714da14e3509176a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with vanilla syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will only quantify &lt;em&gt;existential&lt;/em&gt; type variables. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044539454a09356f28e0ae13ed4c626569d75f51" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with GADT syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;em&gt;all&lt;/em&gt; type variables used in the constructor. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="722ab6109c5e8f9f7714e4e2a9d91f17d7a90602" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with vanilla syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will only quantify &lt;em&gt;existential&lt;/em&gt; type variables. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34d5c83b4ecf116da3871cc1a290a189d5d74ad" translate="yes" xml:space="preserve">
          <source>If a C function prototype has &lt;code&gt;t&lt;/code&gt; as an argument or result type, the use of &lt;code&gt;CT&lt;/code&gt; in the corresponding position in a foreign declaration permits the Haskell program to access the full range of values encoded by the C type; and conversely, any Haskell value for &lt;code&gt;CT&lt;/code&gt; has a valid representation in C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c29459b71d15ab93a1c9fd6e056294e61bdf3d" translate="yes" xml:space="preserve">
          <source>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1c26c5e5d7b0e6a433e2ce679bce2faf2ee71c" translate="yes" xml:space="preserve">
          <source>If a RHS of a type family equation is a bare type variable we require that all LHS variables (including implicit kind variables) are also bare. In other words, this has to be a sole equation of that type family and it has to cover all possible patterns. If the patterns are not covering GHC reports that the type family is not injective.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae1bcb9b1cecea16f3e3634cf7f4ebbfdfb031c" translate="yes" xml:space="preserve">
          <source>If a RHS of a type family equation is a type family application GHC reports that the type family is not injective.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db25b8f3188747af958388f20acf6bd09afc1781" translate="yes" xml:space="preserve">
          <source>If a call is annotated as &lt;code&gt;interruptible&lt;/code&gt; and the program was multithreaded, the call may be interrupted in the event that the Haskell thread receives an exception. The mechanism by which the interrupt occurs is platform dependent, but is intended to cause blocking system calls to return immediately with an interrupted error code. The underlying operating system thread is not to be destroyed. See &lt;a href=&quot;#ffi-interruptible&quot;&gt;Interruptible foreign calls&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c05c3def7562a739048b872d41b6d6eb05d7a90" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns a position &lt;code&gt;p&lt;/code&gt;, then computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt; sets the position of &lt;code&gt;hdl&lt;/code&gt; to the position it held at the time of the call to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba018d0d62ee53ce6b9db280035b85aedadefa2f" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns a position &lt;code&gt;p&lt;/code&gt;, then computation &lt;code&gt;&lt;a href=&quot;system-io#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt; sets the position of &lt;code&gt;hdl&lt;/code&gt; to the position it held at the time of the call to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f98223cfb0eee3633d62b814584044de61b78c" translate="yes" xml:space="preserve">
          <source>If a constructor has no arguments, then &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; is used as its representation. For example the representation of &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f3d133e06321809c86bac4a4d58b06416b36bf" translate="yes" xml:space="preserve">
          <source>If a declaration occurs in multiple inherited signatures, they will be &lt;em&gt;merged&lt;/em&gt; together. For values, we require that the types from both signatures match exactly; however, other declarations may merge in more interesting ways. The merging operation in these cases has the effect of textually replacing all occurrences of the old name with a reference to the new, merged declaration. For example, if we have the following two signatures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb4f4cbaa3cf83a5c5f2e268c4fafffea33710e" translate="yes" xml:space="preserve">
          <source>If a field has a higher-rank or existential type, the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved automatically (as described above), but in the interests of simplicity we do not permit users to define their own instances either. If a field is not in scope, the corresponding instance is still prohibited, to avoid conflicts in downstream modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8eaf7aebcd40fba7a5385d613e9ae5cec1a85c4" translate="yes" xml:space="preserve">
          <source>If a finalizer throws an exception, subsequent finalizers that had been queued to run after it do not get run. This behavior may change in a future release. See issue &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/13167&quot;&gt;13167&lt;/a&gt; on the issue tracker. Writing a finalizer that throws exceptions is discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b752cff9e74d6e08fc8898cd07eefb082da1bf" translate="yes" xml:space="preserve">
          <source>If a module was then to import &lt;code&gt;MyNum&lt;/code&gt; from &lt;code&gt;Example&lt;/code&gt;, it would also import the pattern synonym &lt;code&gt;Zero&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893611b3da8b13dca82bbde8d7e30b09c03ec327" translate="yes" xml:space="preserve">
          <source>If a number is given before the command, then the commands are run when the specified breakpoint (only) is hit. This can be quite useful: for example, &lt;code&gt;:set stop 1 :continue&lt;/code&gt; effectively disables breakpoint 1, by running &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; whenever it is hit (although GHCi will still emit a message to say the breakpoint was hit). What&amp;rsquo;s more, with cunning use of &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt; to implement conditional breakpoints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1469d9b993c79ed9fd15d1a5a0d6060aaa153a72" translate="yes" xml:space="preserve">
          <source>If a record field does not have a selector function because its type would allow an existential variable to escape, the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164c3702f74e30bae3bcb4e2249a8dd0868593c2" translate="yes" xml:space="preserve">
          <source>If a record field has a polymorphic type (and hence the selector function is higher-rank), the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved, because doing so would violate the functional dependency on &lt;code&gt;HasField&lt;/code&gt; and/or require impredicativity. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc8e267ccbb00ce682890bda99554fbfc2f7a86" translate="yes" xml:space="preserve">
          <source>If a record type has an old-fashioned datatype context, the &lt;code&gt;HasField&lt;/code&gt; constraint will be reduced to solving the constraints from the context. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608bb4b5a475db6a4953e34347efc01b12ab3dbd" translate="yes" xml:space="preserve">
          <source>If a thread makes a foreign call (and the call is not marked &lt;code&gt;unsafe&lt;/code&gt;), then other Haskell threads in the program will continue to run while the foreign call is in progress. Additionally, &lt;code&gt;foreign export&lt;/code&gt;ed Haskell functions may be called from multiple OS threads simultaneously. See &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afb526f4bf8bfbbfbd29f142d6a0d74ef8a8864" translate="yes" xml:space="preserve">
          <source>If a type variable &lt;code&gt;a&lt;/code&gt; in a datatype, class, or type family declaration depends on another such variable &lt;code&gt;k&lt;/code&gt; in the same declaration, two properties must hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa7a794644c3b1936544c749803bfa930ad77e9" translate="yes" xml:space="preserve">
          <source>If a user does not provide a manual implementation for &lt;code&gt;sPpr&lt;/code&gt;, then it will default to &lt;code&gt;show&lt;/code&gt;. Now we can leverage the &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extension to easily implement a &lt;code&gt;SPretty&lt;/code&gt; instance for a new data type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7120c3db21432a6f1b3610362bef769bc13113" translate="yes" xml:space="preserve">
          <source>If a weak pointer (object) refers to an &lt;em&gt;unreachable&lt;/em&gt; key, it may be finalized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102c2b7d4713d61cdf925ffde90969e0cf8621ec" translate="yes" xml:space="preserve">
          <source>If a worker has that many arguments, none will be unpacked anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93932446c468ada97c37e6d1c9ba23f662e6eb7" translate="yes" xml:space="preserve">
          <source>If all else fails, then you need to resort to &lt;code&gt;Foreign.malloc&lt;/code&gt; and &lt;code&gt;Foreign.free&lt;/code&gt;. These are just wrappers around the C functions of the same name, and their efficiency will depend ultimately on the implementations of these functions in your platform&amp;rsquo;s C library. We usually find &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; to be significantly slower than the other forms of allocation above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a9c3c0b52a8eea92099f68faa2621ba66a2174" translate="yes" xml:space="preserve">
          <source>If all the matches against the &lt;code&gt;pi&lt;/code&gt; succeed, the match succeeds, binding the variables bound by the &lt;code&gt;pi&lt;/code&gt; . (The &lt;code&gt;xi&lt;/code&gt; are not bound; they remain local to the pattern synonym declaration.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed9f549e1682b63a8806713ee685fb3c9adfb3a" translate="yes" xml:space="preserve">
          <source>If all the remaining candidates are incoherent, the search suceeds, returning an arbitrary surviving candidate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb88aceb390c3de7d3ec513d599b8826a7a3104e" translate="yes" xml:space="preserve">
          <source>If all values stored in all maps in the arguments are in WHNF, then all values stored in all maps in the results will be in WHNF once those maps are evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f53d1f0ff24c6a37e378e5ebd89c1567f62d05" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;callCommand&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;callCommand&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa75dc761964532aaa328fd35153a5453bcd7b2e" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;callProcess&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;callProcess&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1293622c4845776f0f7f46e69be43df4b5fb632" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;readProcess&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;readProcess&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac09f8306bc4c40a9a80bb592e856f9697dfc58b" translate="yes" xml:space="preserve">
          <source>If an entry within the directory vanishes while &lt;code&gt;removePathForcibly&lt;/code&gt; is running, it is silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f47696dc0606508335264b40a8a2bc81264cf0b" translate="yes" xml:space="preserve">
          <source>If an environment entry does not contain an &lt;code&gt;'='&lt;/code&gt; character, the &lt;code&gt;key&lt;/code&gt; is the whole entry and the &lt;code&gt;value&lt;/code&gt; is the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588c20098b5c4c736fc7038d90ea284118f71b07" translate="yes" xml:space="preserve">
          <source>If an exception occurs while removing an entry, &lt;code&gt;removePathForcibly&lt;/code&gt; will still try to remove as many entries as it can before failing with an exception. The first exception that it encountered is re-thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f43e9ffc752b9a35ea582ecc7ec760456f3ea2c" translate="yes" xml:space="preserve">
          <source>If an explicit deriving strategy is not given, multiple strategies may apply. In that case, GHC chooses the strategy as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8ac1961b2d3e86583dd04eda895ba3b29064e6" translate="yes" xml:space="preserve">
          <source>If an identifier&amp;rsquo;s type has a &lt;code&gt;forall&lt;/code&gt;, then the order of type variables as written in the &lt;code&gt;forall&lt;/code&gt; is retained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f039989be66fcac53da059edc720fe7f2a41936" translate="yes" xml:space="preserve">
          <source>If an optional package identifier ⟨P⟩ is given, then only packages matching that identifier are shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9480ee90d261f8569a157de91547e584915aaf32" translate="yes" xml:space="preserve">
          <source>If any of the allocation functions fails, an exception is thrown. In some cases, memory exhaustion may mean the process is terminated. If &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; is applied to a memory area that has been allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt;, the behaviour is undefined. Any further access to memory areas allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt;, after the computation that was passed to the allocation function has terminated, leads to undefined behaviour. Any further access to the memory area referenced by a pointer passed to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; entails undefined behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7fd42d0300203e3af493856477c90e7ae13199" translate="yes" xml:space="preserve">
          <source>If any of the quantified type variables has a kind that mentions a kind variable, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e0a573c5bd37919b95c361fc7a30bc02d831c3" translate="yes" xml:space="preserve">
          <source>If any of the variables depend on other variables (that is, if some of the variables are &lt;em&gt;kind&lt;/em&gt; variables), the variables are reordered so that kind variables come before type variables, preserving the left-to-right order as much as possible. That is, GHC performs a stable topological sort on the variables. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0557de3fe76952756c65625bbfb3066796d428b" translate="yes" xml:space="preserve">
          <source>If both of these conditions are met, GHC will generate this instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce69b4f84d82a5182cf85076110c0eb025eac55" translate="yes" xml:space="preserve">
          <source>If both rules apply to a deriving clause, then &lt;code&gt;anyclass&lt;/code&gt; is used and the user is warned about the ambiguity. The warning can be avoided by explicitly stating the desired deriving strategy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa898721e2cf3e2c6fc02511763040c586b29a5" translate="yes" xml:space="preserve">
          <source>If compatibility with Haskell compilers (including GHC prior to version 7.10.1) which do not define &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; is required, the presence of the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; macro needs to be ensured before it is called, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f60c7543719f4b0441de2debed7ccff9b057ee" translate="yes" xml:space="preserve">
          <source>If compiled against a version of &lt;code&gt;unix&lt;/code&gt; prior to &lt;code&gt;2.7.0.0&lt;/code&gt;, the function would not be able to set timestamps with sub-second resolution. In this case, there would also be loss of precision in the access time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca0ce3ddba01a79e74af5c98436169275d83f0d" translate="yes" xml:space="preserve">
          <source>If compiled against a version of &lt;code&gt;unix&lt;/code&gt; prior to &lt;code&gt;2.7.0.0&lt;/code&gt;, the function would not be able to set timestamps with sub-second resolution. In this case, there would also be loss of precision in the modification time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a5f02902c36d5e634fb160347312d3187dcbaf" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-O2&lt;/code&gt; enabled, then the fields will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedUnpack&quot;&gt;DecidedUnpack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b6e9b0f077c5045ff320f1e46e64bdc9093838" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-XStrictData&lt;/code&gt; enabled, then the fields will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="894b0f94836181331c4facb44019c7354d1c68db" translate="yes" xml:space="preserve">
          <source>If compiled without optimization or other language extensions, then the fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f0a56741935b56d9657b26b078c93129516f82" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;&lt;a href=&quot;control-applicative#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; should be the least solutions of the equations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="702c4c7f59fbddacdb90bd27f31c03920aeed35e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;&lt;a href=&quot;ghc-base#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; should be the least solutions of the equations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13447cdcf1a935f05011fe0f50982abf26334ad9" translate="yes" xml:space="preserve">
          <source>If divisor is zero, &lt;code&gt;(# &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;, &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt; #)&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079e039a9d9a2492d984ad6955aa2d617c670ae6" translate="yes" xml:space="preserve">
          <source>If given an explicit &amp;lt;mask&amp;gt;, the &amp;lt;mask&amp;gt; is interpreted as a bitmap that indicates the NUMA nodes on which to run the program. For example, &lt;code&gt;--numa=3&lt;/code&gt; would run the program on NUMA nodes 0 and 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc002cc69c30cbd42ee3fdd97604037215dd998" translate="yes" xml:space="preserve">
          <source>If given invalid input, an exception will be thrown by the function or continuation where it is encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b94f294f89264115630dd884435117d7704777a" translate="yes" xml:space="preserve">
          <source>If hs-boot files are considered distinct from their parent source files, and if a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import is considered to refer to the hs-boot file, then the module import graph must have no cycles. The command &lt;code&gt;ghc -M&lt;/code&gt; will report an error if a cycle is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1bdd645b7861dcf3835e2124b49ce612dfa503" translate="yes" xml:space="preserve">
          <source>If in doubt, don't use this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d098bda271cdeda0c89226b1f9334177dda1ff17" translate="yes" xml:space="preserve">
          <source>If in doubt, return non-zero, but do make an effort to create the correct answer for small args, since otherwise the performance of &lt;code&gt;(*) :: Integer -&amp;gt; Integer -&amp;gt; Integer&lt;/code&gt; will be poor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901bbb7f5d809f3c6e6b017688b99e54b9c8c79f" translate="yes" xml:space="preserve">
          <source>If it cannot open the user's terminal, use file-style interaction, reading input from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49674ddcca37568931ac6e297642bf137c06f0fb" translate="yes" xml:space="preserve">
          <source>If it is heavily used on lists with &lt;code&gt;Widget&lt;/code&gt; keys, you could specialise it as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0edddfba80ac6a09b6665c39b1ef9f0ebf6fbab" translate="yes" xml:space="preserve">
          <source>If it says you&amp;rsquo;re using more than 20% of total time in garbage collecting, then more memory might help: use the &lt;code&gt;-H⟨size⟩&lt;/code&gt; (see &lt;code&gt;-H
[⟨size⟩]&lt;/code&gt;) option. Increasing the default allocation area size used by the compiler&amp;rsquo;s RTS might also help: use the &lt;code&gt;+RTS -A⟨size⟩ -RTS&lt;/code&gt; option (see &lt;code&gt;-A ⟨size⟩&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205fa22c0cf21d40cd9db8045e7c70a4db4f3ae2" translate="yes" xml:space="preserve">
          <source>If it uses terminal-style interaction, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; will be read from the user's &lt;code&gt;~/.haskeline&lt;/code&gt; file (if present). If it uses file-style interaction, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; are not relevant and will not be read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a69ac0f3095acb072ddfcfb9a6bdffd564f050" translate="yes" xml:space="preserve">
          <source>If more than one non-incoherent candidate remains, the search fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092903c3946d9ebf1026389c3dca1af41e4be180" translate="yes" xml:space="preserve">
          <source>If more than one rule matches a call, GHC will choose one arbitrarily to apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c551abf7dfa66ea7e6819fd50f9537ead8ac62" translate="yes" xml:space="preserve">
          <source>If multiple CodingProgress returns are possible, OutputUnderflow must be preferred to InvalidSequence. This allows GHC's IO library to assume that if we observe InvalidSequence there is at least a single element available in the output buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c993cec0b4151ad1b0f5562c270a5895e49c59e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for datatypes where each constructor has just zero or one field, in particular for enumeration types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777411d8c4bf9b9216adcc59bd1260d805fb12f9" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for empty datatypes or datatypes that have a single constructor, but will fail on datatypes with more than one constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076b26677e1e9d94d1e31f006635bd3641fcc733" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for enumeration types, where no constructor has any fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db076b7e62e1c825a47aaaf3a5ab3a6b5fbdafa9" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for any datatype where each constructor has at least one field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1606eb80e1c8dfc4c88130f2d2acd1efbbfc995e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for any datatype that is not empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b3a7948164a4bece210a1698cfedabc51fc766" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;MINIMAL&lt;/code&gt; pragma is given in the class declaration, it is just as if a pragma &lt;code&gt;{-# MINIMAL op1, op2, ..., opn #-}&lt;/code&gt; was given, where the &lt;code&gt;opi&lt;/code&gt; are the methods that lack a default method in the class declaration (c.f. &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt;&lt;code&gt;-Wmissing-methods&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6558b92d136aeb7b89c5f372133e67b42639edb6" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;default&lt;/code&gt; declaration is given, then it is just as if the module contained the declaration &lt;code&gt;default( Integer, Double, String)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784b5f99e839f7b12ec2093256b70c6cad4b74c2" translate="yes" xml:space="preserve">
          <source>If no candidates remain, the search failes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9192657645342fee69fd524510551ad47221178f" translate="yes" xml:space="preserve">
          <source>If no export list is provided for a signature, the exports of a signature are all of its defined entities merged with the exports of all inherited signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ff16fc0e935cafc45afe04c519a876483f5dcb" translate="yes" xml:space="preserve">
          <source>If no inlining takes place, the &lt;code&gt;&lt;a href=&quot;ghc-exts#v:inline&quot;&gt;inline&lt;/a&gt;&lt;/code&gt; function expands to the identity function in Phase zero, so its use imposes no overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09340baa4f1fe5048c9542d16a391d2e3eb6f959" translate="yes" xml:space="preserve">
          <source>If no mode flag is present, then GHC will enter &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode (&lt;a href=&quot;#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt;) if there are any Haskell source files given on the command line, or else it will link the objects named on the command line to produce an executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545b39aee7ff9dd8868144c774e3a1c54c9f14dd" translate="yes" xml:space="preserve">
          <source>If no quantified constraints match, look up in the global instances, as described in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance resolution&lt;/a&gt; and &lt;a href=&quot;#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8910a1e7567042e5831890a8c1459a75e51e378b" translate="yes" xml:space="preserve">
          <source>If not, look at all the available given quantified constraints; if exactly one one matches &lt;code&gt;C t&lt;/code&gt;, choose it; if more than one matches, report an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c47246abbeffab64ebd4d936953fd4c7c077f74" translate="yes" xml:space="preserve">
          <source>If omitted, ⟨n⟩ and ⟨m⟩ default to the first or last available completion candidate respectively. If there are less candidates than requested via the range argument, ⟨n⟩ and ⟨m⟩ are implicitly capped to the number of available completion candidates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43110c483674fe00877c4157e9200eb8ff216c7b" translate="yes" xml:space="preserve">
          <source>If one input list is short, excess elements of the longer list are discarded:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae8b4e0fe43800691134bf9658ff55ae4812650" translate="yes" xml:space="preserve">
          <source>If one were to attempt to derive a Generic instance for a datatype with an unlifted argument (for example, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;), one might expect the occurrence of the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; argument to be marked with &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;. This won't work, though, since &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; is of an unlifted kind, and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; expects a type of kind &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1ad15ce25abb2710fa65ecce3a62a8bb2f9029" translate="yes" xml:space="preserve">
          <source>If platform does not provide &lt;code&gt;posix_fadvise(2)&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; becomes a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fd0fc4ca5ca1f4279bebce52029854ce0a49ff" translate="yes" xml:space="preserve">
          <source>If possible &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt;, will be used directly (i.e. shared &lt;em&gt;without&lt;/em&gt; cloning the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; into a newly allocated one)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cc4cf0d03d5edea947b7488d65fce86a4331f7" translate="yes" xml:space="preserve">
          <source>If profiling has pointed the finger at particular functions, look at their Core code. &lt;code&gt;lets&lt;/code&gt; are bad, &lt;code&gt;cases&lt;/code&gt; are good, dictionaries (&lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt;) [or anything overloading-ish] are bad, nested lambdas are bad, explicit data constructors are good, primitive operations (e.g., &lt;code&gt;eqInt#&lt;/code&gt;) are good, ...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f317cd94e7a84b9481c4cd3410991be028a616" translate="yes" xml:space="preserve">
          <source>If recursive bindings are required for a monad, then that monad must be declared an instance of the &lt;code&gt;MonadFix&lt;/code&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bff50aaf133e46c4c389202fbe2fead3ced4d7" translate="yes" xml:space="preserve">
          <source>If right-to-left evaluation is required, the input list should be reversed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfe3ca7d56d7c40b077f20b07320acbb2603c62" translate="yes" xml:space="preserve">
          <source>If some of the rows are shorter than the following rows, their elements are skipped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a471137408c37fe4b26bd411d1c9b91c60232b56" translate="yes" xml:space="preserve">
          <source>If such a package environment is found, it is equivalent to passing these command line arguments to &lt;code&gt;ghc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100bc4626b0efab2c2dfa95a3d57f85130c6e4b0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt; is enabled (with the &lt;a href=&quot;#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt; runtime system flag) heap samples will additionally be emitted to the GHC event log (see &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;Heap profiler event log output&lt;/a&gt; for details about event format).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984396ef6b346f6f5a141f1b3cc9c98c57b40449" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-foralls&quot;&gt;&lt;code&gt;-Wunused-foralls&lt;/code&gt;&lt;/a&gt; flag is enabled, a warning will be emitted when you write a type variable in an explicit &lt;code&gt;forall&lt;/code&gt; statement that is otherwise unused. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67067af8a67e4c0ac00744d32ff51787c4c23ceb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;*&lt;/code&gt; symbol is placed before the module name, then &lt;em&gt;all&lt;/em&gt; the identifiers in scope in ⟨module⟩ (rather that just its exports) are shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7426ed03e0cc31e14922c9ce2a60b1c4a4d18a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-rtsopts&lt;/code&gt; flag is set to something other than &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;ignoreAll&lt;/code&gt; when linking, RTS options are also taken from the environment variable &lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-5&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt;. For example, to set the maximum heap size to 2G for all GHC-compiled programs (using an &lt;code&gt;sh&lt;/code&gt;-like shell):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee47e204ad25ad75b90f894519d743cd373d5ec1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; is not found returns &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eecdf1765fe1b5c7a149e43f46aee92b76c9e9d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is a relative path, then for every search directory &lt;code&gt;dir&lt;/code&gt;, the function checks whether &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; exists and satisfies the predicate. If so, &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; is returned as one of the results. In other words, the returned paths can be either relative or absolute depending on the search directories were used. If there are no search directories, no results are ever returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e66c7a66ac7c32b8ef7f9ce828408309a2951cf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is an absolute path, then the function will return a single result if the file exists and satisfies the predicate and no results otherwise. This is irrespective of what search directories were given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e84cba36edfb057e05285c58d1b651c2f290d8" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95557e9796ad5018f234723793eebbd659062bdd" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37fb4ee444bede274c669b4d448a3acdb65fb55" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916aaf70159a57842ced3963dcd6e37575d65a6b" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74b7c9262440ab8eb34e0a6d3d1e23753614271" translate="yes" xml:space="preserve">
          <source>If the buffer mode is changed from &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt;, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb44311b2b43303ecd2e4401810f83b01105af2e" translate="yes" xml:space="preserve">
          <source>If the buffer mode is changed from &lt;code&gt;&lt;a href=&quot;system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;system-io#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt;, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="340506b1fc7cfecd1cc706b1ed0b444cb860cf41" translate="yes" xml:space="preserve">
          <source>If the computation is to modify the stored information, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c240367cda084253143432ddcf60bf0b03fa3e5" translate="yes" xml:space="preserve">
          <source>If the constraint solver encounters a constraint &lt;code&gt;HasField x r a&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is a concrete datatype with a field &lt;code&gt;x&lt;/code&gt; in scope, it will automatically solve the constraint using the field selector as the dictionary, unifying &lt;code&gt;a&lt;/code&gt; with the type of the field if necessary. This happens irrespective of which extensions are enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac5d0fe1d7acda30fb0ec5a56697651c36a28ef" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc73951c5c10ca78ae5366f259e7017f69544b8f" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a11dfd9c83245d6ba417f9310e69a934f255b67" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7340551eb65b17d80f26730fb4f3289da8692a48" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7834f177091806c3787fe742b48954a28d269ce" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff881ab5c74b90094d3fe1033075847bf7fe644" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24a3dfbd521f865d8c41e8577fde1211e1662ee" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cae460cd107a842e94f70119834c39ecbdb71b" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45481ebece8ce7cdca4efa8d7e24867db92404c" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dfb1a85a710e73bec4ed69a3c877abb78023f39" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a05487843b471ffa877f4ad69c2c7e4d703688" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b96127742ffe03893d0e4f936b677e699812df7" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915369447c441596818ea47cd1848a5ce0c1bbc6" translate="yes" xml:space="preserve">
          <source>If the derived instance were allowed, what would the type of its method &lt;code&gt;bad&lt;/code&gt; be? It would seem to be &lt;code&gt;Age -&amp;gt; Inspect Age&lt;/code&gt;, which is equivalent to &lt;code&gt;Age -&amp;gt; Int&lt;/code&gt;, according to the type family &lt;code&gt;Inspect&lt;/code&gt;. Yet, if we simply adapt the implementation from the instance for &lt;code&gt;Int&lt;/code&gt;, the implementation for &lt;code&gt;bad&lt;/code&gt; produces a &lt;code&gt;Bool&lt;/code&gt;, and we have trouble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99dd79a68e6ace7bc36818530a36dff1b61996fd" translate="yes" xml:space="preserve">
          <source>If the elements are ordered, a linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-set#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffe9c900b23c1f743c980afb39a54b09a15873e" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-11&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; is set, and its value does not end in a separator (&lt;code&gt;:&lt;/code&gt; on Unix, &lt;code&gt;;&lt;/code&gt; on Windows), then the last database is considered to be the global database, and will be modified by default by &lt;code&gt;ghc-pkg&lt;/code&gt;. The intention here is that &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; can be used to create a virtual package environment into which Cabal packages can be installed without setting anything other than &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d64c16a458e52bfe82101c17b8bb95dd2a0fb1" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f96e8b63db707eb0457ade29de32d3c2df84734" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2dff9269612b6f615c400bd3a6c96cd41d71ec5" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b31e706b20ca1dd226c814726e8413042889a0f" translate="yes" xml:space="preserve">
          <source>If the expression was instead of type &lt;code&gt;IO a&lt;/code&gt; for some &lt;code&gt;a&lt;/code&gt;, then &lt;code&gt;it&lt;/code&gt; will be bound to the result of the &lt;code&gt;IO&lt;/code&gt; computation, which is of type &lt;code&gt;a&lt;/code&gt;. eg.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557b536a62aea491508b3f277f7c66ebafe8f737" translate="yes" xml:space="preserve">
          <source>If the file does not exist and it is opened for output, it should be created as a new file. If &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; and the file already exists, then it should be truncated to zero length. Some operating systems delete empty files, so there is no guarantee that the file will exist following an &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;mode&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; unless it is subsequently written to successfully. The handle is positioned at the end of the file if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt;, and otherwise at the beginning (in which case its internal position is 0). The initial buffer mode is implementation-dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bdafef8b919def741e21f11e5c61515c31e3d40" translate="yes" xml:space="preserve">
          <source>If the file does not exist and it is opened for output, it should be created as a new file. If &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; and the file already exists, then it should be truncated to zero length. Some operating systems delete empty files, so there is no guarantee that the file will exist following an &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;mode&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; unless it is subsequently written to successfully. The handle is positioned at the end of the file if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt;, and otherwise at the beginning (in which case its internal position is 0). The initial buffer mode is implementation-dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8848ff01b8a32afcddff36cec08d4b6728717d85" translate="yes" xml:space="preserve">
          <source>If the final statement is not of one of these forms, GHC falls back to standard &lt;code&gt;do&lt;/code&gt; desugaring, and the expression will require a &lt;code&gt;Monad&lt;/code&gt; constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99750cf8581988661447b877b8a2ef2af75d98f8" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b9d8e821fceed6649d1fb75df70e0b3ecb6ca6" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e53de7a23bc55e53e1793d6fcc64937e975381" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a17c36982066985bf53c44ca7e61aeacd02ae41" translate="yes" xml:space="preserve">
          <source>If the first argument evaluates to &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then the result is the second argument. Otherwise an &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; exception is raised, containing a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with the source file and line number of the call to &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb4f24ce87f487be05ef1c288b600a60dcbf5bb" translate="yes" xml:space="preserve">
          <source>If the first argument evaluates to &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then the result is the second argument. Otherwise an &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; exception is raised, containing a &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with the source file and line number of the call to &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0054b769e95e245513b766b41dc0a78a5fa0e67" translate="yes" xml:space="preserve">
          <source>If the first completer produces no suggestions, fallback to the second completer's output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d227d6371173673bc113bcadb48246870a816fc" translate="yes" xml:space="preserve">
          <source>If the first list contains duplicates, so will the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f303f44f15d67e9e20a0ff01c05b8e471995e19" translate="yes" xml:space="preserve">
          <source>If the first list is not finite, the result is the first list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabb69bed587314beb9edec19efed156d82f6d0c" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;f&lt;/code&gt; takes more than one parameter, the type variable &lt;code&gt;b&lt;/code&gt; is instantiated to a functional type which combines nicely with the adds parser &lt;code&gt;p&lt;/code&gt; to the (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator. This results in stylized code where a permutation parser starts with a combining function &lt;code&gt;f&lt;/code&gt; followed by the parsers. The function &lt;code&gt;f&lt;/code&gt; gets its parameters in the order in which the parsers are specified, but actual input can be in any order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb94185e7818eb4718538187db5c7b4cbfd254a" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;f&lt;/code&gt; takes more than one parameter, the type variable &lt;code&gt;b&lt;/code&gt; is instantiated to a functional type which combines nicely with the adds parser &lt;code&gt;p&lt;/code&gt; to the (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator. This results in stylized code where a permutation parser starts with a combining function &lt;code&gt;f&lt;/code&gt; followed by the parsers. The function &lt;code&gt;f&lt;/code&gt; gets its parameters in the order in which the parsers are specified, but actual input can be in any order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0bf34eec193f2a121ba6f174b48d6e08e32c420" translate="yes" xml:space="preserve">
          <source>If the function isn&amp;rsquo;t exported, just compile with the extra flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;; next to the signature for any binder, it will print the self-same pragmatic information as would be put in an interface file. (Besides, Core syntax is fun to look at!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79369b89e6cd5dd14719075c040fa3bcd79b2c7d" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d21b1729033749751e04b2041b55e92dac94b3" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733eefc07bf9e51bd55cbb49b0874fcb5f17d31b" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a38fbd33678c8e1ac4ad25b0d95cd894290536" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6e0e76a190f2043a8bd3777daebaebf1def2ab" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac14468e0ab875750716201383acedb0f1aa59a2" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4758d777c012362f6479362e01995e935a7b09ed" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a808de4e438b2cac191975ec1178b82376b0eb" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695c3d916d62f2ea55cdb779edc67a44a1f3c788" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9752d59da062f75442fd0c45b415851963415b0" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f82e3a8d0be8d48a4f40713cb2d9fb06f2e221" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb52b41e41c616d22190f5e23f9b5d53c5c8fa6" translate="yes" xml:space="preserve">
          <source>If the handler returns a value wrapped with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;, that value will be used in the output as the replacement for the invalid input. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no value will be used in the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe922e3d119fe0f1cc74a44c92d349bcf461e892" translate="yes" xml:space="preserve">
          <source>If the initial buffer is too small to hold all data, subsequent buffers will be the default buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8e4480bef91d631c461344a2de2236d4cfee75" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown (either by this function or a continuation) that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd132895bcb29067d5281e312732641ade69617a" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f85b42e97d38521695bc5719fab602af715f74" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b23031b09a6ace4ba4f6ac224b740e40f02c57" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, the relevant exception will be returned, otherwise the decoded text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754415b1a59c2ab620f6ecdfc36468a832eed47d" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a4190d0c5a617251a227f4e4ffc0dc4c3ec80e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a938f8cb41602c2e37ba21b2b1d159bacbe79e60" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a0fd29f327678893fbe7d2c540d1bfc2f81f6e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64bf7ac928bb9d8d34aaf3441fc5265800b5a9d5" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1b7df55ab6d8158aa8cf994eaac1e0b9224b7e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c2f670f171baeb0231536712051cb1c8aaf33a" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c26edc2ab81f9a20a2fa34e0b70f9dd71e74d9ab" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d43fcf632f6993095dae2aeab0f213b43767b8e" translate="yes" xml:space="preserve">
          <source>If the key exists in the map, this function is lazy in &lt;code&gt;value&lt;/code&gt; but strict in the result of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625b4beded575a88ac5daec835ba706a687d2bcb" translate="yes" xml:space="preserve">
          <source>If the keys of the list are ordered, linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1448f4c78b74e05628456296d2ae49ddecc501e" translate="yes" xml:space="preserve">
          <source>If the keys of the list are ordered, linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749dbe9f6d5460db51b381f2ed3cc45b62922708" translate="yes" xml:space="preserve">
          <source>If the linker complains about not finding &lt;code&gt;_&amp;lt;something&amp;gt;_fast&lt;/code&gt;, then something is inconsistent: you probably didn&amp;rsquo;t compile modules in the proper dependency order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ce2aaa6f885fafff129a1f5c7f288b0246cde9" translate="yes" xml:space="preserve">
          <source>If the module is omitted, then the most recently-loaded module is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06465b1683dc6997624e8cf98f88a5ffebfed678" translate="yes" xml:space="preserve">
          <source>If the object becomes unreachable right before the program exits, then GC may not be performed. Finalizers run during GC, so finalizers associated with the object do not run if GC does not happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1118a0190298be9b79dcb8130235e2ed75e7ad6d" translate="yes" xml:space="preserve">
          <source>If the operations needed are available in &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt;, it's recommended to avoid importing this module and use &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt; instead for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d002b03429965487a13f5d84e867b7a6ca60210f" translate="yes" xml:space="preserve">
          <source>If the option &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; is passed to the compiler, the above restrictions are not enforced and it is on the programmer to ensure termination of the normalisation of type families during type inference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a071a26aa48a39d43d14f16a87c253716cb792f4" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--simple-output&lt;/code&gt; is given, then the packages are listed on a single line separated by spaces, and the database names are not included. This is intended to make it easier to parse the output of &lt;code&gt;ghc-pkg list&lt;/code&gt; using a script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2972ccb36c0dde44e00d9bbf8a450ab2fdf58ed" translate="yes" xml:space="preserve">
          <source>If the package contains profiling libraries, then the interface files for those library modules should have the suffix &lt;code&gt;.p_hi&lt;/code&gt;. So the package can contain both normal and profiling versions of the same library without conflict (see also &lt;code&gt;library_dirs&lt;/code&gt; below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccd8f5434504821c2b94076a11f8715fe0b84ba" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;a&lt;/code&gt; appears underneath a composition of other type constructors, then the representation involves composition, too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32cab9cb10b6c38303476943187addc7db896eb0" translate="yes" xml:space="preserve">
          <source>If the path is already absolute, the operation never fails. Otherwise, the operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b17cb9d8e7bb5e296d3da780f46cf2d367124c" translate="yes" xml:space="preserve">
          <source>If the path is already absolute, the operation never fails. Otherwise, the operation may throw exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd818a895dd0680e5558fe6703f03edd2d2230d" translate="yes" xml:space="preserve">
          <source>If the path points to an existing file or directory, then the output path shall also point to the same file or directory, subject to the condition that the relevant parts of the file system do not change while the function is still running. In other words, the function is definitively not atomic. The results can be utterly wrong if the portions of the path change while this function is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17dcdf1f1aa0a2191303abce0bb5187d7f7a9885" translate="yes" xml:space="preserve">
          <source>If the pattern is a constructor pattern &lt;code&gt;(P p1 ... pn)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern synonym defined by &lt;code&gt;P x1 ... xn = p&lt;/code&gt; or &lt;code&gt;P x1 ... xn &amp;lt;- p&lt;/code&gt;, then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba484df09e44ad6151f620767b5567f42c57031" translate="yes" xml:space="preserve">
          <source>If the pattern matches multiple packages, the description for each package is emitted, separated by the string &lt;code&gt;---&lt;/code&gt; on a line by itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddedbc84892409431bb5cd9dff6d864c792acc8" translate="yes" xml:space="preserve">
          <source>If the plugin cannot make any progress, it should return &lt;code&gt;TcPluginOk [] []&lt;/code&gt;. Otherwise, if there were any new constraints, the main constraint solver will be re-invoked to simplify them, then the plugin will be invoked again. The plugin is responsible for making sure that this process eventually terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4dd01b74a08371cbefaa339741c2f2bf732cc33" translate="yes" xml:space="preserve">
          <source>If the pointer argument to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;. If the requested size is 0, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a8bff9ac670099a84c99ae99166a8b13917470" translate="yes" xml:space="preserve">
          <source>If the program needs to be linked with additional objects (say, some auxiliary C code), then the object files can be given on the command line and GHC will include them when linking the executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0e55f0ed3aeca48a639cdc97cfce430926d732" translate="yes" xml:space="preserve">
          <source>If the program&amp;rsquo;s heap exceeds the value set by &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt;, the RTS throws an exception to the program, and the program gets an additional quota of allocation before the exception is raised again, the idea being so that the program can execute its exception handlers. &lt;code&gt;-Mgrace=&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05bad59c9ffd07726909b6b71df24cb1faeae56" translate="yes" xml:space="preserve">
          <source>If the quotes are left off in the above command, &lt;code&gt;ghci&lt;/code&gt; will interpret the filename as two, &lt;code&gt;c:\\\\Program&lt;/code&gt; and &lt;code&gt;Files\\\\Haskell\\\\Project.hs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2999a971417548d37995328ba747557f94ced1e4" translate="yes" xml:space="preserve">
          <source>If the specifics of the data format is not important to you, for example, you are more interested in serializing and deserializing values than in which format will be used, it is possible to derive &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; instances using the generic support. See &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryGet&quot;&gt;GBinaryGet&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryPut&quot;&gt;GBinaryPut&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bff18fc6fb06d1186c47eea05dc08be6efd2b10" translate="yes" xml:space="preserve">
          <source>If the strings do not have a common prefix or either one is empty, this function returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96483a865258b93f60fbe9c7b1b6209ab588de4" translate="yes" xml:space="preserve">
          <source>If the system call is successfully interrupted, it will return to Haskell whereupon the exception can be raised. Be especially careful when using &lt;code&gt;interruptible&lt;/code&gt; that the caller of the foreign function is prepared to deal with the consequences of the call being interrupted; on Unix it is good practice to check for &lt;code&gt;EINTR&lt;/code&gt; always, but on Windows it is not typically necessary to handle &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ea0825d60f59ed95619566d152ac3af5d1dc48" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef565fe58fa8cc5e2adb616fefe14b2fe53e3eb9" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ed533e57740cc52561c9e0778a3939079b1869" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5423771ba3f07d0d121d4047b87be07039385d" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f635604a794f0509d229ca0450224e3801f13960" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb32a1414cef013e5d3c55de2b52fcec36dfcc67" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410b774382afae43c015c978d6a4c05a23286a81" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aae4a4891882f9616442e3ab4e703d074ae744f" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efe330fe5a7f319c74a83698c2016b7024d2870" translate="yes" xml:space="preserve">
          <source>If the tick-count expires, GHC summarises what simplifier steps it has done; you can use &lt;code&gt;-fddump-simpl-stats&lt;/code&gt; to generate a much more detailed list. Usually that identifies the loop quite accurately, because some numbers are very large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f834f3278901f9fdfc11689ba5008e3d53a52f10" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c720209a65937fe0295731a0ddd0e77cf4c007" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31cbe33b88501dc1cab64cc221110f7cc955564" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a3cb38f79f019c8eefd564552c10ef09d46fb9" translate="yes" xml:space="preserve">
          <source>If the type signature includes any kind annotations (either on variable binders or as annotations on types), any variables used in kind annotations come before any variables never used in kind annotations. This rule is not recursive: if there is an annotation within an annotation, then the variables used therein are on equal footing. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4ea0e44780d77e1880898106ce1bbf9df2c555" translate="yes" xml:space="preserve">
          <source>If the types of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; are not unboxed, the resulting binding is lazy like any other Haskell pattern binding. The above example desugars like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f18250f43f2740e1195441a25da60c594f32dd" translate="yes" xml:space="preserve">
          <source>If the underlying encoding is not itself roundtrippable, this mechanism can fail. Roundtrippable encodings are those which have an injective mapping into Unicode. Almost all encodings meet this criteria, but some do not. Notably, Shift-JIS (CP932) and Big5 contain several different encodings of the same Unicode codepoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18d7f0b53d60c67a0f0044ea31055a7a2c5370e" translate="yes" xml:space="preserve">
          <source>If the user has supplied a type signature, as in &lt;code&gt;f&lt;/code&gt;, then this is easy: we just take the ordering from the type signature, going left to right and using the first occurrence of a variable to choose its position within the ordering. Thus, the variables in &lt;code&gt;f&lt;/code&gt; will be &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153127ffa367d83e2cf43ec8214e9672b8320af2" translate="yes" xml:space="preserve">
          <source>If the user writes &quot;lexical&quot;, the parser fails with: &lt;code&gt;unexpected
 'x', expecting 't' in &quot;let&quot;&lt;/code&gt;. Indeed, since the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator only tries alternatives when the first alternative hasn't consumed input, the &lt;code&gt;identifier&lt;/code&gt; parser is never tried (because the prefix &quot;le&quot; of the &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser is already consumed). The right behaviour can be obtained by adding the &lt;code&gt;try&lt;/code&gt; combinator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077149390f83f66f25123eacbd59fbfc008ad8c0" translate="yes" xml:space="preserve">
          <source>If the user writes &quot;lexical&quot;, the parser fails with: &lt;code&gt;unexpected
 'x', expecting 't' in &quot;let&quot;&lt;/code&gt;. Indeed, since the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator only tries alternatives when the first alternative hasn't consumed input, the &lt;code&gt;identifier&lt;/code&gt; parser is never tried (because the prefix &quot;le&quot; of the &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser is already consumed). The right behaviour can be obtained by adding the &lt;code&gt;try&lt;/code&gt; combinator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627396045def6a2b30cfb67918ea7b827134e0dc" translate="yes" xml:space="preserve">
          <source>If the value of the error is not required, the variant in &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; may be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbcf45c8589b25e6b77fbe3fd739a89f107ae36" translate="yes" xml:space="preserve">
          <source>If the value of the exception is not required, the variant in &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; may be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9596c4f417cd0a2eeda3532c57a9759b3148d2e2" translate="yes" xml:space="preserve">
          <source>If there are multiple exposed versions of a package, GHC will prefer the latest one. Additionally, some packages may be broken: that is, they are missing from the package database, or one of their dependencies are broken; in this case; these packages are excluded from the default set of packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2744f509c20d0d226472161d7c5e0d680881c742" translate="yes" xml:space="preserve">
          <source>If there are no other threads to run, the runtime system will check for runnable finalizers before declaring the system to be deadlocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2754d33a517265ae953ce70490f5a33b97494617" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b72501bc991c36ff4bffdeb5e90240c549826c" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786b9b7efbfcf460816260b5fc3891ba66319ff4" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb2173b7203347d640f077ccdf8f741ab650cd9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;CallStack&lt;/code&gt; in scope &amp;ndash; i.e. the enclosing definition has a &lt;code&gt;HasCallStack&lt;/code&gt; constraint &amp;ndash; GHC will push the new call-site onto the existing &lt;code&gt;CallStack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9751e595298ec0b63212d3d3e3da71e206e9047f" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;-odir&lt;/code&gt; option (the default), then the object filename is derived from the source filename (ignoring the module name) by replacing the suffix with ⟨osuf⟩.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0459b16b546d66c267a51da320d328d26755c8cb" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b3dd98e9cfee97be33be76a5f1ce7dc9f8f5e6" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1471f8828c2379e165ca2717ec8725b325f74acd" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5dadc898713c4d1ac69f3e2c4c1c3cd662c85a" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a2154090a11c56205c916716db23e3aaf5e97a" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb76c92af062244a4e188e2b7f8ad3c706df8fb" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41b4ceb40ee7df7d2779d08c19440a00fd4dee9" translate="yes" xml:space="preserve">
          <source>If these instances can be defined, defining instances of the base classes is mechanical:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9d1a25b60758f4043441274ee9783e99a3d47e" translate="yes" xml:space="preserve">
          <source>If this flag is on, call-pattern specialisation will specialise a call &lt;code&gt;(f (Just x))&lt;/code&gt; with an explicit constructor argument, even if the argument is not scrutinised in the body of the function. This is sometimes beneficial; e.g. the argument might be given to some other function that can itself be specialised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615c1d104b752d5fbf04f2f7bfaa64a63695c34b" translate="yes" xml:space="preserve">
          <source>If true, create the semaphore if it does not yet exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5726894dc0e940e30aa84621008b693bdc032ec8" translate="yes" xml:space="preserve">
          <source>If true, create the shm object if it does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a6257ede23921542c050cc42cf5a60299cc751" translate="yes" xml:space="preserve">
          <source>If true, open the shm object read-write rather than read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1c0f18f18624f27614c4ffe42965205a397757" translate="yes" xml:space="preserve">
          <source>If true, throw an exception if the semaphore already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa803c6c609db6b79b17d1491838007497e1d827" translate="yes" xml:space="preserve">
          <source>If true, throw an exception if the shm object already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed093df6f14d931fa3c4c256a6b87b3891dc67ba" translate="yes" xml:space="preserve">
          <source>If true, wipe the contents of the shm object after opening it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b399c89393340f06d26617e02a5d2db971dcd55d" translate="yes" xml:space="preserve">
          <source>If variable &lt;code&gt;v&lt;/code&gt; at the cursor is depended on by any earlier variable &lt;code&gt;w&lt;/code&gt;, move &lt;code&gt;v&lt;/code&gt; immediately before the leftmost such &lt;code&gt;w&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f59d5d88acf30508b2934ebb596d83dcf81d86" translate="yes" xml:space="preserve">
          <source>If we aren&amp;rsquo;t concerned about preserving the evaluatedness of a variable, we can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; command behaves exactly like &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, except that it forces the evaluation of any thunks it encounters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46aacca2dc2b515359c3629f8b545b4072e9cb10" translate="yes" xml:space="preserve">
          <source>If we expanded the superclasses of &lt;code&gt;C Id&lt;/code&gt; we&amp;rsquo;d get first &lt;code&gt;Id (C Id)&lt;/code&gt; and thence &lt;code&gt;C Id&lt;/code&gt; again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab06f8bed3c50d147e0f34ef14e2a2bfe485f229" translate="yes" xml:space="preserve">
          <source>If we map the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; constructor, the entire list should be returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7cadd59d96946a92a3e4e327a5bdc6e946f758a" translate="yes" xml:space="preserve">
          <source>If we need to combine multiple values we can use the &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; function to do so. We need to ensure however that we have at least one value to operate on, since otherwise our result would be undefined. It is for this reason that &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; uses &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty&lt;/a&gt; - a list that can never be empty:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3467969828fd41de06ba2ada1d51483a9746f64f" translate="yes" xml:space="preserve">
          <source>If we now load a file into GHCi, the prompt will change:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f9b336b3695cb29c6493fac4402515a8e4d030" translate="yes" xml:space="preserve">
          <source>If we now modify the source of &lt;code&gt;D&lt;/code&gt; (or pretend to: using the Unix command &lt;code&gt;touch&lt;/code&gt; on the source file is handy for this), the compiler will no longer be able to use the object file, because it might be out of date:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b556699afcea8a3861c7bd49d57539e01604beee" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS installs signal handlers to catch things like &lt;code&gt;Ctrl-C&lt;/code&gt;. This option is primarily useful for when you are using the Haskell code as a DLL, and want to set your own signal handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47cebe51b03f623c16d891f461a3756b2773fce" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows installs exception handlers to catch unhandled exceptions using the Windows exception handling mechanism. This option is primarily useful for when you are using the Haskell code as a DLL, and don&amp;rsquo;t want the RTS to ungracefully terminate your application on erros such as segfaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862def3a23c265087b17b9a922955600a2924ede" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a core dump on any crash. These dumps can be inspected using debuggers such as WinDBG. The dumps record all code, registers and threading information at the time of the crash. Note that this implies &lt;code&gt;&amp;ndash;install-seh-handlers=yes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babf43c52d9b937cdcace43cdc2f276acdb87956" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a stack trace on crashes if exception handling are enabled. In order to get more information in compiled executables, C code or DLLs symbols need to be available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75dc4a8f44681567411c7cc8c3553fb7e90b3d1c" translate="yes" xml:space="preserve">
          <source>If you absolutely positively want all the rest of the options in a command line to go to the program (and not the RTS), use a &lt;code&gt;--RTS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb60052601f4a3531e65c7d5067016decf78928" translate="yes" xml:space="preserve">
          <source>If you also use &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;, you can write an unboxed tuple in a type synonym:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705b934efdf6451c14bd14b83d658533f8914cf9" translate="yes" xml:space="preserve">
          <source>If you are building GHC from source, you need at least a stage-2 bootstrap compiler to run Template Haskell splices and quasi-quotes. A stage-1 compiler will only accept regular quotes of Haskell. Reason: TH splices and quasi-quotes compile and run a program, and then looks at the result. So it&amp;rsquo;s important that the program it compiles produces results whose representations are identical to those of the compiler itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969473549eb7eda775de0bbd5b7e1c35fe2a3fe0" translate="yes" xml:space="preserve">
          <source>If you are down to your last-compile-before-a-bug-report, we would recommend that you add a &lt;code&gt;-dcore-lint&lt;/code&gt; option (for extra checking) to your compilation options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8db781218acb5f2994b23e09a56675a86f2ceeb8" translate="yes" xml:space="preserve">
          <source>If you are hit by this, you may want to compile the affected module with &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt;&lt;code&gt;-fno-omit-yields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;). This flag ensures that yield points are inserted at every function entrypoint (at the expense of a bit of performance).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2cd5fd786322ce97e57aaf58e15a0f10e358b1" translate="yes" xml:space="preserve">
          <source>If you are making foreign calls from multiple Haskell threads and using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, make sure that the foreign code you are calling is thread-safe. In particularly, some GUI libraries are not thread-safe and require that the caller only invokes GUI methods from a single thread. If this is the case, you may need to restrict your GUI operations to a single Haskell thread, and possibly also use a bound thread (see &lt;a href=&quot;#haskell-threads-and-os-threads&quot;&gt;The relationship between Haskell threads and OS threads&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cb86bb37d550f99fb107d358e09f2ff4997d45" translate="yes" xml:space="preserve">
          <source>If you are setting language options in your &lt;code&gt;.ghci&lt;/code&gt; file, it is good practice to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;, unless you really do want them to apply to all modules you load in GHCi.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2780984904c2d880871374ff9ccab143b480b0b2" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97f8aaadda196835b4af2ea1886f79e9ad8ac0e" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f294dc39561bb7510ab182cdc6070d0d208bd977" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;make&lt;/code&gt;, GHC can automatically generate the dependencies required in order to make sure that every module &lt;em&gt;is&lt;/em&gt; up-to-date with respect to its imported interfaces. Please see &lt;a href=&quot;separate_compilation#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64df0960b34991e4d85de84eb1668ccd834d0e6f" translate="yes" xml:space="preserve">
          <source>If you are using a Haskell &amp;ldquo;package&amp;rdquo; (see &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;), don&amp;rsquo;t forget to add the relevant &lt;code&gt;-package&lt;/code&gt; option when linking the program too: it will cause the appropriate libraries to be linked in with the program. Forgetting the &lt;code&gt;-package&lt;/code&gt; option will likely result in several pages of link errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7cc346da82320cb12d47cf0a63adf255287f4d" translate="yes" xml:space="preserve">
          <source>If you are using as system that doesn't support the mkdtemp glibc function (supported in glibc &amp;gt; 2.1.91) then this function uses mktemp and so shouldn't be considered safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755c446ad00dee715ae6a725a7e54ef9a2b3bb98" translate="yes" xml:space="preserve">
          <source>If you are using as system that doesn't support the mkstemps glibc function (supported in glibc &amp;gt; 2.11) then this function simply throws an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ce0801a711815e8a0985a07d3d4a08fee712a7" translate="yes" xml:space="preserve">
          <source>If you are using external packages with &lt;strong&gt;cabal&lt;/strong&gt;, you may need to reinstall these packages with profiling support; typically this is done with &lt;code&gt;cabal install -p package --reinstall&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449e0cceb9882f742ae4ba71b581c42c65c1bc09" translate="yes" xml:space="preserve">
          <source>If you aren't using GHC or Hugs then this function simply wraps mktemp and so shouldn't be considered safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57e71626bccca627c9de3e0d23513402fbfad64" translate="yes" xml:space="preserve">
          <source>If you can't be bothered with the above, then you can build simple tables with simpleTable. Just provide the attributes for the whole table, attributes for the cells (same for every cell), and a list of lists of cell contents, and this function will build the table for you. It does presume that all the lists are non-empty, and there is at least one list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1274d2d2a7e0ba4a2c783c4ef67e9c677accd2" translate="yes" xml:space="preserve">
          <source>If you do not have an explicit export list in a module, GHC must assume that everything in that module will be exported. This has various pessimising effects. For example, if a bit of code is actually &lt;em&gt;unused&lt;/em&gt; (perhaps because of unfolding effects), GHC will not be able to throw it away, because it is exported and some other module may be relying on its existence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1ecd7c0b5ed67d9ee213cf7d0666e703994546" translate="yes" xml:space="preserve">
          <source>If you do not need the offset parameter then you do should be using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringLen&quot;&gt;unsafePackCStringLen&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringFinalizer&quot;&gt;unsafePackCStringFinalizer&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dacf0556d43b3d2afe433d11b8b9c360f1380a6b" translate="yes" xml:space="preserve">
          <source>If you do not write out the constructors, you may need to give a kind annotation (&lt;a href=&quot;glasgow_exts#kinding&quot;&gt;Explicitly-kinded quantification&lt;/a&gt;), to tell GHC the kind of the type variable, if it is not &amp;ldquo;*&amp;rdquo;. (In source files, this is worked out from the way the type variable is used in the constructors.) For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4308cfa9bfacb8d98d2c6bb15e1dd09df45e6181" translate="yes" xml:space="preserve">
          <source>If you do not write out the constructors, you may need to give a kind to tell GHC what the kinds of the type variables are, if they are not the default &lt;code&gt;*&lt;/code&gt;. Unlike regular data type declarations, the return kind of an abstract data declaration can be anything (in which case it probably will be implemented using a type synonym.) This can be used to allow compile-time representation polymorphism (as opposed to &lt;a href=&quot;#runtime-rep&quot;&gt;run-time representation polymorphism&lt;/a&gt;), as in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d8e4e35d4f313452afad0626c5a13b4457d20a" translate="yes" xml:space="preserve">
          <source>If you do want custom history behavior, you may need to disable the above default setting(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbfd1c6f422cd2cb2dbbb7fda57624d1324776cf" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have &lt;code&gt;cygpath&lt;/code&gt;, you probably don&amp;rsquo;t have cygwin and hence no problems with it... unless you want to write one build process for several platforms. Again, relative paths are your friend, but if you have to use absolute paths, and don&amp;rsquo;t want to use different tools on different platforms, you can simply write a short Haskell program to print the current directory (thanks to George Russell for this idea): compiled with GHC, this will give you the view of the file system that GHC depends on (which will differ depending on whether GHC is compiled with cygwin&amp;rsquo;s gcc or mingw&amp;rsquo;s gcc or on a real Unix system..) - that little program can also deal with escaping &lt;code&gt;\\&lt;/code&gt; in paths. Apart from the banner and the startup time, something like this would also do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ca8436639b62f991d1a8bca7a44877f0eba7f3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know what virtual memory, thrashing, and page faults are, or you don&amp;rsquo;t know the memory configuration of your machine, &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; try to be clever about memory use: you&amp;rsquo;ll just make your life a misery (and for other people, too, probably).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa78b2c4ba732d90be891c20923a016c2ca06a59" translate="yes" xml:space="preserve">
          <source>If you don't care about leap seconds, use &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;NominalDiffTime&lt;/code&gt; for your clock calculations, and you'll be fine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fa5b3759632ec86596531c30715d1630f054a4" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider use &lt;code&gt;Data.HashMap.Strict&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919994a6ad24d536810a2f90a16851626c53afe9" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider using &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbad3655a306b0eed532c2a8565759cd003f86c6" translate="yes" xml:space="preserve">
          <source>If you don't use the &lt;code&gt;-threaded&lt;/code&gt; option, then the runtime does not make use of multiple OS threads. Foreign calls will block all other running Haskell threads until the call returns. The &lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt; library still does multiplexing, so there can be multiple threads doing I/O, and this is handled internally by the runtime using &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798faf56167bc1eadc054491085974ccd1b8e71f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f18162bea62ea91e089db538307585a73e927f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181e16d814261217260a59c6eebf52bfe99f472f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead50587e0a0cdc543693c999e66d196c802d0fa" translate="yes" xml:space="preserve">
          <source>If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e72fd7c3e56cd41e50c2977a39a79818e565356" translate="yes" xml:space="preserve">
          <source>If you feel your code warrants modifying these settings please consult the source code for default values and documentation. But I strongly advise against this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b8dd6cc517c8e6f32241fd0c8da26f585dc4a7" translate="yes" xml:space="preserve">
          <source>If you find cases of significant performance regressions, which can be traced back to obviously bad code layout please open a ticket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddd7a1b6ed2ec9f8ddbaa4b9719044314989fa0" translate="yes" xml:space="preserve">
          <source>If you forget the &lt;code&gt;-watch&lt;/code&gt; flag you can still select &amp;ldquo;Watch file&amp;rdquo; from the &amp;ldquo;State&amp;rdquo; menu. Now each time you generate a new profile &lt;code&gt;FOO.ps&lt;/code&gt; the view will update automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b468bbdec19642d76f696af7811d40687e4a9c8" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt; enabled, tuple sections will also be available for them, like so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a2a18f9fd122d9f155cead5fb45d6a3af3ea4b" translate="yes" xml:space="preserve">
          <source>If you have specific requirements about the encoding format, you can use the encoding and decoding primitives directly, see the modules &lt;a href=&quot;data-binary-get&quot;&gt;Data.Binary.Get&lt;/a&gt; and &lt;a href=&quot;data-binary-put&quot;&gt;Data.Binary.Put&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedbc3661026d144c58745e2aaa481b83a3bdcbc" translate="yes" xml:space="preserve">
          <source>If you have to use absolute paths (beware of the innocent-looking &lt;code&gt;ROOT=$(pwd)&lt;/code&gt; in makefile hierarchies or configure scripts), Cygwin provides a tool called &lt;code&gt;cygpath&lt;/code&gt; that can convert Cygwin&amp;rsquo;s Unix-style paths to their actual Windows-style counterparts. Many Cygwin tools actually accept absolute Windows-style paths (remember, though, that you either need to escape &lt;code&gt;\\&lt;/code&gt; or convert &lt;code&gt;\\&lt;/code&gt; to &lt;code&gt;/&lt;/code&gt;), so you should be fine just using those everywhere. If you need to use tools that do some kind of path-mangling that depends on unix-style paths (one fun example is trying to interpret &lt;code&gt;:&lt;/code&gt; as a separator in path lists), you can still try to convert paths using &lt;code&gt;cygpath&lt;/code&gt; just before they are passed to GHC and friends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4762767c31f000dd608b9d320e6a27ecd6749f85" translate="yes" xml:space="preserve">
          <source>If you have trouble because of running out of space in &lt;code&gt;/tmp&lt;/code&gt; (or wherever your installation thinks temporary files should go), you may use the &lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; option option to specify an alternate directory. For example, &lt;code&gt;-tmpdir .&lt;/code&gt; says to put temporary files in the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0263efca84aff634e475d876d93d1d53987bcc2" translate="yes" xml:space="preserve">
          <source>If you know in advance that you will be working with data that has a specific encoding (e.g. UTF-8), and your application is highly performance sensitive, you may find that it is faster to perform I/O with bytestrings and to encode and decode yourself than to use the functions in this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9980c81f41f8848255c9b3c4f5b6f35d26a2660e" translate="yes" xml:space="preserve">
          <source>If you locally define a signature which specifies &lt;code&gt;type Elem = Char&lt;/code&gt;, you can now use &lt;code&gt;head&lt;/code&gt; from the inherited signature as if it returned a &lt;code&gt;Char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a2b1931884bf135bea0a3fa27795d553e75cd2" translate="yes" xml:space="preserve">
          <source>If you make some changes to the source code and want GHCi to recompile the program, give the &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command. The program will be recompiled as necessary, with GHCi doing its best to avoid actually recompiling modules if their external dependencies haven&amp;rsquo;t changed. This is the same mechanism we use to avoid re-compiling modules in the batch compilation setting (see &lt;a href=&quot;separate_compilation#recomp&quot;&gt;The recompilation checker&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9454e1d6cb0edc697a136b26feb4f14fca0245" translate="yes" xml:space="preserve">
          <source>If you must use a non-UTF-8 locale on an older version of GHC, you will have to perform the transcoding yourself, e.g. as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0177890eaf8c9853290382c679f931e99463619" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1d6d4a81148f3b4501f77ab4535df2eb1411a3" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60305b59f145cbe3c8640c6266d72f000c109cde" translate="yes" xml:space="preserve">
          <source>If you need to unmask asynchronous exceptions again in the exception handler, &lt;code&gt;restore&lt;/code&gt; can be used there too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4591e0c74e5d8610c0f46b0b70574c886adac838" translate="yes" xml:space="preserve">
          <source>If you need to write your own builder primitives, then be aware that you are writing code with &lt;em&gt;all saftey belts off&lt;/em&gt;; i.e., *this is the code that might make your application vulnerable to buffer-overflow attacks!* The &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests&lt;/a&gt; module provides you with utilities for testing your encodings thoroughly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85034b2140ed46e219a17c0fb6a82d6555ea6a0b" translate="yes" xml:space="preserve">
          <source>If you redirect the interface file somewhere that GHC can&amp;rsquo;t find it, then the recompilation checker may get confused (at the least, you won&amp;rsquo;t get any recompilation avoidance). We recommend using a combination of &lt;code&gt;-hidir&lt;/code&gt; and &lt;code&gt;-hisuf&lt;/code&gt; options instead, if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c56d9c704da4ef4488b84c4ca979cb6f42ee172" translate="yes" xml:space="preserve">
          <source>If you run GHCi in a Cygwin or MSYS shell, then the Control-C behaviour is adversely affected. In one of these environments you should use the &lt;code&gt;ghcii.sh&lt;/code&gt; script to start GHCi, otherwise when you hit Control-C you&amp;rsquo;ll be returned to the shell prompt but the GHCi process will still be running. However, even using the &lt;code&gt;ghcii.sh&lt;/code&gt; script, if you hit Control-C then the GHCi process will be killed immediately, rather than letting you interrupt a running program inside GHCi as it should. This problem is caused by the fact that the Cygwin and MSYS shell environments don&amp;rsquo;t pass Control-C events to non-Cygwin child processes, because in order to do that there needs to be a Windows console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499bbb66890db92d2aef64ba55e59fe5e3a4a579" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; flag appropriately when linking (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), you can give RTS options on the command line when running your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779ae353821cb3c36339c8fffc8e4e1da51bc948" translate="yes" xml:space="preserve">
          <source>If you specify the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo;, GHC will in addition normalise the type by expanding out type synonyms and evaluating type-function applications, and display the normalised result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17573b39128b09ddb274fe402c07a3712fa0b038" translate="yes" xml:space="preserve">
          <source>If you started up GHCi from the command line then GHCi&amp;rsquo;s current directory is the same as the current directory of the shell from which it was started. If you started GHCi from the &amp;ldquo;Start&amp;rdquo; menu in Windows, then the current directory is probably something like &lt;code&gt;C:\Documents and Settings\user name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba902f4235b03731027db2ba203807d60051b0f0" translate="yes" xml:space="preserve">
          <source>If you still have a problem after consulting this section, then you may have found a &lt;em&gt;bug&lt;/em&gt;&amp;mdash;please report it! See &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt; for details on how to report a bug and a list of things we&amp;rsquo;d like to know about your bug. If in doubt, send a report &amp;mdash; we love mail from irate users :-!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6e307b2815d284d219246f3cc396f72341fb96" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt;, you should ensure that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9036a091eb31d7e1d179225efb47ed576aaf8c2" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt;, ensure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43deefe8a45aff4b957628597a98f2d9c624d164" translate="yes" xml:space="preserve">
          <source>If you supply both, you should also ensure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ad27dbd268005c25e921cdbe065308694238cd" translate="yes" xml:space="preserve">
          <source>If you think of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value as an array of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values (which it is not), you run the risk of writing inefficient code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de2aa2ed3ef394e6e0d1016569003785b8ad818" translate="yes" xml:space="preserve">
          <source>If you think that GHC could have produced a better error message, please report it as a bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f6f86d2972b585d04fe43fdaef1e7b40cc4531" translate="yes" xml:space="preserve">
          <source>If you turn on the &lt;code&gt;+t&lt;/code&gt; option, GHCi will show the type of each variable bound by a statement. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5833a6633f41ece1646113439cfc7147d21b2d27" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;ghc --make&lt;/code&gt; and you don&amp;rsquo;t use the &lt;code&gt;-o&lt;/code&gt;, the name GHC will choose for the executable will be based on the name of the file containing the module &lt;code&gt;Main&lt;/code&gt;. Note that with GHC the &lt;code&gt;Main&lt;/code&gt; module doesn&amp;rsquo;t have to be put in file &lt;code&gt;Main.hs&lt;/code&gt;. Thus both</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8fe07ab672e6ec151ea93a6073a6731a1a39a86" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt;&lt;code&gt;-Wmissing-local-signatures&lt;/code&gt;&lt;/a&gt; flag GHC will warn you about any polymorphic local bindings. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28c5895543f69e7126cf50a6926f46b942709ca" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5a15f9c3c8b55e5de03f7f69c8dd111c9672ec" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-s&lt;/code&gt; flag then, when your program finishes, you will see something like this (the exact details will vary depending on what sort of RTS you have, e.g. you will only see profiling data if your RTS is compiled for profiling):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b228a004af7cc3ea3defaec36492a49b21092145" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-t&lt;/code&gt; flag then, when your program finishes, you will see something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42843f480d669d0dd71c1f456d85a83006a59f62" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt;, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Wno-orphans&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; will make the compilation fail if the warning is issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3539d052ca8f3d12bdfa6a2cf6c42e142aedfd6e" translate="yes" xml:space="preserve">
          <source>If you want a RULE that truly applies to the overloaded class method, the only way to do it is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc687a75092e5bd8f51f4c5f01b8880c77b9787b" translate="yes" xml:space="preserve">
          <source>If you want impredicative polymorphism, the main workaround is to use a newtype wrapper. The &lt;code&gt;id runST&lt;/code&gt; example can be written using this workaround like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51a0b4a5af5e77d81a82bb08f150b3da8ce734c3" translate="yes" xml:space="preserve">
          <source>If you want line-buffered behaviour, as in GHC, you can start your program thus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca971e710dc0dea81074a50ffdb031c934cf7b8" translate="yes" xml:space="preserve">
          <source>If you want the latter type, you can write your &lt;code&gt;forall&lt;/code&gt;s explicitly. Indeed, doing so is strongly advised for rank-2 types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549a9b63d55271a3b9df4de32eb523229040185b" translate="yes" xml:space="preserve">
          <source>If you want the program to wait for child threads to finish before exiting, you need to program this yourself. A simple mechanism is to have each child thread write to an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; when it completes, and have the main thread wait on all the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s before exiting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9571a9dcbff8738c6a55f4c7676d668b8f5fc0" translate="yes" xml:space="preserve">
          <source>If you want to also pass some data back from the C callback to Haskell, this is best done by first allocating some memory in Haskell to receive the data, and passing the address to C, as we did in the above example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34429256ffca9baa1e5bbc692ae867402400276" translate="yes" xml:space="preserve">
          <source>If you want to create hard link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-hardlink#v:createHardLink-39-&quot;&gt;createHardLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791c272c3172b5ca90ccf11219abe251062c8501" translate="yes" xml:space="preserve">
          <source>If you want to create symbolic link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3df7bf8a33fccc5739143bc2735696e4c097cb3" translate="yes" xml:space="preserve">
          <source>If you want to do some cleanup in the event that an exception is raised, use &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4838ba039983c15a539bfb6ca822e21c42138c" translate="yes" xml:space="preserve">
          <source>If you want to do the steps manually or are writing your own build system then there are certain conventions that must be followed. Building a shared library that exports Haskell code, to be used by other Haskell code is a bit more complicated than it is for one that exports a C API and will be used by C code. If you get it wrong you will usually end up with linker errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fb26a20e253d10479d39da2a4fcad468dce057" translate="yes" xml:space="preserve">
          <source>If you want to give a cost centre different name than the function name, you can pass a string to the annotation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4f1ffc646261bf14798c8c4f8089e635cc58af" translate="yes" xml:space="preserve">
          <source>If you want to make use of assertions in your standard Haskell code, you could define a function like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f423384a233b13b91f89809f16b0b043668524f" translate="yes" xml:space="preserve">
          <source>If you want to mention any of the primitive data types or operations in your program, you must first import &lt;code&gt;GHC.Prim&lt;/code&gt; to bring them into scope. Many of them have names ending in &lt;code&gt;#&lt;/code&gt;, and to mention such names you need the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61014e31e4e9b046a9ef2fe3074becc72ef93381" translate="yes" xml:space="preserve">
          <source>If you want to opt out of all preprocessing just expliticly use namespaces in your paths. Due to this change, if you need to open raw devices (e.g. COM ports) you need to use the device namespace explicitly. (e.g. &lt;code&gt;\\.\COM1&lt;/code&gt;). GHC and Haskell programs in general no longer support opening devices in the legacy format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebcdc956ed871c44f4c6bca024bf09987c0e4ea" translate="yes" xml:space="preserve">
          <source>If you want to reexport an entity from a signature, you must also include a &lt;code&gt;module SigName&lt;/code&gt; export, so that all of the entities defined in the signature are exported. For example, the following module exports both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; from &lt;code&gt;Prelude&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5bd52fcd4928ca0545145bd2a955f15998cd35" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf3e986051a32ecf5c1ec7e4a43659b77ba4029" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60cbafbc7fa66b6dc79d12e60e2984d79a1c2f8" translate="yes" xml:space="preserve">
          <source>If you want to write your own good consumers or producers, look at the Prelude definitions of the above functions to see how to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3353ab3b67d47aa44c20e1d16cbe4a8241b654" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every exported top-level function/value has a type signature, but not check unexported values, use the &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; option. This option takes precedence over &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt;. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb30d07648b8cbbd10ad61170b84d1c688b54b88" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every pattern synonym has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-pattern-synonym-signatures&quot;&gt;&lt;code&gt;-Wmissing-pattern-synonym-signatures&lt;/code&gt;&lt;/a&gt; option. If this option is used in conjunction with &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; then only exported pattern synonyms must have a type signature. GHC also reports the inferred type. This option is off by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640d34ea6f4536c99e1408cd399b64374ccf19de" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every top-level function/value has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt; option. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922fe94f618cace70dccf3e7c465abb01606e0ff" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re feeling really paranoid, the &lt;a href=&quot;debugging#ghc-flag--dcore-lint&quot;&gt;&lt;code&gt;-dcore-lint&lt;/code&gt;&lt;/a&gt; option is a good choice. It turns on heavyweight intra-pass sanity-checking within GHC. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a661b6665d9019ecdcc937c98f6c881af1386b5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;code&gt;Complex&lt;/code&gt;, definitely use &lt;code&gt;Complex Double&lt;/code&gt; rather than &lt;code&gt;Complex Float&lt;/code&gt; (the former is specialised heavily, but the latter isn&amp;rsquo;t).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea05e3cdd60f132f915750383a0d35497a9912f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Cabal, then the exposed or hidden status of a package is irrelevant: the available packages are instead determined by the dependencies listed in your &lt;code&gt;.cabal&lt;/code&gt; specification. The exposed/hidden status of packages is only relevant when using &lt;code&gt;ghc&lt;/code&gt; or &lt;code&gt;ghci&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0881127c805c94fe0b7925eea21f4274da0ef78" translate="yes" xml:space="preserve">
          <source>If you'd like to be able to set environment variables to blank strings, use &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99dd4325947ff2bc013e316ae08d0a505ef5df45" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;GHC.Generics&lt;/code&gt;, you should consider using the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving&lt;/a&gt; package, which contains many useful generic functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf81c24bf66e4ccd3de419acbb16c71960559688" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9d738102f8d206b5388e75296045ea1b95c56d" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94332bc18cf68bdf173c4385ef20100acbd02982" translate="yes" xml:space="preserve">
          <source>If your datatype has a single constructor with a single field, use a &lt;code&gt;newtype&lt;/code&gt; declaration instead of a &lt;code&gt;data&lt;/code&gt; declaration. The &lt;code&gt;newtype&lt;/code&gt; will be optimised away in most cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1b5c441eca4c4d33097e3b6efbf4299541fa8b" translate="yes" xml:space="preserve">
          <source>If your program contains multiple modules, then you only need to tell GHC the name of the source file containing the &lt;code&gt;Main&lt;/code&gt; module, and GHC will examine the &lt;code&gt;import&lt;/code&gt; declarations to find the other modules that make up the program and find their source files. This means that, with the exception of the &lt;code&gt;Main&lt;/code&gt; module, every source file should be named after the module name that it contains (with dots replaced by directory separators). For example, the module &lt;code&gt;Data.Person&lt;/code&gt; would be in the file &lt;code&gt;Data/Person.hs&lt;/code&gt; on Unix/Linux/Mac, or &lt;code&gt;Data\Person.hs&lt;/code&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c51f85806fd47c9dd60cc6181af38ca30de15c" translate="yes" xml:space="preserve">
          <source>If your program has no foreign calls in it, and no calls to known-unsafe functions (such as &lt;code&gt;unsafePerformIO&lt;/code&gt;) then a crash is always a BUG in the GHC system, except in one case: If your program is made of several modules, each module must have been compiled after any modules on which it depends (unless you use &lt;code&gt;.hi-boot&lt;/code&gt; files, in which case these &lt;em&gt;must&lt;/em&gt; be correct with respect to the module source).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24caa1726f2cf05e2f221b7c2e73786d79f53d8" translate="yes" xml:space="preserve">
          <source>If your program&amp;rsquo;s GC stats (&lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS option) indicate that it&amp;rsquo;s doing lots of garbage-collection (say, more than 20% of execution time), more memory might help &amp;mdash; with the &lt;code&gt;-H⟨size⟩&lt;/code&gt; or &lt;code&gt;-A⟨size⟩&lt;/code&gt; RTS options (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;). As a rule of thumb, try setting &lt;code&gt;-H ⟨size⟩&lt;/code&gt; to the amount of memory you&amp;rsquo;re willing to let your process consume, or perhaps try passing &lt;code&gt;-H ⟨size⟩&lt;/code&gt; without any argument to let GHC calculate a value based on the amount of live data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d51b512922ef864f145abd749faf72a2827c750" translate="yes" xml:space="preserve">
          <source>If your shared library exports a Haskell API then you cannot directly link it into another Haskell program and use that Haskell API. You will get linker errors. You must instead make it into a package as described in the section above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d789f4ed9268a1d21783901d260313592caf0cd5" translate="yes" xml:space="preserve">
          <source>If ⟨n⟩ is omitted, level 2 is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e8f60e1dacd712159be5f50380ce32b92d474d" translate="yes" xml:space="preserve">
          <source>If ⟨prompt⟩ starts with &lt;code&gt;&quot;&lt;/code&gt; then it is parsed as a Haskell String; otherwise it is treated as a literal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40887e4a14555fe188999a20b1ed14821cfa667" translate="yes" xml:space="preserve">
          <source>If ⟨size⟩ is omitted, then the garbage collector will take the size of the heap at the previous GC as the ⟨size⟩. This has the effect of allowing for a larger &lt;code&gt;-A&lt;/code&gt; value but without increasing the overall memory requirements of the program. It can be useful when the default small &lt;code&gt;-A&lt;/code&gt; value is suboptimal, as it can be in programs that create large amounts of long-lived data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cbf12867cec0a1cfdbab9049d695f31f35ad31" translate="yes" xml:space="preserve">
          <source>If, as a library author of a type constructor like &lt;code&gt;Set a&lt;/code&gt;, you want to prevent a user of your module to write &lt;code&gt;coerce :: Set T -&amp;gt; Set NT&lt;/code&gt;, you need to set the role of &lt;code&gt;Set&lt;/code&gt;'s type parameter to &lt;code&gt;nominal&lt;/code&gt;, by writing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae8e5b9dd31d643002083a67d731779f470355f" translate="yes" xml:space="preserve">
          <source>If, however, you enable the extension &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt; when compiling the module that contains (D), GHC will instead pick (C), without complaining about the problem of subsequent instantiations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b618f909fc1ba5b25f3ecf49daabdeb00466da8" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581c6edcefcd8eed3b3ae0f7ff0449e91b4a1964" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0312c7db6cdd96c1e4afe75b973aea9e68784cd" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;ghc-arr#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3727d8d991f15f746dc285dd2ca3bc1e889211" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a437f0ed534e2c46aa15fd000c2c49a678255cee" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f1c19a944153820e63548e8f204d611cc0ec11" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ddcd1aa495c4907a6fe0bad7ff4515b81505d0" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f55db57c8ed898dbaabddea8af88630b3b7caf" translate="yes" xml:space="preserve">
          <source>Ignore</source>
          <target state="translated">Ignore</target>
        </trans-unit>
        <trans-unit id="6ced7795214ecfa08f172052b124c985d4dc2867" translate="yes" xml:space="preserve">
          <source>Ignore an invalid input, substituting nothing in the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de491836ac03baa0a19777da9dff92193700b2f" translate="yes" xml:space="preserve">
          <source>Ignore assertions in the source. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="796ae3faa0a04e8aa497303246f1859cfbe98a2a" translate="yes" xml:space="preserve">
          <source>Ignore cfg weights for code layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282a96dffe5fa4b96c3595d453205018d521d4f8" translate="yes" xml:space="preserve">
          <source>Ignore marks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619d7d17ba8aa59dc524ffcd3b64d16b188b1a3c" translate="yes" xml:space="preserve">
          <source>Ignore package ⟨pkg⟩</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591f0c15c8a037cd490c5cb494c2d82d49da6604" translate="yes" xml:space="preserve">
          <source>Ignore pragmas in interface files. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt; only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58001447e7c0f2060ba0e27ea5f58c03c12170c4" translate="yes" xml:space="preserve">
          <source>Ignore the exposed flag on installed packages, and hide them all by default. If you use this flag, then any packages you require (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly exposed using &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1acc423ed92fdcade39f871d86c0a091be2b4d" translate="yes" xml:space="preserve">
          <source>Ignore the trusted flag on installed packages, and distrust them by default. If you use this flag and Safe Haskell then any packages you require to be trusted (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly trusted using &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; options. This option does not change the exposed/hidden status of a package, so it isn&amp;rsquo;t equivalent to applying &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; to all packages on the system. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a80c4097f230ea51440815b595a3404f62d484" translate="yes" xml:space="preserve">
          <source>IgnoreBreak</source>
          <target state="translated">IgnoreBreak</target>
        </trans-unit>
        <trans-unit id="4bc3560f87c85dba51d0aa8d52c5b4fea219fa0e" translate="yes" xml:space="preserve">
          <source>IgnoreCR</source>
          <target state="translated">IgnoreCR</target>
        </trans-unit>
        <trans-unit id="5cc74aacba3116f5c95cef183a2a38286abfa5de" translate="yes" xml:space="preserve">
          <source>IgnoreCodingFailure</source>
          <target state="translated">IgnoreCodingFailure</target>
        </trans-unit>
        <trans-unit id="fe3f599d5da3fc2eaa2412ebe7eba8e9f6ce8049" translate="yes" xml:space="preserve">
          <source>IgnoreParityErrors</source>
          <target state="translated">IgnoreParityErrors</target>
        </trans-unit>
        <trans-unit id="7045891c278655482762e70dd83a0b56759287f9" translate="yes" xml:space="preserve">
          <source>Ignoring breakpoints for a specified number of iterations is also possible using similar techniques.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2575568b1dcfc64c91f1f0fba9eba34462ba8283" translate="yes" xml:space="preserve">
          <source>IllegalOperation</source>
          <target state="translated">IllegalOperation</target>
        </trans-unit>
        <trans-unit id="21b60a9549daf6edf60beed5d20bc1d15c3b1b25" translate="yes" xml:space="preserve">
          <source>Immediately</source>
          <target state="translated">Immediately</target>
        </trans-unit>
        <trans-unit id="06ecb0ede3eff0f856805c208c7b6f7685988a9a" translate="yes" xml:space="preserve">
          <source>Immutable array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f741bf79c240632317d4b768abc8b5c1a34b775c" translate="yes" xml:space="preserve">
          <source>Immutable arrays, with an overloaded interface. For array types which can be used with this interface, see the &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; type exported by this module and the &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; module. Other packages, such as diffarray, also provide arrays using this interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2439111ed8a6dd1e9e35ac3526ebfdf6f8659f07" translate="yes" xml:space="preserve">
          <source>Immutable non-strict (boxed) arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0150626bdfa29e3185274acde3b82736d872c8f" translate="yes" xml:space="preserve">
          <source>Immutable non-strict arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6434427f6f7e2bf4d2041f12cd8285fbd475e3" translate="yes" xml:space="preserve">
          <source>ImplBidir</source>
          <target state="translated">ImplBidir</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3c9c8e530dca9330d05d5aa3109b2b8286699aca" translate="yes" xml:space="preserve">
          <source>Implementation Internals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f225c7ab898261af0638456301826901232d3d11" translate="yes" xml:space="preserve">
          <source>Implementation details aside, the function names in the stack should hopefully give you enough clues to track down the bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f0e36fb0e54bb9f6609b935523e843d65a2659" translate="yes" xml:space="preserve">
          <source>Implementations for the character predicates (isLower, isUpper, etc.) and the conversions (toUpper, toLower). The implementation uses libunicode on Unix systems if that is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4803faa28409cecc36571d8ab8726f7adec639ce" translate="yes" xml:space="preserve">
          <source>Implementations should enforce as far as possible, at least locally to the Haskell process, multiple-reader single-writer locking on files. That is, &lt;em&gt;there may either be many handles on the same file which manage input, or just one handle on the file which manages output&lt;/em&gt;. If any open or semi-closed handle is managing a file for output, no new handle can be allocated for that file. If any open or semi-closed handle is managing a file for input, new handles can only be allocated if they do not manage output. Whether two files are the same is implementation-dependent, but they should normally be the same if they have the same absolute path name and neither has been renamed, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b15fdd44b258375ec9508491e65e9614ff63d6" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9605b9875596b2f9957b69963d14d19dbd98a4" translate="yes" xml:space="preserve">
          <source>Implemented using an algorithm adapted from /Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design&lt;em&gt;, by Chris Okasaki, &lt;/em&gt;ICFP'00/.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce44457603020d3e393a5770d9319edff0c59393" translate="yes" xml:space="preserve">
          <source>Implicit call stacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4767a7af64b718f0f087f2f77c45daac0f221c4" translate="yes" xml:space="preserve">
          <source>Implicit parameter binding declaration. Can only be used in let and where clauses which consist entirely of implicit bindings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5e6bdeb8195ae9a56250fa5a11abb1b4c4ca76" translate="yes" xml:space="preserve">
          <source>Implicit parameters (see &lt;a href=&quot;glasgow_exts#implicit-parameters&quot;&gt;Implicit parameters&lt;/a&gt;) are only available at the scope of a breakpoint if there is an explicit type signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96344ea55749ca67fb2833fb9d1ea7587feab87a" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id60&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d896817ab0c9fc745a6846e04e6e0b797e133fb2" translate="yes" xml:space="preserve">
          <source>Implicit-parameter constraints do not cause ambiguity. For example, consider:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96fdb8318fd32f2e2e39a2a6d18b9f85a8f84b4" translate="yes" xml:space="preserve">
          <source>ImplicitParams</source>
          <target state="translated">ImplicitParams</target>
        </trans-unit>
        <trans-unit id="2b2233be7646337ec9333a40a93e6817457da678" translate="yes" xml:space="preserve">
          <source>ImplicitPrelude</source>
          <target state="translated">ImplicitPrelude</target>
        </trans-unit>
        <trans-unit id="9084c82dfec5377f9fc397a036577c18a18be8e1" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt;, otherwise off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b621c4b935c566b23caad050661b44248a2aea06" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wdeferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f431cb19e87fba9b86d9726b255a020698520002" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wtyped-holes&quot;&gt;&lt;code&gt;-Wtyped-holes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb21b29dd0fa6b86f91cfc36f481aa089a2398e" translate="yes" xml:space="preserve">
          <source>Implied by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6242df79ef25a40efdb6b02069e963ee6c75ae36" translate="yes" xml:space="preserve">
          <source>Implies:</source>
          <target state="translated">Implies:</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="1de625c46836a8d690ceb58d45293b81c48c397e" translate="yes" xml:space="preserve">
          <source>Import a module by &lt;code&gt;hs-boot&lt;/code&gt; file to break a module loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a02ed60dd913a32866007cb8b0f286d068920a" translate="yes" xml:space="preserve">
          <source>Import statements and scoping rules are exactly as in Haskell. To mention a non-Prelude type or class, you must import it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccaf39f584206e7c3969db9d359129399c8be167" translate="yes" xml:space="preserve">
          <source>Import the patterns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ace903aa74341e5d1ccb710b3fdc2bed74b4565" translate="yes" xml:space="preserve">
          <source>Import/export functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df41abfd75ae06055cd5c44bb9065e3454ceee7" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179fcf640a3d899c14d346ac25778d5710538175" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c64cf2f235ca7554567f7534fe0b43d5677eea" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4589bf4e9a6ce37b31d36f0a6e150b4292fb9be8" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c537cf521e62d230fcbda7200d4c65bb85bb9950" translate="yes" xml:space="preserve">
          <source>Importantly, GHC will &lt;strong&gt;never&lt;/strong&gt; infer a &lt;code&gt;HasCallStack&lt;/code&gt; constraint, you must request it explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209a185dcdc64df7c89fd6b4a06c378dd59a523b" translate="yes" xml:space="preserve">
          <source>Imports can be &lt;em&gt;removed&lt;/em&gt; from the context, using the syntax &lt;code&gt;:module -M&lt;/code&gt;. The &lt;code&gt;import&lt;/code&gt; syntax is cumulative (as in a Haskell module), so this is the only way to subtract from the scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d8d8c71e07fcca11b70e8d6722717ba5c7bbd1" translate="yes" xml:space="preserve">
          <source>ImpredicativeTypes</source>
          <target state="translated">ImpredicativeTypes</target>
        </trans-unit>
        <trans-unit id="ada1b47a54b4c0472b230f71a39fa22ace4b62eb" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this algorithm's complexity degrades towards O(n*m).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b4f236af14825a1f87646152c7ae5ae54d6f1b" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this function's time complexity degrades towards O(n*m).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cba8ae40b482d6815c0aed2cb5cad28971bc60" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode and &lt;a href=&quot;using#ghc-flag---interactive&quot;&gt;&lt;code&gt;--interactive&lt;/code&gt;&lt;/a&gt; mode (see &lt;a href=&quot;using#modes&quot;&gt;Modes of operation&lt;/a&gt;), the compiler normally determines which packages are required by the current Haskell modules, and links only those. In batch mode however, the dependency information isn&amp;rsquo;t available, and explicit &lt;code&gt;-package&lt;/code&gt; options must be given when linking. The one other time you might need to use &lt;code&gt;-package&lt;/code&gt; to force linking a package is when the package does not contain any Haskell modules (it might contain a C library only, for example). In that case, GHC will never discover a dependency on it, so it has to be mentioned explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9c1cc6f5410615b774e4fbc397355fcbc8c4fd" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&quot;wrong1&quot;&lt;/code&gt;, the LHS is not an application; in &lt;code&gt;&quot;wrong2&quot;&lt;/code&gt;, the LHS has a pattern variable in the head. In &lt;code&gt;&quot;wrong3&quot;&lt;/code&gt;, the LHS consists of a &lt;em&gt;constructor&lt;/em&gt;, rather than a &lt;em&gt;variable&lt;/em&gt;, applied to an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cba9c2c873dc3a1842eba8795586b3cad1e7927" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;('[] :: [Maybe a])&lt;/code&gt;, the kind variable &lt;code&gt;a&lt;/code&gt; is implicitly bound by the kind signature of the LHS type pattern &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd722d9619f7131d53a6e0696cd49a366c57cba6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;...rhs...&lt;/code&gt; there is, in effect a local instance for &lt;code&gt;Eq (f a)&lt;/code&gt; for any &lt;code&gt;a&lt;/code&gt;. But at a call site for &lt;code&gt;f&lt;/code&gt; the compiler itself produces evidence to pass to &lt;code&gt;f&lt;/code&gt;. For example, if we called &lt;code&gt;f Nothing&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;Maybe&lt;/code&gt; and the compiler must prove (at the call site) that &lt;code&gt;forall a. Eq a =&amp;gt; Eq (Maybe a)&lt;/code&gt; holds. It can do this easily, by appealing to the existing instance declaration for &lt;code&gt;Eq (Maybe a)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a829120c1a8cf6dc40005b5743e07320e4e76d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948361792703e617253f8a40efc29e2464a33346" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt;, the parameter &lt;code&gt;p&lt;/code&gt; is used for the first time, whereas &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; simply wraps an application of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a4440f56e4e4c2cfc9de276b7ac8c2dd211dcc7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845d36fb6d42c5c12db137868f32d7eab65dd2b2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d9284ef85a16cb7684b74958aee144b991c17a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e7141714d539cd7c869ec1a2a44cb47eefb8e1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8baeebee8820ef8d8750b87cc615ff6f0298f331" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d196e0b1f2acfe7fd37b1d4013ccf57a2a366c38" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b499ce2ba87784f2de26193d6919b4f01a32b507" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d657fa5f332487c2a8bc2384b505cdd8da898c0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="267623324428073bc541eebd4aad8f68ba67c469" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef1f15923838f9b858d723d5c8a4bfd38ff8b06" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5468a181d7acdf72891e57c5df9af13b9a16ef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaCons n f s&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the constructor's name, &lt;code&gt;f&lt;/code&gt; is its fixity, and &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the constructor contains record selectors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdcb03ae6fc4038ed5d8f740a99f5a3faec1e49a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaData n m p nt&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the datatype's name, &lt;code&gt;m&lt;/code&gt; is the module in which the datatype is defined, &lt;code&gt;p&lt;/code&gt; is the package in which the datatype is defined, and &lt;code&gt;nt&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the datatype is a &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83eee84186dc4d831c882f80bd99d4e5968d965" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaSel mn su ss ds&lt;/code&gt;, if the field uses record syntax, then &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the record name. Otherwise, &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;su&lt;/code&gt; and &lt;code&gt;ss&lt;/code&gt; are the field's unpackedness and strictness annotations, and &lt;code&gt;ds&lt;/code&gt; is the strictness that GHC infers for the field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34a93041bfae2648000d66b86976acbec2d0642" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced4e254bc1eb559ceb481fab3bee8103d304a01" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87dae09b658c1498dee148900bef2b9dd60aee21" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe62b913f985335a3ba832edccdcf6977c0bf16" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc75f8d8c4b35c1f3e3a3913bb479147b81cb55" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monad&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6899c2e8dfb1d03397333b9eb9a07339697044" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monoid&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39ca16be80f52a77708c1a747b96b2360e52634" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; is not quantified by the outermost &lt;code&gt;forall&lt;/code&gt;, so it is not in scope over the bodies of the functions. Neither is &lt;code&gt;b&lt;/code&gt; in scope over the body of &lt;code&gt;f3&lt;/code&gt;, as the &lt;code&gt;forall&lt;/code&gt; is tucked underneath the &lt;code&gt;Foo&lt;/code&gt; type synonym.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77988f2a2ed6a0e43f6b8c5f856f98a253efb90" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s definition, we&amp;rsquo;ll instantiate to &lt;code&gt;(C alpha)&lt;/code&gt; and try to deduce &lt;code&gt;(C alpha)&lt;/code&gt; from &lt;code&gt;(C a)&lt;/code&gt;, and fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc4c70c143662f5383482b6d67de0f92f7a365d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;kindOf&lt;/code&gt;, the &lt;code&gt;k&lt;/code&gt; variable is used both in a kind position and a type position. Currently, &lt;code&gt;kindOf&lt;/code&gt; happens to be accepted as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b35e40411bc58348de1c2765fb1a4292327ba91" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;libraries/base/GHC/Base.hs&lt;/code&gt; look at the rules for &lt;code&gt;map&lt;/code&gt; to see how to write rules that will do fusion and yet give an efficient program even if fusion doesn&amp;rsquo;t happen. More rules in &lt;code&gt;GHC/List.hs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a114c54d904ac4a8b931a8b996071d7f5db6f6" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;batch mode&lt;/em&gt;, GHC will compile one or more source files given on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d94fdb74e22b1e4ed6c0f3d1765a358e401fba" translate="yes" xml:space="preserve">
          <source>In GHC 6.12.3 and earlier, the default was to process all RTS options. However, since RTS options can be used to write logging data to arbitrary files under the security context of the running program, there is a potential security problem. For this reason, GHC 7.0.1 and later default to &lt;code&gt;-rtsopts=some&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bf7ad7520a92b283b23d11132eda5dbd26c8a6" translate="yes" xml:space="preserve">
          <source>In GHC 8.4 and higher, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; has been corrected to lift a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance instead of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance. Consequently, this type is no longer useful. It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf62f569044864c4ed60a6a7bb15cef4826949f" translate="yes" xml:space="preserve">
          <source>In GHC the &lt;code&gt;Int&lt;/code&gt; type follows the size of an address on the host architecture; in other words it holds 32 bits on a 32-bit machine, and 64-bits on a 64-bit machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9843e6ca6c6b645c8f794b9b1a427c411f140a1a" translate="yes" xml:space="preserve">
          <source>In GHC version 6.12 building shared libraries is supported for Linux (on x86 and x86-64 architectures). GHC version 7.0 adds support on Windows (see &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Building and using Win32 DLLs&lt;/a&gt;), FreeBSD and OpenBSD (x86 and x86-64), Solaris (x86) and Mac OS X (x86 and PowerPC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1daba1b4560bdfc70e09fd592e0d65dc1e9c37b9" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;alloca&lt;/code&gt; is implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;, so allocation and deallocation are fast: much faster than C&amp;rsquo;s &lt;code&gt;malloc/free&lt;/code&gt;, but not quite as fast as stack allocation in C. Use &lt;code&gt;alloca&lt;/code&gt; whenever you can.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaea8bf5bbec3eca1845287a1a36bf3f40ff1211" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;mallocForeignPtr&lt;/code&gt; is also implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;. Although the memory is pointed to by a &lt;code&gt;ForeignPtr&lt;/code&gt;, there are no actual finalizers involved (unless you add one with &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;), and the deallocation is done using GC, so &lt;code&gt;mallocForeignPtr&lt;/code&gt; is normally very cheap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39daf99f45a84ba8de844fc76ad7b4153033baaa" translate="yes" xml:space="preserve">
          <source>In GHC, a fixity declaration may accompany a local binding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4c63d000de5dba60a416622dd3245150848f85" translate="yes" xml:space="preserve">
          <source>In GHC, the stdout handle is line-buffered by default. However, in GHCi we turn off the buffering on stdout, because this is normally what you want in an interpreter: output appears as it is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8852f0e928d58c915cd8b9e1a00743a1e68d9fa3" translate="yes" xml:space="preserve">
          <source>In GHC, this is 1 (a tab is just a character)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19c28d54f7c0de858c1b5974a88ffcb3bf56049" translate="yes" xml:space="preserve">
          <source>In GHC, threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; are lightweight threads, and are managed entirely by the GHC runtime. Typically Haskell threads are an order of magnitude or two more efficient (in terms of both time and space) than operating system threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1805c71d435523bc362fb0a41eec670b0de8eef4" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, certain kinds of expressions can be used without parentheses as an argument to an operator, but not as an argument to a function. They include &lt;code&gt;do&lt;/code&gt;, lambda, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, and &lt;code&gt;let&lt;/code&gt; expressions. Some GHC extensions also define language constructs of this type: &lt;code&gt;mdo&lt;/code&gt; (&lt;a href=&quot;#recursive-do-notation&quot;&gt;The recursive do-notation&lt;/a&gt;), &lt;code&gt;\case&lt;/code&gt; (&lt;a href=&quot;#lambda-case&quot;&gt;Lambda-case&lt;/a&gt;), and &lt;code&gt;proc&lt;/code&gt; (&lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958b65070f6cab89550e593513742b0ca3a25efb" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, this is an opaque type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141c5fc516d90c0307fae2cd69b966988b2f5738" translate="yes" xml:space="preserve">
          <source>In Haskell 98 mode and by default (but not in Haskell 2010 mode), GHC is a little less strict about the layout rule when used in &lt;code&gt;do&lt;/code&gt; expressions. Specifically, the restriction that &amp;ldquo;a nested context must be indented further to the right than the enclosing context&amp;rdquo; is relaxed to allow the nested context to be at the same level as the enclosing context, if the enclosing context is a &lt;code&gt;do&lt;/code&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599e88170bd7d883f77ba5d44a7ddebdba1a790b" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the context of a class declaration (which introduces superclasses) must be simple; that is, each predicate must consist of a class applied to type variables. The extension &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) lifts this restriction, so that the only restriction on the context in a class declaration is that the class hierarchy must be acyclic. So these class declarations are OK:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c8da415db612e5f1ea4bd84f8b71735ea83ad2" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the head of an instance declaration must be of the form &lt;code&gt;C (T a1 ... an)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is the class, &lt;code&gt;T&lt;/code&gt; is a data type constructor, and the &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables. In the case of multi-parameter type classes, this rule applies to each parameter of the instance head (Arguably it should be okay if just one has this form and the others are type variables, but that&amp;rsquo;s the rules at the moment).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4ec2e25de3b576b30de329ce5f6bd4501065f2" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the class constraints in the context of the instance declaration must be of the form &lt;code&gt;C a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable that occurs in the head.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc46eaaf6d9e1c84e4c85176656529491f0cd53f" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the inferred kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt;
Type&lt;/code&gt;. But this is overly specific, because another suitable Haskell 98 kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt;, where the kind assigned to &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Indeed, without kind signatures (&lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;), it is necessary to use a dummy constructor to get a Haskell compiler to infer the second kind. With kind polymorphism (&lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;), GHC infers the kind &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt;
Type&lt;/code&gt; for &lt;code&gt;App&lt;/code&gt;, which is its most general kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac9bc239948204f2a8d4ed156b20d8d29b1b9f6" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the only derivable classes are &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;. &lt;a href=&quot;#deriving-extra&quot;&gt;Various language extensions&lt;/a&gt; extend this list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2150415688076448290962ad6fd2b0c86ad5929a" translate="yes" xml:space="preserve">
          <source>In Haskell 98, we can define a parsing monad by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c90bfb63f72d089b5eed20faef5057d4b7a83ec" translate="yes" xml:space="preserve">
          <source>In Haskell, a &lt;code&gt;let&lt;/code&gt; expression is followed by &lt;code&gt;in&lt;/code&gt;. However, in GHCi, since the expression can also be interpreted in the &lt;code&gt;IO&lt;/code&gt; monad, a &lt;code&gt;let&lt;/code&gt; binding with no accompanying &lt;code&gt;in&lt;/code&gt; statement can be signalled by an empty line, as in the above example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9068501a015364519d15db889c0608523757cd88" translate="yes" xml:space="preserve">
          <source>In Haskell, a newline is always represented by the character &lt;code&gt;'\n'&lt;/code&gt;. However, in files and external character streams, a newline may be represented by another character sequence, such as &lt;code&gt;'\r\n'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7c74c15737415db5c329d8398aaad16be0f6da" translate="yes" xml:space="preserve">
          <source>In Haskell, a programmer-written type signature is implicitly quantified over its free type variables (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt; of the Haskell Report). Lexically scoped type variables affect this implicit quantification rules as follows: any type variable that is in scope is &lt;em&gt;not&lt;/em&gt; universally quantified. For example, if type variable &lt;code&gt;a&lt;/code&gt; is in scope, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a045d12bdfe38097b59295fbb7e2d5b85ec1646" translate="yes" xml:space="preserve">
          <source>In Haskell, floating-point operations have pure types, and the evaluation order is unspecified. So strictly speaking, since the &lt;code&gt;fenv.h&lt;/code&gt; functions let you change the results of, or observe the effects of floating point operations, use of &lt;code&gt;fenv.h&lt;/code&gt; renders the behaviour of floating-point operations anywhere in the program undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8a1e12648617b7ab29a94bd933ecabcb8fcfe6" translate="yes" xml:space="preserve">
          <source>In Haskell, you can&amp;rsquo;t write a type signature in an instance declaration, but it is sometimes convenient to do so, and the language extension &lt;a href=&quot;#extension-InstanceSigs&quot;&gt;&lt;code&gt;InstanceSigs&lt;/code&gt;&lt;/a&gt; allows you to do so. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8427a76c9ee7a864a646e420064761a09284fce9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;closed type family&lt;/em&gt; all equations are ordered and in one place. Equations are also checked pair-wise but this time an equation has to be paired with all the preceeding equations. Of course a single-equation closed type family is trivially injective (unless (1), (2) or (3) above holds).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450e95ea754d91229aeb1e695390ebec4e7895e5" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;source&lt;/em&gt; program this would declare TA to have no constructors (a GHC extension: see &lt;a href=&quot;glasgow_exts#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), but in an hi-boot file it means &amp;ldquo;I don&amp;rsquo;t know or care what the constructors are&amp;rdquo;. This is the most common form of data type declaration, because it&amp;rsquo;s easy to get right. You &lt;em&gt;can&lt;/em&gt; also write out the constructors but, if you do so, you must write it out precisely as in its real definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d45f71dec31ef9b1d51fa3c3cf25f39fcadcc0" translate="yes" xml:space="preserve">
          <source>In a GADT-style data type declaration there is no obvious way to specify that a data constructor should be infix, which makes a difference if you derive &lt;code&gt;Show&lt;/code&gt; for the type. (Data constructors declared infix are displayed infix by the derived &lt;code&gt;show&lt;/code&gt;.) So GHC implements the following design: a data constructor declared in a GADT-style data type declaration is displayed infix by &lt;code&gt;Show&lt;/code&gt; iff (a) it is an operator symbol, (b) it has two arguments, (c) it has a programmer-supplied fixity declaration. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a23e9f4a3adccc2a7677063668d39db095dd14" translate="yes" xml:space="preserve">
          <source>In a class declaration, all of the class type variables must be reachable (in the sense mentioned in &lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) from the free variables of each method type. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6ea776cade0a00536fe0dd1e2c07174843e962" translate="yes" xml:space="preserve">
          <source>In a concurrent program, &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; operations may appear out-of-order to another thread, depending on the memory model of the underlying processor architecture. For example, on x86, loads can move ahead of stores, so in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8414a11b42213e9da0ee87ae53530ee3ce8a4f45" translate="yes" xml:space="preserve">
          <source>In a few cases, even equality constraints cannot be deferred. Specifically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f8a7d6c3b7eb5e07bab83a298a4d4322657fec" translate="yes" xml:space="preserve">
          <source>In a form that checks the invariant lazily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e001e5b19bb7f459d52b88fa8993534911ab892" translate="yes" xml:space="preserve">
          <source>In a future release of GHC, both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;kindOf&lt;/code&gt; will be rejected per the &amp;ldquo;forall-or-nothing&amp;rdquo; rule. This warning, being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, allows to detect this before the actual breaking change takes place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a786f90842cfbc1183ff12a32670a5ffa98f0bc7" translate="yes" xml:space="preserve">
          <source>In a multithreaded program, the current working directory is a global state shared among all threads of the process. Therefore, when performing filesystem operations from multiple threads, it is highly recommended to use absolute rather than relative paths (see: &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61315f4b8bb71a0b1c939d36bc50aba8647c5d4e" translate="yes" xml:space="preserve">
          <source>In a pattern context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9010ad7519addcc90a448173aedba3758c2fa46a" translate="yes" xml:space="preserve">
          <source>In a pattern context with field puns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71bde6dc1de743e6a58a0db5f14b26f355407ecb" translate="yes" xml:space="preserve">
          <source>In a pattern context with record syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c8cccfc50e043aecf8ac5ce9ee8531c541f745" translate="yes" xml:space="preserve">
          <source>In a pattern type signature (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6844f7a79c5dfe3ec9aa5a919c116ac89f9053b7" translate="yes" xml:space="preserve">
          <source>In a record update</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8401c566cf94c06de714273e8a2c803bf6fdb3" translate="yes" xml:space="preserve">
          <source>In a record update such as &lt;code&gt;e { x = 1 }&lt;/code&gt;, if there are multiple &lt;code&gt;x&lt;/code&gt; fields in scope, then the type of the context must fix which record datatype is intended, or a type annotation must be supplied. Consider the following definitions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd9f17a624418d16516d174a2fcb42b7bab910d" translate="yes" xml:space="preserve">
          <source>In a similar way, the earlier definition of &lt;code&gt;g&lt;/code&gt; will now be flagged as a type error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce7f512726e8d285ac156a0f35f6359e45bcb80" translate="yes" xml:space="preserve">
          <source>In a single pattern, variables bound by patterns to the left of a view pattern expression are in scope. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b6b61563103c5b7dfd5b620fb5437b770cc196" translate="yes" xml:space="preserve">
          <source>In a standalone GHC program, only the main thread is required to terminate in order for the process to terminate. Thus all other forked threads will simply terminate at the same time as the main thread (the terminology for this kind of behaviour is &quot;daemonic threads&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa908ae420e77e1f4bb85ee334ad239c1ccb262" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4597cb1599aee82731cada610232980bbc2d3431" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;#{stuff}&lt;/code&gt; is equivalent to &lt;code&gt;#stuff&lt;/code&gt; except that it&amp;rsquo;s self-delimited and thus needs not to be placed at the end of line or in some brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb314fe5b2039048608ae504bca0f576e50cf0b7" translate="yes" xml:space="preserve">
          <source>In addition to Core plugins, GHC has experimental support for typechecker plugins, which allow the behaviour of the constraint solver to be modified. For example, they make it possible to interface the compiler to an SMT solver, in order to support a richer theory of type-level arithmetic expressions than the theory built into GHC (see &lt;a href=&quot;glasgow_exts#typelit-tyfuns&quot;&gt;Computing With Type-Level Naturals&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4828c748a125eae444ad80c1e864e71abc3d059" translate="yes" xml:space="preserve">
          <source>In addition to being equivalent in the structural sense, the two also have &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instances that behave the same. This type will be marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are advised to use the variant from &lt;a href=&quot;data-semigroup&quot;&gt;Data.Semigroup&lt;/a&gt; and wrap it in &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8311e5504e292a63b6e04f775b8d4c2184db072" translate="yes" xml:space="preserve">
          <source>In addition to core and type checker plugins, you can install plugins that can access different representations of the source code. The main purpose of these plugins is to make it easier to implement development tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babc3f5d8badd87263ede33fef263b59d78b2950" translate="yes" xml:space="preserve">
          <source>In addition to creating a DLL, the &lt;code&gt;-shared&lt;/code&gt; option also creates an import library. The import library name is derived from the name of the DLL, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249a7c61164a88062524e2aa24c887b8f5661159" translate="yes" xml:space="preserve">
          <source>In addition to exceptions thrown by &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, exceptions may be thrown by pure code (imprecise exceptions) or by external events (asynchronous exceptions), but may only be caught in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. For more details, see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee7bbb76ed60016773cd70eeacaa30823fc8982" translate="yes" xml:space="preserve">
          <source>In addition to profiling the time and allocation behaviour of your program, you can also generate a graph of its memory usage over time. This is useful for detecting the causes of space leaks, when your program holds on to more memory at run-time that it needs to. Space leaks lead to slower execution due to heavy garbage collector activity, and may even cause the program to run out of memory altogether.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5fe76494632cc57e366196cfdfa66ddce021ab" translate="yes" xml:space="preserve">
          <source>In addition to the data that has just been written into your buffer by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action, it gives you a pre-existing chunk of data as a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It also gives you the following &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. It is safe to run this following action using a buffer with as much free space as was left by the previous run action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a3d1c2998b358fa67a87a4eae02294a3a1f06e" translate="yes" xml:space="preserve">
          <source>In addition to the usual DIEs specified by the DWARF specification, GHC produces a variety of others using the vendor-extensibility regions of the tag and attribute space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367b4aa700725245db9b4214f26896949ea4e52a" translate="yes" xml:space="preserve">
          <source>In addition you can use the &lt;a href=&quot;#rts-flag--P&quot;&gt;&lt;code&gt;-P&lt;/code&gt;&lt;/a&gt; RTS option to get the following additional information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a0aaebb5d7ddb8779614a440c8d24ce42c1bca" translate="yes" xml:space="preserve">
          <source>In addition, in &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; mode, &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; will throw a &lt;code&gt;UserInterrupt&lt;/code&gt; exception if the process terminated with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt;. Typically you will not want to catch this exception, but let it propagate, giving a normal orderly shutdown. One detail to be aware of is that the &lt;code&gt;UserInterrupt&lt;/code&gt; exception is thrown &lt;em&gt;synchronously&lt;/em&gt; in the thread that calls &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;, whereas normally &lt;code&gt;SIGINT&lt;/code&gt; causes the exception to be thrown &lt;em&gt;asynchronously&lt;/em&gt; to the main thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90bb874cbfbf13e44d04cff0d054e6082425071b" translate="yes" xml:space="preserve">
          <source>In addition, the datatype that is meant may be given as a type signature on the argument to the selector:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4126bb6eb85667a0ba0f06971d33a3e7b8c05e03" translate="yes" xml:space="preserve">
          <source>In addition, the profile can be restricted to heap data which satisfies certain criteria - for example, you might want to display a profile by type but only for data produced by a certain module, or a profile by retainer for a certain type of data. Restrictions are specified as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e228e4f1543c3dc7a9d1ed29f66747995deb83" translate="yes" xml:space="preserve">
          <source>In addition, there are some fields with special syntax (e.g. package names, version, dependencies).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e619bf7b233d387015ddc79828be55161d099a" translate="yes" xml:space="preserve">
          <source>In addition, with &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt; you can prefix the name of a data constructor in an import or export list with the keyword &lt;code&gt;pattern&lt;/code&gt;, to allow the import or export of a data constructor without its parent type constructor (see &lt;a href=&quot;#patsyn-impexp&quot;&gt;Import and export of pattern synonyms&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3132ea808ceba667f793dbacd623742dade438fc" translate="yes" xml:space="preserve">
          <source>In all cases (apart from arrow notation), the static semantics should be that of the desugared form, even if that is a little unexpected. For example, the static semantics of the literal &lt;code&gt;368&lt;/code&gt; is exactly that of &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt;; it&amp;rsquo;s fine for &lt;code&gt;fromInteger&lt;/code&gt; to have any of the types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f38c78f8727c5dd6daeb670eabd5e48e13730ce" translate="yes" xml:space="preserve">
          <source>In all other contexts, type wildcards are disallowed, and a named wildcard is treated as an ordinary type variable. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57867e96afea7ee28118e42687442828dc1fec7" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;instance&lt;/code&gt; declaration for the class, if no explicit &lt;code&gt;type instance&lt;/code&gt; declaration is given for the associated type, the default declaration is used instead, just as with default class methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a6cf8b0ee18b4eb7df425b8e1b8603664a8706" translate="yes" xml:space="preserve">
          <source>In an import or export list, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55a4f9d1aac9b09d0ad21c5b54130b49a8ea4a4" translate="yes" xml:space="preserve">
          <source>In base we can't use wordToNatural# as built-in rules transform some of them into Natural literals. Use this function instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734a9d6aacdebfcf8e099a4ac67e6c63811f6437" translate="yes" xml:space="preserve">
          <source>In batch compilation mode, the name of the object file can also be overridden using the &lt;a href=&quot;#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-o ⟨file⟩&lt;/code&gt;&lt;/a&gt; option, and the name of the interface file can be specified directly using the &lt;a href=&quot;#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-ohi ⟨file⟩&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dabb8697131df61b0e2fe80e2efe74db486060e0" translate="yes" xml:space="preserve">
          <source>In binary format to a file for later analysis by a variety of tools. One such tool is &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;, which interprets the event log to produce a visual parallel execution profile of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03034364819bbabad90c6e7c5e8b8d93809898f3" translate="yes" xml:space="preserve">
          <source>In binary format to customized event log writer. This enables live analysis of the events while the program is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31be45f64d4525c6c8cb6e9758d8d1527903b2fe" translate="yes" xml:space="preserve">
          <source>In binding positions, we have similar parsing rules. Consider the following example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed50f5a5fcb2b11667475d2e83b41c38eee4ebd" translate="yes" xml:space="preserve">
          <source>In both cases &lt;code&gt;e&lt;/code&gt; is evaluated before starting to evaluate &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bacc600884c7ef880d3490fde1eab0149e179ff1" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; are available both throughout the &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;rec&lt;/code&gt; block, and in the statements that follow it. The difference is that &lt;code&gt;let&lt;/code&gt; is non-monadic, while &lt;code&gt;rec&lt;/code&gt; is monadic. (In Haskell &lt;code&gt;let&lt;/code&gt; is really &lt;code&gt;letrec&lt;/code&gt;, of course.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be81ef5fcc497dfbbeafbf556c2438a6c9895ee9" translate="yes" xml:space="preserve">
          <source>In case you try to derive some class on a newtype, and &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is also on, &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; takes precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51760f56c296114327d0a572e7ed7fabe636444" translate="yes" xml:space="preserve">
          <source>In cases where several instances of &lt;code&gt;needle&lt;/code&gt; overlap, only the first one will be replaced:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9ef87c7934b0a5953335739ae5904bf71e50d1" translate="yes" xml:space="preserve">
          <source>In concert with &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;, GHC supports higher-rank kinds. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0160dd1b8a2fb226728d5dc6a312d10bda3db9e4" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20440f6fb3e228846c05d91a5f12ecb0390cdea" translate="yes" xml:space="preserve">
          <source>In contrast, there is no reliable way to do this for &lt;code&gt;g&lt;/code&gt;; we will not know whether &lt;code&gt;Eq a&lt;/code&gt; or &lt;code&gt;Eq b&lt;/code&gt; will be listed first in the constraint in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3824b67115f2edecbe27bdcb0540496f21f8bbe" translate="yes" xml:space="preserve">
          <source>In dumps, suppress everything (except for uniques) that is suppressible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827cb020739fbf9c40831c2ab9e7d2857ae60ae1" translate="yes" xml:space="preserve">
          <source>In each case the appropriate class must be in scope before it can be mentioned in the &lt;code&gt;deriving&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2baf294e27435a713527ed1fabd3f79a5937ec" translate="yes" xml:space="preserve">
          <source>In earlier versions of GHC, it was possible to omit the &lt;code&gt;forall&lt;/code&gt; in the type of the constructor if there was an explicit context. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa31c0c659980e252d481c558bed906f0492165" translate="yes" xml:space="preserve">
          <source>In either case, C is the only authority on package trust. It is up to the client to decide which &lt;a href=&quot;#safe-package-trust&quot;&gt;packages they trust&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e577bd1cf962e0880951f56bb28b5bcc144b9dbd" translate="yes" xml:space="preserve">
          <source>In error messages, expressions are printed to a certain &amp;ldquo;depth&amp;rdquo;, with subexpressions beyond the depth replaced by ellipses. This flag sets the depth. Its default value is 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3785b1fb09bd9bd3050ae561da76ff7c2ea38ed" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;Issue #5252&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbd3972ad6aafb5b6e87ed35007593f460b926a" translate="yes" xml:space="preserve">
          <source>In fact, GHC enters make mode automatically if there are any Haskell source files on the command line and no other mode is specified, so in this case we could just type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ccc14a1c3446055aa550c00e0053392d4a3107" translate="yes" xml:space="preserve">
          <source>In fact, GHCi provides a way to run a command when a breakpoint is hit, so we can make it automatically do &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c63df3de91a091a7b7f15134cec823a993cb116" translate="yes" xml:space="preserve">
          <source>In function &lt;code&gt;showHelp&lt;/code&gt; GHC sees no overlapping instances, and so uses the &lt;code&gt;MyShow [a]&lt;/code&gt; instance without complaint. In the call to &lt;code&gt;myshow&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;, GHC resolves the &lt;code&gt;MyShow [T]&lt;/code&gt; constraint using the overlapping instance declaration in module &lt;code&gt;Main&lt;/code&gt;. As a result, the program prints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec6fbf6ec53f51208aead68b9f4175c5c65a628" translate="yes" xml:space="preserve">
          <source>In general a lazy pattern binding &lt;code&gt;p = e&lt;/code&gt; is a no-op if &lt;code&gt;p&lt;/code&gt; does not bind any variables. The motivation for allowing lone wild-card patterns is they are not very different from &lt;code&gt;_v = rhs3&lt;/code&gt;, which elicits no warning; and they can be useful to add a type constraint, e.g. &lt;code&gt;_ = x::Int&lt;/code&gt;. A banged pattern (see &lt;a href=&quot;glasgow_exts#bang-patterns&quot;&gt;Bang patterns and Strict Haskell&lt;/a&gt;) is &lt;em&gt;not&lt;/em&gt; a no-op, because it forces evaluation, and is useful as an alternative to &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f41108f0c2bbe0749431bd7963794d7183a3a6" translate="yes" xml:space="preserve">
          <source>In general terms, a weak pointer is a reference to an object that is not followed by the garbage collector - that is, the existence of a weak pointer to an object has no effect on the lifetime of that object. A weak pointer can be de-referenced to find out whether the object it refers to is still alive or not, and if so to return the object itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481359b39a7a3a188516a1c2c13bacad1c4ff5db" translate="yes" xml:space="preserve">
          <source>In general there are three kinds of pattern synonyms. Unidirectional, bidirectional and explicitly bidirectional. The examples given so far are examples of bidirectional pattern synonyms. A bidirectional synonym behaves the same as an ordinary data constructor. We can use it in a pattern context to deconstruct values and in an expression context to construct values. For example, we can construct the value &lt;code&gt;intEndo&lt;/code&gt; using the pattern synonyms &lt;code&gt;Arrow&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; as defined previously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b27522334b948b2f46f2564190ed9a7b062b44c" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;ghc -M Foo&lt;/code&gt; does the following. For each module &lt;code&gt;M&lt;/code&gt; in the set &lt;code&gt;Foo&lt;/code&gt; plus all its imports (transitively), it adds to the Makefile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7c6f26fd4493c528d23d0ae55697bac0eab934" translate="yes" xml:space="preserve">
          <source>In general, GHC only inlines the function if there is some reason (no matter how slight) to suppose that it is useful to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a1f55e5825a2ce9deec4865aae9e5195367f7d" translate="yes" xml:space="preserve">
          <source>In general, GHC will only instantiate a polymorphic function at a monomorphic type (one with no foralls). For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="225fcb89e38b97f2054653e3553fa5805a7ccac0" translate="yes" xml:space="preserve">
          <source>In general, after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, an automatic import is added to the scope for the most recently loaded &amp;ldquo;target&amp;rdquo; module, in a &lt;code&gt;*&lt;/code&gt;-form if possible. For example, if you say &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; and &lt;code&gt;bar.hs&lt;/code&gt; contains module &lt;code&gt;Bar&lt;/code&gt;, then the scope will be set to &lt;code&gt;*Bar&lt;/code&gt; if &lt;code&gt;Bar&lt;/code&gt; is interpreted, or if &lt;code&gt;Bar&lt;/code&gt; is compiled it will be set to &lt;code&gt;Prelude Bar&lt;/code&gt; (GHCi automatically adds &lt;code&gt;Prelude&lt;/code&gt; if it isn&amp;rsquo;t present and there aren&amp;rsquo;t any &lt;code&gt;*&lt;/code&gt;-form modules). These automatically-added imports can be seen with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31992d81c36250762b8a1fe8122ed580d721498" translate="yes" xml:space="preserve">
          <source>In general, as discussed in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance resolution&lt;/a&gt;, &lt;em&gt;GHC requires that it be unambiguous which instance declaration should be used to resolve a type-class constraint&lt;/em&gt;. GHC also provides a way to loosen the instance resolution, by allowing more than one instance to match, &lt;em&gt;provided there is a most specific one&lt;/em&gt;. Moreover, it can be loosened further, by allowing more than one instance to match irrespective of whether there is a most specific one. This section gives the details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24a52ff5732e7457a6c0f10b8d48e80b50c3fe8" translate="yes" xml:space="preserve">
          <source>In general, if GHC sees an expression within Oxford brackets (e.g., &lt;code&gt;[|
foo bar |]&lt;/code&gt;, then GHC looks up each name within the brackets. If a name is global (e.g., suppose &lt;code&gt;foo&lt;/code&gt; comes from an import or a top-level declaration), then the fully qualified name is used directly in the quotation. If the name is local (e.g., suppose &lt;code&gt;bar&lt;/code&gt; is bound locally in the function definition &lt;code&gt;mkFoo bar = [| foo bar |]&lt;/code&gt;), then GHC uses &lt;code&gt;lift&lt;/code&gt; on it (so GHC pretends &lt;code&gt;[| foo bar |]&lt;/code&gt; actually contains &lt;code&gt;[|
foo $(lift bar) |]&lt;/code&gt;). Local names, which are not in scope at splice locations, are actually evaluated when the quotation is processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64b81fdef25b826556b46bc221a058713ff56df" translate="yes" xml:space="preserve">
          <source>In general, it is not recommended to use finalizers on separate objects with ordering constraints between them. To express the ordering robustly requires explicit synchronisation using &lt;code&gt;MVar&lt;/code&gt;s between the finalizers, but even then the runtime sometimes runs multiple finalizers sequentially in a single thread (for performance reasons), so synchronisation between finalizers could result in artificial deadlock. Another alternative is to use explicit reference counting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a479e2f380ec3084c0c0b21decb15ffdb8b192d" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;pluginRecompile&lt;/code&gt; field has the following type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f3128b6b16c5e45ef1a5d99515ed3873e858da" translate="yes" xml:space="preserve">
          <source>In general, the rule for when a &lt;code&gt;do&lt;/code&gt; statement incurs a &lt;code&gt;Monad&lt;/code&gt; constraint is as follows. If the do-expression has the following form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16433cfc779e293649e5b61b5f49a9b6e34ab87f" translate="yes" xml:space="preserve">
          <source>In general, these options act on a &lt;code&gt;.tix&lt;/code&gt; file after an instrumented binary has generated it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16864de7adb994a5d73b4457714719a11060892c" translate="yes" xml:space="preserve">
          <source>In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL&amp;lsquo;96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of &amp;ldquo;some help&amp;rdquo; but the rule is this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2024a464eb534dfbe74fefedd702f7a3e2250030" translate="yes" xml:space="preserve">
          <source>In general, you can only pattern-match on an existentially-quantified constructor in a &lt;code&gt;case&lt;/code&gt; expression or in the patterns of a function definition. The reason for this restriction is really an implementation one. Type-checking binding groups is already a nightmare without existentials complicating the picture. Also an existential pattern binding at the top level of a module doesn&amp;rsquo;t make sense, because it&amp;rsquo;s not clear how to prevent the existentially-quantified type &amp;ldquo;escaping&amp;rdquo;. So for now, there&amp;rsquo;s a simple-to-state restriction. We&amp;rsquo;ll see how annoying it is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c6d67c9ce44b8e6eac2d0b4075c81dabba5106" translate="yes" xml:space="preserve">
          <source>In high-performance Haskell code (e.g. numeric code) eliminating thunks from an inner loop can be a huge win. GHC supports three extensions to allow the programmer to specify use of strict (call-by-value) evaluation rather than lazy (call-by-need) evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3bb19915354a80256cd126fd6a60161eb482c2d" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC does not accept datatype contexts, as it has been decided to remove them from the next version of the language standard. This behaviour can be controlled with the &lt;code&gt;DatatypeContexts&lt;/code&gt; extension. See &lt;a href=&quot;glasgow_exts#datatype-contexts&quot;&gt;Data type contexts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275629b87d7294aa0eaa9588d8a9a706ba895f13" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC makes some programs slightly more defined than they should be. For example, consider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94f4b216d151b4a30a7c1bd717bfe451b1cb48d" translate="yes" xml:space="preserve">
          <source>In keeping with the way that class methods list their class variables first, associated types also list class variables before others. This means that the inferred variables from the class come before the specified variables from the class, which come before other implicitly bound variables. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1a88fdd917297213df61b4944e92d2f20600ce" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;control-monad#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e41b1490a2b7bfe151acff33ef58b56ab399e1" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;ghc-base#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2d8e96b23e6bc78c49594a14c36c62bbb7071e" translate="yes" xml:space="preserve">
          <source>In more complicated examples, you may wish to define a whole hierarchy of exceptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4936db3ddc3e67725b71767b1d5c5e41743bb8" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3027d30c8f8fb2c3a4b6e7dd0e32412aa9179811" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b1ffe4dff1aba8ccdccdaa16d342830f1d4227" translate="yes" xml:space="preserve">
          <source>In most cases, you must supply an explicit context (in the example the context is &lt;code&gt;(Eq a)&lt;/code&gt;), exactly as you would in an ordinary instance declaration. (In contrast, in a &lt;code&gt;deriving&lt;/code&gt; clause attached to a data type declaration, the context is inferred.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e317a4f2744059301e6b1045661a71d5655709" translate="yes" xml:space="preserve">
          <source>In most scenarios, every &lt;code&gt;deriving&lt;/code&gt; statement generates a typeclass instance in an unambiguous fashion. There is a corner case, however, where simultaneously enabling both the &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extensions can make deriving become ambiguous. Consider the following example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b692dc9121229cacd00afc8cf58d7662492e8b8" translate="yes" xml:space="preserve">
          <source>In mutually recursive bindings, such as &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, or the top level, view patterns in one declaration may not mention variables bound by other declarations. That is, each declaration must be self-contained. For example, the following program is not allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becdc0c8077f7104b4c28a91add0067b223f02f7" translate="yes" xml:space="preserve">
          <source>In order to allow full flexibility in how kinds are used, it is necessary to use the kind system to differentiate between boxed, lifted types (normal, everyday types like &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;[Bool]&lt;/code&gt;) and unboxed, primitive types (&lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;) like &lt;code&gt;Int#&lt;/code&gt;. We thus have so-called levity polymorphism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6cd748eca92cb9876cb47ec0d324628b6e60b35" translate="yes" xml:space="preserve">
          <source>In order to avoid conflicting with the built-in constraint solving, the following user-defined &lt;code&gt;HasField&lt;/code&gt; instances are prohibited (in addition to the usual rules, such as the prohibition on type families appearing in instance heads):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93af4d623943d3f8bd7b71270963bbcbfaf23873" translate="yes" xml:space="preserve">
          <source>In order to be able to do this, we need to know the actual definitions of these types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec123491a69a064a575a51206895c88f02274ac" translate="yes" xml:space="preserve">
          <source>In order to guarantee that type inference in the presence of type families decidable, we need to place a number of additional restrictions on the formation of type instance declarations (c.f., Definition 5 (Relaxed Conditions) of &amp;ldquo;&lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;Type Checking with Open Type Functions&lt;/a&gt;&amp;rdquo;). Instance declarations have the general form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5e110d7e22d8c1fbc33d3a5b3e328299c301bb" translate="yes" xml:space="preserve">
          <source>In order to make graphs more readable, &lt;code&gt;hp2ps&lt;/code&gt; sorts the shaded bands for each identifier. The default sort ordering is for the bands with the largest area to be stacked on top of the smaller ones. The &lt;code&gt;-d&lt;/code&gt; option causes rougher bands (those representing series of values with the largest standard deviations) to be stacked on top of smoother ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05de27ae60fa5ff58255cf77bb61e0034b072231" translate="yes" xml:space="preserve">
          <source>In order to make use of multiple CPUs, your program must be linked with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). Additionally, the following compiler options affect parallelism:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a539e64a6ae327e4d4847a3da0692c246af57900" translate="yes" xml:space="preserve">
          <source>In order to stop the value &lt;code&gt;it&lt;/code&gt; being bound on each command, the flag &lt;a href=&quot;#ghc-flag--fno-it&quot;&gt;&lt;code&gt;-fno-it&lt;/code&gt;&lt;/a&gt; can be set. The &lt;code&gt;it&lt;/code&gt; variable can be the source of space leaks due to how shadowed declarations are handled by GHCi (see &lt;a href=&quot;#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ff7b86e25253644ff1722e9fde733a07775459" translate="yes" xml:space="preserve">
          <source>In order to tell GHC the C type that a Haskell type corresponds to when it is used with the CAPI, a &lt;code&gt;CTYPE&lt;/code&gt; pragma can be used on the type definition. The header which defines the type can optionally also be specified. The syntax looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47421418538d24c7ed6361fd82a54bf7f6224d2c" translate="yes" xml:space="preserve">
          <source>In order to use the FFI in a multi-threaded setting, you must use the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3462ac0bc32460cb66fe5ad73156484f635fcbf" translate="yes" xml:space="preserve">
          <source>In order, &lt;code&gt;ghc&lt;/code&gt; will look for the package environment in the following locations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e148f1a9d40b361ea9368ff7b0c22490d6f5818" translate="yes" xml:space="preserve">
          <source>In ordinary Haskell, &lt;code&gt;f&lt;/code&gt; is lazy in its argument and hence in &lt;code&gt;x&lt;/code&gt;; and &lt;code&gt;g&lt;/code&gt; is strict in its argument and hence also strict in &lt;code&gt;x&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, both become strict because &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s argument gets an implicit bang.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e11a6dcf1454bf3942eab61b919beed891ed2da" translate="yes" xml:space="preserve">
          <source>In other ways, however, a standalone deriving obeys the same rules as ordinary deriving:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9811e2dd3d2cfe0a2fc61f31ef2b584425e79b" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;check b = unless b retry&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09118f7c3443c63e9289f6a2ade854e33281ae45" translate="yes" xml:space="preserve">
          <source>In our situation, module &lt;code&gt;TCB_Runner&lt;/code&gt; compiles fine without importing module &lt;code&gt;Dangerous&lt;/code&gt;. So when deciding which instance to use for the call to &lt;code&gt;op&lt;/code&gt;, if we determine the instance &lt;code&gt;TC [Int]&lt;/code&gt; from module Dangerous is the most specific, this is unsafe. This prevents code written by third-parties we don&amp;rsquo;t trust (which is compiled using &lt;code&gt;-XSafe&lt;/code&gt; in Safe Haskell) from changing the behaviour of our existing code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b674e690d27f945dd913940cb2232c8d90f70b" translate="yes" xml:space="preserve">
          <source>In parallel GC, the amount of balanced data copied by all threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61170ee3ee14c29ceaa4174895c06c76c4573d5" translate="yes" xml:space="preserve">
          <source>In parallel GC, the max amount of data copied by any one thread. Deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8ef4c6fe3834e5d04cec18ee87b3394e6f88d0" translate="yes" xml:space="preserve">
          <source>In particular GHC produces the following DWARF sections,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd52b4b1f1e992bf8f459eea8eeca8d965ef594" translate="yes" xml:space="preserve">
          <source>In particular Haskell shared libraries &lt;em&gt;must&lt;/em&gt; be made into packages. You cannot freely assign which modules go in which shared libraries. The Haskell shared libraries must match the package boundaries. The reason for this is that GHC handles references to symbols &lt;em&gt;within&lt;/em&gt; the same shared library (or main executable binary) differently from references to symbols &lt;em&gt;between&lt;/em&gt; different shared libraries. GHC needs to know for each imported module if that module lives locally in the same shared lib or in a separate shared lib. The way it does this is by using packages. When using &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, a module from a separate package is assumed to come from a separate shared lib, while modules from the same package (or the default &amp;ldquo;main&amp;rdquo; package) are assumed to be within the same shared lib (or main executable binary).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684eca7730ca7b2ff8a385904d2e0b0bdd7e41b3" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;inits _|_ = [] : _|_&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e1ce5ee87d506ce95263e7f934380331fec187" translate="yes" xml:space="preserve">
          <source>In particular, after inlining this will expose &lt;code&gt;f&lt;/code&gt; to the loop body directly, allowing heavy specialisation over the recursive cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b268bd7dbdcc411a15b5953757d10b21ca32c1a" translate="yes" xml:space="preserve">
          <source>In particular, constructors are &lt;em&gt;not&lt;/em&gt; retainers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="078a7a8154ddbe01c2111502e8ae65f0e2be01b1" translate="yes" xml:space="preserve">
          <source>In particular, if an instance declaration is in the same module as the definition of any type or class mentioned in the &lt;em&gt;head&lt;/em&gt; of the instance declaration (the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo;; see &lt;a href=&quot;glasgow_exts#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;), then GHC has to visit that interface file anyway. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3a1af7fc684a7365e0b7b609a3039be3699240" translate="yes" xml:space="preserve">
          <source>In particular, in &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations the constructor arguments may be polymorphic types of any rank; see examples in &lt;a href=&quot;#univ&quot;&gt;Examples&lt;/a&gt;. Note that the declared types are nevertheless always monomorphic. This is important because by default GHC will not instantiate type variables to a polymorphic type (&lt;a href=&quot;#impredicative-polymorphism&quot;&gt;Impredicative polymorphism&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e004af97f91f3b14786a737ee2ee1e783b46be" translate="yes" xml:space="preserve">
          <source>In particular, the &quot;bigger&quot; functions in this module (&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:swapMVar&quot;&gt;swapMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt;) are simply the composition of a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; followed by a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; with exception safety. These only have atomicity guarantees if all other threads perform a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; before a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as well; otherwise, they may block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d279defc6ca20240f2cd4bd6ca078465058a78" translate="yes" xml:space="preserve">
          <source>In particular, the functions in this module obey the following law:</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
