<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="de0fd695fef81a6e3c397b49019c4e2e00e1f0cc" translate="yes" xml:space="preserve">
          <source>Some GCC compilation options cause the compiler to generate code that does not conform to the platform&amp;rsquo;s default ABI. Other options cause different program behavior for implementation-defined features that are not covered by an ABI. These options are provided for consistency with other compilers that do not follow the platform&amp;rsquo;s default ABI or the usual behavior of implementation-defined features for the platform. Be very careful about using such options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0325ca2d082f6bb9f5d1e5e855cb8121b2560adb" translate="yes" xml:space="preserve">
          <source>Some ISO C testsuites report failure when the compiler does not produce an error message for a certain program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84f1bb1b30ec55b3fd5d6eb1c7f6faa03400485d" translate="yes" xml:space="preserve">
          <source>Some additional environment variables affect the behavior of the preprocessor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5045e735a2d8c7129e122a97ea30410aa9319aed" translate="yes" xml:space="preserve">
          <source>Some assemblers only support this flag when &lt;var&gt;n&lt;/var&gt; is a power of two; in that case, it is rounded up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ceba313d16765bb5b6ec17c1ebb8d3d9c14df42" translate="yes" xml:space="preserve">
          <source>Some attributes only make sense for C++ programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c2a3663ddcd2a93314c07f339088b18a9513ff" translate="yes" xml:space="preserve">
          <source>Some cases of unnamed fields in structures and unions are only accepted with this option. See &lt;a href=&quot;unnamed-fields#Unnamed-Fields&quot;&gt;Unnamed struct/union fields within structs/unions&lt;/a&gt;, for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15750fff39388c96e233f1fff7614239f8996f69" translate="yes" xml:space="preserve">
          <source>Some characters in ISO 10646 have distinct meanings but look identical in some fonts or display methodologies, especially once formatting has been applied. For instance &lt;code&gt;\u207F&lt;/code&gt;, &amp;ldquo;SUPERSCRIPT LATIN SMALL LETTER N&amp;rdquo;, displays just like a regular &lt;code&gt;n&lt;/code&gt; that has been placed in a superscript. ISO 10646 defines the &lt;em&gt;NFKC&lt;/em&gt; normalization scheme to convert all these into a standard form as well, and GCC warns if your code is not in NFKC if you use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06da659fa22deee4cc3d56729c6b4abce7edba00" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are documented in the corresponding document for the C language. See &lt;a href=&quot;c-implementation#C-Implementation&quot;&gt;C Implementation&lt;/a&gt;. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258878cc764e88fa980c6c9ddf4a6f80e9d5cd8f" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15506c8b8d5d6b275040aeee640a2a5a3f7d4d37" translate="yes" xml:space="preserve">
          <source>Some common examples of pure functions are &lt;code&gt;strlen&lt;/code&gt; or &lt;code&gt;memcmp&lt;/code&gt;. Interesting non-pure functions are functions with infinite loops or those depending on volatile memory or other system resource, that may change between consecutive calls (such as the standard C &lt;code&gt;feof&lt;/code&gt; function in a multithreading environment).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12ce1dfd34507685834493a64bea0bb0f207ab99" translate="yes" xml:space="preserve">
          <source>Some computer manufacturers have published Application Binary Interface standards which specify that plain bit-fields should be unsigned. It is a mistake, however, to say anything about this issue in an ABI. This is because the handling of plain bit-fields distinguishes two dialects of C. Both dialects are meaningful on every type of machine. Whether a particular object file was compiled using signed bit-fields or unsigned is of no concern to other object files, even if they access the same bit-fields in the same data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e1ac9ab0109c68aee90fe9c98e8024ac2ba20a" translate="yes" xml:space="preserve">
          <source>Some configurations of the compiler also support additional target-specific options, usually for compatibility with other compilers on the same platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc299e6d6d519531f7a42935a2ff0371856c97e" translate="yes" xml:space="preserve">
          <source>Some developers use Local Register Variables in an attempt to improve gcc&amp;rsquo;s allocation of registers, especially in large functions. In this case the register name is essentially a hint to the register allocator. While in some instances this can generate better code, improvements are subject to the whims of the allocator/optimizers. Since there are no guarantees that your improvements won&amp;rsquo;t be lost, this usage of Local Register Variables is discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd13c19c4da21f1c5afd2756424c80ed7c852869" translate="yes" xml:space="preserve">
          <source>Some devices support reading from flash memory by means of &lt;code&gt;LD*&lt;/code&gt; instructions. The flash memory is seen in the data address space at an offset of &lt;code&gt;__AVR_PM_BASE_ADDRESS__&lt;/code&gt;. If this macro is not defined, this feature is not available. If defined, the address space is linear and there is no need to put &lt;code&gt;.rodata&lt;/code&gt; into RAM. This is handled by the default linker description file, and is currently available for &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;avrxmega3&lt;/code&gt;. Even more convenient, there is no need to use address spaces like &lt;code&gt;__flash&lt;/code&gt; or features like attribute &lt;code&gt;progmem&lt;/code&gt; and &lt;code&gt;pgm_read_*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cca45385c65440f1fac5331dbdc800f8010a0a" translate="yes" xml:space="preserve">
          <source>Some features that are in ISO C99 but not C90 or C++ are also, as extensions, accepted by GCC in C90 mode and in C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768fab3712868916420b11c9d81a46a5d1e9bab0" translate="yes" xml:space="preserve">
          <source>Some file formats do not support arbitrary sections so the &lt;code&gt;section&lt;/code&gt; attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63737560dbee375bb4595f35dcce3b604d447957" translate="yes" xml:space="preserve">
          <source>Some function attributes take one or more arguments that refer to the function&amp;rsquo;s parameters by their positions within the function parameter list. Such attribute arguments are referred to as &lt;em&gt;positional arguments&lt;/em&gt;. Unless specified otherwise, positional arguments that specify properties of parameters with pointer types can also specify the same properties of the implicit C++ &lt;code&gt;this&lt;/code&gt; argument in non-static member functions, and of parameters of reference to a pointer type. For ordinary functions, position one refers to the first parameter on the list. In C++ non-static member functions, position one refers to the implicit &lt;code&gt;this&lt;/code&gt; pointer. The same restrictions and effects apply to function attributes used with ordinary functions or C++ member functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb33f99a987006c02f399310559443d2a427b3a7" translate="yes" xml:space="preserve">
          <source>Some lines of information at the start have &lt;var&gt;line_number&lt;/var&gt; of zero. These preamble lines are of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5021e481328ac057640ef2a536800d9166dbbe" translate="yes" xml:space="preserve">
          <source>Some linkers are capable of detecting out-of-range calls and generating glue code on the fly. On these systems, long calls are unnecessary and generate slower code. As of this writing, the AIX linker can do this, as can the GNU linker for PowerPC/64. It is planned to add this feature to the GNU linker for 32-bit PowerPC systems as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ded2d98e8ad6e738cfb416e0e144f7c6488a8f" translate="yes" xml:space="preserve">
          <source>Some machines never actually require alignment; they allow references to any data type even at an odd address. For these machines, &lt;code&gt;__alignof__&lt;/code&gt; reports the smallest alignment that GCC gives the data type, usually as mandated by the target ABI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e609cdc1429a6fcb8d2a4566b95c795a179f9f38" translate="yes" xml:space="preserve">
          <source>Some more examples of the use of &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a9b6bbb4ff568061400bba291a0fa95f27baca" translate="yes" xml:space="preserve">
          <source>Some object formats, like ELF, allow interposing of symbols by the dynamic linker. This means that for symbols exported from the DSO, the compiler cannot perform interprocedural propagation, inlining and other optimizations in anticipation that the function or variable in question may change. While this feature is useful, for example, to rewrite memory allocation functions by a debugging implementation, it is expensive in the terms of code quality. With</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b2cdebe3092f05376eba4dc6edb1163b208474" translate="yes" xml:space="preserve">
          <source>Some of these problems are due to bugs in other software, some are missing features that are too much work to add, and some are places where people&amp;rsquo;s opinions differ as to what is best.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a8bcdbd9732dbb47db6e251241faa598f69eaa" translate="yes" xml:space="preserve">
          <source>Some operands need to be in particular places on the stack. All output operands fall in this category&amp;mdash;GCC has no other way to know which registers the outputs appear in unless you indicate this in the constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc3611475871be65cea3ae1eb8a4118c1e3da02" translate="yes" xml:space="preserve">
          <source>Some options for compiling C programs, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aab2dd921eb504a0a6bf04d60fa17f07ef07e59" translate="yes" xml:space="preserve">
          <source>Some options take one or more arguments typically separated either by a space or by the equals sign (&amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09c01fb6d97b0be636c36b27746781fe632f575" translate="yes" xml:space="preserve">
          <source>Some options, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b764d6df82f9df721fda3ecd882ae472b0abef6" translate="yes" xml:space="preserve">
          <source>Some other command-line options starting with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1de7c862240cc77fd4597210b6bd463edb0754" translate="yes" xml:space="preserve">
          <source>Some spurious warnings can be avoided if you declare all the functions you use that never return as &lt;code&gt;noreturn&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7a7ebb3620b1d731c5783bb7dadf2877e0be61" translate="yes" xml:space="preserve">
          <source>Some targets have a special register that holds the &amp;ldquo;flags&amp;rdquo; for the result of an operation or comparison. Normally, the contents of that register are either unmodifed by the asm, or the &lt;code&gt;asm&lt;/code&gt; statement is considered to clobber the contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece7407fc707518ca6db13a249080d20314edfb1" translate="yes" xml:space="preserve">
          <source>Some targets require that GCC track the size of each instruction used in order to generate correct code. Because the final length of the code produced by an &lt;code&gt;asm&lt;/code&gt; statement is only known by the assembler, GCC must make an estimate as to how big it will be. It does this by counting the number of instructions in the pattern of the &lt;code&gt;asm&lt;/code&gt; and multiplying that by the length of the longest instruction supported by that processor. (When working out the number of instructions, it assumes that any occurrence of a newline or of whatever statement separator character is supported by the assembler &amp;mdash; typically &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a576a0cb85284fa181b1af5cb015b4bd820399" translate="yes" xml:space="preserve">
          <source>Some targets, e.g. x86 and PowerPC, support the &lt;code&gt;#pragma ms_struct&lt;/code&gt; directive which lays out structures and unions subsequently defined as the documented &lt;code&gt;__attribute__ ((ms_struct))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c528c0b130160ed58ee14f8bbba2d7a132054b" translate="yes" xml:space="preserve">
          <source>Some users try to use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c714f3fa36461f2e5681ce26cd399297f4a56453" translate="yes" xml:space="preserve">
          <source>Some users try to use &lt;code&gt;__STDC__&lt;/code&gt; to check for the availability of certain library facilities. This is actually incorrect usage in an ISO C program, because the ISO C standard says that a conforming freestanding implementation should define &lt;code&gt;__STDC__&lt;/code&gt; even though it does not have the library facilities. &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0811681aff3d220c177a6ae42df51a4668d70d" translate="yes" xml:space="preserve">
          <source>Sometimes a single instruction has multiple alternative sets of possible operands. For example, on the 68000, a logical-or instruction can combine register or an immediate value into memory, or it can combine any kind of operand into a register; but it cannot combine one memory location into another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcdf40850f5e7d0e40bbaa8bc961e1b76a034440" translate="yes" xml:space="preserve">
          <source>Sometimes it is desirable to write code using a mix of generic vector operations (for clarity) and machine-specific vector intrinsics (to access vector instructions that are not exposed via generic built-ins). On x86, intrinsic functions for integer vectors typically use the same vector type &lt;code&gt;__m128i&lt;/code&gt; irrespective of how they interpret the vector, making it necessary to cast their arguments and return values from/to other vector types. In C, you can make use of a &lt;code&gt;union&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b9f7e78924f4429d79b3875d59ae1541b656fb" translate="yes" xml:space="preserve">
          <source>Sometimes people say that defining &lt;code&gt;__STDC__&lt;/code&gt; in a compiler that does not completely conform to the ISO C standard somehow violates the standard. This is illogical. The standard is a standard for compilers that claim to support ISO C, such as &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8110c50df0a3ae32bff485105c38a69468d7fdd2" translate="yes" xml:space="preserve">
          <source>Special constraints for some particular machines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba4930cab85f2e9501af3573b08b92708f7a0ae" translate="yes" xml:space="preserve">
          <source>Special format strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9d5504a562859df5546c189640d36f2ebdc1bd" translate="yes" xml:space="preserve">
          <source>Special syntax for implementing &lt;code&gt;offsetof&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253477bfce70caeee68c5d46f4cbdd5958d04b09" translate="yes" xml:space="preserve">
          <source>Specifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae65de83d82c109b91ff281d719a67482b13328" translate="yes" xml:space="preserve">
          <source>Specifies a C lvalue expression to hold the output, typically a variable name. The enclosing parentheses are a required part of the syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05513a361baed0fc6bc2b4e7e1181bfda41a5c6c" translate="yes" xml:space="preserve">
          <source>Specifies a symbolic name for the operand. Reference the name in the assembler template by enclosing it in square brackets (i.e. &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c765ec9a6362d918fb2bf1565e87927ec8cd6358" translate="yes" xml:space="preserve">
          <source>Specifies general-purposes registers that the processor automatically saves/restores on interrupt entry and exit. &lt;var&gt;register-range&lt;/var&gt; is specified as two registers separated by a dash. The register range always starts with &lt;code&gt;r0&lt;/code&gt;, the upper limit is &lt;code&gt;fp&lt;/code&gt; register. &lt;var&gt;blink&lt;/var&gt; and &lt;var&gt;lp_count&lt;/var&gt; are optional. This option is only valid for ARC EM and ARC HS cores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3854791e88bad573a0be4f46ed869cefa1b475c" translate="yes" xml:space="preserve">
          <source>Specifies maximal growth of large function caused by inlining in percents. For example, parameter value 100 limits large function growth to 2.0 times the original size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe06371f415167055f13157f6cd31af5c5dbd88" translate="yes" xml:space="preserve">
          <source>Specifies maximal growth of large stack frames caused by inlining in percents. For example, parameter value 1000 limits large stack frame growth to 11 times the original size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94731e3c8ea6ab127a428ca6dbbe480337db1263" translate="yes" xml:space="preserve">
          <source>Specifies maximal overall growth of the compilation unit caused by inlining. For example, parameter value 20 limits unit growth to 1.2 times the original size. Cold functions (either marked cold via an attribute or by profile feedback) are not accounted into the unit size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a6169df4d1b9f4ae3a854ae149c4bc3eb831c7" translate="yes" xml:space="preserve">
          <source>Specifies maximal overall growth of the compilation unit caused by interprocedural constant propagation. For example, parameter value 10 limits unit growth to 1.1 times the original size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09858fd018d531b5e4ff4ecd665a6f14de1bdc3" translate="yes" xml:space="preserve">
          <source>Specifies that interrupt handler functions should preserve the MDUC registers. This is only necessary if normal code might use the MDUC registers, for example because it performs multiplication and division operations. The default is to ignore the MDUC registers as this makes the interrupt handlers faster. The target option -mg13 needs to be passed for this to work as this feature is only available on the G13 target (S2 core). The MDUC registers will only be saved if the interrupt handler performs a multiplication or division operation or it calls another function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16a3667d78dbf88b960c5650973c17d00b701b4" translate="yes" xml:space="preserve">
          <source>Specifies that interrupt handler functions should preserve the accumulator register. This is only necessary if normal code might use the accumulator register, for example because it performs 64-bit multiplications. The default is to ignore the accumulator as this makes the interrupt handlers faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd671f6f6086870972e15aa7905ec8f7db267ac7" translate="yes" xml:space="preserve">
          <source>Specifies that the cache cannot be flushed by using a trap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47947b45b4744585e55d8f763014a0ae39516e00" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes an alternate runtime library to be linked in which supports, for example, file I/O. You must not use this option when generating programs that will run on real hardware; you must provide your own runtime library for whatever I/O functions are needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a7b7c9a6c346e8818d5fec33b1b2c04de8591c" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes an alternate runtime startup and library to be linked. You must not use this option when generating programs that will run on real hardware; you must provide your own runtime library for whatever I/O functions are needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc31c50b75b75e6cf86f872d21ade4b77825de9f" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes the simulator BSP provided by libgloss to be linked in. This option has effect only for &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b908ebdba88cf2c2a293fda93618017153fd58b" translate="yes" xml:space="preserve">
          <source>Specifies the ABI type to use for vectorizing intrinsics using an external library. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8e8fddb7d07761c1b84aad23b4814d921c564b" translate="yes" xml:space="preserve">
          <source>Specifies the ABI type to use for vectorizing intrinsics using an external library. The only type supported at present is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1277fdc0689b726ff15cccd084ddbac36979fe" translate="yes" xml:space="preserve">
          <source>Specifies the ISA to use. Accepted values are &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca955df8b960b04d79d7dd74115e500bda85663" translate="yes" xml:space="preserve">
          <source>Specifies the RL78 core to target. The default is the G14 core, also known as an S3 core or just RL78. The G13 or S2 core does not have multiply or divide instructions, instead it uses a hardware peripheral for these operations. The G10 or S1 core does not have register banks, so it uses a different calling convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f635669de18bf56a687958d1a8c71186afb495b2" translate="yes" xml:space="preserve">
          <source>Specifies the TLS dialect to use for this function. The behavior and permissible arguments are the same as for the command-line option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52b2c30fecaf2eb67f980f2baf7835c6acbf2e9" translate="yes" xml:space="preserve">
          <source>Specifies the architecture version and architectural extensions to use for this function. The behavior and permissible arguments are the same as for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbb7ebc147f28ae0dcd4250f31f3d8fd9cac55e" translate="yes" xml:space="preserve">
          <source>Specifies the core for which to tune the performance of this function and also whose architectural features to use. The behavior and valid arguments are the same as for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe58a5c95595be8f2a1ff92d9451c73415b5a99d" translate="yes" xml:space="preserve">
          <source>Specifies the core for which to tune the performance of this function. The behavior and permissible arguments are the same as for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28873c2fbf7d823a74544bebc8a6344119496c82" translate="yes" xml:space="preserve">
          <source>Specifies the fpu for which to tune the performance of this function. The behavior and permissible arguments are the same as for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce88289fcb8b24761c893dbf247fdd528b95133" translate="yes" xml:space="preserve">
          <source>Specifies the function to call to flush the I and D caches, or to not call any such function. If called, the function must take the same arguments as the common &lt;code&gt;_flush_func&lt;/code&gt;, that is, the address of the memory range for which the cache is being flushed, the size of the memory range, and the number 3 (to flush both caches). The default depends on the target GCC was configured for, but commonly is either &lt;code&gt;_flush_func&lt;/code&gt; or &lt;code&gt;__cpu_flush&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7671feaad590d7ec398f51bb4af652d4dc88ce38" translate="yes" xml:space="preserve">
          <source>Specifies the identification number of the ID-based shared library being compiled. Specifying a value of 0 generates more compact code; specifying other values forces the allocation of that number to the current library but is no more space- or time-efficient than omitting this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99738458ed498047e95197f3c00800b279d2d584" translate="yes" xml:space="preserve">
          <source>Specifies the identification number of the ID-based shared library being compiled. Specifying a value of 0 generates more compact code; specifying other values forces the allocation of that number to the current library, but is no more space- or time-efficient than omitting this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e382c74800682d2e9f3b74a1844826dd2ecb62" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of instructions an out-of-line copy of a self-recursive inline function can grow into by performing recursive inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5e540e476e706af7ae2a630f97b45afd6de5bb3" translate="yes" xml:space="preserve">
          <source>Specifies the maximum recursion depth used for recursive inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842831f7e4e5d29f3e7d0beec2854a0216bc6e42" translate="yes" xml:space="preserve">
          <source>Specifies the maximum size in bytes of global and static variables which can be placed into the small data area. Using the small data area can lead to smaller and faster code, but the size of area is limited and it is up to the programmer to ensure that the area does not overflow. Also when the small data area is used one of the RX&amp;rsquo;s registers (usually &lt;code&gt;r13&lt;/code&gt;) is reserved for use pointing to this area, so it is no longer available for use by the compiler. This could result in slower and/or larger code if variables are pushed onto the stack instead of being held in this register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7412a6cb9b0e0f8b6e7f0d0e77fd2140ccfb86a1" translate="yes" xml:space="preserve">
          <source>Specifies the maximum size, in bytes, of a constant that can be used as an operand in a RX instruction. Although the RX instruction set does allow constants of up to 4 bytes in length to be used in instructions, a longer value equates to a longer instruction. Thus in some circumstances it can be beneficial to restrict the size of constants that are used in instructions. Constants that are too big are instead placed into a constant pool and referenced via register indirection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f498cab10962b0798c0931ba2f63475387ade694" translate="yes" xml:space="preserve">
          <source>Specifies the name of the operating system function to call to flush the cache. The default is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb9f9dd93932f78051a635c26202d7d8e5535cd" translate="yes" xml:space="preserve">
          <source>Specifies the name of the target Blackfin processor. Currently, &lt;var&gt;cpu&lt;/var&gt; can be one of &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0803aab785a2e20aedd243e17212d6d9ce8548e" translate="yes" xml:space="preserve">
          <source>Specifies the number of memory-based pseudo-registers GCC uses during code generation. These pseudo-registers are used like real registers, so there is a tradeoff between GCC&amp;rsquo;s ability to fit the code into available registers, and the performance penalty of using memory instead of registers. Note that all modules in a program must be compiled with the same value for this option. Because of that, you must not use this option with GCC&amp;rsquo;s default runtime libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f3ed905850cb42bd6d50bb52af7907bc7a581e" translate="yes" xml:space="preserve">
          <source>Specifies the number of registers replicated in second register bank on entry to fast interrupt. Fast interrupts are interrupts with the highest priority level P0. These interrupts save only PC and STATUS32 registers to avoid memory transactions during interrupt entry and exit sequences. Use this option when you are using fast interrupts in an ARC V2 family processor. Permitted values are 4, 8, 16, and 32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="affdb413ade6c559688aa8325514465c16425b76" translate="yes" xml:space="preserve">
          <source>Specifies the trap number to use to flush the cache. The default is 12. Valid numbers are between 0 and 15 inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90e51847549c6d7bfb26f9d83f651beb9507ea1" translate="yes" xml:space="preserve">
          <source>Specifies the type of hardware multiplication and division support to be used. The simplest is &lt;code&gt;none&lt;/code&gt;, which uses software for both multiplication and division. This is the default. The &lt;code&gt;g13&lt;/code&gt; value is for the hardware multiply/divide peripheral found on the RL78/G13 (S2 core) targets. The &lt;code&gt;g14&lt;/code&gt; value selects the use of the multiplication and division instructions supported by the RL78/G14 (S3 core) parts. The value &lt;code&gt;rl78&lt;/code&gt; is an alias for &lt;code&gt;g14&lt;/code&gt; and the value &lt;code&gt;mg10&lt;/code&gt; is an alias for &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f81d16d95cc0305e73b474da06956f8e11e96d3" translate="yes" xml:space="preserve">
          <source>Specifies whether FP exceptions are enabled. This affects how FP instructions are scheduled for some processors. The default is that FP exceptions are enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b43446cb2dd4e94fe26ad69b18b9bf05535ef3" translate="yes" xml:space="preserve">
          <source>Specifies which coprocessor registers are available to the register allocator. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0598db288f6f533223b56d068b56fd87125317c1" translate="yes" xml:space="preserve">
          <source>Specifies which coprocessor registers are to be saved and restored by any function using them. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b3620228a9a55d3a61b6172646e0fda8c7d9e2" translate="yes" xml:space="preserve">
          <source>Specifies which floating-point ABI to use. Permissible values are: &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a477d8dab7ef5cc90c58a41d06ca3494aeba078f" translate="yes" xml:space="preserve">
          <source>Specify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d7c4da380841e46021fb0ca037b1a5efba92c6" translate="yes" xml:space="preserve">
          <source>Specify &lt;var&gt;prefix&lt;/var&gt; as the prefix for subsequent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b75d36373bf0a158266aad4b0685acf54bdd9f" translate="yes" xml:space="preserve">
          <source>Specify Atmel AVR instruction set architectures (ISA) or MCU type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ced711925ce2b86f2945855d11a9f765bdf3b8" translate="yes" xml:space="preserve">
          <source>Specify a register to hold the constant -1, which makes loading small negative constants and certain bitmasks faster. Allowable values for &lt;var&gt;reg&lt;/var&gt; are &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4e72d685bf13ccdca2b955146686e94f4dd820" translate="yes" xml:space="preserve">
          <source>Specify bit size of immediate TLS offsets. Valid values are 12, 24, 32, 48. This option requires binutils 2.26 or newer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee5fd4c06f208dc72a94346beb5b066cc520b6c" translate="yes" xml:space="preserve">
          <source>Specify bit size of immediate TLS offsets. Valid values are 14, 22, and 64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d343f19f5a896581a51d8a250efd477d791df5" translate="yes" xml:space="preserve">
          <source>Specify both</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790583d2504db1e70b776b6337942849b2d5671c" translate="yes" xml:space="preserve">
          <source>Specify default compute dimensions for parallel offload regions that do not explicitly specify. The &lt;var&gt;geom&lt;/var&gt; value is a triple of &amp;rsquo;:&amp;rsquo;-separated sizes, in order &amp;rsquo;gang&amp;rsquo;, &amp;rsquo;worker&amp;rsquo; and, &amp;rsquo;vector&amp;rsquo;. A size can be omitted, to use a target-specific default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c09fd54e93619fc886af47d25ab910da3f1f1d" translate="yes" xml:space="preserve">
          <source>Specify desired number of partitions produced during WHOPR compilation. The number of partitions should exceed the number of CPUs used for compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd74922c1fffe0660ee607e7c8c05e6b9c36231" translate="yes" xml:space="preserve">
          <source>Specify either the directory containing the gcov data files, or the object path name. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8bb63ac54bf2ea3fd989f2a3dede75fee9c409d" translate="yes" xml:space="preserve">
          <source>Specify explicitly the &lt;var&gt;language&lt;/var&gt; for the following input files (rather than letting the compiler choose a default based on the file name suffix). This option applies to all following input files until the next</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dece3d1baf820f578333563e62b95b8ee062ffd" translate="yes" xml:space="preserve">
          <source>Specify growth that the early inliner can make. In effect it increases the amount of inlining for code having a large abstraction penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b0123ff59c8271225f538f6c8fc4517d3e5946e" translate="yes" xml:space="preserve">
          <source>Specify how many &lt;var&gt;bytes&lt;/var&gt; of stack space will be requested for each GPU thread (wave-front). Beware that there may be many threads and limited memory available. The size of the stack allocation may also have an impact on run-time performance. The default is 32KB when using OpenACC or OpenMP, and 1MB otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9c99e300af9c8b6bed1288c468edd9f4ff0049" translate="yes" xml:space="preserve">
          <source>Specify integer and floating-point calling convention. &lt;var&gt;ABI-string&lt;/var&gt; contains two parts: the size of integer types and the registers used for floating-point types. For example &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83c8944a923ba0afcb420deeb5f2d35c92d90c2" translate="yes" xml:space="preserve">
          <source>Specify that intrinsic library functions are being compiled, passing all values in registers, no matter the size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece1c6c2bc5985e3475fb38d94d339c81045f6ff" translate="yes" xml:space="preserve">
          <source>Specify that the assembler should encode SSE instructions with VEX prefix. The option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e1f7a9d2a1718382e7b4d035866fa5b223eb27" translate="yes" xml:space="preserve">
          <source>Specify that the program entry point is &lt;var&gt;entry&lt;/var&gt;. The argument is interpreted by the linker; the GNU linker accepts either a symbol name or an address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109f76cb76b9bdcac0640d708d9f5aa531701516" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e795d47484c6aa284871594487a90d959a680146" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E. The preprocessor constant &lt;code&gt;__v850e__&lt;/code&gt; is defined if this option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b95c4ac2d723888f85d1eb5d22f7c525dcae0da" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E1. The preprocessor constants &lt;code&gt;__v850e1__&lt;/code&gt; and &lt;code&gt;__v850e__&lt;/code&gt; are defined if this option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978d09824c615036a75f151e3f181a0c030be29d" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E2. The preprocessor constant &lt;code&gt;__v850e2__&lt;/code&gt; is defined if this option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed32c1d3fe9b0d91dac78559f89b829020d693b3" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E2V3. The preprocessor constant &lt;code&gt;__v850e2v3__&lt;/code&gt; is defined if this option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45dfef0c4ebf051e18bbb6d800fab624cbb970fb" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E3V5. The preprocessor constant &lt;code&gt;__v850e3v5__&lt;/code&gt; is defined if this option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53303aa9a3d3e7e971e5fac1f2e4c19510c6915" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E3V5. This is an alias for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54503d1104c416ab9f70cb3eb9892d2467505fc" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850ES. This is an alias for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a7ba111bd81efdcb44d105c109fea8a9201317" translate="yes" xml:space="preserve">
          <source>Specify the C-SKY target architecture. Valid values for &lt;var&gt;arch&lt;/var&gt; are: &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e0bbd00da02b87a4bf01c5c95da5cd4e1c7d2f" translate="yes" xml:space="preserve">
          <source>Specify the C-SKY target processor. Valid values for &lt;var&gt;cpu&lt;/var&gt; are: &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc89fadc7861eb9269a2f0ab8fd00ec9f83fdfcb" translate="yes" xml:space="preserve">
          <source>Specify the SCORE5 as the target architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ac17f93e6b558b7b64a2653f4a0db05f2f20e9" translate="yes" xml:space="preserve">
          <source>Specify the SCORE5U of the target architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e0fec7f878028d3e3295fde4a330a4137fef1a" translate="yes" xml:space="preserve">
          <source>Specify the SCORE7 as the target architecture. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3faa14b10ee7726e8a0c19877d4b1bbbf4106dd0" translate="yes" xml:space="preserve">
          <source>Specify the SCORE7D as the target architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8f7f5802b742a1c6e69d2f1fd902f62c599e4f" translate="yes" xml:space="preserve">
          <source>Specify the access model for the thread local storage pointer. The valid models are &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe4d9d926d51c315bc40fdf7c449529e2dcee8d" translate="yes" xml:space="preserve">
          <source>Specify the architecture to generate code for in compiling the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ac0518f9e486f66b03f2a62260517f22563228" translate="yes" xml:space="preserve">
          <source>Specify the architecture to generate code for when compiling the function. If you select the &lt;code&gt;target(&quot;cpu=power7&quot;)&lt;/code&gt; attribute when generating 32-bit code, VSX and AltiVec instructions are not generated unless you use the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="815118b1ba2fa776327569310aabc51b60f85457" translate="yes" xml:space="preserve">
          <source>Specify the architecture to tune for in compiling the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c736ab6b1828855a9d2fe005636f63dbc18a00fc" translate="yes" xml:space="preserve">
          <source>Specify the architecture to tune for when compiling the function. If you do not specify the &lt;code&gt;target(&quot;tune=&lt;var&gt;TUNE&lt;/var&gt;&quot;)&lt;/code&gt; attribute and you do specify the &lt;code&gt;target(&quot;cpu=&lt;var&gt;CPU&lt;/var&gt;&quot;)&lt;/code&gt; attribute, compilation tunes for the &lt;var&gt;CPU&lt;/var&gt; architecture, and not the default tuning specified on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb717a175d86a7113193ef8b41cb494223988553" translate="yes" xml:space="preserve">
          <source>Specify the dialect to use for accessing thread local storage. Two &lt;var&gt;dialect&lt;/var&gt;s are supported&amp;mdash;&amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0bb1382b2b688a4ca78557929489507a5c35134" translate="yes" xml:space="preserve">
          <source>Specify the format of the &lt;code&gt;__fp16&lt;/code&gt; half-precision floating-point type. Permissible names are &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ccdaa4f82b5c59817de75dfddfa096068b5632" translate="yes" xml:space="preserve">
          <source>Specify the name of the target architecture and, optionally, one or more feature modifiers. This option has the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2ae06942e745baa6c648898511743a3997f671" translate="yes" xml:space="preserve">
          <source>Specify the name of the target architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd735b6bf455d85d0ce6fea68c71abb062c337b" translate="yes" xml:space="preserve">
          <source>Specify the name of the target processor for which GCC should tune the performance of the code. Permissible values for this option are: &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4403ce6e54a70cfa6d14c2a2335877fa18af0100" translate="yes" xml:space="preserve">
          <source>Specify the name of the target processor, optionally suffixed by one or more feature modifiers. This option has the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4092610bf9412a688b5dccb4c11f819e1c6c07fc" translate="yes" xml:space="preserve">
          <source>Specify the number of bits in an SVE vector register. This option only has an effect when SVE is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e688b24a3a041ea4cb98f3c1a8d73b1e4471b5fc" translate="yes" xml:space="preserve">
          <source>Specify the number of registers to reserve for fast interrupt handler functions. The value &lt;var&gt;N&lt;/var&gt; can be between 0 and 4. A value of 1 means that register &lt;code&gt;r13&lt;/code&gt; is reserved for the exclusive use of fast interrupt handlers. A value of 2 reserves &lt;code&gt;r13&lt;/code&gt; and &lt;code&gt;r12&lt;/code&gt;. A value of 3 reserves &lt;code&gt;r13&lt;/code&gt;, &lt;code&gt;r12&lt;/code&gt; and &lt;code&gt;r11&lt;/code&gt;, and a value of 4 reserves &lt;code&gt;r13&lt;/code&gt; through &lt;code&gt;r10&lt;/code&gt;. A value of 0, the default, does not reserve any registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96cf955f0da2fdbcd4bc1c6671a0522d71316b38" translate="yes" xml:space="preserve">
          <source>Specify the partitioning algorithm used by the link-time optimizer. The value is either &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f46dcee93a04ae249c6b3def708b00260f2a519" translate="yes" xml:space="preserve">
          <source>Specify the register to be used for PIC addressing. For standard PIC base case, the default is any suitable register determined by compiler. For single PIC base case, the default is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9157006b777e209a57da158df2f68846623d8678" translate="yes" xml:space="preserve">
          <source>Specify the size of each cache block, which must be a power of 2 between 4 and 512.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edab8f619041277bee138aa740d3f8bdb844feca" translate="yes" xml:space="preserve">
          <source>Specify the size of each interrupt vector, which must be 4 or 16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde0e6e48055b68c9dfa72618fe117ee2653e7c8" translate="yes" xml:space="preserve">
          <source>Specify the size of the operating system provided stack guard as 2 raised to &lt;var&gt;num&lt;/var&gt; bytes. Higher values may reduce the number of explicit probes, but a value larger than the operating system provided guard will leave code vulnerable to stack clash style attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bee625f3585900ec98450bcf9d2c818f2c00803" translate="yes" xml:space="preserve">
          <source>Specify the struct-like types for which the compiler generates debug information. The intent is to reduce duplicate struct debug information between different object files within the same program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0fd0bd7b4133166f8983f5ca490beae5286735" translate="yes" xml:space="preserve">
          <source>Specify the width of the &lt;code&gt;lp_count&lt;/code&gt; register. Valid values for &lt;var&gt;width&lt;/var&gt; are 8, 16, 20, 24, 28 and 32 bits. The default width is fixed to 32 bits. If the width is less than 32, the compiler does not attempt to transform loops in your program to use the zero-delay loop mechanism unless it is known that the &lt;code&gt;lp_count&lt;/code&gt; register can hold the required loop-counter value. Depending on the width specified, the compiler and run-time library might continue to use the loop mechanism for various needs. This option defines macro &lt;code&gt;__ARC_LPC_WIDTH__&lt;/code&gt; with the value of &lt;var&gt;width&lt;/var&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef84b64c518f868fe3c1456dcd8b940ed2f5f518" translate="yes" xml:space="preserve">
          <source>Specify thread pointer register number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0795a2fa90067cc8a239666f6041471cc59a29ac" translate="yes" xml:space="preserve">
          <source>Specify whether GCC may generate code that reads from executable sections. There are three possible settings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19282618f9569137fcb9b5340c3ea42b2a33ba2" translate="yes" xml:space="preserve">
          <source>Specify whether GCC should insert cache barriers to avoid the side effects of speculation on R10K processors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1440f232d0fc9c6f8894e1bd99ffd6ec679cd656" translate="yes" xml:space="preserve">
          <source>Specify which floating-point unit to use. You must specify the &lt;code&gt;target(&quot;fpmath=sse,387&quot;)&lt;/code&gt; option as &lt;code&gt;target(&quot;fpmath=sse+387&quot;)&lt;/code&gt; because the comma would separate different options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f360040b863c4a298bd666b8b6b30d2471ac8011" translate="yes" xml:space="preserve">
          <source>Specifying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99167fd0d0a95abb4e35db3c3f342b56f873f72a" translate="yes" xml:space="preserve">
          <source>Specifying &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1885b005623a5f02d47b85a83ced0900c30f8b7" translate="yes" xml:space="preserve">
          <source>Specifying a combination that is not valid for the current architecture causes GCC to synthesize the instructions using a narrower mode. For example, if you specify a variable of type &lt;code&gt;V4SI&lt;/code&gt; and your architecture does not allow for this specific SIMD type, GCC produces code that uses 4 &lt;code&gt;SIs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7e05645dcca05e87ea389d828aa6bfe5f9fa1f" translate="yes" xml:space="preserve">
          <source>Specifying a larger number can produce faster, more efficient code, but can also increase the size of the program. Different values are potentially incompatible. Code compiled with one value cannot necessarily expect to work with code or libraries compiled with another value, if they exchange information using structures or unions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c6ae3356882b0eeb6636e77ccaa0aba81823b0" translate="yes" xml:space="preserve">
          <source>Specifying attributes of types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1c53b45f7e03f5a8d931294deb320e271bf08b" translate="yes" xml:space="preserve">
          <source>Specifying attributes of variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db2ee21c24dcdf45bcae194cf2ecad708afe6a7" translate="yes" xml:space="preserve">
          <source>Specifying attributes on enumerators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae68580bc0d24f5d44a4b1108b3374a4cbf533b1" translate="yes" xml:space="preserve">
          <source>Specifying attributes on labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4d8f85b31cb45df6efc5370ca55a06e5b2185a" translate="yes" xml:space="preserve">
          <source>Specifying attributes on statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fb77efc8cd285dcec19a190e5fd370517a59b0" translate="yes" xml:space="preserve">
          <source>Specifying conventions for function calls, data layout and register usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a322c1f2da20dac777d0e24ef37843a3925d344" translate="yes" xml:space="preserve">
          <source>Specifying libraries and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c808a95c8bd97d1d48f311fe3d1ff9cbb26d16" translate="yes" xml:space="preserve">
          <source>Specifying target attributes on individual functions or performing link-time optimization across translation units compiled with different target options can affect function inlining rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee9cc1aa83bf2a8aaa7d549089eae697b9df2fe" translate="yes" xml:space="preserve">
          <source>Specifying the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be769970f9d0ab94f326ad5f60920cc958cef495" translate="yes" xml:space="preserve">
          <source>Specifying the assembler name to use for a C symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b768e2f08c0d665e3b9b9a2f57c49ac37e0b4986" translate="yes" xml:space="preserve">
          <source>Speculation Barrier Instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39eb4a0ece25ea3aad502401ffe4e7271da49e1" translate="yes" xml:space="preserve">
          <source>Speculatively hoist loads from both branches of an if-then-else if the loads are from adjacent locations in the same structure and the target architecture has a conditional move instruction. This flag is enabled by default at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c7808e8703d45ea319f5ac9cfea72c1d3b2c26" translate="yes" xml:space="preserve">
          <source>Split 32-byte AVX unaligned load and store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66f8bdb0cdd7c740f8bab1b871317c083f59cec" translate="yes" xml:space="preserve">
          <source>Split a loop into two if it contains a condition that&amp;rsquo;s always true for one side of the iteration space and false for the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e793f0b9e2c47f7ff51cea5a83ac494564f9b01" translate="yes" xml:space="preserve">
          <source>Split paths leading to loop backedges. This can improve dead code elimination and common subexpression elimination. This is enabled by default at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c19cf5ca00368b6bf60823f07c7f7db52961a1db" translate="yes" xml:space="preserve">
          <source>Split the include path. This option has been deprecated. Please use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d6628c91b12235f628c3f0849b814233af5af3" translate="yes" xml:space="preserve">
          <source>Split vector moves into single word moves before reload. In theory this can give better register allocation, but so far the reverse seems to be generally the case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6e2276ec4ca5446d91dd4b3bca6fc9336a2104" translate="yes" xml:space="preserve">
          <source>Stack clash protection involves probing stack space as it is allocated. This param controls the maximum distance between probes into the stack as 2 raised to &lt;var&gt;num&lt;/var&gt; bytes. Higher values may reduce the number of explicit probes, but a value larger than the operating system provided guard will leave code vulnerable to stack clash style attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42423254dd8ef2b598b3ee0e697e74e7db04abbc" translate="yes" xml:space="preserve">
          <source>Stack pointer register (SP).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d47e20f0d3ac51ec48cf366af32c77c2669b54f" translate="yes" xml:space="preserve">
          <source>Stack pointer register (SPH:SPL)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ceeae642420027f1322393a2a3a2e2bcca2060" translate="yes" xml:space="preserve">
          <source>Stack register $sp.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b7dc1683e0d583c27f00412d344ea74bdf5a0a" translate="yes" xml:space="preserve">
          <source>Stack variables are not affected by linker restrictions; GCC can properly align them on any target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5a8f549a994c1b8e4dd80d24db9f3996eea422" translate="yes" xml:space="preserve">
          <source>Standard 80387 floating point constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="257c765fd4761dbfb8a7c22158ae9ccc2a9c0d89" translate="yes" xml:space="preserve">
          <source>Standard C requires that pointer types used with &lt;code&gt;va_arg&lt;/code&gt; in functions with variable argument lists either must be compatible with that of the actual argument, or that one type must be a pointer to &lt;code&gt;void&lt;/code&gt; and the other a pointer to a character type. GNU C implements the POSIX XSI extension that additionally permits the use of &lt;code&gt;va_arg&lt;/code&gt; with a pointer type to receive arguments of any other pointer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7654adc68a64f36e03bf390845ec45238411d8" translate="yes" xml:space="preserve">
          <source>Standard C90 requires the elements of an initializer to appear in a fixed order, the same as the order of the elements in the array or structure being initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23b0b38a39d349a3165d9fefce6588293b09611" translate="yes" xml:space="preserve">
          <source>Standard system directories are scanned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3657857ae8fa83a5a6acb61ee0490999a1f0da" translate="yes" xml:space="preserve">
          <source>Start a RTM (Restricted Transactional Memory) transaction. Returns &lt;code&gt;_XBEGIN_STARTED&lt;/code&gt; when the transaction started successfully (note this is not 0, so the constant has to be explicitly tested).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d321cb5e91b977aa5f4a76bb28fcd908795d2d2b" translate="yes" xml:space="preserve">
          <source>Start lock elision on a lock variable. Memory order must be &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; or stronger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d710b21a9b9bf4c6c45243e4c0bf0c7460f48764" translate="yes" xml:space="preserve">
          <source>Starting with GCC 3.2, GCC binary conventions for C++ are based on a written, vendor-neutral C++ ABI that was designed to be specific to 64-bit Itanium but also includes generic specifications that apply to any platform. This C++ ABI is also implemented by other compiler vendors on some platforms, notably GNU/Linux and BSD systems. We have tried hard to provide a stable ABI that will be compatible with future GCC releases, but it is possible that we will encounter problems that make this difficult. Such problems could include different interpretations of the C++ ABI by different vendors, bugs in the ABI, or bugs in the implementation of the ABI in different compilers. GCC&amp;rsquo;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0603cbbfdea44aa94fc492612a783b691bd4ebd" translate="yes" xml:space="preserve">
          <source>Starting with GCC 4.7.0, the traditional GNU runtime API is no longer available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d99177a777348b93d27364c0bfe456087ad31a7" translate="yes" xml:space="preserve">
          <source>Statement Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5ff5b401235fc57fb6c95d79c8c8b7116e1c37" translate="yes" xml:space="preserve">
          <source>States an expression as an assumption, and if possible, verifies that the assumption is valid. For example, &lt;code&gt;assume(n &amp;gt; 0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f44280770a4ee1097a4edddc52f0cd05d85a900" translate="yes" xml:space="preserve">
          <source>Static libraries are archives of object files, and have file names like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46e734f5fd8510b9e062efd2082eeb14db6af81" translate="yes" xml:space="preserve">
          <source>Static member declarations are not definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94ff9dc4d646834a0535298621e393784d6f1d3" translate="yes" xml:space="preserve">
          <source>Stop after the preprocessing stage; do not run the compiler proper. The output is in the form of preprocessed source code, which is sent to the standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2daee47861dfd3c59bf8ff060a32e292f65fec05" translate="yes" xml:space="preserve">
          <source>Stop after the stage of compilation proper; do not assemble. The output is in the form of an assembler code file for each non-assembler input file specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8347e9bfc02ac3a60787813c10d80e9ff680d75e" translate="yes" xml:space="preserve">
          <source>Stop forward growth if the best edge has probability lower than this threshold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e3b1851a75fdb25f8f9ca9807e49174553cf12" translate="yes" xml:space="preserve">
          <source>Stop forward growth if the probability of best edge is less than this threshold (in percent). Used when profile feedback is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2c101566fb4988550c86b87f1d88d336f66263" translate="yes" xml:space="preserve">
          <source>Stop reverse growth when the reverse probability of best edge is less than this threshold (in percent).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4aff278c0fdce3e7f55f32e7c895daaa47f804" translate="yes" xml:space="preserve">
          <source>Stop tail duplication once code growth has reached given percentage. This is a rather artificial limit, as most of the duplicates are eliminated later in cross jumping, so it may be set to much higher values than is the desired code growth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5524f873f830633dc8a23de8cf2d30b3d74c34d" translate="yes" xml:space="preserve">
          <source>Store (do not store) the address of the caller&amp;rsquo;s frame as backchain pointer into the callee&amp;rsquo;s stack frame. A backchain may be needed to allow debugging using tools that do not understand DWARF call frame information. When</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16037d0dfeba50e99ce7619111826617ed26b77" translate="yes" xml:space="preserve">
          <source>Store data (but not code) in the big-endian format. The default is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b3895de4641414ac79dc4d41b3d54519e0dbbf" translate="yes" xml:space="preserve">
          <source>Store the usual &amp;ldquo;temporary&amp;rdquo; intermediate files permanently. If the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825a3542481737ba30d5e3c1a289571cd11217e5" translate="yes" xml:space="preserve">
          <source>Store the usual &amp;ldquo;temporary&amp;rdquo; intermediate files permanently; place them in the current directory and name them based on the source file. Thus, compiling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a52a11a90147dcb5f7e83906aec646860b00234" translate="yes" xml:space="preserve">
          <source>Storing into the pointer can be done likewise with the same union.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e43c92861ad3e02cc7239ce0887aa080085a685" translate="yes" xml:space="preserve">
          <source>Storing the new address in &lt;code&gt;*&lt;var&gt;ra-address&lt;/var&gt;&lt;/code&gt;, if &lt;var&gt;ra-address&lt;/var&gt; is nonnull.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51f83d4384be85e0661264f111bae505e048852" translate="yes" xml:space="preserve">
          <source>Stream extra information needed for aggressive devirtualization when running the link-time optimizer in local transformation mode. This option enables more devirtualization but significantly increases the size of streamed data. For this reason it is disabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474bfcc8400d6e8dacea61eec4b30865208de5b9" translate="yes" xml:space="preserve">
          <source>Structure members are stored sequentially in the order in which they are declared: the first member has the lowest memory address and the last member the highest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3de1ed2a463e2a1c2ff86baf892b9da62d4e4d8" translate="yes" xml:space="preserve">
          <source>Structure of the JSON is following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4ea855e21caf3a76611861328cfb1249cb6b2a" translate="yes" xml:space="preserve">
          <source>Structures with no members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9075bc2ab7ab689b643437d474f305a0857530db" translate="yes" xml:space="preserve">
          <source>Stubs are generated automatically by the linker if the following two conditions are met:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9013b380508240de43628bfd190a9b994da8e678" translate="yes" xml:space="preserve">
          <source>Substitute a file name that has suffix &lt;var&gt;suffix&lt;/var&gt; and is chosen once per compilation, and mark the argument in the same way as &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a84f064e80a6c0f3317c7855f9c6ac2c41131d2" translate="yes" xml:space="preserve">
          <source>Substitute any of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998b2b0ec7c7cc0618199202723cd62e2208d036" translate="yes" xml:space="preserve">
          <source>Substitute one &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0f6708feea91da92348701c1acca054bd497b6" translate="yes" xml:space="preserve">
          <source>Substitute the basename of the input file being processed. This is the substring up to (and not including) the last period and not including the directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de1b430997906cd235f8cdbc3a04979f0ce1846" translate="yes" xml:space="preserve">
          <source>Substitute the contents of spec string &lt;var&gt;name&lt;/var&gt; at this point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2fde2ae73c8516cb1a3cac098e2359e8a7c33a" translate="yes" xml:space="preserve">
          <source>Substitute the name of the input file being processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8eaa414e533e6922c45c08150cca1cb19b9be1" translate="yes" xml:space="preserve">
          <source>Substitute the variable part of a matched option. See below. Note that each comma in the substituted string is replaced by a single space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43dec03cdd027bda7c71fa5dcb7ea1dab00d8963" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt; if either &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-P&lt;/code&gt; is given to GCC. This may be combined with &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6be527872250ba01c3017e89b857046ca96045c" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt; if one or more switches whose names start with &lt;code&gt;-S&lt;/code&gt; are specified to GCC. Normally &lt;code&gt;X&lt;/code&gt; is substituted only once, no matter how many such switches appeared. However, if &lt;code&gt;%*&lt;/code&gt; appears somewhere in &lt;code&gt;X&lt;/code&gt;, then &lt;code&gt;X&lt;/code&gt; is substituted once for each matching switch, with the &lt;code&gt;%*&lt;/code&gt; replaced by the part of that switch matching the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786d7f6a8f7f27970f79f53feb14051559d33597" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if &lt;em&gt;not&lt;/em&gt; processing a file with suffix &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864ccc2fa9d07c116ad04b8eeaefd7787e81b65c" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if not processing a file for language &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dfa62f2736f224c236543aa31324e1526b2435" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if processing a file for language &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6dded313927000e1a3934ea810bce16c0a202a3" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if processing a file with suffix &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0531e0f44345fcee0b59ff85181d8e187cb0d34" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381da79492b4d41df2595656917a76e838b4035d" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;var&gt;.SUFFIX&lt;/var&gt; for the suffixes of a matched switch&amp;rsquo;s args when it is subsequently output with &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330d507dbe426595b8910e78b9c215b447059d1c" translate="yes" xml:space="preserve">
          <source>Substitutes all the switches specified to GCC whose names start with &lt;code&gt;-S&lt;/code&gt;, but which also take an argument. This is used for switches like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c0a4e01bdd2a1adfb064f09d23d09f40d1cc63" translate="yes" xml:space="preserve">
          <source>Substitutes the &lt;code&gt;-S&lt;/code&gt; switch, if that switch is given to GCC. If that switch is not specified, this substitutes nothing. Note that the leading dash is omitted when specifying this option, and it is automatically inserted if the substitution is performed. Thus the spec string &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c13db3d4f7d55a97362e7f68ba24cf3424c2837" translate="yes" xml:space="preserve">
          <source>Substitutes the last file name generated with &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b4f52841be7dd8b1c205fb48bea71f8dc73cc8b" translate="yes" xml:space="preserve">
          <source>Substitutes the name of the &lt;code&gt;HOST_BIT_BUCKET&lt;/code&gt;, if any, and if it is writable, and if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510d92a70f7a6df088d50db8add12d77997610de" translate="yes" xml:space="preserve">
          <source>Substitutes the names of all the output files, with spaces automatically placed around them. You should write spaces around the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e406a2f9f9f2524ce85dd8f1df47e0fcb53fb6" translate="yes" xml:space="preserve">
          <source>Substitutes the standard macro predefinitions for the current target machine. Use this when running &lt;code&gt;cpp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601b96766181d9e1c5aa982978f52e20aab04d35" translate="yes" xml:space="preserve">
          <source>Substitutes the suffix for object files. Note that this is handled specially when it immediately follows &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb148237b08e3751f6fc1e4dce1cbcd763ff06d" translate="yes" xml:space="preserve">
          <source>Subtraction, multiplication, division, and the logical operations operate in a similar manner. Likewise, the result of using the unary minus or complement operators on a vector type is a vector whose elements are the negative or complemented values of the corresponding elements in the operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed92f9622e5eda43509c60bb3049fa12fe5ec7f" translate="yes" xml:space="preserve">
          <source>Such a feature would work only occasionally&amp;mdash;only for calls that appear in the same file as the called function, following the definition. The only way to check all calls reliably is to add a prototype for the function. But adding a prototype eliminates the motivation for this feature. So the feature is not worthwhile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af0feab651599b508e437900c6cfc81abd2fe41" translate="yes" xml:space="preserve">
          <source>Such accesses are supported, subject to the same requirements for synchronization for concurrent accesses as for concurrent accesses to any object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cfbaa1bf62e72b4bca886bc067e3bd96ad98df4" translate="yes" xml:space="preserve">
          <source>Such an array of label values serves a purpose much like that of the &lt;code&gt;switch&lt;/code&gt; statement. The &lt;code&gt;switch&lt;/code&gt; statement is cleaner, so use that rather than an array unless the problem does not fit a &lt;code&gt;switch&lt;/code&gt; statement very well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4348530a5b230f9786021cf2cdbed2168537bbe7" translate="yes" xml:space="preserve">
          <source>Such an object is normally accessed by pointers and used for accessing hardware. In most expressions, it is intuitively obvious what is a read and what is a write. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9903330f56016812404c897216c2074bedf62f" translate="yes" xml:space="preserve">
          <source>Such argument passing is supported, using the same pass-by-invisible-reference approach used for normal function arguments of such types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdaf5b5f6a3d1715a900b4b2779de302364392a5" translate="yes" xml:space="preserve">
          <source>Such assignments must be very common; warning about them would cause more annoyance than good.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc536d9f079301ea3cff9bd45f17bf843dbe50ad" translate="yes" xml:space="preserve">
          <source>Such built-in functions are provided for &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;mempcpy&lt;/code&gt;, &lt;code&gt;memmove&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;stpcpy&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt; and &lt;code&gt;strncat&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a73b44a4d02b7ee2f589148448bb9f1b269841d" translate="yes" xml:space="preserve">
          <source>Such code is suitable for level 0 PA systems and kernels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221482fe63639c70a1d813f43faebcec11cd2c30" translate="yes" xml:space="preserve">
          <source>Such expressions are rvalues, and GCC implements this as a read of the volatile object being pointed to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cf0f4f846947a1f248438be1e959f7db481213" translate="yes" xml:space="preserve">
          <source>Such tokens may not be concatenated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bba52ae9199f8bd23584e0938f470a93242074f" translate="yes" xml:space="preserve">
          <source>Support &lt;em&gt;IBM RS/6000 SP&lt;/em&gt;&lt;em&gt;Parallel Environment&lt;/em&gt; (PE). Link an application written to use message passing with special startup code to enable the application to run. The system must have PE installed in the standard location (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075bd5530c2b703c7849a9e331065651957bda71" translate="yes" xml:space="preserve">
          <source>Support ISO C trigraphs. These are three-character sequences, all starting with &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8219e8938cf7630391bdb51b3542081a049cff2c" translate="yes" xml:space="preserve">
          <source>Support all ISO C90 programs (certain GNU extensions that conflict with ISO C90 are disabled). Same as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54fea23628caa918a67b27ac084d811f983c065d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; and &lt;code&gt;resolveClassMethod:&lt;/code&gt; was added to the GNU Objective-C runtime in GCC version 4.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd68cf9e9a0ec7bc0fc781d9f962022790ff0418" translate="yes" xml:space="preserve">
          <source>Support for decimal floating types includes the arithmetic operators add, subtract, multiply, divide; unary arithmetic operators; relational operators; equality operators; and conversions to and from integer and other floating types. Use a suffix &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ca39c921120d2adfd04ac948aaa079d0c3ae01" translate="yes" xml:space="preserve">
          <source>Support for fixed-point types includes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e968c4a4e334d0a74a0d1d72a11bad05634a930" translate="yes" xml:space="preserve">
          <source>Support for garbage collection with the GNU runtime has been added by using a powerful conservative garbage collector, known as the Boehm-Demers-Weiser conservative garbage collector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0504a68e0c39cc0a79b57df0e39cf16b54d9e942" translate="yes" xml:space="preserve">
          <source>Support for these additional types includes the arithmetic operators: add, subtract, multiply, divide; unary arithmetic operators; relational operators; equality operators; and conversions to and from integer and other floating types. Use a suffix &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f86c51be480704f6fd0e7ee0fe1bad4e5dee50" translate="yes" xml:space="preserve">
          <source>Support thread-safe exception handling on MinGW. Programs that rely on thread-safe exception handling must compile and link all code with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b789d7421ca6bd2ef122f7c0fe30f55f0075ed29" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;var&gt;cpu&lt;/var&gt; are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb84e33320d5d24d55a608a57ed95d8069c1f60" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;var&gt;cpu_type&lt;/var&gt; are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e586e3e5b6ddb947a96ee95bbf9931e047b7a75c" translate="yes" xml:space="preserve">
          <source>Suppose for example you have a &lt;code&gt;FileStream&lt;/code&gt; class that declares &lt;code&gt;Stdin&lt;/code&gt;, &lt;code&gt;Stdout&lt;/code&gt; and &lt;code&gt;Stderr&lt;/code&gt; as global variables, like below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59b9335cfc4b19ac5e0c2f6fad649ab56af701c" translate="yes" xml:space="preserve">
          <source>Suppose the type &lt;code&gt;uid_t&lt;/code&gt; happens to be &lt;code&gt;short&lt;/code&gt;. ISO C does not allow this example, because subword arguments in old-style non-prototype definitions are promoted. Therefore in this example the function definition&amp;rsquo;s argument is really an &lt;code&gt;int&lt;/code&gt;, which does not match the prototype argument type of &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ba8dd72d18863780aea11859486731c35e5eea" translate="yes" xml:space="preserve">
          <source>Suppress the generation of link options to search libdld.sl when the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35c9ca6cfae417ba88541dbae7bd0b48fb96152" translate="yes" xml:space="preserve">
          <source>Suppress warning messages emitted by &lt;code&gt;#warning&lt;/code&gt; directives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f779f6a3dd8fc46f68f940fe5b38cc8f0332cb0" translate="yes" xml:space="preserve">
          <source>Suppress warnings about inheriting from a virtual base with a non-trivial C++11 move assignment operator. This is dangerous because if the virtual base is reachable along more than one path, it is moved multiple times, which can mean both objects end up in the moved-from state. If the move assignment operator is written to avoid moving from a moved-from object, this warning can be disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a42269132ea484d01ac088e414c9e42de642c6" translate="yes" xml:space="preserve">
          <source>Suppress warnings about use of C++11 inheriting constructors when the base class inherited from has a C variadic constructor; the warning is on by default because the ellipsis is not inherited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3aae6f5324c78295db9baccb5bafa853510ca1" translate="yes" xml:space="preserve">
          <source>Suppress warnings from applying the &lt;code&gt;offsetof&lt;/code&gt; macro to a non-POD type. According to the 2014 ISO C++ standard, applying &lt;code&gt;offsetof&lt;/code&gt; to a non-standard-layout type is undefined. In existing C++ implementations, however, &lt;code&gt;offsetof&lt;/code&gt; typically gives meaningful results. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba83304e4c99868bbbe79f9fdcf9011c9415eab0" translate="yes" xml:space="preserve">
          <source>Suppress warnings from casts from a pointer to an integer type of a different size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9b18daa97b7e3ff555e42290cbf027c56dba77" translate="yes" xml:space="preserve">
          <source>Suppress warnings from casts to pointer type of an integer of a different size. In C++, casting to a pointer type of smaller size is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c7bd9509193e71d10cdb667e9063dd06de3280" translate="yes" xml:space="preserve">
          <source>Suppress warnings when a positional initializer is used to initialize a structure that has been marked with the &lt;code&gt;designated_init&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5db30b4023b1a002e3bf61c91080c305981c620" translate="yes" xml:space="preserve">
          <source>Switch ARM/Thumb modes on alternating functions. This option is provided for regression testing of mixed Thumb/ARM code generation, and is not intended for ordinary use in compiling code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7301da94a751f6929a8a4eed4be94e8d5777d3a" translate="yes" xml:space="preserve">
          <source>Switch initialization conversion refuses to create arrays that are bigger than</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf2d10ad0dec99d41b3214114d91b1b2422b89f" translate="yes" xml:space="preserve">
          <source>Switch to code generation variant that allows to execute all threads in each warp, while maintaining memory state and side effects as if only one thread in each warp was active outside of OpenMP SIMD regions. All atomic operations and calls to runtime (malloc, free, vprintf) are conditionally executed (iff current lane index equals the master lane index), and the register being assigned is copied via a shuffle instruction from the master lane. Outside of SIMD regions lane 0 is the master; inside, each thread sees itself as the master. Shared memory array &lt;code&gt;int __nvptx_uni[]&lt;/code&gt; stores all-zeros or all-ones bitmasks for each warp, indicating current mode (0 outside of SIMD regions). Each thread can bitwise-and the bitmask at position &lt;code&gt;tid.y&lt;/code&gt; with current lane index to compute the master lane index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df31493a786b81749ab4d7d1c6bbb6b81f2ef537" translate="yes" xml:space="preserve">
          <source>Symbolic constant for call/jump instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02b75640f5617b344a6fd481b4fcf74a33c7dab" translate="yes" xml:space="preserve">
          <source>Synonyms for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f02fe7170bb60802488281e7b6535e4525bc7a" translate="yes" xml:space="preserve">
          <source>Syntax without an explicit &lt;var&gt;opts&lt;/var&gt; parameter is deprecated. It is equivalent to specifying an &lt;var&gt;opts&lt;/var&gt; list of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5461d0f57b9c531d984331d59cfb9c2b43a2f9" translate="yes" xml:space="preserve">
          <source>System V Release 4 small data area reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2218a74f01f0ccb4e48f5247664f57112a4f0aaf" translate="yes" xml:space="preserve">
          <source>TI C6X family&amp;mdash;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c941de06f499163c146e2988a363757665dd2da4" translate="yes" xml:space="preserve">
          <source>TILE-Gx&amp;mdash;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94413aebaec1d35ed29622efe6a91644c6c91dd4" translate="yes" xml:space="preserve">
          <source>TILEPro&amp;mdash;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd7eecc4f728ae74383a27923d7203db8bfeb4c" translate="yes" xml:space="preserve">
          <source>Take advantage of linker relaxations to reduce the number of instructions required to materialize symbol addresses. The default is to take advantage of linker relaxations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d35405dd4f6f085c687c5306bb4a6e617f2e88" translate="yes" xml:space="preserve">
          <source>Taking the address of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is permitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff36b684e3489808b01be7efb64c6849f9ba0f5" translate="yes" xml:space="preserve">
          <source>Taking the address of a label may generate errors from the HP-UX PA assembler. GAS for the PA does not have this problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7129ffec0f9a33a9ffe8b44de153b8593725b3" translate="yes" xml:space="preserve">
          <source>Taking the address of a scalar field of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is not permitted and yields an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5bfaf20daa2c55100557696546e467c263a569" translate="yes" xml:space="preserve">
          <source>Taking the address of an array field, whose component is scalar, of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is permitted but yields a warning, unless</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb41297adae8dd10c30aff884697e8695add6957" translate="yes" xml:space="preserve">
          <source>Taking this into account, it is important to note the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69e706d0180e6de86eaea828036822f65c39e90" translate="yes" xml:space="preserve">
          <source>Target architectures are encouraged to provide their own patterns for each of the atomic built-in functions. If no target is provided, the original non-memory model set of &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c745960637a96625efff80e3b7b6cb80a28125" translate="yes" xml:space="preserve">
          <source>Target has split instruction and data space. Implies -m45.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70857ff656af8497b29b5cea7cede66fd2b8d04e" translate="yes" xml:space="preserve">
          <source>Target-specific attributes that affect the identity of a type, such as ia32 calling conventions on a function type (stdcall, regparm, etc.), did not affect the mangled name, leading to name collisions when function pointers were used as template arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ac9adb172fe07da9b52a8103d4a87829fbaae5" translate="yes" xml:space="preserve">
          <source>Target-specific options, such as compiling for a specific processor variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a660e45a245ce196b4fdfa2d1b2b50ce849614" translate="yes" xml:space="preserve">
          <source>Tell the MIPS assembler to not run its preprocessor over user assembler files (with a &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c3b5335b5c0cc22332ebfdb31ac1bb53445273" translate="yes" xml:space="preserve">
          <source>Tells the compiler that any variable marked with the &lt;code&gt;io&lt;/code&gt; attribute is to be considered volatile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c80eca69977e6b469c44eecba1a817d3b44f7d0" translate="yes" xml:space="preserve">
          <source>Tells the compiler to perform function calls by first loading the address of the function into a register and then performing a subroutine call on this register. This switch is needed if the target function lies outside of the 24-bit addressing range of the offset-based version of subroutine call instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7974b9f9368d29b382ac1425edcaf88973b1540" translate="yes" xml:space="preserve">
          <source>Tells the compiler to perform function calls by first loading the address of the function into a register and then performing a subroutine call on this register. This switch is needed if the target function lies outside of the 64-megabyte addressing range of the offset-based version of subroutine call instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4035c3eab8e73aa47237d7e7a48fe4ab59208c8f" translate="yes" xml:space="preserve">
          <source>Template Instantiations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2cd45b5c86db640ab845c9538624992d63586f" translate="yes" xml:space="preserve">
          <source>Temporaries may vanish before you expect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5670dc2252e3e0202f196c05a183f0e891e7ce" translate="yes" xml:space="preserve">
          <source>Temporary assist register $ta (i.e. $r15).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01689c0a988a52e1980b89817f9a193bf32f058" translate="yes" xml:space="preserve">
          <source>Temporary register r0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb69100c455a5efc5c637f0862041f54fcc63021" translate="yes" xml:space="preserve">
          <source>That code overwrites the variable &lt;code&gt;Index&lt;/code&gt; (&amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d372c7173ccc49ed5f8266482156df6e30a1a0e" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;bool&amp;rdquo; version returns &lt;code&gt;true&lt;/code&gt; if the comparison is successful and &lt;var&gt;newval&lt;/var&gt; is written. The &amp;ldquo;val&amp;rdquo; version returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; before the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09bc8f2a14ab55c654c682384317bfec0642af39" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;signature&amp;rdquo; is a null-terminated string, composed of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c06e97499a27f0f80d31e89637ece588d8ec278" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;user time&amp;rdquo; and the &amp;ldquo;system time&amp;rdquo; are moved before the program name, and the options passed to the program are displayed, so that one can later tell what file was being compiled, and with which options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed4c9f9933dd9e4b8da3ca824145866c18f6a63" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9820649111d032078a2e341b12a064c77a65bbc2" translate="yes" xml:space="preserve">
          <source>The 16-bit &lt;code&gt;R10&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd88b0aaf75b51696b24c3768a2b1a20915edac" translate="yes" xml:space="preserve">
          <source>The 16-bit &lt;code&gt;R8&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1272239002f51f4809e26667c1b13c1b964633d" translate="yes" xml:space="preserve">
          <source>The 1998 ISO C++ standard plus the 2003 technical corrigendum and some additional defect reports. Same as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd06b261fe64d273c59c563a73adcb4a19fda6b" translate="yes" xml:space="preserve">
          <source>The 2011 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0824fd4223b0cb3aeed48d8b77f3a1b17acde06" translate="yes" xml:space="preserve">
          <source>The 2014 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75bfd00cf21586d8e597fcc9ed0b86883eb1dfa" translate="yes" xml:space="preserve">
          <source>The 2017 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e4484fd6590cd7f36b6fdf94168a5387d0e46c3" translate="yes" xml:space="preserve">
          <source>The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This has been fixed in GCC 4.4 but the change can lead to differences in the structure layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there is no longer a 4-bit padding between field &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in this structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909967fe10a21a246a86aeb337d0842e478f43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;cc&quot;&lt;/code&gt; clobber indicates that the assembler code modifies the flags register. On some machines, GCC represents the condition codes as a specific hardware register; &lt;code&gt;&quot;cc&quot;&lt;/code&gt; serves to name this register. On other machines, condition code handling is different, and specifying &lt;code&gt;&quot;cc&quot;&lt;/code&gt; has no effect. But it is valid no matter what the target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2534a799a74c45e086749f66cd7d314d0f206ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters). To ensure memory contains correct values, GCC may need to flush specific register values to memory before executing the &lt;code&gt;asm&lt;/code&gt;. Further, the compiler does not assume that any values read from memory before an &lt;code&gt;asm&lt;/code&gt; remain unchanged after that &lt;code&gt;asm&lt;/code&gt;; it reloads them as needed. Using the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber effectively forms a read/write memory barrier for the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287b2b66c9a7de19b9dd84de221d8d45c3b97aec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#pragma GCC target&lt;/code&gt; pragma is presently implemented for x86, ARM, AArch64, PowerPC, S/390, and Nios II targets only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ccfce523413ade3933dc06559f7495350ab0dd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; expressions for the same label might have different values if the containing function is inlined or cloned. If a program relies on them being always the same, &lt;code&gt;__attribute__((__noinline__,__noclone__))&lt;/code&gt; should be used to prevent inlining and cloning. If &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; is used in a static variable initializer, inlining and cloning is forbidden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e1502637058c6ab49c207cf28a3e3142aca9a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; implementation in the GNU runtime guarantees you the following things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91dd9757303b9f56bf3b6cb9119e24fe8a8727f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; is a method that is not overridden by categories. If a class and a category of it both implement &lt;code&gt;+load&lt;/code&gt;, both methods are invoked. This allows some additional initializations to be performed in a category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772d2fc6151afb4fb1792207ec49f4a45839a16b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; method is also invoked when a bundle is dynamically loaded into your running program. This happens automatically without any intervening operation from you. When you write bundles and you need to write &lt;code&gt;+load&lt;/code&gt; you can safely create and send messages to objects whose classes already exist in the running program. The same restrictions as above apply to classes defined in bundle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6d2c3cb15d85f1417842f0fbdf998d14486ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; and &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods thusly generated only operate on instance variables declared in the current Objective-C class, and not those inherited from superclasses. It is the responsibility of the Objective-C runtime to invoke all such methods in an object&amp;rsquo;s inheritance hierarchy. The &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; methods are invoked by the runtime immediately after a new object instance is allocated; the &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods are invoked immediately before the runtime deallocates an object instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7108ce8eed259a604477fdf012b421d600214df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@finally&lt;/code&gt; clause, if present, will be executed upon exit from the immediately preceding &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; section. This will happen regardless of whether any exceptions are thrown, caught or rethrown inside the &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; section, analogously to the behavior of the &lt;code&gt;finally&lt;/code&gt; clause in Java.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478f5300c419fd9f1ddbebddc4f1aa8b783e2f52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@throw&lt;/code&gt; statement may appear anywhere in an Objective-C or Objective-C++ program; when used inside of a &lt;code&gt;@catch&lt;/code&gt; block, the &lt;code&gt;@throw&lt;/code&gt; may appear without an argument (as shown above), in which case the object caught by the &lt;code&gt;@catch&lt;/code&gt; will be rethrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66bfb70bc3d8564c8867b596c9daf7ef51239bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;A&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abbdb5d09af41601d4b6214589f91ad242a72c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AX&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8869263f41399bf1548d77cd0b06fdeab5b6090" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b8662f23339aa40fc33f83b8bce9ef615fd089" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BC&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fafb503a49e3e2b7cffac8865ce407955e8ba5c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c945285a14de09364b5e9d34fc7e6e4e9171bb55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;D&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f334445b19ebbcdfd81f6a6a62d0c7c6a38f5f11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DE&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d9046824f2223a9b4a7038c1fdd6a7981413ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;E&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f8a2094444afcd8a79b22ed65059e8f2a29f862" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;H&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1c2a880567113429c4b1cc1d7e5ee3f5c01334" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HL&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2a84b1e54ac92e546337e928dcc83ba5c11f03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;L&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88299e2896aeb367bb70fd25b9a5db675642c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable specifies character classification. GCC uses it to determine the character boundaries in a string; this is needed for some multibyte encodings that contain quote and escape characters that are otherwise interpreted as a string end or escape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd95cbfac63c17d00419fc1cfbc5f410bf724a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_MESSAGES&lt;/code&gt; environment variable specifies the language to use in diagnostic messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d7ad50b2abf1611438129375bb15e01da761cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OS_main&lt;/code&gt; attribute can be used when there &lt;em&gt;is guarantee&lt;/em&gt; that interrupts are disabled at the time when the function is entered. This saves resources when the stack pointer has to be changed to set up a frame for local variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f1e35a5360b1f14267221fb24f61e47178d10d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OS_task&lt;/code&gt; attribute can be used when there is &lt;em&gt;no guarantee&lt;/em&gt; that interrupts are disabled at that time when the function is entered like for, e.g. task functions in a multi-threading operating system. In that case, changing the stack pointer register is guarded by save/clear/restore of the global interrupt enable flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973b834abbbf1594a420dbfab9c679298adbbcc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PSW&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b6c46fda7548d67fe293013e4597e13b6cc3ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SP&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c3ff8f2bcfaf9382aab427535123ecf6e87b0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7925d7fc0ef32aa9ba1ce9e18d90f31a2b1041d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Float128&lt;/code&gt; type is supported on all systems where &lt;code&gt;__float128&lt;/code&gt; is supported or where &lt;code&gt;long double&lt;/code&gt; has the IEEE binary128 format. The &lt;code&gt;_Float64x&lt;/code&gt; type is supported on all systems where &lt;code&gt;__float128&lt;/code&gt; is supported. The &lt;code&gt;_Float32&lt;/code&gt; type is supported on all systems supporting IEEE binary32; the &lt;code&gt;_Float64&lt;/code&gt; and &lt;code&gt;_Float32x&lt;/code&gt; types are supported on all systems supporting IEEE binary64. The &lt;code&gt;_Float16&lt;/code&gt; type is supported on AArch64 systems by default, and on ARM systems when the IEEE format for 16-bit floating-point types is selected with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85103cf2482f16ae09dc93810b2ec0258970e808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_HTM_FIRST_USER_ABORT_CODE&lt;/code&gt; defined in &lt;code&gt;htmintrin.h&lt;/code&gt; specifies the first abort code which can be used for &lt;code&gt;__builtin_tabort&lt;/code&gt;. Values below this threshold are reserved for machine use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392542e4dc2c75d48ed6b1e9e4e666156b2ab35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__attribute__&lt;/code&gt; keyword is followed by an attribute specification enclosed in double parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8acb405a5cf121cc5773d2c4339fe65a77bcf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_alloca&lt;/code&gt; function must be called at block scope. The function allocates an object &lt;var&gt;size&lt;/var&gt; bytes large on the stack of the calling function. The object is aligned on the default stack alignment boundary for the target determined by the &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; macro. The &lt;code&gt;__builtin_alloca&lt;/code&gt; function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends just before the calling function returns to its caller. This is so even when &lt;code&gt;__builtin_alloca&lt;/code&gt; is called within a nested block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699047c637b673c64e86fa3b74734bf759b728ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; function must be called at block scope. The function allocates an object &lt;var&gt;size&lt;/var&gt; bytes large on the stack of the calling function. The allocated object is aligned on the boundary specified by the argument &lt;var&gt;alignment&lt;/var&gt; whose unit is given in bits (not bytes). The &lt;var&gt;size&lt;/var&gt; argument must be positive and not exceed the stack size limit. The &lt;var&gt;alignment&lt;/var&gt; argument must be a constant integer expression that evaluates to a power of 2 greater than or equal to &lt;code&gt;CHAR_BIT&lt;/code&gt; and less than some unspecified maximum. Invocations with other values are rejected with an error indicating the valid bounds. The function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends at the end of the block in which the function was called. The allocated storage is released no later than just before the calling function returns to its caller, but may be released at the end of the block in which the function was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14b3efa7fa2847225bae57a72e4dc716953742d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; and &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; require an environment supporting ISA 3.0 or later. For these two functions, the &lt;code&gt;range&lt;/code&gt; argument is encoded as 4 bytes, organized as &lt;code&gt;hi_1:lo_1:hi_2:lo_2&lt;/code&gt;. The &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; function returns a non-zero value if and only if its &lt;code&gt;u&lt;/code&gt; argument is within the range bounded between &lt;code&gt;lo_2&lt;/code&gt; and &lt;code&gt;hi_2&lt;/code&gt; inclusive. The &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; function returns non-zero if and only if its &lt;code&gt;u&lt;/code&gt; argument is within either the range bounded between &lt;code&gt;lo_1&lt;/code&gt; and &lt;code&gt;hi_1&lt;/code&gt; inclusive or the range bounded between &lt;code&gt;lo_2&lt;/code&gt; and &lt;code&gt;hi_2&lt;/code&gt; inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c90a92a294d6da36a67b6812f4d7f784a68c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_byte_in_set&lt;/code&gt; function requires a 64-bit environment supporting ISA 3.0 or later. This function returns a non-zero value if and only if its &lt;code&gt;u&lt;/code&gt; argument exactly equals one of the eight bytes contained within its 64-bit &lt;code&gt;set&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb729367b3d36e784ee118ae00a98821f8cbe5c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cmpb&lt;/code&gt; function performs a byte-wise compare on the contents of its two arguments, returning the result of the byte-wise comparison as the returned value. For each byte comparison, the corresponding byte of the return value holds 0xff if the input bytes are equal and 0 if the input bytes are not equal. If either of the arguments to this built-in function is wider than 32 bits, the function call expands into the form that expects &lt;code&gt;unsigned long long int&lt;/code&gt; arguments which is only available on 64-bit targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26cf6e5166e71a9dc3d72ae3910f453428861ff1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cpu_is&lt;/code&gt; function requires GLIBC 2.23 or newer which exports the hardware capability bits. GCC defines the macro &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; if the &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; built-in function is fully supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="225ecb4eafc9e778fee170a226e93b379e52b096" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; function requires GLIBC 2.23 or newer which exports the hardware capability bits. GCC defines the macro &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; if the &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; built-in function is fully supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d549e750824586a0354c272406d5e4e5816a0ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_darn&lt;/code&gt; and &lt;code&gt;__builtin_darn_raw&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;__builtin_darn&lt;/code&gt; function provides a 64-bit conditioned random number. The &lt;code&gt;__builtin_darn_raw&lt;/code&gt; function provides a 64-bit raw random number. The &lt;code&gt;__builtin_darn_32&lt;/code&gt; function provides a 32-bit conditioned random number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4f02a6f5765f9e617ea8ee9a4170e4b962d403" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_eq&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument equals its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_eq_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_eq_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57591fb5134dd8d315ee0a2d1522ee30d9827c9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_gt&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument is greater than its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_gt_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_gt_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01dbf5e64c194eb164595e23ee9b740573ded8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_lt&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument is less than its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_lt_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_lt_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4420e5d860b7c4bb7ba6d7a8d1a6213bfe7043a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_ov&lt;/code&gt; function returns a non-zero value if and only if its &lt;code&gt;value&lt;/code&gt; argument has an undefined number of significant digits, such as when &lt;code&gt;value&lt;/code&gt; is an encoding of &lt;code&gt;NaN&lt;/code&gt;. The &lt;code&gt;__builtin_dfp_dtstsfi_ov_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_ov_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bfeb225a5faf6d6577d095e4bb9f94249f0a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_has_attribute&lt;/code&gt; function evaluates to an integer constant expression equal to &lt;code&gt;true&lt;/code&gt; if the symbol or type referenced by the &lt;var&gt;type-or-expression&lt;/var&gt; argument has been declared with the &lt;var&gt;attribute&lt;/var&gt; referenced by the second argument. For an &lt;var&gt;type-or-expression&lt;/var&gt; argument that does not reference a symbol, since attributes do not apply to expressions the built-in consider the type of the argument. Neither argument is evaluated. The &lt;var&gt;type-or-expression&lt;/var&gt; argument is subject to the same restrictions as the argument to &lt;code&gt;typeof&lt;/code&gt; (see &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;). The &lt;var&gt;attribute&lt;/var&gt; argument is an attribute name optionally followed by a comma-separated list of arguments enclosed in parentheses. Both forms of attribute names&amp;mdash;with and without double leading and trailing underscores&amp;mdash;are recognized. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details. When no attribute arguments are specified for an attribute that expects one or more arguments the function returns &lt;code&gt;true&lt;/code&gt; if &lt;var&gt;type-or-expression&lt;/var&gt; has been declared with the attribute regardless of the attribute argument values. Arguments provided for an attribute that expects some are validated and matched up to the provided number. The function returns &lt;code&gt;true&lt;/code&gt; if all provided arguments match. For example, the first call to the function below evaluates to &lt;code&gt;true&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is declared with the &lt;code&gt;aligned&lt;/code&gt; attribute but the second call evaluates to &lt;code&gt;false&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is declared &lt;code&gt;aligned (8)&lt;/code&gt; and not &lt;code&gt;aligned (4)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cbfc7ec73fa262c76440a5134fc2d0584d6a4cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_is_constant_evaluated&lt;/code&gt; function is available only in C++. The built-in is intended to be used by implementations of the &lt;code&gt;std::is_constant_evaluated&lt;/code&gt; C++ function. Programs should make use of the latter function rather than invoking the built-in directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4494406f2455746a4c649b18a2c01e01f2fd9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_mffsl&lt;/code&gt; uses the ISA 3.0 &lt;code&gt;mffsl&lt;/code&gt; instruction to read the FPSCR. The instruction is a lower latency version of the &lt;code&gt;mffs&lt;/code&gt; instruction. If the &lt;code&gt;mffsl&lt;/code&gt; instruction is not available, then the builtin uses the older &lt;code&gt;mffs&lt;/code&gt; instruction to read the FPSCR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c6f10224f071b484a2f23cb973dde539bd04b1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_pack_ibm128&lt;/code&gt; function takes two &lt;code&gt;double&lt;/code&gt; arguments and returns a &lt;code&gt;__ibm128&lt;/code&gt; value that combines the two arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce45c9f46fdb649818045c7651274a51c7c9b814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; function takes two &lt;code&gt;double&lt;/code&gt; arguments and returns a &lt;code&gt;long double&lt;/code&gt; value that combines the two arguments. The &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; function is only available if &lt;code&gt;long double&lt;/code&gt; uses the IBM extended double representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8465d06a8e70b59990aa3c2108eef59db7b2906e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; and &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; functions generate instructions to read the Time Base Register. The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; function may generate multiple instructions and always returns the 64 bits of the Time Base Register. The &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; function always generates one instruction and returns the Time Base Register value as an unsigned long, throwing away the most significant word on 32-bit environments. The &lt;code&gt;__builtin_mffs&lt;/code&gt; return the value of the FPSCR register. Note, ISA 3.0 supports the &lt;code&gt;__builtin_mffsl()&lt;/code&gt; which permits software to read the control and non-sticky status bits in the FSPCR without the higher latency associated with accessing the sticky status bits. The &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; and &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; take the bit to change as an argument. The valid bit range is between 0 and 31. The builtins map to the &lt;code&gt;mtfsb0&lt;/code&gt; and &lt;code&gt;mtfsb1&lt;/code&gt; instructions which take the argument and add 32. Hence these instructions only modify the FPSCR[32:63] bits by changing the specified bit to a zero or one respectively. The &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; builtin allows changing both of the floating point rounding mode bits. The argument is a 2-bit value. The argument can either be a &lt;code&gt;const int&lt;/code&gt; or stored in a variable. The builtin uses the ISA 3.0 instruction &lt;code&gt;mffscrn&lt;/code&gt; if available, otherwise it reads the FPSCR, masks the current rounding mode bits out and OR&amp;rsquo;s in the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198788e1a597fcc05831a074890ff7147c3e1998" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_recipdiv&lt;/code&gt;, and &lt;code&gt;__builtin_recipdivf&lt;/code&gt; functions generate multiple instructions to implement division using the reciprocal estimate instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca84e06c376750982f7cbde8f6e8edd81f796b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_unpack_ibm128&lt;/code&gt; function takes a &lt;code&gt;__ibm128&lt;/code&gt; argument and a compile time constant of 0 or 1. If the constant is 0, the first &lt;code&gt;double&lt;/code&gt; within the &lt;code&gt;__ibm128&lt;/code&gt; is returned, otherwise the second &lt;code&gt;double&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48855b25f6a50b8b8736a064f19a8b37e730a064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; function takes a &lt;code&gt;long double&lt;/code&gt; argument and a compile time constant of 0 or 1. If the constant is 0, the first &lt;code&gt;double&lt;/code&gt; within the &lt;code&gt;long double&lt;/code&gt; is returned, otherwise the second &lt;code&gt;double&lt;/code&gt; is returned. The &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; function is only available if &lt;code&gt;long double&lt;/code&gt; uses the IBM extended double representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7f4f10325e1d8819fa9c82ff898e127032c07d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__flash&lt;/code&gt; qualifier locates data in the &lt;code&gt;.progmem.data&lt;/code&gt; section. Data is read using the &lt;code&gt;LPM&lt;/code&gt; instruction. Pointers to this address space are 16 bits wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097ea3d6342e0a23a9235845e85db17d4022ac6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__fp16&lt;/code&gt; type may only be used as an argument to intrinsics defined in &lt;code&gt;&amp;lt;arm_fp16.h&amp;gt;&lt;/code&gt;, or as a storage format. For purposes of arithmetic and other operations, &lt;code&gt;__fp16&lt;/code&gt; values in C or C++ expressions are automatically promoted to &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec03917f805a8e50fbb98586530e665bfe69da73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier can be applied only to the names of objects and to anonymous unions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3af60ab1131c66623c0fb9cd375a6e888cff899" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier may be applied to any global, file-scoped static, function-scoped static, or static data member of a class. It may not be applied to block-scoped automatic or non-static data member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8177fe879ae4fe2cff503c3513d84606c176b85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, with the &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; specifiers, but with no other storage class specifier. When used with &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;__thread&lt;/code&gt; must appear immediately after the other storage class specifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63dae9f24b29dc710773ce4dac88b4e87c3c52d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier shall be used only with variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf603edfc142efac4a9a3b77d51d44293820a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__trampolines_start&lt;/code&gt; symbol is defined in the linker script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375e8541e5237f24ef902439af8b3c21cd835020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; registers. This class is used for instructions that return double word results in the &lt;code&gt;ax:dx&lt;/code&gt; register pair. Single word values will be allocated either in &lt;code&gt;ax&lt;/code&gt; or &lt;code&gt;dx&lt;/code&gt;. For example on i386 the following implements &lt;code&gt;rdtsc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0d40f91f92592e29ec24cddc648e15fc94fdbdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9b97f6ebb578cc8aa854722849a8e5b4602c9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abi_tag&lt;/code&gt; attribute can be applied to a function, variable, or class declaration. It modifies the mangled name of the entity to incorporate the tag name, in order to distinguish the function or class from an earlier version with a different ABI; perhaps the class has changed size, or the function has a different return type that is not encoded in the mangled name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecdfed9d96d6be598a27e07d494142206025586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; attribute causes the declaration to be emitted as an alias for another symbol, which must be specified. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf61029ae4ce438827c598f61cf786192d3f583" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute can also be used for functions (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="116110dd4cf7976fa8985541dcc415370c4044c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute can also be used for variables and fields (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b5ae34d39ede17878fd463e5860c5561589d603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment (in bytes) for variables of the specified type. When specified, &lt;var&gt;alignment&lt;/var&gt; must be a power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the maximum alignment for the target, which is often, but by no means always, 8 or 16 bytes. For example, the declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a176d406c41abb708c1f3ca71eadfaf0924f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment for the first instruction of the function, measured in bytes. When specified, &lt;var&gt;alignment&lt;/var&gt; must be an integer constant power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the ideal alignment for the target. The &lt;code&gt;__alignof__&lt;/code&gt; operator can be used to determine what that is (see &lt;a href=&quot;alignment#Alignment&quot;&gt;Alignment&lt;/a&gt;). The attribute has no effect when a definition for the function is not provided in the same translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba9bd3f254f0cc2bc69cd8b105c1d09efd2f77c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment for the variable or structure field, measured in bytes. When specified, &lt;var&gt;alignment&lt;/var&gt; must be an integer constant power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the maximum alignment for the target, which is often, but by no means always, 8 or 16 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46b2b0bb9e3e850ca63944ddf914702b4818ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_align&lt;/code&gt; attribute may be applied to a function that returns a pointer and takes at least one argument of an integer or enumerated type. It indicates that the returned pointer is aligned on a boundary given by the function argument at &lt;var&gt;position&lt;/var&gt;. Meaningful alignments are powers of 2 greater than one. GCC uses this information to improve pointer alignment analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8797cd128649602028c5dfdc7369a0575f411979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; attribute may be applied to a function that returns a pointer and takes at least one argument of an integer or enumerated type. It indicates that the returned pointer points to memory whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06aab07630994254a1a8fb1c75da104d280fc4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; type attribute may be applied to the definition of a type of a function that returns a pointer and takes at least one argument of an integer type. It indicates that the returned pointer points to an object whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. Other sizes are disagnosed when detected. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065a219ddaff6d679a0be49eb2bd7f719e312c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; variable attribute may be applied to the declaration of a pointer to a function that returns a pointer and takes at least one argument of an integer type. It indicates that the returned pointer points to an object whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. Other sizes are disagnosed when detected. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbdc1421fb579e3bcb9c9ed2bb5181ffe0b47ee4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; keyword allows you to embed assembler instructions within C code. GCC provides two forms of inline &lt;code&gt;asm&lt;/code&gt; statements. A &lt;em&gt;basic &lt;code&gt;asm&lt;/code&gt;&lt;/em&gt; statement is one with no operands (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;), while an &lt;em&gt;extended &lt;code&gt;asm&lt;/code&gt;&lt;/em&gt; statement (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;) includes one or more operands. The extended form is preferred for mixing C and assembly language within a function, but to include assembly language at top level you must use basic &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83f20d0e6ffe18a83c8f1ea64e1025e8b4e3b79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; keyword is a GNU extension. When writing code that can be compiled with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5154cd3afb55ec67fd254011d045e0b4c9d93a08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; statement allows you to include assembly instructions directly within C code. This may help you to maximize performance in time-sensitive code or to access assembly instructions that are not readily available to C programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889a71d5c542b05221a1fea4fb081bfa156749e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assume_aligned&lt;/code&gt; attribute may be applied to a function that returns a pointer. It indicates that the returned pointer is aligned on a boundary given by &lt;var&gt;alignment&lt;/var&gt;. If the attribute has two arguments, the second argument is misalignment &lt;var&gt;offset&lt;/var&gt;. Meaningful values of &lt;var&gt;alignment&lt;/var&gt; are powers of 2 greater than one. Meaningful values of &lt;var&gt;offset&lt;/var&gt; are greater than zero and less than &lt;var&gt;alignment&lt;/var&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7eb78f1e02d22076254e95ec303c8093068484f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aux&lt;/code&gt; attribute is used to directly access the ARC&amp;rsquo;s auxiliary register space from C. The auxilirary register number is given via attribute argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63bd6b23aa2da11430c3217df7f40955b5b703f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;b&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0166d882668eb629f4c81b26d5f43ba89f13484a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;c&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07fada73a7cf214a1328d2a6e8cd842b7cf5c1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cf_check&lt;/code&gt; attribute on a function is used to inform the compiler that ENDBR instruction should be placed at the function entry when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2675a5f39c8ca20fe391d93c61cca5056e32cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cleanup&lt;/code&gt; attribute runs a function when the variable goes out of scope. This attribute can only be applied to auto function scope variables; it may not be applied to parameters or variables with static storage duration. The function must take one parameter, a pointer to a type compatible with the variable. The return value of the function (if any) is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d44203c9f2ae9c43811502121d3c877febd137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute on functions is used to inform the compiler that the function is unlikely to be executed. The function is optimized for size rather than speed and on many targets it is placed into a special subsection of the text section so all cold functions appear close together, improving code locality of non-cold parts of program. The paths leading to calls of cold functions within code are marked as unlikely by the branch prediction mechanism. It is thus useful to mark functions used to handle unlikely conditions, such as &lt;code&gt;perror&lt;/code&gt;, as cold to improve optimization of hot functions that do call marked functions in rare occasions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baaebf592a1c26312204d234ba4d0961fa9cfdc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute on labels is used to inform the compiler that the path following the label is unlikely to be executed. This attribute is used in cases where &lt;code&gt;__builtin_expect&lt;/code&gt; cannot be used, for instance with computed goto or &lt;code&gt;asm goto&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84aae041fbfd493303c7dc6f97608b2aa0f0cfea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;common&lt;/code&gt; attribute requests GCC to place a variable in &amp;ldquo;common&amp;rdquo; storage. The &lt;code&gt;nocommon&lt;/code&gt; attribute requests the opposite&amp;mdash;to allocate space for it directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09440712407e39d94a0cdcf960e85948cfc3c350" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; attribute imposes greater restrictions on a function&amp;rsquo;s definition than the similar &lt;code&gt;pure&lt;/code&gt; attribute. Declaring the same function with both the &lt;code&gt;const&lt;/code&gt; and the &lt;code&gt;pure&lt;/code&gt; attribute is diagnosed. Because a const function cannot have any observable side effects it does not make sense for it to return &lt;code&gt;void&lt;/code&gt;. Declaring such a function is diagnosed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8d892c81dcdfdd626d5be4bd09dab512df4f9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; attribute prohibits a function from reading objects that affect its return value between successive invocations. However, functions declared with the attribute can safely read objects that do not change their return value, such as non-volatile constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99106b80230d2cf73a73b452a0a31c02c4de491f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;constructor&lt;/code&gt; attribute causes the function to be called automatically before execution enters &lt;code&gt;main ()&lt;/code&gt;. Similarly, the &lt;code&gt;destructor&lt;/code&gt; attribute causes the function to be called automatically after &lt;code&gt;main ()&lt;/code&gt; completes or &lt;code&gt;exit ()&lt;/code&gt; is called. Functions with these attributes are useful for initializing data that is used implicitly during the execution of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1214564b5cbc84df3e7da6094de27b7006df5a48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;function&lt;/var&gt; has been declared to the declaration of the function to which the attribute is applied. The attribute is designed for libraries that define aliases or function resolvers that are expected to specify the same set of attributes as their targets. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with functions, variables, or types. However, the kind of symbol to which the attribute is applied (either function or variable) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592273a5e05d6744ed0bd5dc37c91bbe97b23cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;variable&lt;/var&gt; has been declared to the declaration of the variable to which the attribute is applied. The attribute is designed for libraries that define aliases that are expected to specify the same set of attributes as the aliased symbols. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with variables, functions or types. However, the kind of symbol to which the attribute is applied (either varible or function) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a505e2a0a73ab045449836d4a18bec5c0bc8127e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which the type of the &lt;var&gt;expression&lt;/var&gt; has been declared to the declaration of the type to which the attribute is applied. The attribute is designed for libraries that define aliases that are expected to specify the same set of attributes as the aliased symbols. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with types, variables, or functions. However, the kind of symbol to which the attribute is applied (either varible or function) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a4a7841fe7fe34c4f48a65b187a7fb8df9b582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;d&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024895282c898bc3d4211d4724e2af4880224cde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for functions and types (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162fc2b6ed9e6c2908900a7eb89f4726020462d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for functions and variables (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cfdb164eda8f42cf6433c514a0ea224366c785" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for variables and types (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;, see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad1e87fce264d36291150600cb66c57e91c1432" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the enumerator is used anywhere in the source file. This is useful when identifying enumerators that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated enumerator, to enable users to easily find further information about why the enumerator is deprecated, or what they should do instead. Note that the warnings only occurs for uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e0cb154d9e21da1f2de2ead88f358575c22b29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the function is used anywhere in the source file. This is useful when identifying functions that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated function, to enable users to easily find further information about why the function is deprecated, or what they should do instead. Note that the warnings only occurs for uses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7280557c8bb44f2fb4dbaff815426552ad4804e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the type is used anywhere in the source file. This is useful when identifying types that are expected to be removed in a future version of a program. If possible, the warning also includes the location of the declaration of the deprecated type, to enable users to easily find further information about why the type is deprecated, or what they should do instead. Note that the warnings only occur for uses and then only if the type is being applied to an identifier that itself is not being declared as deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597712de9335903c130e7df57d7a0ba95b08639b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the variable is used anywhere in the source file. This is useful when identifying variables that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated variable, to enable users to easily find further information about why the variable is deprecated, or what they should do instead. Note that the warning only occurs for uses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344b31eee254fd7731082259002ff33f9b48b98f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;di&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1650914162ce3f6c59a952f96564a05c9635bff9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dllimport&lt;/code&gt; and &lt;code&gt;dllexport&lt;/code&gt; attributes are described in &lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;Microsoft Windows Function Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602269999e7f262d03410dcdc10e151a9ba7ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;either&lt;/code&gt; attribute is special. It tells the linker to place the object into the corresponding &lt;code&gt;lower&lt;/code&gt; section if there is room for it. If there is insufficient room then the object is placed into the corresponding &lt;code&gt;upper&lt;/code&gt; section instead. Note that the placement algorithm is not very sophisticated. It does not attempt to find an optimal packing of the &lt;code&gt;lower&lt;/code&gt; sections. It just makes one pass over the objects and does the best that it can. Using the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127ffb86a9524294853f3ef1fc5800cb8a1c3768" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fallthrough&lt;/code&gt; attribute with a null statement serves as a fallthrough statement. It hints to the compiler that a statement that falls through to another case label, or user-defined label in a switch statement is intentional and thus the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6830b1617bcd576d4ef6cff9b6f00ee4b5966d52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fixincludes&lt;/code&gt; script interacts badly with automounters; if the directory of system header files is automounted, it tends to be unmounted while &lt;code&gt;fixincludes&lt;/code&gt; is running. This would seem to be a bug in the automounter. We don&amp;rsquo;t know any good way to work around it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63425a2cbc7b99cbe7ca99c3dbf9d57e95519bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; attribute allows you to identify your own functions that take format strings as arguments, so that GCC can check the calls to these functions for errors. The compiler always (unless</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8186a0d48987dddde9af17dcccbd13ea17379b53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; attribute specifies that a function takes &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style arguments that should be type-checked against a format string. For example, the declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85cee214b83f923e35c9402c26181e376eaa3ea2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format_arg&lt;/code&gt; attribute allows you to identify your own functions that modify format strings, so that GCC can check the calls to &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; type function whose operands are a call to one of your own function. The compiler always treats &lt;code&gt;gettext&lt;/code&gt;, &lt;code&gt;dgettext&lt;/code&gt;, and &lt;code&gt;dcgettext&lt;/code&gt; in this manner except when strict ISO C support is requested by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3daa7d7140f7871d6b8af467ff44e71c895472e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format_arg&lt;/code&gt; attribute specifies that a function takes one or more format strings for a &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style function and modifies it (for example, to translate it into another language), so the result can be passed to a &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style function (with the remaining arguments to the format function the same as they would have been for the unmodified string). Multiple &lt;code&gt;format_arg&lt;/code&gt; attributes may be applied to the same function, each designating a distinct parameter as a format string. For example, the declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca4e3fc744cfd6bb4409a911b1eaa70a4a7b0f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gcc&lt;/code&gt; program accepts options and file names as operands. Many options have multi-letter names; therefore multiple single-letter options may &lt;em&gt;not&lt;/em&gt; be grouped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13501a1cf6115328de048bf9d04f10c4c82f956e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getenv&lt;/code&gt; spec function takes two arguments: an environment variable name and a string. If the environment variable is not defined, a fatal error is issued. Otherwise, the return value is the value of the environment variable concatenated with the string. For example, if &lt;code&gt;TOPDIR&lt;/code&gt; is defined as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e47220a0b9fe1eafb603003bb97378e81c55693" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hot&lt;/code&gt; attribute on a function is used to inform the compiler that the function is a hot spot of the compiled program. The function is optimized more aggressively and on many targets it is placed into a special subsection of the text section so all hot functions appear close together, improving locality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc71e7bb730a8ac55c634493d73dbda68f4ce5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hot&lt;/code&gt; attribute on a label is used to inform the compiler that the path following the label is more likely than paths that are not so annotated. This attribute is used in cases where &lt;code&gt;__builtin_expect&lt;/code&gt; cannot be used, for instance with computed goto or &lt;code&gt;asm goto&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61dd8421805c3f1f1761646164b13228bc83b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if-exists-else&lt;/code&gt; spec function is similar to the &lt;code&gt;if-exists&lt;/code&gt; spec function, except that it takes two arguments. The first argument is an absolute pathname to a file. If the file exists, &lt;code&gt;if-exists-else&lt;/code&gt; returns the pathname. If it does not exist, it returns the second argument. This way, &lt;code&gt;if-exists-else&lt;/code&gt; can be used to select one file or another, based on the existence of the first. Here is a small example of its usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2fcf31ed2dc4dabd85a0634ae9ce4991a720f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if-exists&lt;/code&gt; spec function takes one argument, an absolute pathname to a file. If the file exists, &lt;code&gt;if-exists&lt;/code&gt; returns the pathname. Here is a small example of its usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f39b443650f9aa0609294fd86fb2e3c92efa3ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ifunc&lt;/code&gt; attribute is used to mark a function as an indirect function using the STT_GNU_IFUNC symbol type extension to the ELF standard. This allows the resolution of the symbol value to be determined dynamically at load time, and an optimized version of the routine to be selected for the particular processor or other system characteristics determined then. To use this attribute, first define the implementation functions available, and a resolver function that returns a pointer to the selected implementation function. The implementation functions&amp;rsquo; declarations must match the API of the function being implemented. The resolver should be declared to be a function taking no arguments and returning a pointer to a function of the same type as the implementation. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93b19f3af6a498a18dbae7f15fda07496789c8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indirect_return&lt;/code&gt; attribute can be applied to a function, as well as variable or type of function pointer to inform the compiler that the function may return via indirect branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d323a0cf85010c427cc0692ec1f74e288bfb70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; type specifies the &lt;em&gt;base type&lt;/em&gt;, while the attribute specifies the vector size for the variable, measured in bytes. For example, the declaration above causes the compiler to set the mode for the &lt;code&gt;v4si&lt;/code&gt; type to be 16 bytes wide and divided into &lt;code&gt;int&lt;/code&gt; sized units. For a 32-bit &lt;code&gt;int&lt;/code&gt; this means a vector of 4 units of 4 bytes, and the corresponding mode of &lt;code&gt;foo&lt;/code&gt; is V4SI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad85eea7d52841e376253f17a96317ee40b42d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; register. Use this register to store values that are no bigger than a word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59f696ee7163d6ae5bf39bf73c4a8eee9fb142c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;longcall&lt;/code&gt; attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The &lt;code&gt;shortcall&lt;/code&gt; attribute indicates that the function is always close enough for the shorter calling sequence to be used. These attributes override both the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcca42c392befdcaa88d2e6501ea9388ada93b12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;longcall&lt;/code&gt; attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The &lt;code&gt;shortcall&lt;/code&gt; attribute indicates that the function is always close enough for the shorter calling sequence to be used. These attributes override the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc876d3a5eef5293c3403c1a8361253a45afc935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;movf&lt;/code&gt; functions are similar but use &lt;code&gt;movf.ps&lt;/code&gt; instead of &lt;code&gt;movt.ps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7edfc9a06b3d4812f5bd4584647b1d884b0e5206" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;movt&lt;/code&gt; functions return the value &lt;var&gt;x&lt;/var&gt; computed by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2610b35bdca1d94154ca3ae8683caf9dc99891a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mutationsPtr&lt;/code&gt; field of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; is used to keep track of mutations. It should point to a number; before working on each object, the fast enumeration loop will check that this number has not changed. If it has, a mutation has happened and the fast enumeration will abort. So, &lt;code&gt;mutationsPtr&lt;/code&gt; could be set to point to some sort of version number of your collection, which is increased by one every time there is a change (for example when an object is added or removed). Or, if you are content with less strict mutation checks, it could point to the number of objects in your collection or some other value that can be checked to perform an approximate check that the collection has not been mutated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba0a2fef84c6754af39561a4cc5765385e357d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_profile_instrument_function&lt;/code&gt; attribute on functions is used to inform the compiler that it should not process any profile feedback based optimization code instrumentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0918428dc764c04c359b85f748a679bc412726a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize&lt;/code&gt; attribute on functions is used to inform the compiler that it should not do sanitization of all options mentioned in &lt;var&gt;sanitize_option&lt;/var&gt;. A list of values acceptable by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598d3a3720c7288dc59d302cd06d4d62ac827b23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_address&lt;/code&gt; attribute on functions is used to inform the compiler that it should not instrument memory accesses in the function when compiling with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f00909d80fd99a1bd86005010002c8eae19649" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_thread&lt;/code&gt; attribute on functions is used to inform the compiler that it should not instrument memory accesses in the function when compiling with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a12b0e3b686d055271b195be15ed20337782164" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_undefined&lt;/code&gt; attribute on functions is used to inform the compiler that it should not check for undefined behavior in the function when compiling with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8d4f077478dc90f16e53c6d13ee06401059297" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute is applied to an object&amp;rsquo;s type. In case of assignment of a function address or a function pointer to another pointer, the attribute is not carried over from the right-hand object&amp;rsquo;s type; the type of left-hand object stays unchanged. The compiler checks for &lt;code&gt;nocf_check&lt;/code&gt; attribute mismatch and reports a warning in case of mismatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037064bc2bccfb10212ace859111994bc55ff79f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute on a function is used to inform the compiler that the function&amp;rsquo;s prologue should not be instrumented when compiled with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59968503e9385085cb3eaa290a16cdafff616101" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute on a type of pointer to function is used to inform the compiler that a call through the pointer should not be instrumented when compiled with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814b4e15c6c880738e37bebfa650ba3630bcdb26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonnull&lt;/code&gt; attribute may be applied to a function that takes at least one argument of a pointer type. It indicates that the referenced arguments must be non-null pointers. For instance, the declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390c2fb36f2ab88e24c7fbba27c3b067ccacf7b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonstring&lt;/code&gt; variable attribute specifies that an object or member declaration with type array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, or &lt;code&gt;unsigned char&lt;/code&gt;, or pointer to such a type is intended to store character arrays that do not necessarily contain a terminating &lt;code&gt;NUL&lt;/code&gt;. This is useful in detecting uses of such arrays or pointers with functions that expect &lt;code&gt;NUL&lt;/code&gt;-terminated strings, and to avoid warnings when such an array or pointer is used as an argument to a bounded string manipulation function such as &lt;code&gt;strncpy&lt;/code&gt;. For example, without the attribute, GCC will issue a warning for the &lt;code&gt;strncpy&lt;/code&gt; call below because it may truncate the copy without appending the terminating &lt;code&gt;NUL&lt;/code&gt; character. Using the attribute makes it possible to suppress the warning. However, when the array is declared with the attribute the call to &lt;code&gt;strlen&lt;/code&gt; is diagnosed because when the array doesn&amp;rsquo;t contain a &lt;code&gt;NUL&lt;/code&gt;-terminated string the call is undefined. To copy, compare, of search non-string character arrays use the &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, and other functions that operate on arrays of bytes. In addition, calling &lt;code&gt;strnlen&lt;/code&gt; and &lt;code&gt;strndup&lt;/code&gt; with such arrays is safe provided a suitable bound is specified, and not diagnosed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfce49165a44d874594bfffebd1dbb2dbd0c7094" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noplt&lt;/code&gt; attribute is the counterpart to option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0300bf5cb9eee09bcd3c5b59946b4122f915396c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noplt&lt;/code&gt; attribute on function &lt;code&gt;foo&lt;/code&gt; tells the compiler to assume that the function &lt;code&gt;foo&lt;/code&gt; is externally defined and that the call to &lt;code&gt;foo&lt;/code&gt; must avoid the PLT in position-independent code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2a9d3dba3dc91ebe5e03bbafab67f8838787f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; keyword does not affect the exceptional path when that applies: a &lt;code&gt;noreturn&lt;/code&gt;-marked function may still return to the caller by throwing an exception or calling &lt;code&gt;longjmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ede64b6031c14f35d5f8cb3935b7f6f8ada1843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; keyword tells the compiler to assume that &lt;code&gt;fatal&lt;/code&gt; cannot return. It can then optimize without regard to what would happen if &lt;code&gt;fatal&lt;/code&gt; ever did return. This makes slightly better code. More importantly, it helps avoid spurious warnings of uninitialized variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322a4c52099d05e4a78d3c92d5bcf0059fa4fd77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nothrow&lt;/code&gt; attribute is used to inform the compiler that a function cannot throw an exception. For example, most functions in the standard C library can be guaranteed not to throw an exception with the notable exceptions of &lt;code&gt;qsort&lt;/code&gt; and &lt;code&gt;bsearch&lt;/code&gt; that take function pointer arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207d7791a2ec8b451439c9235cbe7bcf5c27be6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optimize&lt;/code&gt; attribute is used to specify that a function is to be compiled with different optimization options than specified on the command line. Valid arguments are constant non-negative integers and strings. Each numeric argument specifies an optimization &lt;var&gt;level&lt;/var&gt;. Each &lt;var&gt;string&lt;/var&gt; argument consists of one or more comma-separated substrings. Each substring that begins with the letter &lt;code&gt;O&lt;/code&gt; refers to an optimization option such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826d9e0c3c8b85ab7196ae31fb079d73a80bdae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; attribute specifies that a structure member should have the smallest possible alignment&amp;mdash;one bit for a bit-field and one byte otherwise, unless a larger value is specified with the &lt;code&gt;aligned&lt;/code&gt; attribute. The attribute does not apply to non-member objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39beb9f00633eee839c4a2a5158a15d6e464e28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pass-through-libs&lt;/code&gt; spec function takes any number of arguments. It finds any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c9a7db255ec3b8e7cca6652c90ae20f65b9a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;patchable_function_entry&lt;/code&gt; function attribute can be used to change the number of NOPs to any desired value. The two-value syntax is the same as for the command-line switch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e838ae744489fc704636367520fe3b637d47e7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcs&lt;/code&gt; attribute can be used to control the calling convention used for a function on ARM. The attribute takes an argument that specifies the calling convention to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf4d6b72a577c7b95004980e1bce0048594d8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print-asm-header&lt;/code&gt; function takes no arguments and simply prints a banner like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4fc17c6269a43f696bb9bef92ec98733094225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pure&lt;/code&gt; attribute imposes similar but looser restrictions on a function&amp;rsquo;s definition than the &lt;code&gt;const&lt;/code&gt; attribute: &lt;code&gt;pure&lt;/code&gt; allows the function to read any non-volatile memory, even if it changes in between successive invocations of the function. Declaring the same function with both the &lt;code&gt;pure&lt;/code&gt; and the &lt;code&gt;const&lt;/code&gt; attribute is diagnosed. Because a pure function cannot have any observable side effects it does not make sense for such a function to return &lt;code&gt;void&lt;/code&gt;. Declaring such a function is diagnosed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323eb04f8039811b3bb58c82bccb097f2a6f7bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pure&lt;/code&gt; attribute prohibits a function from modifying the state of the program that is observable by means other than inspecting the function&amp;rsquo;s return value. However, functions declared with the &lt;code&gt;pure&lt;/code&gt; attribute can safely read any non-volatile objects, and modify the value of objects in a way that does not affect their return value or the observable state of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1720331b79d485f642342587a0a4961224f570c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; specifier affects code generation only in these ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5258162416b278a0bfac9c4c7558d341c9154f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove-outfile&lt;/code&gt; spec function takes one argument. It looks for the first argument in the outfiles array and removes it. Here is a small example its usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55bb4e8d3fe19956428bf774ea204bd862418b82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replace-outfile&lt;/code&gt; spec function takes two arguments. It looks for the first argument in the outfiles array and replaces it with the second argument. Here is a small example of its usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9408f2030b23dd54137985158e8c003e073220be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;returns_nonnull&lt;/code&gt; attribute specifies that the function return value should be a non-null pointer. For instance, the declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e04bc9de35eb5e502accce1b00b75bbadd857dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;returns_twice&lt;/code&gt; attribute tells the compiler that a function may return more than one time. The compiler ensures that all registers are dead before calling such a function and emits a warning about the variables that may be clobbered after the second return from the function. Examples of such functions are &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;vfork&lt;/code&gt;. The &lt;code&gt;longjmp&lt;/code&gt;-like counterpart of such function, if any, might need to be marked with the &lt;code&gt;noreturn&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d109540c91de909173d68023125715d31c5696c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rtd&lt;/code&gt; instruction is supported by the 68010, 68020, 68030, 68040, 68060 and CPU32 processors, but not by the 68000 or 5200.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a97b87fbba98b99c49488ce8d99f3965e9820d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_cmp_exp_gt&lt;/code&gt;, &lt;code&gt;scalar_cmp_exp_lt&lt;/code&gt;, &lt;code&gt;scalar_cmp_exp_eq&lt;/code&gt;, and &lt;code&gt;scalar_cmp_exp_unordered&lt;/code&gt; built-in functions return a non-zero value if &lt;code&gt;arg1&lt;/code&gt; is greater than, less than, equal to, or not comparable to &lt;code&gt;arg2&lt;/code&gt; respectively. The arguments are not comparable if one or the other equals NaN (not a number).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed56e8dd6f8e41dde6e37a24332591f1ce27f7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; built-in functions return the significand and the biased exponent value respectively of their &lt;code&gt;source&lt;/code&gt; arguments. When supplied with a 64-bit &lt;code&gt;source&lt;/code&gt; argument, the result returned by &lt;code&gt;scalar_extract_sig&lt;/code&gt; has the &lt;code&gt;0x0010000000000000&lt;/code&gt; bit set if the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is in normalized form. Otherwise, this bit is set to 0. When supplied with a 128-bit &lt;code&gt;source&lt;/code&gt; argument, the &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; bit of the result is treated similarly. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;scalar_extract_sig&lt;/code&gt; function. Use the &lt;code&gt;scalar_test_neg&lt;/code&gt; function to test the sign of its &lt;code&gt;double&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a572c2c2b0d3df765ec4322dbf92c35c2e4cbc19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_insert_exp&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. When supplied with a 64-bit first argument, the &lt;code&gt;scalar_insert_exp&lt;/code&gt; built-in function returns a double-precision floating point value that is constructed by assembling the values of its &lt;code&gt;significand&lt;/code&gt; and &lt;code&gt;exponent&lt;/code&gt; arguments. The sign of the result is copied from the most significant bit of the &lt;code&gt;significand&lt;/code&gt; argument. The significand and exponent components of the result are composed of the least significant 11 bits of the &lt;code&gt;exponent&lt;/code&gt; argument and the least significant 52 bits of the &lt;code&gt;significand&lt;/code&gt; argument respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e5f673754badb55457e9f6e18bad2fb7c8867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_test_data_class&lt;/code&gt; built-in function returns 1 if any of the condition tests enabled by the value of the &lt;code&gt;condition&lt;/code&gt; variable are true, and 0 otherwise. The &lt;code&gt;condition&lt;/code&gt; argument must be a compile-time constant integer with value not exceeding 127. The &lt;code&gt;condition&lt;/code&gt; argument is encoded as a bitmask with each bit enabling the testing of a different condition, as characterized by the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8baf3f4610726735a8a214eff212593a1cbf0b19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_test_neg&lt;/code&gt; built-in function returns 1 if its &lt;code&gt;source&lt;/code&gt; argument holds a negative value, 0 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312b5b4b73e9b711ee72f43d70d664005613348e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selectany&lt;/code&gt; attribute causes an initialized global variable to have link-once semantics. When multiple definitions of the variable are encountered by the linker, the first is selected and the remainder are discarded. Following usage by the Microsoft compiler, the linker is told &lt;em&gt;not&lt;/em&gt; to warn about size or content differences of the multiple definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bbd5708df7b8ad51e26c82827c5a8837087e1d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selectany&lt;/code&gt; attribute is only available on Microsoft Windows targets. You can use &lt;code&gt;__declspec (selectany)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((selectany))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14873a7d123565ace388d75f6ab559389f994c52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared&lt;/code&gt; attribute is only available on Microsoft Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9085a2da6609ed3bc0fa42e0bccb84c58724a810" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;si&lt;/code&gt; register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2831e5752e0e20c3cf70a499fe35cbe998dc8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;extra&lt;/code&gt; fields of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; structure allows your collection object to keep track of the state of the enumeration. In a simple array implementation, &lt;code&gt;state&lt;/code&gt; may keep track of the index of the last object that was returned, and &lt;code&gt;extra&lt;/code&gt; may be unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c61038602bd0b5479d4058a6d4baafd6a0c2107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct __htm_tdb&lt;/code&gt; defined in &lt;code&gt;htmintrin.h&lt;/code&gt; describes the structure of the transaction diagnostic block as specified in the Principles of Operation manual chapter 5-91.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1669605966a6a01f0ff15b0d1cc0c388abd2971a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; attribute can be used for instance to have a function compiled with a different ISA (instruction set architecture) than the default. &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c500ff15f72b79070a64c0e0436e7dcdc9aaf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_clones&lt;/code&gt; attribute is used to specify that a function be cloned into multiple versions compiled with different target options than specified on the command line. The supported options and restrictions are the same as for &lt;code&gt;target&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf91998c7f416dcbd90db0b120c7a4f8d3b089f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tls_model&lt;/code&gt; attribute sets thread-local storage model (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;) of a particular &lt;code&gt;__thread&lt;/code&gt; variable, overriding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f43feeb5f6870d9594f888564bad52895276f45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_absd&lt;/code&gt;, &lt;code&gt;vec_absdb&lt;/code&gt;, &lt;code&gt;vec_absdh&lt;/code&gt;, and &lt;code&gt;vec_absdw&lt;/code&gt; built-in functions each computes the absolute differences of the pairs of vector elements supplied in its two vector arguments, placing the absolute differences into the corresponding elements of the vector result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc17321076f6146e9d0eff176ccfd2642bdf04e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_all_nez&lt;/code&gt;, &lt;code&gt;vec_any_eqz&lt;/code&gt;, and &lt;code&gt;vec_cmpnez&lt;/code&gt; perform pairwise comparisons between the elements at the same positions within their two vector arguments. The &lt;code&gt;vec_all_nez&lt;/code&gt; function returns a non-zero value if and only if all pairwise comparisons are not equal and no element of either vector argument contains a zero. The &lt;code&gt;vec_any_eqz&lt;/code&gt; function returns a non-zero value if and only if at least one pairwise comparison is equal or if at least one element of either vector argument contains a zero. The &lt;code&gt;vec_cmpnez&lt;/code&gt; function returns a vector of the same type as its two arguments, within which each element consists of all ones to denote that either the corresponding elements of the incoming arguments are not equal or that at least one of the corresponding elements contains zero. Otherwise, the element of the returned vector contains all zeros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ea2035fded0002d7bb2f5901563d260d2323cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_cntlz_lsbb&lt;/code&gt; function returns the count of the number of consecutive leading byte elements (starting from position 0 within the supplied vector argument) for which the least-significant bit equals zero. The &lt;code&gt;vec_cnttz_lsbb&lt;/code&gt; function returns the count of the number of consecutive trailing byte elements (starting from position 15 and counting backwards within the supplied vector argument) for which the least-significant bit equals zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b02bbdd65d95e68fbfa45f0222f7cae6e029b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_extract_sig&lt;/code&gt; and &lt;code&gt;vec_extract_exp&lt;/code&gt; built-in functions return vectors representing the significands and biased exponent values of their &lt;code&gt;source&lt;/code&gt; arguments respectively. Within the result vector returned by &lt;code&gt;vec_extract_sig&lt;/code&gt;, the &lt;code&gt;0x800000&lt;/code&gt; bit of each vector element returned when the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is of type &lt;code&gt;float&lt;/code&gt; is set to 1 if the corresponding floating point value is in normalized form. Otherwise, this bit is set to 0. When the &lt;code&gt;source&lt;/code&gt; argument is of type &lt;code&gt;double&lt;/code&gt;, the &lt;code&gt;0x10000000000000&lt;/code&gt; bit within each of the result vector&amp;rsquo;s elements is set according to the same rules. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;vec_extract_sig&lt;/code&gt; function. To extract the sign bits, use the &lt;code&gt;vec_cpsgn&lt;/code&gt; function, which returns a new vector within which all of the sign bits of its second argument vector are overwritten with the sign bits copied from the coresponding elements of its first argument vector, and all other (non-sign) bits of the second argument vector are copied unchanged into the result vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a829a08652f6801fcbd433b37bbf07c5d838fb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_insert_exp&lt;/code&gt; built-in functions return a vector of single- or double-precision floating point values constructed by assembling the values of their &lt;code&gt;significands&lt;/code&gt; and &lt;code&gt;exponents&lt;/code&gt; arguments into the corresponding elements of the returned vector. The sign of each element of the result is copied from the most significant bit of the corresponding entry within the &lt;code&gt;significands&lt;/code&gt; argument. Note that the relevant bits of the &lt;code&gt;significands&lt;/code&gt; argument are the same, for both integer and floating point types. The significand and exponent components of each element of the result are composed of the least significant bits of the corresponding &lt;code&gt;significands&lt;/code&gt; element and the least significant bits of the corresponding &lt;code&gt;exponents&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a91af05019f6d272dc741d0e069fe70406b3512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_revb&lt;/code&gt; built-in function reverses the bytes on an element by element basis. A vector of &lt;code&gt;vector unsigned char&lt;/code&gt; or &lt;code&gt;vector signed char&lt;/code&gt; reverses the bytes in the whole word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de89009a6ac207492ea21a351e324b964d19bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_rsqrt&lt;/code&gt;, &lt;code&gt;__builtin_rsqrt&lt;/code&gt;, and &lt;code&gt;__builtin_rsqrtf&lt;/code&gt; functions generate multiple instructions to implement the reciprocal sqrt functionality using reciprocal sqrt estimate instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246e48e9c9edd5f446bb04be8d23c0491da1918c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_slv&lt;/code&gt; and &lt;code&gt;vec_srv&lt;/code&gt; functions operate on all of the bytes of their &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;shift_distance&lt;/code&gt; arguments in parallel. The behavior of the &lt;code&gt;vec_slv&lt;/code&gt; is as if there existed a temporary array of 17 unsigned characters &lt;code&gt;slv_array&lt;/code&gt; within which elements 0 through 15 are the same as the entries in the &lt;code&gt;src&lt;/code&gt; array and element 16 equals 0. The result returned from the &lt;code&gt;vec_slv&lt;/code&gt; function is a &lt;code&gt;__vector&lt;/code&gt; of 16 unsigned characters within which element &lt;code&gt;i&lt;/code&gt; is computed using the C expression &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(slv_array + i)) &amp;lt;&amp;lt; (0x07 &amp;amp;
shift_distance[i]))&lt;/code&gt;, with this resulting value coerced to the &lt;code&gt;unsigned char&lt;/code&gt; type. The behavior of the &lt;code&gt;vec_srv&lt;/code&gt; is as if there existed a temporary array of 17 unsigned characters &lt;code&gt;srv_array&lt;/code&gt; within which element 0 equals zero and elements 1 through 16 equal the elements 0 through 15 of the &lt;code&gt;src&lt;/code&gt; array. The result returned from the &lt;code&gt;vec_srv&lt;/code&gt; function is a &lt;code&gt;__vector&lt;/code&gt; of 16 unsigned characters within which element &lt;code&gt;i&lt;/code&gt; is computed using the C expression &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(srv_array + i)) &amp;gt;&amp;gt;
(0x07 &amp;amp; shift_distance[i]))&lt;/code&gt;, with this resulting value coerced to the &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1b591d1d5bc9da82b7b03dcf8d2e3d88da8bb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_test_data_class&lt;/code&gt; built-in function returns a vector representing the results of testing the &lt;code&gt;source&lt;/code&gt; vector for the condition selected by the &lt;code&gt;condition&lt;/code&gt; argument. The &lt;code&gt;condition&lt;/code&gt; argument must be a compile-time constant integer with value not exceeding 127. The &lt;code&gt;condition&lt;/code&gt; argument is encoded as a bitmask with each bit enabling the testing of a different condition, as characterized by the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991ae395a453d861dfb8c7b24fc2cbc3ce4b3da0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_xl_len&lt;/code&gt; and &lt;code&gt;vec_xst_len&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;vec_xl_len&lt;/code&gt; function loads a variable length vector from memory. The &lt;code&gt;vec_xst_len&lt;/code&gt; function stores a variable length vector to memory. With both the &lt;code&gt;vec_xl_len&lt;/code&gt; and &lt;code&gt;vec_xst_len&lt;/code&gt; functions, the &lt;code&gt;addr&lt;/code&gt; argument represents the memory address to or from which data will be transferred, and the &lt;code&gt;len&lt;/code&gt; argument represents the number of bytes to be transferred, as computed by the C expression &lt;code&gt;min((len &amp;amp; 0xff), 16)&lt;/code&gt;. If this expression&amp;rsquo;s value is not a multiple of the vector element&amp;rsquo;s size, the behavior of this function is undefined. In the case that the underlying computer is configured to run in big-endian mode, the data transfer moves bytes 0 to &lt;code&gt;(len - 1)&lt;/code&gt; of the corresponding vector. In little-endian mode, the data transfer moves bytes &lt;code&gt;(16 - len)&lt;/code&gt; to &lt;code&gt;15&lt;/code&gt; of the corresponding vector. For the load function, any bytes of the result vector that are not loaded from memory are set to zero. The value of the &lt;code&gt;addr&lt;/code&gt; argument need not be aligned on a multiple of the vector&amp;rsquo;s element size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f436c7a33759092d0385b9b27659581036ece3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_xlx&lt;/code&gt; and &lt;code&gt;vec_xrx&lt;/code&gt; functions extract the single element selected by the &lt;code&gt;index&lt;/code&gt; argument from the vector represented by the &lt;code&gt;data&lt;/code&gt; argument. The &lt;code&gt;index&lt;/code&gt; argument always specifies a byte offset, regardless of the size of the vector element. With &lt;code&gt;vec_xlx&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; is the offset of the first byte of the element to be extracted. With &lt;code&gt;vec_xrx&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; represents the last byte of the element to be extracted, measured from the right end of the vector. In other words, the last byte of the element to be extracted is found at position &lt;code&gt;(15 - index)&lt;/code&gt;. There is no requirement that &lt;code&gt;index&lt;/code&gt; be a multiple of the vector element size. However, if the size of the vector element added to &lt;code&gt;index&lt;/code&gt; is greater than 15, the content of the returned value is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebaac2fb10fbefef121de501464e717714b8367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vector_size&lt;/code&gt; attribute is only applicable to integral and floating scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct. Only sizes that are positive power-of-two multiples of the base type size are currently allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837b5049d27cb5d3caabb0997e45a1cbb234446d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vliw&lt;/code&gt; attribute tells the compiler to emit instructions in VLIW mode instead of core mode. Note that this attribute is not allowed unless a VLIW coprocessor has been configured and enabled through command-line options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d2812dccb310da3b37a59c6a8e7a142b29dac3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warn_unused_result&lt;/code&gt; attribute causes a warning to be emitted if a caller of the function with this attribute does not use its return value. This is useful for functions where not checking the result is either a security problem or always a bug, such as &lt;code&gt;realloc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d64e3cfe5255e69eafb7d485c8c088e61fa4d8a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute causes the declaration to be emitted as a weak symbol rather than a global. This is primarily useful in defining library functions that can be overridden in user code, though it can also be used with non-function declarations. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4250f8084c2d37890c56691349397dd644e93eba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute is described in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362aefd1f311374abf7ac9d8d10e9633ea762db5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weakref&lt;/code&gt; attribute marks a declaration as a weak reference. Without arguments, it should be accompanied by an &lt;code&gt;alias&lt;/code&gt; attribute naming the target symbol. Optionally, the &lt;var&gt;target&lt;/var&gt; may be given as an argument to &lt;code&gt;weakref&lt;/code&gt; itself. In either case, &lt;code&gt;weakref&lt;/code&gt; implicitly marks the declaration as &lt;code&gt;weak&lt;/code&gt;. Without a &lt;var&gt;target&lt;/var&gt;, given as an argument to &lt;code&gt;weakref&lt;/code&gt; or to &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;weakref&lt;/code&gt; is equivalent to &lt;code&gt;weak&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5580c84e305bbd75698ac25971a0df43ef6cc5f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;call_exp&lt;/var&gt; expression must be a function call, and the &lt;var&gt;pointer_exp&lt;/var&gt; expression must be a pointer. The &lt;var&gt;pointer_exp&lt;/var&gt; is passed to the function call in the target&amp;rsquo;s static chain location. The result of builtin is the result of the function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47808f5c44d74211446dd3107371068aa638bc2f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;information&lt;/var&gt; is human readable, but designed to be simple enough for machine parsing too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e82b6b86f048807c7ae6131df8cf24c8fb6345a" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; argument must be a constant integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2457707eff68e08cd199be4e3c699bc3aefc86a0" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; argument should be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07133152e9a0d85287182cf9221be477141dff40" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;oldname&lt;/var&gt; used by &lt;code&gt;#pragma redefine_extname&lt;/code&gt; is always the C-language name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9388ad5137ed5dfa5588bcfa11755abc3ce7181" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;options&lt;/var&gt; can be divided into three groups:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c19aabaea762edf72b5cc0612746c317d8ff2de8" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;os&lt;/var&gt; argument is the object size &lt;var&gt;s&lt;/var&gt; points to, like in the other built-in functions. There is a small difference in the behavior though, if &lt;var&gt;os&lt;/var&gt; is &lt;code&gt;(size_t) -1&lt;/code&gt;, the built-in functions are optimized into the non-checking functions only if &lt;var&gt;flag&lt;/var&gt; is 0, otherwise the checking function is called with &lt;var&gt;os&lt;/var&gt; argument set to &lt;code&gt;(size_t) -1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99051c6bb8529049d31b5150a695460a96f0eb50" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;string&lt;/var&gt; can either be a number (decimal, octal or hex) or an arbitrary string (in which case it&amp;rsquo;s converted to a number by computing CRC32).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a9a665b951d617734d12093bb7933ae309b7f0" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;string&lt;/var&gt; should be different for every file you compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5cf6b74b693d7f4748254b48ea16e3b5621f730" translate="yes" xml:space="preserve">
          <source>The ABI tags apply to a name, so all instantiations and specializations of a template have the same tags. The attribute will be ignored if applied to an explicit specialization or instantiation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e578589905c0491635616be2b8a8085308fc15" translate="yes" xml:space="preserve">
          <source>The AIX calling convention was extended but not initially documented to handle an obscure K&amp;amp;R C case of calling a function that takes the address of its arguments with fewer arguments than declared. IBM XL compilers access floating-point arguments that do not fit in the RSA from the stack when a subroutine is compiled without optimization. Because always storing floating-point arguments on the stack is inefficient and rarely needed, this option is not enabled by default and only is necessary when calling subroutines compiled by IBM XL compilers without optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0286e5ab4aaa67941386b2ad2370f9a09da6cea5" translate="yes" xml:space="preserve">
          <source>The ARM attribute &lt;code&gt;Tag_CPU_unaligned_access&lt;/code&gt; is set in the generated object file to either true or false, depending upon the setting of this option. If unaligned access is enabled then the preprocessor symbol &lt;code&gt;__ARM_FEATURE_UNALIGNED&lt;/code&gt; is also defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b655dda41c627fb0c53750526171175cc9f72b" translate="yes" xml:space="preserve">
          <source>The ARM target defines pragmas for controlling the default addition of &lt;code&gt;long_call&lt;/code&gt; and &lt;code&gt;short_call&lt;/code&gt; attributes to functions. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for information about the effects of these attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180b9a433ddcfbb50e74358632373510b9ae0866" translate="yes" xml:space="preserve">
          <source>The ARM target provides hardware support for conversions between &lt;code&gt;__fp16&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; values as an extension to VFP and NEON (Advanced SIMD), and from ARMv8-A provides hardware support for conversions between &lt;code&gt;__fp16&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; values. GCC generates code using these hardware instructions if you compile with options to select an FPU that provides them; for example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74677651175ff4a21af34df2adc4b16af0c62864" translate="yes" xml:space="preserve">
          <source>The ARM-state integer division instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25504eb2b5db6b1309f7e3ea71e7847bbe69ef9e" translate="yes" xml:space="preserve">
          <source>The ARMv8-A Advanced SIMD and floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8a18de7f60ebb2b7344b3e4891cc4342f1a12d" translate="yes" xml:space="preserve">
          <source>The ARMv8.1-A Advanced SIMD and floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33734522bf6eef68d24bf96c977fe3c147340232" translate="yes" xml:space="preserve">
          <source>The ARMv8.3-A Advanced SIMD and floating-point instructions as well as the Dot Product extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1c8ef545821a2ae5bcfc55a26fd3b81629816e" translate="yes" xml:space="preserve">
          <source>The AT&amp;amp;T C++ translator, Cfront, solved the template instantiation problem by creating the notion of a template repository, an automatically maintained place where template instances are stored. A more modern version of the repository works as follows: As individual object files are built, the compiler places any template definitions and instantiations encountered in the repository. At link time, the link wrapper adds in the objects in the repository and compiles any needed instances that were not previously emitted. The advantages of this model are more optimal compilation speed and the ability to use the system linker; to implement the Borland model a compiler vendor also needs to replace the linker. The disadvantages are vastly increased complexity, and thus potential for error; for some code this can be just as transparent, but in practice it can been very difficult to build multiple programs in one directory and one program in multiple directories. Code written for this model tends to separate definitions of non-inline member templates into a separate file, which should be compiled separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f96e374cb7c3be8b863693d2e8387693d91334" translate="yes" xml:space="preserve">
          <source>The AVR hardware globally disables interrupts when an interrupt is executed. Interrupt handler functions defined with the &lt;code&gt;signal&lt;/code&gt; attribute do not re-enable interrupts. It is save to enable interrupts in a &lt;code&gt;signal&lt;/code&gt; handler. This &amp;ldquo;save&amp;rdquo; only applies to the code generated by the compiler and not to the IRQ layout of the application which is responsibility of the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819e5dd1ebff38014ce3cc47fe71028f5e880298" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions, with the half-precision floating-point conversion operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a974f086b15b184d16af3fa03c2b5403d55b20" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1828fb03b38714492461b5c83b7a35d9811c07" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions. The extensions &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f15c2fd3a5e4f09bf2de0e8dd88934f187e30c" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v2 and the VFPv4 floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb627100c24fb77ea39c11992a8aa490fe9b6bf" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v2 and the VFPv4 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b4e865040163440dd355cb51993ec44628f3a4" translate="yes" xml:space="preserve">
          <source>The Alpha architecture implements floating-point hardware optimized for maximum performance. It is mostly compliant with the IEEE floating-point standard. However, for full compliance, software assistance is required. This option generates code fully IEEE-compliant code &lt;em&gt;except&lt;/em&gt; that the &lt;var&gt;inexact-flag&lt;/var&gt; is not maintained (see below). If this option is turned on, the preprocessor macro &lt;code&gt;_IEEE_FP&lt;/code&gt; is defined during compilation. The resulting code is less efficient but is able to correctly support denormalized numbers and exceptional IEEE values such as not-a-number and plus/minus infinity. Other Alpha compilers call this option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a224b29d0d210a4ad06df789e64da22f568f6054" translate="yes" xml:space="preserve">
          <source>The AltiVec built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.06 or later. These are normally enabled by adding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224e64a8094f6a857fb86e36e422aa4067f4740c" translate="yes" xml:space="preserve">
          <source>The C and C++ language specifications differ when an object is accessed in a void context:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef06715d23eab6e0953d0e3dffa82f688ece5af" translate="yes" xml:space="preserve">
          <source>The C and C++ standards define the order in which expressions in a C/C++ program are evaluated in terms of &lt;em&gt;sequence points&lt;/em&gt;, which represent a partial ordering between the execution of parts of the program: those executed before the sequence point, and those executed after it. These occur after the evaluation of a full expression (one which is not part of a larger expression), after the evaluation of the first operand of a &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;? :&lt;/code&gt; or &lt;code&gt;,&lt;/code&gt; (comma) operator, before a function is called (but after the evaluation of its arguments and the expression denoting the called function), and in certain other places. Other than as expressed by the sequence point rules, the order of evaluation of subexpressions of an expression is not specified. All these rules describe only a partial order rather than a total order, since, for example, if two functions are called within one expression with no sequence point between them, the order in which the functions are called is not specified. However, the standards committee have ruled that function calls do not overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef19b8344a45aab20d25a471f2eb0b887d44fb1e" translate="yes" xml:space="preserve">
          <source>The C++ ABI requires multiple entry points for constructors and destructors: one for a base subobject, one for a complete object, and one for a virtual destructor that calls operator delete afterwards. For a hierarchy with virtual bases, the base and complete variants are clones, which means two copies of the function. With this option, the base and complete variants are changed to be thunks that call a common implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88e1274e3c31338e664afbec99b09eac3f5a529" translate="yes" xml:space="preserve">
          <source>The C++ front end implements syntactic extensions that allow compile-time determination of various characteristics of a type (or of a pair of types).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec04375b745b1f1c4ce1f6fa5f903e079a94852c" translate="yes" xml:space="preserve">
          <source>The C++ language was further revised in 2017 and ISO/IEC 14882:2017 was published. This is referred to as C++17, and before publication was often referred to as C++1z. GCC supports all the changes in the new specification. For further details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&lt;/a&gt;. Use the option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcdb3a64fa68982d2e2c4cbdd5d9be1a69decab7" translate="yes" xml:space="preserve">
          <source>The C++ library used with a C++ compiler includes the Standard C++ Library, with functionality defined in the C++ Standard, plus language runtime support. The runtime support is included in a C++ ABI, but there is no formal ABI for the Standard C++ Library. Two implementations of that library are interoperable if one follows the de-facto ABI of the other and if they are both built with the same compiler, or with compilers that conform to the same ABI for C++ compiler and runtime support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b030a2dbb3c8b3c3ceafa77d7dbaf4d97c312843" translate="yes" xml:space="preserve">
          <source>The C++ standard allows an implementation to omit creating a temporary that is only used to initialize another object of the same type. Specifying this option disables that optimization, and forces G++ to call the copy constructor in all cases. This option also causes G++ to call trivial member functions which otherwise would be expanded inline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c549c47d787f5172f4a63d73dccb4d86a5de3eaa" translate="yes" xml:space="preserve">
          <source>The C++ standard differs from the C standard in its treatment of volatile objects. It fails to specify what constitutes a volatile access, except to say that C++ should behave in a similar manner to C with respect to volatiles, where possible. However, the different lvalueness of expressions between C and C++ complicate the behavior. G++ behaves the same as GCC for volatile access, See &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Volatiles&lt;/a&gt;, for a description of GCC&amp;rsquo;s behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949a50a0730c5f7ad89696edd9c2072338129167" translate="yes" xml:space="preserve">
          <source>The C++ standard just uses the term &amp;ldquo;dependent&amp;rdquo; for names that depend on the type or value of template parameters. This shorter term will also be used in the rest of this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7681d0e5c1533a0361ba254a5958bd845de12e17" translate="yes" xml:space="preserve">
          <source>The C++ standard prescribes that all names that are not dependent on template parameters are bound to their present definitions when parsing a template function or class.&lt;a href=&quot;#FOOT5&quot; id=&quot;DOCF5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; Only names that are dependent are looked up at the point of instantiation. For example, consider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253e6af722c0841d38d6e4f298c9a3cde3c002be" translate="yes" xml:space="preserve">
          <source>The C++ standard specifies that &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e51d56fadfe74149ae162a54ac1fe3c8b16dbb0" translate="yes" xml:space="preserve">
          <source>The C++ standard specifies that such expressions do not undergo lvalue to rvalue conversion, and that the type of the dereferenced object may be incomplete. The C++ standard does not specify explicitly that it is lvalue to rvalue conversion that is responsible for causing an access. There is reason to believe that it is, because otherwise certain simple expressions become undefined. However, because it would surprise most programmers, G++ treats dereferencing a pointer to volatile object of complete type as GCC would do for an equivalent type in C. When the object has incomplete type, G++ issues a warning; if you wish to force an error, you must force a conversion to rvalue with, for instance, a static cast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a31b9577ac049499e169205951815b4d802407" translate="yes" xml:space="preserve">
          <source>The C++11 and OpenMP standards allow &lt;code&gt;thread_local&lt;/code&gt; and &lt;code&gt;threadprivate&lt;/code&gt; variables to have dynamic (runtime) initialization. To support this, any use of such a variable goes through a wrapper function that performs any necessary initialization. When the use and definition of the variable are in the same translation unit, this overhead can be optimized away, but when the use is in a different translation unit there is significant overhead even if the variable doesn&amp;rsquo;t actually need dynamic initialization. If the programmer can be sure that no use of the variable in a non-defining TU needs to trigger dynamic initialization (either because the variable is statically initialized, or a use of the variable in the defining TU will be executed before any uses in another TU), they can avoid this overhead with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463aa5596934552e20b1c86daa9eff2befcfafd9" translate="yes" xml:space="preserve">
          <source>The C++17 standard will define the order of evaluation of operands in more cases: in particular it requires that the right-hand side of an assignment be evaluated before the left-hand side, so the above examples are no longer undefined. But this warning will still warn about them, to help people avoid writing code that is undefined in C and earlier revisions of C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f8518a5ffcdc724e580f436c8e8861c47a79dbf" translate="yes" xml:space="preserve">
          <source>The CC register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac83138ffc7dedbba141af64e9e3833a7581060" translate="yes" xml:space="preserve">
          <source>The Cyclic Redundancy Check (CRC) instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d3b88b25735a58406b058569b742cd7ef6e371" translate="yes" xml:space="preserve">
          <source>The DSP instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a394fdb5f659a018583a4b282fa046a537ed960" translate="yes" xml:space="preserve">
          <source>The Darwin tools vary in their behavior when presented with an ISA mismatch. The assembler,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c474ab61fc35bcc3be354a3a5837d9c0d40e8830" translate="yes" xml:space="preserve">
          <source>The GCC port for AArch64 only supports the IEEE 754-2008 format, and does not require use of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0079c12261c57d6bab6a15c723b1304a15531596" translate="yes" xml:space="preserve">
          <source>The GNU C compiler supports both dialects; you can specify the signed dialect with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9482fb99a743f48dbd7859a7e8e12b5401b580" translate="yes" xml:space="preserve">
          <source>The GNU C preprocessor recognizes several pragmas in addition to the compiler pragmas documented here. Refer to the CPP manual for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0227d0ba5f10912bdc54f8efb32ad7ab5a1942f8" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides a hook, called &lt;code&gt;__objc_msg_forward2&lt;/code&gt;, which is called by &lt;code&gt;objc_msg_lookup()&lt;/code&gt; when it cannot find a method implementation in the runtime tables and after calling &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; and &lt;code&gt;+resolveClassMethod:&lt;/code&gt; has been attempted and did not succeed in dynamically registering the method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32c2c0d5cf1c06ca2fc7f8fc5108f046c90f6d6" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides a way that allows you to execute code before the execution of the program enters the &lt;code&gt;main&lt;/code&gt; function. The code is executed on a per-class and a per-category basis, through a special class method &lt;code&gt;+load&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6204b4438d0b4bf08e65cf328298ab3f8520d1f5" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides an API that allows you to interact with the Objective-C runtime system, querying the live runtime structures and even manipulating them. This allows you for example to inspect and navigate classes, methods and protocols; to define new classes or new methods, and even to modify existing classes or protocols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4882007657bbd3b9904317ecd7c9122b201adae0" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides an API which is similar to the one provided by the &amp;ldquo;Objective-C 2.0&amp;rdquo; Apple/NeXT Objective-C runtime. The API is documented in the public header files of the GNU Objective-C runtime:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda523f70e2cc81aec3a5420312f2dc14631e90d" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime used to provide a different API, which we call the &amp;ldquo;traditional&amp;rdquo; GNU Objective-C runtime API. Functions belonging to this API are easy to recognize because they use a different naming convention, such as &lt;code&gt;class_get_super_class()&lt;/code&gt; (traditional API) instead of &lt;code&gt;class_getSuperclass()&lt;/code&gt; (modern API). Software using this API includes the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a580b32a37e3e1afb84412437056129293c1db6e" translate="yes" xml:space="preserve">
          <source>The GNU Project and GNU/Linux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf08e863571f4a8147fed0d98f89d3a6cc1c1c5" translate="yes" xml:space="preserve">
          <source>The GNU Project and GNU/Linux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565581be4558eda62440473a382dca36e2293950" translate="yes" xml:space="preserve">
          <source>The GNU compiler can produce two kinds of diagnostics: errors and warnings. Each kind has a different purpose:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef6aa50a29b9e95c494d3259dc5f4a2758d594d" translate="yes" xml:space="preserve">
          <source>The GNU compiler provides these extensions to the C++ language (and you can also use most of the C language extensions in your C++ programs). If you want to write code that checks whether these features are available, you can test for the GNU compiler the same way as for C programs: check for a predefined macro &lt;code&gt;__GNUC__&lt;/code&gt;. You can also use &lt;code&gt;__GNUG__&lt;/code&gt; to test specifically for GNU C++ (see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Predefined Macros&lt;/a&gt; in The GNU C Preprocessor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd4d4c02d395886b71e823798e0aedf04f540c0" translate="yes" xml:space="preserve">
          <source>The GNU linker (beginning with version 2.16) has the necessary support for this option. If your linker does not support this option, the header file aspect of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649e8f725ce325928e9d3758e5501f5eb08d8098" translate="yes" xml:space="preserve">
          <source>The HP-UX implementation of setlocale in libc has a dependency on libdld.sl. There isn&amp;rsquo;t an archive version of libdld.sl. Thus, when the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6712fd16e48687aa09a28dcd06ca5cfec22cf46" translate="yes" xml:space="preserve">
          <source>The HTM builtins (with the exception of &lt;code&gt;__builtin_tbegin&lt;/code&gt;) return the full 4-bit condition register value set by their associated hardware instruction. The header file &lt;code&gt;htmintrin.h&lt;/code&gt; defines some macros that can be used to decipher the return value. The &lt;code&gt;__builtin_tbegin&lt;/code&gt; builtin returns a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; value depending on whether a transaction was successfully started or not. The arguments of the builtins match exactly the type and order of the associated hardware instruction&amp;rsquo;s operands, except for the &lt;code&gt;__builtin_tcheck&lt;/code&gt; builtin, which does not take any input arguments. Refer to the ISA manual for a description of each instruction&amp;rsquo;s operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87dbb117c6f13df65961818e4b7b41562cf362b8" translate="yes" xml:space="preserve">
          <source>The IA-64 back end supports the following variable attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f39a7601ef937b791997651319caebaf1d1db8" translate="yes" xml:space="preserve">
          <source>The ISO C standard defines (in clause 4) two classes of conforming implementation. A &lt;em&gt;conforming hosted implementation&lt;/em&gt; supports the whole standard including all the library facilities; a &lt;em&gt;conforming freestanding implementation&lt;/em&gt; is only required to provide certain library facilities: those in &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;; since AMD1, also those in &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;; since C99, also those in &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;; and since C11, also those in &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;. In addition, complex types, added in C99, are not required for freestanding implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df8e4ece265376ae0055a7b2b932c764c91156b" translate="yes" xml:space="preserve">
          <source>The ISO C standard leaves it up to the implementation whether a bit-field declared plain &lt;code&gt;int&lt;/code&gt; is signed or not. This in effect creates two alternative dialects of C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bced80c01ede6829408bc604cd122f3ce07d3569" translate="yes" xml:space="preserve">
          <source>The ISO C++14 library also defines the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ca06952bac1aee629481893fc1242a0df75d20" translate="yes" xml:space="preserve">
          <source>The ISO C90 functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;fabs&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;fprintf&lt;/code&gt;, &lt;code&gt;fputs&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, &lt;code&gt;fscanf&lt;/code&gt;, &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, &lt;code&gt;isxdigit&lt;/code&gt;, &lt;code&gt;tolower&lt;/code&gt;, &lt;code&gt;toupper&lt;/code&gt;, &lt;code&gt;labs&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;putchar&lt;/code&gt;, &lt;code&gt;puts&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;sscanf&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt;, &lt;code&gt;strcmp&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;strcspn&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncmp&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strpbrk&lt;/code&gt;, &lt;code&gt;strrchr&lt;/code&gt;, &lt;code&gt;strspn&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;vfprintf&lt;/code&gt;, &lt;code&gt;vprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; are all recognized as built-in functions unless</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae47f0c159fa493b3beadffa3ea4146c32c1e50a" translate="yes" xml:space="preserve">
          <source>The ISO C94 functions &lt;code&gt;iswalnum&lt;/code&gt;, &lt;code&gt;iswalpha&lt;/code&gt;, &lt;code&gt;iswcntrl&lt;/code&gt;, &lt;code&gt;iswdigit&lt;/code&gt;, &lt;code&gt;iswgraph&lt;/code&gt;, &lt;code&gt;iswlower&lt;/code&gt;, &lt;code&gt;iswprint&lt;/code&gt;, &lt;code&gt;iswpunct&lt;/code&gt;, &lt;code&gt;iswspace&lt;/code&gt;, &lt;code&gt;iswupper&lt;/code&gt;, &lt;code&gt;iswxdigit&lt;/code&gt;, &lt;code&gt;towlower&lt;/code&gt; and &lt;code&gt;towupper&lt;/code&gt; are handled as built-in functions except in strict ISO C90 mode (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cca21d213324c7eb2448728bd34ae61f7e19024" translate="yes" xml:space="preserve">
          <source>The ISO C99 functions &lt;code&gt;_Exit&lt;/code&gt;, &lt;code&gt;acoshf&lt;/code&gt;, &lt;code&gt;acoshl&lt;/code&gt;, &lt;code&gt;acosh&lt;/code&gt;, &lt;code&gt;asinhf&lt;/code&gt;, &lt;code&gt;asinhl&lt;/code&gt;, &lt;code&gt;asinh&lt;/code&gt;, &lt;code&gt;atanhf&lt;/code&gt;, &lt;code&gt;atanhl&lt;/code&gt;, &lt;code&gt;atanh&lt;/code&gt;, &lt;code&gt;cabsf&lt;/code&gt;, &lt;code&gt;cabsl&lt;/code&gt;, &lt;code&gt;cabs&lt;/code&gt;, &lt;code&gt;cacosf&lt;/code&gt;, &lt;code&gt;cacoshf&lt;/code&gt;, &lt;code&gt;cacoshl&lt;/code&gt;, &lt;code&gt;cacosh&lt;/code&gt;, &lt;code&gt;cacosl&lt;/code&gt;, &lt;code&gt;cacos&lt;/code&gt;, &lt;code&gt;cargf&lt;/code&gt;, &lt;code&gt;cargl&lt;/code&gt;, &lt;code&gt;carg&lt;/code&gt;, &lt;code&gt;casinf&lt;/code&gt;, &lt;code&gt;casinhf&lt;/code&gt;, &lt;code&gt;casinhl&lt;/code&gt;, &lt;code&gt;casinh&lt;/code&gt;, &lt;code&gt;casinl&lt;/code&gt;, &lt;code&gt;casin&lt;/code&gt;, &lt;code&gt;catanf&lt;/code&gt;, &lt;code&gt;catanhf&lt;/code&gt;, &lt;code&gt;catanhl&lt;/code&gt;, &lt;code&gt;catanh&lt;/code&gt;, &lt;code&gt;catanl&lt;/code&gt;, &lt;code&gt;catan&lt;/code&gt;, &lt;code&gt;cbrtf&lt;/code&gt;, &lt;code&gt;cbrtl&lt;/code&gt;, &lt;code&gt;cbrt&lt;/code&gt;, &lt;code&gt;ccosf&lt;/code&gt;, &lt;code&gt;ccoshf&lt;/code&gt;, &lt;code&gt;ccoshl&lt;/code&gt;, &lt;code&gt;ccosh&lt;/code&gt;, &lt;code&gt;ccosl&lt;/code&gt;, &lt;code&gt;ccos&lt;/code&gt;, &lt;code&gt;cexpf&lt;/code&gt;, &lt;code&gt;cexpl&lt;/code&gt;, &lt;code&gt;cexp&lt;/code&gt;, &lt;code&gt;cimagf&lt;/code&gt;, &lt;code&gt;cimagl&lt;/code&gt;, &lt;code&gt;cimag&lt;/code&gt;, &lt;code&gt;clogf&lt;/code&gt;, &lt;code&gt;clogl&lt;/code&gt;, &lt;code&gt;clog&lt;/code&gt;, &lt;code&gt;conjf&lt;/code&gt;, &lt;code&gt;conjl&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt;, &lt;code&gt;copysignf&lt;/code&gt;, &lt;code&gt;copysignl&lt;/code&gt;, &lt;code&gt;copysign&lt;/code&gt;, &lt;code&gt;cpowf&lt;/code&gt;, &lt;code&gt;cpowl&lt;/code&gt;, &lt;code&gt;cpow&lt;/code&gt;, &lt;code&gt;cprojf&lt;/code&gt;, &lt;code&gt;cprojl&lt;/code&gt;, &lt;code&gt;cproj&lt;/code&gt;, &lt;code&gt;crealf&lt;/code&gt;, &lt;code&gt;creall&lt;/code&gt;, &lt;code&gt;creal&lt;/code&gt;, &lt;code&gt;csinf&lt;/code&gt;, &lt;code&gt;csinhf&lt;/code&gt;, &lt;code&gt;csinhl&lt;/code&gt;, &lt;code&gt;csinh&lt;/code&gt;, &lt;code&gt;csinl&lt;/code&gt;, &lt;code&gt;csin&lt;/code&gt;, &lt;code&gt;csqrtf&lt;/code&gt;, &lt;code&gt;csqrtl&lt;/code&gt;, &lt;code&gt;csqrt&lt;/code&gt;, &lt;code&gt;ctanf&lt;/code&gt;, &lt;code&gt;ctanhf&lt;/code&gt;, &lt;code&gt;ctanhl&lt;/code&gt;, &lt;code&gt;ctanh&lt;/code&gt;, &lt;code&gt;ctanl&lt;/code&gt;, &lt;code&gt;ctan&lt;/code&gt;, &lt;code&gt;erfcf&lt;/code&gt;, &lt;code&gt;erfcl&lt;/code&gt;, &lt;code&gt;erfc&lt;/code&gt;, &lt;code&gt;erff&lt;/code&gt;, &lt;code&gt;erfl&lt;/code&gt;, &lt;code&gt;erf&lt;/code&gt;, &lt;code&gt;exp2f&lt;/code&gt;, &lt;code&gt;exp2l&lt;/code&gt;, &lt;code&gt;exp2&lt;/code&gt;, &lt;code&gt;expm1f&lt;/code&gt;, &lt;code&gt;expm1l&lt;/code&gt;, &lt;code&gt;expm1&lt;/code&gt;, &lt;code&gt;fdimf&lt;/code&gt;, &lt;code&gt;fdiml&lt;/code&gt;, &lt;code&gt;fdim&lt;/code&gt;, &lt;code&gt;fmaf&lt;/code&gt;, &lt;code&gt;fmal&lt;/code&gt;, &lt;code&gt;fmaxf&lt;/code&gt;, &lt;code&gt;fmaxl&lt;/code&gt;, &lt;code&gt;fmax&lt;/code&gt;, &lt;code&gt;fma&lt;/code&gt;, &lt;code&gt;fminf&lt;/code&gt;, &lt;code&gt;fminl&lt;/code&gt;, &lt;code&gt;fmin&lt;/code&gt;, &lt;code&gt;hypotf&lt;/code&gt;, &lt;code&gt;hypotl&lt;/code&gt;, &lt;code&gt;hypot&lt;/code&gt;, &lt;code&gt;ilogbf&lt;/code&gt;, &lt;code&gt;ilogbl&lt;/code&gt;, &lt;code&gt;ilogb&lt;/code&gt;, &lt;code&gt;imaxabs&lt;/code&gt;, &lt;code&gt;isblank&lt;/code&gt;, &lt;code&gt;iswblank&lt;/code&gt;, &lt;code&gt;lgammaf&lt;/code&gt;, &lt;code&gt;lgammal&lt;/code&gt;, &lt;code&gt;lgamma&lt;/code&gt;, &lt;code&gt;llabs&lt;/code&gt;, &lt;code&gt;llrintf&lt;/code&gt;, &lt;code&gt;llrintl&lt;/code&gt;, &lt;code&gt;llrint&lt;/code&gt;, &lt;code&gt;llroundf&lt;/code&gt;, &lt;code&gt;llroundl&lt;/code&gt;, &lt;code&gt;llround&lt;/code&gt;, &lt;code&gt;log1pf&lt;/code&gt;, &lt;code&gt;log1pl&lt;/code&gt;, &lt;code&gt;log1p&lt;/code&gt;, &lt;code&gt;log2f&lt;/code&gt;, &lt;code&gt;log2l&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;logbf&lt;/code&gt;, &lt;code&gt;logbl&lt;/code&gt;, &lt;code&gt;logb&lt;/code&gt;, &lt;code&gt;lrintf&lt;/code&gt;, &lt;code&gt;lrintl&lt;/code&gt;, &lt;code&gt;lrint&lt;/code&gt;, &lt;code&gt;lroundf&lt;/code&gt;, &lt;code&gt;lroundl&lt;/code&gt;, &lt;code&gt;lround&lt;/code&gt;, &lt;code&gt;nearbyintf&lt;/code&gt;, &lt;code&gt;nearbyintl&lt;/code&gt;, &lt;code&gt;nearbyint&lt;/code&gt;, &lt;code&gt;nextafterf&lt;/code&gt;, &lt;code&gt;nextafterl&lt;/code&gt;, &lt;code&gt;nextafter&lt;/code&gt;, &lt;code&gt;nexttowardf&lt;/code&gt;, &lt;code&gt;nexttowardl&lt;/code&gt;, &lt;code&gt;nexttoward&lt;/code&gt;, &lt;code&gt;remainderf&lt;/code&gt;, &lt;code&gt;remainderl&lt;/code&gt;, &lt;code&gt;remainder&lt;/code&gt;, &lt;code&gt;remquof&lt;/code&gt;, &lt;code&gt;remquol&lt;/code&gt;, &lt;code&gt;remquo&lt;/code&gt;, &lt;code&gt;rintf&lt;/code&gt;, &lt;code&gt;rintl&lt;/code&gt;, &lt;code&gt;rint&lt;/code&gt;, &lt;code&gt;roundf&lt;/code&gt;, &lt;code&gt;roundl&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;scalblnf&lt;/code&gt;, &lt;code&gt;scalblnl&lt;/code&gt;, &lt;code&gt;scalbln&lt;/code&gt;, &lt;code&gt;scalbnf&lt;/code&gt;, &lt;code&gt;scalbnl&lt;/code&gt;, &lt;code&gt;scalbn&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;tgammaf&lt;/code&gt;, &lt;code&gt;tgammal&lt;/code&gt;, &lt;code&gt;tgamma&lt;/code&gt;, &lt;code&gt;truncf&lt;/code&gt;, &lt;code&gt;truncl&lt;/code&gt;, &lt;code&gt;trunc&lt;/code&gt;, &lt;code&gt;vfscanf&lt;/code&gt;, &lt;code&gt;vscanf&lt;/code&gt;, &lt;code&gt;vsnprintf&lt;/code&gt; and &lt;code&gt;vsscanf&lt;/code&gt; are handled as built-in functions except in strict ISO C90 mode (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2784e50b776c95c529ea8bb486ce2750890944bf" translate="yes" xml:space="preserve">
          <source>The ISO type of an integer constant has a different width or signedness from its traditional type. This warning is only issued if the base of the constant is ten. I.e. hexadecimal or octal values, which typically represent bit patterns, are not warned about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a12be836835137fbdc59e2c7d2766dbca00a8c" translate="yes" xml:space="preserve">
          <source>The JSON is emitted as one line, without formatting; the examples below have been formatted for clarity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a22ef3a7780246abe5b933d687f802ceaac7fd9" translate="yes" xml:space="preserve">
          <source>The MIPS DSP Application-Specific Extension (ASE) includes new instructions that are designed to improve the performance of DSP and media applications. It provides instructions that operate on packed 8-bit/16-bit integer data, Q7, Q15 and Q31 fractional data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ed4155655f597ba1ea8fb1a082975a691dee38" translate="yes" xml:space="preserve">
          <source>The MIPS-3D Application-Specific Extension (ASE) includes additional paired-single instructions that are designed to improve the performance of 3D graphics operations. Support for these instructions is controlled by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2568887586875d72638add2c316850a652079522" translate="yes" xml:space="preserve">
          <source>The MIPS64 architecture includes a number of instructions that operate on pairs of single-precision floating-point values. Each pair is packed into a 64-bit floating-point register, with one element being designated the &amp;ldquo;upper half&amp;rdquo; and the other being designated the &amp;ldquo;lower half&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19791c6fc0c7878cc7c0d81440fdc8b3deac6cc4" translate="yes" xml:space="preserve">
          <source>The MSP430 hardware ensures that interrupts are disabled on entry to &lt;code&gt;interrupt&lt;/code&gt; functions, and restores the previous interrupt state on exit. The &lt;code&gt;critical&lt;/code&gt; attribute is therefore redundant on &lt;code&gt;interrupt&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324add0fab22223316ad270b660243d491e201b4" translate="yes" xml:space="preserve">
          <source>The MeP target has a number of addressing modes and busses. The &lt;code&gt;near&lt;/code&gt; space spans the standard memory space&amp;rsquo;s first 16 megabytes (24 bits). The &lt;code&gt;far&lt;/code&gt; space spans the entire 32-bit memory space. The &lt;code&gt;based&lt;/code&gt; space is a 128-byte region in the memory space that is addressed relative to the &lt;code&gt;$tp&lt;/code&gt; register. The &lt;code&gt;tiny&lt;/code&gt; space is a 65536-byte region relative to the &lt;code&gt;$gp&lt;/code&gt; register. In addition to these memory regions, the MeP target has a separate 16-bit control bus which is specified with &lt;code&gt;cb&lt;/code&gt; attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8a7015c96baf068daea7c993c23e530f568f5f" translate="yes" xml:space="preserve">
          <source>The Medium/Anywhere code model for embedded systems: 64-bit addresses, the text and data segments must be less than 2GB in size, both starting anywhere in memory (determined at link time). The global register %g4 points to the base of the data segment. Programs are statically linked and PIC is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc31a18cddf7a0f78efe693458fe2d9afe6d7019" translate="yes" xml:space="preserve">
          <source>The Medium/Anywhere code model: 64-bit addresses, programs may be linked anywhere in memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3c5ad40e25357a2525dfa3cd571c1d3bd7d34a" translate="yes" xml:space="preserve">
          <source>The Medium/Low code model: 64-bit addresses, programs must be linked in the low 32 bits of memory. Programs can be statically or dynamically linked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b39ba546b4adedbbf99b1b31d01ec7fac76520a" translate="yes" xml:space="preserve">
          <source>The Medium/Middle code model: 64-bit addresses, programs must be linked in the low 44 bits of memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2b29936b818cfc1e5a3a58f7738a9fa0c881c1" translate="yes" xml:space="preserve">
          <source>The Microsoft structure layout algorithm is fairly simple with the exception of the bit-field packing. The padding and alignment of members of structures and whether a bit-field can straddle a storage-unit boundary are determine by these rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeff520b5677f801f6da4eeb7f1e51a9a569cd01" translate="yes" xml:space="preserve">
          <source>The NOP instructions are inserted at&amp;mdash;and maybe before, depending on &lt;var&gt;M&lt;/var&gt;&amp;mdash;the function entry address, even before the prologue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff55b141ae724be4a1c090f09197c4cc8d0b49e5" translate="yes" xml:space="preserve">
          <source>The Objective-C 2.0 language extensions and features are automatically enabled; they include properties (via the &lt;code&gt;@property&lt;/code&gt;, &lt;code&gt;@synthesize&lt;/code&gt; and &lt;code&gt;@dynamic keywords&lt;/code&gt;), fast enumeration (not available in Objective-C++), attributes for methods (such as &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, &lt;code&gt;sentinel&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;), the &lt;code&gt;unused&lt;/code&gt; attribute for method arguments, the &lt;code&gt;@package&lt;/code&gt; keyword for instance variables and the &lt;code&gt;@optional&lt;/code&gt; and &lt;code&gt;@required&lt;/code&gt; keywords in protocols. You can disable all these Objective-C 2.0 language extensions with the option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6923a9108193e35102064afa9eda743cb37bdd9" translate="yes" xml:space="preserve">
          <source>The Objective-C compiler generates type encodings for all the types. These type encodings are used at runtime to find out information about selectors and methods and about objects and classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e464bd6510d0d75994dbae5961cb9df5baed7b28" translate="yes" xml:space="preserve">
          <source>The Objective-C exception and synchronization syntax (that is, the keywords &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@throw&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, &lt;code&gt;@finally&lt;/code&gt; and &lt;code&gt;@synchronized&lt;/code&gt;) is supported by GCC and is enabled with the option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504b920d3ddaa29eaf4f4d2837867a09bb928c21" translate="yes" xml:space="preserve">
          <source>The One Definition Rule is relaxed for types without explicit visibility specifications that are defined in more than one shared object: those declarations are permitted if they are permitted when this option is not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d22810fdfaa073bc94d2050ac8533154c085f11" translate="yes" xml:space="preserve">
          <source>The RL78 back end supports the &lt;code&gt;saddr&lt;/code&gt; variable attribute. This specifies placement of the corresponding variable in the SADDR area, which can be accessed more efficiently than the default memory region.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c75a1f23dddf5a55d85a877757468d10500aab3" translate="yes" xml:space="preserve">
          <source>The RS/6000 and PowerPC targets define one pragma for controlling whether or not the &lt;code&gt;longcall&lt;/code&gt; attribute is added to function declarations by default. This pragma overrides the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549fc0bcd99c9fa57f4b149326299d99007e47ae" translate="yes" xml:space="preserve">
          <source>The SCOUNT and POS bits of the DSP control register are global. The WRDSP, EXTPDP, EXTPDPV and MTHLIP instructions modify the SCOUNT and POS bits. During optimization, the compiler does not delete these instructions and it does not delete calls to functions containing these instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feed8b7325d666bcdf4c1efd5aa692caea9e4e2d" translate="yes" xml:space="preserve">
          <source>The SPU supports the &lt;code&gt;spu_vector&lt;/code&gt; attribute for variables. For documentation of this attribute please see the documentation in &lt;a href=&quot;type-attributes#SPU-Type-Attributes&quot;&gt;SPU Type Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00194fefd3abe9f6e9c4ed0e24c5f1cdb3e71d6" translate="yes" xml:space="preserve">
          <source>The Solaris target supports &lt;code&gt;#pragma redefine_extname&lt;/code&gt; (see &lt;a href=&quot;symbol_002drenaming-pragmas#Symbol_002dRenaming-Pragmas&quot;&gt;Symbol-Renaming Pragmas&lt;/a&gt;). It also supports additional &lt;code&gt;#pragma&lt;/code&gt; directives for compatibility with the system compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b577e7bfa4d5d277a90aa967bc9fa309870fa29b" translate="yes" xml:space="preserve">
          <source>The V850 back end supports these function attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ba99adc7a79652db01be899ada60245b8a9d21" translate="yes" xml:space="preserve">
          <source>The VFPv2 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259f6621f353addf35de203c6cc21ec70166871f" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bbc2d35ac5910370025649743d2c9e7aba8bec" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions with 16 double-precision registers. The extension +vfpv3-d16 can be used as an alias for this extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d392f4c1ad45a7ce6a0755dbe2047b64e45ba0e" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea0bf30af6241dd74e66058037f24ca2aa3b024" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c44d40609c70bac64a3214e9aba6ea5f2799b31" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers. The extension &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ba42177cf602fb7a0ed600eac827a8de6a449b" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 32 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193d13643a69320727d206517bd62145a8c8f03c" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 32 double-precision registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0936e97cd9c57c2c85efdbe6388f42baca5f03d" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 16 double-precision registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103d1acc3dfe417798e6bd838ba4fc9709451552" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 16 double-precision registers. The extension &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ddcf864547f4dbeda808689e788fca6e819171" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 32 double-precision registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9285ccf7646c59c98d31930bdd84e56c45d5fd26" translate="yes" xml:space="preserve">
          <source>The VR4130 pipeline is two-way superscalar, but can only issue two instructions together if the first one is 8-byte aligned. When this option is enabled, GCC aligns pairs of instructions that it thinks should execute in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb154aff394215a4189b3dafa08992907beaeea3" translate="yes" xml:space="preserve">
          <source>The VSX instruction set (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0171ba1b31d3315fbbfaace918d589c6b61613" translate="yes" xml:space="preserve">
          <source>The abbreviation &lt;em&gt;GCC&lt;/em&gt; has multiple meanings in common use. The current official meaning is &amp;ldquo;GNU Compiler Collection&amp;rdquo;, which refers generically to the complete suite of tools. The name historically stood for &amp;ldquo;GNU C Compiler&amp;rdquo;, and this usage is still common when the emphasis is on compiling C programs. Finally, the name is also used when speaking of the &lt;em&gt;language-independent&lt;/em&gt; component of GCC: code shared among the compilers for all supported languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9d23d169ba3b72eeef6725cec43a13a50013c2" translate="yes" xml:space="preserve">
          <source>The above generates bytecode for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a36dd9deec63b753f5d433c0dd87cbce7edcf4" translate="yes" xml:space="preserve">
          <source>The above lines are equivalent to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a39976e643ac6d1dc6fe3e4366ed3a13dea2466b" translate="yes" xml:space="preserve">
          <source>The above target attributes can be specified as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1f637f7dae694f5c4cfc72955bdf63e2cee6a2" translate="yes" xml:space="preserve">
          <source>The accuracy is unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120b6f184277986efda6f906c93a195e4dc7e853" translate="yes" xml:space="preserve">
          <source>The accuracy of the floating-point operations and of the library functions in &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; that return floating-point results (C90, C99 and C11 5.2.4.2.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f0b076d52d6244bc6636b163e80827a773f50c" translate="yes" xml:space="preserve">
          <source>The actual register chosen to hold the constant data base address depends upon whether the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30a65f7051569a9a9c6241a0c50efdd3d1de863" translate="yes" xml:space="preserve">
          <source>The added &lt;var&gt;flag&lt;/var&gt; argument is passed unchanged to &lt;code&gt;__sprintf_chk&lt;/code&gt; etc. functions and can contain implementation specific flags on what additional security measures the checking function might take, such as handling &lt;code&gt;%n&lt;/code&gt; differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6f66f554f454fd60e4196cbe8c25320dedb4b7" translate="yes" xml:space="preserve">
          <source>The added comments include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6f1012ead9ec76811fd2e9243c4b72f326472d" translate="yes" xml:space="preserve">
          <source>The additional block information is of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79eafbe5ef62b1bf562656c8ccc8660f517c4542" translate="yes" xml:space="preserve">
          <source>The address as returned by &lt;code&gt;__builtin_return_address&lt;/code&gt; may have to be fed through this function to get the actual encoded address. For example, on the 31-bit S/390 platform the highest bit has to be masked out, or on SPARC platforms an offset has to be added for the true next instruction to be executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9133fefd38b502d139962641eb1473acc29ca6ef" translate="yes" xml:space="preserve">
          <source>The addressability of a particular object can be set with the &lt;code&gt;model&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b38ea0caa823f37a2f086f0d1bc57b4b47d283c" translate="yes" xml:space="preserve">
          <source>The alignment of non-bit-field members of structures (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322481284c6908feb9887b9dd7bb912960123985" translate="yes" xml:space="preserve">
          <source>The alternate keywords &lt;code&gt;__asm__&lt;/code&gt;, &lt;code&gt;__extension__&lt;/code&gt;, &lt;code&gt;__inline__&lt;/code&gt; and &lt;code&gt;__typeof__&lt;/code&gt; continue to work despite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e728c9fa7b9e6ce4962fad39896909da2bde1ee" translate="yes" xml:space="preserve">
          <source>The analogous feature in Fortran is called an assigned goto, but that name seems inappropriate in C, where one can do more than simply store label addresses in label variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c11777761d5f46c1a9fb516ac0c2ee4a9cb68d" translate="yes" xml:space="preserve">
          <source>The application binary interface implemented by a C or C++ compiler affects code generation and runtime support for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b549ce42574a44cc4510011757b7ba9fd1935c" translate="yes" xml:space="preserve">
          <source>The approximate maximum amount of memory that can be allocated in order to perform the global common subexpression elimination optimization. If more memory than specified is required, the optimization is not done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01165ed876927994264f7a9cab383ccc4af10540" translate="yes" xml:space="preserve">
          <source>The argument can be a list of strings of arbitrary length. The strings are sorted on output, so the order of the list is unimportant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d49582cbfaa16c6712e0f374a5a6c15a857459" translate="yes" xml:space="preserve">
          <source>The argument to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d44a319a963da0f3902d413f244d251258e282dd" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;__builtin_tgmath&lt;/code&gt; are at least two pointers to functions, followed by the arguments to the type-generic macro (which will be passed as arguments to the selected function). All the pointers to functions must be pointers to prototyped functions, none of which may have variable arguments, and all of which must have the same number of parameters; the number of parameters of the first function determines how many arguments to &lt;code&gt;__builtin_tgmath&lt;/code&gt; are interpreted as function pointers, and how many as the arguments to the called function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966ac956bf197ec8f0ba6771423c919858f24a7d" translate="yes" xml:space="preserve">
          <source>The arguments to the built-in functions can be divided into three groups: register numbers, compile-time constants and run-time values. In order to make this classification clear at a glance, the arguments and return values are given the following pseudo types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c829863ade5431c1682f5d64360267aae12a2fb8" translate="yes" xml:space="preserve">
          <source>The attribute can also be applied to an inline namespace, but does not affect the mangled name of the namespace; in this case it is only used for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed02eb26a29f10b556adacd30701241deccd245e" translate="yes" xml:space="preserve">
          <source>The attribute cannot be used to decrease the alignment of a function previously declared with a more restrictive alignment; only to increase it. Attempts to do otherwise are diagnosed. Some targets specify a minimum default alignment for functions that is greater than 1. On such targets, specifying a less restrictive alignment is silently ignored. Using the attribute overrides the effect of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae26e49e643c3950ed6f72c5632f4fffd355af07" translate="yes" xml:space="preserve">
          <source>The attribute has no effect on functions defined within the current compilation unit. This is to allow easy merging of multiple compilation units into one, for example, by using the link-time optimization. For this reason the attribute is not allowed on types to annotate indirect calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87e6916763209960cf7a9bdaddf003a5218d3bef" translate="yes" xml:space="preserve">
          <source>The attribute is automatically set with a position of 0 for the built-in functions &lt;code&gt;execl&lt;/code&gt; and &lt;code&gt;execlp&lt;/code&gt;. The built-in function &lt;code&gt;execle&lt;/code&gt; has the attribute set with a position of 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2a754094a48aee11cc854617f21a28a6c915b2" translate="yes" xml:space="preserve">
          <source>The attribute is ignored for undefined symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20b877bf7007b2fcc50da9d21f8618882a3644d" translate="yes" xml:space="preserve">
          <source>The attribute is intended for library functions to improve dataflow analysis. The compiler takes the hint that any data not escaping the current compilation unit cannot be used or modified by the leaf function. For example, the &lt;code&gt;sin&lt;/code&gt; function is a leaf function, but &lt;code&gt;qsort&lt;/code&gt; is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb101c8aa868b197540d1e1e07e514397c2827e" translate="yes" xml:space="preserve">
          <source>The attribute parameters configure what values are passed into the kernel function by the GPU drivers, via the initial register state. Some values are used by the compiler, and therefore forced on. Enabling other options may break assumptions in the compiler and/or run-time libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37e3b5bceea5d68174fbdb23337f013d5dc061b" translate="yes" xml:space="preserve">
          <source>The attributes work in conjunction with a linker script that has been augmented to specify where to place sections with a &lt;code&gt;.lower&lt;/code&gt; and a &lt;code&gt;.upper&lt;/code&gt; prefix. So, for example, as well as placing the &lt;code&gt;.data&lt;/code&gt; section, the script also specifies the placement of a &lt;code&gt;.lower.data&lt;/code&gt; and a &lt;code&gt;.upper.data&lt;/code&gt; section. The intention is that &lt;code&gt;lower&lt;/code&gt; sections are placed into a small but easier to access memory region and the upper sections are placed into a larger, but slower to access, region.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10feff4fc0898bcb9645a7662553ea298f34abd3" translate="yes" xml:space="preserve">
          <source>The authoritative manual on Objective-C 2.0 is available from Apple:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ef9f24ededd45d5c51229d5801270991d5579a" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.05 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbf04361cb171c9ec574af51f9f9931b1811352" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.07 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f8648696a80bbf371453c7d66873b6ed3c1e9f" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 3.0 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5753c392332963f289e128617ea50b9de09b52f" translate="yes" xml:space="preserve">
          <source>The behavior of most of these points are dependent on the implementation of the C library, and are not defined by GCC itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12799856c643d4a305ab2b4319a6be1f011a91bc" translate="yes" xml:space="preserve">
          <source>The behavior of these points are dependent on the implementation of the C library, and are not defined by GCC itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ca99f07d3faae58eb40bce10f1e4e864f854e3" translate="yes" xml:space="preserve">
          <source>The behavior of this switch is not quite the same as marking the methods as hidden directly, because it does not affect static variables local to the function or cause the compiler to deduce that the function is defined in only one shared object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d6b7cdf4a6f4c034253043f3e78682296fde54a" translate="yes" xml:space="preserve">
          <source>The behavior on each recognized non-&lt;code&gt;STDC #pragma&lt;/code&gt; directive (C90 6.8.6, C99 and C11 6.10.6).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78838b89d1e6169626813ca34b5663bfb106ff9a" translate="yes" xml:space="preserve">
          <source>The best solution to such a problem is to put the text into an actual C comment delimited by &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc968ad31a477faa2208668bddbf016d38a55ba" translate="yes" xml:space="preserve">
          <source>The built-in compare types&amp;ndash;eq, ne, gtu, ltu, geu, and leu.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0a88d34ad669c64ab3760c61374b2e37e4cc3c" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;__builtin_complex&lt;/code&gt; is provided for use in implementing the ISO C11 macros &lt;code&gt;CMPLXF&lt;/code&gt;, &lt;code&gt;CMPLX&lt;/code&gt; and &lt;code&gt;CMPLXL&lt;/code&gt;. &lt;var&gt;real&lt;/var&gt; and &lt;var&gt;imag&lt;/var&gt; must have the same type, a real binary floating-point type, and the result has the corresponding complex type with real and imaginary parts &lt;var&gt;real&lt;/var&gt; and &lt;var&gt;imag&lt;/var&gt;. Unlike &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4172235cf37ce3bd8136a03cb1f1f52ca1bd1d30" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;__builtin_tgmath&lt;/code&gt;, available only for C and Objective-C, calls a function determined according to the rules of &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros. It is intended to be used in implementations of that header, so that expansions of macros from that header only expand each of their arguments once, to avoid problems when calls to such macros are nested inside the arguments of other calls to such macros; in addition, it results in better diagnostics for invalid calls to &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros than implementations using other GNU C language features. For example, the &lt;code&gt;pow&lt;/code&gt; type-generic macro might be defined as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ab6bdc7a525221a10db36f04ba0ea776ca5cba" translate="yes" xml:space="preserve">
          <source>The built-in function can be used where a variable appears to be used in a safe way, but the CPU, due to speculative execution may temporarily ignore the bounds checks. Consider, for example, the following function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a003f5f8fd45a849966ac7beaa6dcf85e370f177" translate="yes" xml:space="preserve">
          <source>The built-in function will either cause execution to stall until the conditional branch has been fully resolved, or it may permit speculative execution to continue, but using 0 instead of &lt;code&gt;untrusted_value&lt;/code&gt; if that exceeds the limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23fbf2c81175bf34ed4b14a9d7849c7a6ed67337" translate="yes" xml:space="preserve">
          <source>The built-in functions are optimized into the normal string functions like &lt;code&gt;memcpy&lt;/code&gt; if the last argument is &lt;code&gt;(size_t) -1&lt;/code&gt; or if it is known at compile time that the destination object will not be overflowed. If the compiler can determine at compile time that the object will always be overflowed, it issues a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b0909bb726639d57f4621d69b4f030cedbb5e2" translate="yes" xml:space="preserve">
          <source>The built-in functions promote the first two operands into infinite precision signed type and perform addition on those promoted operands. The result is then cast to the type of the third argument. If the cast result is equal to the infinite precision result, the built-in functions return &lt;code&gt;false&lt;/code&gt;, otherwise they return &lt;code&gt;true&lt;/code&gt;. The value of the third argument is ignored, just the side effects in the third argument are evaluated, and no integral argument promotions are performed on the last argument. If the third argument is a bit-field, the type used for the result cast has the precision and signedness of the given bit-field, rather than precision and signedness of the underlying type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334b3175e81dee6f1e168a0be44f3b7d957b1be7" translate="yes" xml:space="preserve">
          <source>The built-in macros&amp;rsquo; names follow the scheme &lt;code&gt;__AVR_&lt;var&gt;Device&lt;/var&gt;__&lt;/code&gt; where &lt;var&gt;Device&lt;/var&gt; is the device name as from the AVR user manual. The difference between &lt;var&gt;Device&lt;/var&gt; in the built-in macro and &lt;var&gt;device&lt;/var&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f099d3393656bddb7d8b0dd222e5a223f8d688" translate="yes" xml:space="preserve">
          <source>The built-in versions of these functions use GCC&amp;rsquo;s normal mechanisms to save and restore registers using the stack on function entry and exit. The jump buffer argument &lt;var&gt;buf&lt;/var&gt; holds only the information needed to restore the stack frame, rather than the entire set of saved register values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4488c1d75b7b81f78b64d60c26fdf9ed24d8f3bf" translate="yes" xml:space="preserve">
          <source>The call-clobbered integer registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b277cbf75c7f621fb1dabe16f1a3a2fa8a7f4cc" translate="yes" xml:space="preserve">
          <source>The caller copies function arguments passed by hidden reference. This option should be used with care as it is not compatible with the default 32-bit runtime. However, only aggregates larger than eight bytes are passed by hidden reference and the option provides better compatibility with OpenMP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b583bb229dda327522feb6b40a364f4908fd1bf3" translate="yes" xml:space="preserve">
          <source>The carry register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7287b1af6a41a31db6c4fc8adca45c0df1d456b" translate="yes" xml:space="preserve">
          <source>The change to the types of UTF-8 string and character literals introduces incompatibilities with ISO C++11 and later standards. For example, the following code is well-formed under ISO C++11, but is ill-formed when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519631b15cf0936ab9bd0c60033ca6acf8715c58" translate="yes" xml:space="preserve">
          <source>The choices for &lt;var&gt;cpu-type&lt;/var&gt; are the same as for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="682ea402eec35d575ae857912b781a6cde1e0d53" translate="yes" xml:space="preserve">
          <source>The choices for &lt;var&gt;cpu-type&lt;/var&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8623d02fccd10cdf135414efb4d8dedf3d5298b1" translate="yes" xml:space="preserve">
          <source>The code above would iterate over all objects in &lt;code&gt;array&lt;/code&gt;. For each of them, it assigns it to &lt;code&gt;object&lt;/code&gt;, then executes the &lt;code&gt;Do something with 'object'&lt;/code&gt; statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990cbdb236536d3c2c7b3b4ad41a30dc08b70c1d" translate="yes" xml:space="preserve">
          <source>The colors are defined by the environment variable &lt;code&gt;GCC_COLORS&lt;/code&gt;. Its value is a colon-separated list of capabilities and Select Graphic Rendition (SGR) substrings. SGR commands are interpreted by the terminal or terminal emulator. (See the section in the documentation of your text terminal for permitted values and their meanings as character attributes.) These substring values are integers in decimal representation and can be concatenated with semicolons. Common values to concatenate include &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34aa8249352c8e598246fe5c42924ea343806e93" translate="yes" xml:space="preserve">
          <source>The comment needs to be followed after optional whitespace and other comments by &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; keywords or by a user label that precedes some &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f1f40d78278988845f6e6d5dd1df865371c25c" translate="yes" xml:space="preserve">
          <source>The comments are intended for humans rather than machines and hence the precise format of the comments is subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f39136333428ef92d0ab34cd6ec4175f20f2a6" translate="yes" xml:space="preserve">
          <source>The common src/dest memory addressing modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d24a28b1d2dd308a7ff9954bb96ae5aaa048ba" translate="yes" xml:space="preserve">
          <source>The common subset of the ARMv7-A, ARMv7-R and ARMv7-M architectures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c10738c483ffe85f7448f4cbfe545afae5514b" translate="yes" xml:space="preserve">
          <source>The compiler assumes that &lt;code&gt;EIND&lt;/code&gt; never changes during the startup code or during the application. In particular, &lt;code&gt;EIND&lt;/code&gt; is not saved/restored in function or interrupt service routine prologue/epilogue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8983abbfe719941604e388ad4f86efe2a35d89a4" translate="yes" xml:space="preserve">
          <source>The compiler automatically sets the alignment for the declared variable or field to &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables or fields that you have aligned this way. Note that the value of &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; may change depending on command-line options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7e2956c5fa63410dcde9892cdb317e8b9bdabe" translate="yes" xml:space="preserve">
          <source>The compiler can accept several base standards, such as &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae77b7d999c147c822471a0c6078013beaa6bc78" translate="yes" xml:space="preserve">
          <source>The compiler checks to see if the path provided by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75bc3167776cc7681a2a3309af02b07eee5f4ff" translate="yes" xml:space="preserve">
          <source>The compiler contains estimates of the number of clock cycles for &amp;ldquo;typical&amp;rdquo; EV4 &amp;amp; EV5 hardware for the Level 1, 2 &amp;amp; 3 caches (also called Dcache, Scache, and Bcache), as well as to main memory. Note that L3 is only valid for EV5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8338416b67f14201602d466304368b7f468175f5" translate="yes" xml:space="preserve">
          <source>The compiler copies the assembler instructions in a basic &lt;code&gt;asm&lt;/code&gt; verbatim to the assembly language output file, without processing dialects or any of the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28532eae1da814b4665d28f7dd4fbb9e0aec8b2" translate="yes" xml:space="preserve">
          <source>The compiler driver program runs one or more of the subprograms &lt;code&gt;cpp&lt;/code&gt;, &lt;code&gt;cc1&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt; and &lt;code&gt;ld&lt;/code&gt;. It tries &lt;var&gt;prefix&lt;/var&gt; as a prefix for each program it tries to run, both with and without &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9b15ff6acdc5c85d5777579b9105147bc703cb" translate="yes" xml:space="preserve">
          <source>The compiler emits such &lt;code&gt;gs&lt;/code&gt; modifiers for code labels in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa76bdb9ae1bbf7aa774ff7d0e6d298e86f04a3" translate="yes" xml:space="preserve">
          <source>The compiler generates special code to access the variable &lt;code&gt;i&lt;/code&gt;. It may use runtime library support, or generate special machine instructions to access that address space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d157d680a0dc51afbbd2163137f4b54277c4701" translate="yes" xml:space="preserve">
          <source>The compiler is configured to be used together with AVR-Libc. See the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdab34c680d8fa9373eabc63f94733d605cf2016" translate="yes" xml:space="preserve">
          <source>The compiler may generate calls to &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt;. These entries are usually resolved by entries in libc. These entry points should be supplied through some other mechanism when this option is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="197f6accb1b57a2d3b7bbd9dc901a8f9853c9909" translate="yes" xml:space="preserve">
          <source>The compiler may move the addition back before the &lt;code&gt;volatile asm&lt;/code&gt; statement. To make it work as expected, add an artificial dependency to the &lt;code&gt;asm&lt;/code&gt; by referencing a variable in the subsequent code, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9dc939c11511961a2efd9a38375989ea973bee" translate="yes" xml:space="preserve">
          <source>The compiler never sets &lt;code&gt;EIND&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c65d66d80d8006703599470ce9ad6d678c7518" translate="yes" xml:space="preserve">
          <source>The compiler performs optimization based on the knowledge it has of the program. Compiling multiple files at once to a single output file mode allows the compiler to use information gained from all of the files when compiling each of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059a79983e1d0cd8bbb8de563c5411cbd5695493" translate="yes" xml:space="preserve">
          <source>The compiler rearranges the member initializers for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; to match the declaration order of the members, emitting a warning to that effect. This warning is enabled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7ea77386532c48049a0ac434d425f5c9cdb9e9" translate="yes" xml:space="preserve">
          <source>The compiler uses &lt;code&gt;EIND&lt;/code&gt; implicitly in &lt;code&gt;EICALL&lt;/code&gt;/&lt;code&gt;EIJMP&lt;/code&gt; instructions or might read &lt;code&gt;EIND&lt;/code&gt; directly in order to emulate an indirect call/jump by means of a &lt;code&gt;RET&lt;/code&gt; instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a697129b447131da9ef72d7d16ecc19d13cde06f" translate="yes" xml:space="preserve">
          <source>The compiler uses a variety of heuristics to determine whether or not to inline a function. For example, the compiler takes into account the size of the function being inlined and the amount of inlining that has already been done in the current function. Therefore, seemingly insignificant changes in the source program can cause the warnings produced by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e71b48c058bf8bd050867961b9167f5825927e" translate="yes" xml:space="preserve">
          <source>The compiler will attempt to use hardware instructions to implement these built-in functions where possible, like conditional jump on overflow after addition, conditional jump on carry etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f76bb0a6a769fd6051ac5f386b3821fb4f8794e" translate="yes" xml:space="preserve">
          <source>The concatenated &lt;code&gt;hi&lt;/code&gt; and &lt;code&gt;lo&lt;/code&gt; registers. Use this register to store doubleword values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e27c97d9f5e63a4ed1ab3fd7f4a5a1d329e043" translate="yes" xml:space="preserve">
          <source>The conditional text &lt;code&gt;X&lt;/code&gt; in a &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43dc662cd7d08ba0c1419ce7462e0ce31ad7cad" translate="yes" xml:space="preserve">
          <source>The constant -1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06d0b57697105de48b17a361b846597d95ea06a" translate="yes" xml:space="preserve">
          <source>The constant 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c6bdbaee6c04b3fea04b89e43f4576ad393c2b" translate="yes" xml:space="preserve">
          <source>The constant 4096</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dcf3547f5273811228bed3353ffa4e638845233" translate="yes" xml:space="preserve">
          <source>The constant all-ones, for floating-point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d766b475adfc1a095915836fa6b0ad31150ade7f" translate="yes" xml:space="preserve">
          <source>The constant string objects are by default instances of the &lt;code&gt;NXConstantString&lt;/code&gt; class which is provided by the GNU Objective-C runtime. To get the definition of this class you must include the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66bea79ec7c08d8354c118573be3f32ece7da1fe" translate="yes" xml:space="preserve">
          <source>The constant zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0934955261fabaea67e58ba0c7b8bdff156718f6" translate="yes" xml:space="preserve">
          <source>The constant zero or one</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910f5457ff53fa25b37247787227a27d85f14892" translate="yes" xml:space="preserve">
          <source>The constraint matches if the specified part of a constant has a value different from its other parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2273d82451da8273035b5677a47ae31f7f347c8" translate="yes" xml:space="preserve">
          <source>The contents of &lt;var&gt;definition&lt;/var&gt; are tokenized and processed as if they appeared during translation phase three in a &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b752ddcb3035f47ee09a797efcd12407968ef21" translate="yes" xml:space="preserve">
          <source>The convenience of this extension is that &lt;code&gt;f1&lt;/code&gt; has the desired type, eliminating the need to consistently refer to &lt;code&gt;f2.f1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb402cf1ad5d2ebe2ca4cbf79d4710d25aab043" translate="yes" xml:space="preserve">
          <source>The correct solution of the above problem is to use the &lt;code&gt;+load&lt;/code&gt; method instead of &lt;code&gt;+initialize&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5773d425eed0cc1da37ec24e48650c9ef1f3309" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b148cbd7e0801501003f1c6b7a5b5ed93ac8a89" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions. This also enables the Advanced SIMD and floating-point instructions as well as the Dot Product extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bebf33834922696e2e3f146a7028c6f38f3d8ce5" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions. This also enables the Advanced SIMD and floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c616918c11c60074662af2cce8d7bf0b00b006e" translate="yes" xml:space="preserve">
          <source>The current implementation of LTO makes no attempt to generate bytecode that is portable between different types of hosts. The bytecode files are versioned and there is a strict version check, so bytecode files generated in one version of GCC do not work with an older or newer version of GCC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2f64218f4b3df3bf76a18bea506a72c2b53fb3" translate="yes" xml:space="preserve">
          <source>The current locale used to convert a wide character constant consisting of a single multibyte character that maps to a member of the extended execution character set into a corresponding wide character code (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b517f5ebe96bc26ba29bd9df7b451bc7264848" translate="yes" xml:space="preserve">
          <source>The current locale used to convert a wide string literal into corresponding wide character codes (C90 6.1.4, C99 and C11 6.4.5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdee0986787f12266222c4757db3c96510d2856b" translate="yes" xml:space="preserve">
          <source>The data in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad21981df5f9d5df0a92c3202b31e09f62748eca" translate="yes" xml:space="preserve">
          <source>The data segment must be within 512KB while the read-only data segment can be within 4GB addressing space. The text segment should be still within 16MB addressing space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308218254edaf858c826e3717d9728c20e8ea1e8" translate="yes" xml:space="preserve">
          <source>The decimal floating types are &lt;code&gt;_Decimal32&lt;/code&gt;, &lt;code&gt;_Decimal64&lt;/code&gt;, and &lt;code&gt;_Decimal128&lt;/code&gt;. They use a radix of ten, unlike the floating types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; whose radix is not specified by the C standard but is usually two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed195636dddaed157754b6f5efb512126f16823" translate="yes" xml:space="preserve">
          <source>The declaration of an identifier for a variable that has block scope that specifies &lt;code&gt;__thread&lt;/code&gt; shall also specify either &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="539622d22b3611e1a0d2bdec661bbb3d138ab211" translate="yes" xml:space="preserve">
          <source>The default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d93ba84906186c36a266b5450164ecc57295a2f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;GCC_COLORS&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd78088e10f5ca7d05051ca6c08ccd0393bc0395" translate="yes" xml:space="preserve">
          <source>The default choice depends on the target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821efaa8e812e852d4a90373d231a1a43df2b45f" translate="yes" xml:space="preserve">
          <source>The default depends on the specific target configuration. Note that the LP64 and ILP32 ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="073f483a59a39bdd6290fbf3294619a632dc2b8a" translate="yes" xml:space="preserve">
          <source>The default depends on the specific target configuration. Note that the hard-float and soft-float ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83926f7ff8324784f23d17c03f2640efad441ea9" translate="yes" xml:space="preserve">
          <source>The default for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e7e18cf6d489e9159a83316e730a739e99cc90" translate="yes" xml:space="preserve">
          <source>The default for this argument is system dependent, users who want a specific calling convention should specify one explicitly. The valid calling conventions are: &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d2141e4257c252bb28809158d1f4e1362f7a44" translate="yes" xml:space="preserve">
          <source>The default for this option is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5842694f6173b42e85122f8c60c286aa7ddb9932" translate="yes" xml:space="preserve">
          <source>The default is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12e5a4f7dd6f8646e20a0f33147742e17617209" translate="yes" xml:space="preserve">
          <source>The default is &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d068c3eaa8d9ce215b5361f4b44c855149b5984" translate="yes" xml:space="preserve">
          <source>The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when RAM &amp;gt;= 1GB. If &lt;code&gt;getrlimit&lt;/code&gt; is available, the notion of &amp;ldquo;RAM&amp;rdquo; is the smallest of actual RAM and &lt;code&gt;RLIMIT_DATA&lt;/code&gt; or &lt;code&gt;RLIMIT_AS&lt;/code&gt;. If GCC is not able to calculate RAM on a particular platform, the lower bound of 30% is used. Setting this parameter and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce96b424afaca2d610cda8bfb3dce73bc563484" translate="yes" xml:space="preserve">
          <source>The default is the smaller of RAM/8, RLIMIT_RSS, or a limit that tries to ensure that RLIMIT_DATA or RLIMIT_AS are not exceeded, but with a lower bound of 4096 (four megabytes) and an upper bound of 131072 (128 megabytes). If GCC is not able to calculate RAM on a particular platform, the lower bound is used. Setting this parameter very large effectively disables garbage collection. Setting this parameter and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa3b0a93016b2ef8689d14e510c93e9df2d4e56" translate="yes" xml:space="preserve">
          <source>The default is to allow these instructions, but it is not possible for GCC to reliably detect all circumstances where a string instruction might be used to access an I/O register, so their use cannot be disabled automatically. Instead it is reliant upon the programmer to use the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f67e8f5424b41ebf8e66523efa318016a862fb" translate="yes" xml:space="preserve">
          <source>The default is to not maintain the backchain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a0e13c8768face52cb8f602f8efb80a446348b" translate="yes" xml:space="preserve">
          <source>The default is to not use the packed stack layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb857f688cb7de8ba1fbdc52989269bb35500d9" translate="yes" xml:space="preserve">
          <source>The default is usually</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d74d1893ecb7357c9e0df6cf36fc2bbcbd00a365" translate="yes" xml:space="preserve">
          <source>The default linker script is arranged for code with &lt;code&gt;EIND = 0&lt;/code&gt;. If code is supposed to work for a setup with &lt;code&gt;EIND != 0&lt;/code&gt;, a custom linker script has to be used in order to place the sections whose name start with &lt;code&gt;.trampolines&lt;/code&gt; into the segment where &lt;code&gt;EIND&lt;/code&gt; points to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ca561e84dd9753757548b177e64c001dc72487" translate="yes" xml:space="preserve">
          <source>The default memory model for the processor and operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2c3331e29b4e0f75190cbcac7d2cc2935baa6d" translate="yes" xml:space="preserve">
          <source>The default size of &lt;code&gt;int&lt;/code&gt;s, &lt;code&gt;long&lt;/code&gt;s and pointers depends on the ABI. All the supported ABIs use 32-bit &lt;code&gt;int&lt;/code&gt;s. The n64 ABI uses 64-bit &lt;code&gt;long&lt;/code&gt;s, as does the 64-bit EABI; the others use 32-bit &lt;code&gt;long&lt;/code&gt;s. Pointers are the same size as &lt;code&gt;long&lt;/code&gt;s, or the same size as integer registers, whichever is smaller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b0f9504e79ddd153856cb5f4d8eb1074e6f4cb" translate="yes" xml:space="preserve">
          <source>The default state for the &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma (C99 and C11 7.6.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177e9fccdcf6129808c994646c54fbba2a07d2f1" translate="yes" xml:space="preserve">
          <source>The default state for the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 and C11 7.12.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aba487b3647bdb911ee4d93a6d6e3bbfd1ab912" translate="yes" xml:space="preserve">
          <source>The default target is automatically quoted, as if it were given with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b715cc53246030b15f24132e973369879e225c" translate="yes" xml:space="preserve">
          <source>The default value is zero, which disables this feature. Note, this feature is not enabled by default with higher optimization levels (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd9601e22b31b48a224ffc4033c0ab4f7fbfa78" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209814b876827ae56a611572209eb49a8bba5de1" translate="yes" xml:space="preserve">
          <source>The default value of this option is determined by the application binary interface for the target processor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59182b861f448516d9a37ab74276ea6b6b33c147" translate="yes" xml:space="preserve">
          <source>The default value of this option is enabled, thus the only useful form of the option is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a823e9ffdad4eb9044013582624dc9752e06eea" translate="yes" xml:space="preserve">
          <source>The default warning level of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7308db0e02a6c747424ae6a4742ab7d5a6523ec" translate="yes" xml:space="preserve">
          <source>The default when in a standards compliant mode (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45a650c66e86b129ff1159a971751cec60bc96d" translate="yes" xml:space="preserve">
          <source>The default without</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb6ca065b9096c7acde0b3f9da92272ca10172c" translate="yes" xml:space="preserve">
          <source>The default x86-32 ABI assumes that the callee pops the stack for hidden pointer. However, on x86-32 Microsoft Windows targets, the compiler assumes that the caller pops the stack for hidden pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e6fba24182b6c22f37f14e5bbdf01ab49ea815" translate="yes" xml:space="preserve">
          <source>The default, if no C language dialect options are given, is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e40f79f518daef10239cd573498a0a9fbea872" translate="yes" xml:space="preserve">
          <source>The default, if no C++ language dialect options are given, is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d161b7c381e191c75f2893e8fc452452e1e3d3" translate="yes" xml:space="preserve">
          <source>The definition given in the Intel documentation allows only for the use of the types &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt; or their unsigned counterparts. GCC allows any scalar type that is 1, 2, 4 or 8 bytes in size other than the C type &lt;code&gt;_Bool&lt;/code&gt; or the C++ type &lt;code&gt;bool&lt;/code&gt;. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d18656502db6e4e9c93de0479a82b56cb9d524" translate="yes" xml:space="preserve">
          <source>The definitions for &lt;code&gt;__DATE__&lt;/code&gt; and &lt;code&gt;__TIME__&lt;/code&gt; when respectively, the date and time of translation are not available (C90 6.8.8, C99 6.10.8, C11 6.10.8.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09ae46c0bc04395fafa29f4371d3dd1f0905098" translate="yes" xml:space="preserve">
          <source>The depth of search in the dominator tree for expressions to hoist. This is used to avoid quadratic behavior in hoisting algorithm. The value of 0 does not limit on the search, but may slow down compilation of huge functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14934208c61e859a6e7eb6b441a06008f55e391f" translate="yes" xml:space="preserve">
          <source>The device / architecture belongs to the XMEGA family of devices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0848b55d6ef92bf5b121f28a3f70167cf843e9f0" translate="yes" xml:space="preserve">
          <source>The device has Read-Modify-Write instructions (XCH, LAC, LAS and LAT).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94be4f62c4adcfc5a43023ae724a73e574f4d44" translate="yes" xml:space="preserve">
          <source>The device has a hardware multiplier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40eec38c7059a6f4d65d7d4102f16aec3f9f23ce" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;EIJMP&lt;/code&gt; and &lt;code&gt;EICALL&lt;/code&gt; instructions. This is the case for devices with more than 128 KiB of program memory. This also means that the program counter (PC) is 3 bytes wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7183cfd675e5fad71be960e9de6faa5f999d51c4" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; and &lt;code&gt;ELPM
R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124acdeb9487e33b6bf2adad9222c95480d5e077" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;ELPM&lt;/code&gt; instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace169ce6eef96ce4c8d2efd5bee4eef88f9d4da" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;JMP&lt;/code&gt; and &lt;code&gt;CALL&lt;/code&gt; instructions. This is the case for devices with more than 8 KiB of program memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c648d34bf5dc6505ae5b97362b5aa073400b3ded" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; and &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb599358087e9ab1d870c33d3b39e9eeb6c15cf" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;MOVW&lt;/code&gt; instruction to perform 16-bit register-register moves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a1356b9ac9ce24c84c12bd07e29feb04f94c12" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;RAMPD&lt;/code&gt;, &lt;code&gt;RAMPX&lt;/code&gt;, &lt;code&gt;RAMPY&lt;/code&gt;, &lt;code&gt;RAMPZ&lt;/code&gt; special function register, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7440edf5c9a0d8bde64b1ecefe74df7b62918795" translate="yes" xml:space="preserve">
          <source>The device has the SPH (high part of stack pointer) special function register or has an 8-bit stack pointer, respectively. The definition of these macros is affected by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15f34c198926a24e4b29d121787f367b6273a1a" translate="yes" xml:space="preserve">
          <source>The diff may or may not be colorized, following the same rules as for diagnostics (see</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb8bac86341e0faa063bc2c7464731f3754920b" translate="yes" xml:space="preserve">
          <source>The differences to the &lt;code&gt;naked&lt;/code&gt; function attribute are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa2f3d0586724648ad5dc95b2dd6a57770fcc55" translate="yes" xml:space="preserve">
          <source>The direction of rounding when a floating-point number is converted to a narrower floating-point number (C90 6.2.1.4, C99 and C11 6.3.1.5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26fb3de478c5cf1596d7cf8a88ab611eedc18b11" translate="yes" xml:space="preserve">
          <source>The direction of rounding when an integer is converted to a floating-point number that cannot exactly represent the original value (C90 6.2.1.3, C99 and C11 6.3.1.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2a89eb8a493cddb0e17d65209367b348e4e331" translate="yes" xml:space="preserve">
          <source>The earliest version of MacOS X that this executable will run on is &lt;var&gt;version&lt;/var&gt;. Typical values of &lt;var&gt;version&lt;/var&gt; include &lt;code&gt;10.1&lt;/code&gt;, &lt;code&gt;10.2&lt;/code&gt;, and &lt;code&gt;10.3.9&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc00d4d1ee11aa29f8972e4481c89ebd51afb01" translate="yes" xml:space="preserve">
          <source>The easiest way of satisfying these restrictions is to compile and link every module with the same</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ce96812102dd380fc896f02591a99db980d416" translate="yes" xml:space="preserve">
          <source>The effect is equivalent to moving all references to the alias to a separate translation unit, renaming the alias to the aliased symbol, declaring it as weak, compiling the two separate translation units and performing a link with relocatable output (ie: &lt;code&gt;ld -r&lt;/code&gt;) on them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fcdd3faf7319592c843ba96ea56c638eff89d9c" translate="yes" xml:space="preserve">
          <source>The effect of this is that GCC may, effectively, mark inline methods with &lt;code&gt;__attribute__ ((visibility (&quot;hidden&quot;)))&lt;/code&gt; so that they do not appear in the export table of a DSO and do not require a PLT indirection when used within the DSO. Enabling this option can have a dramatic effect on load and link times of a DSO as it massively reduces the size of the dynamic export table when the library makes heavy use of templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80b8b3ee96e1537d805054b77f62723800f759b" translate="yes" xml:space="preserve">
          <source>The elements of the input vectors are numbered in memory ordering of &lt;var&gt;vec0&lt;/var&gt; beginning at 0 and &lt;var&gt;vec1&lt;/var&gt; beginning at &lt;var&gt;N&lt;/var&gt;. The elements of &lt;var&gt;mask&lt;/var&gt; are considered modulo &lt;var&gt;N&lt;/var&gt; in the single-operand case and modulo &lt;em&gt;2*&lt;var&gt;N&lt;/var&gt;&lt;/em&gt; in the two-operand case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03329c8955d8e056ec3aa9ef42249119fe358d03" translate="yes" xml:space="preserve">
          <source>The encoding of any of &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, and &lt;code&gt;char32_t&lt;/code&gt; where the corresponding standard encoding macro (&lt;code&gt;__STDC_ISO_10646__&lt;/code&gt;, &lt;code&gt;__STDC_UTF_16__&lt;/code&gt;, or &lt;code&gt;__STDC_UTF_32__&lt;/code&gt;) is not defined (C11 6.10.8.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c42b29af2e3bb28afd21f635c0f39721670e06" translate="yes" xml:space="preserve">
          <source>The encoding of bit-fields has changed to allow bit-fields to be properly handled by the runtime functions that compute sizes and alignments of types that contain bit-fields. The previous encoding contained only the size of the bit-field. Using only this information it is not possible to reliably compute the size occupied by the bit-field. This is very important in the presence of the Boehm&amp;rsquo;s garbage collector because the objects are allocated using the typed memory facility available in this collector. The typed memory allocation requires information about where the pointers are located inside the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32de7cb2a746befc3519adabd406682f138c91dc" translate="yes" xml:space="preserve">
          <source>The encoding of the branch hint instruction limits the hint to be within 256 instructions of the branch it is affecting. By default, GCC makes sure it is within 125.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86931df671f82bbbca9166c366a69eb90410e2f2" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt;, if defined, non-empty and nonzero, implicitly enables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1abddc031f4887620e779e03fa9bce246eca769" translate="yes" xml:space="preserve">
          <source>The error is only generated if the pragma is present in the code after pre-processing has been completed. It does not matter however if the code containing the pragma is unreachable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62217b180fda693fac806123c3cedff899bcd7c2" translate="yes" xml:space="preserve">
          <source>The evaluation methods characterized by non-standard negative values of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; (C99 and C11 5.2.4.2.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ca0d5b7ee5cf7cc21b906f53631f0432c41aa1" translate="yes" xml:space="preserve">
          <source>The example above is correctly written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2262d7979d1e6f669d9d267628d7f1a5e043c047" translate="yes" xml:space="preserve">
          <source>The execution counts are cumulative. If the example program were executed again without removing the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30cd9cacada80b254b465216587c60514745e9e0" translate="yes" xml:space="preserve">
          <source>The exported header file declaring the function the user calls would contain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3b0d1b517a2735ccea32622e6c16bbe062c918" translate="yes" xml:space="preserve">
          <source>The extended version of &lt;code&gt;__builtin_expect&lt;/code&gt; is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f79933f130a6010408a53873b5c18d791196b0" translate="yes" xml:space="preserve">
          <source>The extended version of the ARMv7-A architecture with support for virtualization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69903151111d03e37009b513bcf8f14816a93e4" translate="yes" xml:space="preserve">
          <source>The extent to which suggestions made by using the &lt;code&gt;register&lt;/code&gt; storage-class specifier are effective (C90 6.5.1, C99 and C11 6.7.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d4acdb059ef7e8275eb6991f7b3fdb57cb4d7e" translate="yes" xml:space="preserve">
          <source>The extent to which suggestions made by using the inline function specifier are effective (C99 and C11 6.7.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1544009a06e2ed9b8c04313febbe4a5054a34c" translate="yes" xml:space="preserve">
          <source>The filename and replacement string escape backslash as &amp;ldquo;\\&quot;, tab as &amp;ldquo;\t&amp;rdquo;, newline as &amp;ldquo;\n&amp;rdquo;, double quotes as &amp;ldquo;\&quot;&amp;rdquo;, non-printable characters as octal (e.g. vertical tab as &amp;ldquo;\013&amp;rdquo;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052b9a9ce595b22df1664059ccb4ac71ceb3b652" translate="yes" xml:space="preserve">
          <source>The files used by gcov.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9146bf44aa8a552083fbcdde4f12b382de6ccc" translate="yes" xml:space="preserve">
          <source>The first argument is the address of the start of the current function, which may be looked up exactly in the symbol table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40b2392c804eafb9e2a38b040dcc6ad4b8a38cb" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;var&gt;auxv&lt;/var&gt;, is the address of an auxiliary register, the second argument, &lt;var&gt;val&lt;/var&gt;, is a compile time constant to be written to the register. Generates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb8468783d812fcfe3a90c5c3005fc31c3a8b43" translate="yes" xml:space="preserve">
          <source>The first built-in function allows arbitrary integral types for operands and the result type must be pointer to some integral type other than enumerated or boolean type, the rest of the built-in functions have explicit integer types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766dbe1354f0d010e9b9752b025269447d8bacdc" translate="yes" xml:space="preserve">
          <source>The first number on each line is the &amp;ldquo;user time&amp;rdquo;, that is time spent executing the program itself. The second number is &amp;ldquo;system time&amp;rdquo;, time spent executing operating system routines on behalf of the program. Both numbers are in seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7705a0a1f8fdbe72b6eed476ebaac5e4596393cb" translate="yes" xml:space="preserve">
          <source>The first operand is the number of a register to be written, the second operand is a compile time constant to write into that register. Generates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5403326826a0ff4e3670389f165daf4e08127b0b" translate="yes" xml:space="preserve">
          <source>The first step in using these extensions is to provide the necessary data types. This should be done using an appropriate &lt;code&gt;typedef&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0180fb5f9566434bbaf5187f78b901ca8a7ed3d8" translate="yes" xml:space="preserve">
          <source>The first two invocations to GCC save a bytecode representation of GIMPLE into special ELF sections inside</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7463018cc3efdf04fea2a1a9520f2dcaa8a917d" translate="yes" xml:space="preserve">
          <source>The fixed-point types are &lt;code&gt;short _Fract&lt;/code&gt;, &lt;code&gt;_Fract&lt;/code&gt;, &lt;code&gt;long _Fract&lt;/code&gt;, &lt;code&gt;long long _Fract&lt;/code&gt;, &lt;code&gt;unsigned short _Fract&lt;/code&gt;, &lt;code&gt;unsigned _Fract&lt;/code&gt;, &lt;code&gt;unsigned long _Fract&lt;/code&gt;, &lt;code&gt;unsigned long long _Fract&lt;/code&gt;, &lt;code&gt;_Sat short _Fract&lt;/code&gt;, &lt;code&gt;_Sat _Fract&lt;/code&gt;, &lt;code&gt;_Sat long _Fract&lt;/code&gt;, &lt;code&gt;_Sat long long _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned short _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned long _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned long long _Fract&lt;/code&gt;, &lt;code&gt;short _Accum&lt;/code&gt;, &lt;code&gt;_Accum&lt;/code&gt;, &lt;code&gt;long _Accum&lt;/code&gt;, &lt;code&gt;long long _Accum&lt;/code&gt;, &lt;code&gt;unsigned short _Accum&lt;/code&gt;, &lt;code&gt;unsigned _Accum&lt;/code&gt;, &lt;code&gt;unsigned long _Accum&lt;/code&gt;, &lt;code&gt;unsigned long long _Accum&lt;/code&gt;, &lt;code&gt;_Sat short _Accum&lt;/code&gt;, &lt;code&gt;_Sat _Accum&lt;/code&gt;, &lt;code&gt;_Sat long _Accum&lt;/code&gt;, &lt;code&gt;_Sat long long _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned short _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned long _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned long long _Accum&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3caefb409c9894c159fb9e3de06457a892f7b065" translate="yes" xml:space="preserve">
          <source>The flag makes these changes to GCC&amp;rsquo;s linkage model:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467579e58b2ed3f9e1f5da092ecc00a08220e553" translate="yes" xml:space="preserve">
          <source>The flag output constraints for the x86 family are of the form &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b70c97084691cff3ef37f7ca63544f38157171" translate="yes" xml:space="preserve">
          <source>The flags register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdec47de335eba5411aba4ed82b1290026a8b9df" translate="yes" xml:space="preserve">
          <source>The floating-point constant 0.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2c9b05e5630a06e86a36a4fbe950b6561191c6" translate="yes" xml:space="preserve">
          <source>The following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5af523cdaaa4e1970de9cf32fc6b6194b0929d" translate="yes" xml:space="preserve">
          <source>The following CPU names can be detected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f10647ac5c4280bde68061d0442176ac21bf7e2" translate="yes" xml:space="preserve">
          <source>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1929bf7289a9ecdc2dad5969b2604877133b0494" translate="yes" xml:space="preserve">
          <source>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 or later:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6e450e5b4547d8cc58a1ea785d39c551b41c7f" translate="yes" xml:space="preserve">
          <source>The following are a set of changes to ISO/IEC 14882:1998 (aka C++98) that document the exact semantics of the language extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973ba60cc5ca780083859b39f3e2346700d51250" translate="yes" xml:space="preserve">
          <source>The following are a set of changes to ISO/IEC 9899:1999 (aka C99) that document the exact semantics of the language extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebfbe098b1dd5eca0cbfbb3ca87cce639c317631" translate="yes" xml:space="preserve">
          <source>The following attributes are available on Microsoft Windows and Symbian OS targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d2d7b6e92a2c518243634b77f2438ea7a789b2" translate="yes" xml:space="preserve">
          <source>The following attributes are supported on most targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3abf3f6e4762f0945d50d1dadcf30c08d9bb36f" translate="yes" xml:space="preserve">
          <source>The following basic built-in functions require</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3618b6444ab4403d286bb790c65250955a9b750" translate="yes" xml:space="preserve">
          <source>The following basic built-in functions, which are also supported on x86 targets, require</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369096374260c4b128f072244e93419c1bf1630f" translate="yes" xml:space="preserve">
          <source>The following built-in function is always available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dad43e81aa335fef875c6f114a13ef9920a9d7" translate="yes" xml:space="preserve">
          <source>The following built-in function is available when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04398186d020848766aea5fdd0b1552e99124d98" translate="yes" xml:space="preserve">
          <source>The following built-in functions allow checking if simple arithmetic operation would overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c890e563c5fad880f7759533a175fe222845037" translate="yes" xml:space="preserve">
          <source>The following built-in functions allow performing simple arithmetic operations together with checking whether the operations overflowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036eb93cb5a048428c65535ab685e9ef099b6ed1" translate="yes" xml:space="preserve">
          <source>The following built-in functions approximately match the requirements for the C++11 memory model. They are all identified by being prefixed with &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf24977f571452f19f365486502e966dab5d0e9" translate="yes" xml:space="preserve">
          <source>The following built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2195469599cbd3dc33d7718d1e125824d6001b" translate="yes" xml:space="preserve">
          <source>The following built-in functions are also available on all PowerPC processors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813e5a763e7aaceeb023e2843416ac3c7a436f0e" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available and can be used to check the target platform type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a8ba0cceaa78de81b273be464b1e1bbe129653" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecfceed60efae2019076e7ea0c389384453f2603" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available. They all generate a Nios II Custom Instruction. The name of the function represents the types that the function takes and returns. The letter before the &lt;code&gt;n&lt;/code&gt; is the return type or void if absent. The &lt;code&gt;n&lt;/code&gt; represents the first parameter to all the custom instructions, the custom instruction number. The two letters after the &lt;code&gt;n&lt;/code&gt; represent the up to two parameters to the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af31ca0a6a69044f40261c9e3766a7bcb45f606" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available. They all generate the machine instruction that is part of the name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ff9df600bfad81ae439ad951e20e63358dbf59" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04c80c36791193b7507cbe8aa1b633c63c489df" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55e084e6b2bbe2c1d4a74d78f9b5a79a08af791" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available on Linux 64-bit systems that use the ISA 3.0 instruction set (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ee9c1229ed14f7445701a16ac0e8900c850fff" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available on systems that use the OSF/1 PALcode. Normally they invoke the &lt;code&gt;rduniq&lt;/code&gt; and &lt;code&gt;wruniq&lt;/code&gt; PAL calls, but when invoked with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74dd20c718ebc6e02b444b4df3b1293b7b777b2" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776fae37ac2c3903c04468f14c58000c2d1da4aa" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available when hardware decimal floating point (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8714301d00c50c02cc49a9653de9815ca07de516" translate="yes" xml:space="preserve">
          <source>The following built-in functions are changed to generate new SSE4.1 instructions when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44b1444a99a16bc850f8161bf3acb0269e3baa5" translate="yes" xml:space="preserve">
          <source>The following built-in functions are changed to generate new SSE4.2 instructions when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabb92d44c62afaf48fdd22b40e596e4fd090919" translate="yes" xml:space="preserve">
          <source>The following built-in functions are intended to be compatible with those described in the Intel Itanium Processor-specific Application Binary Interface, section 7.4. As such, they depart from normal GCC practice by not using the &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831ee0ed207b248768e0caf3e133139a3eef8c8d" translate="yes" xml:space="preserve">
          <source>The following built-in functions are made available by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919b7b433192dee8b53ccb79ce4649060e122b82" translate="yes" xml:space="preserve">
          <source>The following built-in functions are made available either with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ccb74ff52e53e43a5c01fd32034e69dc2ae153d" translate="yes" xml:space="preserve">
          <source>The following built-in functions are provided for ARC targets. The built-ins generate the corresponding assembly instructions. In the examples given below, the generated code often requires an operand or result to be in a register. Where necessary further code will be generated to ensure this is true, but for brevity this is not described in each case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e740a11dbfb99edbd20d26c1a8e83fccd42794" translate="yes" xml:space="preserve">
          <source>The following built-in functions are supported on the SH1, SH2, SH3 and SH4 families of processors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89feba67398daada2fcc2ab442cabeeabf1732a" translate="yes" xml:space="preserve">
          <source>The following built-in functions map directly to a particular MIPS DSP REV 2 instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21bc507e92bf45d2cc2ac3a1f9c044c10482e71" translate="yes" xml:space="preserve">
          <source>The following built-in functions map directly to a particular MIPS DSP instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9487d4f044e41716b6891b45e9753c6c90cda37" translate="yes" xml:space="preserve">
          <source>The following built-in spec functions are provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2786d4ea3cbfa4ab2030f517cdaa8499a49060e7" translate="yes" xml:space="preserve">
          <source>The following built-in vector functions are available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd16ee07975a361776687491f1d62adb24d9f69" translate="yes" xml:space="preserve">
          <source>The following code initializes a variable &lt;code&gt;pfoo&lt;/code&gt; located in static storage with a 24-bit address:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8780ef62a5e7e11e92254999b8a74301b194fac1" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a case where you need to use the &lt;code&gt;volatile&lt;/code&gt; qualifier. It uses the x86 &lt;code&gt;rdtsc&lt;/code&gt; instruction, which reads the computer&amp;rsquo;s time-stamp counter. Without the &lt;code&gt;volatile&lt;/code&gt; qualifier, the optimizers might assume that the &lt;code&gt;asm&lt;/code&gt; block will always return the same value and therefore optimize away the second call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b55ceed13d64aeb896ca2cdaff9ea36b6ca968e" translate="yes" xml:space="preserve">
          <source>The following example shows an &lt;code&gt;asm goto&lt;/code&gt; that uses a memory clobber.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff7cf2e98d1cdb33c85dfebf8c45ca797099418" translate="yes" xml:space="preserve">
          <source>The following examples are all valid uses of these attributes on Epiphany targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133fac7dc52d4be5d02e2ee9f610bd07e27fcb98" translate="yes" xml:space="preserve">
          <source>The following extension options are common to the listed CPUs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585cd94a6c81e37ef942855a4e92760bf2aec5f9" translate="yes" xml:space="preserve">
          <source>The following features can be detected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbf90dbd434ca4f2150e22b1aa4b1a78b14c334" translate="yes" xml:space="preserve">
          <source>The following floating-point built-in functions are always available. All of them implement the function that is part of the name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1be7f4828f104915bab6627d884213aaa11c9fc" translate="yes" xml:space="preserve">
          <source>The following functions require</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31dedf0887f3cce8587f9fc85d3da325ab3058ce" translate="yes" xml:space="preserve">
          <source>The following functions require option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f640e02367945c84624ea0fa79ae818fc5491bf9" translate="yes" xml:space="preserve">
          <source>The following high level HTM interface is made available by including &lt;code&gt;&amp;lt;htmxlintrin.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102c1a366ea24351d92a6971e3810fc18f2df2f4" translate="yes" xml:space="preserve">
          <source>The following i386 example uses the &lt;var&gt;asmSymbolicName&lt;/var&gt; syntax. It produces the same result as the code above, but some may consider it more readable or more maintainable since reordering index numbers is not necessary when adding or removing operands. The names &lt;code&gt;aIndex&lt;/code&gt; and &lt;code&gt;aMask&lt;/code&gt; are only used in this example to emphasize which names get used where. It is acceptable to reuse the names &lt;code&gt;Index&lt;/code&gt; and &lt;code&gt;Mask&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e6249e0b2946138511bcb4a6acddccaf21d75a" translate="yes" xml:space="preserve">
          <source>The following interfaces are supported for the generic and specific AltiVec operations and the AltiVec predicates. In cases where there is a direct mapping between generic and specific operations, only the generic names are shown here, although the specific operations can also be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641482ab6aae43e810063e867385af29b325d058" translate="yes" xml:space="preserve">
          <source>The following is a complete list of all the SIMD built-ins provided for ARC, grouped by calling signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59aaf754b53dd8275d60f36863885f1f7f538958" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved for concepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea9055e3c282c50c68c6d2aeac0047e44355ae3" translate="yes" xml:space="preserve">
          <source>The following language-independent options do not enable specific warnings but control the kinds of diagnostics produced by GCC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f20c0f07be1621f3a5ece2a524e2a15cb445a2" translate="yes" xml:space="preserve">
          <source>The following low level built-in functions are available with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73379da25dc8349b928d96eecb55babb0495892" translate="yes" xml:space="preserve">
          <source>The following machine modes are available for use with MMX built-in functions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;): &lt;code&gt;V2SI&lt;/code&gt; for a vector of two 32-bit integers, &lt;code&gt;V4HI&lt;/code&gt; for a vector of four 16-bit integers, and &lt;code&gt;V8QI&lt;/code&gt; for a vector of eight 8-bit integers. Some of the built-in functions operate on MMX registers as a whole 64-bit entity, these use &lt;code&gt;V1DI&lt;/code&gt; as their mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf3a8e89705f68be72e746786d162672425cfef" translate="yes" xml:space="preserve">
          <source>The following multi-instruction functions are also available. In each case, &lt;var&gt;cond&lt;/var&gt; can be any of the 16 floating-point conditions: &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;un&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ueq&lt;/code&gt;, &lt;code&gt;olt&lt;/code&gt;, &lt;code&gt;ult&lt;/code&gt;, &lt;code&gt;ole&lt;/code&gt;, &lt;code&gt;ule&lt;/code&gt;, &lt;code&gt;sf&lt;/code&gt;, &lt;code&gt;ngle&lt;/code&gt;, &lt;code&gt;seq&lt;/code&gt;, &lt;code&gt;ngl&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;nge&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt; or &lt;code&gt;ngt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0ee4cac44eb1ea6ef3d346a27ca60807cc0101" translate="yes" xml:space="preserve">
          <source>The following option controls the dump verbosity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb8267f4643a3a1e1226701a4af5aa70991f141" translate="yes" xml:space="preserve">
          <source>The following options are enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ad9c293f6f20ff40e11231422dcfe5f5c7994f" translate="yes" xml:space="preserve">
          <source>The following options are maintained for backward compatibility, but are now deprecated and will be removed in a future release:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830e32827e2b8144f32b52b0121c8d7081e1b6a0" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the assembler, and also define preprocessor macro symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3893bff29544ccfaa517cc2326f9ca49c8a38aa9" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the linker:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c36d7938f4b3037d603daaacf0e18dc02039404" translate="yes" xml:space="preserve">
          <source>The following options control compiler behavior regarding floating-point arithmetic. These options trade off between speed and correctness. All must be specifically enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86976c9ace4c113da10573eddefe715e4cb2f672" translate="yes" xml:space="preserve">
          <source>The following options control how the assembly code is annotated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f279a10a5e010786a9e225f2aacc08d5d8248b" translate="yes" xml:space="preserve">
          <source>The following options control optimizations that may improve performance, but are not enabled by any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55fd5087fff35ad2ed3317068955b447140094de" translate="yes" xml:space="preserve">
          <source>The following options control specific optimizations. They are either activated by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75b9b815cb70c1acb6a0a4fa3f69dee634495bb" translate="yes" xml:space="preserve">
          <source>The following options control the architecture variant for which code is being compiled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d7d28f2f9b185e45e491d2e2f8457796b4ee30" translate="yes" xml:space="preserve">
          <source>The following options control the dialect of C (or languages derived from C, such as C++, Objective-C and Objective-C++) that the compiler accepts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813aeaa760a029b92e3d877fed33fc8e7a96dc7f" translate="yes" xml:space="preserve">
          <source>The following options control the semantics of generated code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3598ddb012ba205521fc6ee02e575b5bc46a933" translate="yes" xml:space="preserve">
          <source>The following options control which kinds of messages should be emitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d212367144c7ffb5256031004f3dbec4705f316" translate="yes" xml:space="preserve">
          <source>The following options fine tune code generation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e686313bb7d2bb5ed9fc2b2f596d5d6ba9508b34" translate="yes" xml:space="preserve">
          <source>The following paired-single functions map directly to a particular MIPS instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31f26e42333950d2b2ffa071557eac8358219f6" translate="yes" xml:space="preserve">
          <source>The following pragmas are available for all architectures running the Darwin operating system. These are useful for compatibility with other Mac OS compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5efd4f1d1fe7f21c34100607d9ffdb85cb1ed570" translate="yes" xml:space="preserve">
          <source>The following set of built-in functions are available to gain access to the HTM specific special purpose registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe37409b5b6fb37c45d0db10dbe34cd37d4dfd29" translate="yes" xml:space="preserve">
          <source>The following statements are identical:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c95f76a6048996b1dcedbb4002de26c05b62460" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and three &lt;code&gt;int&lt;/code&gt; arguments and return no result. The second argument must be a 3-bit compile-time constant, identifying the 16-bit sub-register to be stored, the third argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the fourth argument must be an 8-bit compile time constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da4f813451b70864b4ac68a9c6bb25ff058833e" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and two &lt;code&gt;int&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result. The second argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the third argument must be an 8-bit compile time constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="559f51894eceb199907d056ff4f4a6285c76d1d1" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and two &lt;code&gt;int&lt;/code&gt; arguments and return no result. The second argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the third argument must be an 8-bit compile time constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19babaec618194855f5c8b00e66e42a23a7c9b80" translate="yes" xml:space="preserve">
          <source>The following take a single &lt;code&gt;__v8hi&lt;/code&gt; argument and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b4a9f9391a5e9fb5aa4cf91d4033a4a1ba3911" translate="yes" xml:space="preserve">
          <source>The following take an &lt;code&gt;int&lt;/code&gt; argument and return no result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1708876febe0e46c893dfd70681ac1b1b3aa8762" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; and one &lt;code&gt;int&lt;/code&gt; argument and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad9bd81f972d4f83266bbddb59970dde24eddc0" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 3-bit compile time constant indicating a register number I0-I7. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2a1ecceb07161357bd0a5bf4b1cca5ccc19add" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 6-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c720afe018ece35380697d65f42b49460f2c3700" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 8-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0015b52d89388ff44035be55e55280be0b4aaeb6" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;__v8hi&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="074063c3bbf2515afebb90aeb39ce860c2e31da4" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result. The first argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the second argument must be an 8-bit compile time constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b1b82914edb80d2ca00848561437d84a1f1eb2" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return no result. The first argument must a 3-bit compile time constant indicating one of the DR0-DR7 DMA setup channels:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c057c170ec53d564774b373c4a36cf121034de" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return no result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73d90b3764a03700faea9b5a80499c3a3c6ee74" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments, the second of which which must be a 8-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7604a9689ceddf3a88ac390cfb640c35daa9929f" translate="yes" xml:space="preserve">
          <source>The following target-specific function attributes are available for the AArch64 target. For the most part, these options mirror the behavior of similar command-line options (see &lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64 Options&lt;/a&gt;), but on a per-function basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9dcb7afea2063b88c3f0d0bf8b210d678cf434" translate="yes" xml:space="preserve">
          <source>The following type attributes are supported on most targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea3e81960cea1d06fa9fca33b75a29a1d4f2d4a" translate="yes" xml:space="preserve">
          <source>The following values of &lt;var&gt;insn&lt;/var&gt; are supported. Except as otherwise noted, floating-point operations are expected to be implemented with normal IEEE 754 semantics and correspond directly to the C operators or the equivalent GCC built-in functions (see &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da10b4f1472639ab267cde98b6118ed2bb143912" translate="yes" xml:space="preserve">
          <source>The formats are checked against the format features supported by GNU libc version 2.2. These include all ISO C90 and C99 features, as well as features from the Single Unix Specification and some BSD and GNU extensions. Other library implementations may not support all these features; GCC does not support warning about features that go beyond a particular library&amp;rsquo;s limitations. However, if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd329b7b6e510f8c7f38ab04501976f2c6f4c71" translate="yes" xml:space="preserve">
          <source>The forwarding method implementation thus created is returned by &lt;code&gt;objc_msg_lookup()&lt;/code&gt; and is executed as if it was a normal method implementation. When the forwarding method implementation is called, it is usually expected to pack all arguments into some sort of object (typically, an &lt;code&gt;NSInvocation&lt;/code&gt; in a &amp;ldquo;Foundation&amp;rdquo; library), and hand it over to the programmer (&lt;code&gt;forwardInvocation:&lt;/code&gt;) who is then allowed to manipulate the method invocation using a high-level API provided by the &amp;ldquo;Foundation&amp;rdquo; library. For example, the programmer may want to examine the method invocation arguments and name and potentially change them before forwarding the method invocation to one or more local objects (&lt;code&gt;performInvocation:&lt;/code&gt;) or even to remote objects (by using Distributed Objects or some other mechanism). When all this completes, the return value is passed back and must be returned correctly to the original caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370cce3123cd6103545b49952aa7ecfe80d28686" translate="yes" xml:space="preserve">
          <source>The four non-arithmetic functions (load, store, exchange, and compare_exchange) all have a generic version as well. This generic version works on any data type. It uses the lock-free built-in function if the specific data type size makes that possible; otherwise, an external call is left to be resolved at run time. This external call is the same format with the addition of a &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7082dbfb46d172471e10794421761522292732" translate="yes" xml:space="preserve">
          <source>The frame is the area on the stack that holds local variables and saved registers. The frame address is normally the address of the first word pushed on to the stack by the function. However, the exact definition depends upon the processor and the calling convention. If the processor has a dedicated frame pointer register, and the function has a frame, then &lt;code&gt;__builtin_frame_address&lt;/code&gt; returns the value of the frame pointer register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91be25b4a97f2d4dcdca61df07841207c68074ea" translate="yes" xml:space="preserve">
          <source>The front end also exposes a number of internal mechanism that can be used to simplify the writing of type traits. Note that some of these traits are likely to be removed in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0002fd6e851a03368550f6c8393985028e5a22a9" translate="yes" xml:space="preserve">
          <source>The function may cause execution to pause until it is known that the code is no-longer being executed speculatively (in which case &lt;var&gt;val&lt;/var&gt; can be returned, as above); or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c285a5c6cfe9015607ff4a0e2ac733ad987d0e25" translate="yes" xml:space="preserve">
          <source>The function may use target-dependent speculation tracking state to cause &lt;var&gt;failval&lt;/var&gt; to be returned when it is known that speculative execution has incorrectly predicted a conditional branch operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1910cbf4d249572210143c348f1416c66e710621" translate="yes" xml:space="preserve">
          <source>The function parameter denoting the allocated alignment is specified by one constant integer argument whose number is the argument of the attribute. Argument numbering starts at one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b052040572f76188271e0e3e0c80c35be66f2c8" translate="yes" xml:space="preserve">
          <source>The function parameter(s) denoting the allocated size are specified by one or two integer arguments supplied to the attribute. The allocated size is either the value of the single function argument specified or the product of the two function arguments specified. Argument numbering starts at one for ordinary functions, and at two for C++ non-static member functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca979696b9a2800aa34523d4083bf5a14d799aa" translate="yes" xml:space="preserve">
          <source>The function saves the arg pointer register, structure value address, and all registers that might be used to pass arguments to a function into a block of memory allocated on the stack. Then it returns the address of that block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6872e4d72d8fbbd9743faadfaad51d5d8e08d8dc" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to FR-V I-type instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c602f6bdf5c7225fe620c26f84e8de50c7071a07" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to FR-V M-type instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d757b37f17b7bb17dc67a24428e9f56b268f5c5e" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to a particular MIPS-3D instruction. Please refer to the architecture specification for more details on what each instruction does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636b8102a37675bf78355f0f6bba2ff462438334" translate="yes" xml:space="preserve">
          <source>The functions supported are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7023ac286f3db88bfb11b7cae18fc097b31af2" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point data processing instructions. This also enables the Advanced SIMD and floating-point instructions as well as the Dot Product extension and the half-precision floating-point fmla extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f4f715483c2871dde2ce2ca0d2db8aca84c869" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point data processing instructions. This also enables the Advanced SIMD and floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11520bb64917989439d0bd1e50b448954652e968" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point fmla extension. This also enables the half-precision floating-point extension and Advanced SIMD and floating-point instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd47b9fa117c203d0b4afbba7a0a4bc59d68406" translate="yes" xml:space="preserve">
          <source>The hardware multiply routines disable interrupts whilst running and restore the previous interrupt state when they finish. This makes them safe to use inside interrupt handlers as well as in normal code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1700f28ed95fcc91e5f3613066db6eabb50e9b1f" translate="yes" xml:space="preserve">
          <source>The header files contain detailed documentation for each function in the GNU Objective-C runtime API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef3ae0649be61ff8ea14c16eb476e462ede9be4" translate="yes" xml:space="preserve">
          <source>The high part (bits 12 and upwards) of the pc-relative address of a symbol within 4GB of the instruction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0d4a97e0e09b3d462961a102c172f60bf94df3" translate="yes" xml:space="preserve">
          <source>The iWMMX GR registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad23a41b556be75b4554217ab7b7da89d6570d2" translate="yes" xml:space="preserve">
          <source>The iWMMX co-processor registers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46a70e92f765a7f4dbecade6890d0ae606db8e1" translate="yes" xml:space="preserve">
          <source>The idea behind this is that sometimes it is convenient (for the programmer) to consider floating-point values as approximations to infinitely precise real numbers. If you are doing this, then you need to compute (by analyzing the code, or in some other way) the maximum or likely maximum error that the computation introduces, and allow for it when performing comparisons (and when producing output, but that&amp;rsquo;s a different problem). In particular, instead of testing for equality, you should check to see whether the two values have ranges that overlap; and this is done with the relational operators, so equality comparisons are probably mistaken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a98af2de248cc10c278826d9411559e39eee26" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;__func__&lt;/code&gt; is implicitly declared by the translator as if, immediately following the opening brace of each function definition, the declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13fbfb86cc636b25b4f8dbf9788be6becd2407c7" translate="yes" xml:space="preserve">
          <source>The immediate value 0x01.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52de78dd0ef761fa638ed2df23930f5359ca4c01" translate="yes" xml:space="preserve">
          <source>The immediate value 0x7ff.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178295c2520a8328225a3e14f6430b205aa477b7" translate="yes" xml:space="preserve">
          <source>The immediate value 0xff.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba38c21b26ea7ac3618ca4682f483633c0168822" translate="yes" xml:space="preserve">
          <source>The immediate value 0xffff.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3edc2d2bcd9f411eb9c02f201cf5906b594ce1b" translate="yes" xml:space="preserve">
          <source>The immediate value that can be simply set high 20-bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b3ce3b975ce4bb65c0a8ad20428b556134b6e5" translate="yes" xml:space="preserve">
          <source>The immediate value with power of 2 minus 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdad57dc1c93e8c86249089910e5d64e47612ed8" translate="yes" xml:space="preserve">
          <source>The immediate value with power of 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292bc2fc3bad9eb92ff6853193b506ffc6d78c40" translate="yes" xml:space="preserve">
          <source>The impacted functions are determined by the compiler&amp;rsquo;s interprocedural optimizations. For example, a caller is impacted when inlining a function into its caller, cloning a function and changing its caller to call this new clone, or extracting a function&amp;rsquo;s pureness/constness information to optimize its direct or indirect callers, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788e9c101326291dabb53f85af22d398e9b836ec" translate="yes" xml:space="preserve">
          <source>The implementation of messaging in the GNU Objective-C runtime is designed to be portable, and so is based on standard C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de99bcf5ddd6a719a8ac7733daede651bd9f548" translate="yes" xml:space="preserve">
          <source>The important thing to keep in mind is that to enable link-time optimizations you need to use the GCC driver to perform the link step. GCC automatically performs link-time optimization if any of the objects involved were compiled with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2b4fb08fe8eee4956db02cb6f8d3c3fb54b6e4" translate="yes" xml:space="preserve">
          <source>The index values must be constant expressions, even if the array being initialized is automatic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20238db563baf6821f8bed87f8777e30be3fd316" translate="yes" xml:space="preserve">
          <source>The induction variable optimizations give up on loops that contain more induction variable uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b9ae56dc4f69f455cd2846f1efc86548a4f0b0" translate="yes" xml:space="preserve">
          <source>The instructions generated by the following builtins are not considered as candidates for scheduling. They are not moved around by the compiler during scheduling, and thus can be expected to appear where they are put in the C code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0143a1fa40596d46b920e516a49bccafb05c6756" translate="yes" xml:space="preserve">
          <source>The integer constant -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0304e4a19fa9d570fa64154ef073c85be9e9d234" translate="yes" xml:space="preserve">
          <source>The integer constant -2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20219359f9654d4bb60ad841282922f1407f31ff" translate="yes" xml:space="preserve">
          <source>The integer constant 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b9a3c5e77c93a53f2664cad25c5af25a563160" translate="yes" xml:space="preserve">
          <source>The integer constant 0xffffffff.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0900ba8234ff692dd368ac2562960d9c24b87490" translate="yes" xml:space="preserve">
          <source>The integer constant 0xffffffff00000000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1704120ef6a8406a0d73d119b3bae3d2fd6db0c7" translate="yes" xml:space="preserve">
          <source>The integer constant 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7733e70947e25f6ba4f15b855fbc6bb56230e77" translate="yes" xml:space="preserve">
          <source>The integer constant 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e4afdbd5f6f64969b9a9086ed5845106d1e1df4" translate="yes" xml:space="preserve">
          <source>The integer type compatible with each enumerated type (C90 6.5.2.2, C99 and C11 6.7.2.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f4c82404325b1bedf2b678bda8824c1372dc16" translate="yes" xml:space="preserve">
          <source>The integer zero constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5eb05da6eb2941255dd1f24db7755004fe0fb6" translate="yes" xml:space="preserve">
          <source>The intended use can be e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec03e559122067c46321a3d23e2fe242aaa628b" translate="yes" xml:space="preserve">
          <source>The intrinsic &lt;code&gt;void __tile_network_barrier (void)&lt;/code&gt; is used to guarantee that no network operations before it are reordered with those after it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b326f68cedc113119b7cfc329617004f7ca5d0f" translate="yes" xml:space="preserve">
          <source>The intrinsics provided are listed below; each is named after the machine instruction to which it corresponds, with suffixes added as appropriate to distinguish intrinsics that expand to the same machine instruction yet have different argument types. Refer to the architecture documentation for a description of the functionality of each instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0e26ddf5eff18eeea3fbd0b9d1cb136b8b4213" translate="yes" xml:space="preserve">
          <source>The intrinsics provided are listed below; each is named after the machine instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eef6d5321de2f795448068015c7c54f1ed1296f" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;@compatibility_alias&lt;/code&gt; allows you to define a class name as equivalent to another class name. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae34f2a2b2a52f07242474e58c01e8458c373a3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__alignof__&lt;/code&gt; determines the alignment requirement of a function, object, or a type, or the minimum alignment usually required by a type. Its syntax is just like &lt;code&gt;sizeof&lt;/code&gt; and C11 &lt;code&gt;_Alignof&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e11754fcd951a085d6544dab003aaba8cd78a6c" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__attribute__&lt;/code&gt; allows you to specify special properties of variables, function parameters, or structure, union, and, in C++, class members. This &lt;code&gt;__attribute__&lt;/code&gt; keyword is followed by an attribute specification enclosed in double parentheses. Some attributes are currently defined generically for variables. Other attributes are defined for variables on particular target systems. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;). Other front ends might define more attributes (see &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Extensions to the C++ Language&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4cf059503889f054506ae99e86330f0d94efc6c" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__attribute__&lt;/code&gt; allows you to specify various special properties of types. Some type attributes apply only to structure and union types, and in C++, also class types, while others can apply to any type defined via a &lt;code&gt;typedef&lt;/code&gt; declaration. Unless otherwise specified, the same restrictions and effects apply to attributes regardless of whether a type is a trivial structure or a C++ class with user-defined constructors, destructors, or a copy assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1572dc96be7f5e014878efc69fdfd49b0ae87eea" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__thread&lt;/code&gt; applied to a non-local object gives the object thread storage duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b19603ff8ee793099ac42a05990562491ebaf2" translate="yes" xml:space="preserve">
          <source>The label declaration defines the label &lt;em&gt;name&lt;/em&gt;, but does not define the label itself. You must do this in the usual way, with &lt;code&gt;&lt;var&gt;label&lt;/var&gt;:&lt;/code&gt;, within the statements of the statement expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428f4e4c9e8e6a37b249e009bb97c82a44c2fb8f" translate="yes" xml:space="preserve">
          <source>The language-independent component of GCC includes the majority of the optimizers, as well as the &amp;ldquo;back ends&amp;rdquo; that generate machine code for various processors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005fac6b181ca927cb2a738c000f5da953afe1b7" translate="yes" xml:space="preserve">
          <source>The last thing in the compound statement should be an expression followed by a semicolon; the value of this subexpression serves as the value of the entire construct. (If you use some other kind of statement last within the braces, the construct has type &lt;code&gt;void&lt;/code&gt;, and thus effectively no value.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206e1d46d7d3ee120b67ca48c1a3f104346b70ef" translate="yes" xml:space="preserve">
          <source>The length of an array is computed once when the storage is allocated and is remembered for the scope of the array in case you access it with &lt;code&gt;sizeof&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce058b55eed72e669ebdbd6e3aba9093499b97c5" translate="yes" xml:space="preserve">
          <source>The letters represent the following data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77263b459d57cfcd71f0acd14e32e54e7be714c9" translate="yes" xml:space="preserve">
          <source>The lifetime of a compiler generated temporary is well defined by the C++ standard. When a lifetime of a temporary ends, and if the temporary lives in memory, the optimizing compiler has the freedom to reuse its stack space with other temporaries or scoped local variables whose live range does not overlap with it. However some of the legacy code relies on the behavior of older compilers in which temporaries&amp;rsquo; stack space is not reused, the aggressive stack reuse can lead to runtime errors. This option is used to control the temporary stack reuse optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499ee472bf57c8d5ea52c4b866109362dfcc7841" translate="yes" xml:space="preserve">
          <source>The limit applies &lt;em&gt;after&lt;/em&gt; string constant concatenation, and does not count the trailing NUL. In C90, the limit was 509 characters; in C99, it was raised to 4095. C++98 does not specify a normative minimum maximum, so we do not diagnose overlength strings in C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c688d4fc373af85820537cf244755f93f3571e" translate="yes" xml:space="preserve">
          <source>The limit specifying large stack frames. While inlining the algorithm is trying to not grow past this limit too much.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f90ab304447934cd7fe1bd66dac4bb5697c076" translate="yes" xml:space="preserve">
          <source>The limit specifying large translation unit. Growth caused by inlining of units larger than this limit is limited by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24d66aaeb77b8d51a696a30383b9a88d8d0ffec4" translate="yes" xml:space="preserve">
          <source>The limit specifying really large functions. For functions larger than this limit after inlining, inlining is constrained by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f2bb016c8b0766650946224b7ac36870093175" translate="yes" xml:space="preserve">
          <source>The linker searches a standard list of directories for the library. The directories searched include several standard system directories plus any that you specify with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e4e4eb1e36ecbe1ce8c7bd81da2158dd82d6a9" translate="yes" xml:space="preserve">
          <source>The loader for SPU does not handle dynamic relocations. By default, GCC gives an error when it generates code that requires a dynamic relocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168977c575f70c81d88c067d5911fa44bdb4a1dc" translate="yes" xml:space="preserve">
          <source>The local label feature is useful for complex macros. If a macro contains nested loops, a &lt;code&gt;goto&lt;/code&gt; can be useful for breaking out of them. However, an ordinary label whose scope is the whole function cannot be used: if the macro can be expanded several times in one function, the label is multiply defined in that function. A local label avoids this problem. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40c92db025f666809a32030712abb46e10389b2" translate="yes" xml:space="preserve">
          <source>The location is expressed as a half-open range, expressed as a count of bytes, starting at byte 1 for the initial column. In the above example, bytes 3 through 20 of line 45 of &amp;ldquo;test.c&amp;rdquo; are to be replaced with the given string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068a4b98cf23f1dbecfe9f83dd38994bfe05765c" translate="yes" xml:space="preserve">
          <source>The locations within &lt;code&gt;#pragma&lt;/code&gt; directives where header name preprocessing tokens are recognized (C11 6.4, C11 6.4.7).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6965c74c684a5066713cd45514db9bb14c9963" translate="yes" xml:space="preserve">
          <source>The long long types are only implemented for 64-bit code generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b21e2c583138d02ccff65c0acb02831c06a2211" translate="yes" xml:space="preserve">
          <source>The low registers r0 - r15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed4899b603c3d7a32aa6ba260f62f9b063dd80a8" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;__CET__&lt;/code&gt; is defined when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835cec1112f64c57bd44cb4fd1c6251993152130" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; is predefined when the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af0e1087a3dafe7b329598208d0e7bd6efe70c3" translate="yes" xml:space="preserve">
          <source>The main use case of the built-in is to determine whether a &lt;code&gt;constexpr&lt;/code&gt; function is being called in a &lt;code&gt;constexpr&lt;/code&gt; context. A call to the function evaluates to a core constant expression with the value &lt;code&gt;true&lt;/code&gt; if and only if it occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated as defined in the C++ standard. Manifestly constant-evaluated contexts include constant-expressions, the conditions of &lt;code&gt;constexpr if&lt;/code&gt; statements, constraint-expressions, and initializers of variables usable in constant expressions. For more details refer to the latest revision of the C++ standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44703f46619b4bb3387fbb3a9a4987ca25838ebf" translate="yes" xml:space="preserve">
          <source>The mangling was changed in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f9d67774b219fd5194ad2624b61ab77f3088cf" translate="yes" xml:space="preserve">
          <source>The mapping between physical source file multibyte characters and the source character set in translation phase 1 (C90, C99 and C11 5.1.1.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63322b3a774c9974339e8944410fb9a8c6f8ebf4" translate="yes" xml:space="preserve">
          <source>The mapping of members of the source character set (in character constants and string literals) to members of the execution character set (C90 6.1.3.4, C99 and C11 6.4.4.4, C90, C99 and C11 5.1.1.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc3864d5e277c6ac4690c5e9d3fdbf817cb1a7c" translate="yes" xml:space="preserve">
          <source>The max number of reload pseudos which are considered during spilling a non-reload pseudo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f47dce047d8beaa87edf8a1fdc1bf827620a7f2" translate="yes" xml:space="preserve">
          <source>The maximum alignment for SIMD vector mode types. &lt;var&gt;num&lt;/var&gt; may be 4 or 8. The default is 8. Note that this is an ABI change, even though many library function interfaces are unaffected if they don&amp;rsquo;t use SIMD vector modes in places that affect size and/or alignment of relevant types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666ee1692153a86b3ec75a197326eda3a0d60489" translate="yes" xml:space="preserve">
          <source>The maximum amount of iterations of the pass over the function. This is used to limit compilation time in tree tail merging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ecfe4db21e974dbc1daddf5e580b9450304991" translate="yes" xml:space="preserve">
          <source>The maximum amount of similar bbs to compare a bb with. This is used to avoid quadratic behavior in tree tail merging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6556ebb0621924348132da881ea97c1a248f5ac" translate="yes" xml:space="preserve">
          <source>The maximum code size expansion factor when copying basic blocks instead of jumping. The expansion is relative to a jump instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936a590636d845b92624c7728a4827fce9d92d06" translate="yes" xml:space="preserve">
          <source>The maximum conflict delay for an insn to be considered for speculative motion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb7200dcbf807a75160beecc432fa62ed3e9728" translate="yes" xml:space="preserve">
          <source>The maximum depth of a loop nest suitable for complete peeling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a797ef806eaaf765b7a781b669b0a1ee2786d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursive inlining for non-inline functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b08dcc7587be3ab6eef2848d7ad81b5a152655" translate="yes" xml:space="preserve">
          <source>The maximum length of a constant string for a builtin string cmp call eligible for inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e85e4670d6f7ac0961160fd225824b117f4e1d" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;case&lt;/code&gt; values in a &lt;code&gt;switch&lt;/code&gt; statement (C90 6.6.4.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2afaa6d3ae61c2d6492935df7934433f87eae8" translate="yes" xml:space="preserve">
          <source>The maximum number of SSA_NAME assignments to follow in determining a property of a variable such as its value. This limits the number of iterations or recursive calls GCC performs when optimizing certain statements or when determining their validity prior to issuing diagnostics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfdd5d91556b4dd893a62b6a75874eee03cf513" translate="yes" xml:space="preserve">
          <source>The maximum number of assertions to add along the default edge of a switch statement during VRP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e6bc4dbd514d325e3c749eca0229393e1fb788" translate="yes" xml:space="preserve">
          <source>The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop. Larger values can exponentially increase compilation time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018c7375a2caf17039c26fd694620cad7ebfaa5f" translate="yes" xml:space="preserve">
          <source>The maximum number of basic blocks on path that CSE considers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79967caf66fa10b13e953918175f64b9fd85351" translate="yes" xml:space="preserve">
          <source>The maximum number of best instructions in the ready list that are considered for renaming in the selective scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a02e3d5ce6c0b561178810954860635f75b277" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks in a region to be considered for interblock scheduling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3225f5aa45adb6a455e07adb58dbc4331ca98962" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks in a region to be considered for pipelining in the selective scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26d722dd2f733f712aeb0f605ec58066091d632" translate="yes" xml:space="preserve">
          <source>The maximum number of branches on the hot path through the peeled sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fe875bfce475e08e430e98ccc72ad1afca879e" translate="yes" xml:space="preserve">
          <source>The maximum number of branches unswitched in a single loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9965c595ccb073bed98dc2ae6e76b73f1d6e9fe2" translate="yes" xml:space="preserve">
          <source>The maximum number of conditional store pairs that can be sunk. Set to 0 if either vectorization (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126cc6769740c4d71bac9ace9af0b249f19d3967" translate="yes" xml:space="preserve">
          <source>The maximum number of declarators that may modify an arithmetic, structure or union type (C90 6.5.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046b54d8dec00a923499bbe98f2011a4caa2c4d1" translate="yes" xml:space="preserve">
          <source>The maximum number of incoming edges to consider for cross-jumping. The algorithm used by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23db9a7b1aa156bfdeb79b1a74ceb92745f99df4" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in a region to be considered for interblock scheduling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64755c0a10d7b896808172cc7335112d4911d239" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in a region to be considered for pipelining in the selective scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7549b9d59e547801a424f6394451c0c5eb284456" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in loop header duplicated by the copy loop headers pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557a1591041c896c87813c7c44591df470e1d549" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of a completely peeled loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e77354bbeeb82418d9ce51f0cd208bdb1bdb528" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of a peeled loop that rolls only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1366f0a190b8fba2e81ce94bc72ef8becba23f7" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of an unswitched loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7612b99e9ada1082074daa96e9458c5473af04" translate="yes" xml:space="preserve">
          <source>The maximum number of instruction reload should look backward for equivalent register. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9005923e6a32b4692818d139c898763d96182dda" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions CSE processes before flushing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f4ccd7bf5ad2020d3e593506c55f6c162a5002" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions biased by probabilities of their execution that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6459fa6f8aa47f72deca9d3c9064156b11b3b7ad" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions non-inline function can grow to via recursive inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f088738722ed99797643c1cd7fd24995b8cb099a" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions ready to be issued the scheduler should consider at any given time during the first scheduling pass. Increasing values mean more thorough searches, making the compilation time increase with probably little benefit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751361661372b9f65beccbd7de6c9e13c4fb111d" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that a loop may have to be peeled. If a loop is peeled, this parameter also determines how many times the loop code is peeled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7edf4c141bc3a24bbf2d50e04de689b5700fa130" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c3a913df725fc3842845c874668062bf683170" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that an inner loop can have before the loop versioning pass considers it too big to copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0347a5207a00a0a94142de3b1cb1207696bb8750" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that an outer loop can have before the loop versioning pass considers it too big to copy, discounting any instructions in inner loops that directly benefit from versioning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3296c189a6eb29be66f9d755ea47f2387ef49d" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions the RTL combiner tries to combine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3b05a5fc34087d71a21bfbdc9daebc782fc835" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions to consider when looking for an instruction to fill a delay slot. If more than this arbitrary number of instructions are searched, the time savings from filling the delay slot are minimal, so stop searching. Increasing values mean more aggressive optimization, making the compilation time increase with probably small improvement in execution time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5be3b82586aa080f1846e1d109f72232bc815fe" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions to duplicate to a block that jumps to a computed goto. To avoid &lt;em&gt;O(N^2)&lt;/em&gt; behavior in a number of passes, GCC factors computed gotos early in the compilation process, and unfactors them as late as possible. Only computed jumps at the end of a basic blocks with no more than max-goto-duplication-insns are unfactored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f826bd5a9f2e555af6e39cc55fa38f4c63598849" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations of a loop the brute-force algorithm for analysis of the number of iterations of the loop tries to evaluate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827bc9985068a19acb40103212322373c4817b20" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations of a loop to be suitable for complete peeling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed380824467ca338cf023f1dcb3f2de07822555" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations through CFG to extend regions. A value of 0 disables region extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4fe5f590fb9f1538c537c1032bfe7e933f8b30" translate="yes" xml:space="preserve">
          <source>The maximum number of loop iterations we predict statically. This is useful in cases where a function contains a single loop with known bound and another loop with unknown bound. The known number of iterations is predicted correctly, while the unknown number of iterations average to roughly 10. This means that the loop without bounds appears artificially cold relative to the other one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4f0955c671eedabc4872cd4110ae5643c1e035" translate="yes" xml:space="preserve">
          <source>The maximum number of loop peels to enhance access alignment for vectorizer. Value -1 means no limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a4d50649a3963909b22c32025925dae63b4133" translate="yes" xml:space="preserve">
          <source>The maximum number of may-defs we analyze when looking for a must-def specifying the dynamic type of an object that invokes a virtual call we may be able to devirtualize speculatively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a35d2bdd1c57297696d12360403e48281b63730" translate="yes" xml:space="preserve">
          <source>The maximum number of memory locations cselib should take into account. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a0df289b9860c6b27b724bd89cb2e25afbef7b" translate="yes" xml:space="preserve">
          <source>The maximum number of namespaces to consult for suggestions when C++ name lookup fails for an identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511118b67bad71c8756d22dc67344a5b3d5a2116" translate="yes" xml:space="preserve">
          <source>The maximum number of peelings of a single loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f1f05653238e3a565a30b9f73246f26306aaea" translate="yes" xml:space="preserve">
          <source>The maximum number of pending dependencies scheduling allows before flushing the current state and starting over. Large functions with few branches or calls can create excessively large lists which needlessly consume memory and resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e89b0526dda27a2d7f3e6b7314e208af696219" translate="yes" xml:space="preserve">
          <source>The maximum number of run-time checks that can be performed when doing loop versioning for alias in the vectorizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0f184d4982d10802b0494be89c63889d9e1ea5" translate="yes" xml:space="preserve">
          <source>The maximum number of run-time checks that can be performed when doing loop versioning for alignment in the vectorizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ff624d5ca7c27e89395fa51bbbe5ce28d3f9f1" translate="yes" xml:space="preserve">
          <source>The maximum number of stmts in a loop to be interchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2862b2a5dc2c56cf5f469134e2bd6bad6e5964e7" translate="yes" xml:space="preserve">
          <source>The maximum number of stores to attempt to merge into wider stores in the store merging pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6caef17bd294964937582b8b58bab7601c99e27b" translate="yes" xml:space="preserve">
          <source>The maximum number of times that an instruction is scheduled during selective scheduling. This is the limit on the number of iterations through which the instruction may be pipelined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddefe1cfc3442fba935b71446bc04ed2a446b364" translate="yes" xml:space="preserve">
          <source>The maximum number of times the outer loop should be unrolled by the unroll-and-jam transformation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df2840a57590d0c992c35b1f7cd4db504ccf715" translate="yes" xml:space="preserve">
          <source>The maximum number of unrollings of a single loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e4b31a55ed6d6ed41d2b2d48b6006b46bfa532" translate="yes" xml:space="preserve">
          <source>The maximum relative execution frequency (in percents) of the target block relative to a statement&amp;rsquo;s original block to allow statement sinking of a statement. Larger numbers result in more aggressive statement sinking. A small positive adjustment is applied for statements with memory operands as those are even more profitable so sink.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e2688875615cab366f32942394edf8b4b91705" translate="yes" xml:space="preserve">
          <source>The maximum size measured as number of RTLs that can be recorded in an expression in combiner for a pseudo register as last known value of that register.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159ffd5e6070239f87afd549cbfcfd8ded2b299d" translate="yes" xml:space="preserve">
          <source>The maximum size of the lookahead window of selective scheduling. It is a depth of search for available instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3da3af33190929d9965056fd52af9e74099ff3d" translate="yes" xml:space="preserve">
          <source>The memory order parameter is a signed int, but only the lower 16 bits are reserved for the memory order. The remainder of the signed int is reserved for target use and should be 0. Use of the predefined atomic values ensures proper usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9000c0e6476a4bcab6775fb476be520bb235b5" translate="yes" xml:space="preserve">
          <source>The memory-based pseudo-registers $mem0 through $mem15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9aeac04a443a9f208cd4c4e6f4207cbf2bb24b" translate="yes" xml:space="preserve">
          <source>The message attached to the attribute is affected by the setting of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535f4a6df8d49970089b47a9552616a59f08c505" translate="yes" xml:space="preserve">
          <source>The message is in keeping with the output of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d9ad2ced8af2273cacd0833b5a4654b153618b" translate="yes" xml:space="preserve">
          <source>The method by which preprocessing tokens (possibly resulting from macro expansion) in a &lt;code&gt;#include&lt;/code&gt; directive are combined into a header name (C90 6.8.2, C99 and C11 6.10.2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dacbdf1cd80117047022b9711381d6ea5221d3" translate="yes" xml:space="preserve">
          <source>The method is called repeatedly during a fast enumeration to retrieve batches of objects. Each invocation of the method should retrieve the next batch of objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7fa0fb8f65f5da5a26a900516ca2af75a19d924" translate="yes" xml:space="preserve">
          <source>The method used by GCC is as follows: a structure or union which is 1, 2, 4 or 8 bytes long is returned like a scalar. A structure or union with any other size is stored into an address supplied by the caller (usually in a special, fixed register, but on some machines it is passed on the stack). The target hook &lt;code&gt;TARGET_STRUCT_VALUE_RTX&lt;/code&gt; tells GCC where to pass this address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea71b7dec6652fd1c586605bdaf1afaabd9e0d7" translate="yes" xml:space="preserve">
          <source>The middle operand in a conditional expression may be omitted. Then if the first operand is nonzero, its value is the value of the conditional expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9ca9444f11bb1174b6690d0f150eb398c757b0" translate="yes" xml:space="preserve">
          <source>The mini registers r0 - r7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e080de9f963115473e6c7f8a5387551ad83e48b0" translate="yes" xml:space="preserve">
          <source>The minimal probability of speculation success (in percents), so that speculative insns are scheduled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaffaaa968786a2da6ad4d8b8e0d5b378cb65a74" translate="yes" xml:space="preserve">
          <source>The minimum cost of an expensive expression in the loop invariant motion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe3bb81fc851386e4b7cee22649ff792c38641a" translate="yes" xml:space="preserve">
          <source>The minimum fraction of profile runs a given basic block execution count must be not to be considered unlikely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f1b567f7a83d5184bace5014aac03377eeb221" translate="yes" xml:space="preserve">
          <source>The minimum number of instructions that must be matched at the end of two blocks before cross-jumping is performed on them. This value is ignored in the case where all instructions in the block being cross-jumped from are matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c154dc267dae6541e650ecc75738b7fc1946c1" translate="yes" xml:space="preserve">
          <source>The minimum number of iterations per thread of an innermost parallelized loop for which the parallelized variant is preferred over the single threaded one. Note that for a parallelized loop nest the minimum number of iterations of the outermost loop per thread is two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2647f0a952db726e7e97cf159b9a0ce4dc6514c9" translate="yes" xml:space="preserve">
          <source>The minimum number of iterations under which loops are not vectorized when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ff09fc2cb3e08a9eb4ff0c94daf816032e979a" translate="yes" xml:space="preserve">
          <source>The minimum percentage of memory references that must be optimized away for the unroll-and-jam transformation to be considered profitable.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
