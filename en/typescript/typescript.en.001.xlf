<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="">
    <body>
      <group id="">
        <trans-unit id="07f99178b48153ac4d4332687d20d728a7c8bfd4" translate="yes">
          <source>&amp;copy; 2012-2019 Microsoft</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb191ccf7512349b3d99757bc9535f48ae81c17" translate="yes">
          <source>&amp;ldquo;Defaulted declarations&amp;rdquo; allow initializers that reference the declared name in the left side of a logical or:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1fdafe04dd11ea1809cd2cc0c324b66f3a11b35" translate="yes">
          <source>&amp;ldquo;Do&amp;rdquo;s and &amp;ldquo;Don&amp;rsquo;t&amp;rdquo;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d479e429a32f573b7b23a67a8995da08eed47d" translate="yes">
          <source>&amp;lsquo;classic&amp;rsquo; - module resolution rules used by pre 1.6 TypeScript compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c51288c27e2cc818fba1bd491d412143391547" translate="yes">
          <source>&amp;lsquo;node&amp;rsquo; - node-like module resolution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4547d63b41d1c75d2e1b5085da19d735e8dc595e" translate="yes">
          <source>&amp;lsquo;package.json&amp;rsquo; has &lt;strong&gt;&amp;lsquo;types&amp;rsquo;&lt;/strong&gt; field &amp;lsquo;./lib/typescript.d.ts&amp;rsquo; that references &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee44c32e65bc4a9d7773f18d0e20e44810833a3f" translate="yes">
          <source>&amp;lt;amd-dependency /&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934f0cd8be7ed1f9b7b8079909795f738f732556" translate="yes">
          <source>&amp;lt;amd-module /&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4898dc828f34abf0dca9dabec02736d522eceb" translate="yes">
          <source>&amp;lt;reference lib=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62141bcfe5cfcd51fc1a320d36520899bc9edd5f" translate="yes">
          <source>&amp;lt;reference no-default-lib=&amp;quot;true&amp;quot;/&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21029c886af7dc459626422aa0c5b6ca11e413cb" translate="yes">
          <source>&amp;lt;reference path=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120613f8d21d190c622bf610b91d69083361e489" translate="yes">
          <source>&amp;lt;reference types=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105733a69ca97c742b5246c8891283fb75ef628c" translate="yes">
          <source>&amp;lt;reference&amp;gt;-ing a module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccfac08210ff156925b259cf9224a7d62ab98fc8" translate="yes">
          <source>(More) Recursive Type Aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b244b1f4cdc07410d73db6d8271fb3aede63b0" translate="yes">
          <source>*Note: You can specify the JSX factory function to use when targeting react JSX emit with &lt;code&gt;--jsxFactory&lt;/code&gt; option (defaults to &lt;code&gt;React.createElement&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcac7464521b8c19a2372c739f6dc9e9ab7dfc80" translate="yes">
          <source>.babelrc</source>
          <target state="translated">.babelrc</target>
        </trans-unit>
        <trans-unit id="bdbc9a553b902daccdcb974134663c5cbb048999" translate="yes">
          <source>1 - greeting: Mandatory string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d790ef091c0d678928628f711d3a342ed79fdc" translate="yes">
          <source>2 - duration: Optional length of time (in milliseconds)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb356c6c25d42fb0b2006e35569ce371868ed08" translate="yes">
          <source>3 - color: Optional string, e.g. &amp;lsquo;#ff00ff&amp;rsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1f243849fa29b29355c96a02e0cba354d5a774" translate="yes">
          <source>3.7 API Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2dbed9bb17a5c2fdd2db0b9dd5844f947a20c89" translate="yes">
          <source>3.7 Breaking Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d8d7d93cd113005d851de63f1e7f8b91e504d4" translate="yes">
          <source>&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;As mentioned above&lt;/a&gt;, TypeScript 3.7 emits &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4fbbd23ecf68cc6d9a635cad72158cb53c80a0" translate="yes">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects&quot;&gt;ES2015 also introduced &amp;ldquo;Generators&amp;rdquo;&lt;/a&gt;, which are functions that can be used to yield partial computation results via the &lt;code&gt;Iterator&lt;/code&gt; interface and the &lt;code&gt;yield&lt;/code&gt; keyword. Generators can also internally delegate calls to another iterable through &lt;code&gt;yield *&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55463e892e31113c861aadf5f93e77a57de6240a" translate="yes">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-iteration&quot;&gt;ES2015 introduced &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which is an object that exposes three methods, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt;, as per the following interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12aa33cea9b5a79c35ec84291696eb4b59f9da1e" translate="yes">
          <source>&lt;a href=&quot;https://facebook.github.io/jsx/&quot;&gt;JSX&lt;/a&gt; is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX rose to popularity with the &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; framework, but has since seen other implementations as well. TypeScript supports embedding, type checking, and compiling JSX directly to JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef2642d51385f769ab651c082c9dff225d74fc2" translate="yes">
          <source>&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33627&quot;&gt;Types in &lt;code&gt;lib.dom.d.ts&lt;/code&gt; have been updated&lt;/a&gt;. These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0495fdef653ac880036cca0814e7297d71236b4d" translate="yes">
          <source>&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD modules&lt;/a&gt; check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd7f9a4260cf4f7a8c5026d67e5c95d711d16e5" translate="yes">
          <source>&lt;b&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;â†¥ back to top&lt;/a&gt;&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdbdf4e1369a70ccce916824139e46a9847d97a3" translate="yes">
          <source>&lt;code&gt;&quot;*&quot;&lt;/code&gt;: meaning the same name unchanged, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73a6525d7eaa4824134e5210d19e488e565b563" translate="yes">
          <source>&lt;code&gt;&quot;generated/*&quot;&lt;/code&gt; meaning the module name with an appended prefix &amp;ldquo;generated&amp;rdquo;, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c85a37d09c2e1af4c5f31661b285d4d1e16f641" translate="yes">
          <source>&lt;code&gt;&quot;noImplicitAny&quot;&lt;/code&gt; is good idea whenever you&amp;rsquo;re writing new code &amp;mdash; you can make sure that you don&amp;rsquo;t write any untyped code by mistake. &lt;code&gt;&quot;compileOnSave&quot;&lt;/code&gt; makes it easy to update your code in a running web app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe58c3912d521e0998db0d63686a8a2d31499624" translate="yes">
          <source>&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c3c22aa0fd78209c6c0e383e2528e7c6b4250d" translate="yes">
          <source>&lt;code&gt;**/&lt;/code&gt; recursively matches any subdirectory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff5a342935b5b9c3dc600fb9b3b727885179683" translate="yes">
          <source>&lt;code&gt;*&lt;/code&gt; matches zero or more characters (excluding directory separators)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb69c784cbac9dae7012fa8bd2d7bd07b8c923b" translate="yes">
          <source>&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; binary operators with constant enum expressions as operands</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc75f886336759e26741a1a438d89e2625db989" translate="yes">
          <source>&lt;code&gt;--clean&lt;/code&gt;: Deletes the outputs of the specified projects (may be combined with &lt;code&gt;--dry&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48e3154b28f82f1a4769c7208b3f989fff9e7b5" translate="yes">
          <source>&lt;code&gt;--declaration&lt;/code&gt; and &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed49d4e6bfaaf71c24b3551301b4023896fbba9" translate="yes">
          <source>&lt;code&gt;--declarationDir&lt;/code&gt; allows for generating declaration files in a different location than JavaScript files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a925ebadad3dc034212a013d96a8d028eec0d77" translate="yes">
          <source>&lt;code&gt;--dry&lt;/code&gt;: Shows what would be done but doesn&amp;rsquo;t actually build anything</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391e7b99672708dcc5a82b9ab142640e75686d43" translate="yes">
          <source>&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; allows for &lt;em&gt;only&lt;/em&gt; generating declaration files; &lt;code&gt;.js&lt;/code&gt;/&lt;code&gt;.jsx&lt;/code&gt; output generation will be skipped with this flag. The flag is useful when the &lt;code&gt;.js&lt;/code&gt; output generation is handled by a different transpiler like Babel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e68274530cc65ca1af4f49f4f5cff04720ac0248" translate="yes">
          <source>&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9fb3da74ef87ed6a6c5cc462731d82c9d0c65e88" translate="yes">
          <source>&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5a457b35b9491157c629e0302940182ccb5e23a" translate="yes">
          <source>&lt;code&gt;--force&lt;/code&gt;: Act as if all projects are out of date</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e0256ea12246cd1a53115a0051e97b7166b303" translate="yes">
          <source>&lt;code&gt;--incremental&lt;/code&gt; improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2680bfd978e11406b01f962d148789dcac08317" translate="yes">
          <source>&lt;code&gt;--init&lt;/code&gt; command line option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99720ca96a5b0e0056f6395f275543d0ff913fad" translate="yes">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; and &lt;code&gt;inlineSources&lt;/code&gt; command line options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3e1a02d6406f9e0f2c99dcba3493dd92f9d8a1" translate="yes">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; causes source map files to be written inline in the generated &lt;code&gt;.js&lt;/code&gt; files instead of in a independent &lt;code&gt;.js.map&lt;/code&gt; file. &lt;code&gt;--inlineSources&lt;/code&gt; allows for additionally inlining the source &lt;code&gt;.ts&lt;/code&gt; file into the &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f213a09ff50e9dce71ecec1b24aff3aec8683c" translate="yes">
          <source>&lt;code&gt;--newLine&lt;/code&gt; command line option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458f3a7228c6223004510906f46ddc5c2a2fd92d" translate="yes">
          <source>&lt;code&gt;--noEmitHelpers&lt;/code&gt; command line option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0312bee1e756b333574619a9dfc0a5e51d922e3b" translate="yes">
          <source>&lt;code&gt;--pretty&lt;/code&gt; output by default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cacd6ae5c910b5d011312b91818b43c8dbca3da" translate="yes">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; command line option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed17502152114f93d8a25c9ca4ba3c08cc11bea3" translate="yes">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; specifies the input directory to be mirrored in output instead of computing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce69107c4ebefc8f6c4b27a523e9c10b6bac6045" translate="yes">
          <source>&lt;code&gt;--strictNullChecks&lt;/code&gt; switches to a new strict null checking mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e169771b2b9f04c32856782076ccdc93237e692" translate="yes">
          <source>&lt;code&gt;--target ESNext&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f5b91bdc31f6e92780c04a56ba964c398b7284" translate="yes">
          <source>&lt;code&gt;--traceResolution&lt;/code&gt; offers a handy way to understand how modules have been resolved by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f407030ac0547dfee747a39b87fbd94ad60948" translate="yes">
          <source>&lt;code&gt;--verbose&lt;/code&gt;: Prints out verbose logging to explain what&amp;rsquo;s going on (may be combined with any other flag)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fc8c433aeda1db44c3bcf0bd26afcf1442b203" translate="yes">
          <source>&lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; provided by node, both of these methods have pros and cons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38362bf60068a8fc03024f53bf3a560d68cb7a68" translate="yes">
          <source>&lt;code&gt;--watch&lt;/code&gt;: Watch mode (may not be combined with any flag except &lt;code&gt;--verbose&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3f3b3fa6bf342d93e8863e2d8e9e6b14addae36" translate="yes">
          <source>&lt;code&gt;-noEmitOnError&lt;/code&gt; commandline option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327baae57d533178e63d7b713f4cf4788b983059" translate="yes">
          <source>&lt;code&gt;.js&lt;/code&gt; files are now allowed as input to &lt;code&gt;tsc&lt;/code&gt;. The TypeScript compiler checks the input &lt;code&gt;.js&lt;/code&gt; files for syntax errors, and emits valid output based on the &lt;code&gt;--target&lt;/code&gt; and &lt;code&gt;--module&lt;/code&gt; flags. The output can be combined with other &lt;code&gt;.ts&lt;/code&gt; files as well. Source maps are still generated for &lt;code&gt;.js&lt;/code&gt; files just like with &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a3fca2c804aa362f9ea852d9bc2750659b10c6" translate="yes">
          <source>&lt;code&gt;.js&lt;/code&gt; files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in &lt;code&gt;.ts&lt;/code&gt; files and are flagged as errors in &lt;code&gt;.js&lt;/code&gt; files. JSDoc comments can be used to add some type information to your JavaScript code, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript&quot;&gt;JSDoc Support documentation&lt;/a&gt; for more details about the supported JSDoc constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ab280d51b93fdaebf109f5c00c1bac5af53c79" translate="yes">
          <source>&lt;code&gt;// @ts-nocheck&lt;/code&gt; in TypeScript Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc749b3637aaa4c3979a2d33edcfc503506cc3f" translate="yes">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7288e5b9a9753f562fe49deb813afdbf0087fb3d" translate="yes">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call; however, there was no way to consume this module in the TS code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eece5866a10ade200011770d30646176a0b7c17" translate="yes">
          <source>&lt;code&gt;/// &amp;lt;reference lib=&quot;...&quot; /&amp;gt;&lt;/code&gt; reference directives</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68be6d84b0a2fdf1d5f2d8454eb02fa9cc63bc19" translate="yes">
          <source>&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;-ing a module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091d09657c7b31c654b189dcd1f225f1a0ec984a" translate="yes">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ea10290a23b3740565e936d91702057ff37372" translate="yes">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9df7b034b6621c779b27d7c4dc7f558da205013a" translate="yes">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4296e7cb4bf2356c30d2093a8e9404e55c92de63" translate="yes">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef30e25aeff39df1c13b00397846be84602cf411" translate="yes">
          <source>&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c853cb66dcb5dc8bcd3d05b08df126aa012e02" translate="yes">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5253ab85bf2484b7491317cdace822fde2760762" translate="yes">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69dd5451af8cbefbfd16c53fcdb71cc3040ab929" translate="yes">
          <source>&lt;code&gt;?&lt;/code&gt; matches any one character (excluding directory separators)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510d9eec82bb462d81447db0531174b45f1b80bc" translate="yes">
          <source>&lt;code&gt;@callback&lt;/code&gt; is similar to &lt;code&gt;@typedef&lt;/code&gt;, but it specifies a function type instead of an object type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e4ec66e698eca8fcacc4aef3b4a8740b21ad83" translate="yes">
          <source>&lt;code&gt;@class&lt;/code&gt; (or &lt;code&gt;@constructor&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9cd9b641abd25c6590bb4318e0d96edab2387c0" translate="yes">
          <source>&lt;code&gt;@extends&lt;/code&gt; (or &lt;code&gt;@augments&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b149f9a357b0a3ec024cce9f5c3dc2328ec70cc" translate="yes">
          <source>&lt;code&gt;@param&lt;/code&gt; (or &lt;code&gt;@arg&lt;/code&gt; or &lt;code&gt;@argument&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17c616498694e2538a5c3a14034458ed215aaf0" translate="yes">
          <source>&lt;code&gt;@param&lt;/code&gt; allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0e55fe627686baab0559a9cdef55576fc8bd55" translate="yes">
          <source>&lt;code&gt;@param&lt;/code&gt; and &lt;code&gt;@returns&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7336752ac090f78d34c3d11b1ab23f55bc10fd2" translate="yes">
          <source>&lt;code&gt;@param&lt;/code&gt; uses the same type syntax as &lt;code&gt;@type&lt;/code&gt;, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58bf6cf80df0aa9192ae7829c488911d16a03ac6" translate="yes">
          <source>&lt;code&gt;@returns&lt;/code&gt; (or &lt;code&gt;@return&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b067c8654340c958784799626e7b4c6447e4ff" translate="yes">
          <source>&lt;code&gt;@type&lt;/code&gt; can specify a union type &amp;mdash; for example, something can be either a string or a boolean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6370c9d00688eca8044b474975739ec7c282690c" translate="yes">
          <source>&lt;code&gt;@typedef&lt;/code&gt; may be used to define complex types. Similar syntax works with &lt;code&gt;@param&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d98ac31d277f8f7a055ef6892de9b33cd522d19" translate="yes">
          <source>&lt;code&gt;@typedef&lt;/code&gt;, &lt;code&gt;@callback&lt;/code&gt;, and &lt;code&gt;@param&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea9a050b838e7b222925bd33fe2491686e61638" translate="yes">
          <source>&lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50cd5cdee6eaf1adbc6e1a7075eb9ed268b7c53d" translate="yes">
          <source>&lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CommonJs&lt;/code&gt;, &lt;code&gt;UMD&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt; or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd47ffe31f15f736868359790118558f4c90d54" translate="yes">
          <source>&lt;code&gt;CRLF&lt;/code&gt; or &lt;code&gt;LF&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e18a27ec845bd07bc4bd92bd5a9491158c764b4" translate="yes">
          <source>&lt;code&gt;Classic&lt;/code&gt; or &lt;code&gt;Node&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55b3dc1847df4cc22875b738b3f0488ec130264" translate="yes">
          <source>&lt;code&gt;ES3&lt;/code&gt;, &lt;code&gt;ES5&lt;/code&gt;, or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c84b65c2899e07c2577094ba71268f82bb4348" translate="yes">
          <source>&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Exclude from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b118234127720a534c99dc56aab386dafc6292" translate="yes">
          <source>&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Extract from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731cd2078eec18fd1721cd773e8793bd578bbbb1" translate="yes">
          <source>&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the instance type of a constructor function type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4f46cf1c3e00a0668406b1af262c9ac954f250" translate="yes">
          <source>&lt;code&gt;MapToPromise&lt;/code&gt; takes a type &lt;code&gt;T&lt;/code&gt;, and when that type is a tuple like &lt;code&gt;Coordinate&lt;/code&gt;, only the numeric properties are converted. In &lt;code&gt;[number, number]&lt;/code&gt;, there are two numerically named properties: &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. When given a tuple like that, &lt;code&gt;MapToPromise&lt;/code&gt; will create a new tuple where the &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; properties are &lt;code&gt;Promise&lt;/code&gt;s of the original type. So the resulting type &lt;code&gt;PromiseCoordinate&lt;/code&gt; ends up with the type &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3876e328c2a892ca260659a39ae1af62fabdd14a" translate="yes">
          <source>&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt;: Tools only (&lt;code&gt;tsc.exe&lt;/code&gt;, &lt;code&gt;lib.d.ts&lt;/code&gt;, etc.) .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b10a71485a17634b805b9bf6d4a114d9b8719e" translate="yes">
          <source>&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;: Tools as above, as well as MSBuild tasks and targets (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt;, &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt;, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754f9ca6c2a9d6b75591a792a94899f3972d0dcd" translate="yes">
          <source>&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Exclude &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcae45288d3d0341f00e5f0a0c1e04f55875a283" translate="yes">
          <source>&lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ab4b2b1efc56a0da6b2f789333b4eeca92f504" translate="yes">
          <source>&lt;code&gt;Object.defineProperty&lt;/code&gt; declarations in JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516acae2c43a860256900e06b27f3de21816c8f7" translate="yes">
          <source>&lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Readonly&lt;/code&gt;, as described earlier, are very useful constructs. You can use them to describe some common JS routines like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5fb5be503d3cc99bc3891aa2f666671d256ce9" translate="yes">
          <source>&lt;code&gt;Partial&lt;/code&gt;, &lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Record&lt;/code&gt;, and &lt;code&gt;Pick&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9dce20c8a5593c22349b662be93f751022e541" translate="yes">
          <source>&lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt; are homomorphic whereas &lt;code&gt;Record&lt;/code&gt; is not. One clue that &lt;code&gt;Record&lt;/code&gt; is not homomorphic is that it doesn&amp;rsquo;t take an input type to copy properties from:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f09457e713627cb3ff92a240363946a791f063" translate="yes">
          <source>&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the return type of a function type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a86605355daf9f91784a6e95367936d4e082b6" translate="yes">
          <source>&lt;code&gt;abstract&lt;/code&gt; classes and methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9f50e030bc7a5ce9cb5b43dfb74328d401c7c3" translate="yes">
          <source>&lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ed5d892c6e6d7a97395e1de27bc299c07f918b" translate="yes">
          <source>&lt;code&gt;asserts condition&lt;/code&gt; says that whatever gets passed into the &lt;code&gt;condition&lt;/code&gt; parameter must be true if the &lt;code&gt;assert&lt;/code&gt; returns (because otherwise it would throw an error). That means that for the rest of the scope, that condition must be truthy. As an example, using this assertion function means we &lt;em&gt;do&lt;/em&gt; catch our original &lt;code&gt;yell&lt;/code&gt; example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d81ac1481d5d350948454eb43f231d3dccd6195" translate="yes">
          <source>&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; support in ES6 targets (Node v4+)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b0a7f614edcf50ca6da583f1bb124c1000c419" translate="yes">
          <source>&lt;code&gt;compose&lt;/code&gt; takes two other functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f6815f367db078217340961910eed3f0c7f8e8" translate="yes">
          <source>&lt;code&gt;compose&lt;/code&gt; then returns a function which feeds its argument through &lt;code&gt;f&lt;/code&gt; and then &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb41a6e05b71eb6e7a7f237a3f9d9323ff52b694" translate="yes">
          <source>&lt;code&gt;configs/base.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;configs/base.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="f321739617311f53c301a43c80e999c6085eb60a" translate="yes">
          <source>&lt;code&gt;const enum&lt;/code&gt; (completely inlined enums)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3ba5db3958314705ea44cd88cec272faaabfcb" translate="yes">
          <source>&lt;code&gt;const&lt;/code&gt; assertions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012e49b5b90ab3812ce5d5459abd13d8a1d9c849" translate="yes">
          <source>&lt;code&gt;const&lt;/code&gt; declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe167491a7d42fefa52129b16e1e621a2c31788a" translate="yes">
          <source>&lt;code&gt;const&lt;/code&gt; declarations are another way of declaring variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88c4d09927f47dc36c60e05f8c607beb8cd93c2" translate="yes">
          <source>&lt;code&gt;const&lt;/code&gt; enums</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70efaa5f183560f377cb84a1789fe0834b27d50e" translate="yes">
          <source>&lt;code&gt;const&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ad1e1356fede9b7c214d93508aae720dfa9cb1" translate="yes">
          <source>&lt;code&gt;declaration&lt;/code&gt; must be turned on</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1401dfdf98b767d48685797471067283cd20a8d6" translate="yes">
          <source>&lt;code&gt;declarationMap&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;declarationMap&lt;/code&gt;s</target>
        </trans-unit>
        <trans-unit id="70f1caf45465e3b2f9b33169a10a4b2656de7399" translate="yes">
          <source>&lt;code&gt;default&lt;/code&gt; exports are really handy. For instance, a library like jQuery might have a default export of &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt;, which we&amp;rsquo;d probably also import under the name &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;jQuery&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f55dfa5aca95ffd4b7a09bd7b9cc8eb2fadbc9" translate="yes">
          <source>&lt;code&gt;default&lt;/code&gt; exports can also be just values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8b5fd9f825e6be680dd3514510f69b4616113c" translate="yes">
          <source>&lt;code&gt;exclude&lt;/code&gt; property support in tsconfig.json</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9db716df5a416c78cae480a101fb21ea1e7a5c" translate="yes">
          <source>&lt;code&gt;export *&lt;/code&gt; can be used to re-export all exports of another module. This is useful for creating modules that aggregate the exports of several other modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e636e798459cbffd9da7324b94596ca1840bafd" translate="yes">
          <source>&lt;code&gt;export =&lt;/code&gt; and &lt;code&gt;import = require()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d288a4c439ec79c9f01ed90667a909f760945ab" translate="yes">
          <source>&lt;code&gt;extends&lt;/code&gt; is a new top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9840158488dc62fdaa3cb62b51c0e8858b5791cd" translate="yes">
          <source>&lt;code&gt;f&lt;/code&gt; which takes some argument (of type &lt;code&gt;A&lt;/code&gt;) and returns a value of type &lt;code&gt;B&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44df04333c301a58f9a4eb14df232200a4137e3" translate="yes">
          <source>&lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbea6b2144138c02935bdf65a3a5978cc7d89931" translate="yes">
          <source>&lt;code&gt;for..of&lt;/code&gt; loops over an iterable object, invoking the &lt;code&gt;Symbol.iterator&lt;/code&gt; property on the object. Here is a simple &lt;code&gt;for..of&lt;/code&gt; loop on an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95fe318c23178a301fc252f057ad04a9fae6f4e" translate="yes">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a8de33c0d1e331511a9ec2641ee2219e3cc903" translate="yes">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements, Array Destructuring, and Spread elements in Array, Call, and New expressions support &lt;code&gt;Symbol.iterator&lt;/code&gt; in ES5/E3 if available when using &lt;code&gt;--downlevelIteration&lt;/code&gt;, but can be used on an Array even if it does not define &lt;code&gt;Symbol.iterator&lt;/code&gt; at run time or design time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb526d1bc7349c8b0a3895b057b40322758bab4" translate="yes">
          <source>&lt;code&gt;for..of&lt;/code&gt; vs. &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf252545f201f3e3088e9c25cd8f91ad011a692" translate="yes">
          <source>&lt;code&gt;fs.watch&lt;/code&gt; uses file system events to notify the changes in the file/directory. But this is OS dependent and the notification is not completely reliable and does not work as expected on many OS. Also there could be limit on number of watches that can be created, eg. linux and we could exhaust it pretty quickly with programs that include large number of files. But because this uses file system events, there is not much CPU cycle involved. Compiler typically uses &lt;code&gt;fs.watch&lt;/code&gt; to watch directories (eg. source directories included by config file, directories in which module resolution failed etc) These can handle the missing precision in notifying about the changes. But recursive watching is supported on only Windows and OSX. That means we need something to replace the recursive nature on other OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea889051fa717ee536ad67479b6a78c0ea9610ad" translate="yes">
          <source>&lt;code&gt;fs.watchFile&lt;/code&gt; uses polling and thus involves CPU cycles. But this is the most reliable mechanism to get the update on the status of file/directory. Compiler typically uses &lt;code&gt;fs.watchFile&lt;/code&gt; to watch source files, config files and missing files (missing file references) that means the CPU usage depends on number of files in the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d942c2a8b235d3c8b1abcc6b3de3eb5cad957fd4" translate="yes">
          <source>&lt;code&gt;g&lt;/code&gt; which takes an argument of type &lt;code&gt;B&lt;/code&gt; (the type &lt;code&gt;f&lt;/code&gt; returned), and returns a value of type &lt;code&gt;C&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff0b88d92dd631bb6081ce9db31f440e26b7928" translate="yes">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; Accessors Are Allowed in Ambient Contexts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49e1b432c62fc73ee50890c56c8ca86ec135992" translate="yes">
          <source>&lt;code&gt;import.meta&lt;/code&gt; Support in SystemJS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0481e74e61bd0bd88c8e2325d45f8276eb589abf" translate="yes">
          <source>&lt;code&gt;import.meta&lt;/code&gt; is only allowed when targeting &lt;code&gt;ESNext&lt;/code&gt; modules and ECMAScript targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24678ed6edc307f778f38669f8a75994d68cb176" translate="yes">
          <source>&lt;code&gt;import&lt;/code&gt; types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bfe1d5b2564298c1ad9951a1d511481192d2cc8" translate="yes">
          <source>&lt;code&gt;instanceof&lt;/code&gt; type guards</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96fbdf33bebac7a069682e69d1fd6d5b58e1236" translate="yes">
          <source>&lt;code&gt;keyof Car&lt;/code&gt; is completely interchangeable with &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt;. The difference is that if you add another property to &lt;code&gt;Car&lt;/code&gt;, say &lt;code&gt;ownersAddress: string&lt;/code&gt;, then &lt;code&gt;keyof Car&lt;/code&gt; will automatically update to be &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt;. And you can use &lt;code&gt;keyof&lt;/code&gt; in generic contexts like &lt;code&gt;pluck&lt;/code&gt;, where you can&amp;rsquo;t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to &lt;code&gt;pluck&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1987a917ef43df8bddaa16f892f8677d58abfb2b" translate="yes">
          <source>&lt;code&gt;keyof X&lt;/code&gt; is a union of the literal types representing string-like, number-like, and symbol-like properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07209544abdfdc296d7eca721bd91539c66f16c9" translate="yes">
          <source>&lt;code&gt;keyof&lt;/code&gt; and &lt;code&gt;T[K]&lt;/code&gt; interact with index signatures. An index signature parameter type must be &amp;lsquo;string&amp;rsquo; or &amp;lsquo;number&amp;rsquo;. If you have a type with a string index signature, &lt;code&gt;keyof T&lt;/code&gt; will be &lt;code&gt;string | number&lt;/code&gt; (and not just &lt;code&gt;string&lt;/code&gt;, since in JavaScript you can access an object property either by using strings (&lt;code&gt;object['42'&lt;/code&gt;]) or numbers (&lt;code&gt;object[42]&lt;/code&gt;)). And &lt;code&gt;T[string]&lt;/code&gt; is just the type of the index signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a74989aac5ff67841f237ba8439fe200c4f59e" translate="yes">
          <source>&lt;code&gt;keyof&lt;/code&gt; and Lookup Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7587ea139b16cb3066fc1193552ad0a697db99ff" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; are two relatively new types of variable declarations in JavaScript. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;As we mentioned earlier&lt;/a&gt;, &lt;code&gt;let&lt;/code&gt; is similar to &lt;code&gt;var&lt;/code&gt; in some respects, but allows users to avoid some of the common &amp;ldquo;gotchas&amp;rdquo; that users run into in JavaScript. &lt;code&gt;const&lt;/code&gt; is an augmentation of &lt;code&gt;let&lt;/code&gt; in that it prevents re-assignment to a variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578f076915b9987c6c3b4ff784a24189b7365213" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b776172d356ffcb9dd1ee020b2f44b56c7785dd" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644591ecf7a7ac1044c0183c3798f150809bbe15" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope &lt;em&gt;per iteration&lt;/em&gt;. Since this is what we were doing anyway with our IIFE, we can change our old &lt;code&gt;setTimeout&lt;/code&gt; example to just use a &lt;code&gt;let&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f152c0c11e8b4f18e296dd980a05bfe53992b15" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2604695bf1219c913e9ce6e43a919233bb300fd4" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt; vs. &lt;code&gt;const&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47597d61bef00139bb68777625c718cfe83c7a37" translate="yes">
          <source>&lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a829bf2451c18e9c8300170bf81a48d5c7a14e26" translate="yes">
          <source>&lt;code&gt;module === &quot;system&quot;&lt;/code&gt; or &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aedd5acf8ab96c5aa7b3783ab936c10a1ae4b90" translate="yes">
          <source>&lt;code&gt;namespace&lt;/code&gt; keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3757c64ba702c0e95ec29c43f6b3bcbac2dfaf79" translate="yes">
          <source>&lt;code&gt;never&lt;/code&gt; is a subtype of and assignable to every type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf0fffc126fe6f7ef6fe8bd69ac432fc59ec7cf" translate="yes">
          <source>&lt;code&gt;new.target&lt;/code&gt; also comes in handy for writing constructable functions, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f8af0872a567ae1498db2400c8725c6f67981a" translate="yes">
          <source>&lt;code&gt;new.target&lt;/code&gt; comes in handy when &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; or &lt;code&gt;__proto__&lt;/code&gt; needs to be set in a class constructor. One such use case is inheriting from &lt;code&gt;Error&lt;/code&gt; in NodeJS v4 and higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23e511cadd633529e9b1516004a6ec203d2f65d" translate="yes">
          <source>&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; which is helpful if you never want to forget a &lt;code&gt;break&lt;/code&gt; statement between &lt;code&gt;case&lt;/code&gt;s in a &lt;code&gt;switch&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b5ef3461c6310cbfb2829b36fa9f54629275f7" translate="yes">
          <source>&lt;code&gt;noImplicitAny&lt;/code&gt; : Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b684ebe24425d0ae00fe5f4dd392279dd756e18" translate="yes">
          <source>&lt;code&gt;noImplicitReturns&lt;/code&gt; which prevents you from forgetting to return at the end of a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88ad4b11b76f0b52388960f7fb144596753b33f" translate="yes">
          <source>&lt;code&gt;object&lt;/code&gt; is a type that represents the non-primitive type, i.e. anything that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b459667b63171c9a2bfca987e324fd67266a33" translate="yes">
          <source>&lt;code&gt;object&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c2b17b7aa15d4b6c554df6d3c6079bd7ea6b62" translate="yes">
          <source>&lt;code&gt;onEmitOnError&lt;/code&gt; : Do not emit outputs if any errors were reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36f089a00eed6e2a38161e562ca2eadbc3a0ba3" translate="yes">
          <source>&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7271647d356fdf53e4881a83f2b3d24088d1ce22" translate="yes">
          <source>&lt;code&gt;pet is Fish&lt;/code&gt; is our type predicate in this example. A predicate takes the form &lt;code&gt;parameterName is Type&lt;/code&gt;, where &lt;code&gt;parameterName&lt;/code&gt; must be the name of a parameter from the current function signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d591a35ea43b09e97945e00e88029db5bb27c2b9" translate="yes">
          <source>&lt;code&gt;prepend&lt;/code&gt; with &lt;code&gt;outFile&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48ad12a1bd9b139a251683c44c9c037d0781daa" translate="yes">
          <source>&lt;code&gt;react&lt;/code&gt;, &lt;code&gt;react-native&lt;/code&gt;, &lt;code&gt;preserve&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265f731b05abd126578741df3ef1317127023ebd" translate="yes">
          <source>&lt;code&gt;readonly&lt;/code&gt; mapped type modifiers and &lt;code&gt;readonly&lt;/code&gt; arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a72bebc41b3c89da2f3cb186861c5375dc8d827" translate="yes">
          <source>&lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3d715459a937e9292de095a19bf986d41e03e3" translate="yes">
          <source>&lt;code&gt;readonly&lt;/code&gt; vs &lt;code&gt;const&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204249cb0d243afb180412fa55d150953da5fecd" translate="yes">
          <source>&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4c4934c028db6c4d82b88f32de53708b229fb87e" translate="yes">
          <source>&lt;code&gt;sourceMap&lt;/code&gt; : Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b7403357a0651ddeff1c1122a8b2bb08ffe8e1" translate="yes">
          <source>&lt;code&gt;strictNullChecks&lt;/code&gt; is disabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dbbf233507908fb7d0aaad278a5681b3a14a678" translate="yes">
          <source>&lt;code&gt;symbol&lt;/code&gt; values are created by calling the &lt;code&gt;Symbol&lt;/code&gt; constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df548ecfe43e1bd5edc74f5f9d9e11e7c489fabb" translate="yes">
          <source>&lt;code&gt;target&lt;/code&gt; : Specify ECMAScript target version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41807fdfe0d78a471df79e23ac828c29a48b1df2" translate="yes">
          <source>&lt;code&gt;this is T&lt;/code&gt; is now valid return type annotation for methods in classes and interfaces. When used in a type narowing position (e.g. &lt;code&gt;if&lt;/code&gt; statement), the type of the call expression target object would be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25fe4991728ca46519e506de1d8f666a6c8b7fb" translate="yes">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9953e41bed91beb356ec58e55940c473593811e" translate="yes">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type. Second, annotate your calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239502a5db9c22853dabbf84a0a02ea54ae32760" translate="yes">
          <source>&lt;code&gt;this&lt;/code&gt; and arrow functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b4a05163d3be8c272019de111de564106390bb" translate="yes">
          <source>&lt;code&gt;this&lt;/code&gt; parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba826b0f4b51964bc2dcb2689ad5e6718b4d812" translate="yes">
          <source>&lt;code&gt;this&lt;/code&gt; parameters in callbacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a17c6a78a4a91182cb755f2d1f82d0e8352047" translate="yes">
          <source>&lt;code&gt;this&lt;/code&gt;-based type guards</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d7365686580943b61bcc0680fdd9fefd9bb9d0" translate="yes">
          <source>&lt;code&gt;this&lt;/code&gt;-typing</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt;-typing</target>
        </trans-unit>
        <trans-unit id="a5626b5c92a5a1772a40e47f83129a6cdaba494c" translate="yes">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;composite&lt;/code&gt; is on, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a6e88c2494ea9288969156547c6f6523ee7397" translate="yes">
          <source>&lt;code&gt;true&lt;/code&gt; unless piping to another program or redirecting output to a file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5827602d127a01fcf210389ba5b4073a09f73f65" translate="yes">
          <source>&lt;code&gt;tsc -b&lt;/code&gt; Commandline</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbf7438323e3bbf152cf8686704d6a9b92eda48" translate="yes">
          <source>&lt;code&gt;tsc -w&lt;/code&gt; can&amp;rsquo;t run on multiple config files at once</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147a626c1d03568f0d86b81b12aca475f5e24705" translate="yes">
          <source>&lt;code&gt;tsc&lt;/code&gt; will only ever use existing files on disk to do this process, so it&amp;rsquo;s possible to create a project where a correct output file can&amp;rsquo;t be generated because some project&amp;rsquo;s output would be present more than once in the resulting file. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98564db040acf2bf7b395e1d0a36df38b4a8402f" translate="yes">
          <source>&lt;code&gt;tsc&lt;/code&gt;, the TypeScript compiler, supports a new flag called &lt;code&gt;--showConfig&lt;/code&gt;. When running &lt;code&gt;tsc --showConfig&lt;/code&gt;, TypeScript will calculate the effective &lt;code&gt;tsconfig.json&lt;/code&gt; (after calculating options inherited from the &lt;code&gt;extends&lt;/code&gt; field) and print that out. This can be useful for diagnosing configuration issues in general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a7f5e8734c14fa7d0a8d6777c5b5ac6fa8ca44" translate="yes">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; files have a new top-level property, &lt;code&gt;references&lt;/code&gt;. It&amp;rsquo;s an array of objects that specifies projects to reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d62e6e595e456c5e9270cc34e832ead6a38881" translate="yes">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; inheritance via Node.js packages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d6ff9ec9b1c03f6c4865dd1b1475c13329c97c" translate="yes">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; turns a folder into a &amp;ldquo;project&amp;rdquo;. Without specifying any &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; entries, all files in the folder containing the &lt;code&gt;tsconfig.json&lt;/code&gt; and all its sub-directories are included in your compilation. If you want to exclude some of the files use &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt;, if you would rather specify all the files instead of letting the compiler look them up, use &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44461f86b394f4690605fa32353147f0c499cba8" translate="yes">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="dce89073ea61332463e4bc7ffcd226cfebb38fb7" translate="yes">
          <source>&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="802c612cac10d8e06122f662232f3d40cbb16c55" translate="yes">
          <source>&lt;code&gt;typeof&lt;/code&gt; type guards</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1416688590a42ec8a707493a8a76f4bafb32ca" translate="yes">
          <source>&lt;code&gt;typesVersions&lt;/code&gt; can support multiple fields where each field name is specified by the range to match on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c59fd04173482af55d5dc102886aa00a3441e8" translate="yes">
          <source>&lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9085fb15ab9e328c2c89a7b70fa880194687cc" translate="yes">
          <source>&lt;code&gt;var&lt;/code&gt; declarations have some odd scoping rules for those used to other languages. Take the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f91793a72a6bf2a9f9865634b43e9fe9ffea71" translate="yes">
          <source>&lt;code&gt;void&lt;/code&gt; is a little like the opposite of &lt;code&gt;any&lt;/code&gt;: the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5162ce142c852c721ea4c2f90dcd96e468cd2c12" translate="yes">
          <source>&lt;code&gt;y&lt;/code&gt; would have the type &lt;code&gt;any&lt;/code&gt;. This meant the program would type-check, but you could technically do anything with &lt;code&gt;y&lt;/code&gt;, such as the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cc4133a65e863977268415e96540e32efacbaa" translate="yes">
          <source>&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="c1b2e33284cd8b33b99364f12379b80c308e775f" translate="yes">
          <source>&lt;em&gt;(common root directory is computed from the list of input files)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67f8a82845ea83174fddc0273791def9f3791ba2" translate="yes">
          <source>&lt;em&gt;(platform specific)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd153da1f3527d871cddfa9877fa2d91c2500ea" translate="yes">
          <source>&lt;em&gt;&lt;code&gt;instanceof&lt;/code&gt; type guards&lt;/em&gt; are a way of narrowing types using their constructor function. For instance, let&amp;rsquo;s borrow our industrial string-padder example from earlier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c97a851324ff9563ea3a21efd2d3c3c258c8c52" translate="yes">
          <source>&lt;em&gt;Any compiler option&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6848663f06841c4836ef827c8d46d2b7df3d9e2e" translate="yes">
          <source>&lt;em&gt;Class Decorators&lt;/em&gt; are applied for the class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46261c91e2d02cefcc599506ebcf0fdd9241cca2" translate="yes">
          <source>&lt;em&gt;Code&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Code&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b095cf5579d916d24a5da3d12744c26e407ebcb8" translate="yes">
          <source>&lt;em&gt;Configure the TypeScript compiler&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="116f39d7e603ae15f6176b14608384bdd2f4ccc5" translate="yes">
          <source>&lt;em&gt;Declaration&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Declaration&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3144417886ddc6e09e0cb50372c04d88ab6ff96c" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; depend on the npm type declaration package if it doesn&amp;rsquo;t package its declaration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89db8b7cceca187803f1966f48b0b78dc6807c5" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; sort overloads by putting the more general signatures after more specific signatures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d4dbaa7a29534baf764d9d7745b59ff457b95c" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8abf42191e985fd38d25cbfd61b4478044adfc0" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; use optional parameters whenever possible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34280b76cbb108a56a72b557e087d65bbfca383" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; use the return type &lt;code&gt;void&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2582d04d57e5a9ca2606283a30a617ee529f638" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ab3ac84230901f9c46e90452077394873671fb" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; use union types whenever possible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be31bfe1264c4f25766db39e5b90a9fb18fca142" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; write a single overload using the maximum arity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a8d257a217b5e0fad55b648d1b6493b9aaa989" translate="yes">
          <source>&lt;em&gt;Do&lt;/em&gt; write callback parameters as non-optional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abc499e9803a9aa8309f8b0e08bf314ad4f3e5a" translate="yes">
          <source>&lt;em&gt;Documentation&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Documentation&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb8f02b3c9fe34b16e4d7281860a58ffb5f1258c" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; combine it with yours, keep each in their own file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55046e05caf1c72e4c96a87b22fa2202c7225227" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; copy the declarations in your package either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2dfadd00649442a356417e47981d6fcfedbf53f" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever have a generic type which doesn&amp;rsquo;t use its type parameter. See more details in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;TypeScript FAQ page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab2c6da00dd5473019faeda9ef13e58ed031a8a" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever use the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe264f4ba7251b442af48a3b5b9c4e1b135dfc4" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; put more general overloads before more specific overloads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a603d4de241274517e1f16e58ef6ec739c4ebf0c" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; in your declaration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1399216a9d6759d0027db5ae960ecaf5e803541f" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use optional parameters in callbacks unless you really mean it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d00344d385328c471e2760c0b3a980265f52fa1" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use the return type &lt;code&gt;any&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e23e9a1b88c2a712c6058479b769bb4d1ec3dfd" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write overloads that differ by type in only one argument position:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e439fdd1e71a139adb43b822a3f2aaba28d521" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write separate overloads that differ only on callback arity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="247c5c1a979d3fed5d8cc62a706484f0933fae19" translate="yes">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write several overloads that differ only in trailing parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a458b0d98bbea39bc5c4fb3afb6e88d1dfd11e4" translate="yes">
          <source>&lt;em&gt;First some ES2016 terminology:&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33a7ce58f99afe193351513fce2adb5fa23fa05" translate="yes">
          <source>&lt;em&gt;Global Plugin&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b74d2886feeb2bcc628ab0ed5f0f2c95a4fcba" translate="yes">
          <source>&lt;em&gt;Global-modifying Modules&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcead9d078d5e6cb9c2a8d1954d8f1acb7bcdd9" translate="yes">
          <source>&lt;em&gt;MSBuild only option&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5859e547903805656a797e0b51e85d7408c824b7" translate="yes">
          <source>&lt;em&gt;Module Plugin&lt;/em&gt; or &lt;em&gt;UMD Plugin&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05eb70e7bf87cec96374f03c7bbd7c1a2dc4450" translate="yes">
          <source>&lt;em&gt;Module resolution&lt;/em&gt; is the process the compiler uses to figure out what an import refers to. Consider an import statement like &lt;code&gt;import { a } from &quot;moduleA&quot;&lt;/code&gt;; in order to check any use of &lt;code&gt;a&lt;/code&gt;, the compiler needs to know exactly what it represents, and will need to check its definition &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e6a2ccb2d8f44ed1c3e778056f2950ed113c53" translate="yes">
          <source>&lt;em&gt;Not supported in MSBuild&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dac7371112f6ec5085b3b87e625a9052b4ee6a7" translate="yes">
          <source>&lt;em&gt;Note: Currently TypeScript support in jspm is in 0.16beta&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cb755d2229785263aed32055f1123709bd7654" translate="yes">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt; are applied for the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="796db20a306e9b2dd3935de4aee308956682ef88" translate="yes">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each instance member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5479469c16116549f61eeafcc9902b8ba05b63e1" translate="yes">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each static member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e31e103a79ad520b2c48fac19a5feaa38b4da57" translate="yes">
          <source>&lt;em&gt;Rest parameters&lt;/em&gt; are treated as a boundless number of optional parameters. When passing arguments for a rest parameter, you can use as many as you want; you can even pass none. The compiler will build an array of the arguments passed in with the name given after the ellipsis (&lt;code&gt;...&lt;/code&gt;), allowing you to use it in your function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384a6b578c237d923ecb9829216306571810a612" translate="yes">
          <source>&lt;em&gt;Set up NPM&lt;/em&gt; #</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ac1e66f3bd63d151ee5473a7360afdc8a5dfb6" translate="yes">
          <source>&lt;em&gt;Set up gulp&lt;/em&gt; #</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04dd4e00bd479a6cea3c982c3959ab8a78ce6226" translate="yes">
          <source>&lt;em&gt;Type assertions&lt;/em&gt; are a way to tell the compiler &amp;ldquo;trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; A type assertion is like a type cast in other languages, but performs no special checking or restructuring of data. It has no runtime impact, and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b530738f60a429e40a0da7cd4905304cf2dcd24" translate="yes">
          <source>&lt;em&gt;UMD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;UMD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55ac475adb38e0b57582081a72d1746f55ded573" translate="yes">
          <source>&lt;em&gt;Why&lt;/em&gt;: It&amp;rsquo;s always legal for a callback to disregard a parameter, so there&amp;rsquo;s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba95ff529a6d0256d8f93bf5b1f76f42a078259" translate="yes">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for people who are &amp;ldquo;passing through&amp;rdquo; a value to your function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049ec47dfa02534ad24ffb14e28f3f5229781764" translate="yes">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for two reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62327515a94c59f6d707eb154b79f5e5dbfb2a4f" translate="yes">
          <source>&lt;em&gt;Why&lt;/em&gt;: TypeScript chooses the &lt;em&gt;first matching overload&lt;/em&gt; when resolving function calls. When an earlier overload is &amp;ldquo;more general&amp;rdquo; than a later one, the later one is effectively hidden and cannot be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22083a1e79f664f58fd53b8457712dc488debc77" translate="yes">
          <source>&lt;em&gt;Why&lt;/em&gt;: Using &lt;code&gt;void&lt;/code&gt; is safer because it prevents you from accidentally using the return value of &lt;code&gt;x&lt;/code&gt; in an unchecked way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb00c2127ec65942b8f8eaef0ef31ccfcc660872" translate="yes">
          <source>&lt;em&gt;automatic&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;automatic&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6df984511379d608600ad56856c6b7c90da664d" translate="yes">
          <source>&lt;strong&gt;A note about terminology:&lt;/strong&gt; It&amp;rsquo;s important to note that in TypeScript 1.5, the nomenclature has changed. &amp;ldquo;Internal modules&amp;rdquo; are now &amp;ldquo;namespaces&amp;rdquo;. &amp;ldquo;External modules&amp;rdquo; are now simply &amp;ldquo;modules&amp;rdquo;, as to align with &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt;&amp;rsquo;s terminology, (namely that &lt;code&gt;module X {&lt;/code&gt; is equivalent to the now-preferred &lt;code&gt;namespace X {&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb823f67a7cbb8600c4f0350f1c2ad73fe2d021a" translate="yes">
          <source>&lt;strong&gt;After&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;After&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="156a1437d0d6c924eb6ca12562027ff2587f6045" translate="yes">
          <source>&lt;strong&gt;Before&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Before&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="83af59348af09abe07910fb748be25518e341a5c" translate="yes">
          <source>&lt;strong&gt;Command Line&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd8a1d40fc5fe437da8ffe7085dd47f6e01c64d" translate="yes">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this directive has been deprecated. Use &lt;code&gt;import &quot;moduleName&quot;;&lt;/code&gt; statements instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dca272af4b4983e9681bcffd62a12fd4abd3d3" translate="yes">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Usage&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="87244e77c6f80d6ca60d4ab90f5e3a2c23bfbfb5" translate="yes">
          <source>&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="a30a3cb060aed8b038da2f590d07d1fab7bd3b38" translate="yes">
          <source>&lt;sup id=&quot;ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/sup&gt; More specifically, homomorphic mapped types like in the above form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ae02156418abf2a28f0ac9092105d374823167" translate="yes">
          <source>&lt;sup&gt;[1]&lt;/sup&gt; These options are experimental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0447115a5c58a31c601fe3ecaf85a07da3a091" translate="yes">
          <source>&lt;sup&gt;[2]&lt;/sup&gt; These options are only allowed in &lt;code&gt;tsconfig.json&lt;/code&gt;, and not through command-line switches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e2f277649e29a892f6243a1e9f85f91b903aeb" translate="yes">
          <source>======== Module name &amp;lsquo;typescript&amp;rsquo; was &lt;strong&gt;successfully resolved&lt;/strong&gt; to &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;. ========</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54948ed17588662885addef180b7ef879ed0c37c" translate="yes">
          <source>======== Resolving module &lt;strong&gt;&amp;lsquo;typescript&amp;rsquo;&lt;/strong&gt; from &lt;strong&gt;&amp;lsquo;src/app.ts&amp;rsquo;&lt;/strong&gt;. ========</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49ecc37e0ee034f2827da1fd607d32080808c90" translate="yes">
          <source>@constructor</source>
          <target state="translated">@constructor</target>
        </trans-unit>
        <trans-unit id="1730f10972219035ab2f682b1ce4cece7df226d6" translate="yes">
          <source>@extends</source>
          <target state="translated">@extends</target>
        </trans-unit>
        <trans-unit id="105f935c3c4b1ccfdad76f831916ed4a4587adbf" translate="yes">
          <source>@param and @returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ebf6ae3de6f1ca37540e2051a2b384cfa72a27f" translate="yes">
          <source>@template</source>
          <target state="translated">@template</target>
        </trans-unit>
        <trans-unit id="ea9188bc22500c51ab1af4eb545fa93a9a0c4799" translate="yes">
          <source>A &amp;ldquo;bare import&amp;rdquo; can be used to import a module only for its side-effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ab96675e2c97989bb0f021cb50b90f4796d5235" translate="yes">
          <source>A &lt;code&gt;// @ts-ignore&lt;/code&gt; comment suppresses all errors that originate on the following line. It is recommended practice to have the remainder of the comment following &lt;code&gt;@ts-ignore&lt;/code&gt; explain which error is being suppressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0e525ad905e4c93bcdef14ca8854c2dbd392a9" translate="yes">
          <source>A &lt;code&gt;class&lt;/code&gt; declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9321961f59ed7aa165b175642715594e39b66e6f" translate="yes">
          <source>A &lt;code&gt;function&lt;/code&gt; declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5d6828693e8c2d48344e83137c9a8290909b26" translate="yes">
          <source>A &lt;code&gt;namespace&lt;/code&gt; declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dffc5c56bad813471caa1b06219f7ff387e0027" translate="yes">
          <source>A &lt;code&gt;namespace&lt;/code&gt; or &lt;code&gt;module&lt;/code&gt; declaration which contains a value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f40f5525adb3d03f58f4422b7d66754c7565a18" translate="yes">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file can inherit configurations from another file using the &lt;code&gt;extends&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac130cd7375d2fa70c0cad6b27e7077fed8791a" translate="yes">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file is permitted to be completely empty, which compiles all files included by default (as described above) with the default compiler options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f15ae1c31705135e881325aff5e8a346aec850a" translate="yes">
          <source>A &lt;em&gt;Class Decorator&lt;/em&gt; is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739e90613eeebc5ddc5aad4956b450c569d06044" translate="yes">
          <source>A &lt;em&gt;Decorator&lt;/em&gt; is a special kind of declaration that can be attached to a &lt;a href=&quot;#class-decorators&quot;&gt;class declaration&lt;/a&gt;, &lt;a href=&quot;#method-decorators&quot;&gt;method&lt;/a&gt;, &lt;a href=&quot;#accessor-decorators&quot;&gt;accessor&lt;/a&gt;, &lt;a href=&quot;#property-decorators&quot;&gt;property&lt;/a&gt;, or &lt;a href=&quot;#parameter-decorators&quot;&gt;parameter&lt;/a&gt;. Decorators use the form &lt;code&gt;@expression&lt;/code&gt;, where &lt;code&gt;expression&lt;/code&gt; must evaluate to a function that will be called at runtime with information about the decorated declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d56f6c32829ea8275bf6ee5b435cef5ea1f700d" translate="yes">
          <source>A &lt;em&gt;Method Decorator&lt;/em&gt; is declared just before a method declaration. The decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccf751dfd4d98326bc686f6800698c46d17f29f" translate="yes">
          <source>A &lt;em&gt;Parameter Decorator&lt;/em&gt; is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d07f771fa09284a877bbd7b7a8c2200cc1db787" translate="yes">
          <source>A &lt;em&gt;Property Decorator&lt;/em&gt; is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6b5887333ec599f15cdbb7f6b7e41fb24767d5" translate="yes">
          <source>A &lt;em&gt;UMD&lt;/em&gt; module is one that can &lt;em&gt;either&lt;/em&gt; be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, are written this way. For example, in Node.js or using RequireJS, you would write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e831c596f2ba69b8fe1db558042cf1c087c1093" translate="yes">
          <source>A &lt;em&gt;discriminant property type guard&lt;/em&gt; is an expression of the form &lt;code&gt;x.p == v&lt;/code&gt;, &lt;code&gt;x.p === v&lt;/code&gt;, &lt;code&gt;x.p != v&lt;/code&gt;, or &lt;code&gt;x.p !== v&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are a property and an expression of a string literal type or a union of string literal types. The discriminant property type guard narrows the type of &lt;code&gt;x&lt;/code&gt; to those constituent types of &lt;code&gt;x&lt;/code&gt; that have a discriminant property &lt;code&gt;p&lt;/code&gt; with one of the possible values of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af1a45bc532371f09945859192093e4e8e7412f" translate="yes">
          <source>A &lt;em&gt;global plugin&lt;/em&gt; is global code that changes the shape of some global. As with &lt;em&gt;global-modifying modules&lt;/em&gt;, these raise the possibility of runtime conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc8c7dc8fcaba1930b06da38f845e8f6f69fa81" translate="yes">
          <source>A &lt;em&gt;global-modifying module&lt;/em&gt; alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to &lt;code&gt;String.prototype&lt;/code&gt; when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feba008bb2bcd964cfc399bbc4dcc4618c8ee5e2" translate="yes">
          <source>A &lt;em&gt;global&lt;/em&gt; library is one that can be accessed from the global scope (i.e. without using any form of &lt;code&gt;import&lt;/code&gt;). Many libraries simply expose one or more global variables for use. For example, if you were using &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, the &lt;code&gt;$&lt;/code&gt; variable can be used by simply referring to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2289bfc724a5518dc15e4cf5caddd6815845abb" translate="yes">
          <source>A &lt;em&gt;module plugin&lt;/em&gt; changes the shape of another module (either UMD or module). For example, in Moment.js, &lt;code&gt;moment-range&lt;/code&gt; adds a new &lt;code&gt;range&lt;/code&gt; method to the &lt;code&gt;moment&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ef51072168e8fd07bcbf75e20f6fc4027a24cd" translate="yes">
          <source>A &lt;em&gt;relative import&lt;/em&gt; is one that starts with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt;. Some examples include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b0f2d1642b6ff9d5026c5e25f91e02a415f34ce" translate="yes">
          <source>A &lt;strong&gt;mixin class&lt;/strong&gt; is a class declaration or expression that &lt;code&gt;extends&lt;/code&gt; an expression of a type parameter type. The following rules apply to mixin class declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc78810f3bf6a5a9528d8023bc05c6167ef7eaf5" translate="yes">
          <source>A &lt;strong&gt;mixin constructor type&lt;/strong&gt; refers to a type that has a single construct signature with a single rest argument of type &lt;code&gt;any[]&lt;/code&gt; and an object-like return type. For example, given an object-like type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; is a mixin constructor type with an instance type &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3913101a43966f2ccebcc4061aa10428b79384" translate="yes">
          <source>A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e0c2d8bf86efa81f30b4c26580fc67ebbeb4fa" translate="yes">
          <source>A Note on Soundness</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fed6c2698af466cd828f08e21a3d01c917783df" translate="yes">
          <source>A String value that is used in the creation of the default string description of an object. Called by the built-in method &lt;code&gt;Object.prototype.toString&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef0b6dff4f7313a8976b0f0d521140ee41e223c" translate="yes">
          <source>A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e30e8a952193f7d1df77a0d6d1fd7f212ffd28d" translate="yes">
          <source>A call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to &lt;code&gt;any&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8884cee9c569ba73051b4c3340106f32892db818" translate="yes">
          <source>A class constructor may be marked &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt;. A class with private constructor cannot be instantiated outside the class body, and cannot be extended. A class with protected constructor cannot be instantiated outside the class body, but can be extended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714c30cc5bf310cba2527f465ba3e4937c25903e" translate="yes">
          <source>A class declaration (&lt;code&gt;class C { }&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1596db92a712b48a7d481d2882462ab7d550ed38" translate="yes">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe8ffa4d7e2dafe57b8f8b2aa2642caf1ac898fd" translate="yes">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e50811af3fd1732eb86ab44223050144ba8d75bb" translate="yes">
          <source>A common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804ef8425f60cc16494a3ecb8868620fc1d13254" translate="yes">
          <source>A common mistake is to try to use the &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; syntax to refer to a module file, rather than using an &lt;code&gt;import&lt;/code&gt; statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an &lt;code&gt;import&lt;/code&gt; (e.g. the &lt;code&gt;...&lt;/code&gt; in &lt;code&gt;import x from &quot;...&quot;;&lt;/code&gt;, &lt;code&gt;import x = require(&quot;...&quot;);&lt;/code&gt;, etc.) path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6d372643d97ce6592522ce945c126f9d03b1c9" translate="yes">
          <source>A common pattern in JavaScript is to use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;instanceof&lt;/code&gt; to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4ced30fbc2cc726d8b092795387c4127143776" translate="yes">
          <source>A common task is to take an existing type and make each of its properties optional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a0349d4a486bbf82efbf586f7757d0e2680533" translate="yes">
          <source>A common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture &lt;code&gt;i&lt;/code&gt; at each iteration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80959b7998a3c5a6f92da1dbaffb14e14087102c" translate="yes">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. When &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; contains type variables, whether to resolve to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or to defer, is determined by whether or not the type system has enough information to conclude that &lt;code&gt;T&lt;/code&gt; is always assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ca32ef30629a0ef6871441758cc40ce1b420bb" translate="yes">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. Whether to resolve or defer is determined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd55e1e2d504c4f5bd31948eb3ce7aa0ce3cb13" translate="yes">
          <source>A constructor may also be marked &lt;code&gt;protected&lt;/code&gt;. This means that the class cannot be instantiated outside of its containing class, but can be extended. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cadb83f444b2961a4d934d5f3d490b70e4dd1268" translate="yes">
          <source>A couple of limitations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24cf92f2108f7fc6dfb574930ec5df83db3eb0b" translate="yes">
          <source>A couple of things to note about accessors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e092fc815a872b9563a100f8c02b2d0d350825ab" translate="yes">
          <source>A decorator is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1b6da91369927675bbf031b2ce4d5a731e97d7" translate="yes">
          <source>A destructuring declaration introduces one or more named variables and initializes them with values extracted from properties of an object or elements of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba8a48bfe00ec663b6ebb1eceade9d3fff1e679" translate="yes">
          <source>A file whose only top-level declaration is &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; (remove &lt;code&gt;Foo&lt;/code&gt; and move everything &amp;lsquo;up&amp;rsquo; a level)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc68bdd4f9a61f11fcf8696eedfc299f303d8bd" translate="yes">
          <source>A function valued property that is the constructor function that is used to create derived objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ddd76ccda8c0cc52ac61d7fddcd8fcbe5f3cba" translate="yes">
          <source>A function whose body has a reference to the &lt;code&gt;arguments&lt;/code&gt; reference is implicitly considered to have a var-arg parameter (i.e. &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt;). Use JSDoc var-arg syntax to specify the type of the arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ea0b4e5327f594259519fd62a19b6890ab37c08" translate="yes">
          <source>A function&amp;rsquo;s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6091230201a03184d43d1bf3ecad6c4e357aa7e8" translate="yes">
          <source>A generator function can have a return type annotation, just like a function. The annotation represents the type of the generator returned by the function. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3058f8f1fd4d84d69ca0c3d8c31e05fc06865a11" translate="yes">
          <source>A generator function with no type annotation can have the type annotation inferred. So in the following case, the type will be inferred from the yield statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e63dbd0af2ae2aa5dc876191453fa9346622e3" translate="yes">
          <source>A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) following the name of the class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96453b7ccf72e8b01e41461635fa60edbe83b5ea" translate="yes">
          <source>A generic parameter default follows the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6264a6174402b53e580cc927dfee79a2d86c4b7" translate="yes">
          <source>A handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value &lt;code&gt;2&lt;/code&gt; but weren&amp;rsquo;t sure what that mapped to in the &lt;code&gt;Color&lt;/code&gt; enum above, we could look up the corresponding name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3d8efbbf391dd508c0f59ddc90ddfd5e9cb8ce" translate="yes">
          <source>A helpful addition to the standard set of datatypes from JavaScript is the &lt;code&gt;enum&lt;/code&gt;. As in languages like C#, an enum is a way of giving more friendly names to sets of numeric values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae627315bc177e68b8b178eb3fe934f925ae5a99" translate="yes">
          <source>A key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there&amp;rsquo;s no need to proactively wrap up the exported symbols in a namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10dfd449e653eb5c28991f082b6ab993db0f38fc" translate="yes">
          <source>A library can consist of multiple modules, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="408eb52ef9fae5ded272c34e2fb8532daf7f4ceb" translate="yes">
          <source>A long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the &lt;code&gt;--build&lt;/code&gt; flag with &lt;code&gt;tsc&lt;/code&gt;. This is effectively a new entry point for &lt;code&gt;tsc&lt;/code&gt; that behaves more like a build orchestrator than a simple compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf50654387dec069aed329536e7230529d81996c" translate="yes">
          <source>A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9bcb6811c5b2878897a2775d961f00651e45117" translate="yes">
          <source>A mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; permits any &lt;code&gt;K&lt;/code&gt; assignable to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29451e8b78ccc3f4b9ac772135d8ff18632a054a" translate="yes">
          <source>A method that converts an object to a corresponding primitive value. Called by the &lt;code&gt;ToPrimitive&lt;/code&gt; abstract operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="116f6b876af45833882c2bd0e4ed75e7920c3f86" translate="yes">
          <source>A method that determines if a constructor object recognizes an object as one of the constructor&amp;rsquo;s instances. Called by the semantics of the instanceof operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790df4f5d480d1c7b853c049c80823994596880d" translate="yes">
          <source>A method that returns the default iterator for an object. Called by the semantics of the for-of statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db447b4ab93c0844fc4e212f82c10b11c2a634ec" translate="yes">
          <source>A modifier with no &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; prefix is the same as a modifier with a &lt;code&gt;+&lt;/code&gt; prefix. So, the &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; type above corresponds to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dbeca90d263824170468112465310c954b28b6b" translate="yes">
          <source>A module name will be computed for each module based on its relative location to &lt;code&gt;rootDir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcfc7285f1ba3d870a6928e1733a7273fde019a" translate="yes">
          <source>A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51dd9695c995c08645a93f5859af50c64ef61af8" translate="yes">
          <source>A more common error that this feature catches is adding a newline after a &lt;code&gt;return&lt;/code&gt; statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02309890136fe9803436c2b1bde34201107f663d" translate="yes">
          <source>A namespace &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a type, &lt;code&gt;Y&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae465077e189312db19e43d1c7bdbb04e391e9f" translate="yes">
          <source>A namespace &lt;code&gt;Z&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bbec5ff2f5cfc37ba667daafc8343e4c27cc4d" translate="yes">
          <source>A namespace import (i.e. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;) is now correctly flagged as uncallable. Calling it will result in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2830a5f5ce7dd5eaff83de00bb84188237d5ac6f" translate="yes">
          <source>A new &lt;code&gt;!&lt;/code&gt; post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation &lt;code&gt;x!&lt;/code&gt; produces a value of the type of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; excluded. Similar to type assertions of the forms &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; and &lt;code&gt;x as T&lt;/code&gt;, the &lt;code&gt;!&lt;/code&gt; non-null assertion operator is simply removed in the emitted JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2655be7a46ceb733d0fd15d66bae85ebe5cb1eb1" translate="yes">
          <source>A new flag is also added in TypeScript 2.0 to flag all uses of &lt;code&gt;this&lt;/code&gt; in functions without an explicit type annotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce3e808c856b4c4b90bbc578b4afa30e7e8a218" translate="yes">
          <source>A new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4571ad9d84c9c7959037752a1b8faca40bbe10a7" translate="yes">
          <source>A nightly build from the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript&amp;rsquo;s &lt;code&gt;master&lt;/code&gt;&lt;/a&gt; branch is published by midnight PST to NPM and NuGet. Here is how you can get it and use it with your tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a025aabca041d8656b9b41a0f1be5a93ff1fe1" translate="yes">
          <source>A non-relative import can be resolved relative to &lt;code&gt;baseUrl&lt;/code&gt;, or through path mapping, which we&amp;rsquo;ll cover below. They can also resolve to &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declarations&lt;/a&gt;. Use non-relative paths when importing any of your external dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036c7405ac8596f3f842074ad7095463b1af061e" translate="yes">
          <source>A non-relative import to &lt;code&gt;moduleB&lt;/code&gt; such as &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt;, in a source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt;, would result in attempting the following locations for locating &lt;code&gt;&quot;moduleB&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908464f8d4f6e5d96a7983c65456609769299d87" translate="yes">
          <source>A note about &amp;lsquo;let&amp;rsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe7c80c1a11cfefa188943b94c8dce4cafd7212" translate="yes">
          <source>A note about &lt;code&gt;let&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d8d6a247e4459c0dd02162269341b98212407d" translate="yes">
          <source>A partial version of it would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc358ce5550ca2f28f0b4972670dc958c4e4327" translate="yes">
          <source>A polymorphic &lt;code&gt;this&lt;/code&gt; type represents a type that is the &lt;em&gt;subtype&lt;/em&gt; of the containing class or interface. This is called &lt;em&gt;F&lt;/em&gt;-bounded polymorphism. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns &lt;code&gt;this&lt;/code&gt; after each operation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bfc09c2ed20b76aa6a3b9cc810f2a50f0733568" translate="yes">
          <source>A project source layout sometimes does not match that of the output. Usually a set of build steps result in generating the final output. These include compiling &lt;code&gt;.ts&lt;/code&gt; files into &lt;code&gt;.js&lt;/code&gt;, and copying dependencies from different source locations to a single output location. The net result is that modules at runtime may have different names than the source files containing their definitions. Or module paths in the final output may not match their corresponding source file paths at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282c27706098563c877f1ff268884923d740e395" translate="yes">
          <source>A property access or a function call produces a compile-time error if the object or function is of a type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. However, type guards are extended to support non-null and non-undefined checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59344ab2361c175ea781e369233d17a3ef1173a2" translate="yes">
          <source>A property declared with a &lt;code&gt;get&lt;/code&gt; accessor and no &lt;code&gt;set&lt;/code&gt; accessor is considered read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b689c46a292974d609ea79412658e0ee92a02aed" translate="yes">
          <source>A property or index signature can now be declared with the &lt;code&gt;readonly&lt;/code&gt; modifier is considered read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d52bcb9c5e9671606eed7fffb194263c9890a7a" translate="yes">
          <source>A regular expression method that matches the regular expression against a string. Called by the &lt;code&gt;String.prototype.match&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd6edb9d65460dc36b50f0399530c31b1e87d57" translate="yes">
          <source>A regular expression method that replaces matched substrings of a string. Called by the &lt;code&gt;String.prototype.replace&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d5cbe9a0d4a216822033b575ab84161f890fd4" translate="yes">
          <source>A regular expression method that returns the index within a string that matches the regular expression. Called by the &lt;code&gt;String.prototype.search&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d40fad27af50b9cfc4c1b7935edd018faa338e" translate="yes">
          <source>A regular expression method that splits a string at the indices that match the regular expression. Called by the &lt;code&gt;String.prototype.split&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc17888ce2ecd41d7b6b0d5fb3a3670f069072bf" translate="yes">
          <source>A relative import is resolved relative to the importing file and &lt;em&gt;cannot&lt;/em&gt; resolve to an ambient module declaration. You should use relative imports for your own modules that are guaranteed to maintain their relative location at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28de4947ee9f22a7989c024ed424c3f367678816" translate="yes">
          <source>A relative import will be resolved relative to the importing file. So &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9edb5186e2748078674706a60a9cf32f84d1333" translate="yes">
          <source>A rest parameter is permitted to have a generic type that is constrained to an array type, and type inference can infer tuple types for such generic rest parameters. This enables higher-order capturing and spreading of partial parameter lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7553b7e9850da0e4309ead9e8788fc38bf0c98" translate="yes">
          <source>A simple rule to follow is to only declare types &lt;em&gt;namespaced&lt;/em&gt; by whatever global variable the library defines. For example, if the library defines the global value &amp;lsquo;cats&amp;rsquo;, you should write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f69678357ce810ac7be6d3a7871e410f98bb81" translate="yes">
          <source>A triple-slash reference path is resolved relative to the containing file, if unrooted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353474e46afb00c48588800a3c6d0c5342041035" translate="yes">
          <source>A tsconfig.json file that doesn&amp;rsquo;t specify a files property (and therefore implicitly references all *.ts files in all subdirectories) can now contain an exclude property that specifies a list of files and/or directories to exclude from the compilation. The exclude property must be an array of strings that each specify a file or folder name relative to the location of the tsconfig.json file. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0d20ca9dd32bdd7425a8bf1f2869e727193b73" translate="yes">
          <source>A tuple type permits an element to be omitted if it has a postfix &lt;code&gt;?&lt;/code&gt; modifier on its type and all elements to the right of it also have &lt;code&gt;?&lt;/code&gt; modifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fda59c87a9ce8c6218af973a8a318d8c48726a" translate="yes">
          <source>A type &lt;code&gt;C&lt;/code&gt; in the &lt;code&gt;X.Z&lt;/code&gt; namespace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8cb0beae34b84268f8712bb01776f705387774" translate="yes">
          <source>A type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="882188abb4f22a21291e791a69d7bc7153c6ea49" translate="yes">
          <source>A type &lt;code&gt;Y&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74378f84a7232e7c818036a1aa4f8e790357dad0" translate="yes">
          <source>A type &lt;code&gt;Z&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace (the instance shape of the class)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1687cc1f239d5cbfef8dd21147b9dd24d76a0c8" translate="yes">
          <source>A type alias declaration (&lt;code&gt;type sn = number | string;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4c2689d169ce1d458db13d7d40fdbf2f6b6244" translate="yes">
          <source>A type alias that takes the union of those types &amp;mdash; the &lt;em&gt;union&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2efd539d70b51bc5ae0611e5b848813a9078c1" translate="yes">
          <source>A type can include an index signature to explicitly indicate that excess properties are permitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c383b7f56821c1f9a53cd7d2c78316dfd7e93b" translate="yes">
          <source>A type guard for a dotted name has no effect following an assignment to any part of the dotted name. For example, a type guard for &lt;code&gt;x.y.z&lt;/code&gt; will have no effect following an assignment to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.y&lt;/code&gt;, or &lt;code&gt;x.y.z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a377432dffa8ea7066844e2455d6987bca2958f" translate="yes">
          <source>A type parameter is deemed optional if it has a default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d14b0d6b21fc7288313f91b187510fabde9b646" translate="yes">
          <source>A types package is a folder with a file called &lt;code&gt;index.d.ts&lt;/code&gt; or a folder with a &lt;code&gt;package.json&lt;/code&gt; that has a &lt;code&gt;types&lt;/code&gt; field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d41e9733c26726f7735bdd4c4e805ad6e0b738" translate="yes">
          <source>A union type describes a value that can be one of several types. We use the vertical bar (&lt;code&gt;|&lt;/code&gt;) to separate each type, so &lt;code&gt;number | string | boolean&lt;/code&gt; is the type of a value that can be a &lt;code&gt;number&lt;/code&gt;, a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77032b55ce2cb4248190b5e5184e5e0b38ee393b" translate="yes">
          <source>A user could express &lt;code&gt;2 * 5 + 1&lt;/code&gt; as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199d562e0a71e63f245aa31f49c36513d849c222" translate="yes">
          <source>A value &lt;code&gt;C&lt;/code&gt; that is a property of the &lt;code&gt;X.Z&lt;/code&gt; value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e079e6071fdb5e16a79cbbbac36f7c59e77e29" translate="yes">
          <source>A value &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a value, &lt;code&gt;Z&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72326d369b07efe650b4c687b18320a6555b7a1a" translate="yes">
          <source>A value &lt;code&gt;Y&lt;/code&gt; (of type &lt;code&gt;number&lt;/code&gt;) that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db8707fec6d748cc12ab97735dc5f33a19182c2" translate="yes">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ce9a077fea19a3768255595563e3f325b99287" translate="yes">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value (the constructor function of the class)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac5e8f9f24c7489cdb9a76f63355463e38d2ed2" translate="yes">
          <source>A variable declared with no type annotation and an initial value of &lt;code&gt;[]&lt;/code&gt; is considered an implicit &lt;code&gt;any[]&lt;/code&gt; variable. However, each subsequent &lt;code&gt;x.push(value)&lt;/code&gt;, &lt;code&gt;x.unshift(value)&lt;/code&gt; or &lt;code&gt;x[n] = value&lt;/code&gt; operation &lt;em&gt;evolves&lt;/em&gt; the type of the variable in accordance with what elements are added to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d19e4c7a5fa9d0f738254cc159113f3fd200b2" translate="yes">
          <source>AMD / RequireJS SimpleModule.js</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d64764987e4f302df4936aa982040ba263c5581e" translate="yes">
          <source>AMD Module names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e985e77edef4f93404d5e6768643dd9e768f9b" translate="yes">
          <source>AMD-dependency optional names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62845d0d9af23cbc1eec333eb2ecfd163d55a726" translate="yes">
          <source>API Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512a3dad0b0ce90df79e253450f20d82200891c0" translate="yes">
          <source>APIs to Support &lt;code&gt;--build&lt;/code&gt; and &lt;code&gt;--incremental&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34de1e75f36d287ab4c87ba0a5a432c79f048d4" translate="yes">
          <source>ASP.NET Core</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366e9dcb2473f425157fef0b4dc8e68450d4a527" translate="yes">
          <source>ASP.NET Core + TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2bfb743d58034cf4f2ef0407bda4991e6e266a" translate="yes">
          <source>ASP.NET Core: Add TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ca92c515719697094cd865e18cbd056f86e90b" translate="yes">
          <source>ASP.NET Core: Setup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8462d6e971391c5728bd5c55cd114f6c45225c83" translate="yes">
          <source>Above, all inferences for &lt;code&gt;T&lt;/code&gt; originate in contravariant positions, and we therefore infer the &lt;em&gt;best common subtype&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;. This contrasts with inferences from covariant positions, where we infer the &lt;em&gt;best common supertype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99c638eab09eef692bca448341109f58d65928f" translate="yes">
          <source>Above, we have a &lt;code&gt;StringArray&lt;/code&gt; interface that has an index signature. This index signature states that when a &lt;code&gt;StringArray&lt;/code&gt; is indexed with a &lt;code&gt;number&lt;/code&gt;, it will return a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29268223f69d326a5adbf22aa200f48337d3383a" translate="yes">
          <source>Above, we have a numeric enum where &lt;code&gt;Up&lt;/code&gt; is initialized with &lt;code&gt;1&lt;/code&gt;. All of the following members are auto-incremented from that point on. In other words, &lt;code&gt;Direction.Up&lt;/code&gt; has the value &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; has &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;Left&lt;/code&gt; has &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;Right&lt;/code&gt; has &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4c6101610761ea26e2cfbf041a94da323abdcc" translate="yes">
          <source>Abstract Classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d2d55c032fde11e5fb12992c8af2dbab612b6c" translate="yes">
          <source>Abstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The &lt;code&gt;abstract&lt;/code&gt; keyword is used to define abstract classes as well as abstract methods within an abstract class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c7ee5a4b4ef6e67fa95b9c12e51b21561cd41f" translate="yes">
          <source>Abstract properties and accessors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1eac0b05aa68bdf95d2d14137e5c9213052598" translate="yes">
          <source>Accept JavaScript files as inputs (with &lt;code&gt;allowJs&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52e0a010fa39d93f5775a9f132d6deb5746c842" translate="yes">
          <source>Accessing an element outside the set of known indices fails with an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9211673b68532807a6d2c852f45d3d0a3786afaf" translate="yes">
          <source>Accessor Decorators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes">
          <source>Accessors</source>
          <target state="translated">Accessors</target>
        </trans-unit>
        <trans-unit id="ba917141f6a1280321df068fb903677e998c5655" translate="yes">
          <source>Add TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f2f0c4f330f17bca1624a3a414eba729371bb6" translate="yes">
          <source>Add TypeScript code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2826bcb0cd82d31aa891fcd966fb1d7028f4f052" translate="yes">
          <source>Add a TypeScript configuration file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15c277560e45ee3069031db7b1443def54bf1e5" translate="yes">
          <source>Add an index signature to the weak type (i.e. &lt;code&gt;[propName: string]: {}&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d86f6887abf355322f84124fc796c5eca75b3b63" translate="yes">
          <source>Add example code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030eb6eab9d9ce5260b44edf17a0969d1e22a783" translate="yes">
          <source>Add modules to the code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0897ccd0a932866daaf546a1ee6c09bc49494aa1" translate="yes">
          <source>Add the following code to the &lt;code&gt;app.ts&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2583d632f0a677d9ba11848beebe77e200bfeb" translate="yes">
          <source>Adding a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbea2ea77887f1c86da0aa25a3f25ac23ead618" translate="yes">
          <source>Adding using a &lt;code&gt;namespace&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ec7e9fd3e27aeb0e50a50e1368f25d547f3a58" translate="yes">
          <source>Adding using an &lt;code&gt;interface&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b365969c1cff42268e57d78eee550841c3962e45" translate="yes">
          <source>Additional module resolution flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc0373dbdf9447ae6c7d80c2c34b8dc3091badc" translate="yes">
          <source>Additionally, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450&quot;&gt;another caveat&lt;/a&gt; of this new functionality is that due to certain limitations, &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; can&amp;rsquo;t yet fully model generic functions or functions that have overloads. When using these methods on a generic function, type parameters will be substituted with the empty object type (&lt;code&gt;{}&lt;/code&gt;), and when used on a function with overloads, only the last overload will ever be modeled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c07f0e3695aef1b4eb4f9692657a313d0394be" translate="yes">
          <source>Additionally, generators just assumed the type of &lt;code&gt;yield&lt;/code&gt; was always &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9897d524bc1adaf827ec23a4f3fb80edccd67b36" translate="yes">
          <source>Additionally, the &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; interface can be used to specify extra properties used by the JSX framework which are not generally used by the components&amp;rsquo; props or arguments - for instance &lt;code&gt;key&lt;/code&gt; in React. Specializing further, the generic &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the &lt;code&gt;ref&lt;/code&gt; attribute of type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91aefeee6c1829819327d9dfe82ea027b26c097" translate="yes">
          <source>Additionally, to preserve compatibility with existing build workflows, &lt;code&gt;tsc&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; automatically build dependencies unless invoked with the &lt;code&gt;--build&lt;/code&gt; switch. Let&amp;rsquo;s learn more about &lt;code&gt;--build&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb5aba76318fd8538ec6382a2c356952caebc47" translate="yes">
          <source>Adjustments in module resolution logic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051f9a673eec5b48c922324c96f3a02ca352b664" translate="yes">
          <source>Advanced Combinations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1b06d1c8791683bf16e52630b903baefea447c" translate="yes">
          <source>Advanced Techniques</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes">
          <source>Advanced Topics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes">
          <source>Advanced Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54113ef438de5a4b862decfc768acf29d440c666" translate="yes">
          <source>After calling &lt;code&gt;bundle&lt;/code&gt; we use &lt;code&gt;source&lt;/code&gt; (our alias for vinyl-source-stream) to name our output bundle &lt;code&gt;bundle.js&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f00e5874f2361b655fbe3423460af4e2465d08" translate="yes">
          <source>After that, you&amp;rsquo;ll be able to import lodash with no issues, and get accurate completions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c3fc331ac388b23fddf0085ca5e76cb6b8d9ba" translate="yes">
          <source>After you should see an &lt;code&gt;npm&lt;/code&gt; folder in your solution explorer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4510f26185d545e1f9aaebb5b614087f1eb1769" translate="yes">
          <source>Again, being explicit, the following things create values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eae1c48b28511e25caa33f05cb9d4dfab638b20" translate="yes">
          <source>Again, the above code is equivalent to the following.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf3fd22ac6a36d88878ca8d53a1d82c01a94dc2" translate="yes">
          <source>Again, we&amp;rsquo;ve used &lt;code&gt;Bar&lt;/code&gt; as both a type and a value here. Note that we didn&amp;rsquo;t have to declare the &lt;code&gt;Bar&lt;/code&gt; value as being of the &lt;code&gt;Bar&lt;/code&gt; type &amp;ndash; they&amp;rsquo;re independent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="3cb27e3d6bbfd0f085fdbe02b42dec5e1744a340" translate="yes">
          <source>Aliasing doesn&amp;rsquo;t actually create a new type - it creates a new &lt;em&gt;name&lt;/em&gt; to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6c399afd60c09e251a03e83d9bc9a1c384d822" translate="yes">
          <source>All dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; section in your &lt;code&gt;package.json&lt;/code&gt;. For example, imagine we authored a package that used Browserify and TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d806df121ff13261ffaf919876e11a01813f29" translate="yes">
          <source>All implementation files must be matched by an &lt;code&gt;include&lt;/code&gt; pattern or listed in the &lt;code&gt;files&lt;/code&gt; array. If this constraint is violated, &lt;code&gt;tsc&lt;/code&gt; will inform you which files weren&amp;rsquo;t specified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd3b6e7826e2d43235c94e25c6703e5515d96cd" translate="yes">
          <source>All imports from a shorthand module will have the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0df7a5916e9a8c72882caaac651848e0eeba01" translate="yes">
          <source>All imports from a shorthand module will have the any type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee6f3b1a8be543040dd1ce13fd64e1e346a330f" translate="yes">
          <source>All imports to any module under &lt;code&gt;myLibrary&lt;/code&gt; would be considered to have the type &lt;code&gt;any&lt;/code&gt; by the compiler; thus, shutting down any checking on the shapes or types of these modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57b961e5b675a38b262426fe4a67078aecb1477" translate="yes">
          <source>All of the following are red flags for module structuring. Double-check that you&amp;rsquo;re not trying to namespace your external modules if any of these apply to your files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f48504d51c20fbd89324cd74339cdb9e81a6c89" translate="yes">
          <source>All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315057eae22d62b0d6ed2f001a47c88ccf49ba08" translate="yes">
          <source>All the strictness flags (including just &lt;code&gt;strict&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11378de3ed9317ae1cc9f1d37c886e6088970d68" translate="yes">
          <source>AllValidators.ts</source>
          <target state="translated">AllValidators.ts</target>
        </trans-unit>
        <trans-unit id="a20b06e157c57d9a78b57caf9d2b542ef2e984fd" translate="yes">
          <source>Allow JavaScript files to be compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817e523690a2903bd65bba96f5e1a75cd990d338" translate="yes">
          <source>Allow accessing UMD globals from modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe8c273574466d1f1e8e48a9866bca1049e958da" translate="yes">
          <source>Allow captured &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; in loops</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0313de72619ba05b9f37beba9bc65ea42f27f39d" translate="yes">
          <source>Allow comments in tsconfig.json</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243a0709c425e1dcc854b129a4e90d01a36f16eb" translate="yes">
          <source>Allow default imports from modules with no default export. This does not affect code emit, just typechecking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe77e2c3c1c895a9de9714c2ee0a698b6a26f2c" translate="yes">
          <source>Allow duplicate identifiers across declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d79af7df869c57746cb28085bd6d2457c5fb38" translate="yes">
          <source>Allowed Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13463866162e9452fc9466d99aed31c7a984ccdc" translate="yes">
          <source>Along with setting &lt;code&gt;--strict&lt;/code&gt; on by default, &lt;code&gt;tsc --init&lt;/code&gt; has an enhanced output. Default &lt;code&gt;tsconfig.json&lt;/code&gt; files generated by &lt;code&gt;tsc --init&lt;/code&gt; now include a set of the common compiler options along with their descriptions commented out. Just un-comment the configuration you like to set to get the desired behavior; we hope the new output simplifies the setting up new projects and keeps configuration files readable as projects grow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000392e9a54edfab5429407c52d48703930eb447" translate="yes">
          <source>Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d76c0268868384341c5ebe547b3dfcde453c7e8e" translate="yes">
          <source>Also functions that are only called within their own bodies are considered unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540904303a257559b0aeb7e9b92f1cd1b53941db" translate="yes">
          <source>Also important to note is that &lt;code&gt;bigint&lt;/code&gt;s produce a new string when using the &lt;code&gt;typeof&lt;/code&gt; operator: the string &lt;code&gt;&quot;bigint&quot;&lt;/code&gt;. Thus, TypeScript correctly narrows using &lt;code&gt;typeof&lt;/code&gt; as you&amp;rsquo;d expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd80e664a9b3ce76fb4d4f379a35bae6ecbe4f1" translate="yes">
          <source>Also note that if your main declaration file is named &lt;code&gt;index.d.ts&lt;/code&gt; and lives at the root of the package (next to &lt;code&gt;index.js&lt;/code&gt;) you do not need to mark the &lt;code&gt;&quot;types&quot;&lt;/code&gt; property, though it is advisable to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4972f01952c5c6e56d36346995929543d00951" translate="yes">
          <source>Also note that when passing &lt;code&gt;--skipDefaultLibCheck&lt;/code&gt;, the compiler will only skip checking files with &lt;code&gt;/// &amp;lt;reference no-default-lib=&quot;true&quot;/&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6107d072614a65187bd05ede831a6df1fe3accb4" translate="yes">
          <source>Also of note, the use of &lt;code&gt;public&lt;/code&gt; on arguments to the constructor is a shorthand that allows us to automatically create properties with that name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffaed40200024bd111a6ac8089de97648f831c1" translate="yes">
          <source>Also see our wiki page on &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file&quot;&gt;using a custom language service file&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776519898394bb463eff6e30826aacacc1c3da0d" translate="yes">
          <source>Also, a nightly NuGet package to match the &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx&quot;&gt;nightly npm package&lt;/a&gt; is available on &lt;a href=&quot;https://myget.org&quot;&gt;myget&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92083d2d24448d6d4118e25e1f3cea32d46ea66c" translate="yes">
          <source>Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we&amp;rsquo;ll need to use &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags on our webpage to load each emitted file in the appropriate order, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4887b96a506ca1d0dee1e635003357f0a6d33ea" translate="yes">
          <source>Alternatively, you can just say &lt;code&gt;options&lt;/code&gt; has the type &lt;code&gt;any&lt;/code&gt; which is the easiest thing to do, but which will benefit you the least.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43606c68a4c7cf72a0b682885c31d5f52ead2334" translate="yes">
          <source>Alternatives:</source>
          <target state="translated">Alternatives:</target>
        </trans-unit>
        <trans-unit id="8b0c73776c390d3a5733d04f89fdf034e34ec53e" translate="yes">
          <source>Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let&amp;rsquo;s look at a toy Observable example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee099122cb78c5739b4f82dcc4924480f635a80" translate="yes">
          <source>Ambient Classes and Functions Can Merge</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6f848cded8d022fa12717b22d3680a848ad354" translate="yes">
          <source>Ambient Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2667f9b3defd3ff5b3a3b96ac30b540f477156" translate="yes">
          <source>Ambient Namespaces</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072993bc8b201bfe9df293be81dcb3aa09bada66" translate="yes">
          <source>Ambient enums</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d6b6f06f272969887a807bdfd8080d800b8ed3" translate="yes">
          <source>Ambient enums are used to describe the shape of already existing enum types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66df472a2808c10e6e2267da8ee23d33589aa345" translate="yes">
          <source>An &lt;code&gt;enum&lt;/code&gt; declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96131132b1fece4018da08fbe5ae8cdc0f0bbe7c" translate="yes">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e546120c9b08c182111a543340edaa52f8faa73" translate="yes">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c85d60a22bfc72f8be52c9d3473a14b494ef936" translate="yes">
          <source>An &lt;em&gt;Accessor Decorator&lt;/em&gt; is declared just before an accessor declaration. The accessor decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the accessor and can be used to observe, modify, or replace an accessor&amp;rsquo;s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637fccf99e1ca3360a8e160638d580b112623960" translate="yes">
          <source>An &lt;em&gt;async function&lt;/em&gt; is a function or method that has been prefixed with the &lt;code&gt;async&lt;/code&gt; modifier. This modifier informs the compiler that function body transposition is required, and that the keyword &lt;code&gt;await&lt;/code&gt; should be treated as a unary expression instead of an identifier. An &lt;em&gt;Async Function&lt;/em&gt; must provide a return type annotation that points to a compatible &lt;code&gt;Promise&lt;/code&gt; type. Return type inference can only be used if there is a globally defined, compatible &lt;code&gt;Promise&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c5ee8216b1102dc214045b20531cb28dca3422" translate="yes">
          <source>An Example Project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a8a8bcfbc30a10a37d2f8c0745492817b04bd8" translate="yes">
          <source>An IIFE returning a function, class or empty object literal, is also recognized as a namespace:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b482032e9b848d1769fffddba6728c3f513e97d" translate="yes">
          <source>An Object whose own property names are property names that are excluded from the &amp;lsquo;with&amp;rsquo; environment bindings of the associated objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9346f4c4433fdb2ea0b41faaa1f055ba9e22c515" translate="yes">
          <source>An abstract class can declare abstract properties and/or accessors. Any sub class will need to declare the abstract properties or be marked as abstract. Abstract properties cannot have an initializer. Abstract accessors cannot have bodies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01bf8fd95c1254c73cd6a7e1bf75eab586904fa" translate="yes">
          <source>An entity accessed through an ES2015 namespace import is considered read-only (e.g. &lt;code&gt;foo.x&lt;/code&gt; is read-only when &lt;code&gt;foo&lt;/code&gt; is declared as &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ee76cce09b6dda0af497e582271e9daeb1fa9e" translate="yes">
          <source>An entity declared in an &lt;code&gt;import&lt;/code&gt; statement is considered read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010036a4ed3e6887f0a662f6e45e32f749a00f87" translate="yes">
          <source>An enum declaration (&lt;code&gt;enum E { A, B, C }&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a85dd24cd070fb5512fd0ef92b9518fceb29e8c" translate="yes">
          <source>An export default declaration specifies an expression that becomes the default export of a module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbd631e886efac25134c1822d5fc8c0a3f82701" translate="yes">
          <source>An import to a module with no declaration file will still be flagged as an error under &lt;code&gt;--noImplicitAny&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4089846541ea3f66ca0b3aa8324eb27446bfa87c" translate="yes">
          <source>An important rule is that &lt;code&gt;export&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; declarations export or import &lt;em&gt;all meanings&lt;/em&gt; of their targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9829bd2aaefcc0a918548bdfb97be8f7716b574b" translate="yes">
          <source>An index type &lt;code&gt;keyof T&lt;/code&gt; for some type &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3dee51effab23215f94b19b5e6ce849dbbb11b" translate="yes">
          <source>An interface can extend multiple interfaces, creating a combination of all of the interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfb2cf00eea3daab08c8ac76409915d529976bc" translate="yes">
          <source>An interface declaration (&lt;code&gt;interface I { x: number[]; }&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051272f0126c6f4c635d623e56a437da25ba082a" translate="yes">
          <source>An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99cc1cc22b07e8cafd4c0a4ab5a6f60816a8100b" translate="yes">
          <source>An object is deemed iterable if it has an implementation for the &lt;a href=&quot;symbols#symboliterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt; property. Some built-in types like &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Int32Array&lt;/code&gt;, &lt;code&gt;Uint32Array&lt;/code&gt;, etc. have their &lt;code&gt;Symbol.iterator&lt;/code&gt; property already implemented. &lt;code&gt;Symbol.iterator&lt;/code&gt; function on an object is responsible for returning the list of values to iterate on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f02b61e8ec8b6f2bec26f2bedf23c11ecf77a29" translate="yes">
          <source>An object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb8cf874c7b3539ef5e517ffab6e8f6b9569d43" translate="yes">
          <source>An object that supports async iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; method that returns an &lt;code&gt;AsyncIterator&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8447e71f06bf05be69e3922802bfe818075f229" translate="yes">
          <source>An operand is considered nullable if the type of the operand is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; or a union type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Note that the union type case only only occurs in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; disappear from unions in classic type checking mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d5ca7f2497f214678abf18ecf2b51c0278100b" translate="yes">
          <source>An unspecified type argument in JSDoc defaults to any:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9add44f9c257c0dbb7eebf6fe551aa600ac3c7bf" translate="yes">
          <source>And help in Japanese:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c2dac2f30e99536de68e97cb2b18f2d5db2533" translate="yes">
          <source>And just like type predicate signatures, these assertion signatures are incredibly expressive. We can express some fairly sophisticated ideas with these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f7abc94bd4652b1940c01f38e4cdba6a7de10d" translate="yes">
          <source>And results in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524218ceeaedc01c8daaf35729b043a8754e652f" translate="yes">
          <source>And the other is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7683ba2ccf1b61a19dd6dd9bbbf3a532801e3252" translate="yes">
          <source>And to use it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a379f1e77206b5fa5615fc791f830626638ff5b9" translate="yes">
          <source>And usage would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="955c6169edfe74a318e323004916b98e713d7add" translate="yes">
          <source>And with parameters to a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce043e3a6fddbda09013e27b4641adddde08990" translate="yes">
          <source>And, for pre-ES2015 code, it can be used to simulate static methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0355996ea2c36fc48cd0c3c40221f8808eb765" translate="yes">
          <source>Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;the article on the Mozilla Developer Network&lt;/a&gt;. In this section, we&amp;rsquo;ll give a short overview.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a7f2f6380d7122bad959764252b9e24c79240a" translate="yes">
          <source>Another distinction is that &lt;code&gt;for..in&lt;/code&gt; operates on any object; it serves as a way to inspect properties on this object. &lt;code&gt;for..of&lt;/code&gt; on the other hand, is mainly interested in values of iterable objects. Built-in objects like &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; implement &lt;code&gt;Symbol.iterator&lt;/code&gt; property allowing access to stored values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80278db3392e36b25471320c2c5c53b5cfd9afc0" translate="yes">
          <source>Another example would be the &lt;code&gt;TypeName&lt;/code&gt; type alias, which uses nested conditional types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59923c5b5918e19407ea7e824fe9454f6b96dd6d" translate="yes">
          <source>Another fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type &lt;code&gt;string&lt;/code&gt; to refer to these textual datatypes. Just like JavaScript, TypeScript also uses double quotes (&lt;code&gt;&quot;&lt;/code&gt;) or single quotes (&lt;code&gt;'&lt;/code&gt;) to surround string data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22e08f461a07d2394e4b0372b16fbe2608c33ae" translate="yes">
          <source>Another good practice is to have a &amp;ldquo;solution&amp;rdquo; &lt;code&gt;tsconfig.json&lt;/code&gt; file that simply has &lt;code&gt;references&lt;/code&gt; to all of your leaf-node projects and sets &lt;code&gt;files&lt;/code&gt; to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty &lt;code&gt;files&lt;/code&gt; array if you have at least one &lt;code&gt;reference&lt;/code&gt; in a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3ed357192d33940721ba58d1e4e4f234af944b" translate="yes">
          <source>Another property of block-scoped variables is that they can&amp;rsquo;t be read or written to before they&amp;rsquo;re actually declared. While these variables are &amp;ldquo;present&amp;rdquo; throughout their scope, all points up until their declaration are part of their &lt;em&gt;temporal dead zone&lt;/em&gt;. This is just a sophisticated way of saying you can&amp;rsquo;t access them before the &lt;code&gt;let&lt;/code&gt; statement, and luckily TypeScript will let you know that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6536ca406ade59e49db35f06a2bc4ae98274b219" translate="yes">
          <source>Another simple way is to use class expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0433a2f2345ca65e0ca8af5f86b17a73375f6b" translate="yes">
          <source>Another thing to keep in mind is that &lt;code&gt;const&lt;/code&gt; contexts don&amp;rsquo;t immediately convert an expression to be fully immutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0272d130e56f355222a749eeba841dae92661ec" translate="yes">
          <source>Another way that you can simplify working with namespaces is to use &lt;code&gt;import q = x.y.z&lt;/code&gt; to create shorter names for commonly-used objects. Not to be confused with the &lt;code&gt;import x = require(&quot;name&quot;)&lt;/code&gt; syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad06f386aa38881eb01e3e498f2167a151b8b1e6" translate="yes">
          <source>Another way to describe the example is that the type &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; is &lt;em&gt;bivariant&lt;/em&gt; (i.e. covariant &lt;em&gt;or&lt;/em&gt; contravariant) for &lt;code&gt;T&lt;/code&gt; in default type checking mode, but &lt;em&gt;contravariant&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt; in strict function types mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="5d5c745343bd6b12cb5e63f20e6477505f1a8f8f" translate="yes">
          <source>Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the &lt;code&gt;export&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874ba9764ea4968c93711ccd48458d3687016ab7" translate="yes">
          <source>Any files that are referenced by files included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are also included. Similarly, if a file &lt;code&gt;B.ts&lt;/code&gt; is referenced by another file &lt;code&gt;A.ts&lt;/code&gt;, then &lt;code&gt;B.ts&lt;/code&gt; cannot be excluded unless the referencing file &lt;code&gt;A.ts&lt;/code&gt; is also specified in the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d3fbb8847e7adc33f00a67766bcf84d23be884" translate="yes">
          <source>Any optional parameters must follow required parameters. Had we wanted to make the first name optional, rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f5a252552c3c04d4828a9b0a56671420fcd2c6" translate="yes">
          <source>Any other import is considered &lt;strong&gt;non-relative&lt;/strong&gt;. Some examples include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54cc3c33db9d0cc0052e3d3a5370d1f5fb94ee9" translate="yes">
          <source>Any time &lt;code&gt;isFish&lt;/code&gt; is called with some variable, TypeScript will &lt;em&gt;narrow&lt;/em&gt; that variable to that specific type if the original type is compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bab2aa131866dfb42803d6fff4f7d0f0c52622a" translate="yes">
          <source>Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with [] will have type any[], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e2c98bb415f3297c0331ba25fa80d4c29b187e3" translate="yes">
          <source>Anywhere a greeting is expected, you can provide a &lt;code&gt;string&lt;/code&gt;, a function returning a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;Greeter&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2721bd2d72a316000ef90a03336789e7221fe00" translate="yes">
          <source>Apache Cordova Apps still have the existing limitation of a single &lt;code&gt;tsconfig.json&lt;/code&gt; file, which must be in either the root or the &lt;code&gt;scripts&lt;/code&gt; folder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72aa9f35599ef319f4bdce587da34e4ef96d8ee" translate="yes">
          <source>App.ts</source>
          <target state="translated">App.ts</target>
        </trans-unit>
        <trans-unit id="f6775dc00da9c4ef2c019649d89650724f0bc81f" translate="yes">
          <source>Applying the &lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;, all declarations other than those you plan to modify should use &lt;code&gt;const&lt;/code&gt;. The rationale is that if a variable didn&amp;rsquo;t need to get written to, others working on the same codebase shouldn&amp;rsquo;t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using &lt;code&gt;const&lt;/code&gt; also makes code more predictable when reasoning about flow of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="5b19a51e973f07fb33a1f0b3290dd21625155468" translate="yes">
          <source>Array destructuring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5851b2384facd082dae02e6048cf9a0298dc5eb" translate="yes">
          <source>As a heads up, when using &lt;code&gt;strictNullChecks&lt;/code&gt;, your dependencies may need to be updated to use &lt;code&gt;strictNullChecks&lt;/code&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3e12e810f587516dce0ec17be3db602fa8d496" translate="yes">
          <source>As a nice bonus, this can also reduce the memory and runtime footprint of the compiler and language service by avoiding loading &lt;code&gt;.d.ts&lt;/code&gt; files from duplicate packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3d749ddb3000672893220ada4f38c622aabbb5" translate="yes">
          <source>As a note: we encourage the use of &lt;code&gt;--strictNullChecks&lt;/code&gt; when possible, but for the purposes of this handbook, we will assume it is turned off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977dbb0a6075f870e0e4b082c7e83acf8cacfabb" translate="yes">
          <source>As a result, TypeScript 3.2 considers the &lt;code&gt;error&lt;/code&gt; property in the following example to be a discriminant, whereas before it wouldn&amp;rsquo;t since &lt;code&gt;Error&lt;/code&gt; isn&amp;rsquo;t a singleton type. Thanks to this, narrowing works correctly in the body of the &lt;code&gt;unwrap&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368d21349de8cec5ff1bdfc7896830a65df05b5c" translate="yes">
          <source>As a result, users can write getters and setters in ambient contexts in TypeScript 3.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7895ee4a93d7fa1bb09b06ce0af1d11a32158318" translate="yes">
          <source>As an alternative to individual imports, a namespace import can be used to import an entire module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa46177b5c4d16d6b6bc058d8b30ad17e80456e" translate="yes">
          <source>As an example of new errors you might spot as a result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43f82802df7af1b9c148a7744a7e8b03aeeec58" translate="yes">
          <source>As an example of some types that are immediately resolved, we can take a look at the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d1fff48d37907013a550ea65a80338a2731aa0" translate="yes">
          <source>As an example, consider the need to escape a string that contains the character &amp;lsquo;ð ®·&amp;rsquo;. In UTF-16/UCS2, &amp;lsquo;ð ®·&amp;rsquo; is represented as a surrogate pair, meaning that it&amp;rsquo;s encoded using a pair of 16-bit code units of values, specifically &lt;code&gt;0xD842&lt;/code&gt; and &lt;code&gt;0xDFB7&lt;/code&gt;. Previously this meant that you&amp;rsquo;d have to escape the codepoint as &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt;. This has the major downside that it&amp;rsquo;s difficult to discern two independent characters from a surrogate pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cef5c14af957c7ec054d83d89e6e1099bf750eb" translate="yes">
          <source>As an example, getting the declarations for a library like lodash takes nothing more than the following command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cdcd63d828e3b22ca9083f5b988b61d9d275fa" translate="yes">
          <source>As an example, on many Unix-like systems, the standard output stream is accessible by the file &lt;code&gt;/dev/stdout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04db06e8634e811fc030ab034631e6269dc8b211" translate="yes">
          <source>As an example, the following code snippet</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b7043bfc26c1ba1d57755926f65d96698dcbdc6" translate="yes">
          <source>As an example, we can pipe our emitted JavaScript into a pretty printer like &lt;a href=&quot;https://www.npmjs.com/package/pretty-js&quot;&gt;pretty-js&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acab1badefe292ebd417e66a3c779d99e6f3970" translate="yes">
          <source>As discussed earlier, the compiler can visit files outside the current folder when resolving a module. This can be hard when diagnosing why a module is not resolved, or is resolved to an incorrect definition. Enabling the compiler module resolution tracing using &lt;code&gt;--traceResolution&lt;/code&gt; provides insight in what happened during the module resolution process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd062263fc01b5e1d46bab04d2fc86323793b16" translate="yes">
          <source>As in JavaScript, all numbers in TypeScript are floating point values. These floating point numbers get the type &lt;code&gt;number&lt;/code&gt;. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd66e26a872b778f91b4e166644723ee3f84de0" translate="yes">
          <source>As long as the parameter types line up, it&amp;rsquo;s considered a valid type for the function, regardless of the names you give the parameters in the function type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="840af689a0703390b87203932fb9e888f4976db7" translate="yes">
          <source>As mentioned above, TypeScript now errors when functions appear to be uncalled within &lt;code&gt;if&lt;/code&gt; statement conditions. An error is issued when a function type is checked in &lt;code&gt;if&lt;/code&gt; conditions unless any of the following apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5c086b08f5e14213b1e066b50db36d669f8f91" translate="yes">
          <source>As mentioned in &lt;a href=&quot;enums#union-enums-and-enum-member-types&quot;&gt;our section on enums&lt;/a&gt;, enum members have types when every member is literal-initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef133c43f210eb19ff5fbc570648cdd98a773f66" translate="yes">
          <source>As our application grows, we&amp;rsquo;ll want to split the code across multiple files to make it easier to maintain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1bb7cf0157b073ec01dbb6472be74930da9d121" translate="yes">
          <source>As part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called. This gave us the opportunity to expand support for another class of functions: functions that return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390fe60664424f4e52cb8b9bdf97c3dba17b9a17" translate="yes">
          <source>As specified in ECMAScript, mixing &lt;code&gt;number&lt;/code&gt;s and &lt;code&gt;bigint&lt;/code&gt;s in arithmetic operations is an error. You&amp;rsquo;ll have to explicitly convert values to &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b12aa1f9da2310999311b7475d8a9700fd525f1" translate="yes">
          <source>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6bf56e61f5837d2d137d88d1a894bdddcce94e" translate="yes">
          <source>As the name suggests, the component is defined as a JavaScript function where its first argument is a &lt;code&gt;props&lt;/code&gt; object. TS enforces that its return type must be assignable to &lt;code&gt;JSX.Element&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ca06e4caafd2fed96f322e77c268ce050caf98" translate="yes">
          <source>As we add more validators, we&amp;rsquo;re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let&amp;rsquo;s wrap up our objects into a namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a201a25fd7790f05a2ecb442c622ccca689a7b" translate="yes">
          <source>As we covered in &lt;a href=&quot;classes&quot;&gt;our section on classes&lt;/a&gt;, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class&amp;rsquo;s type parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39977ca24b8e7d4979279054a3ddcd2072307e9" translate="yes">
          <source>As we improve the playground and the website, &lt;a href=&quot;https://github.com/microsoft/TypeScript-Website/&quot;&gt;we welcome feedback and pull requests on GitHub&lt;/a&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0926e0c8d61335ab6e159abc80a290ccf182a2" translate="yes">
          <source>As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript&amp;rsquo;s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e667d5c6d0aea6aea249141e0079b9aabfe0e442" translate="yes">
          <source>As we mentioned, BigInt support is only available for the &lt;code&gt;esnext&lt;/code&gt; target. It may not be obvious, but because BigInts have different behavior for mathematical operators like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, etc., providing functionality for older targets where the feature doesn&amp;rsquo;t exist (like &lt;code&gt;es2017&lt;/code&gt; and below) would involve rewriting each of these operations. TypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bec2ed7fb7091a8ef64c32bc287724bfc0cce55" translate="yes">
          <source>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55f71cd30e6435a112a945f64ecb9e401e4684b" translate="yes">
          <source>As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca7c3fc0aeea895ca68482e3282da249688fb4f" translate="yes">
          <source>As with Generators, Async Generators can only be function declarations, function expressions, or methods of classes or object literals. Arrow functions cannot be Async Generators. Async Generators require a valid, global &lt;code&gt;Promise&lt;/code&gt; implementation (either native or an ES2015-compatible polyfill), in addition to a valid &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; reference (either a native symbol or a shim).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4960adc215b4ac881e5c35568584f22fd6212eb" translate="yes">
          <source>As with arrays, you can destructure the rest of the tuple with &lt;code&gt;...&lt;/code&gt;, to get a shorter tuple:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c88c0ca9b6b6b4f95fa0f5e0a3945111347bb7f" translate="yes">
          <source>As with assertion functions, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;read up more at the same pull request&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ebe0449790b742a22a4412bec079981f0005a3" translate="yes">
          <source>As with global modules, you might see these examples in the documentation of a UMD module, so be sure to check the code or documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0705018bf7b343a8a49c9a07104949e0fe3a4e7a" translate="yes">
          <source>As with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example &lt;code&gt;let x = 5;&lt;/code&gt; creates a value called &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a48f4680185d0a1c25499af1056b570588fb64" translate="yes">
          <source>As you might&amp;rsquo;ve figured out, we just declared a variable named &lt;code&gt;a&lt;/code&gt; with the value &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72457daa6f50ff48a819ba7cfab041aeb483b454" translate="yes">
          <source>As you type on the boxes you should see the message appear/change!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4a6547aa8a5fff93868acf4c855dc352b78b55" translate="yes">
          <source>Ask the file named &lt;code&gt;/root/src/moduleB.js&lt;/code&gt;, if it exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae145f96f9923e53fbb6e9f3f9610452236976e4" translate="yes">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;index.js&lt;/code&gt;. That file is implicitly considered that folder&amp;rsquo;s &amp;ldquo;main&amp;rdquo; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b89fe51a739705208f8a298ea55bb588950f3b6" translate="yes">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;package.json&lt;/code&gt; that specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; module. In our example, if Node.js found the file &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; containing &lt;code&gt;{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }&lt;/code&gt;, then Node.js will refer to &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89f9c9a7b547e368f3dab7225883398658593d9" translate="yes">
          <source>Assertion Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c46e5ab2ffec3f635dbcdf5bc83e5353066495" translate="yes">
          <source>Assertions in JavaScript are often used to guard against improper types being passed in. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8da00b586664722cbf919d60c3a4ea73823442f" translate="yes">
          <source>Assigned-before-use checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3dd9c1b7f42e306408c3dfe2c8989c03230b2e" translate="yes">
          <source>Assignment to union types works very intuitively &amp;ndash; anything you could assign to one of the union type&amp;rsquo;s members is assignable to the union:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="f204f370193bea63fc30347377344ab8d15db4a7" translate="yes">
          <source>Assignments at the top-level should behave the same way; in other words, a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; declaration is not required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62de5df53249972bb9af1fc4eb134121b22de084" translate="yes">
          <source>Assignments to &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a3538682165ab749b99e78129248b3c38f0d9b" translate="yes">
          <source>Assignments to properties of &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;global&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58799777e41ae1e8d930adcb89c0780ba66e38d5" translate="yes">
          <source>Assume that each of these modules exports an array of strings. For example &lt;code&gt;./zh/messages&lt;/code&gt; might contain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e528328da4f68ed5eb912249e43e3e2e00accde0" translate="yes">
          <source>Assuming that &lt;code&gt;__dirname&lt;/code&gt; is always available on &lt;code&gt;import.meta&lt;/code&gt;, the declaration would be done through reopening &lt;code&gt;ImportMeta&lt;/code&gt; interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c86e37952421654714f44ff0a3e0b511f5f15f" translate="yes">
          <source>Assumptions that DOM primitives like &lt;code&gt;document&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; exist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb1a430a57e52b71176eabf0a0a52ccef1c8fac" translate="yes">
          <source>Astute readers will notice that, for example, &lt;code&gt;class&lt;/code&gt; appeared in both the &lt;em&gt;type&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; lists. The declaration &lt;code&gt;class C { }&lt;/code&gt; creates two things: a &lt;em&gt;type&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the instance shape of the class, and a &lt;em&gt;value&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the constructor function of the class. Enum declarations behave similarly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd2a8a7dd2324b3dfc1a250fed0f9daa6541f3a" translate="yes">
          <source>Async Generators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1b53675cb58d1ec8542ffe7447c2dc8ed8d373" translate="yes">
          <source>Async Iteration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec7372c392b06a860ac46991a72a2226276fba1" translate="yes">
          <source>Async iterators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bec73a232efba048470ae0342c82f3228e1af2d" translate="yes">
          <source>At its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. The star of the show in optional chaining is the new &lt;code&gt;?.&lt;/code&gt; operator for &lt;em&gt;optional property accesses&lt;/em&gt;. When we write code like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1167ef7e58858fe2a166efd826d59d4d9cd2ba5" translate="yes">
          <source>At the command line, run the TypeScript compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78da82abc219a055bfa736ddf690eb4d03a6708" translate="yes">
          <source>At this point, if you try running &lt;code&gt;tsc&lt;/code&gt; at the root of your project, you should see output files in the &lt;code&gt;built&lt;/code&gt; directory. The layout of files in &lt;code&gt;built&lt;/code&gt; should look identical to the layout of &lt;code&gt;src&lt;/code&gt;. You should now have TypeScript working with your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378f484fcf34a8ed1dd8027e59916eb7638d8ea5" translate="yes">
          <source>At this point, the compiler will ask &amp;ldquo;what&amp;rsquo;s the shape of &lt;code&gt;moduleA&lt;/code&gt;?&amp;rdquo; While this sounds straightforward, &lt;code&gt;moduleA&lt;/code&gt; could be defined in one of your own &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files, or in a &lt;code&gt;.d.ts&lt;/code&gt; that your code depends on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed32a39d243798f06b391e5f95f8515b64a1895b" translate="yes">
          <source>At this point, you&amp;rsquo;re probably ready to start using TypeScript files. The first step is to rename one of your &lt;code&gt;.js&lt;/code&gt; files to &lt;code&gt;.ts&lt;/code&gt;. If your file uses JSX, you&amp;rsquo;ll need to rename it to &lt;code&gt;.tsx&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7ccc595171e95a7eb1f834393506196fbc0ea1" translate="yes">
          <source>Attribute type checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfeae50596a1c82d93481a9895a732d259c70b1" translate="yes">
          <source>Augmenting global/module scope from modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d9210af9045d4fe60bdb145dcc8d78ae6da80c" translate="yes">
          <source>Automatically set to PreferredUILang value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="adcde08c76f527a1993685af5dc553eeaf5a112d" translate="yes">
          <source>Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn&amp;rsquo;t support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca918fb61ddb9faae466290b72a8013b7e396e6" translate="yes">
          <source>Babel&amp;rsquo;s ES5 output should be very similar to TypeScript&amp;rsquo;s output for such a simple script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad5cf24690d2882eba4d3f2b0e0a8bf277990a5" translate="yes">
          <source>Back when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="c2fd3a989facf50da271d674c14207aa8ad92548" translate="yes">
          <source>Bare Import</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbd61f556fe3f920e0c1bc1a21ce34dd73099d6" translate="yes">
          <source>Base URL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172793b0e3b408efe74b0d9f46aaf934fcd5496f" translate="yes">
          <source>Base directory to resolve non-relative module names. See &lt;a href=&quot;module-resolution#base-url&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c8a7205576c1623baf3a7cfcb0a92c99932a66" translate="yes">
          <source>Based on the fact that the above function is being assigned to &lt;code&gt;Window.onscroll&lt;/code&gt;, Typescript knows that &lt;code&gt;uiEvent&lt;/code&gt; is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;, and not a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; like the previous example. &lt;code&gt;UIEvent&lt;/code&gt; objects contain no &lt;code&gt;button&lt;/code&gt; property, and so Typescript will throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eab8fc3ffa32aa796174a77104a420884806a36" translate="yes">
          <source>Basic Concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7519044f052a17daead9b75e1d213e160e8c8476" translate="yes">
          <source>Basic Gruntfile.js</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes">
          <source>Basic Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf61ba3f6509ba114cc8faf2b40e8e71ed35a95e" translate="yes">
          <source>Basic Types: Any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61d7e43d7dc9242055a885bc7b2bde15bb723db" translate="yes">
          <source>Basic Types: Array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed07881f050cc30ef0327d36d1271fbb6c104615" translate="yes">
          <source>Basic Types: Enum</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243307eb146b441d38c323662afa7897483a957d" translate="yes">
          <source>Basic Types: Never</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="682c83570d93e651a69c5cc3c77d360b30490fae" translate="yes">
          <source>Basic Types: Tuple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a2993e94f23073b254c35171c856f14023d41f" translate="yes">
          <source>Basic Types: Void</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes">
          <source>Basic Usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d56735d306d59953f3983c85541271068dbd2d" translate="yes">
          <source>Basic gulpfile.js</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes">
          <source>Basic usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="412b5f9fcb13b09d7c79dbb054f0b03a03299e53" translate="yes">
          <source>Basic webpack.config.js when using Webpack 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb989b59b1f0bb11bab44b3981ea2961cb73436" translate="yes">
          <source>Basic webpack.config.js when using Webpack 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="74f706e43bf557f0281375454415863443ab6f79" translate="yes">
          <source>Be sure to read the &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote &amp;ldquo;The Impact of ES6 on Module Call Signatures&amp;rdquo;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9079f4cebe690d974b574d363d2382dfc53aa88d" translate="yes">
          <source>Because &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;an ideal property of software is being open to extension&lt;/a&gt;, you should always use an interface over a type alias if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5334136ac4ebd83a783dcba6f8148dc9c2a1da75" translate="yes">
          <source>Because &lt;code&gt;Dog&lt;/code&gt; extends the functionality from &lt;code&gt;Animal&lt;/code&gt;, we were able to create an instance of &lt;code&gt;Dog&lt;/code&gt; that could both &lt;code&gt;bark()&lt;/code&gt; and &lt;code&gt;move()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60995ae598e05ed025f86ab90ffdb0762aef9f1" translate="yes">
          <source>Because &lt;code&gt;createClock&lt;/code&gt;&amp;rsquo;s first parameter is of type &lt;code&gt;ClockConstructor&lt;/code&gt;, in &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt;, it checks that &lt;code&gt;AnalogClock&lt;/code&gt; has the correct constructor signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9360e6a9694db19840df20dcd21ab49ff88f74" translate="yes">
          <source>Because &lt;code&gt;haveMuscles&lt;/code&gt; is not exported, only the &lt;code&gt;animalsHaveMuscles&lt;/code&gt; function that shares the same un-merged namespace can see the symbol. The &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; function, even though it&amp;rsquo;s part of the merged &lt;code&gt;Animal&lt;/code&gt; namespace can not see this un-exported member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889f24f65391ea32e9fe866488efa3356b72acf4" translate="yes">
          <source>Because &lt;code&gt;never&lt;/code&gt; is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b5c5e8091b38c11351f7ff855704d831cd693e" translate="yes">
          <source>Because &lt;code&gt;never&lt;/code&gt; is assignable to every type, a function returning &lt;code&gt;never&lt;/code&gt; can be used when a callback returning a more specific type is required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860ec81e43c9b6e92f6dbbf8cdf9b9d2197d4f6a" translate="yes">
          <source>Because &lt;code&gt;onClickGood&lt;/code&gt; specifies its &lt;code&gt;this&lt;/code&gt; type as &lt;code&gt;void&lt;/code&gt;, it is legal to pass to &lt;code&gt;addClickListener&lt;/code&gt;. Of course, this also means that it can&amp;rsquo;t use &lt;code&gt;this.info&lt;/code&gt;. If you want both then you&amp;rsquo;ll have to use an arrow function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153757f182ba0912b5361e2742146aeb4241a619" translate="yes">
          <source>Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a031100a59ee4b651a08813917a85230e2c2bcaf" translate="yes">
          <source>Because TypeScript used to infer the type &lt;code&gt;BasicCalculator&lt;/code&gt; for each method in &lt;code&gt;BasicCalculator&lt;/code&gt; that returned &lt;code&gt;this&lt;/code&gt;, the type system would forget that it had &lt;code&gt;ScientificCalculator&lt;/code&gt; whenever using a &lt;code&gt;BasicCalculator&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b1d39859ec43b815d699d91662781b5301f06b" translate="yes">
          <source>Because a Function Component is simply a JavaScript function, function overloads may be used here as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="346e805975d898d144111246435e10f969746b37" translate="yes">
          <source>Because dependent projects make use of &lt;code&gt;.d.ts&lt;/code&gt; files that are built from their dependencies, you&amp;rsquo;ll either have to check in certain build outputs &lt;em&gt;or&lt;/em&gt; build a project after cloning it before you can navigate the project in an editor without seeing spurious errors. We&amp;rsquo;re working on a behind-the-scenes .d.ts generation process that should be able to mitigate this, but for now we recommend informing developers that they should build after cloning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ecbcc6afccbb397b118fab2ee6414e3c837482" translate="yes">
          <source>Because each &lt;code&gt;unique symbol&lt;/code&gt; has a completely separate identity, no two &lt;code&gt;unique symbol&lt;/code&gt; types are assignable or comparable to each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7c5c8de643b44139d21f506a256a1fa4c079dd" translate="yes">
          <source>Because interfaces (and other object types) introduce a level of indirection and their full structure doesn&amp;rsquo;t need to be eagerly built out, TypeScript has no problem working with this structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30f185f6397eb98d238c4bebb2ebc5adf9430be" translate="yes">
          <source>Because it&amp;rsquo;s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have &lt;em&gt;no&lt;/em&gt; dependencies) may still be global.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8323beb09423cac98a2130445e161c576b080307" translate="yes">
          <source>Because of that, they are now included by default in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c12007f3b8d8a541217ea17e828d1c39d86708" translate="yes">
          <source>Because the &lt;code&gt;switch&lt;/code&gt; is no longer exhaustive, TypeScript is aware that the function could sometimes return &lt;code&gt;undefined&lt;/code&gt;. If you have an explicit return type &lt;code&gt;number&lt;/code&gt;, then you will get an error that the return type is actually &lt;code&gt;number | undefined&lt;/code&gt;. However, this method is quite subtle and, besides, &lt;code&gt;--strictNullChecks&lt;/code&gt; does not always work with old code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef956693dc6ba68c2dd1bf8874b51293ed083ef" translate="yes">
          <source>Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61eeffa792a60ab404349a9470da23f0926e8080" translate="yes">
          <source>Because the generic function is now constrained, it will no longer work over any and all types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aaed882fdf6dc6a4a05e269679bc56b985060ef" translate="yes">
          <source>Because these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1803d91fbdbc9a61174b895ce63bd9e9db8a1a69" translate="yes">
          <source>Because we&amp;rsquo;ve captured &lt;code&gt;city&lt;/code&gt; from within its environment, we&amp;rsquo;re still able to access it despite the fact that the &lt;code&gt;if&lt;/code&gt; block finished executing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29eaff4a22709cf598b50d66101efbf59839265" translate="yes">
          <source>Before ES2015, Javascript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da503870a40cc51e10eea3a3855e0636fb12368" translate="yes">
          <source>Before TypeScript 2.0, a module identifier was always assumed to be extension-less; for instance, given an import as &lt;code&gt;import d from &quot;./moduleA.js&quot;&lt;/code&gt;, the compiler looked up the definition of &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; in &lt;code&gt;./moduleA.js.ts&lt;/code&gt; or &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt;. This made it hard to use bundling/loading tools like &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; that expect URI&amp;rsquo;s in their module identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7118581b77027e58723abfe83ca47073c2beca97" translate="yes">
          <source>Before we get to Browserify, let&amp;rsquo;s build our code out and add modules to the mix. This is the structure you&amp;rsquo;re more likely to use for a real app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3fafb80e647f5908678c0a1365fa6a9b3b25a53" translate="yes">
          <source>Bellow both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; will be marked as unused, because their values are never &lt;em&gt;read&lt;/em&gt;. Previously TypeScript would only check whether their values were &lt;em&gt;referenced&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1593ec79184963de3c26cd55f6cd6ff5fde3164" translate="yes">
          <source>Below, we&amp;rsquo;ve consolidated the Validator implementations used in previous examples to only export a single named export from each module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b1b090e17cb993e2e92ba109a6404125e1c084" translate="yes">
          <source>Best common type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f4d62437edf5f4e4d12a007397acc1aef2efe1" translate="yes">
          <source>Better Module Visibility Rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fe9a5afd90b3567ffa5a70e33cace7ce8a2cd6" translate="yes">
          <source>Better Support for &lt;code&gt;never&lt;/code&gt;-Returning Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21657adf3906ba19a9fc0bf5880e4ab0670a6b78" translate="yes">
          <source>Better Type Inference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2959d47c022c161218042546a51da5d892926e" translate="yes">
          <source>Better Unicode Support for Identifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0ba3945bacbf9283dac7172d7a127f0967cb4d" translate="yes">
          <source>Better checking for &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt; in operands of expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edbfa311bc15bdb82e37657789378148ae24f62" translate="yes">
          <source>Better handling for namespace patterns in &lt;code&gt;.js&lt;/code&gt; files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1459fb8ee8a9e746ee1ec8bc34a675600de96aa9" translate="yes">
          <source>Better inference for literal types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948f70e8d9053f46439ba57d043632fa6e5a5de4" translate="yes">
          <source>BigInt</source>
          <target state="translated">BigInt</target>
        </trans-unit>
        <trans-unit id="288d51c5150441fed0b9e86f5152123e527ee75c" translate="yes">
          <source>BigInt support in TypeScript introduces a new primitive type called the &lt;code&gt;bigint&lt;/code&gt; (all lowercase). You can get a &lt;code&gt;bigint&lt;/code&gt; by calling the &lt;code&gt;BigInt()&lt;/code&gt; function or by writing out a BigInt literal by adding an &lt;code&gt;n&lt;/code&gt; to the end of any integer numeric literal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554ca025eac7b2c84da4d87e6d9f6fd09932aeac" translate="yes">
          <source>BigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers. TypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680e45e0d9641fb72fe09a5f60291f49ec52f51b" translate="yes">
          <source>Block scoped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8c3370d98498723b46771881ba81defd0dc40c" translate="yes">
          <source>Block-scoped variable capturing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a849fb31e66cbf4e00c81e17be0f996cdee6ecbd" translate="yes">
          <source>Block-scoping</source>
          <target state="translated">Block-scoping</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="a34e54cea707257c0130f46138224a1c1962a392" translate="yes">
          <source>Both &lt;code&gt;for..of&lt;/code&gt; and &lt;code&gt;for..in&lt;/code&gt; statements iterate over lists; the values iterated on are different though, &lt;code&gt;for..in&lt;/code&gt; returns a list of &lt;em&gt;keys&lt;/em&gt; on the object being iterated, whereas &lt;code&gt;for..of&lt;/code&gt; returns a list of &lt;em&gt;values&lt;/em&gt; of the numeric properties of the object being iterated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883409a532b5058d1cc5b8f4b490cb78e4d78575" translate="yes">
          <source>Both CommonJS and AMD generally have the concept of an &lt;code&gt;exports&lt;/code&gt; object which contains all exports from a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51d223984b330914b72e271341f74aef8d2cd0b" translate="yes">
          <source>Both of these dependencies will let TypeScript and webpack play well together. ts-loader helps Webpack compile your TypeScript code using the TypeScript&amp;rsquo;s standard configuration file named &lt;code&gt;tsconfig.json&lt;/code&gt;. source-map-loader uses any sourcemap outputs from TypeScript to inform webpack when generating &lt;em&gt;its own&lt;/em&gt; sourcemaps. This will allow you to debug your final output file as if you were debugging your original TypeScript source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes">
          <source>Breaking Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27e195ce4797e99f5340bc74096020036597226" translate="yes">
          <source>Broadly speaking, the way you &lt;em&gt;structure&lt;/em&gt; your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you&amp;rsquo;ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed81754147c265a661af47b5f96c56bae653c0d7" translate="yes">
          <source>Browserify</source>
          <target state="translated">Browserify</target>
        </trans-unit>
        <trans-unit id="edcb28a656230c4acfe867a59a63fd0995d0aef6" translate="yes">
          <source>Build Mode for TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e7d70d841f68a4ff5d6072efb212e8b37ee112" translate="yes">
          <source>Build mode (see below) will automatically build the referenced project if needed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a92faaf499ddda5acb18453d8927f47fed81460" translate="yes">
          <source>Build out-of-date projects in the correct order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2764e7dc64a6afa8f6572a70be9cc2ef88d207b2" translate="yes">
          <source>Build tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ec9400efe849c1db62787034008d1f92c2c91f" translate="yes">
          <source>Build-Free Editing with Project References</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af30b251537bff0e947429ed6b58b4a863bc66d" translate="yes">
          <source>Building on that work, the new &lt;code&gt;Generator&lt;/code&gt; type is an &lt;code&gt;Iterator&lt;/code&gt; that always has both the &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; methods present, and is also iterable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2e862f607c464ec5aa4c11cde1137378e9c2a2" translate="yes">
          <source>Building your first TypeScript file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b24ded4facb2cf945d4c05f6eb1ab851a39a94" translate="yes">
          <source>Builds this project and all of its dependencies specified by &lt;a href=&quot;project-references&quot;&gt;Project References&lt;/a&gt;. Note that this flag is not compatible with others on this page. See more &lt;a href=&quot;project-references&quot;&gt;here&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="343555e3e4e0ac83e26882ec6baa2142ba94e980" translate="yes">
          <source>Built-in &lt;em&gt;lib&lt;/em&gt; files are referenced in the same fashion as the &lt;code&gt;&quot;lib&quot;&lt;/code&gt; compiler option in &lt;em&gt;tsconfig.json&lt;/em&gt; (e.g. use &lt;code&gt;lib=&quot;es2015&quot;&lt;/code&gt; and not &lt;code&gt;lib=&quot;lib.es2015.d.ts&quot;&lt;/code&gt;, etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf48ef674c1f3f27e6a46bcb471b4b64069504c" translate="yes">
          <source>Built-in Combinations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f915eb393ecd85cb63e15dffe8826e1553f8b829" translate="yes">
          <source>But &lt;em&gt;not&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b2b6d682a32e9471d3d56044de293812fad6102" translate="yes">
          <source>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7399465efb16f2292f334ce116d2782df394ded" translate="yes">
          <source>But it&amp;rsquo;s more useful to have a general version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52aa7f7d640381262f44bf2422e0184ae5802614" translate="yes">
          <source>But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5085629431a212a779f2b5de79ca5c3f88994593" translate="yes">
          <source>But workaround of introducing the interface wasn&amp;rsquo;t intuitive for users. And in principle there really wasn&amp;rsquo;t anything wrong with the original version of &lt;code&gt;ValueOrArray&lt;/code&gt; that used &lt;code&gt;Array&lt;/code&gt; directly. If the compiler was a little bit &amp;ldquo;lazier&amp;rdquo; and only calculated the type arguments to &lt;code&gt;Array&lt;/code&gt; when necessary, then TypeScript could express these correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4960285f41cfd516633e4d60d8fcdf547d96a1af" translate="yes">
          <source>By Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56013fe0821df629b3c4ad53f4b6924be246e572" translate="yes">
          <source>By Example: Classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b36dc2d84d25fdd51b964cd61bedec7d9e60902" translate="yes">
          <source>By Example: Global Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3744ba63d2d3cc6574aaf71d98c1674b39508a8a" translate="yes">
          <source>By Example: Global Variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea9b1c9ef5abea178ee5d4cd53163ad4f035d14" translate="yes">
          <source>By Example: Objects with Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74283c34f93d05517451768bcffe2038c4e7a212" translate="yes">
          <source>By Example: Organizing Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786404ba943c8314507c329a9d6f9d54f3179127" translate="yes">
          <source>By Example: Overloaded Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20e92aa75ef55f57a42b723ab0f280766d7b7fe" translate="yes">
          <source>By Example: Reusable Types (Interfaces)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1f49420a7b27a3ee7b0e838fa3b2dbec6f81a8" translate="yes">
          <source>By Example: Reusable Types (Type Aliases)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a082a066e7a09d6b1c6e75f3176d5a38819ca5b2" translate="yes">
          <source>By default &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are subtypes of all other types. That means you can assign &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; to something like &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88529c44919e2de860ade6d72375e6a6ee709e4e" translate="yes">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c715e4fe44b99c0302712a9e167af08e84c2d13" translate="yes">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d87e4e57028fc486e676c2ecdd8c6471f91d0c" translate="yes">
          <source>By default all &lt;em&gt;visible&lt;/em&gt; &amp;ldquo;&lt;code&gt;@types&lt;/code&gt;&amp;rdquo; packages are included in your compilation. Packages in &lt;code&gt;node_modules/@types&lt;/code&gt; of any enclosing folder are considered &lt;em&gt;visible&lt;/em&gt;; specifically, that means packages within &lt;code&gt;./node_modules/@types/&lt;/code&gt;, &lt;code&gt;../node_modules/@types/&lt;/code&gt;, &lt;code&gt;../../node_modules/@types/&lt;/code&gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e369ee47538940ad2b625bd062454fb84b462ef8" translate="yes">
          <source>By default the TypeScript compiler does not report any errors in .js files including using &lt;code&gt;--allowJs&lt;/code&gt;. With TypeScript 2.3 type-checking errors can also be reported in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4e6fef05048e1036967e644248934ab3290242b" translate="yes">
          <source>By default the output new line character is &lt;code&gt;\r\n&lt;/code&gt; on Windows based systems and &lt;code&gt;\n&lt;/code&gt; on *nix based systems. &lt;code&gt;--newLine&lt;/code&gt; command line flag allows overriding this behavior and specifying the new line character to be used in generated output files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8dc7f5bdcc1f900ed0076c9443382574f8ede2" translate="yes">
          <source>By default the result of a JSX expression is typed as &lt;code&gt;any&lt;/code&gt;. You can customize the type by specifying the &lt;code&gt;JSX.Element&lt;/code&gt; interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2b32ff0e315d45d6fc02e2a6cbedac511ef9df" translate="yes">
          <source>By default the type of &lt;code&gt;this&lt;/code&gt; inside a function is &lt;code&gt;any&lt;/code&gt;. Starting with TypeScript 2.0, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b20c9a3a0cc7d25cfbb8affbd8cc2de8f4531f" translate="yes">
          <source>By default with these settings, when we run &lt;code&gt;tsc&lt;/code&gt;, TypeScript will look for a file called &lt;code&gt;.tsbuildinfo&lt;/code&gt; in the output directory (&lt;code&gt;./lib&lt;/code&gt;). If &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; doesn&amp;rsquo;t exist, it&amp;rsquo;ll be generated. But if it does, &lt;code&gt;tsc&lt;/code&gt; will try to use that file to incrementally type-check and update our output files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978c0bcb7dd8270885bef9e6f191062a2f183d1b" translate="yes">
          <source>By default, TypeScript assumes that &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are in the domain of every type. That means anything declared with the type &lt;code&gt;number&lt;/code&gt; could be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Since &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the &lt;code&gt;strictNullChecks&lt;/code&gt; option to spare you the stress of worrying about these issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a8ae67117a0b9e1048859af200beff97bdb1a4" translate="yes">
          <source>By default, enums begin numbering their members starting at &lt;code&gt;0&lt;/code&gt;. You can change this by manually setting the value of one of its members. For example, we can start the previous example at &lt;code&gt;1&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132e01557f70ffea3b32aeb9180827e17d27b06d" translate="yes">
          <source>By doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692f9bb4646bcb36f65c5f7ab233f8f2764f0cb4" translate="yes">
          <source>By installing TypeScript&amp;rsquo;s Visual Studio plugins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86eb4b62601e3e81ff1dca5cc4e6dbdc4a89a2c0" translate="yes">
          <source>By invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9887b67e7c7119b9c0b607afc13f555d0df339" translate="yes">
          <source>By invoking tsc with no input files and a &lt;code&gt;--project&lt;/code&gt; (or just &lt;code&gt;-p&lt;/code&gt;) command line option that specifies the path of a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or a path to a valid &lt;code&gt;.json&lt;/code&gt; file containing the configurations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c63c6b34aecd8a89f4657217a7bc97d993bf39e" translate="yes">
          <source>By invoking tsc with no input files, in which case the compiler searches for the &lt;code&gt;tsconfig.json&lt;/code&gt; file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89553a08b737777f431dc9d9801f1465f3a4fb2" translate="yes">
          <source>By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79537a92f4047372fecdfd37460ca2a8188a29b0" translate="yes">
          <source>By just passing the &lt;code&gt;--pretty&lt;/code&gt; command line option, TypeScript gives more colorful output with context about where things are going wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52ec44ebc49650e959b28d0b5dbe4cdf8ee0312" translate="yes">
          <source>By leveraging &lt;code&gt;rootDirs&lt;/code&gt; we can inform the compiler of this mapping and thereby allow it to safely resolve &lt;code&gt;./#{locale}/messages&lt;/code&gt;, even though the directory will never exist. For example, with the following &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6554ec42c2340c5fe50c2d315a5a222a594fab" translate="yes">
          <source>By now you&amp;rsquo;ve figured out that &lt;code&gt;var&lt;/code&gt; has some problems, which is precisely why &lt;code&gt;let&lt;/code&gt; statements were introduced. Apart from the keyword used, &lt;code&gt;let&lt;/code&gt; statements are written the same way &lt;code&gt;var&lt;/code&gt; statements are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8cb72c1385357bc15ce05b98a7efaf15553d757" translate="yes">
          <source>By reading this guide, you&amp;rsquo;ll have the tools to write complex definition files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411c4003c83ae27481aabc4631e018c37321d319" translate="yes">
          <source>By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3214b1c0cea1d0e9f41edbd469679a29258a29b8" translate="yes">
          <source>By the way, note that whereas some languages (e.g. C# and Scala) require variance annotations (&lt;code&gt;out&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;), variance emerges naturally from the actual use of a type parameter within a generic type due to TypeScript&amp;rsquo;s structural type system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2ff01863822bd01179d80d30eb7f560237e6bf" translate="yes">
          <source>Cache tagged template objects in modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca09b900f387b256b85a63942148d4d37afb51a" translate="yes">
          <source>Calculator.ts</source>
          <target state="translated">Calculator.ts</target>
        </trans-unit>
        <trans-unit id="401d915f4e82bf6c954f6cd72e5e9f45a0aa5cb6" translate="yes">
          <source>Callback Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fafd26147b30637f1273073910f82f95e1d409ec" translate="yes">
          <source>Calling &lt;code&gt;showHello&lt;/code&gt; calls &lt;code&gt;sayHello&lt;/code&gt; to change the paragraph&amp;rsquo;s text. Now change your gulpfile to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a615e5088a07823ba43f480f4662c6c1a80354" translate="yes">
          <source>Calls to &lt;code&gt;define(...)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ab62e91bddb3f6354c13e8b487593b38248ac3" translate="yes">
          <source>Can be used in a non-module file &lt;code&gt;global-script.ts&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4380ba68d466c9670378cbd5fc0514cb1373ac15" translate="yes">
          <source>Case clause fall-throughs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7500c883cdd17fa4172ea83911ebf91a32625de" translate="yes">
          <source>Casts</source>
          <target state="translated">Casts</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="3b3bc5f42ea5021b780ab4b12ba77a349aaacc40" translate="yes">
          <source>Caveats for Project References</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2ce6c0623a19e14dbf0dfa2aff6c6b8a60ed59" translate="yes">
          <source>Certain targets may include a polyfill or BigInt-like runtime object. For those purposes you may want to add &lt;code&gt;esnext.bigint&lt;/code&gt; to the &lt;code&gt;lib&lt;/code&gt; setting in your compiler options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d793fe93a13b689ec59340423e9412ead64313c" translate="yes">
          <source>Changes include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e20420d40f382739b91cf88de0439e6594790f" translate="yes">
          <source>Changes to &lt;code&gt;@types/React&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8221b7b528304e76abf18d987bda46c6ee653964" translate="yes">
          <source>Changing just the &lt;em&gt;internals&lt;/em&gt; in the implementation files required &lt;em&gt;typechecking&lt;/em&gt; the tests again, even though this wouldn&amp;rsquo;t ever cause new errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d9c66f05e816b7f1607245dc26fd6d3d736699" translate="yes">
          <source>Changing just the tests required typechecking the implementation again, even if nothing changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d270f4e0779e7abe44cf1c7ade9171d4da1e226" translate="yes">
          <source>Checks for, or usage of, module loaders like &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9de74e418fac1f9142ff12fe9c9f76d1ed611d6" translate="yes">
          <source>Children Type Checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afdd953eb19ed2481028f5c1801be583a951e01" translate="yes">
          <source>Choose &lt;strong&gt;File&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a0d9877ea63ee92b17d066ea8709fa9a3bb445" translate="yes">
          <source>Choose &lt;strong&gt;New Project&lt;/strong&gt; (Ctrl + Shift + N)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd5281fc9dbfe31531daf20b8c332f350b4edfb" translate="yes">
          <source>Choosing a value of &amp;ldquo;insert&amp;rdquo; or &amp;ldquo;remove&amp;rdquo; also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of &amp;ldquo;ignore&amp;rdquo; makes generated code match the semicolon preference detected in the current file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bc86498e55d8a5d31b0d503b4da787d8e95ab6" translate="yes">
          <source>Circularity between configuration files is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ff354b2b330bd1f8a0587675e43cb32a731f33" translate="yes">
          <source>Class</source>
          <target state="translated">Class</target>
        </trans-unit>
        <trans-unit id="c0951e6f10fd3da585b65324801b21d429796cf4" translate="yes">
          <source>Class Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed903b055db990734f20c5294ee8b8fe9164b593" translate="yes">
          <source>Class Decorators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114686c97766613a29d4825a44b3554d85c66bb1" translate="yes">
          <source>Class Field Mitigations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970423396db9a5db3ab146030f36eab03c9bccf9" translate="yes">
          <source>Class Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17339556e7ad7709847a75274febd591296e07e1" translate="yes">
          <source>Class expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="a84d6a1a8b04f068d6de8792f2128d31b00ac8e8" translate="yes">
          <source>Classes and function declarations can be authored directly as default exports. Default export class and function declaration names are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d45b7fb00541f6a8767f301189945313b46aa644" translate="yes">
          <source>Classes are namespaces in &lt;code&gt;.js&lt;/code&gt; files. This can be used to nest classes, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b983fc3a70e6b758f289e140144ef55d05f6582" translate="yes">
          <source>Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3e378460b98ee4b6e31c2d2b4b1e98ab972d3c" translate="yes">
          <source>Classes, functions, and object literals are namespaces</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130cd7fe33343e419f107596f21d6c9f9d976849" translate="yes">
          <source>Classic</source>
          <target state="translated">Classic</target>
        </trans-unit>
        <trans-unit id="f6c75e6aaeff53723e2a1e6793923cd37ed98551" translate="yes">
          <source>Cleaner output in &lt;code&gt;--watch&lt;/code&gt; mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f49daf62d5f581a04097acf72f7a587d200db2" translate="yes">
          <source>Code Generation for Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aef28f388cc2b6d39bbacf158f6b9e94711ece9" translate="yes">
          <source>Code generation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b36e1c52e858cb2c770a584f49971497c4d447" translate="yes">
          <source>Code that&amp;rsquo;s impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d618575aa117c6b80915c9311258252626feb94" translate="yes">
          <source>Colorization of JSX code in VS 2015</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb53519c43ebafe25dcbd0027128dc98a8b8ab12" translate="yes">
          <source>Comma-separated list of strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f955b144e5934e2a13c8a6e25bf74ab9af19e8c" translate="yes">
          <source>Common Questions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095e91de81638c9fb4d8559305b99b20bbe45f1b" translate="yes">
          <source>CommonJS / Node SimpleModule.js</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda542b3ab64c958c7a9092f48843c2d942bdc34" translate="yes">
          <source>CommonJS modules are supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c7d204d4bf5859f005b121118317373b38a4db" translate="yes">
          <source>CommonJS/Node.js-style imports of the form &lt;code&gt;var fs = require(&quot;fs&quot;);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf7acb84f79d901460975c5fdc7458a15a93f19" translate="yes">
          <source>Comparing two functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="d6b8ebf2c598d92ddec51164751b02621841cd23" translate="yes">
          <source>Compile a project given a valid configuration file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc74f0ec68df0086c27ed702abf06db93a06c411" translate="yes">
          <source>Compiled with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34dce96703c9facc673665ace0f6e41d2baf12d1" translate="yes">
          <source>Compiler Option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05a88eb5583088cfb5f3af23ae435a9c43d6850" translate="yes">
          <source>Compiler Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819847cb3aeaa240fbb932fa94d563cc19eec903" translate="yes">
          <source>Compiler Options in MSBuild</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90bb90e5e03ec7e90a57bd240d9219ac649a200" translate="yes">
          <source>Compiler Options in MSBuild: Mappings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e625c081c57011a6a742bfd97d6371d46e1c009" translate="yes">
          <source>Compiler Options in MSBuild: ToolsVersion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90111a236cc10e2295d1a4cb78fc2a7200d0283" translate="yes">
          <source>Compiler Options in MSBuild: TypeScriptCompileBlocked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630ca760deb5ffc09b9902125668d2e2290de0ec" translate="yes">
          <source>Compiler options can be specified using MSBuild properties within an MSBuild project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e477a43886859b1bbfebb3d31cc0e1afe3973d" translate="yes">
          <source>Compiler options specified on the command line override those specified in the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121ebc6937d17411ed69a6c37b96c6c30daba6d8" translate="yes">
          <source>Compiler supports configuring how to watch files and directories using the environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e701e70295cdeed377c2a897dc9eb65d813980" translate="yes">
          <source>Compiles to exactly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e358939ee8802319ad1e9d8583fade153122cd2d" translate="yes">
          <source>Compiling &lt;code&gt;app.ts&lt;/code&gt; using &lt;code&gt;--noResolve&lt;/code&gt; should result in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f6b87f27d7b70599485207ca9ad09ebb893c0b" translate="yes">
          <source>Compiling and running the output should result in the correct behavior on an ES3/ES5 engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ad9c5360eb345b6e3abac1b97c83060143ba82" translate="yes">
          <source>Compiling your code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3049a2659da50c034aba15cbcd7a9e1060cf134b" translate="yes">
          <source>Composite projects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="83cafe53ded70f2997ef3800657948653907c039" translate="yes">
          <source>Computed and constant members</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e65524c92dd7a22334161d17dd8cd47bc733c7" translate="yes">
          <source>Computed properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9428f1236d3847420fd8cb9cd0a04ad850ff601f" translate="yes">
          <source>Concatenate &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; modules with &lt;code&gt;--outFile&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5e0753cd9e20392bcaed52137c783d4a9ddd51" translate="yes">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d387732801bd4a6ea409c7bad5379547b3bde5c" translate="yes">
          <source>Conceptually, you might consider the type &lt;code&gt;[number, string]&lt;/code&gt; to be equivalent to the following declaration of &lt;code&gt;NumStrTuple&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5885783b19275de55be53a8442d9638f3760ca" translate="yes">
          <source>Conditional Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18754d6645b008e9cccf73f1f4d972ff5e83d7ff" translate="yes">
          <source>Conditional types are particularly useful when combined with mapped types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91f85c89a26e57f7343ae39715ed71a281561e2" translate="yes">
          <source>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8e0afa63b781a425483833f9aa183ceaf9ab905" translate="yes">
          <source>Conditional types in which the checked type is a naked type parameter are called &lt;em&gt;distributive conditional types&lt;/em&gt;. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of &lt;code&gt;T extends U ? X : Y&lt;/code&gt; with the type argument &lt;code&gt;A | B | C&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; is resolved as &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0df65b2f0f0c2d6eb36f5ad9bffffc45bb73cf7" translate="yes">
          <source>Configuration inheritance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf99561f068c66c86d1639cb9577f23d61bf6ef" translate="yes">
          <source>Configuration inheritance with &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced1a4e9ff8bc70735fabd8ba078581258e51943" translate="yes">
          <source>Configuring Watch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc951f746dfbc3c750c7470abaf09a1940d201f" translate="yes">
          <source>Configuring Watch: Background</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfdfb6d0adf0c6f64224be19c2696050ea66bf86" translate="yes">
          <source>Configuring directory watching using environment variable &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22e46f20a3414bdd5ff21017ac41439569be928" translate="yes">
          <source>Configuring file watching using environment variable &lt;code&gt;TSC_WATCHFILE&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d698cd217deceb13be84ca6f6626fed1b6ab6f" translate="yes">
          <source>Confusingly, the colon here does &lt;em&gt;not&lt;/em&gt; indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f0f2bf53179367a5dd94383df864d838cb31c8" translate="yes">
          <source>Congrats you&amp;rsquo;ve built your own .NET Core project with a TypeScript frontend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941a22f7b9c2d7277c983fd34ff491234fe4dbe8" translate="yes">
          <source>Consider a function that creates a new &lt;code&gt;HTMLElement&lt;/code&gt;, calling it with no arguments generates a &lt;code&gt;Div&lt;/code&gt;; you can optionally pass a list of children as well. Previously you would have to define it as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a93950d7261d2e851d7f697ab5cb3ac7485af4e" translate="yes">
          <source>Consider a simple calculator implementation defined in module &lt;code&gt;Calculator.ts&lt;/code&gt;. The module also exports a helper function to test the calculator functionality by passing a list of input strings and writing the result at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b47866222baeccb4c64149b4ef01b8e0a587f3" translate="yes">
          <source>Consider an internationalization scenario where a build tool automatically generates locale specific bundles by interpolating a special path token, say &lt;code&gt;#{locale}&lt;/code&gt;, as part of a relative module path such as &lt;code&gt;./#{locale}/messages&lt;/code&gt;. In this hypothetical setup the tool enumerates supported locales, mapping the abstracted path into &lt;code&gt;./zh/messages&lt;/code&gt;, &lt;code&gt;./de/messages&lt;/code&gt;, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51d52c45ed3cf02e41cacc5bac70bcc7582c3f8" translate="yes">
          <source>Consider the following example in which &lt;code&gt;Animal&lt;/code&gt; is the supertype of &lt;code&gt;Dog&lt;/code&gt; and &lt;code&gt;Cat&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="56d0232c998d778ef55ad35e83c8072f0d14ad7f" translate="yes">
          <source>Const</source>
          <target state="translated">Const</target>
        </trans-unit>
        <trans-unit id="3a99b4ee5816a7cb6e3ef98324d960dc2e81d981" translate="yes">
          <source>Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4e962186bdd37258f8b448774e2dcc2ffcf28a" translate="yes">
          <source>Constant-named properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e68a873a2be3470675b9ee933b98d781ae7fef" translate="yes">
          <source>Constraints</source>
          <target state="translated">Constraints</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes">
          <source>Constructor functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b457798406732b22f251fa45881744c1f45d717e" translate="yes">
          <source>Constructor functions are equivalent to classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78d1b6cb187422161c01ee1e5d55ae78d30cf52" translate="yes">
          <source>ConstructorParameters&amp;lt;T&amp;gt;</source>
          <target state="translated">ConstructorParameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="da51e1fa96b8ea9420b5fa91983ad6d946a019bc" translate="yes">
          <source>Constructs a tuple type of the types of the parameters of a function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79c41aef449a13b15632406dd45cb3296e79353" translate="yes">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9a660daa90148f4ac3004bd45d9aa896dbca1c" translate="yes">
          <source>Constructs a type by excluding from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534a3be9726f529289895ca42ccc7f72d9c3024c" translate="yes">
          <source>Constructs a type by extracting from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e405f5b40b51987ceb9ba1254eee89e3f48777c" translate="yes">
          <source>Constructs a type by picking all properties from &lt;code&gt;T&lt;/code&gt; and then removing &lt;code&gt;K&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13581efb3c161daf55efaa641c95a2937e6fa92d" translate="yes">
          <source>Constructs a type by picking the set of properties &lt;code&gt;K&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa9c5cf9d32c720825d39df29969f2f2dfdb044" translate="yes">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af78f1563236125ebb587f0510bfdfbb33bcfd1" translate="yes">
          <source>Constructs a type consisting of the instance type of a constructor function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67178f246747dfdb076d24fd6fe244d35eea9de7" translate="yes">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92a41e86aee02470adc5b04c55124c13aaff3f2" translate="yes">
          <source>Constructs a type with a set of properties &lt;code&gt;K&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87140e5d46947bf6adcacabd45f115a7d1fa950d" translate="yes">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6638ebe736931ecdde61f721cb96423f589cf127" translate="yes">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd2ae0ee1c90002e81a2a4c5b16f430d5eb5d5d" translate="yes">
          <source>Consumer.ts</source>
          <target state="translated">Consumer.ts</target>
        </trans-unit>
        <trans-unit id="19643388856c2476ec9508c66a7a7a22828effd3" translate="yes">
          <source>Consumers of your module should have as little friction as possible when using things that you export. Adding too many levels of nesting tends to be cumbersome, so think carefully about how you want to structure things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e33338e8781d70a603018c5dde7772e8b7ed456" translate="yes">
          <source>Consuming</source>
          <target state="translated">Consuming</target>
        </trans-unit>
        <trans-unit id="1e2af544c5c4ac1500ff8f4ed22cff22ab2d98d9" translate="yes">
          <source>Consuming Dependencies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a106946fb54af2e98e522133b69f05659ad46a" translate="yes">
          <source>Consumption</source>
          <target state="translated">Consumption</target>
        </trans-unit>
        <trans-unit id="43d406bfbbaf7c88699230d3aef03ec04c451529" translate="yes">
          <source>Consumption: Consuming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a38855f0870542b992b5fff7c96208a8884a3edf" translate="yes">
          <source>Consumption: Downloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a031c3bd99a755d80e5f7da09ef9648fc64a91" translate="yes">
          <source>Consumption: Searching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345009d8692863e53f52a509ffa69fac9f8c1193" translate="yes">
          <source>Contextual Typing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3890ff4bf80a096d2b98096a8e255fb1438bedf3" translate="yes">
          <source>Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8991bf4cd6fcd903e6d8843735f575800e222a1b" translate="yes">
          <source>Control flow analysis errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b790f356c8f06689edb0506cd42e89fdf6a448" translate="yes">
          <source>Control flow based type analysis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5608c55cda3285cb7a6c58d2a3953e2990e12df3" translate="yes">
          <source>Control flow based type analysis is particularly relevant in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because nullable types are represented using union types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676622699467dc4bbf4104746ce06f96c9893b26" translate="yes">
          <source>Conversely when importing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19762d1065d05ceddeccf92411a8f237f298697e" translate="yes">
          <source>Correctly finding &lt;code&gt;moduleA&lt;/code&gt; as it was passed on the command-line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebcad9c0d7aa9b4035b16adbfe6b459f9f243ec" translate="yes">
          <source>Corresponding changes to add &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; definition to the &lt;code&gt;JSX&lt;/code&gt; namespace in &lt;code&gt;@types/React&lt;/code&gt; are still needed. Keep in mind that there are some limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4152f39c03c0eb9e811b3dbb568be8c9505d1aa" translate="yes">
          <source>Create a &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3021179bd177130f09b3a8316daec30a4b2b93d6" translate="yes">
          <source>Create a &lt;code&gt;webpack.config.js&lt;/code&gt; file at the root of the project directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03be7fc935f815567fa5a4bac79cc78db732e8e0" translate="yes">
          <source>Create a file called &lt;code&gt;src/greet.ts&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ff776f31b78475f53c7d5b1e090dd761e922f3" translate="yes">
          <source>Create a file in &lt;code&gt;src&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="325cf797263cfffdce479b5e173823121f9d4d73" translate="yes">
          <source>Create a new project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b403f57bb09e035ae3515269845b15ce38bd27" translate="yes">
          <source>Create a page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647abbb31ccf904ba3c2c45c79357305334edf70" translate="yes">
          <source>Create a webpack configuration file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4329f654175ad323032c9448bb383b6b11a42c" translate="yes">
          <source>Currently &lt;code&gt;useDefineForClassFields&lt;/code&gt; is only available when targeting ES5 and upwards, since &lt;code&gt;Object.defineProperty&lt;/code&gt; doesn&amp;rsquo;t exist in ES3. To achieve similar checking for issues, you can create a seperate project that targets ES5 and uses &lt;code&gt;--noEmit&lt;/code&gt; to avoid a full build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cd15468b55ecfe136f817794b0238725c3ba6b" translate="yes">
          <source>Custom JSX factories using &lt;code&gt;--reactNamespace&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13be717a73cc5b208ba90837f91718dbedc0e5c7" translate="yes">
          <source>D3.d.ts (simplified excerpt)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be0205f470d4c7a15a776fec93f63444a3c1da3" translate="yes">
          <source>DEPRECATED. Use &lt;code&gt;--jsxFactory&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5799536cf1759401f5d741ea6f17c63a6dec9bbc" translate="yes">
          <source>DEPRECATED. Use &lt;code&gt;--outFile&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b53d5c8edc70418359a1b34ceac44b0e0760de" translate="yes">
          <source>DEPRECATED. Use &lt;code&gt;--skipLibCheck&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8569d62477c3f3a8139ad175f1b65dec4c78eb" translate="yes">
          <source>DOM Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd604d99e75e45d38bc7ac8fc714cde0097d901f" translate="yes">
          <source>Debug</source>
          <target state="translated">Debug</target>
        </trans-unit>
        <trans-unit id="2f52e43b6882a3466f1d969c1cb1001473303ede" translate="yes">
          <source>Declaration Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dddf315bf8c952c79983330b50ceb284d3027070" translate="yes">
          <source>Declaration Merging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8121a4da07765109d3a1ebd4396566febe4c31" translate="yes">
          <source>Declaration Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="dc141dc5502f9e0e32e0ce70ae020fbf031bce6e" translate="yes">
          <source>Declarations are &lt;em&gt;always&lt;/em&gt; initialized to &lt;code&gt;undefined&lt;/code&gt;, even if they have no initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41d762770bc6126d4d1fc990ef90759d58eb809" translate="yes">
          <source>Declarations are initialized with &lt;code&gt;Object.defineProperty&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fcdb4b2cc50995c39a00cc184737f3ebc0aa6de" translate="yes">
          <source>Declarations like &lt;code&gt;import * as a from 'b';&lt;/code&gt; or &lt;code&gt;export c;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347802d3a4b4ece7d3a20faf11435d4ac3181083" translate="yes">
          <source>Declare the properties if they really do exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6cb4979eadd458a450c7ab965139630dc251e6" translate="yes">
          <source>Declaring a variable in JavaScript has always traditionally been done with the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c3eb65b36120d75303dd4d19ce72e6c44591cc" translate="yes">
          <source>Declaring variables of type &lt;code&gt;void&lt;/code&gt; is not useful because you can only assign &lt;code&gt;null&lt;/code&gt; (only if &lt;code&gt;--strictNullChecks&lt;/code&gt; is not specified, see next section) or &lt;code&gt;undefined&lt;/code&gt; to them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d80403b6c6762d3135cc4b0364ef0ded8f2e39" translate="yes">
          <source>Decorator Composition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dcd3c584c6cd82aa44ce93304239e663bb5afb" translate="yes">
          <source>Decorator Evaluation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8d0308046fee6336b61acda5e70c000a657952" translate="yes">
          <source>Decorator Factories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e23b650a15e5c693ca1445133d5ee60d9d20b4" translate="yes">
          <source>Decorators</source>
          <target state="translated">Decorators</target>
        </trans-unit>
        <trans-unit id="ef21caee016081351dbb5463efe6ee7af49ce158" translate="yes">
          <source>Decorators &lt;code&gt;readonly&lt;/code&gt; and &lt;code&gt;enumerable(false)&lt;/code&gt; will be applied to the property &lt;code&gt;method&lt;/code&gt; before it is installed on class &lt;code&gt;C&lt;/code&gt;. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0adc2fcd71ed541d9efa8c14c5ad593144b45d" translate="yes">
          <source>Decorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of &lt;code&gt;reduceRight&lt;/code&gt; from the &lt;code&gt;__decorate&lt;/code&gt; helper. The changes also inline calls &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; and &lt;code&gt;Object.defineProperty&lt;/code&gt; in a backwards-compatible fashion that allows for a to clean up the emit for ES5 and later by removing various repetitive calls to the aforementioned &lt;code&gt;Object&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1c2fe01ec5b2e45d64dd5c8c5b343bff75cd10" translate="yes">
          <source>Deduplicated and redirected packages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34129b088d5dff9241ab7abdee9bb553051e041" translate="yes">
          <source>Deep Dive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f606bc9715586c081faee92e0f2cbb0b58c9865" translate="yes">
          <source>Deep Dive: Advanced Combinations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dce9edac26c50b7afe597930a0e4d53c87e0151" translate="yes">
          <source>Deep Dive: Definition File Theory: A Deep Dive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3520f4ddd89ba26396acae5290727ff5fa15a2" translate="yes">
          <source>Deep Dive: Using with export = or import</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="1dcd95e322dde1a1ed9488f1a9be1d85f6302d4a" translate="yes">
          <source>Default Export</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967dd37853ad5171b91867584cc350ce812dd723" translate="yes">
          <source>Default exports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c547e1ab7ad80d7eb94ac89b9475cb2f4ad47cf" translate="yes">
          <source>Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and &lt;code&gt;default&lt;/code&gt; is a reserved word - see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;#14080&lt;/a&gt; for details)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaafa95b77c94d35023aa4c831339a5f6888b4bd" translate="yes">
          <source>Default imports to CommonJS/AMD/UMD are now allowed (e.g. &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt;), and should work as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5a7e29bf0dd24fa5da97c8a78bd7b6478ae9da" translate="yes">
          <source>Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes">
          <source>Default values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373c6cd274b89a3c2582c933d56ada3fedbd82e3" translate="yes">
          <source>Default values let you specify a default value in case a property is undefined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1bceef18898234e393aee21da6ed7ad228f35ee" translate="yes">
          <source>Default-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function. This means optional parameters and trailing default parameters will share commonality in their types, so both</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd59cfb04075f034cef59cd0fa42daf1eb79992e" translate="yes">
          <source>Defaulted declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc6fc711e9d8d97a334f473c6d8d10ccc6870a3" translate="yes">
          <source>Definite Assignment Assertions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf6455d1dfb8e1b31ee9a23f39f86c7d9682067" translate="yes">
          <source>Definition File Theory: A Deep Dive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a5295ab13650a7fc6f7e3962a265606df1d7d936" translate="yes">
          <source>Dependencies on Global Libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6067defa2476905bfad8665adf2145c0c736a17f" translate="yes">
          <source>Dependencies on Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e045eae2e7599477b456a7f9a5428b685bf5aa" translate="yes">
          <source>Dependencies on UMD libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e13e2a33f9902dfc93501c0d9a6a0bb02f3d22" translate="yes">
          <source>Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;), require.js (&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt;), &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;, &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;, or &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015 native modules&lt;/a&gt; (ES6) module-loading systems. For more information on what the &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;register&lt;/code&gt; calls in the generated code do, consult the documentation for each module loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="3e9c954b8528b960f8219e88a4099c898d44449d" translate="yes">
          <source>Despite its appearance, the &lt;code&gt;readonly&lt;/code&gt; type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077ef6bb7e9ca7a81dc6c9028d61cccdb0c255dd" translate="yes">
          <source>Destructuring</source>
          <target state="translated">Destructuring</target>
        </trans-unit>
        <trans-unit id="b44f48048febb0c759b20a351a087cf970585895" translate="yes">
          <source>Destructuring also works in function declarations. For simple cases this is straightforward:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10db471f87802e009d06682868c12eb36cc956b" translate="yes">
          <source>Destructuring declarations also works for extracting values from arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae36bb7ef10a1d27e89e1a1e5cab353c1f39861" translate="yes">
          <source>Destructuring in declarations and assignments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ec4f69e7cfb0ff17a5b214356b9461fa3e35ea" translate="yes">
          <source>Destructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42315aeb1e4c4a5777df9a8f177e68cf09a45e0" translate="yes">
          <source>Destructuring works with already-declared variables as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="93207507957b31ebda343db069ec516064c2e248" translate="yes">
          <source>Detect if they are up-to-date</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec760709f148364d8b2d7249cf252878131b36c" translate="yes">
          <source>Determine how modules get resolved. Either &lt;code&gt;&quot;Node&quot;&lt;/code&gt; for Node.js/io.js style resolution, or &lt;code&gt;&quot;Classic&quot;&lt;/code&gt;. See &lt;a href=&quot;module-resolution&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4dff229f34e808acb097e68696d3c3718ad33a9" translate="yes">
          <source>Difference between the static and instance sides of classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369d22e8ba9dcb70fad4ac90845eb7df1bdf8234" translate="yes">
          <source>Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the &lt;code&gt;implements&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; clauses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3bd0e1c1cd621e6fbcc274e9d250ab1db3c03d9" translate="yes">
          <source>Disable bivariant parameter checking for function types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5492f8c219bc96eb3e1f985831cc36749273fc" translate="yes">
          <source>Disable size limitation on JavaScript project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d6cff3c670100d6c4947847436586c9f909a0c" translate="yes">
          <source>Disable strict checking of generic signatures in function types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc94ad5a04140e86aa8535c4085feefac81708ef" translate="yes">
          <source>Disallow inconsistently-cased references to the same file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca07b6b5d34354414804d10f0627d23afc021014" translate="yes">
          <source>Disallowed Merges</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e50354a241d00dc8de3bce0c769ecd4f5445e88" translate="yes">
          <source>Discriminated Unions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4eecd214b9b9b6bc1adea133960de053499fa9" translate="yes">
          <source>Distributive conditional types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5528e62826cea5c6ba5ef36621e1eb9d42697e3e" translate="yes">
          <source>Do &lt;em&gt;not&lt;/em&gt; use a &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; directive to declare a dependency to a UMD library!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008b4d242c76d59d51967dc8ca342e5c9c0171f2" translate="yes">
          <source>Do not add triple-slash references or module import targets to the list of compiled files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbda7eadbbdea2540dfa2471e3343bfd9af51dfa" translate="yes">
          <source>Do not emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; directives in module output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59925b0be84543d3516bc127648bdda000f9a36" translate="yes">
          <source>Do not emit outputs if any errors were reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8813a3a637738cb30116f3e3de2e596160d664a4" translate="yes">
          <source>Do not emit outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4aecc96dbac4010750a03d9cdf681cad5a2782" translate="yes">
          <source>Do not erase const enum declarations in generated code. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca81886d5434cef3d191c1781471a917134a9cf" translate="yes">
          <source>Do not generate custom helper functions like &lt;code&gt;__extends&lt;/code&gt; in compiled output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47ae1f25d416955ab5b35ad58b6d952ed341297" translate="yes">
          <source>Do not include the default library file (&lt;code&gt;lib.d.ts&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8700379392a841b4a989a2aedc6ee39cc22535" translate="yes">
          <source>Do not report errors on unreachable code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15fbdc059493fca2d963af5c43ecf0c0d7a9902" translate="yes">
          <source>Do not report errors on unused labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="566fc4907f5c0c600bf0a19df75cc66685e5a833" translate="yes">
          <source>Do not resolve symlinks to their real path; treat a symlinked file like a real one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c490d4d3e51d3eaf23f688f0c04328a2f1e119" translate="yes">
          <source>Do not truncate error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de81d23a68639d446e1d87128f4ef58b96239449" translate="yes">
          <source>Do not use namespaces in modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1bd4c5b18a5e7128a31d98a66a29dfc33c9ab2" translate="yes">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719ef97fc832b36afac23fa78d5c08cea2bf6141" translate="yes">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Generics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51c5dd50f698ff95f77e37efad482a71ac91486" translate="yes">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Optional Parameters in Callbacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db0d779491e142ea96422450aabb72ea9596eb7" translate="yes">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d768f81a860ccede1d11160fcbc58466d96e618" translate="yes">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Overloads and Callbacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5ad4c0d887c26ae55bb8c0b3d5849755f0038c" translate="yes">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Return Types of Callbacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f700abeac2aeb953e0842c2152d024b8f203e3" translate="yes">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Optional Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade57914de371d49ae2e67dcf398d7ca7cd0c7e5" translate="yes">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Union Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfd2cbcdd441b33e2a5bbad3336a20b3defd13a" translate="yes">
          <source>Do's and Don'ts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc9e9cd405cd7ed7a8fcb091e91a562cac25433" translate="yes">
          <source>Documentation describing how to &lt;code&gt;require&lt;/code&gt; or import the library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbfdc360214d58c7cb91ac8521019e85f36e4d8" translate="yes">
          <source>Documentation for UMD libraries will also often demonstrate a &amp;ldquo;Using in Node.js&amp;rdquo; example showing &lt;code&gt;require&lt;/code&gt;, and a &amp;ldquo;Using in the browser&amp;rdquo; example showing using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to load the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a9672278fb4d7400c1863d3b7c6f36d8ac8ae1" translate="yes">
          <source>Don&amp;rsquo;t be intimidated by the number of steps here - TypeScript is still only jumping up directories twice at steps (9) and (17). This is really no more complex than what Node.js itself is doing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8722b1128de0f74ea224044ed5056ae0d0f337" translate="yes">
          <source>Don&amp;rsquo;t worry about ordering the files you pass on the commandline - &lt;code&gt;tsc&lt;/code&gt; will re-order them if needed so that dependencies are always built first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c119e0650ca90fa2b62e09ff44c7b5ae64f45581" translate="yes">
          <source>Dotted names in type guards</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccdea752338ea9ee00074218ee9537a9bfdb03c3" translate="yes">
          <source>Dotted property for types with string index signatures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e035b7411ed359c6cdcd7655c199afa4eea32876" translate="yes">
          <source>Downlevel Async Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5cabcaa6a9d5f4be82b1397ad3c7fd26169c044" translate="yes">
          <source>Download the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt; script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4592f9ae45a647155e857c8bbbe5e38c83f01e" translate="yes">
          <source>Downloading</source>
          <target state="translated">Downloading</target>
        </trans-unit>
        <trans-unit id="984d20c7f5194c7c76c4882260c3e8e0fde40023" translate="yes">
          <source>Due to a bug, the following construct was previously allowed in TypeScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5d9cd03387fb41a856eb94a3f12c1e7c45d2c1" translate="yes">
          <source>Duo</source>
          <target state="translated">Duo</target>
        </trans-unit>
        <trans-unit id="39a8e581f6169ec0a9b5700af7954883b503baa0" translate="yes">
          <source>During type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript &lt;em&gt;will&lt;/em&gt;, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d2b88aa61f766d2be10ae43782a97a76b6067a" translate="yes">
          <source>Dynamic &lt;code&gt;import&lt;/code&gt; expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3eb3dff1f243ca444cd0f21c8fa73f06b676b18" translate="yes">
          <source>Dynamic Import Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d07d2547264048b907ca688317344223d5a0bb" translate="yes">
          <source>Dynamic Module Loading in Node.js</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728508cddb478117297b77baabcf7bb4bfc6cd00" translate="yes">
          <source>ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of &lt;em&gt;importing&lt;/em&gt; a &lt;em&gt;module&lt;/em&gt;. In JavaScript CommonJS (Node.js), for example, you would write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85cdebb2ea7d4e839607ea71d7d48e0db5d1567" translate="yes">
          <source>ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f11e274662541f2c8e0e3cb8196626ffc1b7d1e" translate="yes">
          <source>ES6 &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; declarations are now supported when targeting ES3 and ES5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes">
          <source>ES6 Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2acc8bb5a67f66241c722af8d11c013fb591c49" translate="yes">
          <source>ES6 generators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed61ecf2ad6576a5906a380e425433052f29a51a" translate="yes">
          <source>ES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="facf2ab431b3ab3e7ec6da17f65766fba3092531" translate="yes">
          <source>ES7 exponentiation operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1c0c4164faa864b6980e867e23ee2da1e921b7" translate="yes">
          <source>Each enum member has a value associated with it which can be either &lt;em&gt;constant&lt;/em&gt; or &lt;em&gt;computed&lt;/em&gt;. An enum member is considered constant if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4c52e3c0a22643b225662844bb284bc77facc8" translate="yes">
          <source>Each module can optionally export a &lt;code&gt;default&lt;/code&gt; export. Default exports are marked with the keyword &lt;code&gt;default&lt;/code&gt;; and there can only be one &lt;code&gt;default&lt;/code&gt; export per module. &lt;code&gt;default&lt;/code&gt; exports are imported using a different import form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1854fec7a183b17dc9b4b01211c91e48aea1794a" translate="yes">
          <source>Each of these declaration forms creates a new type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86f360c4781ee31be3d35dcc610cf923afd132b" translate="yes">
          <source>Each type of major library structuring pattern has a corresponding file in the &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; section. You can start with these templates to help you get going faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e038538a33dfc2af3364ce4ef765b965c2e718a" translate="yes">
          <source>Early Benefits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd303c2b780c5345fb91f72058772c5f0edd26f" translate="yes">
          <source>Editors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules. These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users&amp;rsquo; style guidelines, and many users were displeased with the editor inserting semicolons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2fc66180c7c3d32691e8c42f8df3300e931653" translate="yes">
          <source>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0871854bfc9d5eb95db51d532c4a4da986a587e1" translate="yes">
          <source>Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77d85d60ae04f1f62d384d542f348cbe2876ff0" translate="yes">
          <source>Embedding Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596bc3c5e7f94b3b0596259252b4462615ba5b98" translate="yes">
          <source>Emit &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; helpers for runtime babel ecosystem compatibility and enable &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; for typesystem compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10fd7d2a0af6ba17c8a5d6662cb400314be7d895" translate="yes">
          <source>Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b14d1fa9901ab52b3d302030734ec92bfda008" translate="yes">
          <source>Emit a single file with source maps instead of having a separate file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87aee0db862567627436ed01449478f0361912f7" translate="yes">
          <source>Emit all of the output files in &lt;code&gt;built&lt;/code&gt; (with &lt;code&gt;outDir&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac823149db4776d1721774a8881dd70ce3fbb97" translate="yes">
          <source>Emit class fields with ECMAScript-standard semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ad8902099d4f51e2a118572dcabdcda9aa3360" translate="yes">
          <source>Emit design-type metadata for decorated declarations in source. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;issue #2577&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3085fd048897dd750ce3fb153c2e815abe1acf" translate="yes">
          <source>Emit the source alongside the sourcemaps within a single file; requires &lt;code&gt;--inlineSourceMap&lt;/code&gt; or &lt;code&gt;--sourceMap&lt;/code&gt; to be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07885f70bcc0b163283a8d21b81002971b80cbe8" translate="yes">
          <source>Enable all strict type checking options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f87c2518fb86141f76c027d8adadd8fdd9cf78" translate="yes">
          <source>Enable incremental compilation by reading/writing information from prior compilations to a file on disk. This file is controlled by the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29470d5b922e340851c6d198cc824890a7ae92da" translate="yes">
          <source>Enable stricter checking of the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f7049440bfb40ca1c47e9547370380c5c3f2e9" translate="yes">
          <source>Enable the &lt;code&gt;jsx&lt;/code&gt; option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da566f675009da0e991b7854614c23e919fa5b97" translate="yes">
          <source>Enables experimental support for ES decorators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ba38450ee027bba050ddc6f6958b0dc5a751f2" translate="yes">
          <source>Enabling &lt;code&gt;--declarationMap&lt;/code&gt; alongside &lt;code&gt;--declaration&lt;/code&gt; causes the compiler to emit &lt;code&gt;.d.ts.map&lt;/code&gt; files alongside the output &lt;code&gt;.d.ts&lt;/code&gt; files. Language Services can also now understand these map files, and uses them to map declaration-file based definition locations to their original source, when available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72c9407930092256221610ac7ab395e789b77dfa" translate="yes">
          <source>Enabling &lt;code&gt;--strict&lt;/code&gt; enables &lt;code&gt;--noImplicitAny&lt;/code&gt;, &lt;code&gt;--noImplicitThis&lt;/code&gt;, &lt;code&gt;--alwaysStrict&lt;/code&gt;, &lt;code&gt;--strictBindCallApply&lt;/code&gt;, &lt;code&gt;--strictNullChecks&lt;/code&gt;, &lt;code&gt;--strictFunctionTypes&lt;/code&gt; and &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c09f58749451934cce8c0be5ef42b0d3dbd75b5" translate="yes">
          <source>Enhanced &lt;code&gt;--init&lt;/code&gt; output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a806eb89f7dea65ab700be49a0d4d559514188" translate="yes">
          <source>Ensure TypeScript can determine where to find the outputs of the referenced project to compile project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ebaa427f44ae4c263b34e0e48d73b34fd5b03c" translate="yes">
          <source>Ensure non-undefined class properties are initialized in the constructor. This option requires &lt;code&gt;--strictNullChecks&lt;/code&gt; be enabled in order to take effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b63149cd444d6b9da7fe416ce289557f10a9e7" translate="yes">
          <source>Enter Index Type Query or &lt;code&gt;keyof&lt;/code&gt;; An indexed type query &lt;code&gt;keyof T&lt;/code&gt; yields the type of permitted property names for &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;keyof T&lt;/code&gt; type is considered a subtype of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="04dd4dbb8815c963d82df0161b050d4d9dafeb1d" translate="yes">
          <source>Enum Member Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3104dd45718e6d1ac6a03b91ae67193ae8361f0" translate="yes">
          <source>Enums</source>
          <target state="translated">Enums</target>
        </trans-unit>
        <trans-unit id="f0e0e96cf6626f01df64dec457720adc8996018c" translate="yes">
          <source>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="446bd29a002c17497b41b96657fcf40bf1d514a6" translate="yes">
          <source>Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9611d38688bf1d99ca887b354676cea9ac16e83d" translate="yes">
          <source>Enums are real objects that exist at runtime. For example, the following enum</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2b9875683168f991703bdf2407bc70e31110ed" translate="yes">
          <source>Enums are very useful, but some programs don&amp;rsquo;t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new &lt;code&gt;const enum&lt;/code&gt; declaration works just like a regular &lt;code&gt;enum&lt;/code&gt; for type safety, but erases completely at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1efbfb0dab275f1ef5a349fd19a692fb55ff662d" translate="yes">
          <source>Enums at compile time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ebfc95d6553fab6dcdd9b37826083250ec08fa" translate="yes">
          <source>Enums at runtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12be1b5b741cc430eaddee58fc5792da5e03257" translate="yes">
          <source>Error for not finding &lt;code&gt;moduleB&lt;/code&gt; as it was not passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbdd5b8b6b60bfdc1de358cfd5636ff3b41ecfd" translate="yes">
          <source>Error messages in Russian:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="6f19afca75f8b76cf43de3568bc8609dc8d889e8" translate="yes">
          <source>Errors in .js files with &lt;code&gt;--checkJs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7513853508e7c6e3aa07908df2a450a026eb88" translate="yes">
          <source>Evaluation</source>
          <target state="translated">Evaluation</target>
        </trans-unit>
        <trans-unit id="c4995d18bbd28ef5b42bb49d1ba1191de1d44e61" translate="yes">
          <source>Even at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt; or &lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio&lt;/a&gt;, you&amp;rsquo;ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30bbcbc5524ea12d314a912290ed9ada676d698e" translate="yes">
          <source>Even better, TypeScript will warn you when you make this mistake if you pass the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag to the compiler. It will point out that &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is of type &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173ad8610f22a569603ffb0f1d0d6365bdf43e93" translate="yes">
          <source>Even though Enums are real objects that exist at runtime, the &lt;code&gt;keyof&lt;/code&gt; keyword works differently than you might expect for typical objects. Instead, use &lt;code&gt;keyof typeof&lt;/code&gt; to get a Type that represents all Enum keys as strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce516d03ed65b851ebf38e0525aa5bb18cc7fca" translate="yes">
          <source>Every time the compiler sees a relative module import in a subfolder of one of the &lt;code&gt;rootDirs&lt;/code&gt;, it will attempt to look for this import in each of the entries of &lt;code&gt;rootDirs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="7db0747c7372815c3b79f00827a669c7a4dff2d2" translate="yes">
          <source>Example &lt;code&gt;tsconfig.json&lt;/code&gt; files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="d90ae2c05a80c11c94b6d08fd48a89595af4e49d" translate="yes">
          <source>Examples of Global Libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816ee629d75640df7d32cc7a04c198a2ba361b71" translate="yes">
          <source>Examples of Modular Libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d278e672973bdd09840c8aa311736e998691e0d6" translate="yes">
          <source>Examples of UMD libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="713425259fb0fd114e02f534a62ae30601cda2b7" translate="yes">
          <source>Excess Property Checks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547cac401b8bdafefb3c93432b560b402f27bd52" translate="yes">
          <source>Exclude&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Exclude&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6d793aeaefda145ae379cd867a6553a054c4ae4" translate="yes">
          <source>Execute Babel from the command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e4946cdd24644aa9627cc6ffbfecf2fb7124a0" translate="yes">
          <source>Exhaustiveness checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be111b001bea1086e5ed60f0def95e565522aa10" translate="yes">
          <source>Expansion of rest parameters with tuple types into discrete parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f747d8df97d89385abfc342525e23104fc53d2b" translate="yes">
          <source>Expansion of spread expressions with tuple types into discrete arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb541c0761ac733bf3e3daebf487a743c08ec49f" translate="yes">
          <source>Experimental support for &lt;code&gt;async&lt;/code&gt; functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2368c03d9c425fa5b1b554196b18d9b35543814" translate="yes">
          <source>Explicit types on &lt;code&gt;defaultProps&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7038922b5a5d6db45da593914421a491587b2f7f" translate="yes">
          <source>Explicitly list imported names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="ee287a51eb5e0d85cc359b2e80f44c061f51aae0" translate="yes">
          <source>Export Declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb5fdc5e694d39f19fe4b7038742fba0274b196" translate="yes">
          <source>Export as close to top-level as possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d426e470cf0b8e87df60e791d67c0cc7797da09b" translate="yes">
          <source>Export statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b321b13d568f9f33b7a4846fbc6a9d7e3b9d6029" translate="yes">
          <source>Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b534c8bf9a0c462bc4987c3561321862fa8572" translate="yes">
          <source>Exporting a declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ed777374ec9c640b886c9f9410bc59fc7a8afa" translate="yes">
          <source>Exporting a namespace from your module is an example of adding too many layers of nesting. While namespaces sometime have their uses, they add an extra level of indirection when using modules. This can quickly become a pain point for users, and is usually unnecessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b0e248cae60e2ac77c9d292f495d69dfef3e27" translate="yes">
          <source>Exporting from Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79421f7ea94b7e0cba104ffc2178605b08987de2" translate="yes">
          <source>Expression operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03a0c147ab3a0e6973bff36e8c810e9858d8a41" translate="yes">
          <source>Expression operators permit operand types to include &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; but always produce values of non-null and non-undefined types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcabbc390e17d15f91473972556065a69ff821df" translate="yes">
          <source>Extending Classes</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
