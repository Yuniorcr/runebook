<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="en" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="a4ac561108af405d7aa448c97e428307506c4b7a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt; and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; interfaces to help virtual table implementations optimize UPDATE operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf120a30cf931bf5d51052ad2c827a892d71cac" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface and enhanced the &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma&lt;/a&gt; to support blocking checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0929c2ba69cbc1ab90381ef901ed1c43220d3b7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;carray&quot;&gt;carray() table-valued function&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4198af2bb2d3a6a2e5d9e717e487ffdb864f387d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#editfunc&quot;&gt;edit() SQL function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474818afcad8b8e66370e87650be26268e65480a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#exexcel*&quot;&gt;.excel command&lt;/a&gt; to simplify exporting database content to a spreadsheet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0d090262bc2f05e4866375d263ebdd0c0c20b9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#fullschema&quot;&gt;.fullschema&lt;/a&gt; dot-command to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efaa065fc6ae309d6f393706b579d1948716e05b" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#sha3sum&quot;&gt;.sha3sum dot-command&lt;/a&gt; and the &lt;a href=&quot;cli#selftest&quot;&gt;.selftest dot-command&lt;/a&gt; to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c65b9a76c93d9f52da8c8997329f7ae8313b1d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ce6e1df1cafb18c2d838e2c4bcdbb99f313309" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e862d7c1b81982153f4eb3d2e608a91a4403f0a9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; and &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;SQLITE_DEFAULT_WAL_SYNCHRONOUS&lt;/a&gt; compile-time options. The &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; compile-time option replaces the &lt;a href=&quot;compile#extra_durable&quot;&gt;SQLITE_EXTRA_DURABLE&lt;/a&gt; option, which is no longer supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9939088e42394a02853dfc4d6f72c7cbfcfabb" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; compile-time option, causing &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;overflow pages&lt;/a&gt; to be read directly from the database file, bypassing the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;page cache&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89be077605abd75e22c5ffc02c2f38f9fadca22f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#disable_fts4_deferred&quot;&gt;SQLITE_DISABLE_FTS4_DEFERRED&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809eece43957fbb9e8168262d4e0fe553c274d57" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#enable_api_armor&quot;&gt;SQLITE_ENABLE_API_ARMOR&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78acf1f8c9551ddf3a305b4527973a912eca40df" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#enable_null_trim&quot;&gt;SQLITE_ENABLE_NULL_TRIM&lt;/a&gt; compile-time option, which can result in significantly smaller database files for some applications, at the risk of being incompatible with older versions of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc7192a68013b4ccfb34fc5fa843f664f068838" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#enable_unknown_sql_function&quot;&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/a&gt; compile-time option and turned that option on by default when building the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26774dce1b145c5b9b287b32dbb4c00e6fe2392" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#fts3_max_expr_depth&quot;&gt;SQLITE_FTS3_MAX_EXPR_DEPTH&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f704cba224d0630f060896cdfabf87b14693b5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#have_isnan&quot;&gt;SQLITE_HAVE_ISNAN&lt;/a&gt; compile-time option which will cause the isnan() function from the standard math library to be used instead of SQLite's own home-brew NaN checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558383d2bbd0eb67a29332971af16389f89345ef" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84daf3b5302c6fe472e4c66d1c3fa77e1f119885" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; compile-time option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d7a7e10a04ea0438234a85069c16c9283a34f44" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3a294a7e977a259efaa0c86a5bd58c0ece5079" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a909d1326bcfce04150c32be27f8c49b83bd0ecc" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#reverse_unordered_selects&quot;&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502456daba3bbfc42c2aae4e0545df4627f551ad" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28034c0cfb70c12e27ba3ede26d8dd8ede415516" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09fb1f6511621b38cfa7a99512d14f14883fbc85" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3173fa35c3a879c2726fc2a5942b9f31caf835" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;completion&quot;&gt;COMPLETION extension&lt;/a&gt; - designed to suggest tab-completions for interactive user interfaces. This is a work in progress. Expect further enhancements in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd72639918b4a26ff2fb29a0faca5f35c83f254f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;csv&quot;&gt;CSV virtual table&lt;/a&gt; for reading &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; formatted comma-separated value files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3160ced06d046132de38a26647860622e0cdffde" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#fts3tok&quot;&gt;fts3tokenize virtual table&lt;/a&gt; to the &lt;a href=&quot;fts3&quot;&gt;full-text search&lt;/a&gt; logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8b894319f521eb57fd47b0be0aa9684d1ec5aa" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7adb875b0c694ac11f99fb4651fab782bc54c4" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#fts4notindexed&quot;&gt;FTS4 notindexed option&lt;/a&gt;, allowing non-indexed columns in an FTS4 table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af80c1928f1855cabc20adda009b71283ddea157" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#matchinfo-b&quot;&gt;matchinfo 'b' flag&lt;/a&gt; to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function in &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d5c29f868afb57f7cc51fb08236c713031a2c7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#matchinfo-y&quot;&gt;matchinfo y flag&lt;/a&gt; to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function of &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a827723f97ea5885e808c3970a4b40110e42abfa" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts5#the_detail_option&quot;&gt;FTS5 detail option&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22bb4ef0d3b7209d712c5d4d93daa0aaef7a82c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;geopoly&quot;&gt;Geopoly module&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c6d5f726f175566512f2d2234a5c4de18fd7f8" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0e11f7f07f3617d74c59523f8c23d59441befb" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;geopoly#regpoly&quot;&gt;geopoly_regular()&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24e2a1102cf6edaae603eaa6aac92e181730dab" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/ext/userauth/user-auth.txt&quot;&gt;User Authentication&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98eddc92334b847599f4ce6d60f53ec694b28ec8" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=tool/genfkey.c&quot;&gt; source code&lt;/a&gt; and &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=tool/genfkey.README&quot;&gt; documentation&lt;/a&gt; for the &lt;b&gt;genfkey&lt;/b&gt; program for automatically generating triggers to enforce foreign key constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb847b6e2ea32d443186a136c7cc13619b505325" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/anycollseq.c&quot;&gt;anycollseq.c&lt;/a&gt;&lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that allows a generic SQLite database connection to read a schema that contains unknown and/or application-specific &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bcf45513f10ebd75a93f6b5b6e89e6063d27a70" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/explain.c&quot;&gt;explain virtual table&lt;/a&gt; as a run-time loadable extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b081bf5f1f1b82752017714981d03b1881cbb935" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fossildelta.c&quot;&gt;fossildelta.c&lt;/a&gt; extension that can create, apply, and deconstruct the &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/delta_format.wiki&quot;&gt;Fossil DVCS file delta format&lt;/a&gt; that is used by the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c17244cfd78fdd7f17b6be947bca36290283497" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/normalize.c&quot;&gt;sqlite3_normalize()&lt;/a&gt; extension function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759f9c17eb2b892ce355010ec281cce2d5bc2292" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;swarm virtual table&lt;/a&gt; to the existing union virtual table extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b331aec1305fafaaca20c2db450d1ed83b8ce70e" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/session/changesetfuzz.c&quot;&gt;changesetfuzz.c&lt;/a&gt; test-case generator utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce84b6020b5a29dc39d3e75ab7c42a1088a870c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/src/dbpage.c&quot;&gt;sqlite_dbpage virtual table&lt;/a&gt; for providing direct access to pages of the database file. The source code is built into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is activated using the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;-DSQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2442f1bc55ec77c692e59556f169e49a895d4fc" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/artifact/d7cc99350?ln=403-443&quot;&gt;sqlite3rbu_bp_progress()&lt;/a&gt; interface to the &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9465d7ab14adb931b5593d0471021aeb683a5ed7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/artifact/f971962e92ebb8b0&quot;&gt;eval.c&lt;/a&gt;&lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements an eval() SQL function that will recursively evaluate SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f6d845a0f388b044a8b1c50b1667ba4a60cc2c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/remember.c&quot;&gt;remember(V,PTR)&lt;/a&gt; SQL function as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425b7d13c017ba95b58d6a07a030a87fd80839e1" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/sha1.c&quot;&gt;sha1.c&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e99c060c956cad10a0ae2061ee04da178be3f84" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;imposter#dotimposter&quot;&gt;.imposter dot-command&lt;/a&gt; to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727f21d6dc5af5ea8308f45987497ba8687f21e0" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;json1#jgrouparray&quot;&gt;json_group_array()&lt;/a&gt; and &lt;a href=&quot;json1#jgroupobject&quot;&gt;json_group_object()&lt;/a&gt; SQL functions in the &lt;a href=&quot;json1#jmini&quot;&gt;json&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb5ebb2b769f13a8af1db1abb9a9158e890bf67" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;json1#jpatch&quot;&gt;json_patch()&lt;/a&gt; SQL function to the &lt;a href=&quot;json1&quot;&gt;JSON1 extension&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a094211337515c1dc028d6f9e6cf2117139fbc0" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;json1#jquote&quot;&gt;json_quote()&lt;/a&gt; SQL function to &lt;a href=&quot;json1&quot;&gt;the json1 extension&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d18b3be87f155b2457df15bacd3dd11c3e674d5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#instr&quot;&gt;instr()&lt;/a&gt; SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="247064f74dbe4b79f59940594bcda97f277a43f3" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely(X)&lt;/a&gt; SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac96e190aeab6b4919769c4f3fd24dfbe89ae73" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf()&lt;/a&gt; SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60a43dfdb6c9e0039a4d0aa4f120238cb346854" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt; SQL functions to be used as hints to the query planner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0ee30e9ce216eed1bab03b1463da8795ac409d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa2810329e9d36a72775faefe7a4b187615efbd" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f839667c95acc5a008254deb814f5fd2e72e82" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; for a speed improvement in excess of 15% on some workloads. (Your mileage may vary.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca85bb0b52986a81e52b50ef04e5ef298fc1ebdf" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; to the query planner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52772fca787badd301bbb28489a51e6b2c18437" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf053bb493580f8d76bf2fe4425a6ee95eb3b00" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_cache_spill&quot;&gt;cache_spill pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7028868fffc72a85c59d3c3b9112eb23b4ec033e" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_cell_size_check&quot;&gt;PRAGMA cell_size_check&lt;/a&gt; command for better and earlier detection of database file corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60e6b13f01cdd96d811863e696687470fe6d7c1" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command that can be used to determine if a database file has been modified by another process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc9cd4f3681e1d6bfff801310b10819f9c239c5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys pragma&lt;/a&gt; and the &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(db, &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;,...) C-language interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9260575fd05ff275b40b928c8ff145c26653a33b" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd33bca500a56cb70a0e4189db705ce4c14918ef" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;PRAGMA index_xinfo&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cb1ad431d49ff1624974b470ad507e7e6aade5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; command, which if enabled causes the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command to behave like older version of SQLite (prior to version 3.25.0) for compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241f9aa0870d7629a649c6fcf7aff48add9bd27d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522f4f5023f50f82e4cb75d28460040b08ac77c8" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_page_count&quot;&gt;PRAGMA page_count&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181f42a6c7e001d819f97d8ba8bb1793d0d0a062" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_page_count&quot;&gt;page_count&lt;/a&gt; PRAGMA for returning the size of the underlying database file in pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0186fd0e400893a1b30b7508e00203dc47dcbd7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_query_only&quot;&gt;query_only pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f14ae05567f16f27c2ce37117eaac6068a50a87" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;reverse_unordered_selects pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0623635bd786359d5b3e0fa8a8c82ab7ea0f9a41" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete=FAST&lt;/a&gt; command. When secure_delete is set to FAST, old content is overwritten with zeros as long as that does not increase the amount of I/O. Deleted content might still persist on the &lt;a href=&quot;fileformat2#freelist&quot;&gt;free-page list&lt;/a&gt; but will be purged from all b-tree pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837b2abaf90eb53043c6e7f99d8293f985e4ea36" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed2f465aa832c05e440067dd7bf41e8a2ea7c7d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;soft_heap_limit pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa4735afedc1efa7a8fd6ef84be33fe2ae0da0d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_stats&quot;&gt;PRAGMA stats&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda41fd88ccb8b6e627abcd4e0e1e198b532f161" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_vdbe_addoptrace&quot;&gt;PRAGMA vdbe_addoptrace&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_vdbe_debug&quot;&gt;PRAGMA vdbe_debug&lt;/a&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca68a9d9e7785e54f4fcfc001732202953d934a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property to the VFS interface. Provide the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; I/O capability, the &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;SQLITE_POWERSAFE_OVERWRITE&lt;/a&gt; compile-time option, and the &quot;psow=BOOLEAN&quot; query parameter for &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04abd4bf7e803d987674de715233b44d21ad1237" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;rtree#rtreecheck&quot;&gt;rtreecheck()&lt;/a&gt; scalar SQL function to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc105b8ec07cf1f35ee3a44ebcb504b698c185e2" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;rtree#xquery&quot;&gt;sqlite3_rtree_query_callback()&lt;/a&gt; interface to &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39750cb3b229cd41fd745ee42224961db3f0e9a9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;session/c_changesetapply_invert&quot;&gt;SQLITE_CHANGESETAPPLY_INVERT&lt;/a&gt; flag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be5c46b76747ab1af6431ca228fa917fafbc088c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt; interface and the &lt;a href=&quot;session/c_changesetstart_invert&quot;&gt;SQLITE_CHANGESETSTART_INVERT&lt;/a&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1c498f90678af89842f0c30b1342851695eaf9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff.exe&lt;/a&gt; utility program for computing the differences between two SQLite database files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e4d8fe0797614c479eea512419e56f330774a0" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT virtual table&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7141a7f71545fdc2d8f0941a70f5d692420e5873" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;&lt;a href=&quot;tclsqlite#config&quot;&gt;config method&lt;/a&gt; in order to be able to disable &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableview&quot;&gt;SQLITE_DBCONFIG_ENABLE_VIEW&lt;/a&gt; as well as control other &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; options from TCL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3034d006b7d037b3012d84d49eab4202967372ce" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;unionvtab&quot;&gt;UNION virtual table&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1fcdd4ec63f81664121b096c84af0efcd65365" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;vtab#colUsed&quot;&gt;colUsed field&lt;/a&gt; to &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; for use by the &lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abff860b551a8d132b543df75ebaabf23d9a1164" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;COPY&lt;/b&gt; command patterned after &lt;a href=&quot;http://www.postgresql.org/&quot;&gt;PostgreSQL&lt;/a&gt; so that SQLite can now read the output of the &lt;b&gt;pg_dump&lt;/b&gt; database dump utility of PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e304ab36743ecbc720ac93786500ba376598ce88" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;LIKE&lt;/b&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12e3e86e8d93c49072339ca4e285a481d50fb9d" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;last_insert_rowid()&lt;/b&gt; SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3193cf97b99861e9e104fce03f06019602ead587" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_..._printf()&lt;/b&gt; interface routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="043d356fd73cb171db8858f0f5622b884db88636" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_busy_handler()&lt;/b&gt; and &lt;b&gt;sqlite_busy_timeout()&lt;/b&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ea8f321d97c10573a695234e9878da4617c5e5" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_changes()&lt;/b&gt; API function to return the number of row that changed in the most recent operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8527c0256e1df6259b3b96966c858732fd00e5f" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_get_table()&lt;/b&gt; API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998f6cbca04b2d05276533a7914bab3fa482581f" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_interrupt()&lt;/b&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71daae0bfba6e902831cbd84539462138fb543a" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_open_aux_file()&lt;/b&gt; API, though it is still mostly undocumented and untested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ac72f388de3cc88954c42e0e92ea3b9fd55074" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_set_authorizer()&lt;/b&gt; API. Formal documentation has not been written - see the source code comments for instructions on how to use this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c76f9466cfa8b45c7eef759eaf4885a10cbd2e" translate="yes" xml:space="preserve">
          <source>Added the &lt;em&gt;experimental&lt;/em&gt;&lt;a href=&quot;c3ref/snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;, &lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, and &lt;a href=&quot;c3ref/snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interfaces. These are subject to change or removal in a subsequent release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8960036bc5202bda42674d6c0203a6bd0c46dd" translate="yes" xml:space="preserve">
          <source>Added the ANALYZE command for gathering statistics on indices and using those statistics when picking an index in the optimizer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76828fc2ef742c439bfc84df1818b198b243eeb" translate="yes" xml:space="preserve">
          <source>Added the ATTACH and DETACH commands to allow interacting with multiple database files at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648b7548b08d3433a571e65bdfcce48f0369af0b" translate="yes" xml:space="preserve">
          <source>Added the COUNT_CHANGES pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a82f263a7163cc945f7a54766155ffe5bad18eb" translate="yes" xml:space="preserve">
          <source>Added the EMPTY_RESULT_CALLBACKS pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf9996aa89891e17522dba8a3b313501dd38637" translate="yes" xml:space="preserve">
          <source>Added the ESCAPE clause on the LIKE operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f305242a3191cbfb5aec027e3852204245b42cf2" translate="yes" xml:space="preserve">
          <source>Added the FULL_COLUMN_NAMES pragma. When set to &quot;ON&quot;, the names of columns are reported back as TABLE.COLUMN instead of just COLUMN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9f140f4e869766b8cc9921a38bfc1214b22f28" translate="yes" xml:space="preserve">
          <source>Added the SANITY_CHECK pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab67de0b2fcd45ff0f66e746a10daf00336c46a1" translate="yes" xml:space="preserve">
          <source>Added the SQLITE_MIXED_ENDIAN_64BIT_FLOAT compile-time option to support ARM7 processors with goofy endianness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8512503a8a6ee6ac4c42b6ec6960124aa1141343" translate="yes" xml:space="preserve">
          <source>Added the SQLITE_READONLY_ROLLBACK extended error code for when a database cannot be opened because it needs rollback recovery but is read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d860363ab44e2e09ecb05e55d177bb6e0cc5efda" translate="yes" xml:space="preserve">
          <source>Added the SQLITE_UINT64_TYPE compile-time option as an analog to SQLITE_INT64_TYPE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc2a114a80ab21b7a59a0682328a2000b97132e" translate="yes" xml:space="preserve">
          <source>Added the SYNCHRONOUS pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2840998df920dfd1ea272df7b05ff7b737d636e" translate="yes" xml:space="preserve">
          <source>Added the TABLE_INFO() and INDEX_INFO() pragmas to help support the ODBC interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b81f73060b913ff9ec244fef4f2242a8077314" translate="yes" xml:space="preserve">
          <source>Added the TRUNCATE option to &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a5050102a4554f6884185179621e32222f113e" translate="yes" xml:space="preserve">
          <source>Added the ability to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ed&lt;/a&gt; database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c38c134cf06def71bdb05238df7b454e3474fe" translate="yes" xml:space="preserve">
          <source>Added the ability to link against the &quot;&lt;a href=&quot;https://github.com/antirez/linenoise&quot;&gt;linenoise&lt;/a&gt;&quot; command-line editing library in unix builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b8cf9d4fd6b2c51e94a6a6f014fcfd569e941f" translate="yes" xml:space="preserve">
          <source>Added the ability to resolve constraint conflicts is ways other than an abort and rollback. See the documentation on the &quot;ON CONFLICT&quot; clause for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f101692603c49e55897cc1b0a0872864ceef28cd" translate="yes" xml:space="preserve">
          <source>Added the ability to specify &quot;*&quot; as part of a larger column list in the result section of a SELECT statement. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da37dd2277aa54e92101d7aa5cc21a4b4b41b35" translate="yes" xml:space="preserve">
          <source>Added the concatenate string operator (||)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8781e73412ec3dcdbe8ddfaabe88ccd47d652415" translate="yes" xml:space="preserve">
          <source>Added the experimental &lt;a href=&quot;cli#expert&quot;&gt;.expert command&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc342be926b0820e09fb4675d0d305018e3e35d" translate="yes" xml:space="preserve">
          <source>Added the experimental &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. Note that this extension is experimental and subject to change in incompatible ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d4e217a57507e7cf4bdc496b8ef5f7cdbf4429" translate="yes" xml:space="preserve">
          <source>Added the experimental &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extension. Note that this extension is experimental and subject to change in incompatible ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd32bd379fd1ee1dbe9dd7bcac2b99d55f0988b" translate="yes" xml:space="preserve">
          <source>Added the experimental and undocumented EXPLAIN QUERY PLAN capability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf7af11f593a05578593b77e950de9d08708237" translate="yes" xml:space="preserve">
          <source>Added the experimental malloc-free memory allocator in mem3.c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c30e3baaca4fbdcfb24a460d6ac28afed94f059" translate="yes" xml:space="preserve">
          <source>Added the fcnt() function to the SQL interpreter. The fcnt() function returns the number of database &quot;Fetch&quot; operations that have occurred. This function is designed for use in test scripts to verify that queries are efficient and appropriately optimized. Fcnt() has no other useful purpose, as far as I know.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a58a2fc5a5367d63f94f8275791e299dd75eb74" translate="yes" xml:space="preserve">
          <source>Added the fsdir(PATH) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; to the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; extension, for listing the files in a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d23ff1e41223a23eed74ee1f278a16171c0953" translate="yes" xml:space="preserve">
          <source>Added the fullfsync pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e37096ddd5586a6257d3283c3c1a2dfcb73ea7" translate="yes" xml:space="preserve">
          <source>Added the new &lt;a href=&quot;c3ref/stmt_isexplain&quot;&gt;sqlite3_stmt_isexplain(S)&lt;/a&gt; interface for determining whether or not a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5a2b0e9f488226eecba61aa448d45b4ae4e1d9" translate="yes" xml:space="preserve">
          <source>Added the new &lt;a href=&quot;tclsqlite#bind_fallback&quot;&gt;bind_fallback method&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="698d2bae74641dc2312ecf24ccb34bdaf37e3654" translate="yes" xml:space="preserve">
          <source>Added the new &lt;b&gt;SQLITE_TEMP_MASTER&lt;/b&gt; table which records the schema for temporary tables in the same way that &lt;b&gt;SQLITE_MASTER&lt;/b&gt; does for persistent tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8314265965cb9729309aa3a47d77b4ebbd0dc84" translate="yes" xml:space="preserve">
          <source>Added the new &lt;b&gt;sqlite_last_insert_rowid()&lt;/b&gt; API function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36e59151eae3a6b62bf13680d5957b9ac83ad96" translate="yes" xml:space="preserve">
          <source>Added the new interface &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_msize()&lt;/a&gt; that returns the size of a memory allocation obtained from &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and its variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d6fc07cdd58d69c1061156379f31f91815e6f2" translate="yes" xml:space="preserve">
          <source>Added the new sqlite3_bind_parameter_name() interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294074eb5cc5a602340ff9920845209bc774b64a" translate="yes" xml:space="preserve">
          <source>Added the optional &lt;a href=&quot;asyncvfs&quot;&gt;asynchronous VFS&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ff57d315c3b6f550eb4477360be1d9ece1af4e" translate="yes" xml:space="preserve">
          <source>Added the remove_diacritics=2 option to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5543829232c2352604477be7d98b18681931c4e6" translate="yes" xml:space="preserve">
          <source>Added the sqlite3_db_handle() API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ca3dd4e3255f6b9042e4416d3da3cdbcd74a82" translate="yes" xml:space="preserve">
          <source>Added the sqlite3_get_autocommit() API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01da972e948cd498d37d659567824ec295b8ab3b" translate="yes" xml:space="preserve">
          <source>Added the sqlite_encode_binary() and sqlite_decode_binary() functions to the source tree. But they are not yet linked into the library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7931525b0f49699c8919c663442c12cd2042a1" translate="yes" xml:space="preserve">
          <source>Added the subquery flattening optimizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b7e1fb260a3da09d3b883f4ceb3d8fea98b06f" translate="yes" xml:space="preserve">
          <source>Added the test_multiplex.c module which provides an example VFS that provides multiplexing (sharding) of a DB, splitting it over multiple files of fixed size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0013cb7d834fd47edf840654f5d38cdca51233" translate="yes" xml:space="preserve">
          <source>Added the test_regexp.c module as a demonstration of how to implement the REGEXP operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a49834c953fbdb6828ba126355f3f55173d44b" translate="yes" xml:space="preserve">
          <source>Added the test_superlock.c module which provides example code for obtaining an exclusive lock to a rollback or WAL database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09972935bcd9fee093e7ba1782e40d68896023ca" translate="yes" xml:space="preserve">
          <source>Added the win32-longpath VFS on windows, permitting filenames up to 32K characters in length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f94f686ce38728ef2b6f0370975b863c680811c8" translate="yes" xml:space="preserve">
          <source>Added the xGetLastError() method to &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; for returning filesystem-specific error messages and error codes back to SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5e4ed0c375fbca2b5b605896122a1929784c92" translate="yes" xml:space="preserve">
          <source>Added two new C-language interfaces: &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_expanded_sql()&lt;/a&gt; and &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt;. These new interfaces subsume the functions of &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; which are now deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82207d09f92cb6fda6e84b7a4f36383b773b1975" translate="yes" xml:space="preserve">
          <source>Added two new experimental functions: &lt;a href=&quot;lang_expr#randomblobFunc&quot;&gt;randomBlob()&lt;/a&gt; and &lt;a href=&quot;lang_expr#hexFunc&quot;&gt;hex()&lt;/a&gt;. Their intended use is to facilitate generating &lt;a href=&quot;http://en.wikipedia.org/wiki/UUID&quot;&gt;UUIDs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738e6cc3217ca2553bb9e0d6d54a155cd0ad0e85" translate="yes" xml:space="preserve">
          <source>Added verbs &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatuspagecachesize&quot;&gt;SQLITE_STATUS_PAGECACHE_SIZE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusscratchsize&quot;&gt;SQLITE_STATUS_SCRATCH_SIZE&lt;/a&gt; to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c680515f169f90f11c5dd355902aaea8ab7434ee" translate="yes" xml:space="preserve">
          <source>Adding anything to null gives null</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb59cdfe69dfa59c552601b0c1f3bb462cce88b5" translate="yes" xml:space="preserve">
          <source>Adding new auxiliary functions implemented in C, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f056b3609aae2fc232cd7cd2146d49c24a7d20cd" translate="yes" xml:space="preserve">
          <source>Adding new tokenizers, also implemented in C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6889504fdc32a6b06fe8b6bcc4bddeee9d4dd115" translate="yes" xml:space="preserve">
          <source>Adding optional features like &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt;, &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt;, or &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; will increase the size of the library, obviously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d5a0933a519ba202a444bedd7df31dcc598d63" translate="yes" xml:space="preserve">
          <source>Adding to Zip</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cc55a80b36a00837a2ba9fccba63e4cde092d5" translate="yes" xml:space="preserve">
          <source>Additional OS/2 updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92dafa949d6bc0b1375a028d351e58c914e80e5e" translate="yes" xml:space="preserve">
          <source>Additional application-specific collating functions can be added to SQLite using the &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27c7e9f8642590f605d8547ee9d3195fc42ee26" translate="yes" xml:space="preserve">
          <source>Additional background information is available in the &lt;a href=&quot;queryplanner&quot;&gt;indexing tutorial&lt;/a&gt; document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c99c8da41f3c9e92b76081bdd22fd42577b1a01" translate="yes" xml:space="preserve">
          <source>Additional documentation is available &lt;a href=&quot;cli&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b84c5eeb4233a176f6bc28e3bd04baf2d28fa4" translate="yes" xml:space="preserve">
          <source>Additional documentation on Fossil can be found at &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/permutedindex.html&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/permutedindex.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317e6d6c624cc48cb4d511774ceb090affd1ec71" translate="yes" xml:space="preserve">
          <source>Additional fixes for issues detected by &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSSFuzz&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911a0b354b810ade1b41221cd419095a4767144e" translate="yes" xml:space="preserve">
          <source>Additional information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a863bb50cbb4e362af4fa066e5c6af932cb4b2" translate="yes" xml:space="preserve">
          <source>Additional information about datatypes in SQLite version 3.0 is available &lt;a href=&quot;datatype3&quot;&gt;separately&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec1e59a22ef60dce4ecbbf53a52e3ca6ce479f4" translate="yes" xml:space="preserve">
          <source>Additional information about each of these temporary file types is in the sequel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d1a81241f56a80c6f10677f29019f00a708f3e" translate="yes" xml:space="preserve">
          <source>Additional information is provided in the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; and &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt; documents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54fe371689214dc8e5e5e621b7eb86aecf9d56f" translate="yes" xml:space="preserve">
          <source>Additional language codes might be added in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd6df38d5642afc4cf37656b0d1bca445886b04" translate="yes" xml:space="preserve">
          <source>Additional notes on compiling SQLite can be found on the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ec2f0b6cbf4bf0e81b4a109aa98e3ffbd4166d" translate="yes" xml:space="preserve">
          <source>Additional notes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332472b920f973dc311033ff008ad95ae21f625e" translate="yes" xml:space="preserve">
          <source>Additional speed-up can occur if an index can be used to speed the search of either or the two loops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62327a6c1f64cd300d626d84824c24a7457822b7" translate="yes" xml:space="preserve">
          <source>Additional tests added to the regression suite to cover the new ROWID feature and the TCL interface bugs mentioned below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654733e6ef7698fde15afb843bdcb55e4a4bdac2" translate="yes" xml:space="preserve">
          <source>Additionally, all VFS implementations are required to provide the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751381c740adf479c5b317c56d4dbca83d940699" translate="yes" xml:space="preserve">
          <source>Additionally, five extra &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations are provided as well as the default. By specifying one of the extra VFS implementations when calling &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, an application may bypass the file-system detection logic and explicitly select one of the above locking styles. The five extra &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations are called &quot;unix-posix&quot;, &quot;unix-afp&quot;, &quot;unix-flock&quot;, &quot;unix-dotfile&quot; and &quot;unix-none&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0db46574ddb3c258907307bfcb277854bd98be" translate="yes" xml:space="preserve">
          <source>Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then SQLite also assumes that if a call to the xUpdate() method is made as part of the same statement to delete or update a virtual table row and the implementation returns SQLITE_CONSTRAINT, then there is no need to rollback any database changes. In other words, if the xUpdate() returns SQLITE_CONSTRAINT, the database contents must be exactly as they were before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by the xUpdate method are automatically rolled back by SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3296bcc9f5f36b885d1f44a772cfcd7df89079" translate="yes" xml:space="preserve">
          <source>Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get() since the last time the wal file was deleted. The wal file is deleted when the database is changed back to rollback mode or when the number of database clients drops to zero. If either snapshot handle was obtained before the wal file was last deleted, the value returned by this function is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ad616133628f7a9c711f524c6d649bfd1e605e" translate="yes" xml:space="preserve">
          <source>Adjust how SQLite does &lt;a href=&quot;malloc&quot;&gt;memory allocation&lt;/a&gt;, including setting up alternative memory allocators appropriate for safety-critical real-time embedded systems and application-defined memory allocators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b033ae4a69004f4620434e4722184d64e21543d" translate="yes" xml:space="preserve">
          <source>Adjust the &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; API so it more often returns the same values for &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements as it did in prior releases, to minimize disruption to applications that might be using that interface in unexpected ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af76f40123a61e61c36534a28bc6944e29327620" translate="yes" xml:space="preserve">
          <source>Adjust the unix driver to avoid unnecessary calls to fchown().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d239da6b2ab732b6958736d4e5cb3d6007246c9" translate="yes" xml:space="preserve">
          <source>Adjust the use of mutexes so that they are appropriate for various &lt;a href=&quot;threadsafe&quot;&gt;threading models&lt;/a&gt;, or substitute an application-defined mutex system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f5fc3d9b3cb240294c036969ed03df2f640df3" translate="yes" xml:space="preserve">
          <source>Adjusting SQLite To Use 8+3 Filenames</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42bff9e6720c99e5345613da344a0c1afa8b6dd4" translate="yes" xml:space="preserve">
          <source>Advance A Changeset Iterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8ccba8f1392a8bc7c3e697913930b9040f8c60" translate="yes" xml:space="preserve">
          <source>Advance cursor P1 so that it points to the next key/data pair in its table or index. If there are no more key/value pairs then fall through to the following instruction. But if the cursor advance was successful, jump immediately to P2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c9571278da3b45a7da23cbb5f3d294d51fc11e" translate="yes" xml:space="preserve">
          <source>Advance virtual table P1 to the next row in its result set and jump to instruction P2. Or, if the virtual table has reached the end of its result set, then fall through to the next instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75e53f7ef6befbc2ec9555564b368fec377a5b4" translate="yes" xml:space="preserve">
          <source>Advantages of WAL-mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c612cc4e584be10a59711cc94c098821d2bdc6" translate="yes" xml:space="preserve">
          <source>Advocacy</source>
          <target state="translated">Advocacy</target>
        </trans-unit>
        <trans-unit id="2d3ad1756a210c3ecab852144ac9d98890b977fa" translate="yes" xml:space="preserve">
          <source>Affinity</source>
          <target state="translated">Affinity</target>
        </trans-unit>
        <trans-unit id="4f72807708b980eccee8200e07c7d36460820a43" translate="yes" xml:space="preserve">
          <source>Affinity of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="23fd162046b3edf8ebd248698454f109bfd31f63" translate="yes" xml:space="preserve">
          <source>After ADD COLUMN has been run on a database, that database will not be readable by SQLite version 3.1.3 (2005-02-20) and earlier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027a417d23e6a18069001a7c19ad2bf39267a70e" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; has been prepared using any of &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; or one of the legacy interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, this function must be called one or more times to evaluate the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4eec0463aaa1bd6eacaf86174eef649dd73f26c" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; has been evaluated by one or more calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, it can be reset in order to be evaluated again by a call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. Think of &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; as rewinding the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; program back to the beginning. Using &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; on an existing &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; rather than creating a new &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; avoids unnecessary calls to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. For many SQL statements, the time needed to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; equals or exceeds the time needed by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. So avoiding calls to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; can give a significant performance improvement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794711e92b4cb710edd2459f0377567195dd4b41" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; has been prepared using any of &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; or one of the legacy interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, this function must be called one or more times to evaluate the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610a52e97ff3ecd7651d2bc9d61eca8fe0a8d8a9" translate="yes" xml:space="preserve">
          <source>After a call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; returns SQLITE_LOCKED, the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; API may be invoked to register for an unlock-notify callback. The unlock-notify callback is invoked by SQLite after the database connection holding the table-lock that prevented the call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; from succeeding has finished its transaction and released all locks. For example, if a call to sqlite3_step() is an attempt to read from table X, and some other connection Y is holding a write-lock on table X, then sqlite3_step() will return SQLITE_LOCKED. If &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is then called, the unlock-notify callback will be invoked after connection Y's transaction is concluded. The connection that the unlock-notify callback is waiting on, in this case connection Y, is known as the &quot;blocking connection&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4986de5057c6d05cb0ea3a0ad2727b5d055cdc6f" translate="yes" xml:space="preserve">
          <source>After a complete checkpoint, if no other connections are in transactions that use the WAL, then subsequent write transactions can overwrite the WAL file from the beginning. This is called &quot;resetting the WAL&quot;. At the start of the first new write transaction, the WAL header salt-1 value is incremented and the salt-2 value is randomized. These changes to the salts invalidate old frames in the WAL that have already been checkpointed but not yet overwritten, and prevent them from being checkpointed again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b922aacb69272f39bced66a3ebf0a3033c1514f" translate="yes" xml:space="preserve">
          <source>After a database is closed, swarmvtab runs the equivalent of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95563154fa733438ac343e5b67e301f468c45088" translate="yes" xml:space="preserve">
          <source>After a sequence of changes that define a single undo/redo step, invoke the undo::barrier command to define the limit of that step. In an interactive program, you can call undo::event after any change and undo::barrier will be called automatically as an idle callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba37aebce03d74bebd4ab72ce08d7281954335c" translate="yes" xml:space="preserve">
          <source>After a session object has been configured, it begins monitoring for changes to its configured tables. However, it does not record an entire change each time a row within the database is modified. Instead, it records just the PRIMARY KEY fields for each inserted row, and just the PRIMARY KEY and all original row values for any updated or deleted rows. If a row is modified more than once by a single session, no new information is recorded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ec21719ff7b0d3ffa4e429b7905254f04d4e5c" translate="yes" xml:space="preserve">
          <source>After a virtual machine has been generated using &lt;b&gt;sqlite_compile&lt;/b&gt; it is executed by one or more calls to &lt;b&gt;sqlite_step&lt;/b&gt;. Each invocation of &lt;b&gt;sqlite_step&lt;/b&gt;, except the last one, returns a single row of the result. The number of columns in the result is stored in the integer that the 2nd parameter points to. The pointer specified by the 3rd parameter is made to point to an array of pointers to column values. The pointer in the 4th parameter is made to point to an array of pointers to column names and datatypes. The 2nd through 4th parameters to &lt;b&gt;sqlite_step&lt;/b&gt; convey the same information as the 2nd through 4th parameters of the &lt;b&gt;callback&lt;/b&gt; routine when using the &lt;b&gt;sqlite_exec&lt;/b&gt; interface. Except, with &lt;b&gt;sqlite_step&lt;/b&gt; the column datatype information is always included in the in the 4th parameter regardless of whether or not the &lt;a href=&quot;pragma#pragma_show_datatypes&quot;&gt;SHOW_DATATYPES&lt;/a&gt; pragma is on or off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23265bf656595ac1bd3eabed0b381392ce07d2ae" translate="yes" xml:space="preserve">
          <source>After all information in the rollback journal has been played back into the database file (and flushed to disk in case we encounter yet another power failure), the hot rollback journal can be deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84435139a07c4a4055bb439605dbd8c9789e7d7" translate="yes" xml:space="preserve">
          <source>After all needed changes are completed, xWrite() is used to move the content back into the database file. Hence the use of memory mapped I/O does not significantly change the performance of database changes. Memory mapped I/O is mostly a benefit for queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260239065f2a92ea494a87b7cf4ba2a2d941420e" translate="yes" xml:space="preserve">
          <source>After all records have been inserted into the Sorter object identified by P1, invoke this opcode to actually do the sorting. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 if there are no records to be sorted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1079dc3c758cc45d2f271e573db223c2cdb12648" translate="yes" xml:space="preserve">
          <source>After an SQL statement has been prepared (and optionally bound), it is executed using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e517dcca2fb3c783a27c4dacd0285a95c871db" translate="yes" xml:space="preserve">
          <source>After any changes to the TEMP database schema, all prepared statements are invalidated and must be recreated using a new call to sqlite3_prepare()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8dfe7bdc91c90b1d784f46b505207e5b5bb9de" translate="yes" xml:space="preserve">
          <source>After duplicating the key, the next instruction, NotExists, pops the stack once and uses the value popped as a key to check the existence of a record in the database file. If there is no record for this key, it jumps back to the ListRead to get another key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="838513ea0f9681d04eb27d7879229c002b821a85" translate="yes" xml:space="preserve">
          <source>After each INSERT on ex1, the ex1_it trigger constructs text of a DELETE statement that will undo the INSERT. The ex1_ut trigger constructs an UPDATE statement that will undo the effects of an UPDATE. And the ex1_dt trigger constructs a statement that will undo the effects of a DELETE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126fa1adfbc14e51e51271a3d3ed7613c3632f33" translate="yes" xml:space="preserve">
          <source>After gcov has been run to verify 100% branch test coverage, then the test program is recompiled using delivery compiler options (without the special -fprofile-arcs and -ftest-coverage options) and the test program is rerun. This second run is the actual test of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8afe929b966e405547381b33bfdc15bcc08124" translate="yes" xml:space="preserve">
          <source>After obtaining a RESERVED lock, the process that wants to write creates a rollback journal. The header of the journal is initialized with the original size of the database file. Space in the journal header is also reserved for a master journal name, though the master journal name is initially empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1634d30fc252b255d4609b96665517fdcea9fa73" translate="yes" xml:space="preserve">
          <source>After process-wide configuration is complete and &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; have been created, individual database connections can be configured using calls to &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3999670e271fa814391d216ed801ffd36e68c0e2" translate="yes" xml:space="preserve">
          <source>After reading the data for a database page, SQLite stores the raw page of data in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f403207f2b4b981533796c7ad5f8378ebe08c950" translate="yes" xml:space="preserve">
          <source>After resolving conflicts, many users like to compile and test the new version before committing it to the repository. Or you can commit first and test later. Either way, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check-in the circle (5) version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63b949f4e88ad0a023a0bdd59afe48dabc17031" translate="yes" xml:space="preserve">
          <source>After running the CREATE TABLE statement, disable the imposter mechanism as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538eea92ccc130ef6b680c0e55263bee066d1733" translate="yes" xml:space="preserve">
          <source>After successfully opening a file-handle on a potentially hot journal file, SQLite shall query the file for its size in bytes using the xFileSize() method of the open file handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fbe2d1674af788e8343a14ee7a4129b26ca4886" translate="yes" xml:space="preserve">
          <source>After the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2360cfd6cf46af06ac709eb02497e9aff167465" translate="yes" xml:space="preserve">
          <source>After the algorithm above completes successfully, it is safe to read from the database file. Once all reading has completed, the SHARED lock is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157772fcdfe2470be92e77475005f7ac0b098542" translate="yes" xml:space="preserve">
          <source>After the application has finished with the result from sqlite3_get_table(), it must pass the result table pointer to sqlite3_free_table() in order to release the memory that was malloced. Because of the way the &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; happens within sqlite3_get_table(), the calling function must not try to call &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; directly. Only &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt; is able to release the memory properly and safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c64408a8164063ed860f68818eaa546c62a346e" translate="yes" xml:space="preserve">
          <source>After the application has finished with the result from sqlite3_get_table(), it must pass the result table pointer to sqlite3_free_table() in order to release the memory that was malloced. Because of the way the &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; happens within sqlite3_get_table(), the calling function must not try to call &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; directly. Only &lt;a href=&quot;free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt; is able to release the memory properly and safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af39ba2343efa84bf5f79d3192cc7d9b779717a4" translate="yes" xml:space="preserve">
          <source>After the database changes are all safely on the mass storage device, the rollback journal file is deleted. This is the instant where the transaction commits. If a power failure or system crash occurs prior to this point, then recovery processes to be described later make it appear as if no changes were ever made to the database file. If a power failure or system crash occurs after the rollback journal is deleted, then it appears as if all changes have been written to disk. Thus, SQLite gives the appearance of having made no changes to the database file or having made the complete set of changes to the database file depending on whether or not the rollback journal file exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb7688984c453ad2bc60e9833b1d02d648b8f95" translate="yes" xml:space="preserve">
          <source>After the header and zero padding are zero or more page records. Each page record stores a copy of the content of a page from the database file before it was changed. The same page may not appear more than once within a single rollback journal. To rollback an incomplete transaction, a process has merely to read the rollback journal from beginning to end and write pages found in the journal back into the database file at the appropriate location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc35438aded45e22aeee0454d230e53ab207bab" translate="yes" xml:space="preserve">
          <source>After the imposter table is loaded into SQLite's internal schema as described above, the imposter table can be used as any other table. But the imposter table will only be visible to the one database connection that created it. No changes are made to the database file on disk. And the imposter table will disappear the next time the schema is loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb2487148ee10be0a40ce759f7c45930d397db5" translate="yes" xml:space="preserve">
          <source>After the master journal is constructed, its content is flushed to disk before any further actions are taken. On Unix, the directory that contains the master journal is also synced in order to make sure the master journal file will appear in the directory following a power failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f402b283ab865f9a9eb59bcf905d302373fd8f" translate="yes" xml:space="preserve">
          <source>After the original page content has been saved in the rollback journal, the pages can be modified in user memory. Each database connection has its own private copy of user space, so the changes that are made in user space are only visible to the database connection that is making the changes. Other database connections still see the information in operating system disk cache buffers which have not yet been changed. And so even though one process is busy modifying the database, other processes can continue to read their own copies of the original database content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39bcb3162c3e5bf861268807e2f722487ba46f2" translate="yes" xml:space="preserve">
          <source>After the parser assembles tokens into a parse tree, the code generator runs to analyze the parser tree and generate &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; that performs the work of the SQL statement. The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object is a container for this bytecode. There are many files in the code generator, including: &lt;a href=&quot;https://sqlite.org/src/file/src/attach.c&quot;&gt;attach.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/auth.c&quot;&gt;auth.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/build.c&quot;&gt;build.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/delete.c&quot;&gt;delete.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/insert.c&quot;&gt;insert.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/pragma.c&quot;&gt;pragma.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/trigger.c&quot;&gt;trigger.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/update.c&quot;&gt;update.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/vacuum.c&quot;&gt;vacuum.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/where.c&quot;&gt;where.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/wherecode.c&quot;&gt;wherecode.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/whereexpr.c&quot;&gt;whereexpr.c&lt;/a&gt;. In these files is where most of the serious magic happens. &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; handles code generation for expressions. &lt;b&gt;where*.c&lt;/b&gt; handles code generation for WHERE clauses on SELECT, UPDATE and DELETE statements. The files &lt;a href=&quot;https://sqlite.org/src/file/src/attach.c&quot;&gt;attach.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/delete.c&quot;&gt;delete.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/insert.c&quot;&gt;insert.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/trigger.c&quot;&gt;trigger.c&lt;/a&gt;&lt;a href=&quot;https://sqlite.org/src/file/src/update.c&quot;&gt;update.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vacuum.c&quot;&gt;vacuum.c&lt;/a&gt; handle the code generation for SQL statements with the same names. (Each of these files calls routines in &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/file/src/where.c&quot;&gt;where.c&lt;/a&gt; as necessary.) All other SQL statements are coded out of &lt;a href=&quot;https://sqlite.org/src/file/src/build.c&quot;&gt;build.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/auth.c&quot;&gt;auth.c&lt;/a&gt; file implements the functionality of &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1c3e7c8a391dcea0df2cfdb448d836a449fa44" translate="yes" xml:space="preserve">
          <source>After the query loop ends, the table being queried is closed at instruction 14. This is done early in order to allow other processes or threads to access that table, if desired. The list of records that was built up inside the query loop is sorted by the instruction at 15. Instructions 16 through 18 walk through the record list (which is now in sorted order) and invoke the callback once for each record. Finally, the sorter is closed at instruction 19.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a2e27dec51b31c6ed11a02889862c44fec50cf" translate="yes" xml:space="preserve">
          <source>After the query loop is finished, the table &quot;examp2&quot; is closed at instruction 23 so that its lock will be released and it can be used by other threads or processes. The next step is to loop over all aggregate buckets and output one row of the result for each bucket. This is done by the loop at instructions 24 through 30. The AggNext instruction at 24 brings the next bucket into focus, or jumps to the end of the loop if all buckets have been examined already. The 3 columns of the result are fetched from the aggregator bucket in order at instructions 25 through 27. Finally, the callback is invoked at instruction 29.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429426adc150c9c3ef8de6d6350a6529072871cf" translate="yes" xml:space="preserve">
          <source>After the shared lock is acquired, we can begin reading information from the database file. In this scenario, we are assuming a cold cache, so information must first be read from mass storage into the operating system cache then transferred from operating system cache into user space. On subsequent reads, some or all of the information might already be found in the operating system cache and so only the transfer to user space would be required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbb1609bfd1352286bb98fe2bf2342dc300ba85" translate="yes" xml:space="preserve">
          <source>After the sqlite3_test_control() call above, then run a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement the defines the imposter table. With the imposter mechanism enabled, this CREATE TABLE statement does not create a real table but instead merely adds an entry in SQLite's internal symbol table. Note that the CREATE TABLE statement must be in the correct format for the index. If the imposter table has the wrong number of columns or is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table or is otherwise incompatible with the index b-tree, then &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors will result when the imposter table is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbb0de8accee9d1365cb588f7fd022b3b5c2ef0" translate="yes" xml:space="preserve">
          <source>After the virtual table has been populated with items from multiple languages, specify the language of interest using a &quot;langid=N&quot; term in the WHERE clause of the query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71df6ec7d17df1770a907c6872e525177a99e4ae" translate="yes" xml:space="preserve">
          <source>AggFinal</source>
          <target state="translated">AggFinal</target>
        </trans-unit>
        <trans-unit id="5429b1962421b3a7ef0110360651a4a4da33b0bd" translate="yes" xml:space="preserve">
          <source>AggInverse</source>
          <target state="translated">AggInverse</target>
        </trans-unit>
        <trans-unit id="d448b9ea9be90bab4fd06d12a2a56f0f2d29976a" translate="yes" xml:space="preserve">
          <source>AggStep</source>
          <target state="translated">AggStep</target>
        </trans-unit>
        <trans-unit id="cec3f9e0080e6fe913455f3060c1205f8c71a2e5" translate="yes" xml:space="preserve">
          <source>AggStep1</source>
          <target state="translated">AggStep1</target>
        </trans-unit>
        <trans-unit id="d64e85e2bbdea61d402b8d3446eb6ec6b1845b61" translate="yes" xml:space="preserve">
          <source>AggValue</source>
          <target state="translated">AggValue</target>
        </trans-unit>
        <trans-unit id="558d7aad6e94b62a3c3d222979b260b60b6db7d2" translate="yes" xml:space="preserve">
          <source>Aggregate Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7162a0d5ccbad3a77b64c735aa5b633485f7bdb" translate="yes" xml:space="preserve">
          <source>Aggregate Functions And The GROUP BY and HAVING Clauses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a5e493a395536162c8208afa9edceff4645801" translate="yes" xml:space="preserve">
          <source>Aggregate window functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="37b83d77a9eb919bf1eed567f29546fa4dda4c46" translate="yes" xml:space="preserve">
          <source>All C-preprocessor macros used to control compile-time options now begin with the prefix &quot;SQLITE_&quot;. This may require changes to applications that compile SQLite using their own makefiles and with custom compile-time options, hence we mark this as a *** Potentially incompatible change ***</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c755a70a5620bfbf08d2e74296f5e3952109420b" translate="yes" xml:space="preserve">
          <source>All FTS5 tables feature a special hidden column named &quot;rank&quot;. If the current query is not a full-text query (i.e. if it does not include a MATCH operator), the value of the &quot;rank&quot; column is always NULL. Otherwise, in a full-text query, column rank contains by default the same value as would be returned by executing the bm25() auxiliary function with no trailing arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb6feba3d971df2c155ebbf32ecf1aeefc50b98" translate="yes" xml:space="preserve">
          <source>All RBU updates use the &quot;OR ROLLBACK&quot; constraint handling mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298c1a6a5b3113028f5781057322c183e5fb18cf" translate="yes" xml:space="preserve">
          <source>All SQLite database connections running within a single process share a single</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68fd5c55fe4176eb0a40eb1e510440312024923d" translate="yes" xml:space="preserve">
          <source>All SQLite releases starting with 3.9.0 use a three-number &quot;&lt;a href=&quot;http://semver.org&quot;&gt;semantic version&lt;/a&gt;&quot; of the form X.Y.Z. The first number X is only increased when there is a change that breaks backward compatibility. The current value for X is 3, and the SQLite developers plan to support the current SQLite database file format, SQL syntax, and C interface through &lt;a href=&quot;lts&quot;&gt;at least the year 2050&lt;/a&gt;. Hence, one can expect that all future versions of SQLite for the next several decades will begin with &quot;3.&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf3befd42e47b2311a200fc6c4505d6d3e74ba2" translate="yes" xml:space="preserve">
          <source>All calls obtain an exclusive &quot;checkpoint&quot; lock on the database file. If any other process is running a checkpoint operation at the same time, the lock cannot be obtained and SQLITE_BUSY is returned. Even if there is a busy-handler configured, it will not be invoked in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e057ca62b435caa749880050f6e16611809628" translate="yes" xml:space="preserve">
          <source>All changes made by these functions are enclosed in a savepoint transaction. If any other error (aside from a constraint failure when attempting to write to the target database) occurs, then the savepoint transaction is rolled back, restoring the target database to its original state, and an SQLite error code returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1dddd8355c69e5dffb77af16e6ef1de6dd31f80" translate="yes" xml:space="preserve">
          <source>All changes to a virtual table are made using the xUpdate method. This one method can be used to insert, delete, or update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f7c518c035d2e61b79e18649b848121cf76a11" translate="yes" xml:space="preserve">
          <source>All changes to be applied by RBU are stored in a separate SQLite database called the &quot;RBU database&quot;. The database that is to be modified is called the &quot;target database&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a33b875d90f9fced8d63e555c38a8d47436549" translate="yes" xml:space="preserve">
          <source>All code is archived on three separate machines: &lt;a href=&quot;https://www.sqlite.org&quot;&gt;https://www.sqlite.org&lt;/a&gt;, &lt;a href=&quot;https://www2.sqlite.org&quot;&gt;https://www2.sqlite.org&lt;/a&gt;, &lt;a href=&quot;https://www3.sqlite.org&quot;&gt;https://www3.sqlite.org&lt;/a&gt;. These machines are located in different cities (Dallas, Newark, and San Francisco, respectively) and managed by two different hosting companies (&lt;a href=&quot;https://linode.com&quot;&gt;Linode&lt;/a&gt; for the first two and &lt;a href=&quot;https://digitalocean.com&quot;&gt;Digital Ocean&lt;/a&gt; for the third). This diversity is intended to avoid a single point of failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9708b5aef2e3a29e2a2fbfcf884786831700182" translate="yes" xml:space="preserve">
          <source>All common table expressions (ordinary and recursive) are created by prepending a WITH clause in front of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement. A single WITH clause can specify one or more common table expressions, some of which are ordinary and some of which are recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202e588a0b168a0b374436adc14ca3f0090beda4" translate="yes" xml:space="preserve">
          <source>All component tables must have the same PRIMARY KEY declaration (if any).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa2fa17b60e175765b75266a7e677f096a5be75" translate="yes" xml:space="preserve">
          <source>All component tables must have the same set of columns, in the same order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220fd2211d0e90275b8fb6a6e680abc0805ee11c" translate="yes" xml:space="preserve">
          <source>All connections hold SQLITE_LOCK_SHARED continuously while attached to a WAL-mode database. This is true for both read/write connections and read-only connections. The SQLITE_LOCK_SHARED lock is held even by connections that are not within transaction. This is different from rollback mode, where the SQLITE_LOCK_SHARED is released at the end of each transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277f01faa8ef768e5f765984b4b0ad448802a74a" translate="yes" xml:space="preserve">
          <source>All database files to be modified by an UPDATE, INSERT or DELETE are now locked before any changes are made to any files. This makes it safe (I think) to access the same database simultaneously from multiple processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbad06084491f62976cce387f8ad55cb93120cd9" translate="yes" xml:space="preserve">
          <source>All existing versions of SQLite do a full table scan for ANALYZE. This can be slow for multi-gigabyte and larger databases. Future versions of SQLite might use random sampling rather than a full table scan to obtain estimates for the database shape, especially on larger tables. The results would approximate, but will be close enough for query planning purposes. As of 2017-03-20, this concept has been tested in experimental branches and appears to work well, but has not been folded into an official release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57093dee5c757a1ceefead7158318b61ace62d82" translate="yes" xml:space="preserve">
          <source>All extended result codes are also error codes. Hence the terms &quot;extended result code&quot; and &quot;extended error code&quot; are interchangeable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7deb3a8cda47ee51b4f2643f421866ddf4e49e" translate="yes" xml:space="preserve">
          <source>All five date and time functions take a time string as an argument. The time string is followed by zero or more modifiers. The strftime() function also takes a format string as its first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a08b0d87542a21311bc53db7ff7fe3705579a9" translate="yes" xml:space="preserve">
          <source>All incompatibilities are on obscure interfaces and hence should have zero impact on most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7142a85dafa0005cc3ffdfca6d520d8fb0b49b9b" translate="yes" xml:space="preserve">
          <source>All internal computations assume the &lt;a href=&quot;http://en.wikipedia.org/wiki/Gregorian_calendar&quot;&gt;Gregorian calendar&lt;/a&gt; system. It is also assumed that every day is exactly 86400 seconds in duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04348814491f3fa4a3cfd08b8932122a12a20fd2" translate="yes" xml:space="preserve">
          <source>All joins in SQLite are &lt;a href=&quot;optoverview#table_order&quot;&gt;implemented using nested scans&lt;/a&gt;. When a SELECT query that features a join is analyzed using EXPLAIN QUERY PLAN, one SCAN or SEARCH record is output for each nested loop. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f65525e42bafddb791aaf9fce17e894639d4b9bf" translate="yes" xml:space="preserve">
          <source>All joins in SQLite are based on the cartesian product of the left and right-hand datasets. The columns of the cartesian product dataset are, in order, all the columns of the left-hand dataset followed by all the columns of the right-hand dataset. There is a row in the cartesian product dataset formed by combining each unique combination of a row from the left-hand and right-hand datasets. In other words, if the left-hand dataset consists of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cb3ce79e6a6e92d559b23cf8ac04406011b307" translate="yes" xml:space="preserve">
          <source>All machines use SSD except Win7 which has a hard-drive. The test database is 100K blobs with sizes uniformly distributed between 8K and 12K, for a total of about 1 gigabyte of content. The database page size is 4KiB. The -DSQLITE_DIRECT_OVERFLOW_READ compile-time option was used for all of these tests. Tests were run multiple times. The first run was used to warm up the cache and its timings were discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffd5cbd04736788f9ab581e918b3089cbebbd40" translate="yes" xml:space="preserve">
          <source>All non-ASCII characters (those with codepoints greater than 127) are always considered token characters. If any non-ASCII characters are specified as part of the separators option, they are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b254312215697943ca788556e0d6b9c9450b8abd" translate="yes" xml:space="preserve">
          <source>All non-hidden columns (i.e. all columns matched by &quot;SELECT *&quot;) of the target table must be present in the input table. For virtual tables, hidden columns are optional - they are updated by RBU if present in the input table, or not otherwise. For example, to write to an fts4 table with a hidden languageid column such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f660b04140a9109b926733d1d15823285d0d8f" translate="yes" xml:space="preserve">
          <source>All of SQLite's &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; may be used as aggregate window functions. It is also possible to &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;create user-defined aggregate window functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceaa2e316a20fa6709117f30bf44efbc7dbbc8c3" translate="yes" xml:space="preserve">
          <source>All of the WAL-index locks, except for WAL_READ_LOCK(0), are held exclusively while reconstructing the global shared WAL-index during &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d3bdb37117516e584fc85e1c08d9757cba475e" translate="yes" xml:space="preserve">
          <source>All of the _printf() routines above are built around the following two functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f6322b342eb9d2dc214ced37e7517990352762" translate="yes" xml:space="preserve">
          <source>All of the above definitions are included in the &quot;sqlite.h&quot; header file that comes in the source tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693deb1c0ebd6029cb9d2f1f239c3bb4c352f744" translate="yes" xml:space="preserve">
          <source>All of the above is possible with Git, given the right extensions and tools and using the right commands. But it is not easy to do, and so it rarely gets done. Consequently, developers have less awareness of what is happening in the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8b16657892b5f01e3b5c073bd55f99b7c4acd2" translate="yes" xml:space="preserve">
          <source>All of the built-in SQL functions of SQLite are created using exactly these same interfaces. Refer to the SQLite source code, and in particular the &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/date.c&quot;&gt;date.c&lt;/a&gt; and &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/func.c&quot;&gt;func.c&lt;/a&gt; source files for examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1d5a95c4233b63280d0f7d11d256d9ad3780ef" translate="yes" xml:space="preserve">
          <source>All of the complications above (and others not mentioned here) arise from the need to preserve backwards compatibility for the hundreds of billions of SQLite database files in circulation. In a perfect world, there would be no such thing as a &quot;rowid&quot; and all tables would following the standard semantics implemented as &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables, only without the extra &quot;WITHOUT ROWID&quot; keywords. Unfortunately, life is messy. The designer of SQLite offers his sincere apology for the current mess.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778689296bb157e74a14076a42a4ee37798df0eb" translate="yes" xml:space="preserve">
          <source>All of the existing safe languages are new. The developers of SQLite applaud the efforts of computer language researchers in trying to develop languages that are easier to program safely. We encourage these efforts to continue. Be we ourselves are more interested in old and boring languages when it comes to implementing SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7375d32a78c6b8f51d450c556f25932bdf217bf1" translate="yes" xml:space="preserve">
          <source>All of the experiments that follow operate the same with either &quot;test1.dir&quot; or &quot;test1.tree&quot;. Very little performance difference is measured in either case, regardless of operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643d0c9cb63fb8635827200eced1089f9e88183c" translate="yes" xml:space="preserve">
          <source>All of the result in the example are the same if the comparisons are commuted - if expressions of the form &quot;a&amp;lt;40&quot; are rewritten as &quot;40&amp;gt;a&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0e885150a13c9c4803941a5f8336469ed747f0" translate="yes" xml:space="preserve">
          <source>All of the tests above must run successfully, on multiple platforms and under multiple compile-time configurations, before each release of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efae1cd770ea6fe5f2bf4478750e0f4cc942ea9" translate="yes" xml:space="preserve">
          <source>All of these commands work the same way if the filename argument is is a ZIP Archive instead of an SQLite database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4dfc2a775cfce09d4f8b1860eec11883d0cac7" translate="yes" xml:space="preserve">
          <source>All of these factors combine to make SQLite a very trouble-free software library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7683c6e8ad5efd15af0f1da2349a585dbe4001cb" translate="yes" xml:space="preserve">
          <source>All of these things can be provided in a single auxiliary C code file and then linked with the stock &quot;sqlite3.c&quot; code file to generate a working SQLite build for the target operating system. In addition to the alternative mutex and memory allocation subsystems and the new VFS, the auxiliary C code file should contain implementations for the following two routines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690aa8cfa4b8586b89a0a9eedc4d3f3b13222c70" translate="yes" xml:space="preserve">
          <source>All other bytes of the database file header are reserved for future expansion and must be set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f932ce0ba425204c0c4c7e4d764d13c207d60d" translate="yes" xml:space="preserve">
          <source>All processes using a database must be on the same host computer; WAL does not work over a network filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a418c8d3a0ce039842b297ad3c3dfb42d51a90" translate="yes" xml:space="preserve">
          <source>All queries on the table must be full-text queries. In other words, they must use the MATCH or = operator with the table-name column as the left-hand operand, or else use the table-valued function syntax. Any query that is not a full-text query results in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38351d4546ab4ff59382ce23bdac471def2ad5d5" translate="yes" xml:space="preserve">
          <source>All reads from and writes to the main database file begin at a page boundary and all writes are an integer number of pages in size. Reads are also usually an integer number of pages in size, with the one exception that when the database is first opened, the first 100 bytes of the database file (the database file header) are read as a sub-page size unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d450d3a75d9f08311a07a29768bf79cccc1c19d2" translate="yes" xml:space="preserve">
          <source>All result codes are integers. Symbolic names for all result codes are created using &quot;#define&quot; macros in the sqlite3.h header file. There are separate sections in the sqlite3.h header file for the &lt;a href=&quot;c3ref/c_abort&quot;&gt;result code definitions&lt;/a&gt; and the &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;extended result code definitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4028b4aa3d3e24115d72e2f624df2443ac4d4652" translate="yes" xml:space="preserve">
          <source>All spaces following the first two keywords are converted into a single space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86f24edc76db2b20a12087f5cf419af602faa95" translate="yes" xml:space="preserve">
          <source>All string values at the SQL level in SQLite are dynamic strings. Requiring type strings to be static makes it difficult to create an application-defined SQL function that can synthesize a pointer of an arbitrary type. We do not want users to create such SQL functions, since such functions would compromise the security of the system. Thus, the requirement to use static strings helps to defend that the integrity of the pointer-passing interfaces against ill-designed SQL functions. The static string requirement is not a perfect defense, since a sophisticated programmer can code around it, and a novice program can simply take the memory leak. But by stating that the pointer type string must be static, we hope to encourage developers who might otherwise use a dynamic string for the pointer type to think more carefully about the problem and avoid introducing security issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a460cfc406da09ab8128bfc4445d97c56d406f1" translate="yes" xml:space="preserve">
          <source>All subsequent command line words are command arguments, not options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed156deca85bc9a5dd9088fbd94f8a842f1f33c" translate="yes" xml:space="preserve">
          <source>All substitutions begin with a single &quot;%&quot; and end with a single type character. The other elements of the substitution are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c42d2b7071c7a3c388400fdb8f6ee7f3109b7cf" translate="yes" xml:space="preserve">
          <source>All tables that participate in a union-vtab must be &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31bee81e9b968bc240c90d0ddec46a1b51435a7" translate="yes" xml:space="preserve">
          <source>All tables that participate in a union-vtab must have identical CREATE TABLE definitions, except that the names of the tables can be different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567093004d4bf6708c2d16ff16df1498f9ca4cec" translate="yes" xml:space="preserve">
          <source>All terms of the WHERE clause are analyzed to see if they can be satisfied using indices. To be usable by an index a term must be of one of the following forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf993933e40301457f333ff6f1f8a23481fc0a6" translate="yes" xml:space="preserve">
          <source>All tests are conducted on an otherwise quiescent machine. A simple Tcl script was used to generate and run all the tests. A copy of this Tcl script can be found in the SQLite source tree in the file &lt;b&gt;tools/speedtest.tcl&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b130e54f0f69ef3abad26bc072b0470f6263286a" translate="yes" xml:space="preserve">
          <source>All tests must give the same answer in all three builds. See the &lt;a href=&quot;testing&quot;&gt;&quot;How SQLite Is Tested&quot;&lt;/a&gt; document for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d8d36777ef2e501af7ab9b2e6ef786e48ae2b6" translate="yes" xml:space="preserve">
          <source>All that said, it is possible that SQLite might one day be recoded in Rust. Recoding SQLite in Go is unlikely since Go hates assert(). But Rust is a possibility. Some preconditions that must occur before SQLite is recoded in Rust include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="707caca3d9bbd176531f568662a7102a40b5f6fd" translate="yes" xml:space="preserve">
          <source>All the example queries above return the ten most relevant query results. By modifying the values used with the OFFSET and LIMIT clauses, a query to return (say) the next ten most relevant results is easy to construct. This may be used to obtain the data required for a search applications second and subsequent pages of results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="470143461be606a45aab0f210d1498edb2c84368" translate="yes" xml:space="preserve">
          <source>All things considered, applications should normally be able to hold their maximum memory allocation size below 2K or 4K. This gives a value for log&lt;sub&gt;2&lt;/sub&gt;(&lt;b&gt;n&lt;/b&gt;) of 2 or 3. This will limit &lt;b&gt;N&lt;/b&gt; to between 2 and 2.5 times &lt;b&gt;M&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635a64a808a6eed58043c45da38b8c4ec5742ac1" translate="yes" xml:space="preserve">
          <source>All three auxiliary functions extract a set of &quot;matchable phrases&quot; from the FTS query expression to work with. The set of matchable phrases for a given query consists of all phrases (including unquoted tokens and token prefixes) in the expression except those that are prefixed with a unary &quot;-&quot; operator (standard syntax) or are part of a sub-expression that is used as the right-hand operand of a NOT operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e856a97cf9fae10a8a385ba08b2985c87e16aaf1" translate="yes" xml:space="preserve">
          <source>All three database engines run faster when they have indices to work with. But SQLite is still the fastest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6baeeca7bdbd41abd15a40b8b926de6f745b8bb0" translate="yes" xml:space="preserve">
          <source>All three of the above source files are contained in the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;amalgamation tarball&lt;/a&gt; available on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf60184a7e675d81f6bedcfe7ca27f21750f46d0" translate="yes" xml:space="preserve">
          <source>All type information or constraint specifications must be removed from column definitions. FTS3/4 ignores everything following the column name in a column definition, FTS5 attempts to parse it (and will report an error if it fails to).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1de722aadb01564eff9284d3ae40b05c75cdc11" translate="yes" xml:space="preserve">
          <source>All uppercase characters within the ASCII range (Unicode codepoints less than 128), are transformed to their lowercase equivalents as part of the tokenization process. Thus, full-text queries are case-insensitive when using the simple tokenizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230a993ba607de10c8e04d67e19e0d8357f45f60" translate="yes" xml:space="preserve">
          <source>All values in SQL statements, whether they are literals embedded in SQL statement text or &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; bound to &lt;a href=&quot;c3ref/stmt&quot;&gt;precompiled SQL statements&lt;/a&gt; have an implicit storage class. Under circumstances described below, the database engine may convert values between numeric storage classes (INTEGER and REAL) and TEXT during query execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2db63f1dd84225eeca5b66732ebeb7dfeca7e9c" translate="yes" xml:space="preserve">
          <source>All versions of SQLite since 3.3.0 (2006-01-10) can read and write any schema format between 1 and 4. But older versions of SQLite might not be able to read formats greater than 1. So that older versions of SQLite will be able to read and write database files created by newer versions of SQLite, the default schema format was set to 1 for SQLite versions through 3.7.9 (2011-11-01). Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the default schema format is 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a315e152418f974223f0caef4a38a40619deaba9" translate="yes" xml:space="preserve">
          <source>All versions of SQLite up to and including &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;version 3.7.9&lt;/a&gt; (2011-11-01) assume that the filesystem does &lt;u&gt;not&lt;/u&gt; provide powersafe overwrite. SQLite has traditionally assumed that when any one byte of a file changes, all other bytes within the same sector of that byte have the potential of being corrupted on a power loss. When writing, SQLite has made sure to journal all bytes in the same sector of any modifications and it pads journal files out to the next sector boundary so that subsequent appends to that journal cannot damage prior records. SQLite understands the sector size to be the value returned by the xSectorSize method in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. The SQLite team has often referred to the value returned by xSectorSize as the &quot;blast radius&quot; of a write, since it expresses the range of bytes that might be damaged if a power loss occurs during the write. The default &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; for unix and windows have always returned 512 as the sector size (or blast radius) for all versions of SQLite up to and including version 3.7.9.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff80c8a340db91dd8a4375abd89d32aa974509b" translate="yes" xml:space="preserve">
          <source>All versions of SQLite up to and including version 3.5.9 have mishandled NULL values on the right-hand side of IN and NOT IN operators. Specifically, SQLite has previously ignored NULLs on the right-hand side of IN and NOT IN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f103276ac70c09043aecb18573124bfe2497c24b" translate="yes" xml:space="preserve">
          <source>Allocate a new b-tree in the main database file if P1==0 or in the TEMP database file if P1==1 or in an attached database if P1&amp;gt;1. The P3 argument must be 1 (BTREE_INTKEY) for a rowid table it must be 2 (BTREE_BLOBKEY) for an index or WITHOUT ROWID table. The root page number of the new b-tree is stored in register P2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c7e4f88a0a3613dabebb78baaf9f796e649934" translate="yes" xml:space="preserve">
          <source>Allocate a new changeset rebaser object. If successful, set (*ppNew) to point to the new object and return SQLITE_OK. Otherwise, if an error occurs, return an SQLite error code (e.g. SQLITE_NOMEM) and set (*ppNew) to NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890d83377e0f9622417e6019e12893679bb2c728" translate="yes" xml:space="preserve">
          <source>Allocate a new page if it easy and convenient to do so. Otherwise return NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b563fc1e21cbbe40e2fcd69876f3f214fc04c0f" translate="yes" xml:space="preserve">
          <source>Allow &quot;&amp;lt;expr&amp;gt; IN &amp;lt;table&amp;gt;&quot; as a shorthand for &quot;&amp;lt;expr&amp;gt; IN (SELECT * FROM &amp;lt;table&amp;gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d0f1303155aabcd4262ede8a9d90bfb68ed8f4" translate="yes" xml:space="preserve">
          <source>Allow &quot;?&quot; parameters in the LIMIT clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8e51f439edbc4cbc973e08ee46366e6e096d45" translate="yes" xml:space="preserve">
          <source>Allow &quot;VIEW&quot; to be a column name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377c13da16b3a423a23503b52be9d946eb79c0be" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;deterministic&quot;&gt;deterministic SQL functions&lt;/a&gt; in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a09844684ca2e04e8580f1dc89f5d23c5aed0e" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; commands to work inside of a transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9aa4176f2699ab1a840e5917668b064b3516ba4" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; to appear on the right-hand side of an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d9b4c29aa05f94ecb72a287ad5d41af03effad" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID virtual tables&lt;/a&gt; to be writable if the PRIMARY KEY contains exactly one column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269070c3e8d911c8236d5f897186b3e1ab6e4e31" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;wal&quot;&gt;WAL-mode&lt;/a&gt; databases to be opened read-only as long as there is an existing read/write connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef741e84d49fdcc8210ba15eda342eea0faf46a9" translate="yes" xml:space="preserve">
          <source>Allow GLOB and LIKE operators to work as functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8d8f395445a63807721ea16945b2777fb51092" translate="yes" xml:space="preserve">
          <source>Allow NULL arguments in sqlite_compile() and sqlite_step().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186268005d1a02f259dbb9958233b56b69668278" translate="yes" xml:space="preserve">
          <source>Allow WHERE clause terms on the left table of a LEFT OUTER JOIN to contain aggregate subqueries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38079f81b0c869a35e192a7c7ee51456917575b5" translate="yes" xml:space="preserve">
          <source>Allow a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; to be used anywhere a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29c570354c3dc76b997275a38b4804dd30d724a" translate="yes" xml:space="preserve">
          <source>Allow arbitrary expressions, including function calls and subqueries, in the filename argument to &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087d2618f268406853ee3cd79209ec421c2d288d" translate="yes" xml:space="preserve">
          <source>Allow collating sequence names to be quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026b30b967a2b6589a1cfbc782a3c2b403048beb" translate="yes" xml:space="preserve">
          <source>Allow constraint names on the DEFAULT clause in a table definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6215a826c022df62b341a6590cb9e2024e5f7525" translate="yes" xml:space="preserve">
          <source>Allow floating point literals to begin or end with a decimal point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c2ba2fe3b0e6c9a56edf6ddf62886b17854fb2" translate="yes" xml:space="preserve">
          <source>Allow identifiers to be quoted in square brackets, for compatibility with MS-Access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a61cbdfe59167766b82b62a24a23f799327821d" translate="yes" xml:space="preserve">
          <source>Allow indices to be used for sorting even if prior terms of the index are constrained by IN operators in the WHERE clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef34a12d16effc2a1e0c0a26a046cc6b9ba4f95" translate="yes" xml:space="preserve">
          <source>Allow more system calls to be overridden in the unix VFS - to provide better support for chromium sandboxes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d47c202ac74ad6be5e5952c7d032a0006fd10e" translate="yes" xml:space="preserve">
          <source>Allow multiple simultaneous readers under Windows by simulating the reader/writers locks that are missing from Win95/98/ME.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec002f75566ff8ab7f2b3337c8366c012290ae9" translate="yes" xml:space="preserve">
          <source>Allow new user-defined functions to be created when there are already one or more precompiled SQL statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331932f674e6d859e399fb8d0775ada55921d45e" translate="yes" xml:space="preserve">
          <source>Allow read transactions to be freely opened and closed by SQL statements run from within the implementation of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; if the function is called by a SELECT statement that does not access any database table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16104cba6ed4e5c5fd3de40cb546c3fb1bc3c957" translate="yes" xml:space="preserve">
          <source>Allow sqlite_exec() to be called from within user-defined SQL functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9296631111fc0993d0527ddffb1b74601f16736" translate="yes" xml:space="preserve">
          <source>Allow the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command to change the page size of a database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac64bf7a32177d90d0452da0d0056ea1b87de06" translate="yes" xml:space="preserve">
          <source>Allow the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; method of &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations to return &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; to indicate that the proposed query plan is unusable and should not be given further consideration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6424ee4a8785aaef1a25b07cf3555293853c9183" translate="yes" xml:space="preserve">
          <source>Allow the DEFAULT value of a column to call functions that have constant operands</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b663434ab971b5c50c2b931e627bcf32963ce5d" translate="yes" xml:space="preserve">
          <source>Allow the error message from &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to be longer than 20000 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb3e6f837b7598e3baf15397c889298e8fd1c4d" translate="yes" xml:space="preserve">
          <source>Allow the name of a database to be prefixed by the driver type. For now, the only driver type is &quot;gdbm:&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc00039aaf898d163afc8dbd0e94542ba8ecc28" translate="yes" xml:space="preserve">
          <source>Allow the value -9223372036854775808 as an integer literal in SQL statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee90ceb52dbab56bc4990303982723135b728d9" translate="yes" xml:space="preserve">
          <source>Allow transactions to span Linux Threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffa48f8c38520d1cf8de848950d598b10eb8e45" translate="yes" xml:space="preserve">
          <source>Allow up to 64 tables in a join - the old limit was 32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fef18fe97d9b603d8ce243c65accbdab4d874a" translate="yes" xml:space="preserve">
          <source>Allow virtual table constructors to be invoked recursively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e23d564e7f297c7a2b5ceff9d8f6ef229ac9a5" translate="yes" xml:space="preserve">
          <source>Allowed P5 bits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1287cd665e8d2234952aeb1f2ae2c3398192c7b9" translate="yes" xml:space="preserve">
          <source>Allowing extension components to pass private information to one another securely and without introducing pointer leaks requires new interfaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d20875a194118243c2bc48398fc9e50e653168b" translate="yes" xml:space="preserve">
          <source>Alphabetical Listing Of All Documents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6ed234869c2180894bb5c831639c8bf2a71c3a" translate="yes" xml:space="preserve">
          <source>Also available is the similar but more mature &lt;a href=&quot;fts3&quot;&gt;FTS3/4&lt;/a&gt; module. FTS5 is a new version of FTS4 that includes various fixes and solutions for problems that could not be fixed in FTS4 without sacrificing backwards compatibility. Some of these problems are &lt;a href=&quot;fts5#_summary_of_technical_differences_&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc4b8824c8f732ab94ebdcfb7669cd9ac01bcf0" translate="yes" xml:space="preserve">
          <source>Also available: &lt;a href=&quot;../rescode&quot;&gt;list of error codes&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04534899f708d46ebaa30f16a02cbe243e196ae" translate="yes" xml:space="preserve">
          <source>Also available: &lt;a href=&quot;rescode&quot;&gt;list of error codes&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861a9e2d67fe5f61973dab8932f2db2e113ce546" translate="yes" xml:space="preserve">
          <source>Also, whether or not P4 is set, check that this is not being called from within a callback to a virtual table xSync() method. If it is, the error code will be set to SQLITE_LOCKED.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087d1b6052e351518f2d15a60b3d4e94a4ca524e" translate="yes" xml:space="preserve">
          <source>Alternatively, FTS5 may be built as a loadable extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c1c99f2707eb260cd81c76dc0cd3c1b0734ce4" translate="yes" xml:space="preserve">
          <source>Alternatively, the first argument following to &quot;.ar&quot; may be the concatenation of the short form of all required options (without the &quot;-&quot; characters). In this case arguments for options requiring them are read from the command line next, and any remaining words are considered command arguments. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abd2d3f1bfc69f474a1675b744197ff1ab504ae" translate="yes" xml:space="preserve">
          <source>Alternatively, the unionvtab.c file may be compiled into the application. In this case, the following function should be invoked to register the extension with each new database connection:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee75d1aa4e172f68779a1484c212e21f3e9f3faf" translate="yes" xml:space="preserve">
          <source>Alternatively, the zipfile.c file may be compiled into the application. In this case, the following function should be invoked to register the extension with each new database connection:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5944ffdf9815956de892051d5dd5e1fe60e1a9e4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a new database using the default temporary storage, then save that database into a disk file using the &quot;.save&quot; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b777ccc0b549914aaf4c953fa2687953baa7c2b" translate="yes" xml:space="preserve">
          <source>Although FTS3 and FTS4 are included with the SQLite core source code, they are not enabled by default. To build SQLite with FTS functionality enabled, define the preprocessor macro &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt; when compiling. New applications should also define the &lt;a href=&quot;compile#enable_fts3_parenthesis&quot;&gt;SQLITE_ENABLE_FTS3_PARENTHESIS&lt;/a&gt; macro to enable the &lt;a href=&quot;fts3#_set_operations_using_the_enhanced_query_syntax&quot;&gt;enhanced query syntax&lt;/a&gt; (see below). Usually, this is done by adding the following two switches to the compiler command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024fe1545f30cb8dee088c5ad188ae320d8b4ae9" translate="yes" xml:space="preserve">
          <source>Although it is less common, a call to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; may also return SQLITE_LOCKED if it cannot obtain a read-lock on the sqlite_master table of each attached database. These APIs need to read the schema data contained in the sqlite_master table in order to compile SQL statements to &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f535c18aa59fdbaaceb49a43b9f2ac5c4e156d04" translate="yes" xml:space="preserve">
          <source>Although it would be easy to design a system that uses the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6556666b4b860beb62beea54857b52422d71a07f" translate="yes" xml:space="preserve">
          <source>Always convert IEEE floating point NaN values into NULL during processing. (Ticket #3060)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b27942fc2ef02de9cc71a49d6d11d937c022cb" translate="yes" xml:space="preserve">
          <source>Always interpret non-zero floating-point values as TRUE, even if the integer part is zero. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/36fae083b450e3a&quot;&gt;36fae083b450e3a&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c848b30df81d8f55cf3c7d1f8d1d01a761b810" translate="yes" xml:space="preserve">
          <source>Always open files using FILE_FLAG_RANDOM_ACCESS under Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0cacbdc1960d533261c8055f23aacbc49821e24" translate="yes" xml:space="preserve">
          <source>Always use &quot;.&quot; instead of &quot;,&quot; as the decimal point even if the locale requests &quot;,&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584a08c96e54122403ed19c82a813d569f28232d" translate="yes" xml:space="preserve">
          <source>Always use memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c823a3478b423d7cd3fa93f63e415cd1f8284276" translate="yes" xml:space="preserve">
          <source>Always use temporary files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57bd289a4480abf71228980bc961a3a7a81bab14" translate="yes" xml:space="preserve">
          <source>Ambiguity resolved using a WHERE clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977cc4fa3c5b3e0d768448bc0910909b0cd480d9" translate="yes" xml:space="preserve">
          <source>Ambiguous use of ON:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0cddb45b39e592335cd66056d26b1854d76f94" translate="yes" xml:space="preserve">
          <source>Among other things, sqlite3_initialize() will invoke sqlite3_os_init(). Similarly, sqlite3_shutdown() will invoke sqlite3_os_end().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0ecb85fd4a2b4dd0713046f9744fe6177cf89e" translate="yes" xml:space="preserve">
          <source>An &quot;SQLite Archive&quot; is a file container similar to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP archive&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Tar_(computing)&quot;&gt;Tarball&lt;/a&gt; but based on an SQLite database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348f5f09abc7f6ee023e124686a6cf3527b1dbca" translate="yes" xml:space="preserve">
          <source>An &quot;application file format&quot; is the file format used to persist application state to disk or to exchange information between programs. There are thousands of application file formats in use today. Here are just a few examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d82aa19e1738a25aad29a6b9a73b1ca57ba1dc" translate="yes" xml:space="preserve">
          <source>An &quot;external content&quot; FTS4 table is similar to a contentless table, except that if evaluation of a query requires the value of a column other than docid, FTS4 attempts to retrieve that value from a table (or view, or virtual table) nominated by the user (hereafter referred to as the &quot;content table&quot;). The FTS4 module never writes to the content table, and writing to the content table does not affect the full-text index. It is the responsibility of the user to ensure that the content table and the full-text index are consistent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec1d3e19881ca421cb7ef0c70026b7ad57adf0c" translate="yes" xml:space="preserve">
          <source>An &quot;int&quot; or &quot;unsigned int&quot;. 32-bits on all modern systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca7e1d1ee9bc38ef78e0ad004ec09a25f38b015" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file in the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;OS interface layer&lt;/a&gt;. Individual OS interface implementations will want to subclass this object by appending additional fields for their own use. The pMethods entry is a pointer to an &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that defines methods for performing I/O operations on the open file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04381375841e88bf037fe1e6179f30d5aff3be33" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; that fails due to a constraint violation is not a successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; and does not change the value returned by this routine. Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails. When INSERT OR REPLACE encounters a constraint violation, it does not fail. The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7085e9237366e0a877aba7cfe87f1fe93d5ad83" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object defines the name of the VFS and the core methods that implement the interface to the operating system, such as checking for existence of files, deleting files, creating files and opening and for reading and/or writing, converting filenames into their canonical form. The &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object also contains methods for obtaining randomness from the operating system, for suspending a process (sleeping) and for finding the current date and time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f60bd7f87def89c1a6337dcd5b5e2b9262a189b" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file in the &lt;a href=&quot;vfs&quot;&gt;OS interface layer&lt;/a&gt;. Individual OS interface implementations will want to subclass this object by appending additional fields for their own use. The pMethods entry is a pointer to an &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that defines methods for performing I/O operations on the open file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a08f9e5c908a78454f64ebfc15b9347529f0e74" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/R-tree&quot;&gt;R-Tree&lt;/a&gt; is a special index that is designed for doing range queries. R-Trees are most commonly used in geospatial systems where each entry is a rectangle with minimum and maximum X and Y coordinates. Given a query rectangle, an R-Tree is able to quickly find all entries that are contained within the query rectangle or which overlap the query rectangle. This idea is easily extended to three dimensions for use in CAD systems. R-Trees also find use in time-domain range look-ups. For example, suppose a database records the starting and ending times for a large number of events. A R-Tree is able to quickly find all events that were active at any time during a given time interval, or all events that started during a particular time interval, or all events that both started and ended within a given time interval. And so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db689d4a40dd989536fc477e73ac5f455ae9b267" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause may be specified as part of an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; action within the body of the trigger. However if an &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause is specified as part of the statement causing the trigger to fire, then conflict handling policy of the outer statement is used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e711e9ab5f059bf81635cdaabe4f6f12406ca0c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement with multiple values in the VALUES clause is implemented internally as a compound SELECT. Hence, this option also disables the ability to insert more than a single row using an INSERT INTO ... VALUES ... statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72576d10f0db6ca1b372a30155a9969a36efce9" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that fails due to a constraint violation is not a successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; and does not change the value returned by this routine. Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails. When INSERT OR REPLACE encounters a constraint violation, it does not fail. The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233c7df9e2b5c5b148e9cdae3dbfbdc38ff611a4" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; error is returned when SQLite detects an error in the structure, format, or other control elements of the database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfcb5b52a759e3eac1cc34a332a837f3610b881" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error is returned when a prepared SQL statement is no longer valid and cannot be executed. When this occurs, the statement must be recompiled from SQL using the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; API. An SQLITE_SCHEMA error can only occur when using the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interfaces to run SQL. You will never receive an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error from &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. Nor will you receive an error if you prepare statements using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb0be389d3467046061e0e60795dd9c8924c2d5" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;INSERT&lt;/b&gt;. An INSERT change contains a single row to add to a database table. The payload of the INSERT change consists of the values for each field of the new row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83cdb736e009dffced879294068506baa8e9d683" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;UPDATE&lt;/b&gt;. An UPDATE change represents the modification of one or more non-PRIMARY KEY fields of a single row within a database table, identified by its PRIMARY KEY fields. The payload for an UPDATE change consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5dfc23afaff11afa8f689dfc92f096e1d0dd0f7" translate="yes" xml:space="preserve">
          <source>An ALWAYS(X) or NEVER(X) sometimes verifies pre-conditions that are subject to change if other parts of the code are modified in subtle ways. At &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5512-5516&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5512-5516&lt;/a&gt; we have a test for two pre-conditions that are true only because of the limited scope of use of the sqlite3BtreeRowCountEst() function. Future enhancements to SQLite might use sqlite3BtreeRowCountEst() in new ways where those preconditions no longer hold, and the NEVER() macros will quickly alert the developers to that fact when the situation arises. But if, for some reason, the pre-conditions are not satisfied in a release build, the program will still behave sanely and will not do an undefined memory access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62094908e44ce569763e84accf72b5b81ec10e3e" translate="yes" xml:space="preserve">
          <source>An Abort is safe if either there have been no writes, or if there is an active statement journal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d4a08053c797c7b22cbaba83f05ba798cb81a9" translate="yes" xml:space="preserve">
          <source>An Asynchronous I/O Module For SQLite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313cb43d54770c72c9e9a5b634de9c9d8807284f" translate="yes" xml:space="preserve">
          <source>An EXCLUDE clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3ccdd1b90a20f1709a032dfb49632f1706153c" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE WAL_CKPT_LOCK is held by any connection that is running a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. The &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; field of the WAL-index header may be increased while holding this exclusive lock, but it may not be decreased.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a19836854f508f748dd9a22070d5c210f0d520" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE WAL_RECOVER_LOCK is held by any connection that is running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; to reconstruct the shared WAL-index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d163a00e9e60a29df0fd7690728f45560ff5f27b" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE WAL_WRITE_LOCK is held by any connection that is appending content to the end of the WAL. Hence, only a single process at a time can append content to the WAL. If a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; occurs as a consequence of a write, then the &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; field of the WAL-index header is reset to zero while holding this lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57abe13c7006fd13b284a30313d8dda20eaf017" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE is also held WAL_CKPT_LOCK, and on several other locking bytes, when a connection is running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; on the shared WAL-index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b81d585355ad5a271ae62aa21273cf7062ea05" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE is also held WAL_WRITE_LOCK, and on several other locking bytes, when a connection is running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; on the shared WAL-index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52310ba827cb9fe23894a867314c3a13854ff87" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE lock is needed in order to write to the database file. Only one EXCLUSIVE lock is allowed on the file and no other locks of any kind are allowed to coexist with an EXCLUSIVE lock. In order to maximize concurrency, SQLite works to minimize the amount of time that EXCLUSIVE locks are held.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2062deb028f6de38ba9c3021c202a7b43810db" translate="yes" xml:space="preserve">
          <source>An FTS tokenizer is a set of rules for extracting terms from a document or basic FTS full-text query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818fc889442be27af5d1325013f400680296296c" translate="yes" xml:space="preserve">
          <source>An I/O error on a memory-mapped file cannot be caught and dealt with by SQLite. Instead, the I/O error causes a signal which, if not caught by the application, results in a program crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c82d6c0937081333b2317419d2ebad443727010" translate="yes" xml:space="preserve">
          <source>An IEEE double-precision (64-bit) floating point number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd5420d6298ed92154e0329258defd31fd25a74" translate="yes" xml:space="preserve">
          <source>An INTEGER or REAL value is less than any TEXT or BLOB value. When an INTEGER or REAL is compared to another INTEGER or REAL, a numerical comparison is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3433c2fda29528c66dead93e3becaa2d64f147" translate="yes" xml:space="preserve">
          <source>An Introduction To The SQLite C/C++ Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1217ba99243b6eebb93b7b8b51f28f6be4f9d08a" translate="yes" xml:space="preserve">
          <source>An ORDER BY clause on the recursive-select can be used to control whether the search of a tree is depth-first or breadth-first. To illustrate, we will use a variation on the &quot;org&quot; table from an example above, without the &quot;height&quot; column, and with some real data inserted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23032a9cac30263b1d8146df43c99d82099810f2" translate="yes" xml:space="preserve">
          <source>An ORDER BY or GROUP BY clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7badb7ceeef79983e30969dff232619460ee2c" translate="yes" xml:space="preserve">
          <source>An OpenDocument Presentation or &quot;ODP&quot; file is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP archive&lt;/a&gt; containing XML files describing presentation slides and separate image files for the various images that are included as part of the presentation. (OpenDocument word processor and spreadsheet files are similarly structured but are not considered by this article.) The reader can easily see the content of an ODP file by using the &quot;zip -l&quot; command. For example, the following is the &quot;zip -l&quot; output from a 49-slide presentation about SQLite from the 2014 &lt;a href=&quot;http://southeastlinuxfest.org/&quot;&gt;SouthEast LinuxFest&lt;/a&gt; conference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc6b47353bce3b91e074154d427c28b96c16d62" translate="yes" xml:space="preserve">
          <source>An R*Tree query is initialized by making the root node the only entry in a priority queue sorted by rScore. The query proceeds by extracting the entry from the priority queue that has the lowest score. If that entry is a leaf (meaning that it is an actual R*Tree entry and not a subtree) then that entry is returned as one row of the query result. If the extracted priority queue entry is a node (a subtree), then sub-subtrees or leaves contained within that entry are passed to the xQueryFunc callback, one by one. Those subelements for which the xQueryFunc callback sets eWithin to PARTLY_WITHIN or FULLY_WITHIN are added to the priority queue using the score supplied by the callback. Subelements that return NOT_WITHIN are discarded. The query runs until the priority queue is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c36503645997aef3b66492ffa49c5737331ae5b" translate="yes" xml:space="preserve">
          <source>An RBU Vacuum operation requires less temporary disk space and writes less data to disk than an SQLite VACUUM. An SQLite VACUUM requires roughly twice the size of the final database file in temporary disk space to run. The total amount of data written is around three times the size of the final database file. By contrast, an RBU Vacuum requires roughly the size of the final database file in temporary disk space and writes a total of twice that to disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b402488c545650e7a0466693ac0992d5dced3759" translate="yes" xml:space="preserve">
          <source>An RBU handle is created by calling sqlite3rbu_vacuum(T, S).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d98c92ed51948506a67c9bcda80cc97f4fcfe4" translate="yes" xml:space="preserve">
          <source>An SQL aggregate function, which can be used to create new archives in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd314dc55feb99e9480fcbcc4eb53b163d23b23" translate="yes" xml:space="preserve">
          <source>An SQL operation that is interrupted will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;. If the interrupted SQL operation is an INSERT, UPDATE, or DELETE that is inside an explicit transaction, then the entire transaction will be rolled back automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8b61384d0c44a2e614c579b268363eaa1fc909" translate="yes" xml:space="preserve">
          <source>An SQL operation that is interrupted will return &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;. If the interrupted SQL operation is an INSERT, UPDATE, or DELETE that is inside an explicit transaction, then the entire transaction will be rolled back automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de39c28f7d860e2f20cf499f83a1ecd516190b8" translate="yes" xml:space="preserve">
          <source>An SQL statement can be preceded by the keyword &quot;EXPLAIN&quot; or by the phrase &quot;EXPLAIN QUERY PLAN&quot;. Either modification causes the SQL statement to behave as a query and to return information about how the SQL statement would have operated if the EXPLAIN keyword or phrase had been omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abd7dabfe02360ec2bf6a05e3dfaa3cf5654f08" translate="yes" xml:space="preserve">
          <source>An SQLITE_BUSY error can occur at any point in a transaction: when the transaction is first started, during any write or update operations, or when the transaction commits. To avoid encountering SQLITE_BUSY errors in the middle of a transaction, the application can use &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; instead of just &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; to start a transaction. The &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; command might itself return SQLITE_BUSY, but if it succeeds, then SQLite guarantees that no subsequent operations on the same database through the next &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; will return SQLITE_BUSY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac700efdf9da65c96e524e1f874e4322c772698e" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_CLOSE callback is invoked when a database connection closes. The P argument is a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; object and the X argument is unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90dda83d19d5a0e9440a66a5153d6f08cfb8e791" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_CLOSE callback is invoked when a database connection closes. The P argument is a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; object and the X argument is unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6463d38e5743fc7b60a45c0dd4edf8e6196b2c76" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_PROFILE callback provides approximately the same information as is provided by the &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback. The P argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument points to a 64-bit integer which is the estimated of the number of nanosecond that the prepared statement took to run. The SQLITE_TRACE_PROFILE callback is invoked when the statement finishes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f65212fb2842387dde50749c6891ed068f1d2c" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_PROFILE callback provides approximately the same information as is provided by the &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback. The P argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument points to a 64-bit integer which is the estimated of the number of nanosecond that the prepared statement took to run. The SQLITE_TRACE_PROFILE callback is invoked when the statement finishes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959b99495fe9f93bfe60c0c8dc39f940a8cc7107" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_ROW callback is invoked whenever a prepared statement generates a single row of result. The P argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument is unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c23282009e34d356e10ef768fd5d27fe9242d7" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_ROW callback is invoked whenever a prepared statement generates a single row of result. The P argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument is unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87f64da2cd54c09ca013ca90ee9edc2e86b39e0" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_STMT callback is invoked when a prepared statement first begins running and possibly at other times during the execution of the prepared statement, such as at the start of each trigger subprogram. The P argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. The X argument is a pointer to a string which is the unexpanded SQL text of the prepared statement or an SQL comment that indicates the invocation of a trigger. The callback can compute the same text that would have been returned by the legacy &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; interface by using the X argument when X begins with &quot;--&quot; and invoking &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_expanded_sql(P)&lt;/a&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e19a52fd0823eafed0ed156581e34f2ae1fb9a" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_STMT callback is invoked when a prepared statement first begins running and possibly at other times during the execution of the prepared statement, such as at the start of each trigger subprogram. The P argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. The X argument is a pointer to a string which is the unexpanded SQL text of the prepared statement or an SQL comment that indicates the invocation of a trigger. The callback can compute the same text that would have been returned by the legacy &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; interface by using the X argument when X begins with &quot;--&quot; and invoking &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_expanded_sql(P)&lt;/a&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40dcdd5a240705c4bdfc3ba184015a22602dc143" translate="yes" xml:space="preserve">
          <source>An SQLite Archive can be queried using a high-level query language (SQL). Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b242257f9fcf2e3e2eac957dac8e90b190c245bb" translate="yes" xml:space="preserve">
          <source>An SQLite Archive can be updated incrementally. Individual files can be added or removed or replaced without having to rewrite the entire archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a576b713a86af9234a7a7f85c2bf0090d4320d5" translate="yes" xml:space="preserve">
          <source>An SQLite Archive can work around firewall-imposed censorship. For example, certain file types that are considered &quot;dangerous&quot; (examples: DLLs) will be &lt;a href=&quot;https://support.google.com/mail/answer/6590&quot;&gt;blocked by Gmail&lt;/a&gt; and probably many other email services and firewall, even if those files are wrapped inside a ZIP Archive or Tarball. But these firewall usually do not care about SQLite Archives and so content can be put inside an SQLite Archive to evade censorship.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4118c0f7a6f81cb74480ccc9fa50eb744542f589" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is an ordinary SQLite database file that contains the following table as part of its schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6cbe656d1d7ad99c40dcbbe2f8824b11660a4b" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is flexible. ZIP Archives and Tarballs are limited to storing only files. An SQLite Archive stores files plus whatever other tabular and/or relational data seems useful to the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b26644641a5c080b143bed71ae376b8f86f40091" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is one example of a more general idea that an SQLite database can behave as a container object holding lots of smaller data components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d177845e7556bf44c101aaef7f85cf75f9d1c63" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is transactional. Updates are atomic and durable, even if there are crashes or power losses in the middle of the update. Readers see a consistent and unchanging version of the content even is some other process is simultaneously updating the archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3312ff278a713e75002ecfaa844a5076353ef655" translate="yes" xml:space="preserve">
          <source>An SQLite Archive supports only the &lt;a href=&quot;https://zlib.net/&quot;&gt;Deflate&lt;/a&gt; compression method. Tarballs and ZIP Archive support a wider assortment of compression methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd49e13abc11c533a20ccc6b5f7798ff20c6616" translate="yes" xml:space="preserve">
          <source>An SQLite Database File</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b000f5fd9df31bd42422b2ef21f81528c08cea1a" translate="yes" xml:space="preserve">
          <source>An SQLite application file format is a great choice in cases where there is a collection or &quot;federation&quot; of separate programs, often written in different languages and by different development teams. This comes up commonly in research or laboratory environments where one team is responsible for data acquisition and other teams are responsible for various stages of analysis. Each team can use whatever hardware, operating system, programming language and development methodology that they are most comfortable with, and as long as all programs use an SQLite database with a common schema, they can all interoperate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcad71b941086fc8d3676a58f2f663381ad6019" translate="yes" xml:space="preserve">
          <source>An SQLite database can become corrupt if the file content changes due to a disk drive or flash memory failure. It is very rare, but disks will occasionally flip a bit in the middle of a sector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa981e15b39eb75edaa6ff0d13de7391ec0f911" translate="yes" xml:space="preserve">
          <source>An SQLite database connection defaults to &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=DELETE&lt;/a&gt;. To convert to WAL mode, use the following pragma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa9719008b383e9c69cd74a19a5c395ef612cf2" translate="yes" xml:space="preserve">
          <source>An SQLite database facilitates data transfer between systems even when the endpoints have different word sizes and/or byte orders. The data can be a complex mix of large binary blobs, text, and small numeric or boolean values. The data format can be easily extended by adding new tables and/or columns, without breaking legacy receivers. The SQL query language means that receivers are not required to parse the entire transfer all at once, but can instead query the received content as needed. The data format is &quot;transparent&quot; in the sense that it is easily decoded for human viewing using a variety of universally available, open-source tools, from multiple vendors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982d7ceede2aaf5d861f9c36536e7099da9073ca" translate="yes" xml:space="preserve">
          <source>An SQLite database file consists of one or more &quot;pages&quot;. For a single database file, all pages are the same size, though for different database files, the page size can any power of two between 512 and 65536, inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d2c158eb6a0a9552493d7c89540c3e0f9e893f" translate="yes" xml:space="preserve">
          <source>An SQLite database file is approximately the same size, and in some cases smaller, than a ZIP archive holding the same information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4396f52519eb130b5dd0375bda350b47a433fb" translate="yes" xml:space="preserve">
          <source>An SQLite database file is divided into pages. The first page is 1, the second page is 2, and so forth. There is no page 0. Every page is the same size. The size of every page is a power of 2 between 512 and 65536. See the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8b304d710aae6886e59c81e1a985cd1cd70645" translate="yes" xml:space="preserve">
          <source>An SQLite database file with a defined schema often makes an excellent application file format. Here are a dozen reasons why this is so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ebdfe9c0e4c8eb0d11614911caf8938817b53f" translate="yes" xml:space="preserve">
          <source>An SQLite database has a lot of capability, which this essay has only begun to touch upon. But hopefully this quick glimpse has convinced some readers that using an SQL database as an application file format is worth a second look.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69541d5b92ee6eb3e8f9d53bc6a238b7db778bec" translate="yes" xml:space="preserve">
          <source>An SQLite database is a &lt;a href=&quot;fileformat2&quot;&gt;well-defined and well-documented&lt;/a&gt; file format that is in widespread use by literally millions of applications and is backwards compatible to its inception in 2004 and which promises to continue to be compatible in decades to come. The longevity of SQLite database files is particularly important to bespoke applications, since it allows the document content to be accessed far in the future, long after all traces of the original application have been lost. Data lives longer than code. SQLite databases are &lt;a href=&quot;locrsf&quot;&gt;recommended by the US Library of Congress&lt;/a&gt; as a storage format for long-term preservation of digital content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1414bb1ca0b7308fabbbb0231f95883cdfb55f17" translate="yes" xml:space="preserve">
          <source>An SQLite database is a single ordinary disk file that can be located anywhere in the directory hierarchy. If SQLite can read the disk file then it can read anything in the database. If the disk file and its directory are writable, then SQLite can change anything in the database. Database files can easily be copied onto a USB memory stick or emailed for sharing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26fb41c051ef1c4cae3e65d019499aa1d3715a71" translate="yes" xml:space="preserve">
          <source>An SQLite database is highly resistant to corruption. If an application crash, or an operating-system crash, or even a power failure occurs in the middle of a transaction, the partially written transaction should be automatically rolled back the next time the database file is accessed. The recovery process is fully automatic and does not require any action on the part of the user or the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b90e2f3f651754fcb6451ab34aac384e7a5fbe" translate="yes" xml:space="preserve">
          <source>An SQLite database is limited in size to 140 terabytes (2&lt;sup&gt;&lt;small&gt;47&lt;/small&gt;&lt;/sup&gt; bytes, 128 tibibytes). And even if it could handle larger databases, SQLite stores the entire database in a single disk file and many filesystems limit the maximum size of files to something less than this. So if you are contemplating databases of this magnitude, you would do well to consider using a client/server database engine that spreads its content across multiple disk files, and perhaps across multiple volumes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efcb5c5b5fbf0d6f174a7bd1fdafd17d5d08348" translate="yes" xml:space="preserve">
          <source>An SQLite database is maintained on disk using a B-tree implementation found in the &lt;a href=&quot;https://sqlite.org/src/file/src/btree.c&quot;&gt;btree.c&lt;/a&gt; source file. A separate B-tree is used for each table and index in the database. All B-trees are stored in the same disk file. The &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; details are stable and well-defined and are guaranteed to be compatible moving forward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25bf5d553881678b34da8985ef757fc5ffe38cac" translate="yes" xml:space="preserve">
          <source>An SQLite database is normally stored in a single ordinary disk file. However, in certain circumstances, the database might be stored in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffcfbe0c6736b628bac17f2c3fd76a08f4a70298" translate="yes" xml:space="preserve">
          <source>An SQLite extension is a shared library or DLL. To load it, you need to supply SQLite with the name of the file containing the shared library or DLL and an entry point to initialize the extension. In C code, this information is supplied using the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; API. See the documentation on that routine for additional information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741d402ffb5729c1f12f8583e23c058762a2645f" translate="yes" xml:space="preserve">
          <source>An SQLite file associates a key with some data. For an SQLite table, the database file is set up so that the key is an integer and the data is the information for one row of the table. Indices in SQLite reverse this arrangement. The index key is (some of) the information being stored and the index data is an integer. To access a table row that has some particular content, we first look up the content in the index table to find its integer index, then we use that integer to look up the complete record in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa48e9ca1a9afbd598f5c369c282c95ae280985d" translate="yes" xml:space="preserve">
          <source>An UPDATE change does not contain any information regarding non-PRIMARY KEY fields that are not modified by the change. It is not possible for an UPDATE change to specify modifications to PRIMARY KEY fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8453636ce12faf3a7d30b3604973de7e92b03be" translate="yes" xml:space="preserve">
          <source>An UPDATE statement is used to modify a subset of the values stored in zero or more rows of the database table identified by the &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt; specified as part of the UPDATE statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f3409a0b0e68f9dad8c3ad576c7434229cfe7d" translate="yes" xml:space="preserve">
          <source>An UPSERT is an ordinary &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement that is followed by the special ON CONFLICT clause shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69182763d75d3decbdc8b998206e5e9e0abdd4fa" translate="yes" xml:space="preserve">
          <source>An administrator might be cleaning up after an OS crash or power failure, see the journal file, think it is junk, and delete it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3394246ad7fb8330c70e24b0e7ea728a29ef0f38" translate="yes" xml:space="preserve">
          <source>An advanced &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911df1dfdba68c60884217edf88c5ceef73757d1" translate="yes" xml:space="preserve">
          <source>An aggregate window function is similar to an &lt;a href=&quot;lang_aggfunc&quot;&gt;ordinary aggregate function&lt;/a&gt;, except adding it to a query does not change the number of rows returned. Instead, for each row the result of the aggregate window function is as if the corresponding aggregate were run over all rows in the &quot;window frame&quot; specified by the OVER clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322176e856e37076d444f90d3c6a55c34f3890cf" translate="yes" xml:space="preserve">
          <source>An alternate VFS can also be specified as the 4th parameter to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; function. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41672a8dda2c83a2c98fffccfd2de6f45dfd99a9" translate="yes" xml:space="preserve">
          <source>An alternative page cache implementation is specified using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;,...).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947c7106a30016236017e10a97e39cd6cd0c6560" translate="yes" xml:space="preserve">
          <source>An alternative page cache implementation is specified using &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;,...).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5b04203def7bb645f2fb1f011d7be6cb15aa11" translate="yes" xml:space="preserve">
          <source>An alternative to using the VACUUM command is auto-vacuum mode, enabled using the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7c395d93d8f14379a00c98e2d82d0ba28b9997" translate="yes" xml:space="preserve">
          <source>An alternative to using the VACUUM command to reclaim space after data has been deleted is auto-vacuum mode, enabled using the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; pragma. When &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; is enabled for a database free pages may be reclaimed after deleting data, causing the file to shrink, without rebuilding the entire database using VACUUM. However, using &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; can lead to extra database file fragmentation. And &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; does not compact partially filled pages of the database as VACUUM does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="553a75a5f14c49499d0ac2492bac151d7f6d24ab" translate="yes" xml:space="preserve">
          <source>An application can initiate a checkpoint using any writable database connection on the database simply by invoking &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; or &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;. There are three subtypes of checkpoints that vary in their aggressiveness: PASSIVE, FULL, and RESTART. The default checkpoint style is PASSIVE, which does as much work as it can without interfering with other database connections, and which might not run to completion if there are concurrent readers or writers. All checkpoints initiated by &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; and by the automatic checkpoint mechanism are PASSIVE. FULL and RESTART checkpoints try harder to run the checkpoint to completion and can only be initiated by a call to &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;. See the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for additional information on FULL and RESET checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67ba81a9225f9986e5d6153b64db41fca122a2b" translate="yes" xml:space="preserve">
          <source>An application can insert layers or &quot;overlays&quot; in between the SQLite core and the underlying memory allocator. For example, the &lt;a href=&quot;#oomtesting&quot;&gt;out-of-memory test logic&lt;/a&gt; for SQLite uses an overlay that can simulate memory allocation failures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c388b93196430467345107651fd79645679ae7e0" translate="yes" xml:space="preserve">
          <source>An application can register additional collating functions using the &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83af746376d0381ac294352b72f5044bc5a90aa4" translate="yes" xml:space="preserve">
          <source>An application is allowed to prepare multiple SQL statements in advance and evaluate them as needed. There is no arbitrary limit to the number of outstanding &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. Some applications call &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; multiple times at start-up to create all of the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; they will ever need. Other applications keep a cache of the most recently used &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; and then reuse &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; out of the cache when available. Another approach is to only reuse &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; when they are inside of a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f92c3ae91ceb152b4ca7b440a380181cc47f0d" translate="yes" xml:space="preserve">
          <source>An application will typically use &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; to create a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; during initialization. Note that &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; can be used to either open existing database files or to create and open new database files. While many applications use only a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, there is no reason why an application cannot call &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; multiple times in order to open multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; - either to the same database or to different databases. Sometimes a multi-threaded application will create separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; for each thread. Note that a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; can access two or more databases using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command, so it is not necessary to have a separate database connection for each database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad0ed6ebbb2c20729bbba2c61a375d2fc0e59a68" translate="yes" xml:space="preserve">
          <source>An application-defined function is permitted to call other SQLite interfaces. However, such calls must not close the database connection nor finalize or reset the prepared statement in which the function is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368a116479c83bd78621f71906b14ee39f5af37e" translate="yes" xml:space="preserve">
          <source>An arbitrary length BLOB</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f821dc4d7f9c71f0ab35cc4c36d94a5e6e1a02bc" translate="yes" xml:space="preserve">
          <source>An arbitrary length strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232575a5b7dcf96eebb74b1c36e1cd9952456a1f" translate="yes" xml:space="preserve">
          <source>An argument with SQL type TEXT it is normally converted into a quoted JSON string even if the input text is well-formed JSON. However, if the argument is the direct result from another json1 function, then it is treated as JSON and all of its JSON type information and substructure is preserved. This allows calls to json_object() and &lt;a href=&quot;json1#jarray&quot;&gt;json_array()&lt;/a&gt; to be nested. The &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; function can also be used to force strings to be recognized as JSON.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3098d8640bbb6ff43023d4a4dc7ae39f23e7f1" translate="yes" xml:space="preserve">
          <source>An argument with SQL type TEXT it is normally converted into a quoted JSON string. However, if the argument is the output from another json1 function, then it is stored as JSON. This allows calls to json_array() and &lt;a href=&quot;json1#jobj&quot;&gt;json_object()&lt;/a&gt; to be nested. The &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; function can also be used to force strings to be recognized as JSON.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4806a509e481529fa2b28682facfc05b551794d" translate="yes" xml:space="preserve">
          <source>An assert() statement is often used to validate pre-conditions on internal functions and methods. Example: &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=1048&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=1048&lt;/a&gt;. This is deemed better than simply stating the pre-condition in a header comment, since the assert() is actually executed. In a highly tested program like SQLite, the reader knows that the pre-condition is true for all of the hundreds of millions of test cases run against SQLite, since it has been verified by the assert(). In contrast, a text pre-condition statement in a header comment is untested. It might have been true when the code was written, but who is to say that it is still true now?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734aa331fcaf7e910bbd2120afae3cf5a122f2fd" translate="yes" xml:space="preserve">
          <source>An assertion fails if P2 is not an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d9c6c8e0b518f22e195d912f6aa5b7d1dd73a5" translate="yes" xml:space="preserve">
          <source>An atomic commit is supposed to happen instantaneously. But the processing described above clearly takes a finite amount of time. Suppose the power to the computer were cut part way through the commit operation described above. In order to maintain the illusion that the changes were instantaneous, we have to &quot;rollback&quot; any partial changes and restore the database to the state it was in prior to the beginning of the transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11c0c4803807d87c78fdeba64f0dde4ba44fbdd" translate="yes" xml:space="preserve">
          <source>An attempt is made to upgrade to an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="404254ba0f2702898e820a78567011f727d4bb51" translate="yes" xml:space="preserve">
          <source>An attempt to execute COMMIT might also result in an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; return code if an another thread or process has an open read connection. When COMMIT fails in this way, the transaction remains active and the COMMIT can be retried later after the reader has had a chance to clear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3979550223b90497821c0aba7295ef97c7b65e0d" translate="yes" xml:space="preserve">
          <source>An attempt to read from an expired &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d2f9e7d226af948b651170c9b5bffda6c6a847" translate="yes" xml:space="preserve">
          <source>An attempt to read from an expired &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c063fe576f329d251937e5f31d7607dcdb3d3ae3" translate="yes" xml:space="preserve">
          <source>An attempt to write to an expired &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Writes to the BLOB that occurred before the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; expired are not rolled back by the expiration of the handle, though of course those changes might have been overwritten by the statement that expired the BLOB handle or by other independent statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75bfad8795848d7c6435b7cbd7f5aec468cc1527" translate="yes" xml:space="preserve">
          <source>An attempt to write to an expired &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Writes to the BLOB that occurred before the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; expired are not rolled back by the expiration of the handle, though of course those changes might have been overwritten by the statement that expired the BLOB handle or by other independent statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad76d49804b0b58fd84332ca5a84e267894c91f" translate="yes" xml:space="preserve">
          <source>An authorizer is used when &lt;a href=&quot;#sqlite3_prepare&quot;&gt;preparing&lt;/a&gt; SQL statements from an untrusted source, to ensure that the SQL statements do not try to access data they are not allowed to see, or that they do not try to execute malicious statements that damage the database. For example, an application may allow a user to enter arbitrary SQL queries for evaluation by a database. But the application does not want the user to be able to make arbitrary changes to the database. An authorizer could then be put in place while the user-entered SQL is being &lt;a href=&quot;#sqlite3_prepare&quot;&gt;prepared&lt;/a&gt; that disallows everything except &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e075e878ae45a376fd2939c290edbd89e855bf" translate="yes" xml:space="preserve">
          <source>An authorizer is used when &lt;a href=&quot;prepare&quot;&gt;preparing&lt;/a&gt; SQL statements from an untrusted source, to ensure that the SQL statements do not try to access data they are not allowed to see, or that they do not try to execute malicious statements that damage the database. For example, an application may allow a user to enter arbitrary SQL queries for evaluation by a database. But the application does not want the user to be able to make arbitrary changes to the database. An authorizer could then be put in place while the user-entered SQL is being &lt;a href=&quot;prepare&quot;&gt;prepared&lt;/a&gt; that disallows everything except &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5a8d89ce83a2b735008709c97144e7c8447c49" translate="yes" xml:space="preserve">
          <source>An automatic index might also be used for a subquery:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a27a69d5289ec3895fe5350ae755b86c8341fcb" translate="yes" xml:space="preserve">
          <source>An encoded FTS varint consumes between one and ten bytes of space. The number of bytes required is determined by the sign and magnitude of the integer value encoded. More accurately, the number of bytes used to store the encoded integer depends on the position of the most significant set bit in the 64-bit twos-complement representation of the integer value. Negative values always have the most significant bit set (the sign bit), and so are always stored using the full ten bytes. Positive integer values may be stored using less space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23566adaf44732949e813db81dd7b604df6839d5" translate="yes" xml:space="preserve">
          <source>An ending frame boundary,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7f16750f7735a9bc64b3d85d026914564b32de" translate="yes" xml:space="preserve">
          <source>An error is now returned when trying to start a transaction if another transaction is already active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6742ab14c7e1b0f89ab6e50a3f4d9ccb4760cbd" translate="yes" xml:space="preserve">
          <source>An error logger callback is invoked on SQLITE_MISUSE errors. This is useful in detecting application design issues when return codes are not consistently checked in the application code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57ea0e26c7c063563f7c480ba3dfeaecea3cb15" translate="yes" xml:space="preserve">
          <source>An error. &quot;darkstar&quot; is not a recognized authority.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d782005fc023f48e522001d78e4867344c8d47" translate="yes" xml:space="preserve">
          <source>An error. &quot;readonly&quot; is not a valid option for the &quot;mode&quot; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1dc1f3ba0806333fcf879ed6122522e9f542e04" translate="yes" xml:space="preserve">
          <source>An example of an eponymous virtual table is the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. To use the dbstat virtual table as an eponymous virtual table, simply query against the &quot;dbstat&quot; module name, as if it were an ordinary table. (Note that SQLite must be compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option to include the dbstat virtual table in the build.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d551629b2a32e687e6920a81c2f515bee137ebdf" translate="yes" xml:space="preserve">
          <source>An example use of hidden columns can be seen in the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; virtual table implementation, where every FTS virtual table contains an &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; that is used to pass information from the virtual table into &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt; and to the &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e17bf1221a1fb0282388819bb91b8a5c6ed013a" translate="yes" xml:space="preserve">
          <source>An example will help to clarify this concept. Consider the following query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b97feb4054b223de8848c552e7e62e2eeabb327" translate="yes" xml:space="preserve">
          <source>An example: Suppose there are two database connections X and Y. X starts a read transaction using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; followed by one or more &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Then Y comes along and runs an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement to modify the database. X can subsequently do a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; against the records that Y modified but X will see the older unmodified entries because Y's changes are all invisible to X while X is holding a read transaction. If X wants to see the changes that Y made, then X must ends its read transaction and start a new one (by running &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; followed by another &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6e6d373bf06dd9c8c05c43eca6f2690b8f93a5" translate="yes" xml:space="preserve">
          <source>An exclusive lock is held on WAL_WRITE_LOCK while adding new frame onto the end of a WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472410dd7fa81690261e9f1011036ea0cbeb522e" translate="yes" xml:space="preserve">
          <source>An experimental module providing on-demand read-only access to multiple tables spread across multiple databases, via a single virtual table abstraction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667c5b4834a03d379059f491edab75c439a88d3e" translate="yes" xml:space="preserve">
          <source>An expression of the form &quot;CAST(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818ecb03985da596f3eae278c34f7853ab10690e" translate="yes" xml:space="preserve">
          <source>An external content FTS4 table is created by setting the content option to the name of a table (or view, or virtual table) that may be queried by FTS4 to retrieve column values when required. If the nominated table does not exist, then an external content table behaves in the same way as a contentless table. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af47edb4534251424ba986a5ead5c83306505ff" translate="yes" xml:space="preserve">
          <source>An external content FTS5 table is created by setting the content option to the name of a table, virtual table or view (hereafter the &quot;content table&quot;) within the same database. Whenever column values are required by FTS5, it queries the content table as follows, with the rowid of the row for which values are required bound to the SQL variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d52b102f266b0f6f1ccf383a15555d761fab3f49" translate="yes" xml:space="preserve">
          <source>An fts4aux virtual table is constructed with one or two arguments. When used with a single argument, that argument is the unqualified name of the FTS table that it will be used to access. To access a table in a different database (for example, to create a TEMP fts4aux table that will access an FTS3 table in the MAIN database) use the two-argument form and give the name of the target database (ex: &quot;main&quot;) in the first argument and the name of the FTS3/4 table as the second argument. (The two-argument form of fts4aux was added for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20) and will throw an error in prior releases.) For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c25046031c36326ccd0fd6dd82951cf50be0673" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;col&quot; contains one row for each distinct term/column combination in the associated FTS5 table. Table columns are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f04198cf656fcfcd60de51b84883a5a273fb8d3" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;instance&quot; contains one row for each term instance stored in the associated FTS index. Assuming the FTS5 table is created with the 'detail' option set to 'full', table columns are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f46cd06dd0edb512dbfe5bb420f25b92508728" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;row&quot; contains one row for each distinct term in the associated FTS5 table. The table columns are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e5d44e56062277710f5511afeab18594a8851fc" translate="yes" xml:space="preserve">
          <source>An implementation of the Guttmann R*Tree spatial index idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd28b3c3d3e6a39cb2320865c316342a20f3142" translate="yes" xml:space="preserve">
          <source>An implicit transaction (a transaction that is started automatically, not a transaction started by BEGIN) is committed automatically when the last active statement finishes. A statement finishes when its last cursor closes, which is guaranteed to happen when the prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;. Some statements might &quot;finish&quot; for the purpose of transaction control prior to being reset or finalized, but there is no guarantee of this. The only way to ensure that a statement has &quot;finished&quot; is to invoke &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; on that statement. An open &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; used for incremental BLOB I/O also counts as an unfinished statement. The &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; finishes when it is &lt;a href=&quot;c3ref/blob_close&quot;&gt;closed&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79074d6687b22dc4e17257f4e6cee62c251811c4" translate="yes" xml:space="preserve">
          <source>An important feature of transactional databases like SQLite is &quot;atomic commit&quot;. Atomic commit means that either all database changes within a single transaction occur or none of them occur. With atomic commit, it is as if many different writes to different sections of the database file occur instantaneously and simultaneously. Real hardware serializes writes to mass storage, and writing a single sector takes a finite amount of time. So it is impossible to truly write many different sectors of a database file simultaneously and/or instantaneously. But the atomic commit logic within SQLite makes it appear as if the changes for a transaction are all written instantaneously and simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52bb5c1058e3b07cc3eb83a0aae8a367e19c8fb8" translate="yes" xml:space="preserve">
          <source>An imposter table is a table that is attached to the same &lt;a href=&quot;fileformat2#btree&quot;&gt;b-tree&lt;/a&gt; as an index. An imposter table allows the content of an index to be queried or modified as if the index were an ordinary table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548d97f9737c13966b0384ddf7c4f5316897fe64" translate="yes" xml:space="preserve">
          <source>An index b-tree interior page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b00cd2ffa8d152bd911781465eeda8179c5b9f" translate="yes" xml:space="preserve">
          <source>An index b-tree leaf page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23b6e554c4c927f47667a50d9e483703c1ef47e" translate="yes" xml:space="preserve">
          <source>An index is another table similar to the original &quot;fruitsforsale&quot; table but with the content (the fruit column in this case) stored in front of the rowid and with all rows in content order. &lt;a href=&quot;#fig4&quot;&gt;Figure 4&lt;/a&gt; gives a logical view of the Idx1 index. The &quot;fruit&quot; column is the primary key used to order the elements of the table and the &quot;rowid&quot; is the secondary key used to break the tie when two or more rows have the same &quot;fruit&quot;. In the example, the rowid has to be used as a tie-breaker for the &quot;Orange&quot; rows. Notice that since the rowid is always unique over all elements of the original table, the composite key of &quot;fruit&quot; followed by &quot;rowid&quot; will be unique over all elements of the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3002819a06b87f2b28823dffe3c0b248534f6bf1" translate="yes" xml:space="preserve">
          <source>An instance of the snapshot object records the state of a &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; database for some specific point in history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc9cd2833d461982fd05cbb236027102f78db05" translate="yes" xml:space="preserve">
          <source>An instance of the snapshot object records the state of a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database for some specific point in history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad16796bc17d538460c93b836ae5c8477d8c7e2" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_str object contains a dynamically-sized string under construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f02269b16b7995873f0e98891ae8060c34bc231" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_vfs object defines the interface between the SQLite core and the underlying operating system. The &quot;vfs&quot; in the name of the object stands for &quot;virtual file system&quot;. See the &lt;a href=&quot;../vfs&quot;&gt;VFS documentation&lt;/a&gt; for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986d34aa72070b33f262aa39aa661f9a7021ae8a" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_vfs object defines the interface between the SQLite core and the underlying operating system. The &quot;vfs&quot; in the name of the object stands for &quot;virtual file system&quot;. See the &lt;a href=&quot;vfs&quot;&gt;VFS documentation&lt;/a&gt; for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45b93bef69dcf39c21d4d46704ba221d046f871" translate="yes" xml:space="preserve">
          <source>An instance of this object acts as a cursor for iterating over the elements of a &lt;a href=&quot;../sessionintro#changeset&quot;&gt;changeset&lt;/a&gt; or &lt;a href=&quot;../sessionintro#changeset&quot;&gt;patchset&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf71b1083943f3e5851ab7a42bcd920407783dbc" translate="yes" xml:space="preserve">
          <source>An instance of this object acts as a cursor for iterating over the elements of a &lt;a href=&quot;sessionintro#changeset&quot;&gt;changeset&lt;/a&gt; or &lt;a href=&quot;sessionintro#changeset&quot;&gt;patchset&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7e618ccd27967f90c1e650a28d3404240080d5" translate="yes" xml:space="preserve">
          <source>An instance of this object defines the interface between SQLite and low-level memory allocation routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b65debab7d2bc5f3be01481bf018b30e5f1a63" translate="yes" xml:space="preserve">
          <source>An instance of this object is a &lt;a href=&quot;../sessionintro&quot;&gt;session&lt;/a&gt; that can be used to record changes to a database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d288e209f1c35236167d79cd8408a6e6645c8dfe" translate="yes" xml:space="preserve">
          <source>An instance of this object is a &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; that can be used to record changes to a database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8cd868b7a8f02ee212f8081b22f84902c700f2" translate="yes" xml:space="preserve">
          <source>An instance of this object represents a single SQL statement that has been compiled into binary form and is ready to be evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac15740a5e0d955ec96459bba2b236546957815" translate="yes" xml:space="preserve">
          <source>An instance of this object represents an open BLOB on which &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; can be performed. Objects of this type are created by &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and destroyed by &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces can be used to read or write small subsections of the BLOB. The &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface returns the size of the BLOB in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e12c7941ae7ce9acfd3af6cea2f4a94a2e0d5a" translate="yes" xml:space="preserve">
          <source>An instance of this object represents an open BLOB on which &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; can be performed. Objects of this type are created by &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and destroyed by &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. The &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces can be used to read or write small subsections of the BLOB. The &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface returns the size of the BLOB in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c5d268a10fe06a59e3c7e963d5ed29fc68438c" translate="yes" xml:space="preserve">
          <source>An instance of this structure defines the low-level routines used to allocate and use mutexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b02932da3aaeca2f83c028e321d42447d0835b5" translate="yes" xml:space="preserve">
          <source>An integer indicating the index of the FTS table column to read the text from. Columns are numbered from left to right starting at zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23d5e6e7614ceb92ef3b6de48759bd54ba26b48" translate="yes" xml:space="preserve">
          <source>An integer indicating the index of the FTS table column to select the returned text from. Columns are numbered from left to right starting at zero. A negative value indicates that the column should be automatically selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c886c068ec97375a0540464685cf9e1ef166d731" translate="yes" xml:space="preserve">
          <source>An intensively used low-level library like SQLite needs to be fast. (And SQLite is fast, see &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt; for example.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b10fc85927484bbd1851b4c4f858fb308385eb" translate="yes" xml:space="preserve">
          <source>An iterator is deleted using a call to the &lt;a href=&quot;session/sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt; API. If an error occured while iterating, an SQLite error code is returned (even if the same error code has already been returned by sqlite3changeset_next()). Or, if no error has occurred, SQLITE_OK is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd92a7436e987265ed18e3cd262b66e57b47ffd2" translate="yes" xml:space="preserve">
          <source>An ongoing RBU operation (either an update or a vacuum) does not interfere with read access to the database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e9fb11f12f8a43c4c89d92d48bc4d12fa12b04" translate="yes" xml:space="preserve">
          <source>An operand of a comparison is considered to have an explicit collating function assignment (rule 1 above) if any subexpression of the operand uses the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;. Thus, if a &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; is used anywhere in a comparision expression, the collating function defined by that operator is used for string comparison regardless of what table columns might be a part of that expression. If two or more &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; subexpressions appear anywhere in a comparison, the left most explicit collating function is used regardless of how deeply the COLLATE operators are nested in the expression and regardless of how the expression is parenthesized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1841b8b7007b74c92e11286f08f070e4631c39a7" translate="yes" xml:space="preserve">
          <source>An ordinary common table expression works as if it were a &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt; that exists for the duration of a single statement. Ordinary common table expressions are useful for factoring out subqueries and making the overall SQL statement easier to read and understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64f3df3f6dbd2c4ab332d741a98dc5f74fa4c01" translate="yes" xml:space="preserve">
          <source>An ordinary filename can usually be converted into an equivalent URI by the steps shown below. The one exception is that a relative windows pathname with a drive letter cannot be converted directly into a URI; it must be changed into an absolute pathname first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f1c5c7c31ea92a8b28f97d519413325cc7abf4" translate="yes" xml:space="preserve">
          <source>An overlay can be created by using the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace2a17ee0ffadfade85b391c6417dbd59dcd570" translate="yes" xml:space="preserve">
          <source>An rtree_i32 stores coordinates as 32-bit signed integers. But it still using floating point computations internally as part of the r-tree algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07cb8663d689220c5b11e75bcc91e43df5ab2f40" translate="yes" xml:space="preserve">
          <source>An sqlite3_changegroup object is used to combine two or more changesets (or patchsets) into a single changeset (or patchset). A single changegroup object may combine changesets or patchsets, but not both. The output is always in the same format as the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf5ebeb61b12b4ca95cabbbacfd2a52d1e22645" translate="yes" xml:space="preserve">
          <source>An sqlite3_rebaser object is created by calling sqlite3rebaser_create().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af9897fcfc348b6ea18f42888797de74b915c33" translate="yes" xml:space="preserve">
          <source>An sqlite3_value object may be either &quot;protected&quot; or &quot;unprotected&quot;. Some interfaces require a protected sqlite3_value. Other interfaces will accept either a protected or an unprotected sqlite3_value. Every interface that accepts sqlite3_value arguments specifies whether or not it requires a protected sqlite3_value. The &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt; interface can be used to construct a new protected sqlite3_value from an unprotected sqlite3_value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf10bfa8716c343b3bd7ed7af7b661d4bbe7281" translate="yes" xml:space="preserve">
          <source>An sqlite3_value object may be either &quot;protected&quot; or &quot;unprotected&quot;. Some interfaces require a protected sqlite3_value. Other interfaces will accept either a protected or an unprotected sqlite3_value. Every interface that accepts sqlite3_value arguments specifies whether or not it requires a protected sqlite3_value. The &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt; interface can be used to construct a new protected sqlite3_value from an unprotected sqlite3_value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e4dafbd07992ae7ef4dffddcd1b4a5c5cb76207" translate="yes" xml:space="preserve">
          <source>An unconditional jump to address P2. The next instruction executed will be the one at index P2 from the beginning of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec2f338946c19a5c8db3e1991942cfffb1ac767" translate="yes" xml:space="preserve">
          <source>An unrelated (and minor) bug from Mark Muranwski fixed. The algorithm for figuring out where to put temporary files for a &quot;memory:&quot; database was not working quite right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="24a1091048c98405fcc66da02f4798476c96d7b9" translate="yes" xml:space="preserve">
          <source>And So Forth...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d62766f3bc1a62b7bc2195312ea71e091c76d3c" translate="yes" xml:space="preserve">
          <source>And if there is an entry in that table where the key column exactly matches the name of parameter (including the initial &quot;?&quot;, &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; character) then the parameter is assigned the value of the value column. If no entry exists, the parameter defaults to NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1613947ae46cd2f84a12cf24acc0820e1f9d0a46" translate="yes" xml:space="preserve">
          <source>And it is not really about just finding the descendents of a check-in from time to time. The fact that descendents are readily available in Fossil means that the information pervades the web pages provided by Fossil. One example: Every Fossil check-in information page (&lt;a href=&quot;https://www.sqlite.org/src/info/ec7addc87f97bcff&quot;&gt;example&lt;/a&gt;) shows a small &quot;Context&quot; graph of the immediate predecessor and successors to that check-in. This helps the user maintain better situational awareness, and it provides useful capabilities, such as the ability click forward to the next check-in in sequence. Another example: Fossil easily shows the context around a specific check-in (&lt;a href=&quot;https://www.sqlite.org/src/timeline?c=2018-03-16&amp;amp;n=10&quot;&gt;example&lt;/a&gt;) which again helps to promote situational awareness and a deeper understanding of what is happening in the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2283cc542d600a5581e49e759263651d3636f77" translate="yes" xml:space="preserve">
          <source>And let the query be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f762e3b5086b03457eac0a8ca5ae39d999e5440" translate="yes" xml:space="preserve">
          <source>And many, many bug fixes...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f247637664b32ff61f9705cffde6b438321ac676" translate="yes" xml:space="preserve">
          <source>And populated as if the target table were an ordinary SQLite table with no explicit PRIMARY KEY columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9380c403c5923e40740011085ed6c0ba26458c2" translate="yes" xml:space="preserve">
          <source>And so forth. Basically any sequence of names optionally followed by one or two signed integers in parentheses will do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0959960067ae4919fa2e1ea2e691b5f145968c7" translate="yes" xml:space="preserve">
          <source>And so forth. For ZIP archives and SQLite Archives, simply change the &quot;/tarball/&quot; element into either &quot;/zip/&quot; or &quot;/sqlar/&quot;, and maybe also change the name of the download file to have a &quot;.zip&quot; or &quot;.sqlar&quot; suffix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8077732ad2502900dddf709f29aa73b1a0f6b4" translate="yes" xml:space="preserve">
          <source>And so forth. There are 8 nodes in the TPC-H Q8 query, so this process repeats a total of 8 times. In the general case of a K-way join, the storage requirement is O(N) and the computation time is O(K*N), which is significantly faster than the O(2&lt;small&gt;&lt;sup&gt;K&lt;/sup&gt;&lt;/small&gt;) exact solution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060f19a1ad677f74cc92295a75b3f1b018b239ae" translate="yes" xml:space="preserve">
          <source>And so forth....</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5207dcf07042e825e2caf9ab6e9995854377e2d5" translate="yes" xml:space="preserve">
          <source>And the generated code looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e512a9542a2e3dfd52435fac1d439e588ebcee9" translate="yes" xml:space="preserve">
          <source>And then you run the query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ffeb8471359e0755ff7942bbfbee2106c5c7ff7" translate="yes" xml:space="preserve">
          <source>And, many more minor bug fixes and performance enhancements....</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e85233665c7566a60532bc230bb5ff92b64c2f" translate="yes" xml:space="preserve">
          <source>Anomaly tests are tests designed to verify the correct behavior of SQLite when something goes wrong. It is (relatively) easy to build an SQL database engine that behaves correctly on well-formed inputs on a fully functional computer. It is more difficult to build a system that responds sanely to invalid inputs and continues to function following system malfunctions. The anomaly tests are designed to verify the latter behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7ee88b419e1339ccb20dd6c8b4d7e9833eca0b" translate="yes" xml:space="preserve">
          <source>Another (safer) approach to creating an imposter table is to add an entry for the imposter table to SQLite's internal symbol table without updating the &quot;sqlite_master&quot; table on disk. That way, the imposter table exists in only a single database connection and is automatically removed whenever the schema is reloaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a256db65f829282a102ced1041e5c60bd3b39bb" translate="yes" xml:space="preserve">
          <source>Another approach is to initially disable the lookaside memory allocator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9265574f7b534649a1277b85f4934a02129bee" translate="yes" xml:space="preserve">
          <source>Another example is a virtual table that implements a full-text index. The xCreate method must create and initialize data structures to hold the dictionary and posting lists for that index. The xConnect method, on the other hand, only has to locate and use an existing dictionary and posting lists that were created by a prior xCreate call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303e110b30c7b4642bb575628bce75a8b23bc25d" translate="yes" xml:space="preserve">
          <source>Another example of corruption caused by using a closed file descriptor was &lt;a href=&quot;https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/&quot;&gt;reported by facebook engineers&lt;/a&gt; in a blog post on 2014-08-12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505afcae9498bd12848d3ae36d382e63fe35606f" translate="yes" xml:space="preserve">
          <source>Another example of this error was reported against &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; on 2019-07-11. A file descriptor would be opened for debugging output, but then closed and reopened by SQLite. But the debugging logic continued to write into the original file descriptor. See the &lt;a href=&quot;https://fossil-scm.org/forum/forumpost/c51b9a1169&quot;&gt;forum discussion&lt;/a&gt; for the bug report and a link to the fix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8183751698c287cb27407f9ba084d293db7c55bd" translate="yes" xml:space="preserve">
          <source>Another example: X starts a read transaction using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; and &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, then Y makes a changes to the database using &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Then X tries to make a change to the database using &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. The attempt by X to escalate its transaction from a read transaction to a write transaction fails with an &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; error because the snapshot of the database being viewed by X is no longer the latest version of the database. If X were allowed to write, it would fork the history of the database file, which is something SQLite does not support. In order for X to write to the database, it must first release its snapshot (using &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; for example) then start a new transaction with a subsequent &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1c30e5a209f39b6a21d890471cf09df8606ebc" translate="yes" xml:space="preserve">
          <source>Another flush must occur to make sure that all the database changes are written into nonvolatile storage. This is a critical step to ensure that the database will survive a power loss without damage. However, because of the inherent slowness of writing to disk or flash memory, this step together with the rollback journal file flush in section 3.7 above takes up most of the time required to complete a transaction commit in SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c301063883293bdf468d0623b6a6911c6d2293c" translate="yes" xml:space="preserve">
          <source>Another limitation of the histogram data is that it only applies to the left-most column on an index. Consider this scenario:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21c319ab2ff434679be56b445eba4fa1aa43f87" translate="yes" xml:space="preserve">
          <source>Another macro used in conjunction with test coverage measurement is the &lt;code&gt;testcase()&lt;/code&gt; macro. The argument is a condition for which we want test cases that evaluate to both true and false. In non-coverage builds (that is to say, in release builds) the &lt;code&gt;testcase()&lt;/code&gt; macro is a no-op:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c493a994000d99e73cbc3f60d51dfc6589078021" translate="yes" xml:space="preserve">
          <source>Another manifestation of this problem is &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;database corruption caused by inconsistent use of 8+3 filenames&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b9d783d5cb2f59bb8b6ca5914b9575e677009e" translate="yes" xml:space="preserve">
          <source>Another optimization introduced in SQLite version 3.5.0 makes use of &quot;safe append&quot; behavior of the underlying disk. Recall that SQLite assumes that when data is appended to a file (specifically to the rollback journal) that the size of the file is increased first and that the content is written second. So if power is lost after the file size is increased but before the content is written, the file is left containing invalid &quot;garbage&quot; data. The xDeviceCharacteristics method of the VFS might, however, indicate that the filesystem implements &quot;safe append&quot; semantics. This means that the content is written before the file size is increased so that it is impossible for garbage to be introduced into the rollback journal by a power loss or system crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dad2e6d1e9648b82626f473ea27ecce5bb27928" translate="yes" xml:space="preserve">
          <source>Another option is to run &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt;. This command will cause SQLite to not wait on data to reach the disk surface, which will make write operations appear to be much faster. But if you lose power in the middle of a transaction, your database file might go corrupt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0728346ee0767219b30d3313656a41918770666a" translate="yes" xml:space="preserve">
          <source>Another useful output mode is &quot;insert&quot;. In insert mode, the output is formatted to look like SQL INSERT statements. Use insert mode to generate text that can later be used to input data into a different database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603f11343da9306fc8345afa2052a80114bf6240" translate="yes" xml:space="preserve">
          <source>Another view of RELEASE is that it merges a named transaction into its parent transaction, so that the named transaction and its parent become the same transaction. After RELEASE, the named transaction and its parent will commit or rollback together, whatever their fate may be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c0bf8ab4584514edb8368d18ba85e753fa2a2d" translate="yes" xml:space="preserve">
          <source>Another way to get the row change counts is to use the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; or &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces. There is a subtle different, though. When an INSERT, UPDATE, or DELETE is run against a view using an &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF trigger&lt;/a&gt;, the count_changes pragma reports the number of rows in the view that fired the trigger, whereas &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; do not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d30986ae4eff5648d38ebb9d01b585109e2411f" translate="yes" xml:space="preserve">
          <source>Another way to think about the difference between rollback and write-ahead log is that in the rollback-journal approach, there are two primitive operations, reading and writing, whereas with a write-ahead log there are now three primitive operations: reading, writing, and checkpointing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c08af7521af2a346bb889060bcedbdd23dc992" translate="yes" xml:space="preserve">
          <source>Anticipated Future Enhancements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03cbea0705f9805750be00c459dd237de0396772" translate="yes" xml:space="preserve">
          <source>Any UTF-8 character or ISO8859 character can be used as part of an identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ff5b973797aa52493296af8db3d0915fb38ed0" translate="yes" xml:space="preserve">
          <source>Any application can run an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; query to get output similar to the above. However, indentation to show the loop structure is not generated by the SQLite core. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; contains extra logic for indenting loops. Also, the &quot;comment&quot; column in the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output is only provided if SQLite is compiled with the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8e347554cfc99745cad972098b020b8602be14" translate="yes" xml:space="preserve">
          <source>Any application state that can be recorded in a pile-of-files can also be recorded in an SQLite database with a simple key/value schema like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ed6ff66cc7fc9ffd4cafbde2a3c28f229641fd" translate="yes" xml:space="preserve">
          <source>Any arguments following &quot;unicode61&quot; in the token specification are treated as a list of alternating option names and values. Unicode61 supports the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81df847e2da7c111d58995774268025f599b0ab5" translate="yes" xml:space="preserve">
          <source>Any column in an SQLite version 3 database, except an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, may be used to store a value of any storage class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12d25e97784fac279be1123d4fbe17792ad0403" translate="yes" xml:space="preserve">
          <source>Any custom collation sequences used by indexes within the database being vacuumed are registered with both of the database handles returned by the sqlite3rbu_db() function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151750db2f16a0f1a6b9b810158ada7a043bfbe4" translate="yes" xml:space="preserve">
          <source>Any database clients wishing to write to the database file while a backup is being created must wait until the shared lock is relinquished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3870d6d9202c275acd1d8b0e06d905fc8afb745c" translate="yes" xml:space="preserve">
          <source>Any database name qualifier that occurs prior to the name of the object being created is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4255994cd14e9b872cd99b88c74cbf406ff9482f" translate="yes" xml:space="preserve">
          <source>Any index that includes the WHERE clause at the end is considered to be a partial index. Indexes that omit the WHERE clause (or indexes that are created by UNIQUE or PRIMARY KEY constraints inside of CREATE TABLE statements) are ordinary full indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43d049b602d1fd2bf9a7b5bea3350eedf1f0673" translate="yes" xml:space="preserve">
          <source>Any number of calls to add() and output() may be made between the calls to new() and delete(), and in any order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc7645ee06bfe979513e08246b74910b770d144" translate="yes" xml:space="preserve">
          <source>Any of the row values in the previous example could be replace by a subquery that returns three columns and the same answer would result. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ffe3efbd83a6aa86da6ab4b6abaf0209d6a58e2" translate="yes" xml:space="preserve">
          <source>Any one of the above test cases would provide 100% statement coverage but all three are required for 100% branch coverage. Generally speaking, 100% branch coverage implies 100% statement coverage, but the converse is not true. To reemphasize, the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test harness for SQLite provides the stronger form of test coverage - 100% branch test coverage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82138b97f6d9555464cfec51a14a23b82edbc037" translate="yes" xml:space="preserve">
          <source>Any operators applied to column names, including the no-op unary &quot;+&quot; operator, convert the column name into an expression which always has no affinity. Hence even if X and Y.Z are column names, the expressions +X and +Y.Z are not column names and have no affinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd223421c2a13bbb89b12c2862d7c77ef4b363f" translate="yes" xml:space="preserve">
          <source>Any other value for the b-tree page type is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784db6f9216a4d895c7e958df2f8f40ae24919c7" translate="yes" xml:space="preserve">
          <source>Any scalar expression may be used in the LIMIT clause, so long as it evaluates to an integer or a value that can be losslessly converted to an integer. If the expression evaluates to a NULL value or any other value that cannot be losslessly converted to an integer, an error is returned. If the LIMIT expression evaluates to a negative value, then there is no upper bound on the number of rows returned. Otherwise, the SELECT returns the first N rows of its result set only, where N is the value that the LIMIT expression evaluates to. Or, if the SELECT statement would return less than N rows without a LIMIT clause, then the entire result set is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680384b496ab63e99e152271be6ec34547a5e90a" translate="yes" xml:space="preserve">
          <source>Any time there is an error either compiling an SQL statement (using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its siblings) or running an SQL statement (using &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;) that error is logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e18824fe4a70b0f37b9e0cb34aa95b757ca28e" translate="yes" xml:space="preserve">
          <source>Any valid query will work against an R*Tree index. But the R*Tree implementation is designed to make two kinds of queries especially efficient. First, queries against the primary key are efficient:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafef79386ae39cfa702a14aae7666f057897932" translate="yes" xml:space="preserve">
          <source>Any value returned by the openclose function is ignored. If an invocation made before opening a database returns an error, then the database file is not opened and the error returned to the user. This is the only scenario in which swarmvtab will issue an &quot;open&quot; invocation without also eventually issuing a corresponding &quot;close&quot; call. If there are still databases open, &quot;close&quot; calls may be issued from within the eventual sqlite3_close() call on the applications database that deletes the temp schema in which the swarmvtab table resides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdf9bbefc76982e17471539cdea1217f5e1e0119" translate="yes" xml:space="preserve">
          <source>Anywhere</source>
          <target state="translated">Anywhere</target>
        </trans-unit>
        <trans-unit id="e511dd65bb11704e83c08777789bf5ec195f3d28" translate="yes" xml:space="preserve">
          <source>Apart from the root node, the nodes that make up a single segment b-tree are always stored using a contiguous sequence of blockids. Furthermore, the nodes that make up a single level of the b-tree are themselves stored as a contiguous block, in b-tree order. The contiguous sequence of blockids used to store the b-tree leaves are allocated starting with the blockid value stored in the &quot;start_block&quot; column of the corresponding %_segdir row, and finishing at the blockid value stored in the &quot;leaves_end_block&quot; field of the same row. It is therefore possible to iterate through all the leaves of a segment b-tree, in key order, by traversing the %_segments table in blockid order from &quot;start_block&quot; to &quot;leaves_end_block&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f3127b3255a243139304b57a2de9b375a5b278" translate="yes" xml:space="preserve">
          <source>Appears in...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cddd694c6980e8f63fe16956f1fed6f2e36dd876" translate="yes" xml:space="preserve">
          <source>Appending a new</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="939a673334c7c748561f23a3fd21e4918a1efbc3" translate="yes" xml:space="preserve">
          <source>Appending a new page to the database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dff26bc78571c36fbf9a79d63221a8d63c4781c9" translate="yes" xml:space="preserve">
          <source>Appendix A: Comparison with FTS3/4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f62ea77455407c6d86c7651d5f030af0222ec84" translate="yes" xml:space="preserve">
          <source>Appendix A: Search Application Tips</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f1d1188ea485eedb2325535cccc6c2b70da6fd" translate="yes" xml:space="preserve">
          <source>Appendix B: Shadow tables created by FTS5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24139aab1ccfea9a0794fea103821cef5044dd2c" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c42705eec7c415a6997bd8c9d3dc65da77e4f55" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557031cad0f1b2b54264afc9d96a7aba19827147" translate="yes" xml:space="preserve">
          <source>Application ID</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871e1857983850d1454dd7c60ae50af733931a7a" translate="yes" xml:space="preserve">
          <source>Application Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c10e408404322943e578d89c2bff7889c626f3" translate="yes" xml:space="preserve">
          <source>Application Porting Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a768f98624703793f6acc4a427b7a53a61477bff" translate="yes" xml:space="preserve">
          <source>Application can invoke the &lt;a href=&quot;#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3350dbe5c54d126511b6c09afcd8f51bea6a199c" translate="yes" xml:space="preserve">
          <source>Application can invoke the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4e99a2282eb2e1c855827ddf5f64dd418ab8c7" translate="yes" xml:space="preserve">
          <source>Application code is allowed to modify the sqlite_sequence table, to add new rows, to delete rows, or to modify existing rows. However, application code cannot create the sqlite_sequence table if it does not already exist. Application code can delete all entries from the sqlite_sequence table, but application code cannot drop the sqlite_sequence table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263c551ee583a68f5c9b570a6b7af2da5afc58f1" translate="yes" xml:space="preserve">
          <source>Application-defined collating functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d0ad5ca7051d2b57b94a5f5601d3d125282b43" translate="yes" xml:space="preserve">
          <source>Applications are not required to use either of these standard memory allocators. If SQLite is compiled with &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; then no implementation for the &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; functions is provided. Instead, the application that links against SQLite must provide its own implementation of these functions. The application provided memory allocator is not required to use the malloc()/free() implementation in the standard C library. An embedded application might provide an alternative memory allocator that uses memory for a fixed memory pool set aside for the exclusive use of SQLite, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38446a7215f8f42cf45502d1b63067076b840788" translate="yes" xml:space="preserve">
          <source>Applications are strongly discouraged from using this global variable. It is required to set a temporary folder on Windows Runtime (WinRT). But for all other platforms, it is highly recommended that applications neither read nor write this variable. This global variable is a relic that exists for backwards compatibility of legacy applications and should be avoided in new projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180a26d65b478f96354579f1533f98cb44ab9c69" translate="yes" xml:space="preserve">
          <source>Applications can activate foreign key enforcement at run-time using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; statement. Or, foreign key enforcement can be activated at compile-time using the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS=1&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa39f6b2c61405c17ac04b8c804d6f91045049fb" translate="yes" xml:space="preserve">
          <source>Applications can call sqlite3_vfs_register() at any time, though of course a VFS needs to be registered before it can be used. The first argument is a pointer to a customized VFS object that the application has prepared. The second argument is true to make the new VFS the default VFS so that it will be used by the legacy &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; APIs. If the new VFS is not the default, then you will probably have to use the new &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; API to use it. Note, however, that if a new VFS is the only VFS known to SQLite (if SQLite was compiled without its usual default VFS or if the precompiled default VFS was removed using &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt;) then the new VFS automatically becomes the default VFS regardless of the makeDflt argument to &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2aaaa457f07aa308713a42a915ad2852c0b39a0" translate="yes" xml:space="preserve">
          <source>Applications can chose to store dates and times in any of these formats and freely convert between formats using the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec145e5678c1f6c0fcbe32fd22a6afa6e15334a5" translate="yes" xml:space="preserve">
          <source>Applications can easily read or write SQLite Archives by linking against SQLite and including the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;ext/misc/sqlar.c&lt;/a&gt; extension to handle the compression and decompression. The sqlar.c extension creates two new SQL functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c37b1dc4c015883a2357b3c09de919e0c79e2e" translate="yes" xml:space="preserve">
          <source>Applications can leverage the &lt;a href=&quot;fts3&quot;&gt;full-text search&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; indexes and use triggers to implement an &lt;a href=&quot;undoredo&quot;&gt;automated undo/redo stack&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c37342832f86fc16406f3d6f977afed5099fdf" translate="yes" xml:space="preserve">
          <source>Applications can use the &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log(E,F,..)&lt;/a&gt; API to send new messages to the log, if desired, but this is discouraged. The &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; interface is intended for use by extensions only, not by applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b11300864c54770f7c5f526b6116f644fe6e616" translate="yes" xml:space="preserve">
          <source>Applications need to receive a pointer to the &quot;fts5_api&quot; object in order to add extensions, such as custom tokenizers, to the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62d5c6028bfae4c8b01799ff1a016b8e43ca22c" translate="yes" xml:space="preserve">
          <source>Applications should &lt;a href=&quot;#sqlite3_finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If sqlite3_close_v2() is called on a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that still has outstanding &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects then it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; and the deallocation of resources is deferred until all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects are also destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370f3cced4e036aaca81af4fa9e5c1fe46910ebe" translate="yes" xml:space="preserve">
          <source>Applications should &lt;a href=&quot;finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If sqlite3_close_v2() is called on a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that still has outstanding &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and/or &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects then it returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; and the deallocation of resources is deferred until all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects are also destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11da7d835aa708827d0f44dfb12fe45f22493e9a" translate="yes" xml:space="preserve">
          <source>Applications that accept untrusted SQL inputs should take the following precautions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32733159fe9563d84f7da23f8a179d0a799e2a5" translate="yes" xml:space="preserve">
          <source>Applications that accept untrusted database files should do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e886a51fcb81bff62e2c48396e856865668d639c" translate="yes" xml:space="preserve">
          <source>Applications that already use SQLite for other purposes can easily add support for SQLite Archives using a small extension (&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;https://sqlite.org/src/file/ext/misc/sqlar.c&lt;/a&gt;) to handle the compression and decompression of content. Even this tiny extension can be omitted if the files in the archive are uncompressed. In contrast, supporting ZIP Archives and/or Tarballs requires either separate libraries or lots of extra custom code, or sometimes both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77baa4279beeeafb725407d72ddb6fda70fe7b8a" translate="yes" xml:space="preserve">
          <source>Applications that desire more control can run &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize(0x03)&lt;/a&gt; to obtain a list of ANALYZE commands that SQLite thinks are appropriate to run, but without actually running those commands. If the returned set is non-empty, the application can then make a decision about whether or not to run the suggested ANALYZE commands, perhaps after prompting the user for guidance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bb5bae5e54c915160fb76cb9810521459a0328b" translate="yes" xml:space="preserve">
          <source>Applications that implement their own memory allocator must provide implementation for the usual three allocation functions &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;. And they must also implement a fourth function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3276d7f69778b6a6958211df873305e75fc12066" translate="yes" xml:space="preserve">
          <source>Applications that need to process SQL from untrusted sources might also consider lowering resource limits using &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and limiting database size using the &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; in addition to using an authorizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354d6571e51ed32448c014f215aad54793f93f19" translate="yes" xml:space="preserve">
          <source>Applications that need to process SQL from untrusted sources might also consider lowering resource limits using &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and limiting database size using the &lt;a href=&quot;../pragma#pragma_max_page_count&quot;&gt;max_page_count&lt;/a&gt;&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; in addition to using an authorizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56219a273baff8fb63d4f640239c5a3823587f98" translate="yes" xml:space="preserve">
          <source>Applications using the split amalgamation simply compile against &quot;sqlite3-all.c&quot; instead of &quot;sqlite3.c&quot;. The two files work exactly the same. But with &quot;sqlite3-all.c&quot;, no single source file contains more than 32,767 lines of code, and so it is more convenient to use some debuggers. The downside of the split amalgamation is that it consists of 6 C source code files instead of just 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514f9d7fb93d92d6765510a1359338148e757312" translate="yes" xml:space="preserve">
          <source>Apply A Changeset To A Database</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f306fb05632f0f4db7dd5e5ff03c213825dd25d" translate="yes" xml:space="preserve">
          <source>Apply a changeset or patchset to a database. These functions attempt to update the &quot;main&quot; database attached to handle db with the changes found in the changeset passed via the second and third arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7bf4a5600a606d3a4f075dab8912ba1aa9d1deb" translate="yes" xml:space="preserve">
          <source>Apply affinities to a range of P2 registers starting with P1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9053b57f5f861486073c17aece29454b87cf37a" translate="yes" xml:space="preserve">
          <source>Applying a changeset to a database is simpler than capturing a changeset. Usually, a single call to &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, as depicted in the example code below, suffices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d64c94c92e46add367d8f8d91e1e8dd6a71ae2e" translate="yes" xml:space="preserve">
          <source>Appropriate Uses For SQLite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db317caf72bb7c9dbfdfdc313cade8bdb182e98" translate="yes" xml:space="preserve">
          <source>Approx. Date</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a877b9c97333a0f773b586cf9b6ea0abe4710d" translate="yes" xml:space="preserve">
          <source>Approximately 25% better performance from the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1acd094f8de42870eb88cfeea3ebc197767f3b95" translate="yes" xml:space="preserve">
          <source>Architecture of SQLite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f076fb02f05c0b3b0347a8ec181af332464b574d" translate="yes" xml:space="preserve">
          <source>Are there any known size limits to SQLite databases?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="c4d2bb6ff9ec16533c1c379a0a3c41d194bcc183" translate="yes" xml:space="preserve">
          <source>Argument T is the name of the database file to vacuum. Argument S is the name of a database in which the RBU module will save its state if the vacuum operation is suspended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0059fb3429a6e57de6b5c01cc5ac92570ab99c32" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12689143ab00ad889ba38fb7f63c86273b0da663" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1502f4d9bcf958ec2d3f9df8d5434c6f3fb95622" translate="yes" xml:space="preserve">
          <source>Argument pIn must point to a buffer containing a changeset nIn bytes in size. This function allocates and populates a buffer with a copy of the changeset rebased rebased according to the configuration of the rebaser object passed as the first argument. If successful, (*ppOut) is set to point to the new buffer containing the rebased changeset and (*pnOut) to its size in bytes and SQLITE_OK returned. It is the responsibility of the caller to eventually free the new buffer using sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut) are set to zero and an SQLite error code returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3273cfe93e49705347b0b90c1dbaf9e32a834424" translate="yes" xml:space="preserve">
          <source>Argument zFromDb must be the name of a database (&quot;main&quot;, &quot;temp&quot; etc.) attached to the same database handle as the session object that contains a table compatible with the table attached to the session by this function. A table is considered compatible if it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2dd08aa3192624f9fd5e4d0f584709c36b430c5" translate="yes" xml:space="preserve">
          <source>Arguments on the virtual table name are matched to &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; in order. The number of arguments can be less than the number of hidden columns, in which case the latter hidden columns are unconstrained. However, an error results if there are more arguments than there are hidden columns in the virtual table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90539d8182e17636548ae12105ee212ec9b16743" translate="yes" xml:space="preserve">
          <source>As SQLite developers edit the SQLite source code, they run the &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script to track the performance impact of changes. This script compiles the speedtest1.c program, runs it under cachegrind, processes the cachegrind output using the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; TCL script, then saves the results in a series of text files. Typical output from the speed-check.sh script looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ed7acd0a6e6b88f39315ac5d476eef951a2dd64" translate="yes" xml:space="preserve">
          <source>As a REAL value that is the fractional &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71c00fe61fb07ca9e09493bb8ec226ec4260341" translate="yes" xml:space="preserve">
          <source>As a TEXT string in the ISO-8610 format. Example: '2018-04-02 12:13:46'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5eb53c0fa9975ea0940d4a4405ff35765d1d45" translate="yes" xml:space="preserve">
          <source>As a performance optimization, reduce actions in the Lemon input grammar are allowed to contain comments of the form &quot;/*A-overwrites-Z*/&quot; to indicate that the semantic value &quot;A&quot; on the right-hand side of the rule is allowed to directly overwrite the semantic value &quot;Z&quot; on the left-hand side. This simple optimization reduces the number of stack operations in the push-down automaton used to parse the input grammar, and thus improve performance of the parser. It also makes the generated code a little smaller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bcc1829db91ffdb7536f92aca2feacdc8bcb274" translate="yes" xml:space="preserve">
          <source>As an FTS5 bareword that is not &quot;AND&quot;, &quot;OR&quot; or &quot;NOT&quot; (case sensitive). An FTS5 bareword is a string of one or more consecutive characters that are all either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6cab6c41155dd3c9ab5be0d8403065e3d7dbaf" translate="yes" xml:space="preserve">
          <source>As an INTEGER number of seconds since 1970 (also known as &quot;unix time&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bbd071581bca01328b9dfe1b573f6b34f404d8" translate="yes" xml:space="preserve">
          <source>As an alternative to step 3 above, the transaction may be rolled back. Transaction rollback is described in section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131746c3b1aff392f599c85628677c24f8811860" translate="yes" xml:space="preserve">
          <source>As an example of the result table format, suppose a query result is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592d95d98cfd4f715eed1be5091215e09168934a" translate="yes" xml:space="preserve">
          <source>As an example, consider a virtual table implementation that provides read-only access to existing comma-separated-value (CSV) files on disk. There is no backing store that needs to be created or initialized for such a virtual table (since the CSV files already exist on disk) so the xCreate and xConnect methods will be identical for that module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3486a0e62ced4a8499838d1b8b7393bbcb9f1f" translate="yes" xml:space="preserve">
          <source>As an example, consider creating a two-dimensional R*Tree index for use in spatial queries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3a827b13a126faa4b33b0ce651746d14a8fc48" translate="yes" xml:space="preserve">
          <source>As an example, consider the following query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e02419a6c1aa60126918f747f9d30c0add3ddc" translate="yes" xml:space="preserve">
          <source>As an example, consider the following table that tracks dollar-amount changes on various &quot;accounts&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9685f258b372a754415995a52cb6b9f9c3a80f7a" translate="yes" xml:space="preserve">
          <source>As an example, suppose someone (perhaps a customer) asks you: &quot;What ever became of that 'prefer-coroutine-sort-subquery' branch from two years ago?&quot; You might try to answer the query by consulting the history in your version control system, thusly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ff54cf6acce621207ec9ac9f6485fedf9ef893" translate="yes" xml:space="preserve">
          <source>As an example, the following graphic:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a7709446ce5823dd6ac2917092a6664f0dbd82" translate="yes" xml:space="preserve">
          <source>As an example, the following setup causes TCL to throw an error if an SQL statement contains an parameter that does not match any global TCL variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed757795f16facadb1fc50b83304333bb04670f" translate="yes" xml:space="preserve">
          <source>As an example, the following table show the relative sizes for an SQLite Archive, a ZIP Archive, and a Tarball of the 1,743 files in the SQLite 3.22.0 source tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d15dfd61e0635160b8312b26c2789af818a9391" translate="yes" xml:space="preserve">
          <source>As an ordinary SQLite table, &quot;wordcount&quot; is implemented as two separate B-Trees. The main table uses the hidden rowid value as the key and stores the &quot;word&quot; and &quot;cnt&quot; columns as data. The &quot;TEXT PRIMARY KEY&quot; phrase of the CREATE TABLE statement causes the creation of an &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt; on the &quot;word&quot; column. This index is a separate B-Tree that uses &quot;word&quot; and the &quot;rowid&quot; as the key and stores no data at all. Note that the complete text of every &quot;word&quot; is stored twice: once in the main table and again in the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8276f7702973f7730b88b6137faf5d630b77f015" translate="yes" xml:space="preserve">
          <source>As before, SQLite does single binary search for the range of rows in the covering index that satisfy the WHERE clause, the scans that range from top to bottom to get the desired results. The rows that satisfy the WHERE clause are guaranteed to be adjacent since the WHERE clause is an equality constraint on the left-most column of the index. And by scanning the matching index rows from top to bottom, the output is guaranteed to be ordered by state since the state column is the very next column to the right of the fruit column. And so the resulting query is very efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15882cefbefb220ce1658791117147edd8cba359" translate="yes" xml:space="preserve">
          <source>As before, the Column instruction uses cursor P1 and pushes the data record in column P2 (1, column &quot;two&quot;) onto the stack. The Integer instruction pushes the value 50 onto the top of the stack. After these two instructions the stack looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0707574912e68bc0443d44af5e83d6ee57452b" translate="yes" xml:space="preserve">
          <source>As before, the second insert on the left will fail because the comparison will convert both strings into floating-point number first and the only difference in the strings is in the 20-th digit which exceeds the resolution of a 64-bit float. In contrast, the second insert on the right will work because in that case, the numbers being inserted are strings and are compared using memcmp().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021a9e62497cd6d1534e29c131c8485644cff8ee" translate="yes" xml:space="preserve">
          <source>As can be seen above, a single run of multitest.tcl invokes th3make dozens of times and takes between 12 and 24 CPU hours. The middle section of the output shows the arguments to each individual th3make run and the result and elapse time for that th3make. All build products and output for the separate th3make runs are captures in subdirectories for post-test analysis. The two-line summary at the bottom shows the total number of errors and tests over all th3make runs and the total elapse time, together with the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; information for the version of SQLite that was tested. This summary information is recorded in the &lt;a href=&quot;https://www.sqlite.org/checklists&quot;&gt;release checklist&lt;/a&gt; during final testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57eec57195e396346032e284f403497e2a6ca2c" translate="yes" xml:space="preserve">
          <source>As far as we can tell, the SQL language specification allows the use of manifest typing. Nevertheless, most other SQL database engines are statically typed and so some people feel that the use of manifest typing is a bug in SQLite. But the authors of SQLite feel very strongly that this is a feature. The use of manifest typing in SQLite is a deliberate design decision which has proven in practice to make SQLite more reliable and easier to use, especially when used in combination with dynamically typed programming languages such as Tcl and Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc29e0fdbff3d25477a8e029f9259bac6f50556e" translate="yes" xml:space="preserve">
          <source>As for all other SQLite tables, virtual or otherwise, data is retrieved from FTS tables using a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10a21db398e4cbe3920a0271ec03a17da9374a2" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#section_3_11&quot;&gt;section 3.11&lt;/a&gt;, the journal file might be truncated to zero length or its header might be overwritten with zeros as an optimization on systems where deleting a file is expensive. Either way, the journal is no longer hot after this step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a052665302d7ed15dacb760a0e1d99f7e61c18a" translate="yes" xml:space="preserve">
          <source>As in the INSERT example, we push the database number P1 (0, the main database) onto the stack and use OpenWrite to open the cursor P1 on table P2 (base page 3, &quot;examp&quot;) for modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493b86f021b95461d337801ffc16a105b55e8b55" translate="yes" xml:space="preserve">
          <source>As in the SELECT example, the &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction rewinds the cursor to the beginning of the table, readying it for use in the loop body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164cc333da63b4862e96f8a93857b770263a0e06" translate="yes" xml:space="preserve">
          <source>As is the case for a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed24902923099bb89f817d03e0f964e2ddf3fe73" translate="yes" xml:space="preserve">
          <source>As its name implies, an R*Tree is organized as a tree. Each node of the tree is a bounding box. The root of the tree is a bounding box that encapsulates all elements of the tree. Beneath the root are a number of subtrees (typically 20 or more) each with their own smaller bounding boxes and each containing some subset of the R*Tree entries. The subtrees may have sub-subtrees, and so forth until finally one reaches the leaves of the tree which are the actual R*Tree entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1329f3ec0fa61448c27dc490e807fec1b74fd581" translate="yes" xml:space="preserve">
          <source>As its name suggests, the &quot;close&quot; method to an SQLite database just closes the database. This has the side-effect of deleting the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9e6df535e040569dafb3fcef3111ff226a3e67" translate="yes" xml:space="preserve">
          <source>As long as the buffer size is greater than zero, sqlite3_snprintf() guarantees that the buffer is always zero-terminated. The first parameter &quot;n&quot; is the total size of the buffer, including space for the zero terminator. So the longest string that can be completely written will be n-1 characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ea5ee053d47ffa17dd452debb3d0d447e3ffce" translate="yes" xml:space="preserve">
          <source>As long as the input parameter is correct, these routines can only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7938d9d029402b8371ec96dc41a03cdd95d8f8" translate="yes" xml:space="preserve">
          <source>As long as the input parameters are correct, these routines will only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3758ac84a3f79558343e605f45f43dad96f8ef" translate="yes" xml:space="preserve">
          <source>As new versions of SQLite are released, repeat steps 3.6 and 3.7 to add changes in the new release to the private branch. Additional private changes can be made on the private branch in between releases if desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e442983efbc639e95659cc425a72881ca75f93d3" translate="yes" xml:space="preserve">
          <source>As noted above, there really is no such thing as a &quot;sqlite3_column()&quot; function in the SQLite API. Instead, what we here call &quot;sqlite3_column()&quot; is a place-holder for an entire family of functions that return a value from the result set in various data types. There are also routines in this family that return the size of the result (if it is a string or BLOB) and the number of columns in the result set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f8a41bee17850d3fdbafd1837635d4f3b48596" translate="yes" xml:space="preserve">
          <source>As of 2017-03-12, you must use Fossil version 2.0 or later for the following instructions to work. The SQLite repository started using artifacts named using SHA3 hashes instead of SHA1 hashes on that date, and Fossil 2.0 or later is needed in order to understand the new SHA3 hashes. To find out what version of Fossil you are running, type &quot;fossil -v&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e28b72fbe9e739630682b02359c85a23e23fe2" translate="yes" xml:space="preserve">
          <source>As of 2018-05-19, the TH3 source tree consists and well over 500,000 lines of source code in 1709 separate files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32045934e18d7d7235684ae81bb4ad3e112f0c5b" translate="yes" xml:space="preserve">
          <source>As of 2019-03-20, there is now an &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;official Git mirror&lt;/a&gt; of the SQLite sources on GitHub.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e28505b65fc1d015c678e6ae0f3c3ddff268608" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10), the SQLite library consists of approximately 138.9 KSLOC of C code. (KSLOC means thousands of &quot;Source Lines Of Code&quot; or, in other words, lines of code excluding blank lines and comments.) By comparison, the project has 662 times as much test code and test scripts - 91946.2 KSLOC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53c8d218bf20b0261060ea362ee56f13c07c935" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14), SQLite supports &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. But enforcement of foreign key constraints is turned off by default (for backwards compatibility). To enable foreign key constraint enforcement, run &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt; or compile with &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS=1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836b2728d9d516fbe942ba314e801009ae9980b0" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12), SQLite includes a new virtual table module called &quot;fts4aux&quot;, which can be used to inspect the full-text index of an existing FTS table directly. Despite its name, fts4aux works just as well with FTS3 tables as it does with FTS4 tables. Fts4aux tables are read-only. The only way to modify the contents of an fts4aux table is by modifying the contents of the associated FTS table. The fts4aux module is automatically included in all &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;builds that include FTS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03eb89fc06866a1260f6276654306363ba727d94" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), FTS5 is included as part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. It is disabled by default. If using the two autoconf build system, it is enabled by specifying the &quot;--enable-fts5&quot; option when running the configure script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cba18acfc338d803dd183b86646f960bc3ebd65" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.16.0 (2017-01-02), the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; contains a dot-command &quot;.imposter&quot; that does all of the work of setting up a transient imposter table. Instead of making multiple calls to sqlite3_test_control() and figuring out and invoking a compatible CREATE TABLE statement, a transient imposter table can be constructed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a2e1c87379924c2c171b5738373e64a2f944b7" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.27.0 (2019-02-07) the use of a double-quoted string literal causes a warning message to be sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477279c68e157e3c69007f56a275a12b81ee766f" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.29.0 (2019-07-10) the use of double-quoted string literals can be disabled at run-time using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt; actions to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;. The default settings can be altered at compile-time using the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS=&lt;i&gt;N&lt;/i&gt;&lt;/a&gt; compile-time option. Application developers are encouraged to compile using -DSQLITE_DQS=0 in order to disable the double-quoted string literal misfeature by default. If that is not possible, then disable double-quoted string literals for individual database connections using C-code like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ccd6edc0578e2c50724724d1f7e72fc2202881" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the WAL file for a single transaction should be proportional in size to the transaction itself. Pages that are changed by the transaction should only be written into the WAL file once. However, with older versions of SQLite, the same page might be written into the WAL file multiple times if the transaction grows larger than the page cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9002d4afcf5621573059e14d645945f49cc82521" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_1.html&quot;&gt;version 3.6.1&lt;/a&gt; (2008-08-06), the soft heap limit only applies to the general-purpose memory allocator. The soft heap limit does not know about or interact with the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; or the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;. This deficiency will likely be addressed in a future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b175c36534eb0163084a39638e664737aba3d613" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt;, the default setting for foreign key enforcement is OFF. However, that might change in a future release of SQLite. The default setting for foreign key enforcement can be specified at compile-time using the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; preprocessor macro. To minimize future problems, applications should set the foreign key enforcement flag as required by the application and not depend on the default setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6461cc943c138056429ef3ecea61d0043a0402" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; utility is able to generate RBU databases representing the difference between two databases with identical schemas. For example, the following command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfbf6fd8aef52e316e037404ed7145e5b99ccf6d" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.21.0 (2017-10-24), the query planner will always prefer to use a co-routine to implement FROM-clause subqueries that contains an ORDER BY clause and that are not part of a join when the result set of the outer query is &quot;complex&quot;. This feature allows applications to shift expensive computations from before the sorter until after the sorter, which can result in faster operation. For example, consider this query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242b46186535aea87c089fafc2bda700b6f5e078" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.22.0, the &quot;sqlite_stat1&quot; table is an exception to some of the rules above. In SQLite, the schema of sqlite_stat1 is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ddb98490083a7f2dc1ca2a3b26fa7d781b747ca" translate="yes" xml:space="preserve">
          <source>As of this writing (2017-07-13), the completion virtual table only looks for SQL keywords, and schema, table, and column names. The context contained in $wholeline is completely ignored. Future enhancements will try to return new completions taken from function and pragma names and other sources, as well as consider more context. The completion table should be considered a work-in-progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b289cb5373e1ff5a5a0c905eb902dc91bdb7b556" translate="yes" xml:space="preserve">
          <source>As of this writing (2018-05-29) the only other recommended storage formats for datasets are XML, JSON, and CSV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ad4e776d39a3ec2c252f71f4dae40cd1708a1c" translate="yes" xml:space="preserve">
          <source>As of this writing (2019-07-16), the SQLite developers have stopped using AFL for routine testing and instead are focused on running dbsqlfuzz. At least one instance of dbsqlfuzz is running on the latest SQLite source code at all times, in order to catch any new problems that might be introduced into the source tree as features are added and routine maintenance is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36686a25a23f2cfaee766f9bfb5607ad00a8413" translate="yes" xml:space="preserve">
          <source>As one might expect, the amount of data read from the database file is minimized by caching portions of the database file in main memory. Additionally, multiple updates to the database file that are part of the same</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972efc3fd6678a6e105ba1a8f1aac17c41abd523" translate="yes" xml:space="preserve">
          <source>As part of opening a new</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b40d60a44eca2b862c669b4ece8404effe70c95" translate="yes" xml:space="preserve">
          <source>As part of the query planning process, SQLite enumerates all usable combinations of indexes and WHERE-clause constraints. For certain pathological queries, the number of these index-and-constraint combinations can be very large, resulting in slow performance by the query planner. The SQLITE_QUERY_PLANNER_LIMIT value (in conjunction with the related &lt;a href=&quot;compile#query_planner_limit_incr&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR&lt;/a&gt; setting) limits the number of index-and-constraint combinations that the query planner will consider, in order to prevent the query planner from using excess CPU time. The default value for SQLITE_QUERY_PLANNER_LIMIT is set high enough so that is never reached for real-world queries. The query planner search limit only applies to queries that are deliberately crafted to use excess planning time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ee480d16c703172bf696c37d4bed26f84974f4" translate="yes" xml:space="preserve">
          <source>As part of the task of creating a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure, this method &lt;u&gt;must&lt;/u&gt; invoke &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; to tell the SQLite core about the columns and datatypes in the virtual table. The &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; API has the following prototype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00876adc6de8fc473fb32b80195d17d4fda9f03" translate="yes" xml:space="preserve">
          <source>As pointed out in the previous paragraph, SQLite takes steps to work around the quirks of POSIX advisory locking. Part of that work-around involves keeping a global list (mutex protected) of open SQLite database files. But, if multiple copies of SQLite are linked into the same application, then there will be multiple instances of this global list. Database connections opened using one copy of the SQLite library will be unaware of database connections opened using the other copy, and will be unable to work around the POSIX advisory locking quirks. A &lt;code&gt;close()&lt;/code&gt; operation on one connection might unknowingly clear the locks on a different database connection, leading to database corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d67b507fa18e45da7b000070cada26cbc7cde7" translate="yes" xml:space="preserve">
          <source>As recently as version 2.7.0, SQLite ran at about the same speed as MySQL on this test. But recent optimizations to SQLite have more than doubled speed of UPDATEs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a13d6d8189152816b2ae81d060e78c812a6905c" translate="yes" xml:space="preserve">
          <source>As soon as the PENDING lock is released from the database file, other processes can begin reading the database again. In the current implementation, the RESERVED lock is also released, but that is not essential for correct operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555c3a9cda5a4b25e0cdbc43fe5e7c8c0b690222" translate="yes" xml:space="preserve">
          <source>As the last step in opening a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5e740293d719649dc267008b44fcf5aaa20455" translate="yes" xml:space="preserve">
          <source>As we enter the interior of the second loop (at instruction 17) the stack contains a single integer which is the key of the record we want to modify. We are going to need to use this key twice: once to fetch the old value of the record and a second time to write back the revised record. So the first instruction is a Dup to make a duplicate of the key on the top of the stack. The Dup instruction will duplicate any element of the stack, not just the top element. You specify which element to duplication using the P1 operand. When P1 is 0, the top of the stack is duplicated. When P1 is 1, the next element down on the stack duplication. And so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4c617d0371eb7d2e50bdeaba7f0656cfa12c47" translate="yes" xml:space="preserve">
          <source>As well as a list of columns, the module arguments passed to a CREATE VIRTUAL TABLE statement used to create an FTS table may be used to specify a &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. This is done by specifying a string of the form &quot;tokenize=&amp;lt;tokenizer name&amp;gt; &amp;lt;tokenizer args&amp;gt;&quot; in place of a column name, where &amp;lt;tokenizer name&amp;gt; is the name of the tokenizer to use and &amp;lt;tokenizer args&amp;gt; is an optional list of whitespace separated qualifiers to pass to the tokenizer implementation. A tokenizer specification may be placed anywhere in the column list, but at most one tokenizer declaration is allowed for each CREATE VIRTUAL TABLE statement. &lt;a href=&quot;fts3#tokenizer&quot;&gt;See below&lt;/a&gt; for a detailed description of using (and, if necessary, implementing) a tokenizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba6435071ee404f8eb600e0af17ad3d0179b00e" translate="yes" xml:space="preserve">
          <source>As well as aggregate window functions, SQLite features a set of built-in window functions based on &lt;a href=&quot;https://www.postgresql.org/docs/10/static/functions-window.html&quot;&gt; those supported by PostgreSQL&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2adc03d8772b0c49ef19569e284dd9591a16b0" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da8075b78c1059d6422bee1d474218e1b6600d9" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a715526e2153a56ee0a3cbcb2c8454333e9e1d8" translate="yes" xml:space="preserve">
          <source>As well as searching for all rows that contain a term, FTS5 allows the user to search for rows that contain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f6e18c709ce14d58e4401d523e835813272b3a" translate="yes" xml:space="preserve">
          <source>As well as the &quot;simple&quot; tokenizer, the FTS source code features a tokenizer that uses the &lt;a href=&quot;http://tartarus.org/~martin/PorterStemmer/&quot;&gt;Porter Stemming algorithm&lt;/a&gt;. This tokenizer uses the same rules to separate the input document into terms including folding all terms into lower case, but also uses the Porter Stemming algorithm to reduce related English language words to a common root. For example, using the same input document as in the paragraph above, the porter tokenizer extracts the following tokens: &quot;right now thei veri frustrat&quot;. Even though some of these terms are not even English words, in some cases using them to build the full-text index is more useful than the more intelligible output produced by the simple tokenizer. Using the porter tokenizer, the document not only matches full-text queries such as &quot;MATCH 'Frustrated'&quot;, but also queries such as &quot;MATCH 'Frustration'&quot;, as the term &quot;Frustration&quot; is reduced by the Porter stemmer algorithm to &quot;frustrat&quot; - just as &quot;Frustrated&quot; is. So, when using the porter tokenizer, FTS is able to find not just exact matches for queried terms, but matches against similar English language terms. For more information on the Porter Stemmer algorithm, please refer to the page linked above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b7b3d7c7af14aee8c40f5a5eff47a557f13b7f" translate="yes" xml:space="preserve">
          <source>As well as the column values and rowid of a matching row, an application may use &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt; to retrieve extra information regarding the matched row. For example, an auxiliary function may be used to retrieve a copy of a column value for a matched row with all instances of the matched term surrounded by html &amp;lt;b&amp;gt;&amp;lt;/b&amp;gt; tags. Auxiliary functions are invoked in the same way as SQLite &lt;a href=&quot;lang_corefunc&quot;&gt;scalar functions&lt;/a&gt;, except that the name of the FTS5 table is specified as the first argument. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0b425505ed4df313764b933ddda058638fd396" translate="yes" xml:space="preserve">
          <source>As well as the columns named by the user (or the &quot;content&quot; column if no module arguments were specified as part of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement), each FTS table has a &quot;rowid&quot; column. The rowid of an FTS table behaves in the same way as the rowid column of an ordinary SQLite table, except that the values stored in the rowid column of an FTS table remain unchanged if the database is rebuilt using the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. For FTS tables, &quot;docid&quot; is allowed as an alias along with the usual &quot;rowid&quot;, &quot;oid&quot; and &quot;_oid_&quot; identifiers. Attempting to insert or update a row with a docid value that already exists in the table is an error, just as it would be with an ordinary SQLite table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8231b142308216452ffa1a9e5faf9c8e3f6c4c97" translate="yes" xml:space="preserve">
          <source>As well as the command option, each invocation of &quot;.ar&quot; may specify one or more modifier options. Some modifier options require an argument, some do not. The following modifier options are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a7e6bcced1d592a4403e3d9c67fd5b0f5481cf" translate="yes" xml:space="preserve">
          <source>As well as the regular sqlite3changegroup_add() and sqlite3changegroup_output() functions, also available are the streaming versions sqlite3changegroup_add_strm() and sqlite3changegroup_output_strm().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79aa6a7ac9fe81930f35128aa127b04b14a76a2" translate="yes" xml:space="preserve">
          <source>As with &quot;.tables&quot;, the &quot;.schema&quot; command shows the schema for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases. If you only want to see the schema for a single database (perhaps &quot;main&quot;) then you can add an argument to &quot;.schema&quot; to restrict its output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1906458c679a89c4cf89131d2ffd0b8ce0439a" translate="yes" xml:space="preserve">
          <source>As with all SQL syntax, the case of the keywords does not matter. One can write &quot;WITHOUT rowid&quot; or &quot;without rowid&quot; or &quot;WiThOuT rOwId&quot; and it will mean the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e240ecd7ad7f6958c55717608dff9d30301be2" translate="yes" xml:space="preserve">
          <source>As with all other SQLite APIs, those whose names end with &quot;16&quot; return UTF-16 encoded strings and the other functions return UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad941d012cf3c0fecce4040017740b92b3cab9e" translate="yes" xml:space="preserve">
          <source>As with all virtual table types, it is not possible to create indices or triggers attached to FTS tables. Nor is it possible to use the ALTER TABLE command to add extra columns to FTS tables (although it is possible to use ALTER TABLE to rename an FTS table).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9244ac5b5d0550aa0d1fc8ca3aa52ca8dfaf6c" translate="yes" xml:space="preserve">
          <source>As with custom file formats, and unlike pure pile-of-file formats, a wrapped pile-of-files format is not as easy to edit, since usually the entire file must be rewritten in order to change any component part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236d7f982d31124f4b94b3c6bc8e43ed33b0fc4b" translate="yes" xml:space="preserve">
          <source>As with the output of the sqlite3session_changeset() and sqlite3session_patchset() functions, all changes related to a single table are grouped together in the output of this function. Tables appear in the same order as for the very first changeset added to the changegroup. If the second or subsequent changesets added to the changegroup contain changes for tables that do not appear in the first changeset, they are appended onto the end of the output changeset, again in the order in which they are first encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38abe488c2a235f79f98488263f0f24db0790ef4" translate="yes" xml:space="preserve">
          <source>As with unix, most of the code for the various Windows VFSes is shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae23c67b5810fa3b2f8c5dc0de91ee63f46fa321" translate="yes" xml:space="preserve">
          <source>As you can see above, our simple insert statement is implemented in 12 instructions. The first 3 and last 2 instructions are a standard prologue and epilogue, so the real work is done in the middle 7 instructions. There are no jumps, so the program executes once through from top to bottom. Let's now look at each instruction in detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7f8dc6fe3c7e8373b6401e629567228cb8e775" translate="yes" xml:space="preserve">
          <source>As you would expect, it is not possible to manipulate the database to a state that violates the foreign key constraint by deleting or updating rows in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60ffe4ee5253e97c8077a55a44490538dd90ceb" translate="yes" xml:space="preserve">
          <source>Aside from those read operations described by H35070 and H21XXX, SQLite shall read data from the database file in aligned blocks of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e2846af72fd7f80a66045f0952619fc82cc85d" translate="yes" xml:space="preserve">
          <source>Assert() macros are disabled by compiling with the NDEBUG macro defined. In most systems, asserts are enabled by default. But in SQLite, the asserts are so numerous and are in such performance critical places, that the database engine runs about three times slower when asserts are enabled. Hence, the default (production) build of SQLite disables asserts. Assert statements are only enabled when SQLite is compiled with the SQLITE_DEBUG preprocessor macro defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c350f30044b71a607c57f6c34de0b1ed5d9089b9" translate="yes" xml:space="preserve">
          <source>Assertion fault in FTS4. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d6ec09eccf68cfc&quot;&gt;d6ec09eccf68cfc&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc26a866ddd19c561f95f02b90e42c3048bf831" translate="yes" xml:space="preserve">
          <source>Assertion fault on queries involving expressions of the form &quot;x IN (?)&quot;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c84e5f05e8b60b78b6a824b91605a18f1523027" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing REPLACE on an index on an expression. Ticket &lt;a href=&quot;https://sqlite.org/src/info/dc3f932f5a147771&quot;&gt;dc3f932f5a147771&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14462bb4d8840870eeb8b473a0f255cc7e22e056" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing an IN operator on a constant index. Ticket &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddcab&quot;&gt;aa98619ad08ddcab&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cea6f6a832fd7bbb6517d045402e777f939a795" translate="yes" xml:space="preserve">
          <source>Assigned the integer at offset 68 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt; as the &lt;a href=&quot;fileformat2#appid&quot;&gt;Application ID&lt;/a&gt; for when SQLite is used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. Added the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command to query and set the Application ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc2100f672c34160990cbf608240b0f61030c73" translate="yes" xml:space="preserve">
          <source>Assuming</source>
          <target state="translated">Assuming</target>
        </trans-unit>
        <trans-unit id="ea6dcdcecbe15c6b4677215943bc88e69426e6db" translate="yes" xml:space="preserve">
          <source>Assuming no errors have occurred, then after attempting to detect and roll back a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d3766c3aab2fade58e514ea17fb6dc49420a581" translate="yes" xml:space="preserve">
          <source>Assuming statistics are enabled, the following routine can be used to access them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836ad82865d510ff9a297c7660cf9d810b0b4728" translate="yes" xml:space="preserve">
          <source>Assuming that after registering for an unlock-notify callback a database waits for the callback to be issued before taking any further action (a reasonable assumption), then using this API may cause the application to deadlock. For example, if connection X is waiting for connection Y's transaction to be concluded, and similarly connection Y is waiting on connection X's transaction, then neither connection will proceed and the system may remain deadlocked indefinitely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba1c75f29bb0c1b541e404f389344df8b7d3190" translate="yes" xml:space="preserve">
          <source>Assuming that any and all sectors in the transient state may be corrupted following a power or system failure is a very pessimistic approach. Some modern systems provide more sophisticated guarantees than this. SQLite allows the VFS implementation to specify at runtime that the current platform supports zero or more of the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e7a33261340b9207abc7f6240781daed2437d8" translate="yes" xml:space="preserve">
          <source>Assuming that customer records are stored in the &quot;customers&quot; table, and that order records are stored in the &quot;orders&quot; table, the following UPDATE trigger ensures that all associated orders are redirected when a customer changes his or her address:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff40c2070ad237bff82bd7bce4ef0b45898889d0" translate="yes" xml:space="preserve">
          <source>Assuming that the compile-time threading mode is not single-thread, then the threading mode can be changed during initialization using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; verb puts SQLite into single-thread mode, the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; verb sets multi-thread mode, and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; verb sets serialized mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4099134714457b667c5a0d0c91727935a69b43" translate="yes" xml:space="preserve">
          <source>Assuming that the first hidden column of &quot;tablevaluedfunc&quot; is &quot;param1&quot;, the query above is semantically equivalent to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a392f90a65c67ef3276bb011e52cf4659579c18e" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;#sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae768e26e15e53e036c5e372149bd64f61fe40d5" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae27622bf93c5f8e58c667e3d2b3f8634b153cf3" translate="yes" xml:space="preserve">
          <source>Assuming the library is compiled with foreign key constraints enabled, it must still be enabled by the application at runtime, using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1dda34c843a460a37b4389bc3fdea530b33452" translate="yes" xml:space="preserve">
          <source>Assuming the nominated table does exist, then its columns must be the same as or a superset of those defined for the FTS table. The external table must also be in the same database file as the FTS table. In other words, The external table cannot be in a different database file connected using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; nor may one of the FTS table and the external content be in the TEMP database when the other is in a persistent database file such as MAIN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="921866ee0046d5a80db64dfb8749244f24a09ba6" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the &lt;a href=&quot;#xInstCount&quot;&gt;xInstCount&lt;/a&gt;, &lt;a href=&quot;#xInst&quot;&gt;xInst&lt;/a&gt;, &lt;a href=&quot;#xPhraseFirst&quot;&gt;xPhraseFirst&lt;/a&gt; and &lt;a href=&quot;#xPhraseNext&quot;&gt;xPhraseNext&lt;/a&gt; are slower than usual. This is because instead of reading the required data directly from the FTS index they have to load and tokenize the document text on demand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc375c212f41b57083889574933fcd5e4987a611" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a contentless table, the &lt;a href=&quot;#xPhraseFirstColumn&quot;&gt;xPhraseFirstColumn&lt;/a&gt; and &lt;a href=&quot;#xPhraseNextColumn&quot;&gt;xPhraseNextColumn&lt;/a&gt; are slower than usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504be981e8ff80c0d63cd17a340b7f1cd587e84d" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O appears to give better responsiveness, but at a price. You lose the Durable property. With the default I/O backend of SQLite, once a write completes, you know that the information you wrote is safely on disk. With the asynchronous I/O, this is not the case. If your program crashes or if a power loss occurs after the database write but before the asynchronous write thread has completed, then the database change might never make it to disk and the next user of the database might not see your change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c26b5cd54f0029b1a3269b19cfe3a6ff6addbcc" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O works by creating an SQLite &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; and registering it with &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. When files opened via this VFS are written to (using the vfs xWrite() method), the data is not written directly to disk, but is placed in the &quot;write-queue&quot; to be handled by the background thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c91d5ce458c482219d3664734d8a556293b6cdf" translate="yes" xml:space="preserve">
          <source>At a shell or DOS prompt, enter: &quot;&lt;b&gt;sqlite3 test.db&lt;/b&gt;&quot;. This will create a new database named &quot;test.db&quot;. (You can use a different name if you like.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449f6270af54115e84fbbfac0ca3ab28ec064210" translate="yes" xml:space="preserve">
          <source>At about that same time, some avionics manufacturers were expressing interest in SQLite, which prompted the SQLite developers to design TH3 to support the rigorous testing standards of &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3fd57d066718d01302089d95d92c8454d1b5f4a" translate="yes" xml:space="preserve">
          <source>At any one time, a single table may have any number of active read-locks or a single active write lock. To read data a table, a connection must first obtain a read-lock. To write to a table, a connection must obtain a write-lock on that table. If a required table lock cannot be obtained, the query fails and SQLITE_LOCKED is returned to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c8ad5daed2b52823fb4c80a495b310ef19384a" translate="yes" xml:space="preserve">
          <source>At any one time, each</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8560f4e49c6caa4d7228201f89aa3ea44ff72f5b" translate="yes" xml:space="preserve">
          <source>At any one time, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faefe425b3756bc94c56346d8a50b44d5ccda922" translate="yes" xml:space="preserve">
          <source>At any point in time, every page in the main database has a single use which is one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4998acdc6089555e0887c221354101b4a2253663" translate="yes" xml:space="preserve">
          <source>At first glance, the final two full-text queries in the example above seem to be syntactically incorrect, as there is a table name (&quot;mail&quot;) used as an SQL expression. The reason this is acceptable is that each FTS table actually has a &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;HIDDEN&lt;/a&gt; column with the same name as the table itself (in this case, &quot;mail&quot;). The value stored in this column is not meaningful to the application, but can be used as the left-hand operand to a MATCH operator. This special column may also be passed as an argument to the &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f5836449640e20f49edf00efccee8083a6bcb35" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59514e13b273471c6ec6f5f109fedbde115ba166" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf0c7d5d4e31a3622d3bed10cffc599203f902a" translate="yes" xml:space="preserve">
          <source>At most one connection to a single shared cache may open a write transaction at any one time. This may co-exist with any number of read transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2549fa7b8565911915cfbc5b3b9d42147224732f" translate="yes" xml:space="preserve">
          <source>At one point, &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; was sometimes licensed to third-parties. Such licensing no longer occurs. However, back when it was occurring, some of the TH3 test cases contained information that was sensitive and could not be released even to licensees. This sensitive information is stored in yet another repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d936f8adee7e8e3dc2d8a9b26c4bae945a9dd4c" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0662b7a2bebf7dce7d12510693eb67ca1548c61" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598f95760d8ef9fc04e0c94379f28c6b7cd53470" translate="yes" xml:space="preserve">
          <source>At the beginning of a cache spill, the status of the database connection is as shown in &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. Original page content has been saved in the rollback journal and modifications of the pages exist in user memory. To spill the cache, SQLite executes steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; through &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;. In other words, the rollback journal is flushed to disk, an exclusive lock is acquired, and changes are written into the database. But the remaining steps are deferred until the transaction really commits. A new journal header is appended to the end of the rollback journal (in its own sector) and the exclusive database lock is retained, but otherwise processing returns to &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. When the transaction commits, or if another cache spill occurs, steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; and &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; are repeated. (Step &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt; is omitted on second and subsequent passes since an exclusive database lock is already held due to the first pass.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07c0967c09d3dbc3e32b1c4ad8479eec1c47ba2" translate="yes" xml:space="preserve">
          <source>At this point you are ready to type &quot;&lt;code&gt;./configure; make&lt;/code&gt;&quot; (or on Windows with MSVC, &quot;&lt;code&gt;nmake /f Makefile.msc&lt;/code&gt;&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9739e0c9d62ebb2f85f2435395edecdd3fc346" translate="yes" xml:space="preserve">
          <source>At this point, you can measure the amount of disk space used by the test1.db database and the space used by the test1.dir directory and all of its content. On a standard Ubuntu Linux desktop, the database file will be 1,024,512,000 bytes in size and the test1.dir directory will use 1,228,800,000 bytes of space (according to &quot;du -k&quot;), about 20% more than the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05593853b78d4288d0ab3317d42f66fcc3356044" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the VDBE well enough to figure out on your own how the above program works. So we will not discuss it further in this text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ed93611b051b3f2ce2f2e18dd2aa20d02819e82" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the basics of how the VDBE writes to a database. Now let's look at how it does queries. We will use the following simple SELECT statement as our example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca131936c53e26b047834300b8b5909015686af9" translate="yes" xml:space="preserve">
          <source>At this time SQLite supports only FOR EACH ROW triggers, not FOR EACH STATEMENT triggers. Hence explicitly specifying FOR EACH ROW is optional. FOR EACH ROW implies that the SQL statements specified in the trigger may be executed (depending on the WHEN clause) for each database row being inserted, updated or deleted by the statement causing the trigger to fire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2f2ddc27722f56f60ce157d4213f6b2caed0bd" translate="yes" xml:space="preserve">
          <source>At this writing, 2050 is still 34 years in the future. Nobody knows what will happen in that time, and we cannot absolutely promise that SQLite will be viable or useful that far out. But we can promise this: we plan as if we will be supporting SQLite until 2050. That long-term outlook affects our decisions in important ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc594be0856868f818e54abe920fd51cc599639" translate="yes" xml:space="preserve">
          <source>Atomic Commit In SQLite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4c9569233db52020accb44326c29045c8c4cce" translate="yes" xml:space="preserve">
          <source>Atomic Transactions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c8139f3cad23c8756bfadca13473ed3a8e76ee" translate="yes" xml:space="preserve">
          <source>Atomic commits for ATTACHed databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92dd7a0665a3434edc8f121885515c600f18e15b" translate="yes" xml:space="preserve">
          <source>Attach A Table To A Session Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d752510d48bfeb2c136d1e65419fdd66d0835e6" translate="yes" xml:space="preserve">
          <source>Attempt To Free Heap Memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ccf4926dcde2d4398cadb109fcd1c1c1205d36" translate="yes" xml:space="preserve">
          <source>Attempt to optimize the database. All schemas are optimized in the first two forms, and only the specified schema is optimized in the latter two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b5f89658d37542e4f2f47adfbbada66e9f74c3" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50dfefcf7c07518a2714e6179a3b3e2c44246560" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316c0eb6ee34ebe2465e653e0615de6cea48d923" translate="yes" xml:space="preserve">
          <source>Attempting to read any column value except the rowid from a contentless FTS5 table returns an SQL NULL value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759ff226aedc6e7693575bc9de2859284a195a00" translate="yes" xml:space="preserve">
          <source>Attempts to signal a waiting thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c4d17e8ff8b4302eac4e4e2a0df21e83e7e1f7" translate="yes" xml:space="preserve">
          <source>Attribute to God, and not to self, whatever good you see in yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825e25e0e089626089745a27ce2ef2c2c1ea38e6" translate="yes" xml:space="preserve">
          <source>Authorizer Action Codes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1592d27599a37fb2c21560009556822d633223ac" translate="yes" xml:space="preserve">
          <source>Authorizer Return Codes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4b099d8f18d61aaa97d7c1192205d9f09f6d1b" translate="yes" xml:space="preserve">
          <source>Authorizer callback now notified of ALTER TABLE ADD COLUMN commands</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99108c69c3665b09cc818cd43a65b08e779b2ac" translate="yes" xml:space="preserve">
          <source>Auto-vacuuming is only possible if the database stores some additional information that allows each database page to be traced backwards to its referrer. Therefore, auto-vacuuming must be turned on before any tables are created. It is not possible to enable or disable auto-vacuum after a table has been created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20745b1bcf8af10b98b427193825b087099c77ec" translate="yes" xml:space="preserve">
          <source>AutoCommit</source>
          <target state="translated">AutoCommit</target>
        </trans-unit>
        <trans-unit id="356d8f675fe3749abf68433babe7ea3575fd985f" translate="yes" xml:space="preserve">
          <source>Autocheckpointing is enabled by default with an interval of 1000 or &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f681c869bb1ea71c5ddca4b639af93b4fef9e9" translate="yes" xml:space="preserve">
          <source>Autoincrement now works for INSERT from a SELECT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6b6b970c4ffe43f44cd98c8c080e19e0935d7d" translate="yes" xml:space="preserve">
          <source>Automatic Creation Of Triggers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08dba6041d7d4235968c19294ed55fda427f921" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo Using SQLite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4c6cb294be7b858504d17f8ae3afc2b1d34ca14" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo With SQLite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21544829b41ef1983cd743adcc40b46678a3e3f5" translate="yes" xml:space="preserve">
          <source>Automatic caching of prepared statements in the TCL interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c31289d03ed4b24b0edaf412e508ce77bc130da" translate="yes" xml:space="preserve">
          <source>Automatic indexing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33bad308a6a3f5703b3375cd2f0464df392fd4f" translate="yes" xml:space="preserve">
          <source>Automatically Load Statically Linked Extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1866c31db7344041c61c845f3e6c7f6209984d28" translate="yes" xml:space="preserve">
          <source>Automatically Running ANALYZE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4babc7f522c90b701f1e40024660f0e6d3fdb828" translate="yes" xml:space="preserve">
          <source>Automatically build binaries for Linux and Windows and put them on the website.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a9f83671a7145cd855649b0b10c0da797dd48a" translate="yes" xml:space="preserve">
          <source>Automatically generated ROWIDs are now sequential.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b507ce65fb930f163c0cce40902e91ce9a4aa2" translate="yes" xml:space="preserve">
          <source>Automatically intercepts the raw &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output and reformats it into an ASCII-art graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415678a6fe9db48ebfdb4a92834062e2d75ff761" translate="yes" xml:space="preserve">
          <source>Automatically running ANALYZE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a90bc3ee0845edb1d6db34dc8f58cfefb8e89a" translate="yes" xml:space="preserve">
          <source>Autovacuum support added</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e357312422cd5ec59a0a1ff553c35208f6f0981" translate="yes" xml:space="preserve">
          <source>Auxiliary Function Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2291a1b828f145bde8901e514ec4c748f1d3e7aa" translate="yes" xml:space="preserve">
          <source>Auxiliary columns are marked with a &quot;+&quot; symbol before the column name. Auxiliary columns must come after all of the coordinate boundary columns. There is a limit of no more than 100 auxiliary columns. The following example shows an r-tree table with auxiliary columns that is equivalent to the two tables &quot;demo_index&quot; and &quot;demo_data&quot; above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107b868f1f6fb032b0de401c1fdc39f9a1324503" translate="yes" xml:space="preserve">
          <source>Auxiliary columns in r-tree tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6771e220703ae7d95117926a910b1882f3865ed2" translate="yes" xml:space="preserve">
          <source>Auxiliary function mapping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a6030396538d218b7dda424404dbcc0322cf175" translate="yes" xml:space="preserve">
          <source>Auxiliary functions are similar to &lt;a href=&quot;lang_corefunc&quot;&gt;SQL scalar functions&lt;/a&gt;, except that they may only be used within full-text queries (those that use the MATCH operator) on an FTS5 table. Their results are calculated based not only on the arguments passed to them, but also on the current match and matched row. For example, an auxiliary function may return a numeric value indicating the accuracy of the match (see the &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25()&lt;/a&gt; function), or a fragment of text from the matched row that contains one or more instances of the search terms (see the &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet()&lt;/a&gt; function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad21e0c1521884ee05b9ffda048d19b6293bf5a4" translate="yes" xml:space="preserve">
          <source>Available as a &lt;a href=&quot;amalgamation&quot;&gt;single ANSI-C source-code file&lt;/a&gt; that is &lt;a href=&quot;howtocompile&quot;&gt;easy to compile&lt;/a&gt; and hence is easy to add into a larger project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91da5ef1fa7e2e4b29d2c4baf5ea203498773356" translate="yes" xml:space="preserve">
          <source>Avoid a possible use-after-free error by deferring schema resets until after the query planner has finished running. Ticket &lt;a href=&quot;https://sqlite.org/src/info/be436a7f4587ce5&quot;&gt;be436a7f4587ce5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e3177c978c905dc59ea3eac3bcce9510d2af169" translate="yes" xml:space="preserve">
          <source>Avoid cache pages leaks following disk-full or I/O errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ddd5eec59e56887e4ac83b6d688d5421fe618d" translate="yes" xml:space="preserve">
          <source>Avoid excess heap usage when copying expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ba1f7d7979447a7e96cb25e07064d86e5bb1c8" translate="yes" xml:space="preserve">
          <source>Avoid invoking the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; callback multiple times when a statement is automatically reprepared due to &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7080f3e1eff1f709a6ca19cf689cc05b5715bf56" translate="yes" xml:space="preserve">
          <source>Avoid recomputing &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; and &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt; on unchanged columns in &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f47e376b982a42c816c624a45b787e38257b92" translate="yes" xml:space="preserve">
          <source>Avoid resetting the schema of &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; connections when any one connection closes. Instead, wait for the last connection to close before resetting the schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3426fcb94fc158c5d46e9b08cc237640ca2e54e" translate="yes" xml:space="preserve">
          <source>Avoid running foreign-key constraint checks on an UPDATE if none of the modified columns are associated with foreign keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8f5db6ab5f0aaaf5afe5d9db180abf76160161" translate="yes" xml:space="preserve">
          <source>Avoid this step if possible, as it defeats one of the huge advantages of the whole SQL language concept, specifically that the application programmer does not need to get involved with query planning. If you do use CROSS JOIN, wait until late in your development cycle to do so, and comment the use of CROSS JOIN carefully so that you can take it out later if possible. Avoid using CROSS JOIN early in the development cycle as doing so is a premature optimization, which is well known to be &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;the root of all evil&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d522f897af88e992f364f85aee2e8282258fc265" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary foreign key processing in UPDATE statements that do not touch the columns that are constrained by the foreign keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0262f30f0e72ef13d068b5ef0d92433c9097800" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary invalidation of &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; handles when making changes to unrelated tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2faf372496683418fb5422fedd49afd1602aeb2d" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary loads of columns in an aggregate query that are not within an aggregate function and that are not part of the GROUP BY clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da85f25c4d81aabb9be26649b6528ed9da5a865" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary reparsing of the database schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ab1c695488dd1d3fd9d54bae9338af8b817457" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary writes to the sqlite_sequence table when an &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; table is updated with an rowid that is less than the maximum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="446e18ff4fd4514774047f13cdefc3e3875bc4b1" translate="yes" xml:space="preserve">
          <source>Avoid using a prepared statement for &quot;.stats on&quot; command of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; after it has been closed by the &quot;.eqp full&quot; logicc. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7be932dfa60a8a6b3b26bcf76&quot;&gt;7be932dfa60a8a6b3b26bcf76&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e234fd1edb94740adc1207ebef38597b49b7c1f2" translate="yes" xml:space="preserve">
          <source>Avoiding the use of low-numbered file descriptors is a defense against accidental database corruption. If a database file was opened using file descriptor 2, for example, and then an assert() failed and invoked write(2,...), that would likely cause database corruption by overwriting part of the database file with the assertion error message. Using only higher-valued file descriptors avoids this potential problem. The protection against using low-numbered file descriptors can be disabled by setting this compile-time option to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4253b60bc870d118d832ba2a3c8eabe133ebeb0" translate="yes" xml:space="preserve">
          <source>Aways stores polygons using the binary format, which is faster and uses less space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209ebb59c54866e4ac4c2bdf04c9d0b7b4a958ec" translate="yes" xml:space="preserve">
          <source>B-Tree</source>
          <target state="translated">B-Tree</target>
        </trans-unit>
        <trans-unit id="b149afb9ac3420444ce1e62aefbcdead10e7e777" translate="yes" xml:space="preserve">
          <source>B-tree</source>
          <target state="translated">B-tree</target>
        </trans-unit>
        <trans-unit id="5b87dc158f4c367648401e86eddf1c6445bb5bf6" translate="yes" xml:space="preserve">
          <source>B-tree Cell Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92950af5441bd3255130ef7a72cc86532e49b1e9" translate="yes" xml:space="preserve">
          <source>B-tree Page Header Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a72ea1d2706a588dd39ad58e7cba99ec26696d" translate="yes" xml:space="preserve">
          <source>BEFORE</source>
          <target state="translated">BEFORE</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="4821edeb87e72ffadc6bc2dd7758d1af495e515f" translate="yes" xml:space="preserve">
          <source>BEGIN IMMEDIATE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8913dda08c8185748e987da82c484c6d35030cb9" translate="yes" xml:space="preserve">
          <source>BEGIN TRANSACTION</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b1b0c3e98b1211a4bf44a668731efbeb0029e7" translate="yes" xml:space="preserve">
          <source>BEGIN;</source>
          <target state="translated">BEGIN;</target>
        </trans-unit>
        <trans-unit id="f8e3370718865431368fd54f746d7da4322cc582" translate="yes" xml:space="preserve">
          <source>BETWEEN</source>
          <target state="translated">BETWEEN</target>
        </trans-unit>
        <trans-unit id="2d0fe684054a53889de74128877e23cf3189b322" translate="yes" xml:space="preserve">
          <source>BIGINT</source>
          <target state="translated">BIGINT</target>
        </trans-unit>
        <trans-unit id="d05fb01e0b399387c3a28586f5fd296e2670d6a3" translate="yes" xml:space="preserve">
          <source>BINARY</source>
          <target state="translated">BINARY</target>
        </trans-unit>
        <trans-unit id="1ce04f29dadb9973458555f164627f66e504686e" translate="yes" xml:space="preserve">
          <source>BLOB</source>
          <target state="translated">BLOB</target>
        </trans-unit>
        <trans-unit id="21ca9d91ce78c58717f1f26654ca03e2a7b624ba" translate="yes" xml:space="preserve">
          <source>BLOB (a.k.a &quot;NONE&quot;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16304f06bca682f9f5ee4a2a62fcbf2abac5ed50" translate="yes" xml:space="preserve">
          <source>BLOB literals are string literals containing hexadecimal data and preceded by a single &quot;x&quot; or &quot;X&quot; character. Example: X'53514C697465'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb465d6672ffe8826d619cf7ad2f842e941cbb22" translate="yes" xml:space="preserve">
          <source>BLOB size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80845ed51d0eb2f39da54fe848593b51f5b7523f" translate="yes" xml:space="preserve">
          <source>BLOB support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf36d55a66f6b65f2497e6f96eb9c688f9ee788" translate="yes" xml:space="preserve">
          <source>BLOB values (even serial types 12 and larger) sort last and in the order determined by memcmp().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066ed32331b295c453ee3f4c55916aa0d7c725b0" translate="yes" xml:space="preserve">
          <source>BLOBs sort last</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab68d8e893a82cff70979ba20bec0023dbfe4be3" translate="yes" xml:space="preserve">
          <source>BOOLEAN</source>
          <target state="translated">BOOLEAN</target>
        </trans-unit>
        <trans-unit id="64c3f5e89864d5e803ba483fadc3c80068321744" translate="yes" xml:space="preserve">
          <source>BY</source>
          <target state="translated">BY</target>
        </trans-unit>
        <trans-unit id="987f01f766f58cd662fc3c685393d0d4667cbc0b" translate="yes" xml:space="preserve">
          <source>Back up cursor P1 so that it points to the previous key/data pair in its table or index. If there is no previous key/value pairs then fall through to the following instruction. But if the cursor backup was successful, jump immediately to P2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09881dbbda2f40a1bff480104e690d3c9470795" translate="yes" xml:space="preserve">
          <source>Backport a &lt;a href=&quot;https://www.sqlite.org/src/info/c648539b52ca28c0&quot;&gt;simple query planner optimization&lt;/a&gt; that allows the IS operator to drive an index on a LEFT OUTER JOIN. No other changes from the &lt;a href=&quot;#version_3_9_2&quot;&gt;version 3.9.2&lt;/a&gt; baseline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88c7762ebd772cef5a8b0f5dbf885740af02d796" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/docsrc&quot;&gt;https://www2.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3758d4866043fb72f7921be565221b2798bf18ec" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/src&quot;&gt;https://www2.sqlite.org/src&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5635a7bbe580f297d0f1cfe698eb39a60af249f7" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/th3&quot;&gt;https://www2.sqlite.org/th3&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354ff6f3afacd7c64aab0b45ca232e39fd5ab191" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/docsrc&quot;&gt;https://www3.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a437cf7f4394ac5ab3c8c6bf1f4decbf817f299c" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/src&quot;&gt;https://www3.sqlite.org/src&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b0bc099757fb937c2145628c4ebe2caf89fed6" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/th3&quot;&gt;https://www3.sqlite.org/th3&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad652023d4f99d0238bf9d42108eaead0a853d3a" translate="yes" xml:space="preserve">
          <source>Backup-filename</source>
          <target state="translated">Backup-filename</target>
        </trans-unit>
        <trans-unit id="8999e5aefef2d471c86fa4aebf649d22b2fddfc3" translate="yes" xml:space="preserve">
          <source>Backups on private servers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63591d4f03e6c8c8462a238e710f0f3cd900691f" translate="yes" xml:space="preserve">
          <source>Backwards compatibility constraints mean that SQLite is only able to store values that are NULL, integers, floating-point numbers, text, and BLOBs. It is not possible to add a sixth &quot;JSON&quot; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8e908309343005a016d54d23589bde15362521" translate="yes" xml:space="preserve">
          <source>Backwards compatibility note:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70457c51de59bc0303eae7ef527e14f90b80a187" translate="yes" xml:space="preserve">
          <source>Backwards-incompatible changes to some extensions in order to take advantage of the improved security offered by the new &lt;a href=&quot;bindptr&quot;&gt;pointer passing interfaces&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af928fbbb6d75554958505ba9734eca9710f8051" translate="yes" xml:space="preserve">
          <source>Bad programmers worry about the code. Good programmers worry about data structures and their relationships.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97ded08ec4df20e52b3ce05668bb0a2705fa978" translate="yes" xml:space="preserve">
          <source>Bare aggregate terms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2b9b9d48fdc95bbb5af1e6353dd4395e3738d9" translate="yes" xml:space="preserve">
          <source>Based on the above, SQLite is designed around a model of the file-system whereby any sector of a file written to is considered to be in a transient state until after the file has been successfully</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2843b17c6eb4616657b580040fb118c722f6edb6" translate="yes" xml:space="preserve">
          <source>Be a help in times of trouble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a6a5570deb3a7eb7ea55daa060ee1c39dbe74c" translate="yes" xml:space="preserve">
          <source>Be a stranger to the world's ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe99077b2a420989db9a6580456c2197461f868" translate="yes" xml:space="preserve">
          <source>Be careful when using the &quot;.save&quot; command as it will overwrite any preexisting database files having the same name without prompting for confirmation. As with the &quot;.open&quot; command, you might want to use a full pathname with forward-slash directory separators to avoid ambiguity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131acb5be798f8713c6bbeeaf8a6813dbe81748d" translate="yes" xml:space="preserve">
          <source>Be in dread of hell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbdb220ba30f3bde62d258265aacea82a8c9ef6a" translate="yes" xml:space="preserve">
          <source>Be not a detractor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18586b20264d29baf4b88bd2bdc140f64986d83" translate="yes" xml:space="preserve">
          <source>Be not a great eater.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c62076277d9f6b2639631bb528912ff4eff4ffa" translate="yes" xml:space="preserve">
          <source>Be not a grumbler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288a450b2fc66179cb51c9c9d0a00b7f03fc2121" translate="yes" xml:space="preserve">
          <source>Be not addicted to wine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d66a95d2dfd76a1e01a40e31a7daa8f6db0117" translate="yes" xml:space="preserve">
          <source>Be not drowsy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f81046cf302e1b08a651f45ee31005254461af" translate="yes" xml:space="preserve">
          <source>Be not jealous, nor harbor envy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5bf647a944160204f29d66b6480eda5640fcdc" translate="yes" xml:space="preserve">
          <source>Be not lazy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c899d6734a837258800bab2a2f7343b95199829" translate="yes" xml:space="preserve">
          <source>Be not proud.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9305ebf69b60c3d882da16805b530bbf3e6f3d95" translate="yes" xml:space="preserve">
          <source>Bear persecution for justice's sake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca5c28c37834244df00d49b68c2bef2606b1e1f" translate="yes" xml:space="preserve">
          <source>Because &quot;text&quot; columns have a different sort order from numeric, indices on &quot;text&quot; columns occur in a different order for version 2.7.0 and later database. Hence version 2.6.3 and earlier of SQLite will be unable to read a 2.7.0 or later database. But version 2.7.0 and later of SQLite will read earlier databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85eeb52404350645676cc7b1bb211e4acfd5ad5b" translate="yes" xml:space="preserve">
          <source>Because AUTOINCREMENT keyword changes the behavior of the ROWID selection algorithm, AUTOINCREMENT is not allowed on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or on any table column other than INTEGER PRIMARY KEY. Any attempt to use AUTOINCREMENT on a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table or on a column other than the INTEGER PRIMARY KEY column results in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb868502c2d293980db003c26a1d7e59cde0343" translate="yes" xml:space="preserve">
          <source>Because FTS3 and FTS4 are virtual tables, The &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt; compile-time option is incompatible with the &lt;a href=&quot;compile#omit_virtualtable&quot;&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/a&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4912d0649aa9ed8b2a285af375de29c2823b504b" translate="yes" xml:space="preserve">
          <source>Because Lemon is a program not normally found on development machines, the complete source code to Lemon (just one C file) is included in the SQLite distribution in the &quot;tool&quot; subdirectory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b4ac6aceecf052168be7879566274bb4b65047" translate="yes" xml:space="preserve">
          <source>Because ZIP archives are optimized for storing big chunks of content, they encourage a style of programming where the entire document is read into memory at startup, all editing occurs in memory, then the entire document is written to disk during &quot;File/Save&quot;. OpenOffice and its descendants embrace that pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aef204394eb2f42a054518ac1383e25f6308e7c" translate="yes" xml:space="preserve">
          <source>Because allocations are all the same size, the memory allocator can operate much faster. The allocator need not bother with coalescing adjacent free slots or searching for a slot of an appropriate size. All unallocated memory slots can be stored on a linked list. Allocating consists of removing the first entry from the list. Deallocating is simply adding an entry to the beginning of the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe792a90bccd6800bd67f3f37ebbaabb1467610" translate="yes" xml:space="preserve">
          <source>Because an SQLite database is a single compact file in a &lt;a href=&quot;fileformat2&quot;&gt;well-defined cross-platform format&lt;/a&gt;, it is often used as a container for transferring content from one system to another. The sender gathers content into an SQLite database file, transfers that one file to the receiver, then the receiver uses SQL to extract the content as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c1f92dc828402b18e6e117bb816b40d1c734ed" translate="yes" xml:space="preserve">
          <source>Because an SQLite database requires no administration, it works well in devices that must operate without expert human support. SQLite is a good fit for use in cellphones, set-top boxes, televisions, game consoles, cameras, watches, kitchen appliances, thermostats, automobiles, machine tools, airplanes, remote sensors, drones, medical devices, and robots: the &quot;internet of things&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788be5cf964c9ee21f08ece0ea7377ef2e19234d" translate="yes" xml:space="preserve">
          <source>Because assert() can be and is commonly misused, some programming language theorists and designers look upon it with disfavor. For example, the designers of the &lt;a href=&quot;https://golang.org&quot;&gt;Go programming language&lt;/a&gt; intentionally &lt;a href=&quot;https://golang.org/doc/faq#assertions&quot;&gt;omit a built-in assert()&lt;/a&gt;. They feel that the harm caused by misuse of assert() outweighs the benefits of including it as a language built-in. The SQLite developers disagree. In fact, the original purpose of this article is to push back against the common notion that assert() is harmful. In our experience, SQLite would be much more difficult to develop, test, and maintain without assert().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c8b76107dc390feb365087dd23a9e6847d8ec8" translate="yes" xml:space="preserve">
          <source>Because it does not have a central server to coordinate access, SQLite must close and reopen the database file, and thus invalidate its cache, for each transaction. In this test, each SQL statement is a separate transaction so the database file must be opened and closed and the cache must be flushed 1000 times. In spite of this, the asynchronous version of SQLite is still nearly as fast as MySQL. Notice how much slower the synchronous version is, however. SQLite calls &lt;b&gt;fsync()&lt;/b&gt; after each synchronous transaction to make sure that all data is safely on the disk surface before continuing. For most of the 13 seconds in the synchronous test, SQLite was sitting idle waiting on disk I/O to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c3dab6a322e3be0dd40f52ec50b7f7abadf611" translate="yes" xml:space="preserve">
          <source>Because it is a simulator, running a binary in Valgrind is slower than running it on native hardware. (To a first approximation, an application running in Valgrind on a workstation will perform about the same as it would running natively on a smartphone.) So it is impractical to run the full SQLite test suite through Valgrind. However, the veryquick tests and the coverage of the TH3 tests are run through Valgrind prior to every release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d7f244d51b1fc8bd92e3755f3ff4412ae2f2b57" translate="yes" xml:space="preserve">
          <source>Because it is simple to setup and use (installation is trivial: just copy the &lt;b&gt;sqlite3&lt;/b&gt; or &lt;b&gt;sqlite3.exe&lt;/b&gt; executable to the target machine and run it) SQLite makes a good database engine for use in teaching SQL. Students can easily create as many databases as they like and can email databases to the instructor for comments or grading. For more advanced students who are interested in studying how an RDBMS is implemented, the modular and well-commented and documented SQLite code can serve as a good basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8ea41ffd9236f49c6f3b48d5813c7ba03da82f" translate="yes" xml:space="preserve">
          <source>Because it reorganizes the entire FTS index, the optimize command can take a long time to run. The &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt; can be used to divide the work of optimizing the FTS index into multiple steps. To do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444393da5087c1cdc4456d5a26de8bf63b917b08" translate="yes" xml:space="preserve">
          <source>Because it stores extra information on disk in two new &lt;a href=&quot;fts3#*shadowtab&quot;&gt;shadow tables&lt;/a&gt; in order to support the performance optimizations and extra matchinfo() options, FTS4 tables may consume more disk space than the equivalent table created using FTS3. Usually the overhead is 1-2% or less, but may be as high as 10% if the documents stored in the FTS table are very small. The overhead may be reduced by specifying the directive &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; as part of the FTS4 table declaration, but this comes at the expense of sacrificing some of the extra supported matchinfo() options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b96b15368e6c99132d7d8a67a04e723712af54" translate="yes" xml:space="preserve">
          <source>Because lookaside allocations are always the same size, the allocation and deallocation algorithms are very quick. There is no need to coalesce adjacent free slots or search for a slot of a particular size. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; maintains a singly-linked list of unused slots. Allocation requests simply pull the first element of this list. Deallocations simply push the element back onto the front of the list. Furthermore, each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is assumed to already be running in a single thread (there are mutexes already in place to enforce this) so no additional mutexing is required to serialize access to the lookaside slot freelist. Consequently, lookaside memory allocations and deallocations are very fast. In speed tests on Linux and Mac OS X workstations, SQLite has shown overall performance improvements as high as 10% and 15%, depending on the workload how and lookaside is configured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668e105a1044bfeea3b1760bf6f04ba2a54183c0" translate="yes" xml:space="preserve">
          <source>Because main-memory is a limited resource, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc0f2ea6af2e7d5aa2876f1718288d4bc691129" translate="yes" xml:space="preserve">
          <source>Because of continuing security concerns, the two-argument version of of the seldom-used and little-known &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function is disabled unless SQLite is compiled with the &lt;a href=&quot;compile#enable_fts3_tokenizer&quot;&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e6d86d9770a8829aec592e59f4248ba67ce358" translate="yes" xml:space="preserve">
          <source>Because of its past success, AFL became a standard part of the testing strategy for SQLite beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;version 3.8.10&lt;/a&gt; (2015-05-07). Both SQL statements and database files are fuzzed. Billions and billions of mutations have been tried, but AFL's instrumentation has narrowed them down to less than 50,000 test cases that cover all distinct behaviors. Newly discovered test cases are periodically captured and added to the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; where they can be rerun using the &quot;make fuzztest&quot; or &quot;make valgrindfuzz&quot; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a2bab974445beaebfdcb0d2e216e6aab6976e2" translate="yes" xml:space="preserve">
          <source>Because of security concerns, the two-argument fts3_tokenizer() feature was disabled beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;Version 3.11.0&lt;/a&gt; (2016-02-15) unless this compile-time option is used. &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;Version 3.12.0&lt;/a&gt; (2016-03-29) added the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0) interface that activates the two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; for a specific &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at run-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90667c0d2f4c3f9e700d1a02bf683d36a408bbd8" translate="yes" xml:space="preserve">
          <source>Because of the behaviors described above, programmers are encouraged to prefer AFTER triggers over BEFORE triggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428b411cc0640abd27f1cf3a950377d2c4b5358f" translate="yes" xml:space="preserve">
          <source>Because of the potential disadvantages, memory-mapped I/O is disabled by default. To activate memory-mapped I/O, use the &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;mmap_size pragma&lt;/a&gt; and set the mmap_size to some large number, usually 256MB or larger, depending on how much address space your application can spare. The rest is automatic. The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will be a silent no-op on systems that do not support memory-mapped I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4a67ca1996129326c7f0bddce34637e22bf4f7" translate="yes" xml:space="preserve">
          <source>Because of these advantages, SQLite always tries to do a partial sort using an index even if a complete sort by index is not possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aff0a8b5eb6e0fbec96bd0626840af7bfdbee19" translate="yes" xml:space="preserve">
          <source>Because resetting a database is destructive and irreversible, the process requires the use of this obscure API and multiple steps to help ensure that it does not happen by accident.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b538eb844bddf9ea8a5b9a11872b1b61bfa979d" translate="yes" xml:space="preserve">
          <source>Because sorting can be expensive, SQLite works hard to convert ORDER BY clauses into no-ops. If SQLite determines that output will naturally appear in the order specified, then no sorting is done. So, for example, if you request the output in rowid order, no sorting will be done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e05ab9d98b3cd637f9791d810eeb3b04a00c42" translate="yes" xml:space="preserve">
          <source>Because the SQLite developers do not know whether the SQLITE_ENABLE_SORTER_REFERENCES option will help or hurt performance, it is disabled by default at this time (2018-05-04). It might be enabled by default in some future release, depending on what is learned about its impact on performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ba7f227189763df8625f3bee22f683d880802a" translate="yes" xml:space="preserve">
          <source>Because the completion table is built into the command-line shell in order to provide for tab-completions, you can run test queries against the completion table directly in the command-line shell. Simply type a query such as the example shown above, filling in appropriate values for $prefix and $wholeline, and observe the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8514da27bd50380cff29e01b5a61eb7772e130b" translate="yes" xml:space="preserve">
          <source>Because the content of leaf freelist pages is unimportant, SQLite avoids storing leaf freelist page content in the rollback journal in &lt;a href=&quot;#section_3_5&quot;&gt;step 3.5&lt;/a&gt; of the commit process. If a leaf freelist page is changed and that change does not get rolled back during a transaction recovery, the database is not harmed by the omission. Similarly, the content of a new freelist page is never written back into the database at &lt;a href=&quot;#section_3_9&quot;&gt;step 3.9&lt;/a&gt; nor read from the database at &lt;a href=&quot;#section_3_3&quot;&gt;step 3.3&lt;/a&gt;. These optimizations can greatly reduce the amount of I/O that occurs when making changes to a database file that contains free space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09f5109878254b678ca47d639d75e4bf226a1da" translate="yes" xml:space="preserve">
          <source>Because the indexed documents themselves are usually much larger than the full-text index, the content option can be used to achieve significant space savings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761cb8246ba69558ca8aeb80b8dbab8c62f5efed" translate="yes" xml:space="preserve">
          <source>Because the left-most column of the index does not appear in the WHERE clause of the query, one is tempted to conclude that the index is not usable here. But SQLite is able to use the index. Conceptually, SQLite uses the index as if the query were more like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a128485eb3a76806acc833997f2bb0ca8f3bab85" translate="yes" xml:space="preserve">
          <source>Because the non-primary key &quot;old.*&quot; fields are omitted, no SQLITE_CHANGESET_DATA conflicts can be detected or reported if a patchset is passed to the sqlite3changeset_apply() API. Other conflict types work in the same way as for changesets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e558ba54b31e234aa1a29ff45d5a07a13c1806f" translate="yes" xml:space="preserve">
          <source>Because the pointer is passed in the t1 column of the t1 table as a BLOB (in older versions of SQLite), such a query would have shown the value of the pointer in hex. The attacker could then modify that pointer to try to get the snippet() function to modify memory in some other part of the application address space instead of the fts3cursor object it was supposed to be operating on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ea5223eef09f4a78746e1785e07a1242a94565" translate="yes" xml:space="preserve">
          <source>Because the same query could be written without the use of row values, row values do not provide new capabilities. However, many developers say that the row value format is easier to read, write, and debug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8629347e97d2900d75943390265d789337dab5" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;../c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d755c27985069d9c58f3f925b7f20c86ab3fc1d" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc547a5fb4644ceebfd077fa4efa0549df654d8" translate="yes" xml:space="preserve">
          <source>Because the shm file is not involved in recovery, the shm file does not need to be machine byte-order independent. Hence, numeric values in the shm file are written in the native byte order of the host computer, rather than being converted into a specific cross-platform byte order as is done with the main database file and the wal file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d0b82e26ee2d676d928a1d7402d5916fc2656a" translate="yes" xml:space="preserve">
          <source>Because the shm is only used to coordinate access between concurrent clients, the shm file is omitted if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, as an optimization. When &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, SQLite uses heap memory in place of the memory-mapped shm file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da09f02d441cbe1ccd49c9803ec08e4160143a9" translate="yes" xml:space="preserve">
          <source>Because there is no cross-platform way to specify 64-bit integer types SQLite includes typedefs for 64-bit signed and unsigned integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5873520ec115c715db00ab0ac94f393f103400" translate="yes" xml:space="preserve">
          <source>Before SQLite can write to a database, it must first read the database to see what is there already. Even if it is just appending new data, SQLite still has to read in the database schema from the &lt;b&gt;sqlite_master&lt;/b&gt; table so that it can know how to parse the INSERT statements and discover where in the database file the new information should be stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccacc0177cbd2ba716b19132f920379d439772e2" translate="yes" xml:space="preserve">
          <source>Before a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement can be run, the module specified in that statement must be registered with the database connection. This is accomplished using either of the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c589001febca68c36ef8079ff9faca5b3d4efc6b" translate="yes" xml:space="preserve">
          <source>Before a new auxiliary function or tokenizer implementation may be registered with FTS5, an application must obtain a pointer to the &quot;fts5_api&quot; structure. There is one fts5_api structure for each database connection with which the FTS5 extension is registered. To obtain the pointer, the application invokes the SQL user-defined function fts5() with a single argument. That argument must be set to a pointer to a pointer to an fts5_api object using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface. The following example code demonstrates the technique:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae8b38a31b33865e805e86015a35fae53d45a85" translate="yes" xml:space="preserve">
          <source>Before any database pages may be modified within the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aafeb2e2bb5cf3269cb7e705f038008b263f110" translate="yes" xml:space="preserve">
          <source>Before any information-bearing page of the database is modified, the original unmodified content of that page is written into the rollback journal. If a transaction is interrupted and needs to be rolled back, the rollback journal can then be used to restore the database to its original state. Freelist leaf pages bear no information that would need to be restored on a rollback and so they are not written to the journal prior to modification, in order to reduce disk I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31e39238fffa8a7d3425c769271d3112873aa6f" translate="yes" xml:space="preserve">
          <source>Before calling this method, the SQLite core initializes an instance of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure with information about the query that it is currently trying to process. This information derives mainly from the WHERE clause and ORDER BY or GROUP BY clauses of the query, but also from any ON or USING clauses if the query is a join. The information that the SQLite core provides to the xBestIndex method is held in the part of the structure that is marked as &quot;Inputs&quot;. The &quot;Outputs&quot; section is initialized to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b6c291315b8e1fb3f265c15e369937b630aaf5" translate="yes" xml:space="preserve">
          <source>Before data may be read from a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae7b06f8fadf1f8b2bbb51c0629366481aebe32" translate="yes" xml:space="preserve">
          <source>Before entering a trigger program the value returned by sqlite3_changes() function is saved. After the trigger program has finished, the original value is restored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7968bdea3fbca698f15e058c3369cb48f81fd4ca" translate="yes" xml:space="preserve">
          <source>Before executing a statement that modifies the database schema (i.e. a CREATE or DROP TABLE statement), a connection must obtain a write-lock on</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64443a5dc257f480bf4a79d829dcae9017cc971a" translate="yes" xml:space="preserve">
          <source>Before making changes to any page of the database, the process writes the original content of that page into the rollback journal. Changes to pages are held in memory at first and are not written to the disk. The original database file remains unaltered, which means that other processes can continue to read the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed294139e05d80e58de31e418d68f4cfaebeb6a7" translate="yes" xml:space="preserve">
          <source>Before making changes to the database, SQLite first obtains a &quot;reserved&quot; lock on the database file. A reserved lock is similar to a shared lock in that both a reserved lock and shared lock allow other processes to read from the database file. A single reserve lock can coexist with multiple shared locks from other processes. However, there can only be a single reserved lock on the database file. Hence only a single process can be attempting to write to the database at one time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b64dbebb4ad46a9aeb1a098c15aadd4e3eaf44" translate="yes" xml:space="preserve">
          <source>Before modifying a database page within the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e0ccf77dc018ac7ea18b90477a40f1a7c510fa" translate="yes" xml:space="preserve">
          <source>Before opening a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6822a9cef8f0664c32cddfaac23e4bff41485b02" translate="yes" xml:space="preserve">
          <source>Before reading from a database file, SQLite always checks to see if that database file has a hot journal. If the file does have a hot journal, then the journal is rolled back before the file is read. In this way, we ensure that the database file is in a consistent state before it is read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffabc9625263621654187c58d31675c59e6730d" translate="yes" xml:space="preserve">
          <source>Before the content of a page modified within the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a76187aef00ad8a5abadfac889a6b98dd1db2fb" translate="yes" xml:space="preserve">
          <source>Before the contents of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f97138118a317cbc3bf1e3e8dd4c6fd1edd23a0" translate="yes" xml:space="preserve">
          <source>Before we begin looking at this problem, let's briefly review how queries work in SQLite so that we will know what we are trying to accomplish. For each row in the result of a query, SQLite will invoke a callback function with the following prototype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c00a0d3ea5cf97be2cbc8e0c749bfff4206bbf5" translate="yes" xml:space="preserve">
          <source>Begin a transaction on database P1 if a transaction is not already active. If P2 is non-zero, then a write-transaction is started, or if a read-transaction is already active, it is upgraded to a write-transaction. If P2 is zero, then a read-transaction is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd194a93ac6ccfaf40c7f7cd5a992cb067293a7" translate="yes" xml:space="preserve">
          <source>Begin adding lots of new documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c994ef269c7ca4806cc0aace7ca7e97ba28671" translate="yes" xml:space="preserve">
          <source>Begin by obtaining a copy of SQLite in whatever form you use it. The public SQLite you obtain should be as close to your private edited copy as possible. If your project uses the SQLite amalgamation, then get a copy of the amalgamation. If you use the preprocessed separate source files, get those instead. Put all the source files in the checkout directory created in the previous step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95a84f6810e9547323b7d36381036499b6e85a2" translate="yes" xml:space="preserve">
          <source>Begin enforcing &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvdbeop&quot;&gt;SQLITE_LIMIT_VDBE_OP&lt;/a&gt;. This can be used, for example, to prevent excessively large prepared statements in systems that accept SQL queries from untrusted users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5e2f03338f65ea55efadd743c2073f0844124d" translate="yes" xml:space="preserve">
          <source>Begin every identifier with the letter &quot;Z&quot; as no SQL keywords start with &quot;Z&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c9b7ac07f4b963268a3915518a82c60026c1c8" translate="yes" xml:space="preserve">
          <source>Begin writing documentation on the TCL interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93624195948cab4e3c3cf8a06c4ba66150434ee" translate="yes" xml:space="preserve">
          <source>Begin writing the &lt;a href=&quot;vdbe&quot;&gt;VDBE tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2891bac57361d1d80487ccfbba99ba09325df3b5" translate="yes" xml:space="preserve">
          <source>Beginning a Write Transaction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60eca843fdd7093ad8665839ef32416ade71c639" translate="yes" xml:space="preserve">
          <source>Beginning in 2016, a team of engineers at Google started the &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS Fuzz&lt;/a&gt; project. OSS Fuzz uses a AFL-style guided fuzzer running on Google's infrastructure. The Fuzzer automatically downloads the latest check-ins for participating projects, fuzzes them, and sends email to the developers reporting any problems. When a fix is checked in, the fuzzer automatically detects this and emails a confirmation to the developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ddec92a44c4044495e3a4272f88fb5bf0d2787" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14), an assignment in the SET clause can be a &lt;a href=&quot;syntax/column-name-list&quot;&gt;parenthesized list of column names&lt;/a&gt; on the left and a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the same size on the right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0744464084ddf340ea6c6e0a24aad6d9c12c18" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_4.html&quot;&gt;version 3.6.4&lt;/a&gt; (2008-10-15), the TRUNCATE journal mode is also supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adac7327da12129344605aed8c6230ec2a45b5c" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;version 3.7.4&lt;/a&gt; (2010-12-07), WAL databases can be created, read, and written even if shared memory is unavailable as long as the &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE before the first attempted access. In other words, a process can interact with a WAL database without using shared memory if that process is guaranteed to be the only process accessing the database. This feature allows WAL databases to be created, read, and written by legacy &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; that lack the &quot;version 2&quot; shared-memory methods xShmMap, xShmLock, xShmBarrier, and xShmUnmap on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f100a899b26537fc63caa4230653ce9716130e4" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite version 3.5.0, the new Virtual File System (VFS) interface contains a method named xDeviceCharacteristics which reports on special properties that the underlying mass storage device might have. Among the special properties that xDeviceCharacteristics might report is the ability of to do an atomic sector write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe6df39f8d021809fb2ab3e47422b19fa74d670" translate="yes" xml:space="preserve">
          <source>Beginning in late 2018, SQLite has been fuzzed using a new proprietary fuzzer called &quot;dbsqlfuzz&quot;. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f6d3a3a096224887296bd514258ca7ceae764c" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), SQLite supports a new transaction control mechanism called &quot;&lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&quot;. When a database is in WAL mode, all connections to that database must use the WAL. A particular database will use either a rollback journal or a WAL, but not both at the same time. The WAL is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; appended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9839d2cef57fa5d151a0ce9cbe15a6e0c36fbc7" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), SQLite has the option of accessing disk content directly using memory-mapped I/O and the new xFetch() and xUnfetch() methods on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a395622db69c8b77803fcd06e3a2c5d4cdefa3" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23), the SQLite database file argument to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces and to the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command can be specified either as an ordinary filename or as a Uniform Resource Identifier or URI. The advantage of using a URI filename is that query parameters on the URI can be used to control details of the newly created database connection. For example, an alternative &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can be specified using a &quot;vfs=&quot; query parameter. Or the database can be opened read-only by using &quot;mode=ro&quot; as a query parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b26610830584adfe4c3b1f430311725c505dc65" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14) SQLite uses &lt;a href=&quot;http://semver.org&quot;&gt;semantic versioning&lt;/a&gt;. Prior to that time, SQLite employed a version identifier that contained between two and four numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a7a785dc79c6f97e7e9b629f10c98e7d6eaa12" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite 3.23.0 (2018-04-02), SQLite recognizes the identifiers &quot;TRUE&quot; and &quot;FALSE&quot; as boolean literals, if and only if those identifiers are not already used for some other meaning. If there already exists columns or tables or other objects named TRUE or FALSE, then for the sake of backwards compatibility, the TRUE and FALSE identifiers refer to those other objects, not to the boolean values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e27a2a72ed98b30f89096b193da3e3a912285cdd" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06), the unix OS interface will attempt to resolve symbolic links and open the database file by its canonical name. Prior to version 3.10.0, opening a database file through a symbolic link was similar to opening a database file that had multiple hard links and resulted in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669009bffd329a7525e12f992041efbc93a9e4fc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_14.html&quot;&gt;version 3.14.0&lt;/a&gt; (2016-08-08), the CREATE TABLE statement that is passed into &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; may contain a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; clause. This is useful for cases where the virtual table rows cannot easily be mapped into unique integers. A CREATE TABLE statement that includes WITHOUT ROWID must define one or more columns as the PRIMARY KEY. Every column of the PRIMARY KEY must individually be NOT NULL and all columns for each row must be collectively unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="914fd4075646f327da4b592c31312990facc6a8d" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02), SQLite also recognizes TRUE and FALSE keywords as aliases for integer values 1 and 0, respectively. This provides better compatibility with other SQL implementations. But to retain backwards compatibility, if there are columns named TRUE or FALSE, then the keywords are treated as identifiers referencing those columns, rather than BOOLEAN literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f2cb99d27921b6ac8152e7a3c891a53596352b" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11), shared cache can be used on &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt;, provided that the database is created using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For backwards compatibility, shared cache is always disable for in-memory databases if the unadorned name &quot;:memory:&quot; is used to open the database. Prior to version 3.7.13, shared cache was always disabled for in-memory databases regardless of the database name used, current system shared cache setting, or query parameters or flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d897fef3b918d90f462942b797bcba2f181cd38" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file has multiple hard links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa120398347f1152da8e84a3905c5d3c58c3466" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file is unlinked while it is still in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4af8bd16f5f6dcf0575ed25d9da5ad7a3cecfc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0dfecc63fffa644348dc3e00941cc0dedd6014a" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c179ab3e7d04af330c7efc2cec123a479ee926c3" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.24.0 (2018-06-04), r-tree tables can have auxiliary columns that store arbitrary data. Auxiliary columns can be used in place of secondary tables such as &quot;demo_data&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d8128996ffada537e69bde476b38bfd6abdaaa" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.3.14 a mechanism has been added to try to reduce the needless rereading of data. In newer versions of SQLite, the data in the user-space pager cache is retained when the lock on the database file is released. Later, after the shared lock is acquired at the beginning of the next transaction, SQLite checks to see if any other process has modified the database file. If the database has been changed in any way since the lock was last released, the user-space cache is erased at that point. But commonly the database file is unchanged and the user-space cache can be retained, and some unnecessary read operations can be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0eba5a240e8bc3220e00f595afb167768fa6cb7" translate="yes" xml:space="preserve">
          <source>Beginning with release 3.25.0 (2018-09-15), references to the table within trigger bodies and view definitions are also renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d654ce8d1a877b686fbd470426c428e02c9409c6" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.2.0, SQLite no longer builds an index for an INTEGER PRIMARY KEY column. Instead, it uses that column as the actual B-Tree key for the main table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042e0229fee0d8bfed5724fa18cd980bad0c1945" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.3.0, SQLite supports some additional syntax (the &quot;ON CONFLICT&quot; clause) in the CREATE TABLE and CREATE INDEX statements that are stored in the SQLITE_MASTER table. If you create a database that contains this new syntax, then try to read that database using version 2.2.5 or earlier, the parser will not understand the new syntax and you will get an error. Otherwise, databases for 2.2.x and 2.3.x are interchangeable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9bdf31e2f633cc8ef293e098f7f5d722da8a2a8" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite added support for views. Information about views is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains VIEW information in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail. Also, the way SQLite keeps track of unused disk blocks in the database file changed slightly. If an older version of SQLite attempts to write a database that was previously written by version 2.4.0 or later, then it may leak disk blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413008ed4f165a3aca53c2fe0890bace8386a170" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite allows the SQL language to be extended with new functions implemented as C code. The following interface is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dad8b696b630a32cf19067fe14052c10b2bac25" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.5.0, SQLite added support for triggers. Information about triggers is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains a CREATE TRIGGER in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c1ec93a00d0cbe5badad130d3d4fbd2db53937" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.7.0, SQLite understands two different datatypes: text and numeric. Text data sorts in memcmp() order. Numeric data sorts in numerical order if it looks like a number, or in memcmp() order if it does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06e002a374c4a8233bf3048a5c902a5ad629404" translate="yes" xml:space="preserve">
          <source>Beginning with version 3.5, SQLite obtains all of the heap memory it needs using the routines &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;. These routines have existed in prior versions of SQLite, but SQLite has previously bypassed these routines and used its own memory allocator. This all changes in version 3.5.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb8a180b3917332f0d153bfa0ea4cd9cfa4625e" translate="yes" xml:space="preserve">
          <source>Behavior when page is not already in cache</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f48bb3f768498f6c1f4331bb2d5a6b0f760fe90" translate="yes" xml:space="preserve">
          <source>Below is a simple &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL program&lt;/a&gt; that demonstrates how to use the TCL interface to SQLite. The program executes the SQL statements given as the second argument on the database defined by the first argument. The commands to watch for are the &lt;b&gt;sqlite3&lt;/b&gt; command on line 7 which opens an SQLite database and creates a new object named &quot;&lt;b&gt;db&lt;/b&gt;&quot; to access that database, the use of the &lt;a href=&quot;tclsqlite#eval&quot;&gt;eval method&lt;/a&gt; on the &lt;b&gt;db&lt;/b&gt; object on line 8 to run SQL commands against the database, and the closing of the database connection on the last line of the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e427c04349f8bec5760358d6c76a33f48f0315" translate="yes" xml:space="preserve">
          <source>Below is a simple C program that demonstrates how to use the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ interface&lt;/a&gt; to SQLite. The name of a database is given by the first argument and the second argument is one or more SQL statements to execute against the database. The function calls to pay attention to here are the call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; on line 22 which opens the database, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; on line 28 that executes SQL commands against the database, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on line 33 that closes the database connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ff95327015619a83afc17706ad74370a046f84" translate="yes" xml:space="preserve">
          <source>Benefits of SQLite As A File Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616211207d8aaf668be94882f808c6f4c9f8f380" translate="yes" xml:space="preserve">
          <source>Benefits of using WITHOUT ROWID</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115df5f31354f3b89a7926f5d6643866714998ab" translate="yes" xml:space="preserve">
          <source>Better Applications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f38499da00d33476ac2d33142547447ccd5f2e2" translate="yes" xml:space="preserve">
          <source>Better detection and handling of corrupt database files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add6069aec6aedde19e26e2f4dc8b5d52557685c" translate="yes" xml:space="preserve">
          <source>Better error reporting when problems occur during the automatic 2.5.6 to 2.6.0 database format upgrade.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0db7dca50a13779a4f0032e6c97723feb41348" translate="yes" xml:space="preserve">
          <source>Better handling of aggregate queries where the aggregate functions are contained within subqueries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da084dd71de733c50c5b48104f01706c6f95c252" translate="yes" xml:space="preserve">
          <source>Better labels on column names of the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03681c8056a98d5199927eacf80bcf86a612f164" translate="yes" xml:space="preserve">
          <source>Better optimization of some IN operator expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591ea8e488260fd421c2b234d660007536c8a620" translate="yes" xml:space="preserve">
          <source>Better support for file locking so that two or more processes (or threads) can access the same database simultaneously. More work needed in this area, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfa329825b8b1d38ad9507f28f42ef4366de8b4" translate="yes" xml:space="preserve">
          <source>Between them, the contents of the &quot;level&quot; and &quot;idx&quot; fields define the relative age of the segment b-tree. The smaller the value stored in the &quot;level&quot; field, the more recently the segment b-tree was created. If two segment b-trees are of the same &quot;level&quot;, the segment with the larger value stored in the &quot;idx&quot; column is more recent. The PRIMARY KEY constraint on the %_segdir table prevents any two segments from having the same value for both the &quot;level&quot; and &quot;idx&quot; fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a826f46e213d85c4e2bac37d6cf8440b8e199d0" translate="yes" xml:space="preserve">
          <source>Beware of deleting persistent journal files by any other means since the journal file might be hot, in which case deleting it will corrupt the corresponding database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb96cbd05d1971e3d28050245a8829dd6b6aafd2" translate="yes" xml:space="preserve">
          <source>Binary operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ac1eab329712a8a9c96ce99d077a92e950ad90" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d99e3f4d2a89e533a8c574a3feaf717d81ec03" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1661e468dacca4fb2103651a60de473fcaf35b" translate="yes" xml:space="preserve">
          <source>Binding Values To Prepared Statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416ca5a10db41c1cbc8b3d0b2abf3f34e937f4af" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712e7456596b23817bd39e4145191dbf11698c78" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309af9e25956170a810f78e3c71afc45e9766ccf" translate="yes" xml:space="preserve">
          <source>BitAnd</source>
          <target state="translated">BitAnd</target>
        </trans-unit>
        <trans-unit id="0c26c52f02ad0e8a5ab4b7954c846a924ecffb7e" translate="yes" xml:space="preserve">
          <source>BitNot</source>
          <target state="translated">BitNot</target>
        </trans-unit>
        <trans-unit id="f64578ede789cb16c75f551e17bc358c839da2a7" translate="yes" xml:space="preserve">
          <source>BitOr</source>
          <target state="translated">BitOr</target>
        </trans-unit>
        <trans-unit id="c24315eb20cc1f5a565ec08f29abab31c0925f1a" translate="yes" xml:space="preserve">
          <source>Blob</source>
          <target state="translated">Blob</target>
        </trans-unit>
        <trans-unit id="d309b3faf2ef71b6ca2ba079fca1c0074e7599d4" translate="yes" xml:space="preserve">
          <source>Blob containing the root node of the segment b-tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d284e53d53a1c613b92c33b3c974704b23b2a857" translate="yes" xml:space="preserve">
          <source>Block until the unlock-notify callback is invoked by another thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ac379f83771407fb1e0d78aaf3f7b5adc6706f" translate="yes" xml:space="preserve">
          <source>Boolean Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e413aea96ae1ca804567104303036969e3a88f" translate="yes" xml:space="preserve">
          <source>Boolean datatype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb72c24cf8f622cb6c601ea54b18c1fb6181c3db" translate="yes" xml:space="preserve">
          <source>Boolean expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275cc7006db94d75505db825dc5542aed9bfc26c" translate="yes" xml:space="preserve">
          <source>Borland</source>
          <target state="translated">Borland</target>
        </trans-unit>
        <trans-unit id="2198db2aa3b167004c136853d6cdd281fb62f84a" translate="yes" xml:space="preserve">
          <source>Borland Interbase does not support CASE expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddec281bbecd09ca0988545c1af57dbffaa268c1" translate="yes" xml:space="preserve">
          <source>Both UPDATE statements do exactly the same thing. (They generate identical &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt;.) But the first form, the row value form, seems to make it clearer that the intent of the statement is to swap the values in columns A and B.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dfb4c7d44434c0c4d4db97610721023fe7e4509" translate="yes" xml:space="preserve">
          <source>Both forms of the CASE expression use lazy, or short-circuit, evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb63583b07e5e464e63e50a8a4cb32ce2f9c5978" translate="yes" xml:space="preserve">
          <source>Both methods for loading an extension allow you to specify the name of an entry point for the extension. You can leave this argument blank - passing in a NULL pointer for the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language interface or omitting the second argument for the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL interface - and the extension loader logic will attempt to figure out the entry point on its own. It will first try the generic extension name &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a entry point using the template &quot;sqlite3_X_init&quot; where the X is replaced by the lowercase equivalent of every ASCII character in the filename after the last &quot;/&quot; and before the first following &quot;.&quot; omitting the first three characters if they happen to be &quot;lib&quot;. So, for example, if the filename is &quot;/usr/lib/libmathfunc-4.8.so&quot; the entry point name would be &quot;sqlite3_mathfunc_init&quot;. Or if the filename is &quot;./SpellFixExt.dll&quot; then the entry point would be called &quot;sqlite3_spellfixext_init&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d91ab9fdfa652980c96ceff09049c0ea85b3c70" translate="yes" xml:space="preserve">
          <source>Both of the RBU functions may be accomplished using SQLite's built-in SQL commands - RBU update via a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands within a single transaction, and RBU vacuum by a single &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. The RBU module provides the following advantages over these simpler approaches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f6600d4e5a9c39fa518762238ad90dd63b65fb" translate="yes" xml:space="preserve">
          <source>Both of the above example queries would work fine without the acctchng_magnitude index. The acctchng_magnitude index index merely helps the queries to run faster, especially on databases where there are many entries in the table for each account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2132ed90a9ffb07d66917a3fc0b34d8d92cac4" translate="yes" xml:space="preserve">
          <source>Both the TCL and TH3 test harnesses automatically track system resources and report resource leaks on &lt;u&gt;every&lt;/u&gt; test run. No special configuration or setup is required. The test harnesses are especially vigilant with regard to memory leaks. If a change causes a memory leak, the test harnesses will recognize this quickly. SQLite is designed to never leak memory, even after an exception such as an OOM error or disk I/O error. The test harnesses are zealous to enforce this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad3d82720f17203691deee7f5777d99c121ae33" translate="yes" xml:space="preserve">
          <source>Both the WHEN clause and the trigger actions may access elements of the row being inserted, deleted or updated using references of the form &quot;NEW.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f093637993a88624b64eec10be0614efea759e81" translate="yes" xml:space="preserve">
          <source>Both the pointer and the pointer type parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; interfaces are &quot;owned&quot; by the caller. In other words, the caller is responsible for ensuring that both values remain valid until after the last access via &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2992a96404e75efb9d5d247c72b5e6d63bb4aa3e" translate="yes" xml:space="preserve">
          <source>Boundary value tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3145fd01726b003b2b97b5a9fb483277f3a90dd2" translate="yes" xml:space="preserve">
          <source>Branch coverage in SQLite is currently measured using &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; with the &quot;-b&quot; option. First the test program is compiled using options &quot;-g -fprofile-arcs -ftest-coverage&quot; and then the test program is run. Then &quot;gcov -b&quot; is run to generate a coverage report. The coverage report is verbose and inconvenient to read, so the gcov-generated report is processed using some simple scripts to put it into a more human-friendly format. This entire process is automated using scripts, of course.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4adfe3c542d88432092f783bc046835df0fe815" translate="yes" xml:space="preserve">
          <source>Branch coverage is more rigorous than statement coverage. Branch coverage measures the number of machine-code branch instructions that are evaluated at least once on both directions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22b75ea309c645c4530e03f4541cb259f2d61c7" translate="yes" xml:space="preserve">
          <source>Branch coverage is more strict. With branch coverage, each test and each subblock within the statement is considered separately. In order to achieve 100% branch coverage in the example above, there must be at least three test cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c730065aaff2da27316c3a4fdb27f33630fd48" translate="yes" xml:space="preserve">
          <source>Break out the &quot;Presentor Notes&quot; from each slide into a separate table, for easier access from third-party applications and/or scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53bff6ff25ebaccf14a4078fdb0261d0ccc01ee" translate="yes" xml:space="preserve">
          <source>Break out the GDBM driver into a separate file in anticipation to added new drivers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282c5dfb378bb6abed7a208812bdb6a15f29a876" translate="yes" xml:space="preserve">
          <source>Bring the OS/2 porting layer up-to-date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e575ff594a72cfcaccd19ccbf9ad35b704bb47" translate="yes" xml:space="preserve">
          <source>Bring the processing of ORDER BY into compliance with the SQL standard for case where a result alias and a table column name are in conflict. Correct behavior is to prefer the result alias. Older versions of SQLite incorrectly picked the table column. (See ticket #2822.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f04fd57f5bfebe96a862aebe73b135def3ab6df" translate="yes" xml:space="preserve">
          <source>Bug fix in the processing of the ORDER BY clause for GROUP BY queries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a725ca76655ec9003bb82b1a676029a85c0e7d07" translate="yes" xml:space="preserve">
          <source>Bug fix: &quot;SELECT count(*)&quot; was returning NULL for empty tables. Now it returns 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e476047ffbbf1baca852a2317f6d224dd2d875a" translate="yes" xml:space="preserve">
          <source>Bug fix: Add in a mutex that was omitted from the previous release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7e0eb1f7494f905f4da13b15772e1fb07bbe1e" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing if &quot;PRAGMA full_column_names=ON;&quot; was set and you did a query that used a rowid, like this: &quot;SELECT rowid, * FROM ...&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421117f09c1ef6c1c766b17bffc8c48c0d11cebc" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing when a temporary table with an index had the same name as a permanent table created by a separate process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dceede8b9155b23f776e96cfdf9ce26f1c18497" translate="yes" xml:space="preserve">
          <source>Bug fix: An attempt to delete a single row of a table with a WHERE clause of &quot;ROWID=x&quot; when no such rowid exists was causing an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faaa0c6caea2e40fd936178cd8a1148168d7f164" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid a deadlock or crash if the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;, &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, and the SQLite Encryption Extension are all used at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9851f7cc2ef1b47f1ede36a70787a28d8a73936" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid leaking memory on LIMIT and OFFSET clauses in deeply nested UNION ALL queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb351871f180a85fd09c35dd04ce4b51eee599a0" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid segfault when using the &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; inside of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a618ecebefb94412f1562472983ff94e3605eaab" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid various concurrency problems in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633b128d954ff36563e10076bd92bfc7d4d254bc" translate="yes" xml:space="preserve">
          <source>Bug fix: Bare identifiers in ORDER BY clauses bind more tightly to output column names, but identifiers in expressions bind more tightly to input column names. Identifiers in GROUP BY clauses always prefer output column names, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a402a829e3faf4148ff927e5cc1ab64a56cfa4a" translate="yes" xml:space="preserve">
          <source>Bug fix: Column names in the result set were not being generated correctly for some (rather complex) VIEWs. This could cause a segfault under certain circumstances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6507d4034fca406ed1e6de7d9c69eb86666298e" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute correct table names with the FULL_COLUMN_NAMES pragma is turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d170d4831a6701524951017930d51215c0de3ceb" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute the correct answer for queries that contain an IS NOT NULL term in the WHERE clause and also contain an OR term in the WHERE clause and are compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;. &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;Ticket [4c86b126f2]&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
