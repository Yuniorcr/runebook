<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="en" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="82877b639e06578b26b7b6487eda6b76c0a0e3c6" translate="yes" xml:space="preserve">
          <source>Some &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements do their work during sqlite3_prepare() rather than during sqlite3_step(). Those PRAGMA statements are unaffected by EXPLAIN. They operate the same with or without the EXPLAIN prefix. The set of PRAGMA statements that are unaffected by EXPLAIN can vary from one release to the next. Some PRAGMA statements operate during sqlite3_prepare() depending on their arguments. For consistent results, avoid using EXPLAIN on PRAGMA statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5732042dba5cf74de37a47838012719f36ee8111" translate="yes" xml:space="preserve">
          <source>Some Example Triggers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2da6518510111d1ca6bc33d2d1e98dff9548bb8" translate="yes" xml:space="preserve">
          <source>Some SQL database engines provide non-standard &quot;hint&quot; mechanisms which can be used to give the query optimizer clues about what indices it should use for a particular statement. The INDEX BY clause of SQLite is &lt;em&gt;not&lt;/em&gt; a hinting mechanism and it should not be used as such. The INDEXED BY clause does not give the optimizer hints about which index to use; it gives the optimizer a requirement of which index to use. If the query optimizer is unable to use the index specified by the INDEX BY clause, then the query will fail with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf443b96f0d9f6eac4bc80a9c5c544e6d64bd31" translate="yes" xml:space="preserve">
          <source>Some commentators say that SQLite is &quot;weakly typed&quot; and that other SQL databases are &quot;strongly typed&quot;. We consider these terms to be inaccurate and pejorative. We prefer to say that SQLite is &quot;flexibly typed&quot; and that other SQL databases are &quot;rigidly typed&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa0bb5b46a56bce712735328de2ecfd7898dd9a" translate="yes" xml:space="preserve">
          <source>Some devices are compelled to use an older filesystem with 8+3 filename restrictions for backwards compatibility, or due to other non-technical factors. In such situations, SQLite can be coerced into using auxiliary files that fit the 8+3 pattern as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a4bdb9a86e43ef62782dbb2803e2ef7fef0a7a" translate="yes" xml:space="preserve">
          <source>Some example, cost table entries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9234854e8f0cb7e3b23fa0273a95bcc8f4a8eaf9" translate="yes" xml:space="preserve">
          <source>Some examples will help illustrate the difference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31941b285d3264077d66c50c29fee18d7a8c1f66" translate="yes" xml:space="preserve">
          <source>Some freelist pages contain critical data; specifically the locations of other freelist pages. But most freelist pages contain nothing useful. These latter freelist pages are called &quot;leaf&quot; pages. We are free to modify the content of a leaf freelist page in the database without changing the meaning of the database in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4f98671a50a0a922d51c622597741cdfcd893a" translate="yes" xml:space="preserve">
          <source>Some future versions of SQLite may change to enable this feature by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc7150370b1275da7b22e0b3c0daa34955ce5a3" translate="yes" xml:space="preserve">
          <source>Some limits can be changed at run-time on a per-connection basis using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface with one of the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;limit categories&lt;/a&gt; defined for that interface. Run-time limits are designed for applications that have multiple databases, some of which are for internal use only and others which can be influenced or controlled by potentially hostile external agents. For example, a web browser application might use an internal database to track historical page views but have one or more separate databases that are created and controlled by javascript applications that are downloaded from the internet. The &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface allows internal databases managed by trusted code to be unconstrained while simultaneously placing tight limitations on databases created or controlled by untrusted external code in order to help prevent a denial of service attack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f0f8e3878344df85d2a4246c11bee1e47d7640" translate="yes" xml:space="preserve">
          <source>Some older versions of Linux used the LinuxThreads library for thread support. LinuxThreads is similar to Pthreads, but is subtly different with respect to handling of POSIX advisory locks. SQLite versions 2.2.3 through 3.6.23 recognized that LinuxThreads were being used at runtime and took appropriate action to work around the non-standard behavior of LinuxThreads. But most modern Linux implementations make use of the newer, and correct, NPTL implementation of Pthreads. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), the use of NPTL is assumed. No checks are made. Hence, recent versions of SQLite will subtly malfunction and may corrupt database files if used in multi-threaded application that run on older linux systems that make use of LinuxThreads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bef87b7bc572b2934b8ea6d4c58c70ed7dd3633" translate="yes" xml:space="preserve">
          <source>Some older versions of SQLite (prior to version 2.4.0) would show decreasing performance after a sequence of DELETEs followed by new INSERTs. As this test shows, the problem has now been resolved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52125a8361f282383783887e4dc2c4cfed4a215d" translate="yes" xml:space="preserve">
          <source>Some opcodes are self-altering. For example, the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (which is always the first opcode run a bytecode program) increments its P1 operand. Subsequent &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes compare their P1 operands to the P1 value for the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode in order to determine if the one-time initialization code that follows should be skipped. Another example is the &lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt; opcode which converts its P4 operand from UTF-8 into the correct database string encoding, then converts itself into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="426e64b4a66f4f7807aa6667039b81573979fe2a" translate="yes" xml:space="preserve">
          <source>Some opcodes use all five operands. Some opcodes use one or two. Some opcodes use none of the operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b335ac36fb2d38cd00024b326c89df9316f364" translate="yes" xml:space="preserve">
          <source>Some or all of these restrictions may be removed in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b476a9e69a79b5371957fc7b1a40c95e375aeff4" translate="yes" xml:space="preserve">
          <source>Some other SQL database engines advise developers to store blobs in separate files and then store the filename in the database. In that case, where the database must first be consulted to find the filename before opening and reading the file, simply storing the entire blob in the database gives much faster read and write performance with SQLite. See the &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; article for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94448e3ce0b80c02ec3cf58a3a89e81bfc4e794" translate="yes" xml:space="preserve">
          <source>Some other database constraint, for example a UNIQUE or CHECK constraint, may be violated when the new row is inserted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87a22bd6e23f0cc806f999949a67d71c38a0517" translate="yes" xml:space="preserve">
          <source>Some other database constraint, for example a UNIQUE or CHECK constraint, may be violated when the row is updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a803eb726af2b55f4a3a45a5ec6b4038451fda8a" translate="yes" xml:space="preserve">
          <source>Some other ways in which FTS5 differs from FTS3/4 are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d6bed42aa0aeee6bb3a36da7e69907ed2fed99" translate="yes" xml:space="preserve">
          <source>Some people say that we should eliminate all warnings because benign warnings mask real warnings that might arise in future changes. This is true enough. But in reply, the developers observe that all warnings have already been fixed in the builds used for SQLite development (various versions of GCC, MSVC, and clang). Compiler warnings usually only arise from compilers or compile-time options that the SQLite developers do not use themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8711937cd8478cc6ecffffaffa9bef747431485f" translate="yes" xml:space="preserve">
          <source>Some people view RELEASE as the equivalent of COMMIT for a SAVEPOINT. This is an acceptable point of view as long as one remembers that the changes committed by an inner transaction might later be undone by a rollback in an outer transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7ab5e876e4a01802f6862f91dcb4e0c53f5563" translate="yes" xml:space="preserve">
          <source>Some pragmas take effect during the SQL compilation stage, not the execution stage. This means if using the C-language &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; API (or similar in a wrapper interface), the pragma may run during the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; call, not during the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call as normal SQL statements do. Or the pragma might run during sqlite3_step() just like normal SQL statements. Whether or not the pragma runs during sqlite3_prepare() or sqlite3_step() depends on the pragma and on the specific release of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b35f88ff5fdb19b220d3f1fb964fe543a7595b" translate="yes" xml:space="preserve">
          <source>Some programmers cannot imagine developing a complex system like SQLite in a language that is not &quot;object oriented&quot;. So why is SQLite not coded in C++ or Java?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34c6a5bd79eb90989f1ccbc7f5ec2a47398a0d5" translate="yes" xml:space="preserve">
          <source>Some query parameters are interpreted by the SQLite core and used to modify the characteristics of the new connection. All query parameters are always passed through into the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; even if they are previously read and interpreted by the SQLite core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe466f14dd2cc6407106f618ec85911c7fcc3f4" translate="yes" xml:space="preserve">
          <source>Some readers might be reluctant to consider SQLite as an application file format because they have been inculcated with the idea that all SQL database schemas must be factored into third normal form and store only small primitive data types such as strings and integers. Certainly relational theory is important and designers should strive to understand it. But, as demonstrated above, it is often quite acceptable to store complex information as XML or JSON in text fields of a database. Do what works, not what your database professor said you ought to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da24c123adee2fd8a84517f276f1059ec16db37d" translate="yes" xml:space="preserve">
          <source>Some readers might resist using SQLite as an application file format due to prior exposure to enterprise SQL databases and the caveats and limitations of those other systems. For example, many enterprise database engines advise against storing large strings or BLOBs in the database and instead suggest that large strings and BLOBs be stored as separate files and the filename stored in the database. But SQLite is not like that. Any column of an SQLite database can hold a string or BLOB up to about a gigabyte in size. And for strings and BLOBs of 100 kilobytes or less, &lt;a href=&quot;intern-v-extern-blob&quot;&gt;I/O performance is better&lt;/a&gt; than using separate files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4623126273e781b93958cb9c59802c9b42b20a62" translate="yes" xml:space="preserve">
          <source>Some sanity checking code was removed from the inner loop of vdbe.c to help the library to run a little faster. The code is only removed if you compile with -DNDEBUG.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb2b13b24f119a63e7d35aeab7a0a13260e1127" translate="yes" xml:space="preserve">
          <source>Some systems (for example, Windows 95) do not support the operation implemented by sqlite3_mutex_try(). On those systems, sqlite3_mutex_try() will always return SQLITE_BUSY. The SQLite core only ever uses sqlite3_mutex_try() as an optimization so this is acceptable behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3594c70c212410200cff937ed0dc1d8804fee77c" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations (ex: &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;) make use of real (non-virtual) database tables to store content. For example, when content is inserted into the FTS3 virtual table, the data is ultimately stored in real tables named &quot;%_content&quot;, &quot;%_segdir&quot;, &quot;%_segments&quot;, &quot;%_stat&quot;, and &quot;%_docsize&quot; where &quot;%&quot; is the name of the original virtual table. This auxiliary real tables that store content for a virtual table are called &quot;shadow tables&quot;. See (&lt;a href=&quot;fts3#*shadowtab&quot;&gt;1&lt;/a&gt;), (&lt;a href=&quot;fts5#appendix_b&quot;&gt;2&lt;/a&gt;), and (&lt;a href=&quot;rtree#xshadow&quot;&gt;3&lt;/a&gt;) for additional information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3c1999dd15ec935e4c05fd2cbb35a8f0236c55" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g. to flush data accumulated in memory to disk). In this case subsequent calls to this function return the rowid associated with these internal INSERT operations, which leads to unintuitive results. Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt; before returning control to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0309e04b01e09dca18924e050475fbb9284235" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g. to flush data accumulated in memory to disk). In this case subsequent calls to this function return the rowid associated with these internal INSERT operations, which leads to unintuitive results. Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt; before returning control to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37863aa03861c512ad1c77afb4b6689cfad7493b" translate="yes" xml:space="preserve">
          <source>Some virtual tables exist automatically in the &quot;main&quot; schema of every database connection in which their module is registered, even without a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. Such virtual tables are called &quot;eponymous virtual tables&quot;. To use an eponymous virtual table, simply use the module name as if it were a table. Eponymous virtual tables exist in the &quot;main&quot; schema only, so they will not work if prefixed with a different schema name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0235dde661a1106f01332ba53a569381817a7286" translate="yes" xml:space="preserve">
          <source>Someone (or some process) might rename the database file but fail to also rename its associated journal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4532d3d7be4feca574a6f6430b43e863945ec230" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;b&gt;sqlite_exec()&lt;/b&gt; would return SQLITE_PROTOCOL when it should have returned SQLITE_BUSY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0c06ae51aa05a33354304329c9c25f09e5959c" translate="yes" xml:space="preserve">
          <source>Sometimes SQLite uses compile-time evaluatable assert() statements. Consider the code at &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&lt;/a&gt;. Four assert() statements verify the values for compile-time constants so that the reader can quickly check the validity of the if-statement that follows, without having to look up the constant values in a separate header file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e72dc8159e740969eabd99a1be0aa498a87e7c0f" translate="yes" xml:space="preserve">
          <source>Sometimes a LEFT JOIN can be completely omitted from a query without changing the result. This can happen if all of the following are true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f8fa5c7b1abe4111bb41632dd1fff37e6c00e99" translate="yes" xml:space="preserve">
          <source>Sometimes a LEFT JOIN can be converted into an ordinary JOIN, if there are terms in the WHERE clause that guarantee that the two joins will give identical results. In particular, if any column in the right-hand table of the LEFT JOIN must be non-NULL in order for the WHERE clause to be true, then the LEFT JOIN is demoted to an ordinary JOIN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f090235439a288798f47de0b5a65b1ea028dc3f6" translate="yes" xml:space="preserve">
          <source>Sometimes a power failure will cause a filesystem to be corrupted such that recently changed filenames are forgotten and the file is moved into a &quot;/lost+found&quot; directory. When that happens, the hot journal will not be found and recovery will not occur. SQLite tries to prevent this by opening and syncing the directory containing the rollback journal at the same time it syncs the journal file itself. However, the movement of files into /lost+found can be caused by unrelated processes creating unrelated files in the same directory as the main database file. And since this is out from under the control of SQLite, there is nothing that SQLite can do to prevent it. If you are running on a system that is vulnerable to this kind of filesystem namespace corruption (most modern journalling filesystems are immune, we believe) then you might want to consider putting each SQLite database file in its own private subdirectory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9f858786d7c98364aee861ef2804edc03f7313" translate="yes" xml:space="preserve">
          <source>Sometimes applications encounter this error even though there is an abundance of primary disk space because the error occurs when writing into &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt; on a system where temporary files are stored on a separate partition with much less space that the primary disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff8b7e3376a922064133232ffd6552acd46f238" translate="yes" xml:space="preserve">
          <source>Sometimes compile-time assert() statements are used to verify that SQLite has been correctly compiled. For example, the code at &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&lt;/a&gt; verifies that the SQLITE_PTRSIZE preprocessor macro is set correctly for the target architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e0873ee1e2576915056da7a06e2b494b2dd17f" translate="yes" xml:space="preserve">
          <source>Sometimes only part of an ORDER BY clause can be satisfied using indexes. Consider, for example, the following query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e9765fc44bda2fdb0012e4541cc28a30458938" translate="yes" xml:space="preserve">
          <source>Sometimes operating systems will exhibit non-standard behavior which can lead to problems. Sometimes this non-standard behavior is deliberate, and sometimes it is a mistake in the implementation. But in any event, if the operating performs differently from they way SQLite expects it to perform, the possibility of database corruption exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f1e4ae24175645a79034bd7c885a1e7d0f09d3" translate="yes" xml:space="preserve">
          <source>Sometimes the use of row values just makes the SQL easier to read and write. Consider the following two UPDATE statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e2bab9e04a22b3a6d58f84b00743d3fb69e859" translate="yes" xml:space="preserve">
          <source>Sometimes when this error code is encountered, the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; routine will convert the error into &lt;a href=&quot;rescode#error_retry&quot;&gt;SQLITE_ERROR_RETRY&lt;/a&gt; and try again to prepare the SQL statement using a different query plan that does not require the use of the unknown collating sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc4e96a478be02a8147b100bd68113f38b89f80" translate="yes" xml:space="preserve">
          <source>Sort</source>
          <target state="translated">Sort</target>
        </trans-unit>
        <trans-unit id="5601af90fba7fe38466b58c08c018711849b8855" translate="yes" xml:space="preserve">
          <source>Sort order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ab25d1e3d8ae1cb528685baf2d71b92460809e" translate="yes" xml:space="preserve">
          <source>SorterCompare</source>
          <target state="translated">SorterCompare</target>
        </trans-unit>
        <trans-unit id="e274ec5d63c6eab4a322b40fa92da953e269dcf5" translate="yes" xml:space="preserve">
          <source>SorterData</source>
          <target state="translated">SorterData</target>
        </trans-unit>
        <trans-unit id="84dc5b8de2832faa332b637acd50721fb4db3efe" translate="yes" xml:space="preserve">
          <source>SorterInsert</source>
          <target state="translated">SorterInsert</target>
        </trans-unit>
        <trans-unit id="2737748d72de05dcf6eba2817820522a4badd0ec" translate="yes" xml:space="preserve">
          <source>SorterNext</source>
          <target state="translated">SorterNext</target>
        </trans-unit>
        <trans-unit id="efe2a2f235ed328025a0db49a289c00d154bb3ba" translate="yes" xml:space="preserve">
          <source>SorterOpen</source>
          <target state="translated">SorterOpen</target>
        </trans-unit>
        <trans-unit id="58a2d7ee050bba205b0d21e366ed8ecfcceedf59" translate="yes" xml:space="preserve">
          <source>SorterSort</source>
          <target state="translated">SorterSort</target>
        </trans-unit>
        <trans-unit id="7dadfa55de2cffb43bdf1a8f139a4a743a9af71b" translate="yes" xml:space="preserve">
          <source>Sorting is accomplished by writing records into a sorting index, then rewinding that index and playing it back from beginning to end. We use the &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; opcode instead of &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; to do the rewinding so that the global variable will be incremented and regression tests can determine whether or not the optimizer is correctly optimizing out sorts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c08b606385251adc6f9a4723f760124243a4d3" translate="yes" xml:space="preserve">
          <source>Sorting subsets of the result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516e89309d994acf5d94c4a4907b3ff4a8e53a80" translate="yes" xml:space="preserve">
          <source>Source Of Data In A Query Result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbc658da4e64bd6eef7ec70eab5adab3d14a41a" translate="yes" xml:space="preserve">
          <source>Source code for several useful extensions can be found in the &lt;a href=&quot;http://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext/misc&lt;/a&gt; subdirectory of the SQLite source tree. You can use these extensions as-is, or as a basis for creating your own custom extensions to address your own particular needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64243b8fe27d8786b74ebe9ad360b0c831315629" translate="yes" xml:space="preserve">
          <source>Sources are in the &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;public domain&lt;/a&gt;. Use for any purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb7e396773f80244c6756a8ac8a3ba107260e6f" translate="yes" xml:space="preserve">
          <source>Spatial indices using &lt;a href=&quot;rtree&quot;&gt;R-Trees&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f329318e826b6123bdadb48df921310c8b500b7" translate="yes" xml:space="preserve">
          <source>Speak no useless words or words that move to laughter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cda32c171792b8ebd4697561ad451beebb8dd76" translate="yes" xml:space="preserve">
          <source>Special INSERT operates can be used to issue commands to FTS3 and FTS4 tables. Every FTS3 and FTS4 has a hidden, read-only column which is the same name as the table itself. INSERTs into this hidden column are interpreted as commands to the FTS3/4 table. For a table with the name &quot;xyz&quot; the following commands are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c62a06b3206449dc4ac80333e6db0c204db7ba5" translate="yes" xml:space="preserve">
          <source>Special processing occurs when the aggregate function is either &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min()&lt;/a&gt; or &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max()&lt;/a&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6937900c4a39aa0fb125a152dfd5d62be4f8822d" translate="yes" xml:space="preserve">
          <source>Special sqlite_stat1 Handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4c6816e6235fac1910f655a4449098f3bab054" translate="yes" xml:space="preserve">
          <source>Special versions of the SQLite amalgamation that do work with a predetermined set of SQLITE_OMIT_* options can be generated. To do so, make a copy of the Makefile.linux-gcc makefile template in the canonical source code distribution. Change the name of your copy to simply &quot;Makefile&quot;. Then edit &quot;Makefile&quot; to set up appropriate compile-time options. Then type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348842ed415067bf469c3c07cbca8231199b183f" translate="yes" xml:space="preserve">
          <source>Specialized applications for which the default implementation of shared memory is unacceptable can devise alternative methods via a custom &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. For example, if it is known that a particular database will only be accessed by threads within a single process, the wal-index can be implemented using heap memory instead of true shared memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a647b0621c3756491eb85db442ab54ae4811cd09" translate="yes" xml:space="preserve">
          <source>Specific pragma statements may be removed and others added in future releases of SQLite. There is no guarantee of backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a894085a5589da14805f40b5e5ec42d34bdb30" translate="yes" xml:space="preserve">
          <source>Specify an alternative malloc implementation using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; verb with the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7969816e7b05b7f6c6da58d9c3d55a797859dc5f" translate="yes" xml:space="preserve">
          <source>Specify an alternative mutex implementation using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; verb with the &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d9e8c303af8fa2eba928e74e37e3e2d5b8ccc2" translate="yes" xml:space="preserve">
          <source>Specify an application-defined page cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675036f344331d67d2ac3929e1284013b1817b31" translate="yes" xml:space="preserve">
          <source>Specifying a new page size does not change the page size immediately. Instead, the new page size is remembered and is used to set the page size when the database is first created, if it does not already exist when the page_size pragma is issued, or at the next &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command that is run on the same database connection while not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdc7dcd44b7642ef54261a530f0a8d271e92800" translate="yes" xml:space="preserve">
          <source>Specifying an explicit value for the rowid field as part of an INSERT statement is not supported. Any value supplied is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff83e10cd15a3b1a3684d12025d600161e1e03fe" translate="yes" xml:space="preserve">
          <source>Specifying an unknown parameter in the query component of a URI is not an error. Future versions of SQLite might understand additional query parameters. See &quot;&lt;a href=&quot;../uri#coreqp&quot;&gt;query parameters with special meaning to SQLite&lt;/a&gt;&quot; for additional information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca08c5f93bc177c41e9e1cbac8bb1b05f691f402" translate="yes" xml:space="preserve">
          <source>Specifying an unknown parameter in the query component of a URI is not an error. Future versions of SQLite might understand additional query parameters. See &quot;&lt;a href=&quot;uri#coreqp&quot;&gt;query parameters with special meaning to SQLite&lt;/a&gt;&quot; for additional information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5466deac546a32beeffc729c74a6e5fd300f895" translate="yes" xml:space="preserve">
          <source>Specifying three arguments when creating an fts5vocab table in any database other than &quot;temp&quot; results in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d5a13bd4511e6816f18d10b6fcf53288c30d62" translate="yes" xml:space="preserve">
          <source>Speed improvements and library footprint reductions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886fdbf5bb356c1170f6be819f95ecf4cc1461e3" translate="yes" xml:space="preserve">
          <source>Speed improvements in the VDBE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d42db811b80e228f8d1a0a01dc2cacac3b1009" translate="yes" xml:space="preserve">
          <source>Speed improvements in the btree and pager layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da1385bd95c04e2cef432911cc39014873cc087" translate="yes" xml:space="preserve">
          <source>Speed improvements: Do not do synchronous updates on TEMP tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d342a78b198923e433b8a1315c81a6ffbf9833" translate="yes" xml:space="preserve">
          <source>Split amalgamation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dac9d1634f1fa754c9cb08212550ad68bf6b1f7" translate="yes" xml:space="preserve">
          <source>Split the pager subsystem into separate pager and pcache subsystems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb46447f9362d79f903651b48710b55ec51dd8a" translate="yes" xml:space="preserve">
          <source>Splitting content into smaller pieces also helps File/Save operations to go faster. Instead of having to write back the content of all pages when doing a File/Save, the application only has to write back those pages that have actually changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b1c55ba41f5df4c296b1603dd8662a874ad05f" translate="yes" xml:space="preserve">
          <source>SqlExec</source>
          <target state="translated">SqlExec</target>
        </trans-unit>
        <trans-unit id="21ba7365f757b4f24cbf08b5870a91de5cd965d8" translate="yes" xml:space="preserve">
          <source>Sqldiff --rbu</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785ca9526809c90e3417966be7d5844fd2a0c5c8" translate="yes" xml:space="preserve">
          <source>Stability</source>
          <target state="translated">Stability</target>
        </trans-unit>
        <trans-unit id="d96e5b2dd07c1733b2b013bd82922c22baade37d" translate="yes" xml:space="preserve">
          <source>Stable</source>
          <target state="translated">Stable</target>
        </trans-unit>
        <trans-unit id="ed9cb8071fd38e38b556df67e342f21ef7bd62db" translate="yes" xml:space="preserve">
          <source>Stable interfaces will be maintained indefinitely in a backwards compatible way. An application that uses only stable interfaces should always be able to relink against a newer version of SQLite without any changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d69ca23f60003536eb90ef7c1a45510967cd2a5" translate="yes" xml:space="preserve">
          <source>Stale file descriptor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf4ee63c814f2ac7a90ca00e168f99ba47070e5" translate="yes" xml:space="preserve">
          <source>Standard File Control Opcodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0271f691eaa2014cfdc1f8a7ed1187c67c1f03ee" translate="yes" xml:space="preserve">
          <source>Standard Query Syntax Precedence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62af2c2f7d7a242deb88ffff88441215850f0cf0" translate="yes" xml:space="preserve">
          <source>Standard builds include the default &quot;unix&quot; or &quot;win32&quot; VFSes. But if you use the -DOS_OTHER=1 compile-time option, then SQLite is built without a default VFS. In that case, the application must register at least one VFS prior to calling &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;. This is the approach that embedded applications should use. Rather than modifying the SQLite source to insert an alternative OS layer as was done in prior releases of SQLite, instead compile an unmodified SQLite source file (preferably the amalgamation) with the -DOS_OTHER=1 option, then invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to define the interface to the underlying filesystem prior to creating any database connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4bb77fea34e91bf036ddd54845284d1cf9ef7e7" translate="yes" xml:space="preserve">
          <source>Standard builds of SQLite for Unix or Windows come with a single VFS named &quot;unix&quot; or &quot;win32&quot;, as appropriate. This one VFS is also the default. So if you are using the legacy open functions, everything will continue to operate as it has before. The change is that an application now has the flexibility of adding new VFS modules to implement a customized OS layer. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; API can be used to tell SQLite about one or more application-defined VFS modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cadaed061bc7503c3155b4851296844f6b19b6" translate="yes" xml:space="preserve">
          <source>Start a read transaction on an historical snapshot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789445bbe2e230b404b0877611cb047ff79a2a8a" translate="yes" xml:space="preserve">
          <source>Start a transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65d3b5410040822706753355b83a262ca2b3805" translate="yes" xml:space="preserve">
          <source>Start the &lt;b&gt;sqlite3&lt;/b&gt; program by typing &quot;sqlite3&quot; at the command prompt, optionally followed by the name the file that holds the SQLite database. If the named file does not exist, a new database file with the given name will be created automatically. If no database file is specified on the command-line, a temporary database is created, then deleted when the &quot;sqlite3&quot; program exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb60319509fec567263f40a7e8bf18c02dfd219" translate="yes" xml:space="preserve">
          <source>Starting with &lt;a href=&quot;https://sqlite.org/releaselog/3_3_0.html&quot;&gt;version 3.3.0&lt;/a&gt; (2006-01-11), SQLite includes a special &quot;shared-cache&quot; mode (disabled by default) intended for use in embedded servers. If shared-cache mode is enabled and a thread establishes multiple connections to the same database, the connections share a single data and schema cache. This can significantly reduce the quantity of memory and IO required by the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="023a31bfb8ddab03b504852064e49a20e7d9d830" translate="yes" xml:space="preserve">
          <source>Startup time is reduced by allowing the application to read in only the content shown for the initial screen. This largely eliminates the need to show a progress bar when opening a new document. The document just pops up immediately, further enhancing the user experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7c6f024748b0b4ca685edf7c9c36a22ff2bd48" translate="yes" xml:space="preserve">
          <source>Statement Rollback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c7b81be5c9efcc042ff8389d0cd187913125cb" translate="yes" xml:space="preserve">
          <source>Statement Transactions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90f613a0e148cacdfc6a3c9d8b61b95e2acb93e" translate="yes" xml:space="preserve">
          <source>Statement journal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1040e934c3b0c196798a9d1961f27355d86e45" translate="yes" xml:space="preserve">
          <source>Statement journals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8ba443e0e2998259e771cf2ecb0604dd034de1" translate="yes" xml:space="preserve">
          <source>Static analysis has not been helpful in finding bugs in SQLite. Static analysis has found a few bugs in SQLite, but those are the exceptions. More bugs have been introduced into SQLite while trying to get it to compile without warnings than have been found by static analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680999abb1389f8c322acbd6c1aa5dbe84be6521" translate="yes" xml:space="preserve">
          <source>Static analysis means analyzing source code at compile-time to check for correctness. Static analysis includes compiler warning messages and more in-depth analysis engines such as the &lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt;. SQLite compiles without warnings on GCC and Clang using the -Wall and -Wextra flags on Linux and Mac and on MSVC on Windows. No valid warnings are generated by the Clang Static Analyzer tool &quot;scan-build&quot; either (though recent versions of clang seem to generate many false-positives.) Nevertheless, some warnings might be generated by other static analyzers. Users are encouraged not to stress over these warnings and to instead take solace in the intense testing of SQLite described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e49731cc0b88e4893c23ef28a83ddda3bfb212a" translate="yes" xml:space="preserve">
          <source>Statistics gathered by ANALYZE are not automatically updated as the content of the database changes. If the content of the database changes significantly, or if the database schema changes, then one should consider rerunning the ANALYZE command in order to update the statistics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d77b9bb2436857be2774ccf495a6735714ef3f" translate="yes" xml:space="preserve">
          <source>Statistics might not be available for all loops in all statements. In cases where there exist loops with no available statistics, this function behaves as if the loop did not exist - it returns non-zero and leave the variable that pOut points to unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc97dbd639562aa95bfaa677d2f8dc3487a559db" translate="yes" xml:space="preserve">
          <source>Stats pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df542e628beff2a0b73ed1e479f1091511d9cd6a" translate="yes" xml:space="preserve">
          <source>Status Of A Dynamic String</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6872312ea81433049bd70deac565b5d633fd6998" translate="yes" xml:space="preserve">
          <source>Status Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adc22e7dbafa333d0e47ced61c20bab368c7387" translate="yes" xml:space="preserve">
          <source>Status Parameters for database connections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8499ef2845b7984472eeaa5eec92eef3c3ddc5e1" translate="yes" xml:space="preserve">
          <source>Status Parameters for prepared statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04daddc4070fdc058ac9e443c8962cff2f5d578" translate="yes" xml:space="preserve">
          <source>Sticky &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; or &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; errors in the pager are reset when a new transaction is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4fde80455d82361972cd992928272cdd38d544" translate="yes" xml:space="preserve">
          <source>Storage class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adf951cb70d6bfcdd293ee933bb14acec2e8923" translate="yes" xml:space="preserve">
          <source>Storage space for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf3f676fb55796ce1a966642440eafe303dfddd" translate="yes" xml:space="preserve">
          <source>Storage used for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5447c3e2de40c5c68aa31375241b98a076167c" translate="yes" xml:space="preserve">
          <source>Store an &lt;a href=&quot;undoredo&quot;&gt;automated undo/redo stack&lt;/a&gt; in a database table so that Undo could go back into prior edit sessions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49a369d4dc034b2ddab0ef35e3bc0a19be08a8f" translate="yes" xml:space="preserve">
          <source>Store in register P2 an integer which is the key of the table entry that P1 is currently point to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867b15696e9fa5010d6dcd54eb51b1ee5a1a7a9e" translate="yes" xml:space="preserve">
          <source>Store in register P3 the value of the P2-th column of the current row of the virtual-table of cursor P1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36766981b9139e0da225001d40b99095efc88b9" translate="yes" xml:space="preserve">
          <source>Store in register r[P3] the byte offset into the database file that is the start of the payload for the record at which that cursor P1 is currently pointing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c620766d52d9f14ee6085868bffd5fb7f16c25" translate="yes" xml:space="preserve">
          <source>Store new polygons in the table using ordinary INSERT statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e312586c7080f660b8a13dd56528c07ac821e623" translate="yes" xml:space="preserve">
          <source>Store the maximum page count after the change in register P2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a03a2e19022832dfb9661ede226d69d6b142a41" translate="yes" xml:space="preserve">
          <source>Store the number of entries (an integer value) in the table or index opened by cursor P1 in register P2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640b00f8e936acd9d22458864812f703b6f037f6" translate="yes" xml:space="preserve">
          <source>Store the statement journal in the temporary file directory instead of collocated with the database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a1d24f343a9c4193ce3147697d66befd80ac3b" translate="yes" xml:space="preserve">
          <source>Storing the schema a text also makes the &lt;a href=&quot;fileformat2&quot;&gt;SQLite database file format&lt;/a&gt; easier to define, document, and understand. This helps make SQLite database files a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term archiving of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9347ad87d0fbebdfc89e77280c0ab0e8462e84d1" translate="yes" xml:space="preserve">
          <source>Storing the schema as text rather than as parsed tables also give flexibility to the implementation. Since the internal parse of the schema is regenerated each time the database is opened, the internal representation of the schema can change from one release to the next. This is important, as sometimes new features require enhancements to the internal schema representation. Changing the internal schema representation would be much more difficult if the schema representation was exposed in the database file. So, in other words, storing the schema as text helps maintain backwards compatibility, and helps ensure that older database files can be read and written by newer versions of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275b8884950b47fafacc5239216411e5afbdc454" translate="yes" xml:space="preserve">
          <source>Streaming Versions of API functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cda8a5c429d321cd55319d79be9050795d95668" translate="yes" xml:space="preserve">
          <source>Streaming Versions of API functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b71513a74ee80684014356a0159868598a4ea7" translate="yes" xml:space="preserve">
          <source>Streaming function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76c18624ee750ab230cd2529398af4c90203056" translate="yes" xml:space="preserve">
          <source>Strengthen defenses against deliberately corrupted database files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d422bf6680eb42d320cae6dd4ad922e3705a6b" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object is not required since the convenience wrapper interfaces, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec&lt;/a&gt; or &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table&lt;/a&gt;, can be used and these convenience wrappers encapsulate and hide the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object. Nevertheless, an understanding of &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; is needed to make full use of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="f631842398197770725f42465ce9be3bb217fe7f" translate="yes" xml:space="preserve">
          <source>String Comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca91d4c03b6524119c1475d05b8b5503e052ba2" translate="yes" xml:space="preserve">
          <source>String Globbing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8c2dabd43b3a0fa081659375ff18075de8cb9f3" translate="yes" xml:space="preserve">
          <source>String LIKE Matching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfab1bcbfa804d1a74a7282da9ab4ff5c5353c70" translate="yes" xml:space="preserve">
          <source>String8</source>
          <target state="translated">String8</target>
        </trans-unit>
        <trans-unit id="add2080ddbdcd32891495b46eb567565fc93baa2" translate="yes" xml:space="preserve">
          <source>Strings returned by sqlite3_column_text() and sqlite3_column_text16(), even empty strings, are always zero-terminated. The return value from sqlite3_column_blob() for a zero-length BLOB is a NULL pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109fcef442d10303df5f7d59d40936a03977dfcb" translate="yes" xml:space="preserve">
          <source>Strings that include any other characters must be quoted. Characters that are not currently allowed in barewords, are not quote characters and do not currently serve any special purpose in FTS5 query expressions may at some point in the future be allowed in barewords or used to implement new query functionality. This means that queries that are currently syntax errors because they include such a character outside of a quoted string may be interpreted differently by some future version of FTS5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b6945b8df636a6d934a512accf12a8b76fc6265" translate="yes" xml:space="preserve">
          <source>Studies show that many applications already use SQLite as a container object. For example, &lt;a href=&quot;https://odin.cse.buffalo.edu/papers/2015/TPCTC-sqlite-final.pdf&quot;&gt;Kennedy&lt;/a&gt; (no relation to the &lt;a href=&quot;https://sqlite.org/crew.html#dan&quot;&gt;SQLite developer&lt;/a&gt;) reports that 14% of Android applications never write to their SQLite databases. It is believed that these applications are downloading entire databases from the cloud and then using the information locally as needed. In other words, the applications are using SQLite not so much as a database but as a queryable wire-transfer format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd17ca7716d1959474368eb0c63e1ad9ad957be" translate="yes" xml:space="preserve">
          <source>Subqueries</source>
          <target state="translated">Subqueries</target>
        </trans-unit>
        <trans-unit id="9a235eb288a64671965312f5d0ad9f1b72cd84b6" translate="yes" xml:space="preserve">
          <source>Subqueries might also need to be materialized when they appear in the FROM clause of a SELECT statement. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79095639cf2544d3073712b3f47816fbf8b20418" translate="yes" xml:space="preserve">
          <source>Subquery Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14de4f03d3cdec3c98a5016002bc81eb0292385c" translate="yes" xml:space="preserve">
          <source>Subquery co-routines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0025e26a750eaf886e5b666d451246677ab333" translate="yes" xml:space="preserve">
          <source>Substitution Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5f61e523ef194692c08eae320b323a03f8bb9b" translate="yes" xml:space="preserve">
          <source>Subtract</source>
          <target state="translated">Subtract</target>
        </trans-unit>
        <trans-unit id="b2b6c0ca0db2f38dd797d319d2f786a2af93e034" translate="yes" xml:space="preserve">
          <source>Subtract 200 from X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351c38b73ce6b309921bfd5c87f12ea777d4a4ac" translate="yes" xml:space="preserve">
          <source>Subtract the value in register P1 from the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ad01aa557050dded853fc788b3484598298d39" translate="yes" xml:space="preserve">
          <source>Such a line of C code might generate a dozen separate machine code instructions. If any one of those instructions is ever evaluated, then we say that the statement has been tested. So, for example, it might be the case that the conditional expression is always false and the &quot;d&quot; variable is never incremented. Even so, statement coverage counts this line of code as having been tested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a042ce9ca13e4d4ddb750a0fe77ea337b1cdceb1" translate="yes" xml:space="preserve">
          <source>Such a virtual table has the same columns as the table-valued function described in the previous section. It may be read from using a SELECT statement in the same way as the table-valued function can.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da045363c8fb916c7bdb60bedab8cb85e2f1f5a1" translate="yes" xml:space="preserve">
          <source>Such advanced searches are requested by providing a more complicated FTS5 query string as the text to the right of the MATCH operator (or = operator, or as the first argument to a table-valued function syntax). The full query syntax is &lt;a href=&quot;fts5#full_text_query_syntax&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0936ee6227b30512f2222702e2254d11d72a242" translate="yes" xml:space="preserve">
          <source>Such criticism would be well-founded for a traditional client/server database engine, such as MySQL, PostgreSQL, or SQL Server. In a client/server database, each SQL statement requires a message round-trip from the application to the database server and back to the application. Doing over 200 round-trip messages, sequentially, can be a serious performance drag. This is sometimes called the &quot;N+1 Query Problem&quot; or the &quot;N+1 Select Problem&quot; and it is an anti-pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f834acdfa0c7dab757f2bc4e26b1966eff963a52" translate="yes" xml:space="preserve">
          <source>Suggested Uses For SQLite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f08f43d3c61d6c426d33128ee0c38e51fb6aad20" translate="yes" xml:space="preserve">
          <source>Suggested compile-time options include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1a384ea1042be63f3032ea726e70fc4a04f311" translate="yes" xml:space="preserve">
          <source>Suggests completions for partially-entered words during interactive SQL input. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to help implement tab-completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adca4d21f8bf7900f73ede68196274afd881f1d7" translate="yes" xml:space="preserve">
          <source>Sum() will throw an &quot;integer overflow&quot; exception if all inputs are integers or NULL and an integer overflow occurs at any point during the computation. Total() never throws an integer overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="1a7bd9ebcad37a0dd711dfc793fa96bb5022047c" translate="yes" xml:space="preserve">
          <source>Summary of Technical Differences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2e3b9850b401306a39a3a804f43e7d4f55c01f" translate="yes" xml:space="preserve">
          <source>Support for &quot;:AAA&quot; style bind parameter names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e333e85b28ab7b57a0a5c9131f54f806015a6221" translate="yes" xml:space="preserve">
          <source>Support for ALTER TABLE ... RENAME TABLE ... added</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3251d36ace39f64a5ddca9143a5668b65028289f" translate="yes" xml:space="preserve">
          <source>Support for TCL variable names embedded in SQL statements in the TCL bindings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4e649b2faf6e7dd28f3f288044f754a9767c05" translate="yes" xml:space="preserve">
          <source>Support for UTF-16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ef276ba874be88caa55a5b3e4a37db519f9394" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 and ISO8859 characters in column and table names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78dc81c2a8faafa4c84493782b19c441e17956a6" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 and UTF-16</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1164bc2160d30de5ee08ec06fc2a323f2028fc" translate="yes" xml:space="preserve">
          <source>Support for both UTF-8 and UTF-16 text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf37e2ec021b62a6c46ffa2eb125d86eb07ffbc5" translate="yes" xml:space="preserve">
          <source>Support for correlated subqueries added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9173b8e288c70be66cdbfa81d0ba7ad6705c9c" translate="yes" xml:space="preserve">
          <source>Support for full text search using the FTS1 module (beta)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09344ff56160150e5ec18eb5a71ba2f29a6312fc" translate="yes" xml:space="preserve">
          <source>Support for internationalization including UTF-8, UTF-16, and user defined collating sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091e86f3d19a27b9089ddce8c418dcc49fd9c304" translate="yes" xml:space="preserve">
          <source>Support for non-ASCII characters in win95 filenames</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfddf0106ec96c94ef54d4e7b75188870573ef30" translate="yes" xml:space="preserve">
          <source>Support for the EXISTS clause added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d1badc676c125ad5e671e3ae8383a4753e9f6c" translate="yes" xml:space="preserve">
          <source>Support for the diagnostic functions sqlite3_compileoption_used() and sqlite3_compileoption_get() may be omitted by specifying the &lt;a href=&quot;../compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; option at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceaebbe4250e5e44fc85c0a7be72215c2fc6b3df" translate="yes" xml:space="preserve">
          <source>Support for the diagnostic functions sqlite3_compileoption_used() and sqlite3_compileoption_get() may be omitted by specifying the &lt;a href=&quot;compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; option at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e227243100baec383101a5e3e5550db71fb48de1" translate="yes" xml:space="preserve">
          <source>Support operators IS TRUE, IS FALSE, IS NOT TRUE, and IS NOT FALSE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b76c3512f29a884a102a942cd3b81fe8d384ace" translate="yes" xml:space="preserve">
          <source>Supported unary prefix operators are these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14453b6f0216ab7b03129623da62580288e5db4c" translate="yes" xml:space="preserve">
          <source>Supports terabyte-sized databases and gigabyte-sized strings and blobs. (See &lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a1709933364d69e93326e81a6775d317d15202" translate="yes" xml:space="preserve">
          <source>Suppose N=4. Then for the TPC-H Q8 graph, the first step finds the four shortest paths to visit any single node in the graph:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61fbb5bff735b0969304e1938310f741780fb8bb" translate="yes" xml:space="preserve">
          <source>Suppose SQLite is used as the &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; for a particular design application. Two users, Alice and Bob, each start with a baseline design that is about a gigabyte in size. They work all day, in parallel, each making their own customizations and tweaks to the design. At the end of the day, they would like to merge their changes together into a single unified design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef94f961eb3bb04314c719aa5da9edd146e885d3" translate="yes" xml:space="preserve">
          <source>Suppose an application wants to display a list of contacts in alphabetical order by lastname, firstname, in a scrolling window that can only show 7 contacts at a time. Initialize the scrolling window to the first 7 entries is easy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56904d3ea47369b0068186e8a39203c8a5f870c3" translate="yes" xml:space="preserve">
          <source>Suppose each entry in the BIG table is a JSON object with a '$.id' field that is a unique identifier and a '$.partlist' field that can be a deeply nested object. You want to find the id of every entry that contains one or more references to uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808' anywhere in its '$.partlist'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01636cb9299568d887d10674105e44b34b08d5bf" translate="yes" xml:space="preserve">
          <source>Suppose that after a while (about a month, usually) a new version of SQLite is released: 3.6.16. You will want to incorporate this new public version of SQLite into your repository in the public branch (the trunk). To do this, first change your repository over to the trunk:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cede4c6f59f784278daddf56ee62d38bbe080c9a" translate="yes" xml:space="preserve">
          <source>Suppose that in addition to the index on &quot;fruit&quot; there was also an index on &quot;state&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66f9ffa5f1e3c7efa56791a73580d03426c293ab" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;a href=&quot;http://en.wikipedia.org/wiki/OpenDocument&quot;&gt;OpenDocument&lt;/a&gt; file format, and specifically the &quot;ODP&quot; OpenDocument Presentation format, were built around SQLite. Benefits would include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6796b2c9a16b027d38641aa802a501818a470f" translate="yes" xml:space="preserve">
          <source>Suppose the SQLite source tree is stored in a directory named &quot;sqlite&quot;. Plan to construct the amalgamation in a parallel directory named (for example) &quot;bld&quot;. First construct an appropriate Makefile by either running the configure script at the top of the SQLite source tree, or by making a copy of one of the template Makefiles at the top of the source tree. Then hand edit this Makefile to include the desired compile-time options. Finally run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af5f7045e9a9cbdbcc9c95551ce4e94ea5602be" translate="yes" xml:space="preserve">
          <source>Suppose the demo_data.boundary field holds some proprietary data description of a complex two-dimensional boundary for an object and suppose that the application has used the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface to created application-defined functions &quot;contained_in&quot; and &quot;overlaps&quot; accepting two demo_data.boundary objects and return true or false. One may assume that &quot;contained_in&quot; and &quot;overlaps&quot; are relatively slow functions that we do not want to invoke too frequently. Then an efficient way to find the name of all objects located within the North Carolina 12th District, one may be to run a query like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9cbf4654b2bfbdcf1b2bf833bfb8cf7cccef29" translate="yes" xml:space="preserve">
          <source>Suppose the initial sequence of non-wildcard characters on the right-hand side of the LIKE or GLOB operator is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15341cf73e257c233d78d57ae1e295622b133b68" translate="yes" xml:space="preserve">
          <source>Suppose the power loss occurred during &lt;a href=&quot;#section_3_10&quot;&gt;step 3.10&lt;/a&gt; above, while the database changes were being written to disk. After power is restored, the situation might be something like what is shown to the right. We were trying to change three pages of the database file but only one page was successfully written. Another page was partially written and a third page was not written at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502f7a3363de6f918e427baeeb23c0fbeb554eda" translate="yes" xml:space="preserve">
          <source>Suppose the table &quot;CREATE TABLE user(name,phone)&quot; stores zero or more phone numbers as a JSON array object in the user.phone field. To find all users who have any phone number with a 704 area code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5297ab1e192fe178acfe6ab94a19f582b117e15" translate="yes" xml:space="preserve">
          <source>Suppose the term that is being spell-corrected is X. To limit the search space, X is converted to a k2-like key using the equivalent of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b244116e469acf86fbb0e19b53f1d8598b689446" translate="yes" xml:space="preserve">
          <source>Suppose there is a site hosting a database in state S0. And that modifications are made that move that database to state S1 and a changeset recorded (the &quot;local&quot; changeset). Then, a changeset based on S0 is received from another site (the &quot;remote&quot; changeset) and applied to the database. The database is then in state (S1+&quot;remote&quot;), where the exact state depends on any conflict resolution decisions (OMIT or REPLACE) made while applying &quot;remote&quot;. Rebasing a changeset is to update it to take those conflict resolution decisions into account, so that the same conflicts do not have to be resolved elsewhere in the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ead91310400eb3c0d2b88fd20fde2e0225bdf31" translate="yes" xml:space="preserve">
          <source>Suppose we have a table X1 defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538e32b0b37a9243b789f735088e6724ac330912" translate="yes" xml:space="preserve">
          <source>Suppose we want to find the prices of all kinds of oranges sorted in order of the state where they are grown. The query is this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064cebf29367ccdae2597fb8c1cb7630379e90ac" translate="yes" xml:space="preserve">
          <source>Suppose we want to know the order number, product number, and quantity for any item in which the product number and quantity match the product number and quantity of any item in order number 365:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465043a8fd6b7a4a4148ce99421e90822984188c" translate="yes" xml:space="preserve">
          <source>Suppose you want to look up the price of peaches. The query would be as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cde9a11c3caa7425e0b0c2c0bc60b2a242f9c61" translate="yes" xml:space="preserve">
          <source>Surprisingly, using SQLite in place of ZIP makes the presentation file smaller. Really. One would think that a relational database file would be larger than a ZIP archive, but at least in the case of NeoOffice that is not so. The following is an actual screen-scrape showing the sizes of the same NeoOffice presentation, both in its original ZIP archive format as generated by NeoOffice (self2014.odp), and as repacked as an SQLite database using the &lt;a href=&quot;http://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;SQLAR&lt;/a&gt; utility:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055c319b3692b1bab785599b3ba80b0068542bb5" translate="yes" xml:space="preserve">
          <source>Suspend Execution For A Short Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bdfc376d6f876239b6de7abf665805218ef476e" translate="yes" xml:space="preserve">
          <source>Swap the program counter with the value in register P1. This has the effect of yielding to a coroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb264ae88f7fbec3546350312b9af582b1fc481" translate="yes" xml:space="preserve">
          <source>Swapping journal files between two different databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8485294b019aa85fdb1a929771cba23d5593c45" translate="yes" xml:space="preserve">
          <source>Swarmvtab Virtual Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d32f35e7401403e071bd64f5c3b26a4e4dc5be" translate="yes" xml:space="preserve">
          <source>Swarmvtab context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875cb081d7d2e461450da0199489f1266311e3ff" translate="yes" xml:space="preserve">
          <source>Swarmvtab efficiently handles range and equality constraints on the rowid (or other INTEGER PRIMARY KEY) field only. If a query does not contain such a constraint, then swarmvtab finds the results by opening each database in turn and linearly scanning the component table. Which generates a correct result, but is often slow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85aa4db2e47035bd4c2140f56e8799ea09c7ae90" translate="yes" xml:space="preserve">
          <source>Swarmvtab virtual tables must be created in the temp schema. Attempting to create a swarmvtab in the main or an attached database is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d92527f493460a8c4ce6ccbbd585c5ead2d11f" translate="yes" xml:space="preserve">
          <source>Synchronization Type Flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e6b31b20f1d4434bcadd521f6861e2f3378f97" translate="yes" xml:space="preserve">
          <source>Synchronous pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae6fa22bc9918cf39eb8d8cef197a88e78982e8" translate="yes" xml:space="preserve">
          <source>Syncing</source>
          <target state="translated">Syncing</target>
        </trans-unit>
        <trans-unit id="c66891a446af4f02e4055198cbfa371561a78fd4" translate="yes" xml:space="preserve">
          <source>Syncing the Journal File</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17aba038fa3266b07efa450a91b91b1e792d66c5" translate="yes" xml:space="preserve">
          <source>Syntax Diagrams</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bbfae733b0f97c3ea72475efb5dfbb61ebe1e1" translate="yes" xml:space="preserve">
          <source>Syntax Diagrams For SQLite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a8fcc6fa01af0d580c320ddb0e42484905e68e" translate="yes" xml:space="preserve">
          <source>Syntax Restrictions On UPDATE, DELETE, and INSERT Statements Within Triggers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b408d97f8998a54cd64e9461c53dd4d1067b38" translate="yes" xml:space="preserve">
          <source>System Failure Related Assumptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2da263deb1258b36edfe6f11f1b761d86b8d6d" translate="yes" xml:space="preserve">
          <source>Systems designers report success using SQLite as a data store on server applications running in the datacenter, or in other words, using SQLite as the underlying storage engine for an application-specific database server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7244bff04e9f7001cbde5e129092d3ed31f1946c" translate="yes" xml:space="preserve">
          <source>Systems that run automatic backups in the background might try to make a backup copy of an SQLite database file while it is in the middle of a transaction. The backup copy then might contain some old and some new content, and thus be corrupt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4394edb00669dc4429b903f672c10ae13c95e90" translate="yes" xml:space="preserve">
          <source>TABLE</source>
          <target state="translated">TABLE</target>
        </trans-unit>
        <trans-unit id="2ba83e39946a4ce4cedf8d25757aa5972284aa54" translate="yes" xml:space="preserve">
          <source>TABLENAME</source>
          <target state="translated">TABLENAME</target>
        </trans-unit>
        <trans-unit id="4ff4bacb6a130128f6603752138b57217ef9b6fa" translate="yes" xml:space="preserve">
          <source>TBD...</source>
          <target state="translated">TBD...</target>
        </trans-unit>
        <trans-unit id="e44916ac43724313d53ca25dbe2f20ee993ff6ec" translate="yes" xml:space="preserve">
          <source>TBD: More information about the header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd060df603a64a7bee550bbc1c098580b231ab0" translate="yes" xml:space="preserve">
          <source>TCL interface authorizer method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa517168bae4e2e388a6074b5a96fe2e5afc293f" translate="yes" xml:space="preserve">
          <source>TCL interface backup method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29047291bb3d39d19d4b03699cb7f433f5736f2" translate="yes" xml:space="preserve">
          <source>TCL interface bind_fallback method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5ad56544d8041c9b02f88d11a25782f14e4c9f" translate="yes" xml:space="preserve">
          <source>TCL interface busy method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4d989bf3b3b512cc61d500b0cb58cfc259ca59" translate="yes" xml:space="preserve">
          <source>TCL interface cache method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25b192d00bf0645e7eae602ec160016f797e6ac" translate="yes" xml:space="preserve">
          <source>TCL interface changes method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f884ed1b8425d04cb3811d2ea16b66af480340" translate="yes" xml:space="preserve">
          <source>TCL interface close method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c5f46c7769b7e1d49b804ecba806907889a771" translate="yes" xml:space="preserve">
          <source>TCL interface collate method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2332befec61c50669cde60f3b1533591736f6a66" translate="yes" xml:space="preserve">
          <source>TCL interface collation_needed method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd4b4c1ed1732eb767f776cef0372d6c6cd1054" translate="yes" xml:space="preserve">
          <source>TCL interface commit_hook method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0157c2d923f1a0bec3d0245febd3f5035181a5aa" translate="yes" xml:space="preserve">
          <source>TCL interface complete method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09e584a42654f26d29ff74df19ed9ca909905e4" translate="yes" xml:space="preserve">
          <source>TCL interface config method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70df1b7dc237a292692ace288ac2eb93a3bcef2" translate="yes" xml:space="preserve">
          <source>TCL interface copy method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347f513a80d88ab334df317b8f83092d3ee26571" translate="yes" xml:space="preserve">
          <source>TCL interface deserialize method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa7225f1cfbaa7982110594b19739c6dbdfb9ac" translate="yes" xml:space="preserve">
          <source>TCL interface enable_load_extension method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64987beca677d7a4b95b820f3bed800e413b8cde" translate="yes" xml:space="preserve">
          <source>TCL interface errorcode method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2189980d19fa911ed2ea4bb8d946cfdc55a53bc7" translate="yes" xml:space="preserve">
          <source>TCL interface eval method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1bf6449a26eb7b025248f0b61a91066e3c39b49" translate="yes" xml:space="preserve">
          <source>TCL interface exists method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648b3c74c3afc3cad32dadd0965691c51538573c" translate="yes" xml:space="preserve">
          <source>TCL interface function method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d842678586502cd1c46097c8ca3621079c38b98" translate="yes" xml:space="preserve">
          <source>TCL interface incrblob method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066821d02e0db49a10a7937ff6d8bc5c5b5055c7" translate="yes" xml:space="preserve">
          <source>TCL interface interrupt method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2e3158832088a3ccb54fc358c6461aace750451" translate="yes" xml:space="preserve">
          <source>TCL interface last_insert_rowid method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f8a5afc729daeaa27f3e057a6884d99bd7f622" translate="yes" xml:space="preserve">
          <source>TCL interface nullvalue method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0711044ae2edb8698df1518d744c5b6309e1ba0" translate="yes" xml:space="preserve">
          <source>TCL interface onecolumn method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb062b4a3cda7b5c21d07e42888d6f537605587" translate="yes" xml:space="preserve">
          <source>TCL interface profile method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd65df2fc14e08847cf659f886e3675b02fd603" translate="yes" xml:space="preserve">
          <source>TCL interface progress method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24560fa957755f945fd0a996100a7a50130fe691" translate="yes" xml:space="preserve">
          <source>TCL interface restore method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c81f806023d5b1efa791fd568b8a71993cb3fc8" translate="yes" xml:space="preserve">
          <source>TCL interface rollback_hook method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d16200e0392f874424c9d693d564e213809df7d" translate="yes" xml:space="preserve">
          <source>TCL interface serialize method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad2308cc6d8c87dd4d39e3a54c207bf26684239" translate="yes" xml:space="preserve">
          <source>TCL interface status method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149cac088a8935337f35ceed17575a182fb384dd" translate="yes" xml:space="preserve">
          <source>TCL variable substitution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def1cac8277b55b62d6889e51352a77e3186587b" translate="yes" xml:space="preserve">
          <source>TEMP</source>
          <target state="translated">TEMP</target>
        </trans-unit>
        <trans-unit id="c02f25e228aca3bb6f42e48160b40dd55194b2cc" translate="yes" xml:space="preserve">
          <source>TEMP Triggers on Non-TEMP Tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d43ca29f9403615d1a5c8f0da40adcdae819802" translate="yes" xml:space="preserve">
          <source>TEMP databases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c21d62a74809c85ca0475d94b6c298ee066de4e" translate="yes" xml:space="preserve">
          <source>TEMP tables and indices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7db63622b3659c5ca6d357417169e72078f0bc" translate="yes" xml:space="preserve">
          <source>TEMP triggers on non-TEMP tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec4186ff6dd054f66dc48342664cc916e7cee64" translate="yes" xml:space="preserve">
          <source>TEMPORARY</source>
          <target state="translated">TEMPORARY</target>
        </trans-unit>
        <trans-unit id="7d4e42ef9d04a046b5679f952cb0b6b5c498c73c" translate="yes" xml:space="preserve">
          <source>TEXT</source>
          <target state="translated">TEXT</target>
        </trans-unit>
        <trans-unit id="6e2d2a0b927ccbcb0059d0c7ba90d9609187d08f" translate="yes" xml:space="preserve">
          <source>TH3</source>
          <target state="translated">TH3</target>
        </trans-unit>
        <trans-unit id="f0b11e9a80109508da2e3cbd3b7a0a8827845799" translate="yes" xml:space="preserve">
          <source>TH3 achieves 100% branch test coverage (and 100% &lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_condition/decision_coverage&quot;&gt;MC/DC&lt;/a&gt;) over the SQLite core. (Test coverage of extensions such as FTS and RTREE is less than 100%).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39ec8bc0fe82988bb1da1f05fc2de8eb41887fa" translate="yes" xml:space="preserve">
          <source>TH3 checks SQLite's response to out-of-memory errors, disk I/O errors, and power loss during transaction commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055f71da54f782f8f65239fd4fb6b9c021760b69" translate="yes" xml:space="preserve">
          <source>TH3 comes with additional TCL scripts that help automate the testing process on workstations. The &quot;th3make&quot; script automatically runs &quot;mkth3.tcl&quot; and &quot;gcc&quot; and then runs the resulting test program and checks the results. Arguments to th3make include all of the &quot;*.test&quot; test modules and &quot;*.cfg&quot; configurations that are to be included in the test. Additional options to th3make can cause the test program to be compiled using different compilers (GCC, Clang, MSVC), to use different output verbosity levels, to run the test program under valgrind, to check the output for coverage using gcov, and so forth. The th3make script also accepts &quot;*.rc&quot; filenames as arguments. These *.rc files are just collections of other arguments that are commonly used together for a single purpose. For example, the &quot;quick.rc&quot; file contains a set of eight arguments to th3make that run a fast (3-minute) full-coverage test. This allows the operator to type &quot;./th3make quick.rc&quot; as a short-cut to typing out all of the required command-line options. The following are a few of the more than 40 available *.rc files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a05ad4acef3c330bf37c9357e657e9ed2af845" translate="yes" xml:space="preserve">
          <source>TH3 exercises SQLite in a variety of run-time configurations (UTF8 vs UTF16, different pages sizes, varying journal modes, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e21da8c02749a044b3aef819f8092fd00ef786" translate="yes" xml:space="preserve">
          <source>TH3 is a test program generator. The output of TH3 is a program implemented in C-code and intended to be linked against the SQLite library under test. The generated test program is compiled and run on the target platform in order to verify correct operation of SQLite on that platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35be3734cb33090a9156032bab76a3246a8875be" translate="yes" xml:space="preserve">
          <source>TH3 is able to run on embedded platforms that lack the support infrastructure of workstations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924274e45e00b2de29022bcd422e62f257c51552" translate="yes" xml:space="preserve">
          <source>TH3 originated from an effort to test SQLite on &lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS&lt;/a&gt;. Prior to TH3, all SQLite tests were run using the &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; script language, but TCL would not (easily) compile on SymbianOS which made testing difficult. The first attempt to remedy this problem was the &quot;TH1&quot; (Test Harness #1) scripting language - a reimplementation of parts of the TCL language in a more portable form that would compile and run on SymbianOS, and that was sufficient to run the SQLite tests. TH1 did not survive as a standard testing tool for SQLite, but it did find continued service as a scripting language used to customize the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system. There was also a &quot;Test Harness #2&quot; which was an attempt to create a simple scripting language using operator prefix notation to drive tests. TH3 was the third attempt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2607d86f3f95561abb29b75d3920751195896dbd" translate="yes" xml:space="preserve">
          <source>TH3 tests SQLite in an as-deployed configuration using only published and documented interfaces. In other words, TH3 tests the compiled object code, not the source code, thus verifying that no problems were introduced by compiler bugs. &quot;Test what you fly and fly what you test.&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87cfbcfb0ff68ef8b8fa0759657744ff88b88af" translate="yes" xml:space="preserve">
          <source>TH3 was originally written for validation testing only, but has subsequently been used for development testing and debugging as well, and has proven very helpful in those roles. A full-coverage test takes less than five minutes on a workstation and hence serves as a fast regression test during day-to-day maintenance of the SQLite code base.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd7f8a83e07337beedb291a476a0abdb89ed6b4f" translate="yes" xml:space="preserve">
          <source>THEN</source>
          <target state="translated">THEN</target>
        </trans-unit>
        <trans-unit id="2c1d90a10bc6577f471f3c2c8cd6836385b31b82" translate="yes" xml:space="preserve">
          <source>TIES</source>
          <target state="translated">TIES</target>
        </trans-unit>
        <trans-unit id="4fe5a3682f8029783789ec9b3abba10f67f03ffa" translate="yes" xml:space="preserve">
          <source>TINYINT</source>
          <target state="translated">TINYINT</target>
        </trans-unit>
        <trans-unit id="15f51444be75bc88e935c57ef2ee7477dc73a64e" translate="yes" xml:space="preserve">
          <source>TO</source>
          <target state="translated">TO</target>
        </trans-unit>
        <trans-unit id="cd4fd03fe967437fff9a9133b579cdd5421577a6" translate="yes" xml:space="preserve">
          <source>TODO:  Add something about checking the page-cache first etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb66aab7e490b4f8a5b13b306c51e116175236a" translate="yes" xml:space="preserve">
          <source>TODO:  After sections 4 and 5 are finished, come back here and see if we can add a list of state items associated with each database connection to make things easier to understand. i.e each database connection has a file handle, a set of entries in the page cache, an expected page size etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc847eb4b63db6446f6040c4f09bb7ba16604ab" translate="yes" xml:space="preserve">
          <source>TODO:  After this document is ready, make the vocabulary consistent and then add a glossary here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e2201a943d83ad82ae3edd3d70f87d9d34b73f" translate="yes" xml:space="preserve">
          <source>TODO:  Describe the parameters set to configure the page cache limits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30bb6265750b23e36fff26fba218f095577396da" translate="yes" xml:space="preserve">
          <source>TODO:  Expand on and explain the above a bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f19663a5c44b6305b426b72aadfc9a70eb894d" translate="yes" xml:space="preserve">
          <source>TODO:  Introduce the following sub-sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593039ec1c1939952bb9949b2bcbe1140a495e60" translate="yes" xml:space="preserve">
          <source>TODO:  Is the shared lock held after committing a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a151926d0634538ee91af79c910ea2132025f5" translate="yes" xml:space="preserve">
          <source>TODO:  Master journal file pointers?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c459077da83b75d52b821b2b77b9e73be290e1e" translate="yes" xml:space="preserve">
          <source>TODO:  Requirements describing the way in which the configuration parameters are used. About LRU etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e945f52e85f69c533b2d7abf6ea281ed104013" translate="yes" xml:space="preserve">
          <source>TODO:  System requirement references for the above points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="840394002935b6f4d9da99212e26895929cd86d7" translate="yes" xml:space="preserve">
          <source>TODO:  What happens if the exclusive lock cannot be obtained? It is not possible for the attempt to upgrade from a reserved to a pending lock to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6714ad8471919f57bc47d379c3524d08542a02be" translate="yes" xml:space="preserve">
          <source>TODO:  Why a 16 byte block? Why not 4? (something to do with encrypted databases).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e614c97a332a0295344a53ea5da2a36633b1954" translate="yes" xml:space="preserve">
          <source>TPC-H Q8 is an eight-way join. As observed above, the main task of the query planner is to figure out the best nesting order of the eight loops in order to minimize the work needed to complete the join. A simplified model of this problem for the case of TPC-H Q8 is shown by the following diagram:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac722ed74faff65da62171d3c4183479a271d1f" translate="yes" xml:space="preserve">
          <source>TRANSACTION</source>
          <target state="translated">TRANSACTION</target>
        </trans-unit>
        <trans-unit id="c162c076dc07a546449be9e07aa7a5c312ecbfe1" translate="yes" xml:space="preserve">
          <source>TRIGGER</source>
          <target state="translated">TRIGGER</target>
        </trans-unit>
        <trans-unit id="74303786eb95ccd75228db361d37b804576e18e6" translate="yes" xml:space="preserve">
          <source>TRUNCATE</source>
          <target state="translated">TRUNCATE</target>
        </trans-unit>
        <trans-unit id="dc45fdb7de43a003177f8df9ee10d01f58f57a58" translate="yes" xml:space="preserve">
          <source>Table B-Tree Interior Cell (header 0x05):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984abe18431413aca60298750d5de10b6d8716c4" translate="yes" xml:space="preserve">
          <source>Table B-Tree Interior Cell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d19a21f457eb5da8f03166c4dbc3a6ef641531" translate="yes" xml:space="preserve">
          <source>Table B-Tree Leaf Cell (header 0x0d):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31beedcdbc76a09dd63a101eacf4e15dc87e80c5" translate="yes" xml:space="preserve">
          <source>Table B-Tree Leaf Cell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdad59a82a2e26e2fc2225d0629f7733aef385c4" translate="yes" xml:space="preserve">
          <source>Table Column Names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1225362d8c3c05de317acf9684ffe2e1a7649c08" translate="yes" xml:space="preserve">
          <source>Table Interior (0x05)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de156b09866349ad52b0a535e8144a86d129a154" translate="yes" xml:space="preserve">
          <source>Table Leaf (0x0d)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27c7c360e130231f97ba874c98e3448dd648d35" translate="yes" xml:space="preserve">
          <source>Table Name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a975d3ec2f404cfb761b1314fc6745ca72f942e" translate="yes" xml:space="preserve">
          <source>Table b-tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92db13efcb630c92ecf1220fd763e9d0e237c97e" translate="yes" xml:space="preserve">
          <source>Table name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70aee3388a925e7cbb0852fe8dcdd4c402a95fd1" translate="yes" xml:space="preserve">
          <source>Table zTable does not exist within database zDb,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8886ec4df0da407409b6e2c6457e09d78592c0c0" translate="yes" xml:space="preserve">
          <source>Table zTable is a WITHOUT ROWID table,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053f4c073c904977c9ac1e40ab060f8397a0907f" translate="yes" xml:space="preserve">
          <source>Table-name must already exists as a table. File-name must exist, and each row must contain the same number of columns as defined in the table. If a line in the file contains more or less than the number of columns defined, the copy method rollbacks any inserts, and returns an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea731c8e5cbf2292cf08d50a7760fa0d709eb35" translate="yes" xml:space="preserve">
          <source>Table-valued Functions In The FROM Clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3ba8bea68a8b6f73ff90024cfd6082eaf4a791" translate="yes" xml:space="preserve">
          <source>Table-valued functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b503117e6dd30a0beff0cc1ab7fb7d005000dd03" translate="yes" xml:space="preserve">
          <source>Table-valued functions exist only for PRAGMAs that return results and that have no side-effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f155ed85208e2d25c37ff0660af9e88e0ce41331" translate="yes" xml:space="preserve">
          <source>Table-valued functions exist only for built-in PRAGMAs, not for PRAGMAs defined using the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ea5c3f4a86eb9511e7fd13ab5c2a7a105f6e9f" translate="yes" xml:space="preserve">
          <source>TableLock</source>
          <target state="translated">TableLock</target>
        </trans-unit>
        <trans-unit id="c52e87aa9f54904a290a1ea1125feb8f0b12b884" translate="yes" xml:space="preserve">
          <source>Tables are removed using the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bee9f4ba2588a4abe8a5e77c961e698fb909d93" translate="yes" xml:space="preserve">
          <source>Tables created using CREATE TABLE AS are initially populated with the rows of data returned by the SELECT statement. Rows are assigned contiguously ascending &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; values, starting with 1, in the &lt;a href=&quot;lang_select#orderby&quot;&gt;order&lt;/a&gt; that they are returned by the SELECT statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b08405f06556bfc4a2cd40880fee5d5df353fe5" translate="yes" xml:space="preserve">
          <source>Tables created using the &quot;CREATE TEMP TABLE&quot; syntax are only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in which the &quot;CREATE TEMP TABLE&quot; statement is originally evaluated. These TEMP tables, together with any associated indices, triggers, and views, are collectively stored in a separate temporary database file that is created as soon as the first &quot;CREATE TEMP TABLE&quot; statement is seen. This separate temporary database file also has an associated rollback journal. The temporary database file used to store TEMP tables is deleted automatically when the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398c675fc2fa417398cf9f153388d4a182136954" translate="yes" xml:space="preserve">
          <source>Tables in an attached database can be referred to using the syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230baa2e574ece0e6ffe7c574dcbbb9cd18fff76" translate="yes" xml:space="preserve">
          <source>Tables with names of the form &quot;sqlite_statN&quot; where N is an integer. Such tables store database statistics gathered by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used by the query planner to help determine the best algorithm to use for each query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dbeddaf590f294decd7c12cd9b3ac14168d3997" translate="yes" xml:space="preserve">
          <source>Take advantage of the atomic-write capabilities in the &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS filesystem&lt;/a&gt; when available, for greatly reduced transaction overhead. This currently requires the &lt;a href=&quot;compile#enable_batch_atomic_write&quot;&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf997da6bf4365bf440bc3ad9c07d7d7925e743" translate="yes" xml:space="preserve">
          <source>Take into account the fact WHERE clause terms that cannot be used with indices still probably reduce the number of output rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2975a6466c6b11f1519a6c8652f37b3cef0c265" translate="yes" xml:space="preserve">
          <source>Take the bit-wise AND of the values in register P1 and P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23882df60c1b18a8b147b1926280887dfe7acb8a" translate="yes" xml:space="preserve">
          <source>Take the bit-wise OR of the values in register P1 and P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0b05dea29609663a6574c364045bd831c5b261" translate="yes" xml:space="preserve">
          <source>Take the logical AND of the values in registers P1 and P2 and write the result into register P3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe2090d6b7e599d38b33eca83b4b2c09d8a131d" translate="yes" xml:space="preserve">
          <source>Take the logical OR of the values in register P1 and P2 and store the answer in register P3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86743ec77172a00f99a2bc089314b61779948598" translate="yes" xml:space="preserve">
          <source>Taking into consideration all of the above, the SQLite developers recommend compiling SQLite using GCC-7 with the -Os optimization setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c9ad6f3798c330d93462b6d6a9dc1c1bbb0620" translate="yes" xml:space="preserve">
          <source>Tarball</source>
          <target state="translated">Tarball</target>
        </trans-unit>
        <trans-unit id="81919e9867e82f4145f1c83ee343766917076a71" translate="yes" xml:space="preserve">
          <source>Tcl Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5962096d8eee555590e081b0968ff7c28d5fa0d8" translate="yes" xml:space="preserve">
          <source>Tcl command. Here is an example of opening and then immediately closing a database:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d70929c5f61502f6c778af83fbc14057a6c36d" translate="yes" xml:space="preserve">
          <source>Tcl interface allows BLOB values to be transferred to user-defined functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fe9aa4119c1f18902f153a0d50a82f529e5cfb" translate="yes" xml:space="preserve">
          <source>Tcl variable names can appear in the SQL statement of the second argument in any position where it is legal to put a string or number literal. The value of the variable is substituted for the variable name. If the variable does not exist a NULL values is used. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2087e1ec9a4eee3edea091cbf4ce24dad9709230" translate="yes" xml:space="preserve">
          <source>Technical and Design Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d6d722a0223fd3e9343b1f4796db6a665b091d" translate="yes" xml:space="preserve">
          <source>Temporary Databases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6035a1db7f899a29bfadee59c52d9c07fdd98c4f" translate="yes" xml:space="preserve">
          <source>Temporary Files Used By SQLite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb2a1ec0fce944f3e17c8ab4b4f05b81d7ac8a9" translate="yes" xml:space="preserve">
          <source>Temporary directory search algorithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f84f0ca9f1ad9f151e46cd589374308dcbfc81" translate="yes" xml:space="preserve">
          <source>Temporary files are always stored in memory regardless of the setting of the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a5156680aa1ea2c11db1f65a26abbd9db39a63" translate="yes" xml:space="preserve">
          <source>Temporary files are always stored on disk regardless of the setting of the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7777ca8353568841ffb0454d79b2cf5d09f1f51b" translate="yes" xml:space="preserve">
          <source>Temporary files are now automatically deleted by the operating system when closed. There are no more dangling temporary files on a program crash. (If the OS crashes, fsck will delete the file after reboot under Unix. I do not know what happens under Windows.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96da9e1a1910e6d40a0e879229d60b3a31a1bf7a" translate="yes" xml:space="preserve">
          <source>Temporary files are stored in memory by default but this can be overridden by the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e15117ca75e55537b6f5f3dded721aee297def" translate="yes" xml:space="preserve">
          <source>Temporary files are stored on disk by default but this can be overridden by the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7500f7d38f84089cbb32d6695814260f35c022d2" translate="yes" xml:space="preserve">
          <source>Temporary journal files are created as part of transaction control, but those extra files are not part of the steady-state database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="455a1e08ff236bc4fc37f10c45a4f1a9d962e921" translate="yes" xml:space="preserve">
          <source>Temporary tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dff3aa4061b74df07e184cd766c027d8d0851b5" translate="yes" xml:space="preserve">
          <source>Terminate the sqlite3 program by typing your system End-Of-File character (usually a Control-D). Use the interrupt character (usually a Control-C) to stop a long-running SQL statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f859f91a5306999f44ef0e2194daef49cbdeb611" translate="yes" xml:space="preserve">
          <source>Terminating a read-only transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46428866c7ab286d2c6ac557b2373b6b72377ee3" translate="yes" xml:space="preserve">
          <source>Terms of the ORDER BY clause that is part of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement may be assigned a collating sequence using the &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, in which case the specified collating function is used for sorting. Otherwise, if the expression sorted by an ORDER BY clause is a column, then the collating sequence of the column is used to determine sort order. If the expression is not a column and has no COLLATE clause, then the BINARY collating sequence is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb252ee8cea482226d27c4a24f04af58befef27" translate="yes" xml:space="preserve">
          <source>Terms of the WHERE clause can be manually disqualified for use with indices by prepending a unary *+* operator to the column name. The unary *+* is a no-op and will not generate any byte code in the prepared statement. But the unary *+* operator will prevent the term from constraining an index. So, in the example above, if the query were rewritten as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8a7aee242ffd686d07e20367e523410ddf047e" translate="yes" xml:space="preserve">
          <source>Test 10: 25000 text UPDATEs with an index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacbc05d861c7b90deae327687214123e261d5d7" translate="yes" xml:space="preserve">
          <source>Test 11: INSERTs from a SELECT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca64bdf90089bb1a7f070072ce5ba7eb929e0ca" translate="yes" xml:space="preserve">
          <source>Test 12: DELETE without an index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24752c37e60c377f791b489053904e7999992109" translate="yes" xml:space="preserve">
          <source>Test 13: DELETE with an index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00cb0edebe54a9c5c407d066d9fcba0da202194b" translate="yes" xml:space="preserve">
          <source>Test 14: A big INSERT after a big DELETE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8033466c1d65a1a2a0c68dc77e0e42697e35f88b" translate="yes" xml:space="preserve">
          <source>Test 15: A big DELETE followed by many small INSERTs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391b748d4bf30ad6ba35b1537b20fb9263b9be11" translate="yes" xml:space="preserve">
          <source>Test 16: DROP TABLE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="700f1cfb18cec62b7bd8f4bd15b16b69774b094a" translate="yes" xml:space="preserve">
          <source>Test 1: 1000 INSERTs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a74380705222d36f436d75c90099251831b68c6d" translate="yes" xml:space="preserve">
          <source>Test 2: 25000 INSERTs in a transaction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01c89b36c5ea1e456013c3cc10174d42005deaa" translate="yes" xml:space="preserve">
          <source>Test 3: 25000 INSERTs into an indexed table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5150380a9467a7720fe9216afc4866b3aea9f992" translate="yes" xml:space="preserve">
          <source>Test 4: 100 SELECTs without an index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d07089542c5b6e56dea3631a868016dd2267c55" translate="yes" xml:space="preserve">
          <source>Test 5: 100 SELECTs on a string comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee313e9981650c288efefb71dc3528b68b2a91a" translate="yes" xml:space="preserve">
          <source>Test 6: Creating an index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0797e7844f18b5e63c9d2f6207a7266e87d829e" translate="yes" xml:space="preserve">
          <source>Test 7: 5000 SELECTs with an index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccbfc70f55db2b38d057e5e2decb47d90df070e" translate="yes" xml:space="preserve">
          <source>Test 8: 1000 UPDATEs without an index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47ad12d810778d98e72de67605dc988105d4b09b" translate="yes" xml:space="preserve">
          <source>Test 9: 25000 UPDATEs with an index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a302ee283ea042f30ca2cb852a2846f97c9413" translate="yes" xml:space="preserve">
          <source>Test Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcf57d6160711801ae44b031c459127add7faaa" translate="yes" xml:space="preserve">
          <source>Test Environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76dd0a3dd495aa45fe2a39614c44782afcb01ca" translate="yes" xml:space="preserve">
          <source>Test For Auto-Commit Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05597ed0dba53dda21d6b294858039879f34b2b" translate="yes" xml:space="preserve">
          <source>Test To See If The Library Is Threadsafe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02446da6bfd0c0c261b870c2d7a5bfb426f2969d" translate="yes" xml:space="preserve">
          <source>Test data unavailable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a364e52356a7ca07cff67161e3755ffa1a5b6b19" translate="yes" xml:space="preserve">
          <source>Test if a changeset has recorded any changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0687fd76855654ace6e8592132670b232e8466bb" translate="yes" xml:space="preserve">
          <source>Test if a changeset has recorded any changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975278e4cf4ae85f07454f0bd57ddce6fc5bd9a5" translate="yes" xml:space="preserve">
          <source>Testcase macros are also used when two or more cases of a switch statement go to the same block of code, to make sure that the code was reached for all cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d38ba7cbc400f9b209719e16e540214a64776c" translate="yes" xml:space="preserve">
          <source>Testing Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adc754de4730d9303e4e9dfdc04c11250d45d3c" translate="yes" xml:space="preserve">
          <source>Testing Interface Operation Codes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b27896db003bc4e45807f83422aff3b0ba8af9" translate="yes" xml:space="preserve">
          <source>Testing of both source code and object code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1859263f675753d24029e449e12bbca3196f641" translate="yes" xml:space="preserve">
          <source>Testing on multiple platforms and with multiple compilers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9efb9d787a1a844d9d75c706c96b2d104de210f" translate="yes" xml:space="preserve">
          <source>Text Encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104683d616e58eaef10d6dc4873ecdc3df7b2908" translate="yes" xml:space="preserve">
          <source>Text encoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12c4eeb80ad1f4c53769014c35b62416e040202" translate="yes" xml:space="preserve">
          <source>Text files read by the COPY command can now have line terminators of LF, CRLF, or CR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9a8c0f2eca40d02a98349a624352ec809c4662" translate="yes" xml:space="preserve">
          <source>Text is appended to the sqlite3_str object using various methods, such as &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f06b000ef5df2cf2524013049769bc8b85cadef" translate="yes" xml:space="preserve">
          <source>Text is appended to the sqlite3_str object using various methods, such as &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ebd99ce12ebe199710e41e33f5f3620f55ed7a" translate="yes" xml:space="preserve">
          <source>Text values (odd serial types 13 and larger) sort after numeric values in the order determined by the columns &lt;a href=&quot;datatype3#collation&quot;&gt;collating function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beca9771feb98f615524a1df72482f4458f93607" translate="yes" xml:space="preserve">
          <source>Text values come after numerics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938716cf9d2d773dc94de020d7864e49e44b2b9d" translate="yes" xml:space="preserve">
          <source>Th functionality described in this section may be integrated into other applications or tools using the &lt;a href=&quot;http://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt; SQLite expert extension&lt;/a&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5401c7212b5c2e26aee89d6b33a167be2b97f64d" translate="yes" xml:space="preserve">
          <source>That command only works as written on Windows. The equivalent line on a Mac would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3c3c06cd257877a1f47703881aa426e835ba23" translate="yes" xml:space="preserve">
          <source>That last command is the same &quot;ui&quot; command that we ran before. It starts a mini-webserver running and points your web browser at it. But this time we didn't have to specify the repository file because we are located inside a checkout and so fossil can figure out the repository for itself. If you want to type in the repository filename as the second argument, you can. But it is optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec5cf39a76e0d09154e1a51128f437190f411ce" translate="yes" xml:space="preserve">
          <source>That said, there are a number of things that external programs or bugs in your hardware or OS can do to corrupt a database file. See &lt;a href=&quot;howtocorrupt&quot;&gt;How To Corrupt An SQLite Database File&lt;/a&gt; for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac09579911e9129dbe219b67c0bf67a294beccfa" translate="yes" xml:space="preserve">
          <source>That statement is ambiguous, having at least two possible interpretations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c679c2a5140d95b7fe5e7a9c937890448e4790a5" translate="yes" xml:space="preserve">
          <source>That there are the same number of entries in the %_parent table as there are non-leaf cells in the r-tree structure, and that there is a non-leaf cell that corresponds to each entry in the %_parent table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc14fa3c4653db3dfe511c9da292c9e32677da7" translate="yes" xml:space="preserve">
          <source>That there are the same number of entries in the %_rowid table as there are leaf cells in the r-tree structure, and that there is a leaf cell that corresponds to each entry in the %_rowid table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="c3fcc1dd87de9c9ad15a933b970c62ff1decbfcb" translate="yes" xml:space="preserve">
          <source>The &quot;%&quot; in the name of each shadow table is replaced by the name of the R*Tree virtual table. So, if the name of the R*Tree table is &quot;xyz&quot; then the three shadow tables would be &quot;xyz_node&quot;, &quot;xyz_parent&quot;, and &quot;xyz_rowid&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ac1d4dc22d0f78dbeef0512926462de5ac6f42" translate="yes" xml:space="preserve">
          <source>The &quot;-1&quot; term at the start of the formula is not found in most implementations of the BM25 algorithm. Without it, a better match is assigned a numerically higher BM25 score. Since the default sorting order is &quot;ascending&quot;, this means that appending &quot;ORDER BY bm25(fts)&quot; to a query would cause results to be returned in order from worst to best. The &quot;DESC&quot; keyword would be required in order to return the best matches first. In order to avoid this pitfall, the FTS5 implementation of BM25 multiplies the result by -1 before returning it, ensuring that better matches are assigned numerically lower scores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a8a21328c61527fb3df55781ac56d188f8d80f" translate="yes" xml:space="preserve">
          <source>The &quot;.archive&quot; dot-command and the &quot;-A&quot; command-line option provide built-in support for the &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive format&lt;/a&gt;. The interface is similar to that of the &quot;tar&quot; command on unix systems. Each invocation of the &quot;.ar&quot; command must specify a single command option. The following commands are available for &quot;.archive&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83487a27f6e8c5a3e4b3ee1c0c3210033e4ad993" translate="yes" xml:space="preserve">
          <source>The &quot;.breakpoint&quot; command in the CLI does nothing but invoke the procedure named &quot;test_breakpoint()&quot;, which is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469a3442411a65b2a429f963b79791f612ed7d6e" translate="yes" xml:space="preserve">
          <source>The &quot;.databases&quot; command shows a list of all databases open in the current connection. There will always be at least 2. The first one is &quot;main&quot;, the original database opened. The second is &quot;temp&quot;, the database used for temporary tables. There may be additional databases listed for databases attached using the ATTACH statement. The first output column is the name the database is attached with, and the second column is the filename of the external file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee926b57bed300f9a7e5c92f6be433c508e9bcc7" translate="yes" xml:space="preserve">
          <source>The &quot;.dump&quot; output from the shell does not work if there are embedded newlines anywhere in the data. This is an old bug that was carried forward from version 1.0. To fix it, the &quot;.dump&quot; output no longer uses the COPY command. It instead generates INSERT statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b85291d31b07e89b01fbd9925959d88473c2a10" translate="yes" xml:space="preserve">
          <source>The &quot;.excel&quot; command is an alias for &quot;.once -x&quot;. It does exactly the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9686c64857b56634cf1d980b549835b7a48ecb3c" translate="yes" xml:space="preserve">
          <source>The &quot;.excel&quot; command is really an alias for &quot;.once -x&quot;. The -x option to .once causes it to writes results as CSV into a temporary file that is named with a &quot;.csv&quot; suffix, then invoke the systems default handler for CSV files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ea244938baaf074aedf53e702eadce70d483bf" translate="yes" xml:space="preserve">
          <source>The &quot;.expert&quot; command accepts the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62869dd914f2d45ca628931082045505cc0aa98c" translate="yes" xml:space="preserve">
          <source>The &quot;.expert&quot; command is issued first, followed by the SQL query on a separate line. For example, consider the following session:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf73e6ae296e826f7923e0357132694890491637" translate="yes" xml:space="preserve">
          <source>The &quot;.fullschema&quot; dot-command works like the &quot;.schema&quot; command in that it displays the entire database schema. But &quot;.fullschema&quot; also includes dumps of the statistics tables &quot;sqlite_stat1&quot;, &quot;sqlite_stat3&quot;, and &quot;sqlite_stat4&quot;, if they exist. The &quot;.fullschema&quot; command normally provides all of the information needed to exactly recreate a query plan for a specific query. When reporting suspected problems with the SQLite query planner to the SQLite development team, developers are requested to provide the complete &quot;.fullschema&quot; output as part of the trouble report. Note that the sqlite_stat3 and sqlite_stat4 tables contain samples of index entries and so might contain sensitive data, so do not send the &quot;.fullschema&quot; output of a proprietary database over a public channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c41f773b4bec069e65cdeb1f84472339fd67927" translate="yes" xml:space="preserve">
          <source>The &quot;.genfkey&quot; operator has been removed from the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da1e8e52719870c46e4714e803817bbb945c7a2" translate="yes" xml:space="preserve">
          <source>The &quot;.indexes&quot; command works in a similar way to list all of the indexes. If the &quot;.indexes&quot; command is given an argument which is the name of a table, then it shows just indexes on that table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332e81eb83bf30c51e9f2eb4830d160fd5e91b60" translate="yes" xml:space="preserve">
          <source>The &quot;.load&quot; command with one argument invokes sqlite3_load_extension() with the zProc parameter set to NULL, causing SQLite to first look for an entry point named &quot;sqlite3_extension_init&quot; and then &quot;sqlite3_X_init&quot; where &quot;X&quot; is derived from the filename. If your extension has an entry point with a different name, simply supply that name as the second argument. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0f642688db88c440c3786a62b2e62ab2274b87" translate="yes" xml:space="preserve">
          <source>The &quot;.parameter&quot; command exists to simplify managing this table. The &quot;.parameter init&quot; command (often abbreviated as just &quot;.param init&quot;) creates the temp.sqlite_parameters table if it does not already exist. The &quot;.param list&quot; command shows all entries in the temp.sqlite_parameters table. The &quot;.param clear&quot; command drops the temp.sqlite_parameters table. The &quot;.param set KEY VALUE&quot; and &quot;.param unset KEY&quot; commands create or delete entries from the temp.sqlite_parameters table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789a156efc523de5bfce09730a51219cae2ec0c9" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command can be augmented with the &quot;--indent&quot; option, in which case it tries to reformat the various CREATE statements of the schema so that they are more easily readable by humans.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754968254f462d66877df03c1c7cd51953693cab" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command is roughly the same as setting list mode, then entering the following query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7428559526f83a5c56d268af9889807faae2685e" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command shows the complete schema for the database, or for a single table if an optional tablename argument is provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ace065300c40138c37799338bd3ec51aca18df" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command shows the structure of virtual tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bcba8970e82dc921d7f4ec8db20bb33cbfb0a3" translate="yes" xml:space="preserve">
          <source>The &quot;.selftest --init&quot; command creates the selftest table if it does not already exists, then appends entries that check the SHA3 hash of the content of all tables. Subsequent runs of &quot;.selftest&quot; will verify that the database has not been changed in any way. To generates tests to verify that a subset of the tables are unchanged, simply run &quot;.selftest --init&quot; then &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; the selftest rows that refer to tables that are not constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23d6efbb796b87124747de656b1313433a59a58" translate="yes" xml:space="preserve">
          <source>The &quot;.selftest&quot; command attempts to verify that a database is intact and is not corrupt. The .selftest command looks for a table in schema named &quot;selftest&quot; and defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da3394cbf6e430093bb273dc53c5c24290fb42a2" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command is implemented with the help of the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/shathree.c&quot;&gt;extension function &quot;sha3_query()&quot;&lt;/a&gt; that is included with the command-line shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49607863a0b317eaa9e0bb0334b35c6b17a96a09" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command supports options &quot;--sha3-224&quot;, &quot;--sha3-256&quot;, &quot;--sha3-384&quot;, and &quot;--sha3-512&quot; to define which variety of SHA3 to use for the hash. The default is SHA3-256.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e496b68fde3cba7a6d3e4d071d1b64676cd89817" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command takes a single optional argument which is a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern. If this option is present, only tables whose names match the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern will be hashed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e55e4c460c47133735d47238f402c87368287c" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; dot-command computes a &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-3&quot;&gt;SHA3&lt;/a&gt; hash of the &lt;em&gt;content&lt;/em&gt; of the database. To be clear, the hash is computed over the database content, not its representation on disk. This means, for example, that a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or similar data-preserving transformation does not change the hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2252b9e19709b03f7ab086b59b1a77291173bd1" translate="yes" xml:space="preserve">
          <source>The &quot;.tables&quot; command is similar to setting list mode then executing the following query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eda9619ee5cbc80757e21696103e58ade470ff1" translate="yes" xml:space="preserve">
          <source>The &quot;.width&quot; command in the example above sets the width of the first column to 12 and the width of the second column to 6. All other column widths were unaltered. You can give as many arguments to &quot;.width&quot; as necessary to specify the widths of as many columns as are in your query results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d28508cd52964017863df7d9bff1bae6f7b1b73" translate="yes" xml:space="preserve">
          <source>The &quot;1&quot; at the end of the name for the json1 extension is deliberate. The designers anticipate that there will be future incompatible JSON extensions building upon the lessons learned from json1. Once sufficient experience is gained, some kind of JSON extension might be folded into the SQLite core. For now, JSON support remains an extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec1a7b1bff513b8dc885dad8096593de50c679b9" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt;&quot; command ignores an initial UTF-8 BOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a3b12173588647fa6bbe9bfdec68cffc6ff3a2" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; must be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt; where the right-most &lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator&lt;/a&gt; is either UNION or UNION ALL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1ee86a4eb35dd217941c49a4c1f826afe5d0c7" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; syntax diagram above attempts to show as much of the SELECT statement syntax as possible in a single diagram, because some readers find that helpful. The following &quot;&lt;a href=&quot;syntax/factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&quot; is an alternative syntax diagrams that expresses the same syntax but tries to break the syntax down into smaller chunks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f631ef63bea49256ea8a2d7bafc4554c3faedfb" translate="yes" xml:space="preserve">
          <source>The &quot;Application ID&quot; set by &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f5d1070df133cbc828d184fa205995550d45fd" translate="yes" xml:space="preserve">
          <source>The &quot;CREATE TABLE&quot; command is used to create a new table in an SQLite database. A CREATE TABLE command specifies the following attributes of the new table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5736b1f20cbfd4541c75d144c2bb263b3a789707" translate="yes" xml:space="preserve">
          <source>The &quot;INDEXED BY index-name&quot; phrase specifies that the named index must be used in order to look up values on the preceding table. If index-name does not exist or cannot be used for the query, then the preparation of the SQL statement fails. The &quot;NOT INDEXED&quot; clause specifies that no index shall be used when accessing the preceding table, including implied indices create by UNIQUE and PRIMARY KEY constraints. However, the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; can still be used to look up entries even when &quot;NOT INDEXED&quot; is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21fa27bc6e581b8fb060c98b51ebafd394898e71" translate="yes" xml:space="preserve">
          <source>The &quot;INSERT INTO</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c67e89c578626f4a5845690f5e802d46290edfe" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY 2&quot; (which means the same as &quot;ORDER BY under_alice.level+1&quot;) causes higher levels in the organization chart (with smaller &quot;level&quot; values) to be processed first, resulting in a breadth-first search. The output is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f957a1348139bb0e4f79cd1d2fbd5306c674fbde" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY checkin.mtime DESC&quot; term in the recursive-select makes the query run much faster by preventing it from following branches that merge checkins from long ago. The ORDER BY forces the recursive-select to focus on the most recent checkins, the ones we want. Without the ORDER BY on the recursive-select, one would be forced to compute the complete set of thousands of ancestors, sort them all by mtime, then take the top twenty. The ORDER BY essentially sets up a priority queue that forces the recursive query to look at the most recent ancestors first, allowing the use of a LIMIT clause to restrict the scope of the query to just the checkins of interest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05aec33569483f3dc1a8463df38060dbf53e2c35" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA cache_spill=</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0a062742c0bea5342163f23635fff0e75751fe" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; command provides an indication that the database file has been modified. Interactive programs that hold database content in memory or that display database content on-screen can use the PRAGMA data_version command to determine if they need to flush and reload their memory or update the screen display.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c212d19062433a8ddb99b497e81dcefb5db939" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; value is a local property of each database connection and so values returned by two concurrent invocations of &quot;PRAGMA data_version&quot; on separate database connections are often different even though the underlying database is identical. It is only meaningful to compare the &quot;PRAGMA data_version&quot; values returned by the same database connection at two different points in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03965d42503dca17ab62ff9cad1d8a5c3c8ffdbb" translate="yes" xml:space="preserve">
          <source>The &quot;Page Count&quot; - The number of pages in the next segment of the journal, or -1 to mean all content to the end of the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c6586de090c3bc2e13cc3b6a2a69ed36fa59fa" translate="yes" xml:space="preserve">
          <source>The &quot;USING TEMP B-TREE&quot; clause in the above output indicates that a temporary b-tree structure is used to implement the UNION of the results of the two sub-selects. An alternative method of computing a compound is to run each subquery as a co-routine, arrange for their outputs to appear in sorted order, and merge the results together. When the query planner chooses this latter approach, the EXPLAIN QUERY PLAN output looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bff9645401cb328b5613b5233bf3e5ba1e2eb1" translate="yes" xml:space="preserve">
          <source>The &quot;alternate-form-2&quot; flag (&quot;!&quot;) on the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; implementation now causes string substitutions to measure the width and precision in characters instead of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4319cae606348ce23e782f966b47ff645421643" translate="yes" xml:space="preserve">
          <source>The &quot;atom&quot; column is the SQL value corresponding to primitive elements - elements other than JSON arrays and objects. The &quot;atom&quot; column is NULL for a JSON array or object. The &quot;value&quot; column is the same as the &quot;atom&quot; column for primitive JSON elements but takes on the text JSON value for arrays and objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8a5773e6c48280d7fe42741f8b4a093d392533" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2039edadf3792f44d9f55f1e52e41e045647126" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method provides access to the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C/C++ interface. The argument to authorizer is the name of a procedure that is called when SQL statements are being compiled in order to authorize certain operations. The callback procedure takes 5 arguments which describe the operation being coded. If the callback returns the text string &quot;SQLITE_OK&quot;, then the operation is allowed. If it returns &quot;SQLITE_IGNORE&quot;, then the operation is silently disabled. If the return is &quot;SQLITE_DENY&quot; then the compilation fails with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d780e49acdf2e828a0e7b0580dfd96aff50cee2e" translate="yes" xml:space="preserve">
          <source>The &quot;automerge=N&quot; command (where N is an integer between 0 and 15, inclusive) is used to configure an FTS3/4 tables &quot;automerge&quot; parameter, which controls automatic incremental inverted index merging. The default automerge value for new tables is 0, meaning that automatic incremental merging is completely disabled. If the value of the automerge parameter is modified using the &quot;automerge=N&quot; command, the new parameter value is stored persistently in the database and is used by all subsequently established database connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35cc018cff76ce7093039d6d69782515b8dd9cbd" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c005edd2de62803b18a4eb1743378927a517fad5" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method makes a backup copy of a live database. The command syntax is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7652bc7646799c25c956b30319f71b75ca9a3e80" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31d9979cf6770ea07cdb2b87a23b0343179e30e" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method gives the application control over how to handle parameter binding when no TCL variable matches the parameter name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fd78a195f0dd5acebc1e5d408aa889656042c4" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method has a single optional argument. If the argument is an empty string, then the bind_fallback is cancelled and the default behavior is restored. If the argument is a non-empty string, then the argument is a TCL command (usually the name of a proc) to invoke whenever an SQL parameter is seen that does not match any TCL variable. If the &quot;bind_fallback&quot; method is given no arguments, then the current bind_fallback command is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a08084b4de7b3f67549ffe53d83ec728fa3cca" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cabb870539d2659c509ca5d30b8de78ce6a143" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method, like &quot;timeout&quot;, only comes into play when the database is locked. But the &quot;busy&quot; method gives the programmer much more control over what action to take. The &quot;busy&quot; method specifies a callback Tcl procedure that is invoked whenever SQLite tries to open a locked database. A single integer argument is appended to the callback before it is invoke. The argument is the number of prior calls to the busy callback for the current locking event. It is intended that the callback will do some other useful work for a short while (such as service GUI events) then return so that the lock can be tried again. The callback procedure should return &quot;0&quot; if it wants SQLite to try again to open the database and should return &quot;1&quot; if it wants SQLite to abandon the current operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="806dbf019d18a933c45ea06755b6a277743f61ae" translate="yes" xml:space="preserve">
          <source>The &quot;cache&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5d5ba4e30c1f02fb732b5f9e013dee90e5777d" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94441f79eee4930e4324a3b4a4acbce248260c58" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified by the most recent &quot;eval&quot; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fc353d826f676e72487db0fd8f37052f9b16c1" translate="yes" xml:space="preserve">
          <source>The &quot;close&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78db738260018e26bc56c431d7e164adb66bba3" translate="yes" xml:space="preserve">
          <source>The &quot;collate&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be1a86e589629a9a881a6da512b2ad6b5f62c78" translate="yes" xml:space="preserve">
          <source>The &quot;collation_needed&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f6089837a9332235ef1f677d9e2936edf51cae" translate="yes" xml:space="preserve">
          <source>The &quot;columns&quot; of a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or FROM-clause subquery are really the expressions in the result set of the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that implements the VIEW or subquery. Thus, the affinity for columns of a VIEW or subquery are determined by the expression affinity rules above. Consider an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efc033d7171b4cae5dcc026d731d1abc23f16f8" translate="yes" xml:space="preserve">
          <source>The &quot;commit_hook&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075f9fcec0c51906d7830312bd2ffff7ac323743" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36202288005d888ee9c02c9332ba422aac36a5b3" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method is useful when building interactive applications in order to know when the user has finished entering a line of SQL code. This is really just an interface to the &lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;sqlite3_complete()&lt;/b&gt;&lt;/a&gt; C function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6d6b519cc240799d0eae2497f1b956b7749126" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method takes a string of supposed SQL as its only argument. It returns TRUE if the string is a complete statement of SQL and FALSE if there is more to be entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bbc7a4eaf4d4f9fe40b357ef388a365c9285df" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bb4ff8aef62d6cb6272264cef7cda239984bc9" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method queries or changes certain configuration settings for the database connection using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface. Run this method with no arguments to get a TCL list of available configuration settings and their current values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b266e6a044670a6e3a5e4102b0820031cb7ab393" translate="yes" xml:space="preserve">
          <source>The &quot;configure&quot; scripts should now automatically configure Unix systems for large file support. Improved error messages for when large files are encountered and large file support is disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577865d2c9835070772d4e94f47615cadfb2baec" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be51d012e0d49a380524a8121847e82af3226bf" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac7414b87b280f152adca2a25c602ba20600788" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aae3497dac443e109983b1c00a5960530139406" translate="yes" xml:space="preserve">
          <source>The &quot;content&quot; option, used to make the FTS5 table an &lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;external content or contentless table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c79f409b23d48e87e77e61ee87998224597bc3" translate="yes" xml:space="preserve">
          <source>The &quot;content_rowid&quot; option, used to set the rowid field of an &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39cd9c81e20b57d6b78e1af2643005b4d6ac3fb3" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="983ea0fee26b9222536bfed9a0514ad997e9a0a2" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method copies data from a file into a table. It returns the number of rows processed successfully from the file. The syntax of the copy method looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3e7bd12c41305b3fc796bf145f478af20ae557" translate="yes" xml:space="preserve">
          <source>The &quot;cost&quot; here is logarithmic. With nested loops, the work is multiplied, not added. But it is customary to think of graphs with additive weights and so the graph shows the logarithm of the various costs. The graph shows a cost advantage of S being inside of L of about 6.87, but this translates into the query running about 963 times faster when S loop is inside of the L loop rather than being outside of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350bdd92630f61bca90b3168c90039a63f7ced5e" translate="yes" xml:space="preserve">
          <source>The &quot;csv&quot; mode option in the shell puts strings inside double-quotes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f521a5c994d919d955260e93be15342970bdf26" translate="yes" xml:space="preserve">
          <source>The &quot;db&quot; parameter is a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The &quot;main&quot; argument is the name of the schema in which the imposter table is to be created. The &quot;1&quot; argument enables the imposter table mechanism. &quot;tnum&quot; is the root page of the index that the imposter table should mirror.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7867d45fc6532563a6e0e1052f994086d7d4d3" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f372f07e9e348fc01623f3016d82e06dd84212c" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method takes a TCL byte-array that contains an SQLite database file and adds it to the database connection. The syntax is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b478850c0ef98b47e5a07304d319496a735ccd" translate="yes" xml:space="preserve">
          <source>The &quot;docid&quot; alias does not exist. Applications must use &quot;rowid&quot; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cca21a87502057869d942479f833e57c886177" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the T parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b47ab7441632c19a646d6f3d2e70bb71a8af6b" translate="yes" xml:space="preserve">
          <source>The &quot;ellipses&quot; text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785dfb0eb14780fdc8609d7c7187bbcbf0dfe81b" translate="yes" xml:space="preserve">
          <source>The &quot;enable_load_extension&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24181470839fe75a380a1959898a8b67107aab1a" translate="yes" xml:space="preserve">
          <source>The &quot;end match&quot; text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4952b422a3c809d77afa1776609a2750c092857" translate="yes" xml:space="preserve">
          <source>The &quot;errorcode&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f7c0ddb2f3a3e97f9983c467d9c601808c789a" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da370283ad69c2823d6201a69b7d1765374cb685" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method described &lt;a href=&quot;#eval&quot;&gt;above&lt;/a&gt; keeps a cache of &lt;a href=&quot;c3ref/prepare&quot;&gt;prepared statements&lt;/a&gt; for recently evaluated SQL commands. The &quot;cache&quot; method is used to control this cache. The first form of this command is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221bab33d21ea69f4dd52f3f0492767cb572de7f" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdfc3e12d096d22035e667cf9f9a8fa50dec02d" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is often used to test for the existence of rows in a table. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64883f01f5bafd4c69a4447377f37fc6c44868cb" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is similar to &quot;onecolumn&quot; and &quot;eval&quot; in that it executes SQL statements. The difference is that the &quot;exists&quot; method always returns a boolean value which is TRUE if a query in the SQL statement it executes returns one or more rows and FALSE if the SQL returns an empty set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa39980ca4c6c390fc0963b907ef032a2115a04" translate="yes" xml:space="preserve">
          <source>The &quot;family&quot; table is similar to the earlier &quot;org&quot; table except that now there are two parents to each member. We want to know all living ancestors of Alice, from oldest to youngest. An ordinary common table expression, &quot;parent_of&quot;, is defined first. That ordinary CTE is a view that can be used to find all parents of any individual. That ordinary CTE is then used in the &quot;ancestor_of_alice&quot; recursive CTE. The recursive CTE is then used in the final query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0decf38085a4ffc55fce2f25b175fd346628c61" translate="yes" xml:space="preserve">
          <source>The &quot;fast&quot; setting for secure_delete (added circa 2017-08-01) is an intermediate setting in between &quot;on&quot; and &quot;off&quot;. When secure_delete is set to &quot;fast&quot;, SQLite will overwrite deleted content with zeros only if doing so does not increase the amount of I/O. In other words, the &quot;fast&quot; setting uses more CPU cycles but does not use more I/O. This has the effect of purging all old content from &lt;a href=&quot;fileformat2#btree&quot;&gt;b-tree pages&lt;/a&gt;, but leaving forensic traces on &lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist pages&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5e5534bc0599c1bf3dbead2d2f44bed70807ce6" translate="yes" xml:space="preserve">
          <source>The &quot;fsync()&quot; that occurs after the header is written in a WAL reset now uses the sync settings for checkpoints. This means it will use a &quot;fullfsync&quot; on macs if &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync&lt;/a&gt; set on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80417a09b17dfee14228d5c4ecb3ba63e1360a53" translate="yes" xml:space="preserve">
          <source>The &quot;fts3tokenize&quot; virtual table can be used to directly access any tokenizer. The following SQL demonstrates how to create an instance of the fts3tokenize virtual table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cdf37fe2751376d1b848056d4ec78cc31cd8173" translate="yes" xml:space="preserve">
          <source>The &quot;fullkey&quot; column is a text path that uniquely identifies the current row element within the original JSON string. The complete key to the true top-level element is returned even if an alternative starting point is provided by the &quot;root&quot; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81485590afed062476035ea78c2df833a07ce15c" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982021b0dd51770755c9c9e39c1c765e77fbdd84" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method accepts the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e581fe2aa68e5275a553b3adbf390b762a9e4053" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method registers new SQL functions with the SQLite engine. The arguments are the name of the new SQL function and a TCL command that implements that function. Arguments to the function are appended to the TCL command before it is invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9f7422b3d2ef0edf475eeb60798d293ddec7bd" translate="yes" xml:space="preserve">
          <source>The &quot;fuzzershell.c&quot; program is used to run some &lt;a href=&quot;#fuzztesting&quot;&gt;fuzz tests&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4947473658b4ae028d7e71df03314bb5d6e009" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b3487c37966e4df98f8fc69e59c76eae09190d" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;c_scanstat_est&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abd56a3f33aa682cb5beed98f5ecb39cbd50edd" translate="yes" xml:space="preserve">
          <source>The &quot;id&quot; column is an integer that identifies a specific JSON element within the complete JSON string. The &quot;id&quot; integer is an internal housekeeping number, the computation of which might change in future releases. The only guarantee is that the &quot;id&quot; column will be different for every row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8669e4db9525865c9346904ab8bb3b3eb055a9" translate="yes" xml:space="preserve">
          <source>The &quot;incrblob&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d184fd38641411539a264597b11e40c38841938" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; or staging area</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e7f631fc9ab8b7e2eecdc6301a632079a07cf7" translate="yes" xml:space="preserve">
          <source>The &quot;input&quot; CTE defines the input puzzle. The &quot;digits&quot; CTE defines a table that holds all digits between 1 and 9. The work of solving the puzzle is undertaken by the &quot;x&quot; CTE. An entry in x(s,ind) means that the 81-character string &quot;s&quot; is a valid sudoku puzzle (it has no conflicts) and that the first unknown character is at position &quot;ind&quot;, or ind==0 if all character positions are filled in. The goal, then, is to compute entries for &quot;x&quot; with an &quot;ind&quot; of 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6cb46f4a227f8313e332f23912dfe269a430a8c" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd32578e68672fbb14bf7b3a04807a29e7c2c005" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47984da42c27787f28bd87d963296a6ecc85d38" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command causes SQLite to read and verify the accuracy of all inverted indices in an FTS3/4 table by comparing those inverted indices against the original content. The &quot;integrity-check&quot; command silently succeeds if the inverted indices are all ok, but will fail with an SQLITE_CORRUPT error if any problems are found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ee1009fc8d7ceb03381f3a07a84d688fe06706" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command is similar in concept to &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;. In a working system, the &quot;integrity-command&quot; should always be successful. Possible causes of integrity-check failures include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9351b7e4831f50f0cddfc49da3ef44df26240c27" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5c7fcb603da939ee7df1123931389580f03242" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method invokes the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface, causing any pending queries to halt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33827ff37e59286ea63b18a3b491ccd55fa35d36" translate="yes" xml:space="preserve">
          <source>The &quot;isInit&quot; flag. 1 when the shm file has been initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d80d07107f3dd674071f8dcb5d66e927b93ae8" translate="yes" xml:space="preserve">
          <source>The &quot;isolation&quot; property of a database determines when changes made to the database by one operation become visible to other concurrent operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6207f3c60486460fc150891b4e2b2ff184348d" translate="yes" xml:space="preserve">
          <source>The &quot;key&quot; column is the integer array index for elements of a JSON array and the text label for elements of a JSON object. The key column is NULL in all other cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06bf7b5c9acc6e224eb6aebb494891b0b016a3d" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bbfdca82da26696ded7dc7b5667ad95fba9734" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method returns an integer which is the ROWID of the most recently inserted database row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7284b909bd501ff8419335375b9cbd82855b5cf7" translate="yes" xml:space="preserve">
          <source>The &quot;localtime&quot; modifier (12) assumes the time string to its left is in Universal Coordinated Time (UTC) and adjusts the time string so that it displays localtime. If &quot;localtime&quot; follows a time that is not UTC, then the behavior is undefined. The &quot;utc&quot; modifier is the opposite of &quot;localtime&quot;. &quot;utc&quot; assumes that the string to its left is in the local timezone and adjusts that string to be in UTC. If the prior string is not in localtime, then the result of &quot;utc&quot; is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b3080063f65f5e859c8cbf90675f21f18f1993" translate="yes" xml:space="preserve">
          <source>The &quot;lost_and_found&quot; table contains one row for each orphaned row recovered from the database. Additionally, there is one row for each recovered index entry that cannot be attributed to any SQL index. This is because, in an SQLite database, the same format is used to store SQL index entries and WITHOUT ROWID table entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9bb88fb1467415e1fd0ce3e886e98f2fabd9f8" translate="yes" xml:space="preserve">
          <source>The &quot;main&quot; argument to dbstat is default schema for which information is to be provided. The default is &quot;main&quot;, and so the use of &quot;main&quot; in the example above is redundant. For any particular query, the schema can be changed by specifying the alternative schema as a function argument to the virtual table name in the FROM clause of the query. (See further discussion of &lt;a href=&quot;lang_select#tabfunc1&quot;&gt;table-valued functions in the FROM clause&lt;/a&gt; for more details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09862758c2c346b79031222c95f1cc2f0ca91ec9" translate="yes" xml:space="preserve">
          <source>The &quot;make&quot; utility, or optionally &quot;nmake&quot; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658c3f95d62bc63b68f3b7aa685ee8fbc83d8cde" translate="yes" xml:space="preserve">
          <source>The &quot;matchinfo=fts3&quot; option is not available. The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize=0&quot;&lt;/a&gt; option is equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99f30c2d0e908e2cc3022d7fdccaca904765bb1" translate="yes" xml:space="preserve">
          <source>The &quot;merge&quot; command attempts to apply all the changes between circles (1) and (4) to the files in the local checkout. Note that circle (5) has not been created yet. You will need to run the &quot;commit&quot; to create circle (5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e41a414a4991da0955ad788ff392c91737d8599" translate="yes" xml:space="preserve">
          <source>The &quot;merge=X,Y&quot; command (where X and Y are integers) causes SQLite to do a limited amount of work toward merging the various inverted index b-trees of an FTS3/4 table together into one large b-tree. The X value is the target number of &quot;blocks&quot; to be merged, and Y is the minimum number of b-tree segments on a level required before merging will be applied to that level. The value of Y should be between 2 and 16 with a recommended value of 8. The value of X can be any positive integer but values on the order of 100 to 300 are recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3f77712e8ba4f79aa6578b325009e072dd171a" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3a9546b734b773233219e3ac894021d9c4aea3" translate="yes" xml:space="preserve">
          <source>The &quot;mmap_size&quot; is the maximum number of bytes of the database file that SQLite will try to map into the process address space at one time. The mmap_size applies separately to each database file, so the total amount of process address space that could potentially be used is the mmap_size times the number of open database files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05f6ca4b8375a55040cbbe82e13d67e18ad454c" translate="yes" xml:space="preserve">
          <source>The &quot;mptester.c&quot; program is a stress test for multiple processes concurrently reading and writing a single database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aceceab4037b5385ba92b29e0b20a81e94146ade" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3321ce8b4cd40cd33c761004ca598eb073646da" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method changes the representation for NULL returned as result of the &quot;eval&quot; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd7b6ac7a6da46e476f310a277a91923a4e7d04" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method is useful to differ between NULL and empty column values as Tcl lacks a NULL representation. The default representation for NULL values is an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c64f6777879373881c2c98b6dbc2b30411e222a" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3506b602f0b2580a68e5b060067cc065e54d9b3f" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method works like &quot;&lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt;&quot; in that it evaluates the SQL query statement given as its argument. The difference is that &quot;onecolumn&quot; returns a single element which is the first column of the first row of the query result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0182d08456ee166091bc283f720fe1e714fcddc" translate="yes" xml:space="preserve">
          <source>The &quot;onoff&quot; parameter is true to enable the tracking of memory statistics and false to disable statistics tracking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c453be3bed80a3f6062f894d9c91b09f2a405f4" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12d49df2a6244cc1bdf5cf47d59be2df870804d" translate="yes" xml:space="preserve">
          <source>The &quot;optimize&quot; command causes FTS3/4 to merge together all of its inverted index b-trees into one large and complete b-tree. Doing an optimize will make subsequent queries run faster since there are fewer b-trees to search, and it may reduce disk usage by coalescing redundant entries. However, for a large FTS table, running optimize can be as expensive as running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;. The optimize command essentially has to read and write the entire FTS table, resulting in a large transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4ccdc372ee3d695bbd6a513c0e6e7c13353814" translate="yes" xml:space="preserve">
          <source>The &quot;order&quot; option may be set to either &quot;DESC&quot; or &quot;ASC&quot; (in upper or lower case). If it is set to &quot;DESC&quot;, then FTS4 stores its data in such a way as to optimize returning results in descending order by docid. If it is set to &quot;ASC&quot; (the default), then the data structures are optimized for returning results in ascending order by docid. In other words, if many of the queries run against the FTS4 table use &quot;ORDER BY docid DESC&quot;, then it may improve performance to add the &quot;order=desc&quot; option to the CREATE VIRTUAL TABLE statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a820cd844c9df8619832ad41e29de304a643e275" translate="yes" xml:space="preserve">
          <source>The &quot;pBuf&quot; parameter is a pointer to memory space that will be used for the lookaside memory pool. If pBuf is NULL, then SQLite will obtain its own space for the memory pool using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The &quot;sz&quot; and &quot;cnt&quot; parameters are the size of each lookaside slot and the number of slots, respectively. If pBuf is not NULL, then it must point to at least sz*cnt bytes of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f961210acaa75affae517c15c72d34812d54b4" translate="yes" xml:space="preserve">
          <source>The &quot;parent&quot; column is always NULL for json_each(). For json_tree(), the &quot;parent&quot; column is the &quot;id&quot; integer for the parent of the current element, or NULL for the top-level JSON element or the element identified by the root path in the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a41ee583b00942417f0c8c5f788e416b5fcd33" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2306ed00f4707f3494099d14093fb57dc4cef952" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column is the path to the array or object container the holds the current row, or the path to the current row in the case where the iteration starts on a primitive type and thus only provides a single row of output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4d6b26f49abb4a72a1bbdb1337cbe3b3abe73d" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; in the last parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; is used to prevent pointers intended for one extension from being redirected to a different extension. For example, without the use of pointer types, an attacker could still get access to pointer information in a system that included both the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt; using SQL like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adee741afd091308ea52b91bf986798eb9c23f39" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; string which is the last parameter to each of the pointer-passing interfaces should be a distinct, application-specific string literal that appears directly in the API call. The pointer type should not be a parameter passed in from a higher-level function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d3095f178983c8a04814005e7e058687741b3d" translate="yes" xml:space="preserve">
          <source>The &quot;prefix&quot; option, used to add &lt;a href=&quot;fts5#prefix_indexes&quot;&gt;prefix indexes&lt;/a&gt; to an FTS5 table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007337419b82fead3e9a4bb4ea6d17cd18d879d3" translate="yes" xml:space="preserve">
          <source>The &quot;price of California oranges&quot; query was made more efficient through the use of a two-column index. But SQLite can do even better with a three-column index that also includes the &quot;price&quot; column:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57afc82684ba8294d6cce9305c290f392e265962" translate="yes" xml:space="preserve">
          <source>The &quot;profile&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a8d9f9ad6e3aababd749d5fdde2d82848ad996" translate="yes" xml:space="preserve">
          <source>The &quot;progress&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98ea4147c812e538b99bc21f1f6a4e8e90abfe0" translate="yes" xml:space="preserve">
          <source>The &quot;rbu_control&quot; column may also be set to integer value 2 for an INSERT. In this case, the new row silently replaces any existing row that has the same primary key values. This is equivalent to a DELETE followed by an INSERT with the same primary key values. It is not the same as an SQL REPLACE command, as in that case the new row may replace any conflicting rows (i.e. those that conflict due to UNIQUE constraints or indexes), not just those with conflicting primary keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26e076f35ba0ef194f00cabb02d8f0d110dbd9a" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command causes SQLite to discard the entire FTS3/4 table and then rebuild it again from original text. The concept is similar to &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, only that it applies to an FTS3/4 table instead of an ordinary index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfe3ef5f9d0e5aefda4d198135af7dfc82b7ad7" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command should be run whenever the implementation of a custom tokenizer changes, so that all content can be retokenized. The &quot;rebuild&quot; command is also useful when using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; after changes have been made to the original content table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e0f27230c23e1210b0f85831927b9fb4ed65b1" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c21c10984afe5581e89897013fce4a408ba45f" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method copies the content from a separate database file into the current database connection, overwriting any preexisting content. The command syntax is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9587ea916bf4a39318094206a7a32f2bcdfaa5ba" translate="yes" xml:space="preserve">
          <source>The &quot;rollback_hook&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00d488bea46afaaecd75512057a1c66d8fe6370" translate="yes" xml:space="preserve">
          <source>The &quot;score&quot; for a comparison is the edit distance between the pattern and the word, adjusted down by the base-2 logarithm of the word rank. For example, a match with distance 100 but rank 1000 would have a score of 122 (= 100 - log2(1000) + 32) whereas a match with distance 100 with a rank of 1 would have a score of 131 (100 - log2(1) + 32). (NB: The constant 32 is added to each score to keep it from going negative in case the edit distance is zero.) In this way, frequently used words get a slightly lower cost which tends to move them toward the top of the list of alternative spellings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c73b0b5b1beb7568fc6d18b01b575dea3734b9a" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d89d42c3828f01cc4451e3643a15ed26533dc51" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method creates a BLOB which is a complete copy of an underlying database. The syntax is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ecb1d818748f027a6df9d4ecf31fdb4abf6802" translate="yes" xml:space="preserve">
          <source>The &quot;size&quot; of a row value is the number of scalar values the row value contains. The size of a row value is always at least 2. A row value with a single column is just a scalar value. A row value with no columns is a syntax error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5edd5de6e6f1cc913259bc478dccfe21c6a5d5fb" translate="yes" xml:space="preserve">
          <source>The &quot;speedtest1.c&quot; program estimates the performance of SQLite under a typical workload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d1e1fa50bdc62251cad63515806a616cb08e98" translate="yes" xml:space="preserve">
          <source>The &quot;spellfix1&quot; term is the name of the spellfix module and must be entered as shown. The &quot;demo&quot; term is the name of the virtual table you will be creating and can be altered to suit the needs of your application. The virtual table is initially empty. In order for the virtual table to be useful, you will need to populate it with your vocabulary. Suppose you have a list of words in a table named &quot;big_vocabulary&quot;. Then do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f251add4c0609e09930cd5b2e1c244e554f6696" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; code file contains default implementations of a VFS and of the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; functions that are appropriate for Unix, Windows, and OS/2. To prevent one of these default components from being loaded when sqlite3.c is compiled, it is necessary to add the following compile-time option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25afe467d47fff3cdb66b829147595e777d2e30" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; make target will automatically construct the regular &quot;&lt;b&gt;sqlite3.c&lt;/b&gt;&quot; amalgamation source file, its header file &quot;&lt;b&gt;sqlite3.h&lt;/b&gt;&quot;, and the &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot; amalgamation source file that includes the TCL interface. Afterwards, the needed files can be copied into project directories and compiled according to the procedures outlined above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d4d7e86561a6b1d54c81eff00582173909b3a6" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3_analyzer.exe&quot; utility program, available as source code in the SQLite source tree or as a precompiled binary on the &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite Download page&lt;/a&gt;, can be used to measure the average sizes of table rows in an existing SQLite database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff30531d333139aba53fa40d0cdd26055103901a" translate="yes" xml:space="preserve">
          <source>The &quot;start match&quot; text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b039029daf858be6adbac43c34475b31375cdd36" translate="yes" xml:space="preserve">
          <source>The &quot;start of&quot; modifiers (7 through 9) shift the date backwards to the beginning of the current month, year or day.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b5d073f83b249218dde4220e351fdb9c81957d" translate="yes" xml:space="preserve">
          <source>The &quot;state&quot; index works just like the &quot;fruit&quot; index in that it is a new table with an extra column in front of the rowid and sorted by that extra column as the primary key. The only difference is that in Idx2, the first column is &quot;state&quot; instead of &quot;fruit&quot; as it is with Idx1. In our example data set, there is more redundancy in the &quot;state&quot; column and so they are more duplicate entries. The ties are still resolved using the rowid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf055db4baca803941f56b418b3f79cd69d69f75" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb7bc19f02c001a06f5cf0e9a288feeb79d31b6" translate="yes" xml:space="preserve">
          <source>The &quot;swarmvtab&quot; virtual table allows the user to query a large number of tables (hereafter &quot;component&quot; tables) with similar schemas but distinct ranges of rowid values as if they were a single database table. The tables may be (and usually are) located in different databases. Swarmvtab tables are read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab19bcea20e3ab7d9ecf3510719cf0224e13f4a" translate="yes" xml:space="preserve">
          <source>The &quot;sz&quot; parameter is the size in bytes of each lookaside slot. The &quot;cnt&quot; parameter is the total number of lookaside memory slots per database connection. The total amount of lookaside memory allocated to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is sz*cnt bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21cc2584b07fb547745b9d5684016c88291d98ce" translate="yes" xml:space="preserve">
          <source>The &quot;sz=NNN&quot; argument (where NNN represents a sequence of 1 or more digits) means that the average row size over all records of the table or index is NNN bytes per row. The SQLite query planner might use the estimated row size information provided by the &quot;sz=NNN&quot; token to help it choose smaller tables and indexes that require less disk I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5faa11cc0f3cca617edc23b678832f22fc7469" translate="yes" xml:space="preserve">
          <source>The &quot;temp&quot; database (in which TEMP tables and indices are stored) and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; always uses exclusive locking mode. The locking mode of temp and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; cannot be changed. All other databases use the normal locking mode by default and are affected by this pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb92fbf85091b767df43e1863c69aa8515916b3" translate="yes" xml:space="preserve">
          <source>The &quot;test1.dir&quot; directory created above puts all the blobs into a single folder. It was conjectured that some operating systems would perform poorly when a single directory contains 100,000 objects. To test this, the kvtest program can also store the blobs in a hierarchy of folders with no more than 100 files and/or subdirectories per folder. The alternative on-disk representation of the blobs can be created using the --tree command-line option to the &quot;export&quot; command, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8c625e743111097d3b7602f25647d8fd5f0deb" translate="yes" xml:space="preserve">
          <source>The &quot;th3&quot; binary is run and the output checked for errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405706da87374261dc84d98a92672d2aa3e6824d" translate="yes" xml:space="preserve">
          <source>The &quot;threadtest3.c&quot; program is a stress test for multiple threads using SQLite simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ea8ab5c5050c4a238a6302498853dd2f689e62" translate="yes" xml:space="preserve">
          <source>The &quot;three&quot; column -- the key to the bucket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa8abbe4c1763e70302352dd8c5a5a17e072b27" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d44f83daf7e28e3193a3ecca21e30ba205796c2" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method is used to control how long the SQLite library will wait for locks to clear before giving up on a database transaction. The default timeout is 0 millisecond. (In other words, the default behavior is not to wait at all.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac730ff83376aab14adb2a2686e6b4272b35baf" translate="yes" xml:space="preserve">
          <source>The &quot;tokenize&quot; option, used to configure a &lt;a href=&quot;fts5#tokenizers&quot;&gt;custom tokenizer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5924f14d286c018a59c3ed95d3124a43c86bfc19" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67201b01d24a416fed46b29f515a9e7ed51080c3" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified since the current database connection was first opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6156617165c2bee31d2c34a55e3df2f7ee7cbc" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2906df9327952a977291763abf36d4cd7917ee1" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method registers a callback that is invoked as each SQL statement is compiled. The text of the SQL is appended as a single string to the command before it is invoked. This can be used (for example) to keep a log of all SQL operations that an application performs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce50004a13c3fcabcb6ebda341338c2b6ecfb280" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe37d0c891dddf24c1d50f2d3327a7f07cf31d0" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method registers a callback that is invoked as each SQL statement is compiled. The syntax is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e9294106d107e583dc783efd0d04b347f737f9" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839415a25e55cb5e0ba1d1d3bedbc6f8468c1f73" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method is used to execute a TCL script inside an SQLite database transaction. The transaction is committed when the script completes, or it rolls back if the script fails. If the transaction occurs within another transaction (even one that is started manually using BEGIN) it is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378f72a23dc895cffd3910e611b45425aeb46721" translate="yes" xml:space="preserve">
          <source>The &quot;type&quot; column is an SQL text value taken from ('null', 'true', 'false', 'integer', 'real', 'text', 'array', 'object') according to the type of the current JSON element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135f2f5e5d2c30f651d7adf36038240ab6497277" translate="yes" xml:space="preserve">
          <source>The &quot;typical&quot; workload is generated by the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; program in the canonical SQLite source tree. This program strives to exercise the SQLite library in a way that is typical of real-world applications. Of course, every application is different, and so no test program can exactly mirror the behavior of all applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bfc78b4ec7e83cf7c09ae529723bb27ae007c2" translate="yes" xml:space="preserve">
          <source>The &quot;ui&quot; command will cause fossil to run a miniature built-in webserver and to launch your web-browser pointing at that webserver. You can use your web-browser to configure your project in various ways. See the instructions on the fossil website for additional information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78919ab60690742844f0ae8327639ff7f7b254a" translate="yes" xml:space="preserve">
          <source>The &quot;unicode61&quot; tokenizer is available beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11). Unicode61 works very much like &quot;simple&quot; except that it does simple unicode case folding according to rules in Unicode Version 6.1 and it recognizes unicode space and punctuation characters and uses those to separate tokens. The simple tokenizer only does case folding of ASCII characters and only recognizes ASCII space and punctuation characters as token separators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53568b33d00330dcebc8eb48a597c612134f3558" translate="yes" xml:space="preserve">
          <source>The &quot;unixepoch&quot; modifier (11) only works if it immediately follows a timestring in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix Time&lt;/a&gt; - the number of seconds since 1970. If the &quot;unixepoch&quot; modifier does not follow a timestring of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the &quot;unixepoch&quot; modifier from prior DDDDDDDDDD then the behavior is undefined. For SQLite versions before 3.16.0 (2017-01-02), the &quot;unixepoch&quot; modifier only works for dates between 0000-01-01 00:00:00 and 5352-11-01 10:52:47 (unix times of -62167219200 through 106751991167).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a380264abb876efbc0e0abf2e6a2f4c233a20b1" translate="yes" xml:space="preserve">
          <source>The &quot;unlock_notify&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59aa60915a8fc6bc6f97fdfa3c585be19ca1408" translate="yes" xml:space="preserve">
          <source>The &quot;update_hook&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1e96bd97056b4fb89ac4a9d66b380d5f0978cd" translate="yes" xml:space="preserve">
          <source>The &quot;usable size&quot; of a database page is the page size specified by the 2-byte integer at offset 16 in the header less the &quot;reserved&quot; space size recorded in the 1-byte integer at offset 20 in the header. The usable size of a page might be an odd number. However, the usable size is not allowed to be less than 480. In other words, if the page size is 512, then the reserved space size cannot exceed 32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0117a41a4edb11977b96c0bfbaf5ae135dd4dc28" translate="yes" xml:space="preserve">
          <source>The &quot;user version&quot; as read and set by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1221e2090e85cfaa0707db328c83c8e04e4462" translate="yes" xml:space="preserve">
          <source>The &quot;verb&quot; argument determines what statistic is accessed. There are &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;various verbs&lt;/a&gt; defined. The list is expected to grow as the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface matures. The current value the selected parameter is written into integer &quot;current&quot; and the highest historical value is written into integer &quot;highwater&quot;. If resetflag is true, then the high-water mark is reset down to the current value after the call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa357090791a4202ebbb1affe438340a7edf58ef" translate="yes" xml:space="preserve">
          <source>The &quot;version&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd6ed1a853164caf36a9ec472723c210aaf3324f" translate="yes" xml:space="preserve">
          <source>The &quot;wal_hook&quot; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13953b9d13af87a94ab5c5d6a6cf14aaf24d8b07" translate="yes" xml:space="preserve">
          <source>The &quot;weekday&quot; modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the &quot;weekday&quot; modifier leaves the date unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5b825d3bb551c0ffab90d4aebeaa4b072d1ccb" translate="yes" xml:space="preserve">
          <source>The $nExtCode extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c45544c374d408b5b737fa2b109d54d1a57530" translate="yes" xml:space="preserve">
          <source>The $nPrimCode result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab512eff5b3fb377f299e58700487486d503855" translate="yes" xml:space="preserve">
          <source>The $prefix parameter may be NULL, in which case the prefix is deduced from $wholeline. Or, the $wholeline parameter may be NULL or omitted if context information is unavailable or if context-aware completion is not desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bbc5a1a7e84666a4d4dd0cec4c28449ae27a6f" translate="yes" xml:space="preserve">
          <source>The %_content table contains the unadulterated data inserted by the user into the FTS virtual table by the user. If the user does not explicitly supply a &quot;docid&quot; value when inserting records, one is selected automatically by the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff27a5cb67628299a86678a48c0336fb247a12c" translate="yes" xml:space="preserve">
          <source>The %_stat and %_docsize tables are only created if the FTS table uses the FTS4 module, not FTS3. Furthermore, the %_docsize table is omitted if the FTS4 table is created with the &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; directive specified as part of the CREATE VIRTUAL TABLE statement. If they are created, the schema of the two tables is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c824e78a5796a4ada97aea7265fbe991ac4b8766" translate="yes" xml:space="preserve">
          <source>The %q and %Q substitutions are SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a9fc3133aa73e0b29b95de437699b671e4c4f6" translate="yes" xml:space="preserve">
          <source>The %s substitution is universal, but the %z substitution is an SQLite enhancement, not found in other printf() implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b87f6c99821c5908fd04958d29e2e7c01fcfa39" translate="yes" xml:space="preserve">
          <source>The %w substitution is an SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ed0c85ed4fa11e23eab78d700cba29a96e54ed" translate="yes" xml:space="preserve">
          <source>The '%' character is used in requirement H35300 to represent the modulo operator, just as it is in programming languages such as C, Java and Javascript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9354cba92715c3a8151b0bdbb532432be7bdd61" translate="yes" xml:space="preserve">
          <source>The 'crisismerge' option is similar to 'automerge', in that it determines how and how often the component b-trees that make up the full-text index are merged together. Once there exist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139c169421eec1791495afdd3b65ecbf6f7f8622" translate="yes" xml:space="preserve">
          <source>The *+* operator on the *x* column will prevent that term from constraining an index. This would force the use of the ex2i2 index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe65d357eb360ea29fe1d68436790805aab233d0" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ea66787615c66d86376977b69791f61618b2a2" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0209d4ffca3af22d05eab8c450129e95986f2c" translate="yes" xml:space="preserve">
          <source>The --blob-api option on the database read test causes kvtest to use the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; feature of SQLite to load the content of the blobs, rather than running pure SQL statements. This helps SQLite to run a little faster on read tests. You can omit that option to compare the performance of SQLite running SQL statements. In that case, the SQLite still out-performs direct reads, though by not as much as when using &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;. The --blob-api option is ignored for tests that read from individual disk files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeee09a9fb263d7d0932e1687159faa31b022fff" translate="yes" xml:space="preserve">
          <source>The --deserialize option associated with opening a new database cause the database file to be read into memory and accessed using the &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; API. This simplifies running tests on a database without modifying the file on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d3b8386b1e3ccb1cc08c05d6ada4438f0769ba" translate="yes" xml:space="preserve">
          <source>The --primarykey flag changes the pairing algorithm slightly so that the schema-declared &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; is always used for pairing, even on tables that have a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. This is often a better choice for finding differences, however it can lead to missed differences in the case of rows that have one or more PRIMARY KEY columns set to NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd46599c902c6e8fdb69c21ede0585852a486b3" translate="yes" xml:space="preserve">
          <source>The --update and --insert commands work like --create command, except that they do not delete the current archive before commencing. New versions of files silently replace existing files with the same names, but otherwise the initial contents of the archive (if any) remain intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d15467647a321ed86c3b0d4ddfb73a9334e61d" translate="yes" xml:space="preserve">
          <source>The -ldl library is needed to support dynamic loading, the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface and the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt;. If these features are not required, then they can be omitted using &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; compile-time option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff976c7e2e67ea0658ecbf1774cc0a53bba77580" translate="yes" xml:space="preserve">
          <source>The .selftest command reads the rows of the selftest table in selftest.tno order. For each 'memo' row, it writes the text in 'cmd' to the output. For each 'run' row, it runs the 'cmd' text as SQL and compares the result to the value in 'ans', and shows an error message if the results differ.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12dcfb8a7c514a22ec8efe2151085ef4fd8b43ec" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header (found on page 1 only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17caaa0027df54644d9d8d5e0706c4b71db11b0" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header is found only on page 1, which is always a table b-tree page. All other b-tree pages in the database file omit this 100-byte header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6884cf3226327e79dce3b07ec790a620af6f29" translate="yes" xml:space="preserve">
          <source>The 12-step &lt;a href=&quot;lang_altertable#otheralter&quot;&gt;generalized ALTER TABLE procedure&lt;/a&gt; above will work even if the schema change causes the information stored in the table to change. So the full 12-step procedure above is appropriate for dropping a column, changing the order of columns, adding or removing a UNIQUE constraint or PRIMARY KEY, adding CHECK or FOREIGN KEY or NOT NULL constraints, or changing the datatype for a column, for example. However, a simpler and faster procedure can optionally be used for some changes that do no affect the on-disk content in any way. The following simpler procedure is appropriate for removing CHECK or FOREIGN KEY or NOT NULL constraints, or adding, removing, or changing default values on a column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3229fe36f5dbdb9bc16916270b8799663f2b4b3a" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8004ad0fbc670903554e47567c2e9bf84a736bf" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de71717ad00d5c6da7753059b7611f9841b1d459" translate="yes" xml:space="preserve">
          <source>The 32-bit integer value P1 is written into register P2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa6dc01b797fc02e2f48692d3a39f9204d77ab0" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 128 in the WAL-index header is called the &quot;nBackfill&quot;. this field holds the number of frames in the WAL file which have been copied back into the main database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3de01c332227a39275dbc5888bb606fa2949671" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 16 (and repeated at offset 64) is the number of valid frames in the WAL. Because WAL frame are numbered starting with 1, mxFrame is also the index of the last valid commit frame in the WAL. A commit frame is a frame that has a non-zero &quot;size of database&quot; value in bytes 4 through 7 of the frame header, and that indicates the end of a transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0f85b04e7fa9cc6d6fac1b8bbc475f7f896833" translate="yes" xml:space="preserve">
          <source>The 35% figure is based on running tests on every machine that the author has easily at hand. Some reviewers of this article report that SQLite has higher latency than direct I/O on their systems. We do not yet understand the difference. We also see indications that SQLite does not perform as well as direct I/O when experiments are run using a cold filesystem cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99484295a38d44d61a5164088be45dfe447bd6fb" translate="yes" xml:space="preserve">
          <source>The 3rd parameter of the built-in SUBSTR() function is now optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03a25a4d8213505aa58b43a2a9ec61a89d8bd66" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 28 into the header stores the size of the database file in pages. If this in-header datasize size is not valid (see the next paragraph), then the database size is computed by looking at the actual size of the database file. Older versions of SQLite ignored the in-header database size and used the actual file size exclusively. Newer versions of SQLite use the in-header database size if it is available but fall back to the actual file size if the in-header database size is not valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2a0b06932c2dcd259f9b038635b5911a22f5bb" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 56 determines the encoding used for all text strings stored in the database. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be. No other values are allowed. The sqlite3.h header file defines C-preprocessor macros SQLITE_UTF8 as 1, SQLITE_UTF16LE as 2, and SQLITE_UTF16BE as 3, to use in place of the numeric codes for the text encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59780a9139eaaa69dc8ff8373215df2d27399d4a" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 60 is the user version which is set and queried by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;. The user version is not used by SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59b6e739385a58f0bfd59ff19b74ae1c97b3ca9" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 68 is an &quot;Application ID&quot; that can be set by the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command in order to identify the database as belonging to or associated with a particular application. The application ID is intended for database files used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. The application ID can be used by utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; to determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f0a53720eada7bca96ab5b1af017ecee35257f" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 96 stores the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; value for the SQLite library that most recently modified the database file. The 4-byte big-endian integer at offset 92 is the value of the &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; when the version number was stored. The integer at offset 92 indicates which transaction the version number is valid for and is sometimes called the &quot;version-valid-for number&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d1137ce6ac9536674089958f7183c5cef074dd" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian signed integer at offset 48 is the suggested cache size in pages for the database file. The value is a suggestion only and SQLite is under no obligation to honor it. The absolute value of the integer is used as the suggested size. The suggested cache size can be set using the &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;default_cache_size pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7632ae3463f74e8bc40ebd99c8e14ebcad0e1acf" translate="yes" xml:space="preserve">
          <source>The 8 or 12 byte b-tree page header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b2d0b06ac8eecacdf1f9fc8ceb4463be132806" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113a719d1e8937c17801bea84f7fbfbe80a9d62b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81aa4d01093839a3328717a25027872953f919a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c75916c07cfb8eae73aa66b68a34bf29c22777" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf64bb75c15b60e54d733e7fb04737bfbdcc130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b899c2433d199dbb7815bdf0ba2afb729910cf1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243b1f5a94daea2d7cb3ce8a6e46d2fc0337bddb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9c76fa5b1b1ce93415a995c6d4d84ffeb6d357" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d45a04d8212fde9c0874120a3960331ca779f2b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1190e60391b896900656c0ed0c45b80a24b61942" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68df0918aa353458edcd2a2adfa1d6ea97cffd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e18bfb46029f881a46fabedb7acfaf5c4cc5dda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d3a9c5e86973d6925c26336eb4b86036d70cb6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc30f41b86e312b265eb4e71d4d9a6acf99b0d1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895178f8a3d57626d41012b259bf092ebaa065ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f98e455bc2921056f5d6b0ffb541ab9df1ffaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08d4a7c0ce7457f9dab2dfa8af96af8deafb79d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ad44c525d8f71caf7bed2b7e946c3d8c4e4d51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c708fa87b4305f6c6c7b152f77487e32500d735" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62645acd92fc3d494d833d1a2acf99fc550b25a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b2a32ae166fcb0b54e0a6a66b0c37e428124e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aaeaf525c4a02afa566b3b6fde01711f410b96" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec7f66ae2478b5bf1fba7004c6f9eca0c47bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de889cb07b2c7dd83d04327e082d9b8afd75421b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20fbf1dd1eb586565d476c6ea4477e75271549a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775754ed627fe2a2cc8e3c07dc04d7c2771ef634" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14be7fcf3129f0807a23ee14219023eee52d1a02" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c246e9ef7aa9d8e18a838b47761936cd8a2acc5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2146a577e5e49a77b490e29aca2d82e371ec702c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd7fc3c3c9a64e738f23c02f6e6fbe25f03ae8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e3c98131317b43afc18d358e2869af93b46671" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d565fd5c1ee3cccc1b5c10ce8ef575521cca40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6917c29880e6eab55b32466b3048653ea9692486" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8658941f24fcaee032cb73b6958282aac488a0c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf4ff61e78e32620c83211a0d5e1e3795abc7df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc22c6c47d48b515ed10c7b3b7ca6cc54142437" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f1ec747ece71d77c655f9a07fae8cab37f0a797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abad991ae0af361a9313d8cfba4c5223a9d4a389" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed76b8571c1160c10dee5527b0d46210f6deae9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8bb7e6f2617ebce878cf41863558873c56dd1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283dcdc6097ac99a155d31e274b76b664e287d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a765f2716bbd0a7165479eb04c6ad3833cfd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95615e5c78fed3ee43eff0e7b082843f593e6a31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d8a3ef92ef4d7b314975584d8072e9206e198e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485ac31bffb8ac065daf3ba2a8161fbdf5039efd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67cdd83f23b0c9baf88d22cb2f2c082de3577118" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc4153435020e41ac99ab2b5b83d08f27b98c68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9142f5b65b53643523fc33889c4ba6acff8188e5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0804c63302651c02a306eb7ec9ff35797d83276d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16ec9bd7cc655e1fcca3234a2d80781961dcf25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196a41f980c38337225c4ba413e0b1dc0b2b471a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7c39458516ed31456486d668f266799517f0b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6067fb898268faa568cf0d8b727509a1e63a822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45a2fa29af05eafc8a58031e6a08762e72b9ebb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32fc3ec6f9212eb93de60bbea8de22f4f5c0720b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961fafabf95f8005cd6aacb0ba427c7a66f5ca95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3359a645510d53c409e1e871158229645d3789b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413d8e1b0a9fd900669cb69e73b3dca110ff8c2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a69e4da16c0af72de938b51b675221a8706b54" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d526543f15c2ce77f0461ecf7fe44c9004bea17a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebd2a70a799339bb0872257764cf8c08eda9ecd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdccf2fe8da7ee0d8c5941a2ea211306829a9588" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f192c2e63c8633453fa1eae93e0c07df64cf07f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf9a50cfd48cde386829709800477dc50bcc565" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3dd434f5b5d6086654ad44e0af5b3fa3e940b9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97cd9ce5f443d3219025ca93221b345486932d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6ee4f80c9cf2b24ebb8343bd1162955c7d2500" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105a39338a53cf76076319343b91a58b713c591f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a39c75085aed62eed16a6bd93eb299fac8af13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0de6e2585567c94a4d2150e4d89a4457d85ed27" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb5c486ab423108118235eb419e942dcdffc3fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2324c4dab632501938725b9d6af72b57f5294994" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="257792bb90d40cbd5be070de917b57c36a5f9cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774ea185734630483687c4bdf35dc5a0169545c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d8e8025bf5df9df0de6e9fce45f3dc3f3a1832f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a84f41bb71a501decc458aa53d2eb6f639dc064" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d12472a003010a0b08bc4775382d299187ba70" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;../compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fbc9bba97b7220d8d7ecc905032c6bd233e87c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9eb53bad0c35cc3dcade82b9f30796bebe98ba9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4683a2e9a942c25fe816aae1882f9a79405f5686" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d082fe94995359849591e8be7fa905999e11458e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2688b20853de688f9667ff56467cd11f77df2163" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d14328a2609f4c2f2e647906b7ed9c9b0a6470e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c456ed19efa854514b7975cbb780401189b8da5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52eaec5cfbc452ed9aad230504ada3c60f5e208b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabaf2d0ed146df6465d7c01128019f3ef60888d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;atomiccommit&quot;&gt;atomic update capabilities&lt;/a&gt; of SQLite allow small incremental changes to be safely written into the document. This reduces total disk I/O and improves File/Save performance, enhancing the user experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08525d9bc082ee31e91cdcebab98cc6662084121" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature in SQLite works differently than it does in MySQL. This often causes confusion for people who initially learned SQL on MySQL and then start using SQLite, and expect the two systems to work identically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc38744c25dba895f9fced962c1bfedae8b7cde9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218098ad11bde6e156b4a9f8e57ca75e25354cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f66c39b1fdccfb02fbdb0dd7e08e6474fe1802" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface, which has been deprecated and undocumented for 8 years, is changed into a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cbc1814be35648af44f26835e6f82841778c411" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm&lt;/a&gt; routine is used to register a callback on memory allocation events. This routine registers or clears a callback that fires when the amount of memory allocated exceeds iThreshold. Only a single callback can be registered at a time. Each call to &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; overwrites the previous callback. The callback is disabled by setting xCallback to a NULL pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7e34038a904f7366dde6ee090a8282d84ade6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup()&lt;/a&gt; interface has become a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac435cb36a069024ddc4f4287c8ff0d76c80af5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;Online Backup API&lt;/a&gt; was created to address these concerns. The online backup API allows the contents of one database to be copied into another database, overwriting the original contents of the target database. The copy operation may be done incrementally, in which case the source database does not need to be locked for the duration of the copy, only for the brief periods of time when it is actually being read from. This allows other database users to continue uninterrupted while a backup of an online database is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563d98f5bc61682f67da5d25a1062884fd2fdf5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; interface does &lt;u&gt;not&lt;/u&gt; work for a union-vtab. BLOB content must be read from the union-vtab using ordinary SQL statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d5c3998902d7d51338a9f7531152bceea38f9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked once with a column name that is an empty string for every table referenced in a query from which no columns are extracted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68ee8ce42ad40a73650dbfe088fcf3e1c842ed0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; run-time option and the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option enable the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt;. See also ticket &lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2430856bd9775a861cef9dfde7c36d65a2cc4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bit means that all writes to this device are atomic in the sense that either the entire write occurs or none of it occurs. The other &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt; values indicate that writes of aligned blocks of the indicated size are atomic. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt; means that when extending a file with new data, the new data is written first and then the file size is updated. So if a power failure occurs, there is no chance that the file might have been extended with randomness. The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt; bit means that all writes occur in the order that they are issued and are not reordered by the underlying file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a653d67bd1da50ffe32f058a08a81d4f6edcd9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. This will always be set for TEMP databases and journals and for subjournals. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag means the file should be opened for exclusive access. This flag is set for all files except for the main database file. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen is allocated by the caller. xOpen just fills it in. The caller allocates a minimum of szOsFile bytes for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229110ee7251c5cf9b125b0ef0813a6c6ba215fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; and &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flags to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can also be used to adjust the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; of individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; at run-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966cc2ea77fca46efeb8c4289b4a653605ed43e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; option was added to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc999536061a5d7a156494c35b1ed191a9effbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type()&lt;/a&gt; function returns the datatype for the value in the Nth column. The return value is one of these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffa274dabb801c01eb4f4986ad5f8726b7dca26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; function returns the number of columns in the results set. sqlite3_column_count() can be called at any time after &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; works similarly to &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; except that it only works following &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. If the previous call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returned SQLITE_DONE or an error code, then &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; will return 0 whereas &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; will continue to return the number of columns in the result set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df909dfd5bdc309e3368846cb0f8c21a5731a3d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface is used to make global, process-wide configuration changes for SQLite. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface must be called before any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; are created. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows the programmer to do things like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb7ccb56d39b4e4c7e512ab71314c715b6ea1d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) interfaces was invoked at start-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c837fffcba80492d406ed18ba293449ca9513c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface is used to create new &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; for sorting text. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface is used to register new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface creates new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c521e07609cbfdb8d566dab7163fc87d422895" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces now return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; when passed invalid parameter combinations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf6561662b932f66438111d53034fa55d79a49d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface can be used to override the like() function and thereby change the operation of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. When overriding the like() function, it may be important to override both the two and three argument versions of the like() function. Otherwise, different code may be called to implement the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator depending on whether or not an ESCAPE clause was specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b630ee12d42fc4528bfc71d36f585a36895111" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface creates new SQL functions - either scalar or aggregate. The new function implementation typically makes use of the following additional interfaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99635893a7742a2b0a9430ca501d241e5f7023c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces return SQLITE_MISUSE on any attempt to overload or replace a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; module. The destructor is always called in this case, in accordance with historical and current documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7c498dc9b696b8a3e4e1f8ce0b76687320b809" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; routines associates a module name with an &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure and a separate client data that is specific to each module. The only difference between the two create_module methods is that the _v2 method includes an extra parameter that specifies a destructor for client data pointer. The module structure is what defines the behavior of a virtual table. The module structure looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2068b9a7520d6dd4dead5bbb83fc7b95e63987" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;,...) C-language interface can be used during a transaction to determine if there are deferred and unresolved foreign key constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d823f649e66e357a40f8457ae11a89f890b8312" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8c7487a7241b1b53f75118a25cdfbd803a1bd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; function works much as it did in SQLite version 2. Zero or more SQL statements specified in the second parameter are compiled and executed. Query results are returned to a callback routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060e03cab55fa6e258498e740c2441a904ee6a9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; interface is a convenience wrapper that carries out all four of the above steps with a single function call. A callback function passed into &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is used to process each row of the result set. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; is another convenience wrapper that does all four of the above steps. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface differs from &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; in that it stores the results of queries in heap memory rather than invoking a callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55eb24f412d567a8152cd959c8adf08902c2ff0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface works on any prepared statement created using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;. It is no longer necessary to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE&lt;/a&gt; in order to use &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b367904a5b319d97004324430003a01cf6b1ae72" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file. The xOpen method of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; constructs an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object when the file is opened. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; keeps track of the state of the file while it is opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30882c8710d7d3a10831e6a935d755bd7e25652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is used to pass information into and out of the xBestIndex method of the module that implements a virtual table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c68c89f6fed7e1292abcc19abd161e51c2b5b49a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface can be called to explicitly initialize the SQLite subsystem. The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically when invoking certain interfaces so the use of &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; is not required, but it is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086866a1ce9981846c47e35c1af526651c7809af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface causes SQLite to release any system resources (memory allocations, mutexes, open file handles) that might have been allocated by &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18eeb48351b373543379c24e8aba67998ec2d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface frees all mutexes under windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14f29a4830a0488c9f404caad392cc8f7efd81d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; routine can be called for a different thread</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78920df495dd4dfe901c1e207965f56317d12fca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object holds the methods used to interact with an open file. Each &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains a pointer to an &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that is appropriate for the file it represents. The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object contains methods to do things such as read and write from the file, to truncate the file, to flush any changes to persistent storage, to find the size of the file, to lock and unlock the file, and to close file and destroy the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899386dff25e21c6b737c3d54a2f1045b6441f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object is a structure that contains pointers to methods for reading, writing, and otherwise dealing with files. This object is defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1277e9425f23dd50c872910508a38720a4c40a0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; function tries to detect if the source code has been modified from what is checked into version control and if there are modifications, the last four characters of the version hash are shown as &quot;alt1&quot; or &quot;alt2&quot;. The objective is to detect accidental and/or careless edits. A forger can subvert this feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51a6d9f987aab5062f7ef525db57b1e02273eb7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface loads an &lt;a href=&quot;loadext&quot;&gt;extension&lt;/a&gt; into a single database connection. The default behavior is for that extension to be automatically unloaded when the database connection closes. However, if the extension entry point returns SQLITE_OK_LOAD_PERMANENTLY instead of SQLITE_OK, then the extension remains loaded into the process address space after the database connection closes. In other words, the xDlClose methods of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is not called for the extension when the database connection closes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e180768903c106d7d176b62ab434360e88ec87ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces are deprecated. The equivalent functionality is now available through &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ea088bdd6bab93bd39ac4df39be5b9d52d9d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces, the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;) interface, and the &lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt; compile-time option are all non-functional when memory usage tracking is disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1193a5998521b29a68d3af0690b60d457381cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure defines a module object used to implement a virtual table. Think of a module as a class from which one can construct multiple virtual tables having similar properties. For example, one might have a module that provides read-only access to comma-separated-value (CSV) files on disk. That one module can then be used to create several virtual tables where each virtual table refers to a different CSV file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e5c834aec9a24795809e8d9018891e41492180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_enter()&lt;/a&gt; attempts to enter the mutex and blocks if another threads is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try()&lt;/a&gt; attempts to enter and returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another thread is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; exits a mutex. The mutex is held until the number of exits matches the number of entrances. If &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; is called on a mutex that the thread is not currently holding, then the behavior is undefined. If any routine is called for a deallocated mutex, then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f27ad8fcfe5b9da304436aec019b4cf39a32876" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free()&lt;/a&gt; routine should be used to deallocate a non-static mutex. If a static mutex is passed to this routine then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee285158d4476d2f4cfb28e9d58a1b17557c72d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; interface allows an application to discover all &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab075f99c29f68391431d9855c2d09e8ff55b4eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces act as a compiler for converting SQL text into bytecode. The &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object is a container for a single bytecode program using to implement a single SQL statement. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface passes a bytecode program into the virtual machine, and runs the program until it either completes, or forms a row of result to be returned, or hits a fatal error, or is &lt;a href=&quot;c3ref/interrupt&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f760f8c540dcc654012aa0be1cef03e69842a01e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interface creates a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that will automatically recompile itself if the schema changes. The easiest way to deal with &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors is to always use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb166cb387770ce5ad92997ed9078bd0c5b5827" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback is invoked (by &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;) for statements that did not run to completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86c0301bb7f9f1fb47baffd646cd224ccc8e2ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface will now attempt to reduce the memory usages across all database connections in all threads, not just connections in the thread where the interface is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049881541bf38acf3045d3cb673c48aa92e47dd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;, &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt;, and &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interfaces now work cross all threads in the process, not just the single thread in which they are invoked. *** Potentially incompatible change ***</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af837a86c1e38824ef1d301d32834ef9f9b670f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked regardless of the presence of EXPLAIN or EXPLAIN QUERY PLAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af9451c90d2dee9cf3e529bb13a675b0008b0a17" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527b7feeedc271730252349576ab47baa1d727e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface works by registering a memory alarm at the soft heap limit and invoking &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; in the alarm callback. Application programs should not attempt to use the &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface because doing so will interfere with the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; module. This interface is exposed only so that applications can provide their own alternative implementation when the SQLite core is compiled with &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ed21e10553df3077d02ccee7e2ab02fc21afc9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb6a622a1771cf9ae256233e2fb0c463ea616f9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects are controlled by a small set of C/C++ interface routine listed below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5466713b299a5e73e4a0863d52f92664bc3844c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object: sqlite3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3b251682ed613e33db0de124845adce3edbb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is running the VACUUM INTO statement was originally opened using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e9d37ccb6719391098f5d43ea1dcd316705462" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object: sqlite3_stmt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcb829701917628eb2fd7b1899f66a93be104f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C/C++ interface together with the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; and &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; verbs can be used to detect at run-time when an SQL statement is not making effective use of indices. Many applications may prefer to use the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface to detect index misuse rather than the INDEXED BY phrase described here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e46371f36d9155345020a6a81ffaba033339b8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/table_column_metadata&quot;&gt;sqlite3_table_column_metadata()&lt;/a&gt; is enhanced to work correctly on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables and to check for the existence of a a table if the column name parameter is NULL. The interface is now also included in the build by default, without requiring the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc8c97e4cc1a5aa05b289505090d5b34bad9902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_OPTIMIZATIONS&lt;/a&gt;, ...) interface allows selected SQL statement optimizations to be disabled at run-time. SQLite should always generate exactly the same answer with optimizations enabled and with optimizations disabled; the answer simply arrives quicker with the optimizations turned on. So in a production environment, one always leaves the optimizations turned on (the default setting).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43fd3a5c9f7460ba2ff5df434fcffaa34616785e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; output for nested SQL statements should always begin with a &quot;--&quot; comment marker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19462b9c93da59d00cf4ac09d7e75c3130b9c27d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; API, which is only available if the library is compiled with the pre-processor symbol &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; defined, is &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;documented here&lt;/a&gt;. This article is not a substitute for reading the full API documentation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8d6caa4b5453ea5545263fa9616b15bb0d4f1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface is designed for use in systems that have a separate thread assigned to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. There is nothing in the implementation that prevents a single thread from running multiple database connections. However, the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface only works on a single connection at a time, so the lock resolution logic presented here will only work for a single database connection per thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d6fc659db0d56afaed258d4fdfa842c7a2494e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/update_hook&quot;&gt;update hook&lt;/a&gt; is not invoked for rows that are deleted by the REPLACE conflict resolution strategy. Nor does REPLACE increment the &lt;a href=&quot;c3ref/changes&quot;&gt;change counter&lt;/a&gt;. The exceptional behaviors defined in this paragraph might change in a future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50634212838ce725193912da3e909e9a53b3f585" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; API is used to locate a particular VFS by name. Its prototype is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd79207584e9ef224be15cf9411b2100d6ae0c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; API is used to remove an existing VFS from the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7466f7f648f5cd0c7b32027691a4626bfd37a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure represents a pointer to a specific row of a virtual table. This is what an sqlite3_vtab_cursor looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405e780a5eda0077cf02e3ce6060be9576266571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09f9898013c2f2b9084c257d373e6d8fb8e1f1d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563228c7f58e18a697dff44f98d2797b60b51628" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b45f1d52cb17aec209a2fdf03a83375e0b951e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe01cd54971699e5fe35af1a0adc94faad95fbe1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0a05c22977d8b1dc9945aac16fc4626f1dd660" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddddd8caea4f2699898b48925bf95b8d69764816" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc589731780274c54e5cd365284382cd5887eded" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;../lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d8ff8dd3d322caf95cdc56c272ff4998cee7a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835bd4a6a4daee4b5c892d531fad550f3b7944bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9534ed4df1d95266c96610467198479542d6649c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;../pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85959ccb42981e5ee3527aa791391f6482ac784e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2750128ef1083c346294ef6e3be361e6eba77af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;../wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3329771b09c8d9c17e5ba63393baaa851477f87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ebc915c79af1c389d3c702e8a0e217f15cd6b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a6279d094b2efb4418d75c6d39f8cf80f5db9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37dec85b72b827823523f2dbeaab4ae1365e897b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53dec04041f2a1cd0f5d61ecfdd7363482736f2d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb8033743ca0212b9de7ee6d6d452df418e67e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5b82162695e993bb266a9bcb74822b0cb0729d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;../vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;../compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc747f657ceac57a6b93ab7190def0e8a928303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a271c98ba50f856db7d26935d70d5164c6f00e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5113389d53b260a388ff9b96ca66847bbd222b0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1b780daaf82dc713d986bde97a154815b1318d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="937fe17d531247dde2a8c434e7c019ad55d302c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e591e785c2547026326ba62eddb1a8e3a00235" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3e0696fb81e2cd89dc43dbc9ef7b0440a8b5e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15edb51b39cd83bfa83c4b8e2f7138c93f46e748" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3c6baa196558e15836748dd318cdd30a688ef6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2061592c87f5f999944ce29cf7569df9e8b3f69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc6747416294fa8545c14bddccb7cfdc4ee3b78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6d6c3ad7f7d02755c43722a7a4b2dabb76ea67" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carray&quot;&gt;carray table-valued function&lt;/a&gt; needs to accept a pointer to an array of C-language values from the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c282faf1973e4f89130abe26a61f3f513af735e2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; compile-time option can be used to change the default page size assigned to new databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f025c2cb604da7be21c2713e7ae110d6fc22479" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; is increased from 1024 to 4096. The &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; is changed from 2000 to -2000 so the same amount of cache memory is used by default. See the application note on the &lt;a href=&quot;pgszchng2016&quot;&gt;version 3.12.0 page size change&lt;/a&gt; for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623f46dd8d1f8aedc876d36b9e6b7c6843fb38ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;-DSQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; compile-time option causes SQLite to bypass its page cache when reading content from overflow pages. This helps database reads of 10K blobs run a little faster, but not all that much faster. SQLite still holds a speed advantage over direct filesystem reads without the SQLITE_DIRECT_OVERFLOW_READ compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d73bde2dc7785ffa127c202c3991e5af269a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is now turned on by default in the standard builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9ba2ea4ea2e87921df34017de3d69d7b4137bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; compile-time option causes the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect a small histogram of each index, to help SQLite better select among competing range query indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0180c578d01206ca2260b932e5fe2d4e6cc6568" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options only work when building from canonical source files. They do &lt;u&gt;not&lt;/u&gt; work when you build from the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the pre-processed source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f951ab56418025da71fd3229ec924e7681f98557" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option sets an initial baseline value for the maximum number of index-and-constraint combinations that the query planner consider. The baseline query planner limit is increased by SQLITE_QUERY_PLANNER_LIMIT_INCR prior to processing each table of a join so that each table is guaranteed to be able to propose at least some index-and-constraint combinations to the optimizer even if prior tables of the join have exhausted the baseline limit. The default value for both this compile-time option and the &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option are set high enough so that they should never be reached for real-world queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd49b137fd67eca14bbcc5b6c746f08a2997711" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option fixed to make sure that content is deleted even when the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; applies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656d7af3931cb41fc80d6fdefc85a4cfb80b7c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is a #define whose value is an integer between 0 and 3, inclusive. The meaning of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c11588171d30d65004665748aee39867b770ec3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355c715bbc78271373ada3410d668232a6d1cc69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f82d70cfe7739c80fc41874304dfb1e1ffafd3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28bbb907be12b8d8d6cb3f58bde73db3db4a2a3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output no longer shows an estimate of the number of rows generated by each loop in a join.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0403e12475b1041021c7db25c8bbeab40ee20902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c477329521e0c202c4f6312a9b20720b0061408f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2&quot;&gt;underlying file format&lt;/a&gt; for SQLite databases does not change in incompatible ways. There are literally hundreds of billions, perhaps trillions, of SQLite database files in circulation and the SQLite developers are committing to supporting those files for decades into the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019a9b5a0c4bab7b2872e5382ef484fc4c667e1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47ad55bfdbffd81a341414cce2caff94549fb57d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL file format&lt;/a&gt; is precisely defined and is cross-platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e921edb70343a6bdb367da8f2286bed023bed5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent key&lt;/a&gt; of a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; is not allowed to use the rowid. The parent key must used named columns only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94136fe2e1cb36bfe5b8895ca9db2e90ee44f1f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; MATCH operator passes pointers into &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43eb5ae7856e6e2985afc5b90e134ad6efe6a669" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#*fts4rebuidcmd&quot;&gt;FTS4 &quot;rebuild&quot; command&lt;/a&gt; deletes the entire full-text index and rebuilds it based on the current set of documents in the content table. Assuming again that &quot;t3&quot; is the name of the external content FTS4 table, the rebuild command looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98c7bde5e55ca0fc0875001b5230f001bb8d1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function always returns NULL unless either the legacy application-defined FTS3 tokenizers interface are enabled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting, or unless the first argument to fts3_tokenizer() is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1574210b17663fb17af96bfd5572d4febc918bf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; operator is supported for queries based on the built-in full-text index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afda903a3f03dcbd2f01644e1f0a3ea9a0e62818" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#matchinfo-x&quot;&gt;matchinfo 'x' flag&lt;/a&gt; would report a single hit for the phrases &quot;a&quot; and &quot;c&quot;. However, the 'y' directive reports the number of hits for &quot;c&quot; as zero, as it is part of a sub-expression that does not match the document - (b AND c). For queries that do not contain AND operators descended from OR operators, the result values returned by 'y' are always the same as those returned by 'x'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3b429b14a3a0c21190f0bbe4a4fec620e8c35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;, &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; are available to support full-text queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986cc21a6b9f4c0f213b24757430a9834e1ed2e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;snippet&lt;/a&gt; function cannot be used with the above query. Because the outer query does not include a &quot;WHERE ... MATCH&quot; clause, the snippet function may not be used with it. One solution is to duplicate the WHERE clause used by the sub-query in the outer query. The overhead associated with this is usually negligible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bce43282ea827774137f471cf2a2f9eafebbd71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer is now included in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b9e4179a7690f373db2c622ddd029271ea2c29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25() auxiliary function&lt;/a&gt; returns a real value reflecting the accuracy of the current match. Better matches are assigned numerically lower values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d537287fe3b1d151168bae58fabce38b16555d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt;, used to configure whether or not the size in tokens of each value in the FTS5 table is stored separately within the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4542957e1a08fcc6a2bdcd49b04a58f559cf1ff8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_detail_option&quot;&gt;&quot;detail&quot; option&lt;/a&gt;. This option may be used to reduce the size of the FTS index on disk by omitting some information from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41a2e84baae07818885bfa4f91b936da5a1f958" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_highlight_function&quot;&gt;highlight() auxiliary function&lt;/a&gt; returns a copy of the text from one of the columns of the current match with each instance of a queried term within the result surrounded by specified markup (for example &quot;&amp;lt;b&amp;gt;&quot; and &quot;&amp;lt;/b&amp;gt;&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b98a3fb75c4347301e0a46ec5f5ca45961387193" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet() auxiliary function&lt;/a&gt; selects a short fragment of text from one of the columns of the matched row and returns it with each instance of a queried term surrounded by markup in the same manner as the highlight() function. The fragment of text is selected so as to maximize the number of queried terms it contains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9eabcd215930eb738f36712bb83d6c0b14ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; or &quot;AFL&quot; fuzzer is a recent (circa 2014) innovation from Michal Zalewski. Unlike most other fuzzers that blindly generate random inputs, the AFL fuzzer instruments the program being tested (by modifying the assembly-language output from the C compiler) and uses that instrumentation to detect when an input causes the program to do something different - to follow a new control path or loop a different number of times. Inputs that provoke new behavior are retained and further mutated. In this way, AFL is able to &quot;discover&quot; new behaviors of the program under test, including behaviors that were never envisioned by the designers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ddbb2bd7ba87408b594939a6917d04da89a5349" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; is the version control system used to track all of the SQLite source code. A Fossil repository is an SQLite database file. (Readers are invited to ponder this recursion as an independent exercise.) Fossil is both the version-control system for SQLite and a test platform for SQLite. Whenever enhancements are made to SQLite, Fossil is one of the first applications to test and evaluate those enhancements. So Fossil was an early adopter of the NGQP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca3e4effc9207d5a63c711cbfd8ac97defe5fba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL Logic Test&lt;/b&gt;&lt;/a&gt; or SLT test harness is used to run huge numbers of SQL statements against both SQLite and several other SQL database engines and verify that they all get the same answers. SLT currently compares SQLite against PostgreSQL, MySQL, Microsoft SQL Server, and Oracle 10g. SLT runs 7.2 million queries comprising 1.12GB of test data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154e70bf20f83a327304d76749961d8773743242" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_SQL_Database&quot;&gt;WebSQL&lt;/a&gt; interface to webkit allowed any webpage to run arbitrary SQL in the browser for Chrome and Safari. That arbitrary SQL was supposed to be run inside a sandbox where it could do no harm even if exploited, but that sandbox turned out to be less secure than people supposed. In the spring of 2017, one team of hackers was able to root an iMac using a long sequence of exploits, one of which involved corrupting the pointers passed as BLOB values to the snippet() FTS3 function of an SQLite database running via the WebSQL interface inside of Safari.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6101be379589e2c8cd0e728015188ca8e192b3db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil Distributed Version Control&lt;/a&gt; system provides users with the option to download check-ins as either Tarballs, ZIP Archives, or SQLite Archives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6106b2007efa210c8ee70fed3636c5f43bb5c12d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt; is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; that allows an SQLite database to be appended to some other file. This allows (for example) a database to be appended to an executable that then opens and reads the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80173a6349ab4ffb46f02ada86de670d66a57b26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;sqlite_btreeinfo&lt;/a&gt; eponymous virtual table for introspecting and estimating the sizes of the btrees in a database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab07c049c01997dbb19b575504dcb74af616cde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/remember.c&quot;&gt;remember() extension&lt;/a&gt; needs a pointer to a C-language integer variable in which to remember the value it passes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d93d46695516053b394cd5886b780db3048dfe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt; extension show an example of a loadable extension that persistently registers both a new VFS and a new virtual table. The &lt;a href=&quot;https://sqlite.org/src/info/77b5b4235c9f7f11?ln=801-819&quot;&gt;sqlite3_vfsstat_init()&lt;/a&gt; initialization routine in that extension is called only once, when the extension is first loaded. It registers the new &quot;vfslog&quot; VFS just that one time, and it returns SQLITE_OK_LOAD_PERMANENTLY so that the code used to implement the &quot;vfslog&quot; VFS will remain in memory. The initialization routine also invokes &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; on a pointer to the &quot;vstatRegister()&quot; function so that all subsequent database connections will invoke the &quot;vstatRegister()&quot; function as they start up, and hence register the &quot;vfsstat&quot; virtual table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037dcdadc7444a9f8e13871793682a198eab41e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script, also in the canonical source tree, is used to run the speedtest1.c program. To replicate the performance measurements, collect the following files into a single directory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3427f1e6f488cf0eccc944462552651c0021ca21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/finfo?name=src/shell.c&quot;&gt;src/shell.c&lt;/a&gt; source code to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; is no longer under version control. That file is now generated as part of the build process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c808a45cb504200c3f1dbb6bdafa2749899db0fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;SQLite Fossil Repository&lt;/a&gt; contains links for downloading a Tarball, ZIP Archive, or &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; for any historical version of SQLite. The URLs for these downloads are simple and can be incorporated easily into automated tools. The format is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3fbdd1d270cc576e74540d52236d70c3135bcb8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;GeoJSON standard&lt;/a&gt; is syntax for exchanging geospatial information using JSON. GeoJSON is a rich standard that can describe nearly any kind of geospatial content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103a9865440a893fd3c0abf774146aac35769fd1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil Version Control System&lt;/a&gt; uses its own printf() implementation that is derived from an early version of the SQLite printf() implementation, but those two implementations have since diverged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9ad5b94e94e6f0742495238eb4e3e441c282ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system (designed and written for the purpose of supporting SQLite development) allows mildly trusted users to enter arbitrary SQL for generating trouble-ticket reports. That SQL is sanitized using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface, and no exploits have ever been found. But this is an example of potentially hostile agents being able to inject arbitrary SQL into the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3062c93a43df260caeb23ab2e3ad2153f90cd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1220ff947aa3310307b8d1e97a7892f5326b35" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d635355782e5d01fca2019b73467bea006012ad0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; article on this website is an earlier investigation (circa 2011) that uses the same approach as the Jim Gray paper &amp;mdash; storing the blob filenames as entries in the database &amp;mdash; but for SQLite instead of SQL Server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7fb4a466758f27d2e851f548bb98e33d7f26c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang&quot;&gt;SQL language documentation&lt;/a&gt; is converted to use &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax diagrams&lt;/a&gt; instead of BNF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0edaa5ff21911b0f3da41c0480fbb1aa18847d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command works differently in two respects when foreign key constraints are enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9caf431fddd0486fb12661e16a4ade73718c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command now gathers statistics on tables even if they have no indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e90c478519d8e9b1bd82d0dd1c5b19da711cd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement is an SQLite extension that allows two or more databases to be associated to the same database connection and to operate as if they were a single database. The number of simultaneously attached databases is limited to SQLITE_MAX_ATTACHED which is set to 10 by default. The maximum number of attached databases cannot be increased above 125.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65f9f430c67e4418373e91a58e15ed50bb5c875" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1a4fb3e81abe601d6a76ca6511292629d722a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#ifnull&quot;&gt;ifnull()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; SQL functions are now implemented using in-line VDBE code rather than calling external functions, so that unused arguments need never be evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38d1ab83adc6d5e3ecac3108de3718b731fffb5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; function is obviously non-deterministic because it gives a different answer every time it is invoked. The answers from &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid()&lt;/a&gt; depend on prior SQL statements, and so they are also non-deterministic. The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_version()&lt;/a&gt; function is mostly constant, but it can change when SQLite is upgraded, and so even though it always returns the same answer for any particular session, because it can change answers across sessions it is still considered non-deterministic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201a260c8bdbe59035cb4cd8dc3341936a60ec2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function requires a new interface on the B-tree storage engine, a new opcode in the &lt;a href=&quot;opcode&quot;&gt;virtual machine&lt;/a&gt; that runs SQL statements, and a new conditional in a critical path of the code generator. To avoid that overhead in applications that do not need the utility of sqlite_offset(X), the function is disabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5130992bbae98a73266f7f76541f0aac8e1ee306" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; SQL function does not bother to measure the length its entire input string if it is only computing a prefix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051b877cf20f31f8d1edc5b8d94b799ecd70ba91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; of a rowid table (if there is one) is usually not the true primary key for the table, in the sense that it is not the unique key used by the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine. The exception to this rule is when the rowid table declares an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. In the exception, the INTEGER PRIMARY KEY becomes an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d236ba188ef88897dc53c50ffce983697148b3b9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a rowid table can be accessed (or changed) by reading or writing to any of the &quot;rowid&quot; or &quot;oid&quot; or &quot;_rowid_&quot; columns. Except, if there is a declared columns in the table that use those special names, then those names refer to the declared columns, not to the underlying &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ebcd163f26bc17678c31c9203482eaa22d5842" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a table must be an integer. Attempt to set the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to anything other than an integer (or a NULL which will be automatically converted into the next available integer rowid) results in an SQLITE_MISMATCH error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feca6ba206a41f2092893b9e83da76d7c569ae87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement now accepts an optional list of column names following the view name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140e631b88f462024e846431476301a80f59bb76" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_datefunc&quot;&gt;Date And Time Functions&lt;/a&gt; are enhanced so that the current time (ex: julianday('now')) is always the same for multiple function invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e6d59e6b5b950615232d8af21bbe3ba88f948d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; SQL command is used to obtain a high-level description of the strategy or plan that SQLite uses to implement a specific SQL query. Most significantly, EXPLAIN QUERY PLAN reports on the way in which the query uses database indices. This document is a guide to understanding and interpreting the EXPLAIN QUERY PLAN output. Background information is available separately:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20275284a3bb298e3ed89b5acd684907f3305751" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefixes to SQL statements only affect the behavior of the statement during &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. That means that PRAGMA statements that take effect during &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; will behave the same way regardless of whether or not they are prefaced by &quot;EXPLAIN&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65133dc98116af2c7f0912fa88b4b43954bbc4b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa44fcf9bdf1d542216cc05466871344f55fb9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92948d462015f78d114a35cb7f278e70f987a87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt; is now able to drive indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d7aaefd27d25ac767f490e47e6b7c9452f7e20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3b6b4eb30c653aa6f7ff986fc3927d49da19df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command only works if the transaction stack is empty, or in other words if there are no pending transactions. If the transaction stack is not empty when the &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command is invoked, then the command fails with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68024f72adbd8a0a422c4b54cc30c9ba1ec76d4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command commits all outstanding transactions and leaves the transaction stack empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3d11e09f03993abe204e129a5f26dcc598fb68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command now succeeds even if there are pending queries. It returns &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are pending incremental BLOB I/O requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502339818ec9310f1093ba4d9556feff42c6ac87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command without a TO clause rolls backs all transactions and leaves the transaction stack empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ed8eeff156b9ac5c3272aebc736d20e9be8ea0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements within triggers do not support the full syntax for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements. The following restrictions apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25fa7af4817ff50638a1d09b6077bfa20413eee0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command packs the database about 1% tighter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6f65ccce3c60bd3538bde45dbba0bdabdce834" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command preserves the setting of the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt;. (Ticket #2804.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47212a8707d0f0bd1679c6ba64f918cc5f5c6039" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command works by creating a temporary file and then rebuilding the entire database into that temporary file. Then the content of the temporary file is copied back into the original database file and the temporary file is deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf2bbad9bfa5eb4a9865a13c14cd208bf3e40df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause must occur on the first SELECT of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;. It cannot follow a &lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db6f4f9f7ee46543ffd0410e2806fc648ca23245" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; creates a faster parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ba7e4dcf6a75ed4b1ebb47695358df4a104180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; documentation describes how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt; as shared libraries. The techniques described there work fine for the json1 module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01edd329b33f240dcc5cfa34ddb1e15eb22f3ff1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d8579383d45cb472d3a4833d1ee2e13e4c3902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6272b90c1e46ccb51f6a211fb05dce0a9b88e6f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2033aab7c928977e8c566f6458591e6094a394bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54555d04b0b2355ea81551452a102d3dd5b8966e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f893d6e4ed45be57e659539245cae9d67b977d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; program created by the code generator is run by a virtual machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f82427ae6db3af3b60ee7889919a09e27176099" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Delete&quot;&gt;Delete&lt;/a&gt; does the work of this loop; it pops an integer key off the stack (placed there by the preceding ListRead) and deletes the record of cursor P1 that has that key. Because P2 is true, the row change counter is incremented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49cbb2109ea61f54a2e0e215073c0e8f4e901d2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Ge&quot;&gt;Ge&lt;/a&gt; operator compares the top two elements on the stack, pops them, and then branches based on the result of the comparison. If the second element is &amp;gt;= the top element, then jump to address P2 (the Next instruction at the end of the loop). Because P1 is true, if either operand is NULL (and thus the result is NULL) then take the jump. If we don't jump, just advance to the next instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04783e2a879da777c9928b0ae80c86689e955e7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Gosub&quot;&gt;Gosub&lt;/a&gt; opcode stores the current program counter into register P1 then jumps to address P2. The &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; opcode jumps to address P1+1. Hence, every subroutine is associated with two integers: the address of the entry point in the subroutine and the register number that is used to hold the return address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4a6e0d461e428b5be9265ddcc51214a7a17162" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; jumps back to the beginning of the loop. This is the end of the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b42b8529eed45ca4088e7606ce454bf579c098" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRead&quot;&gt;ListRead&lt;/a&gt; instruction reads an element from the temporary storage list and pushes it onto the stack. If this was successful, it continues to the next instruction. If this fails because the list is empty, it branches to P2, which is the instruction just after the loop. Afterwards the stack looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4879ed312fe574048c51b739d2a2e0c47c1cf28a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListReset&quot;&gt;ListReset&lt;/a&gt; instruction empties the temporary storage list. This list is emptied automatically when the VDBE program terminates, so it isn't necessary in this case. The Close instruction closes the cursor P1. Again, this is done by the VDBE engine when it is finished running this program. The Commit ends the current transaction successfully, and causes all changes that occurred in this transaction to be saved to the database. The final Halt is also unnecessary, since it is added to every VDBE program when it is prepared to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c0b593163bf5647baef877e0e92b5b46f19553" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRewind&quot;&gt;ListRewind&lt;/a&gt; instruction rewinds the temporary storage list to the beginning. This prepares it for use in the second loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d684585d2e3d5fa36d7d1264c013ad5c814a5d30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bec0991ede69ff0f5b657d6da948ae6ccecdc12" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; instruction pops the top stack element and uses it as an integer key. If a record with that key does not exist in table P1, then jump to P2. If a record does exist, then fall through to the next instruction. In this case P2 takes us to the Goto at the end of the loop, which jumps back to the ListRead at the beginning. This could have been coded to have P2 be 16, the ListRead at the start of the loop, but the SQLite parser which generated this code didn't make that optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d15a242c00ad338da3936112e42488d3db597cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; opcode performs the same operation, but with &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; the P3 register must be guaranteed to contain an integer value. With this opcode, register P3 might not contain an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea51892f8acadad179e6f2fd2f42516a5edf44d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; opcode performs the same operation on index btrees (with arbitrary multi-value keys).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066073395b0144e2fa69bed2cb062af29a031388" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7073f193fc700364fff65aec536137cac5241f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Recno&quot;&gt;Recno&lt;/a&gt; instruction pushes onto the stack an integer which is the first 4 bytes of the key to the current entry in a sequential scan of the table pointed to by cursor P1. The &lt;a href=&quot;opcode#ListWrite&quot;&gt;ListWrite&lt;/a&gt; instruction writes the integer on the top of the stack into a temporary storage list and pops the top element. This is the important work of this loop, to store the keys of the records to be deleted so we can delete them in the second loop. After this ListWrite instruction the stack is empty again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3dc9b6c04eaf92dc7b817ad9cb3a0c30096f49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode may only be used with P5==0 or P5==OPFLAG_SEEKEQ and with P4 being a P4_KEYINFO object. Furthermore, the P3 value must be the same as every other &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; or &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; for the same cursor number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b24140a6cba2cd01303fe562cef908cbaa8ca3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it first checks to see if the cursor on P1 is already open on the same b-tree and if it is this opcode becomes a no-op. In other words, if the cursor is already open, do not reopen it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cd685549e7ced789f6d67a2427e140b8a8620d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; opcode causes the bytecode engine to pause and the corresponding &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call to return &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. Before invoking &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt;, the bytecoded program will have loaded the results for a single row of a query into a series of registers. C-language APIs such as &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_int()&lt;/a&gt; or &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt; extract the query results from those registers. The bytecode engine resumes with the next instruction after the &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; on the next call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2441406e5ac75bb5fd7cf1919c714faf20d6ab5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction initializes a loop that iterates over the &quot;examp&quot; table. It rewinds the cursor P1 to the first entry in its table. This is required by the Column and Next instructions, which use the cursor to iterate through the table. If the table is empty, then jump to P2 (10), which is the instruction just past the loop. If the table is not empty, fall through to the following instruction at 6, which is the beginning of the loop body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de14c27a6545978f9bf6b60627e8141b94b7884" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt; opcode performs the same operation but also allows the P3 register to contain a non-integer value, in which case the jump is always taken. This opcode requires that P3 always contain an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b451f841c2d23194bca9774c72889abafce37d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; opcode swaps the value of the program counter with the integer value in register P1. This opcode is used to implement coroutines. Coroutines are often used to implement subqueries from which content is pulled on an as-needed basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf8499185976fd90927b75af83cad8ae29ef209" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; optimization is now capable of generating a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; if that is appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430bd4f8cb87deb1b045d791ee37f7bd1ef6a250" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; is allowed to proceed even if the OR expression has also been converted into an IN expression. Uses of the OR optimization are now also &lt;a href=&quot;eqp#or-opt&quot;&gt;more clearly shown&lt;/a&gt; in the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e2344b1a8686faee26008aaf6a744a538483c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt; PRAGMA auto_vacuum=incremental&lt;/a&gt; setting is now persistent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d34339badbc8db002db2288680cbe2b4fee1a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;PRAGMA compile_options&lt;/a&gt; command now attempts to show the version number of the compiler that generated the library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e347c28fc2dc6a091d91c4397055e68e6edfd76f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dace9501e55329de3c436aaaf6d76500923f6803" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;PRAGMA defer_foreign_keys=ON&lt;/a&gt; statement now also disables &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;RESTRICT actions&lt;/a&gt; on foreign key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="182946c7ddef87f825c408a1e9bcb94b2aebed4e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys pragma&lt;/a&gt; can be used to temporarily change all foreign key constraints to deferred regardless of how they are declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f76b3a27760e9d216beb8e378b627c5a5752f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt; commands are now enabled in all builds by default. Disable them using &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;-DSQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530eb5492fa66c41d47c216aab5658b932f1fde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo&lt;/a&gt; pragmas are enhanced to provide information about the on-disk representation of &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e422cf4cf15df880c393dd24dbfb049b1fcebe08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt; is enhanced to detect out-of-order rowids.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e10d900e5bf7e69cd4dd309e31da996954ece3c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is not OFF, MEMORY, or WAL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c602efe807a207ac9abab9847aa84a66f50dd768" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49dd3e21f049f6bfedb0b7b5b1043722f3e1e37c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; setting is enabled prior to invoking this method, and the value for legacy_alter_table is restored after this method finishes. This is necessary for the correct operation of virtual tables that make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; where the shadow tables must be renamed to match the new virtual table name. If the legacy_alter_format is off, then the xConnect method will be invoked for the virtual table every time the xRename method tries to change the name of the shadow table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb34969d518c763e5a52bf4853965875f5d7c504" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt; max_page_count PRAGMA&lt;/a&gt; can be used to raise or lower this limit at run-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5ae39d1285e1f44b4d8e91bc72231ec08350d0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will never increase the amount of address space used for memory-mapped I/O above the hard limit set by the &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt; compile-time option, nor the hard limit set start-time by the second argument to sqlite3_config(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bccc6c555afb6a2715bad46795ba129af0dfe49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command was first introduced with SQLite 3.18.0 (2017-03-28) and is a no-op for all prior releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8494947b4ce168119d270366337d52ae940b6c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command will automatically run ANALYZE on individual tables on an as-needed basis. The recommended practice is for applications to invoke the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; statement just before closing each database connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb4e7b95d0d162ecc58614e1af3f3f6380ba85b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is not OFF</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b30b153f5bd150efb6f72a306c286fdddb45c5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; has an integer value which also influences the decision of where to store temporary files. The values of the temp_store pragma have the following meanings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fb45c2bb944888554bf90c8cb9a47bf3f2a979" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7aff6f6a70787230cfdaa84381a4df9ff6088c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; pragmas correctly set their column names in the result set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69bec34ec00cc126a20d5db14b73449e907cdd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae72cb78cf83086aebe14bf09934eef63425e9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a223c3d19041fa0b396d7e3f3b2e302f5459e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684edbb611cbfa5623d7b600fa16d86090b5ff1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2d35feb7b268110f32aac36c1f5d65016e60f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61dec61cb0cf17103a6811f56ba836ebb2ef7198" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df93bf8497a2d78f6914976e1609ba432170056" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb8933cda6d990d1669eb3665d8053606aee0ba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd30234761e0c7ea9f1053536a7bfab89c37bb25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6dd20be85a6ee9376cfe67d011732f51298a56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0815af1640f3451efe07a076fe65835b297a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt; describes steps that application developers should following to help resolve query planner problems. Notice the that the use of INDEXED BY is a last resort, to be used only when all other measures fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1b5fdf8ac1234008ffa858abbdb051486a832c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; extended error code is returned in WAL mode when a read transaction cannot be upgraded to a write transaction because the read is on an older snapshot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55e40d30155becf01edc33f7916ec42f8c15006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3841b0084bc10aa5540a5c6c5c96fb98131e7bf0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540e7b1566721b5eeac705b77c4d701d37c07cab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; returns this result code when an attempt is made to update the R-Tree while another prepared statement is actively reading the R-Tree. The update cannot proceed because any change to an R-Tree might involve reshuffling and rebalancing of nodes, which would disrupt read cursors, causing some rows to be repeated and other rows to be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7707f3c0dce0c68c0fd1c390c4bccf3ca9ffcb57" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API is called to create and initialize an iterator to iterate through the contents of a changeset. Initially, the iterator points to no element at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c05e642dac6053ce210738d48ce79ebc45ba34" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9f192cd368c894585cf856c53081dab4346439" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88888932989847ef34ae0441a4a296cbf9342ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334527e56ba0a296ee1d1034ee6898a348187ebd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f028c2f95ad413ccf78f4f0e636bf684908330" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60983fe9853f804b509f3ca97ea438091fe792b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e22e1c7c111b00a70790db9ce08d967e255fcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086ca737ecffa34122715fb37e08e08253d88ee7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511890649947f63b55f8621e1cda37e48d68f4cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cef92cfdf633fc0c634b624e8f2e6727a6b4196" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension allows the application to optionally specify the rowid for each INSERT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d837c3195216596d022a1ac6dfae8f94ace29826" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function can also be selected or deselected at run-time by inserting an appropriate string into the &quot;command&quot; column of the virtual table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832a2975224a148de7d49b3ae21cbf638061bcda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; idea shows how SQLite can be used as a substitute for ZIP archives or Tarballs. An archive of files stored in SQLite is only very slightly larger, and in some cases actually smaller, than the equivalent ZIP archive. And an SQLite archive features incremental and atomic updating and the ability to store much richer metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e695129653037caa8407461dbbd9ea2a46762ce1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a912a810b3a28ec149be0106a75289dbfa6333" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fad1c80b91150cb25ef6b94b5eb5de73c5d25b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0fd412f541ab2a0f3d35988066ed4e8e4128c77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a49ade027432cc3ca56bc0bb1633c34a874ad30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;../printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8207628b57fa2acb2222184f79be191c7783d2ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3979188fa64e50e829929b1acf8c993dc30e5490" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c6db74a667c1ebd14fbec47092019e01e83407" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e06028d8d9a37c76976481d45631c9360b94773" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893b46b38f797cff31c49b4ea957f7271c4d11b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f2751d83d7d253a00544efb010e3f4e128798b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4893933da22367d13b4236043c7aa3ee536ea00a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e174ba8e6223c998f458135f997fdab25603db49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f61b252192f444bf8f6f8d93e248db03a4d372" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8540813014d56ead7baf2b2daf047a27f8df8c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4bc6f080bcb0613b19c8e24f2c8215e3263de6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; has been enhanced to use the &lt;a href=&quot;http://www.tcl-lang.org/cgi-bin/tct/tip/322.html&quot;&gt;Non-Recursive Engine (NRE)&lt;/a&gt; interface to the TCL interpreter when linked against TCL 8.6 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4e73f7d156e22fa7106d9f30fd3d58ff51bfbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing#slt&quot;&gt;SQL Logic Tests&lt;/a&gt; are a set of test cases designed to show that SQLite behaves the same as other SQL database engines. These tests are hosted in a separate code public repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f65ab47a0f86c2f22ae6f2632075f4320a179c7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;th3&quot;&gt;Test Harness #3&lt;/a&gt; or &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite is a private set of test cases used to test SQLite to 100% MC/DC in an as-delivered configuration. TH3 sources are served on the same servers as the other SQLite repositories, but differ from the others in being proprietary. The TH3 code is only accessible to SQLite developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a696ccc2b635cda261283e62314013cf8db5a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2803f974353bfc4cbf30a15e234d493460a39f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;versionnumbers&quot;&gt;version numbering conventions&lt;/a&gt; for SQLite are revised to use the emerging standard of &lt;a href=&quot;http://semver.org/&quot;&gt;semantic versioning&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca284a5c0b69f330d98de127457542bdad0ece1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16) adds a new device characteristic named &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;. Database files that report this characteristic are assumed to reside on storage systems that have the powersafe overwrite property. The default unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now report &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; if SQLite is compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=1&lt;/a&gt; or they make the legacy assumption that storage does not have the powersafe overwrite property if compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=0&lt;/a&gt;. For now, the default is for powersafe overwrite to be turned on, though we may revisit this in the future and default it off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28df118ed088f75e95fa60751c2ccab88df9bbf6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; method in the implementation of this table checks for equality constraints against the HIDDEN columns, and uses those as input parameters to determine the range of integer &quot;value&quot; outputs to generate. Reasonable defaults are used for any unconstrained columns. For example, to list all integers between 5 and 50:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cea685ebbde84bdb5186b0eb1062c8517be452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b191bb31eb6d4e8bdeb7b48904acffd3c2dfc6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6feb2481a619b82b0e2f46a25f49c2e66551dca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; method is called whenever a database connection that uses a virtual table is closed. The xDestroy method is only called when a &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement is executed against the virtual table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0ce4af06185c37b128ad21eebbd21f3f9ac244" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method was originally designed around having a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; as a single value. The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method has been expanded to accommodate an arbitrary PRIMARY KEY in place of the ROWID, but the PRIMARY KEY must still be only one column. For this reason, SQLite will reject any WITHOUT ROWID virtual table that has more than one PRIMARY KEY column and a non-NULL xUpdate method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e22d8d27e272cb6edbc57854c2655aac986253" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal#advantages&quot;&gt;second advantage of WAL-mode&lt;/a&gt; is that writers do not block readers and readers to do not block writers. This is &lt;u&gt;mostly&lt;/u&gt; true. But there are some obscure cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, so applications should be prepared for that happenstance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73dd67efef2f2aca70b69d53d116d51359c36e68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70220a93d132293d087792692e0745eaa50f6944" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c4cc754894816f7c5238173cc6918a40c6ae4d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#locks&quot;&gt;WAL-mode locks&lt;/a&gt; are described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2815c286729fb6fca3fa728a7812f5c530ea71ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; is implemented using an ordinary file that is mmapped for robustness. Early (pre-release) implementations of WAL mode stored the wal-index in volatile shared-memory, such as files created in /dev/shm on Linux or /tmp on other unix systems. The problem with that approach is that processes with a different root directory (changed via &lt;a href=&quot;http://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt;) will see different files and hence use different shared memory areas, leading to database corruption. Other methods for creating nameless shared memory blocks are not portable across the various flavors of unix. And we could not find any method to create nameless shared memory blocks on windows. The only way we have found to guarantee that all processes accessing the same database file use the same shared memory is to create the shared memory by mmapping a file in the same directory as the database itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f2b794ee3e27ce7edc3429510c9bf44ed6503d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;whentouse#website&quot;&gt;Appropriate Uses For SQLite&lt;/a&gt; page says that dynamic pages on the SQLite website typically do about 200 SQL statements each. This has provoked criticism from readers. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb12d8d86687eb25304ab545c4bdc2adb558bbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; can read and write a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP Archive&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23698ad6db1bcbbe81ce38782af791870223128" translate="yes" xml:space="preserve">
          <source>The &lt;b id=&quot;tcl&quot;&gt;TCL Tests&lt;/b&gt; are the oldest set of tests for SQLite. They are contained in the same source tree as the SQLite core and like the SQLite core are in the public domain. The TCL tests are the primary tests used during development. The TCL tests are written using the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL scripting language&lt;/a&gt;. The TCL test harness itself consists of 26.9 KSLOC of C code used to create the TCL interface. The test scripts are contained in 1264 files totaling 20.5MB in size. There are 44792 distinct test cases, but many of the test cases are parameterized and run multiple times (with different parameters) so that on a full test run millions of separate tests are performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6c5521cf56a12cd7c97f53a6e81f778a626555" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; test harness is a set of proprietary tests, written in C that provide 100% branch test coverage (and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC test coverage&lt;/a&gt;) to the core SQLite library. The TH3 tests are designed to run on embedded and specialized platforms that would not easily support TCL or other workstation services. TH3 tests use only the published SQLite interfaces. TH3 consists of about 69.4 MB or 948.1 KSLOC of C code implementing 44753 distinct test cases. TH3 tests are heavily parameterized, though, so a full-coverage test runs about 1.7 million different test instances. The cases that provide 100% branch test coverage constitute a subset of the total TH3 test suite. A soak test prior to release does hundreds of millions of tests. Additional information on TH3 is &lt;a href=&quot;th3&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd8f15572230ed1f58d51c1d5372e68bc7d3339" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;i&gt;page number&lt;/i&gt;&lt;/b&gt; of the cached page. Pages are sequentially numbered within a database file starting from page 1 (page 1 begins at byte offset 0). Refer to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a39adda694af530886e4e9df6d7182a049eea0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SQLITE_ENABLE_REDEF_IO&lt;/b&gt; compile-time flag no longer functions. I/O procedures are now always redefinable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66961c7dbacae09d459d2962003215ef6b06eee5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ascii&lt;/b&gt; tokenizer, which assumes all characters outside of the ASCII codepoint range (0-127) are to be treated as token characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7024788e6b267f1ba270622b866f7355ceaff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;atomic-write&lt;/b&gt; property. A system that supports this property also specifies the size or sizes of the blocks that it is capable of writing. Valid sizes are powers of two greater than 512. If a write operation modifies a block of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ac7f6fa28d8af8532959a7c557a99ffb086e4a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;cached data&lt;/b&gt;; a blob of data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdaa687775a7cc6ed8f468435ceaab97dc48b3c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum initializer&lt;/b&gt; field is set to a pseudo-random value. It is used as part of the algorithm to calculate the checksum for all</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9732c0255b0b0de3b180d5a5b9e6e0e0de10ed21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum&lt;/b&gt; field contains a checksum value stored as a 4-byte big-endian signed integer. The checksum value is calculated as the sum of the bytes that make up the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808b646bb572829a50a12856cab578c0ba1273b4" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child key&lt;/b&gt; is the column or set of columns in the child table that are constrained by the foreign key constraint and which hold the REFERENCES clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb5a92cd04b8762d6cafb14dc40e6502ca97d4b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child table&lt;/b&gt; is the table that a foreign key constraint is applied to and the table that contains the REFERENCES clause. The example in this section uses the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c172ce98989ce0e6fad8d66979d45e11202395" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;columns=&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbf98eb754afaa644e3f69b92d0dc2195f52253" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;data=&lt;/b&gt; argument specifies that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6baedccfb53deaad3fb37afa8fc4d96019b82c5a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbhash&lt;/b&gt; (or &lt;b&gt;dbhash.exe&lt;/b&gt; on Windows) utility is a command-line program that computes the SHA1 hash of the schema and content for an SQLite database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a3ef16a0b39b8edb4795fe8274619e6786a20a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbstat&lt;/b&gt; virtual table is available on all &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; when SQLite is built using the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option. The dbstat virtual table provides low-level information about btree and overflow pages in a database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a580c33e2e93bdaf2b8468f5fe69cbcb6b77c7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;filename=&lt;/b&gt; argument specifies an external file from which CSV content is read. Every CSV virtual table must have either a &lt;b&gt;filename=&lt;/b&gt; argument or a &lt;b&gt;data=&lt;/b&gt; argument and not both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b993a193dd09d944f6699b7d9c40cd91aa1faf7c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;journal magic&lt;/b&gt; field always contains a well-known 8-byte string value used to identify SQLite journal files. The well-known sequence of byte values is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb60bd76a6daf3fc22f58ff7ed03bdcd9faa9a0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a8fe72057fb6a9d52ebf2366e8ca3d47b3ef51" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;master journal name&lt;/b&gt; field contains the name of the master journal file, encoded as a utf-8 string. There is no nul-terminator appended to the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32cd399bbb4e1a23152d71a26f07f3eec308179e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;name-length&lt;/b&gt; field contains the length of the previous field in bytes, formatted as a 4-byte big-endian unsigned integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae22eeca9bdb678bd49709e0047fc71684a2c64" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;page size&lt;/b&gt; field contains the database page size used by the corresponding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47567cd5b3319ed0502d81821002b32b190c8e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent key&lt;/b&gt; is the column or set of columns in the parent table that the foreign key constraint refers to. This is normally, but not always, the primary key of the parent table. The parent key must be a named column or columns in the parent table, not the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
