<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sequelize">
    <body>
      <group id="sequelize">
        <trans-unit id="baf542c6a886f2170e6594b0cd4c2ad52976c234" translate="yes" xml:space="preserve">
          <source>Having options</source>
          <target state="translated">옵션 있음</target>
        </trans-unit>
        <trans-unit id="8421e2a51a8261b6660fa9c0a9fd6e14eb653c86" translate="yes" xml:space="preserve">
          <source>Helper functions for use inside getter and setter definitions</source>
          <target state="translated">게터 및 세터 정의 내부에서 사용하기위한 도우미 함수</target>
        </trans-unit>
        <trans-unit id="24c3d9b4e0e40c927afc8e7965f44190f7b0a7ad" translate="yes" xml:space="preserve">
          <source>Helper method to determine if a instance is &quot;soft deleted&quot;.</source>
          <target state="translated">인스턴스가 &quot;소프트 삭제&quot;되었는지 확인하는 도우미 메서드</target>
        </trans-unit>
        <trans-unit id="15900e9e0261074339464c903170431feba6def9" translate="yes" xml:space="preserve">
          <source>Helper method to determine if a instance is &quot;soft deleted&quot;. This is particularly useful if the implementer renamed the &lt;code&gt;deletedAt&lt;/code&gt; attribute to something different. This method requires &lt;code&gt;paranoid&lt;/code&gt; to be enabled.</source>
          <target state="translated">인스턴스가 &quot;소프트 삭제&quot;되었는지 확인하는 도우미 메서드 이것은 구현 &lt;code&gt;deletedAt&lt;/code&gt; 속성의 이름 을 다른 것으로 바꾼 경우에 특히 유용합니다 . 이 방법을 사용하려면 &lt;code&gt;paranoid&lt;/code&gt; 을 활성화 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="74b5b0e337605288491d3919c18791d4428323a7" translate="yes" xml:space="preserve">
          <source>Here is an example demonstrating use cases of BelongsTo and HasOne.</source>
          <target state="translated">다음은 ContainssTo 및 HasOne의 사용 사례를 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="c526e01d78df0d88e184c85be4505b4a091ed47f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;deleted&lt;/code&gt; scope is merged with the finder. If we were to pass &lt;code&gt;where: { firstName: 'john', deleted: false }&lt;/code&gt; to the finder, the &lt;code&gt;deleted&lt;/code&gt; scope would be overwritten.</source>
          <target state="translated">여기서 &lt;code&gt;deleted&lt;/code&gt; 범위는 파인더와 병합됩니다. 우리가 통과한다면 &lt;code&gt;where: { firstName: 'john', deleted: false }&lt;/code&gt; 파인더에의 &lt;code&gt;deleted&lt;/code&gt; 범위는 덮어 될 것이다.</target>
        </trans-unit>
        <trans-unit id="9afa5e334e28c0ce37c5ef76de0154fcbd75e3db" translate="yes" xml:space="preserve">
          <source>Here, our user model is called &lt;code&gt;user&lt;/code&gt;, with a lowercase u - This means that the property in the object should also be &lt;code&gt;user&lt;/code&gt;. If the name given to &lt;code&gt;sequelize.define&lt;/code&gt; was &lt;code&gt;User&lt;/code&gt;, the key in the object should also be &lt;code&gt;User&lt;/code&gt;. Likewise for &lt;code&gt;addresses&lt;/code&gt;, except it's pluralized being a &lt;code&gt;hasMany&lt;/code&gt; association.</source>
          <target state="translated">여기서, 우리의 사용자 모델은 &lt;code&gt;user&lt;/code&gt; 이며, 소문자 u-이것은 객체의 속성도 &lt;code&gt;user&lt;/code&gt; 여야 함을 의미합니다 . &lt;code&gt;sequelize.define&lt;/code&gt; 에 지정된 이름 이 &lt;code&gt;User&lt;/code&gt; 인 경우 개체의 키도 &lt;code&gt;User&lt;/code&gt; 여야합니다 . &lt;code&gt;hasMany&lt;/code&gt; 연관으로 복수화되는 것을 제외하고 는 &lt;code&gt;addresses&lt;/code&gt; 에 대해서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="139103af93155175db170f4086701037ce627db7" translate="yes" xml:space="preserve">
          <source>Hierarchies</source>
          <target state="translated">Hierarchies</target>
        </trans-unit>
        <trans-unit id="4c2c702395b304a44afd07f98c51e1749b23060d" translate="yes" xml:space="preserve">
          <source>Historical records / Time travel</source>
          <target state="translated">역사 기록 / 시간 여행</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="4212538b69426994af61524680ab6c713fab4826" translate="yes" xml:space="preserve">
          <source>Hooks (also known as lifecycle events), are functions which are called before and after calls in sequelize are executed. For example, if you want to always set a value on a model before saving it, you can add a &lt;code&gt;beforeUpdate&lt;/code&gt; hook.</source>
          <target state="translated">후크 (라이프 사이클 이벤트라고도 함)는 시퀀스에서 호출이 실행되기 전후에 호출되는 함수입니다. 예를 들어, 모델을 저장하기 전에 항상 값을 설정하려면 &lt;code&gt;beforeUpdate&lt;/code&gt; 후크를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f00c9b0e6957fcef4079e622b05e8f359ef558dc" translate="yes" xml:space="preserve">
          <source>HostNotFoundError</source>
          <target state="translated">HostNotFoundError</target>
        </trans-unit>
        <trans-unit id="df98405c75e3d2293644f3903f9ba376eecd65dd" translate="yes" xml:space="preserve">
          <source>HostNotReachableError</source>
          <target state="translated">HostNotReachableError</target>
        </trans-unit>
        <trans-unit id="deb41f9eccd872d97cae66101673dc591a3dd320" translate="yes" xml:space="preserve">
          <source>How many rows to delete</source>
          <target state="translated">삭제할 행 수</target>
        </trans-unit>
        <trans-unit id="55c6fc1c78b7f02391f35f14b313aa07ac416870" translate="yes" xml:space="preserve">
          <source>How many rows to undelete (only for mysql)</source>
          <target state="translated">삭제를 취소 할 행 수 (mysql 만 해당)</target>
        </trans-unit>
        <trans-unit id="c74419ff22ba551918695ec2d4d452f7e5aafa8c" translate="yes" xml:space="preserve">
          <source>How many rows to update (only for mysql and mariadb, implemented as TOP(n) for MSSQL; for sqlite it is supported only when rowid is present)</source>
          <target state="translated">업데이트 할 행 수 (mysql 및 mariadb 만 해당, MSSQL의 경우 TOP (n)으로 구현, sqlite의 경우 rowid가있는 경우에만 지원됨)</target>
        </trans-unit>
        <trans-unit id="6ae043fac4f95946de2cb5d70a20b98cbb4b4075" translate="yes" xml:space="preserve">
          <source>How many times a failing query is automatically retried.</source>
          <target state="translated">실패한 쿼리가 자동으로 재 시도되는 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="bcd7ff308853d4934c2fcd304af01bbf8af438f7" translate="yes" xml:space="preserve">
          <source>How many times a failing query is automatically retried. Set to 0 to disable retrying on SQL_BUSY error.</source>
          <target state="translated">실패한 쿼리가 자동으로 재 시도되는 횟수입니다. SQL_BUSY 오류에서 재 시도를 사용하지 않으려면 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cb9871e1bb1811c7e92e66eae26e9dbdc2227fce" translate="yes" xml:space="preserve">
          <source>However, adding &lt;code&gt;hooks: true&lt;/code&gt; explicitly tells Sequelize that optimization is not of your concern and will perform a &lt;code&gt;SELECT&lt;/code&gt; on the associated objects and destroy each instance one by one in order to be able to call the hooks with the right parameters.</source>
          <target state="translated">그러나 &lt;code&gt;hooks: true&lt;/code&gt; 추가하면 Sequelize에 최적화가 중요하지 않다고 알려주고 올바른 매개 변수로 후크를 호출 할 수 있도록 연관된 객체에 대해 &lt;code&gt;SELECT&lt;/code&gt; 를 수행 하고 각 인스턴스를 하나씩 파괴합니다.</target>
        </trans-unit>
        <trans-unit id="c2b8ea142713d4e18b2a52407b042919ba804f65" translate="yes" xml:space="preserve">
          <source>However, if getters and/or setters are defined for &lt;code&gt;field&lt;/code&gt; they will be invoked, instead of returning the value from &lt;code&gt;dataValues&lt;/code&gt;. Accessing properties directly or using &lt;code&gt;get&lt;/code&gt; is preferred for regular use, &lt;code&gt;getDataValue&lt;/code&gt; should only be used for custom getters.</source>
          <target state="translated">그러나 getter 및 / 또는 setter가 &lt;code&gt;field&lt;/code&gt; 에 대해 정의 된 경우 &lt;code&gt;dataValues&lt;/code&gt; 에서 값을 리턴하는 대신 호출됩니다 . 속성을 직접 액세스하거나 &lt;code&gt;get&lt;/code&gt; 을 사용 하는 것이 정기적으로 사용되는 것이 바람직하며 &lt;code&gt;getDataValue&lt;/code&gt; 는 사용자 정의 getter에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d191358a866703a8af0d57f25666c38b8499366" translate="yes" xml:space="preserve">
          <source>However, please note that whenever you get back a value that is range you will receive:</source>
          <target state="translated">그러나 범위의 값을 되 찾을 때마다 다음을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="971b6559af147ead7fa90d836302f41e54b0377c" translate="yes" xml:space="preserve">
          <source>However, the code above will result in the following error: &lt;code&gt;Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -&amp;gt; versions =&amp;gt; documents&lt;/code&gt;.</source>
          <target state="translated">그러나 위의 코드는 다음과 같은 오류가 발생합니다. &lt;code&gt;Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -&amp;gt; versions =&amp;gt; documents&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9226f99dd645a71848cf0585c15059d7de868f4" translate="yes" xml:space="preserve">
          <source>IGNORE</source>
          <target state="translated">IGNORE</target>
        </trans-unit>
        <trans-unit id="8ae3e8381a64e36db57a5344790db89d7de90954" translate="yes" xml:space="preserve">
          <source>IMMEDIATE</source>
          <target state="translated">IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="8f3bb7db433392fa9cd059cb669816e6111bb633" translate="yes" xml:space="preserve">
          <source>INET</source>
          <target state="translated">INET</target>
        </trans-unit>
        <trans-unit id="69c8af3292fb9fef906812e99c9acfa99a66fd97" translate="yes" xml:space="preserve">
          <source>INITIALLY_DEFERRED</source>
          <target state="translated">INITIALLY_DEFERRED</target>
        </trans-unit>
        <trans-unit id="d0a0d37857e35a2dc02ec4fe0c913bf1991b276e" translate="yes" xml:space="preserve">
          <source>INITIALLY_IMMEDIATE</source>
          <target state="translated">INITIALLY_IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="0fe37e40e5dab3ac411c2ddca6d21991e811acfa" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
          <target state="translated">INTEGER</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="d9fdf457bfc8e4d5000783186983c15ac6bcde12" translate="yes" xml:space="preserve">
          <source>If a particular field of a model is set to not allow null (with &lt;code&gt;allowNull: false&lt;/code&gt;) and that value has been set to &lt;code&gt;null&lt;/code&gt;, all validators will be skipped and a &lt;code&gt;ValidationError&lt;/code&gt; will be thrown.</source>
          <target state="translated">모델의 특정 필드가 null을 허용하지 않도록 설정되고 ( &lt;code&gt;allowNull: false&lt;/code&gt; ) 해당 값이 &lt;code&gt;null&lt;/code&gt; 로 설정된 경우 모든 유효성 검증 기가 건너 뛰고 &lt;code&gt;ValidationError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80d19fa71b3b212078b2af9bb47612878b596815" translate="yes" xml:space="preserve">
          <source>If a single default schema per model is needed, set the &lt;code&gt;options.schema='schema'&lt;/code&gt; parameter during the &lt;code&gt;define()&lt;/code&gt; call for the model.</source>
          <target state="translated">모델 당 단일 기본 스키마가 필요한 경우 모델 의 &lt;code&gt;define()&lt;/code&gt; 호출 중에 &lt;code&gt;options.schema='schema'&lt;/code&gt; 매개 변수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ec2460c5c0105c3640d21141a54ba2c766998ff" translate="yes" xml:space="preserve">
          <source>If a string is provided, that column is decremented by the value of &lt;code&gt;by&lt;/code&gt; given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given</source>
          <target state="translated">문자열이 제공되면 해당 열은 옵션 &lt;code&gt;by&lt;/code&gt; 지정된 by 값만큼 감소합니다 . 배열이 제공되면 각 열에 대해서도 동일합니다. 및 객체가 제공되면 각 열은 제공된 값만큼 감소합니다.</target>
        </trans-unit>
        <trans-unit id="a038ac481096e063842e82236359d80e84de916c" translate="yes" xml:space="preserve">
          <source>If a string is provided, that column is incremented by the value of &lt;code&gt;by&lt;/code&gt; given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.</source>
          <target state="translated">문자열이 제공되면 해당 열은 옵션 에 &lt;code&gt;by&lt;/code&gt; 주어진 값만큼 증가합니다 . 배열이 제공되면 각 열에 대해서도 동일합니다. 및 객체가 제공되면 각 열은 주어진 값만큼 증가합니다.</target>
        </trans-unit>
        <trans-unit id="d3f8b21413ef2d75f353e547b63ad8a094ceae96" translate="yes" xml:space="preserve">
          <source>If an array is passed, &lt;code&gt;$1&lt;/code&gt; is bound to the 1st element in the array (&lt;code&gt;bind[0]&lt;/code&gt;)</source>
          <target state="translated">배열이 전달되면 &lt;code&gt;$1&lt;/code&gt; 이 배열의 첫 번째 요소에 &lt;code&gt;bind[0]&lt;/code&gt; 됩니다 ( bind [0] )</target>
        </trans-unit>
        <trans-unit id="04ff1e23f5982cac50100dca79c353131b430203" translate="yes" xml:space="preserve">
          <source>If an array is passed, &lt;code&gt;?&lt;/code&gt; will be replaced in the order that they appear in the array</source>
          <target state="translated">배열이 전달되면 &lt;code&gt;?&lt;/code&gt; 배열에 나타나는 순서대로 교체됩니다</target>
        </trans-unit>
        <trans-unit id="021622889c30d11d413d8e307364ba9ff4ad40e3" translate="yes" xml:space="preserve">
          <source>If an association is aliased (using the &lt;code&gt;as&lt;/code&gt; option), you must specify this alias when including the model. Notice how the user's &lt;code&gt;Tool&lt;/code&gt;s are aliased as &lt;code&gt;Instruments&lt;/code&gt; above. In order to get that right you have to specify the model you want to load, as well as the alias:</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 옵션을 사용하여 연결의 별칭이 지정되면 모델을 포함 할 때이 별칭을 지정해야합니다. 사용자 &lt;code&gt;Tool&lt;/code&gt; 가 위의 &lt;code&gt;Instruments&lt;/code&gt; 별칭을 어떻게 사용하는지 주목하십시오 . 이를 위해서는로드 할 모델과 별명을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c54b915fccb2e4ddf42da3781b85ba11c94eff3f" translate="yes" xml:space="preserve">
          <source>If an attribute name of the table contains dots, the resulting objects will be nested. This is due to the usage of &lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;dottie.js&lt;/a&gt; under the hood. See below:</source>
          <target state="translated">테이블의 속성 이름에 점이 포함되어 있으면 결과 개체가 중첩됩니다. 이것은 후드 에서 &lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;dottie.js를&lt;/a&gt; 사용하기 때문 입니다. 아래를보십시오 :</target>
        </trans-unit>
        <trans-unit id="7e8f4a0270879aa34288ff325e1734fc57abfc56" translate="yes" xml:space="preserve">
          <source>If an object is passed, &lt;code&gt;$key&lt;/code&gt; is bound to &lt;code&gt;object['key']&lt;/code&gt;. Each key must begin with a non-numeric char. &lt;code&gt;$1&lt;/code&gt; is not a valid key, even if &lt;code&gt;object['1']&lt;/code&gt; exists.</source>
          <target state="translated">객체가 전달되면 &lt;code&gt;$key&lt;/code&gt; 는 &lt;code&gt;object['key']&lt;/code&gt; 에 바인딩됩니다 . 각 키는 숫자가 아닌 문자로 시작해야합니다. &lt;code&gt;object['1']&lt;/code&gt; 이 있어도 &lt;code&gt;$1&lt;/code&gt; 은 유효한 키가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="6e127f4ede46c56ba8a869fe2aad272d846c5e9a" translate="yes" xml:space="preserve">
          <source>If an object is passed, &lt;code&gt;:key&lt;/code&gt; will be replaced with the keys from that object. If the object contains keys not found in the query or vice versa, an exception will be thrown.</source>
          <target state="translated">객체가 전달되면 &lt;code&gt;:key&lt;/code&gt; 가 해당 객체의 키로 대체됩니다. 개체에 쿼리에서 찾을 수없는 키가 포함 된 경우 또는 그 반대의 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9304ce1affc25db6aa67ee93e8d468669f898fd5" translate="yes" xml:space="preserve">
          <source>If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed.</source>
          <target state="translated">JSON / JSONB 속성에서 dot.separated 키를 사용하여 호출하면 중첩 된 값을 설정하고 전체 객체가 변경된 것으로 플래그를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="300a90b91f546fafc57ddf54696a6ab280b20fc2" translate="yes" xml:space="preserve">
          <source>If called without a key, returns the previous values for all values which have changed</source>
          <target state="translated">키없이 호출 된 경우 변경된 모든 값의 이전 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="db0b72801ce4daab0ede65373af164330463fbaa" translate="yes" xml:space="preserve">
          <source>If changed is called with a string it will return a boolean indicating whether the value of that key in &lt;code&gt;dataValues&lt;/code&gt; is different from the value in &lt;code&gt;_previousDataValues&lt;/code&gt;.</source>
          <target state="translated">문자열과 함께 changed가 호출되면 &lt;code&gt;dataValues&lt;/code&gt; 의 해당 키 값이 &lt;code&gt;_previousDataValues&lt;/code&gt; 의 값과 다른지 여부를 나타내는 부울을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b57e7f29c55e30f10a44c4cebddd8704ddabfd60" translate="yes" xml:space="preserve">
          <source>If changed is called without an argument and no keys have changed, it will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">인수없이 changed가 호출되고 키가 변경되지 않은 경우 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="cb8a52b4f780a30671fc27031ceae2a7e48b802e" translate="yes" xml:space="preserve">
          <source>If changed is called without an argument, it will return an array of keys that have changed.</source>
          <target state="translated">인수없이 changed가 호출되면 변경된 키 배열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="20c37c0197f08cf51e26c1e2044ffa20d35483f5" translate="yes" xml:space="preserve">
          <source>If false do not prepend the query with the search_path (Postgres only)</source>
          <target state="translated">false 인 경우 search_path와 함께 쿼리를 추가하지 마십시오 (Postgres 만 해당)</target>
        </trans-unit>
        <trans-unit id="657ba5fa03244f7aee9eb6c421c8a628fdb8a23e" translate="yes" xml:space="preserve">
          <source>If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved.</source>
          <target state="translated">false이면 열에 NOT NULL 제약 조건이 있으며 인스턴스가 저장되기 전에 null이 아닌 유효성 검사가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b7040facc6b4350a46a2def78c5b8c73e7bcb1a8" translate="yes" xml:space="preserve">
          <source>If false, validations won't be run.</source>
          <target state="translated">False이면 유효성 검사가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44cd1fb91500ac78a5a510a589057a193ab6aa6d" translate="yes" xml:space="preserve">
          <source>If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; instead of &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Default is false</source>
          <target state="translated">force가 true이면 동일한 매개 변수를 가진 기존 기능이 대체됩니다. 포스트 그레스의 경우,이 수단을 사용하여 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 을 대신 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; . 기본값은 false</target>
        </trans-unit>
        <trans-unit id="6e07f5f6020b14d25df9a8addee707cdd889572f" translate="yes" xml:space="preserve">
          <source>If force is true, each Model will run &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt;, before it tries to create its own table</source>
          <target state="translated">force가 true이면 각 모델은 자체 테이블을 작성하기 전에 &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="0e59b7682415bc819345577fa12bec6b2f9cba27" translate="yes" xml:space="preserve">
          <source>If freezeTableName is true, sequelize will not try to alter the model name to get the table name. Otherwise, the model name will be pluralized</source>
          <target state="translated">freezeTableName이 true 인 경우 sequelize는 테이블 이름을 얻기 위해 모델 이름을 변경하지 않습니다. 그렇지 않으면 모델 이름이 복수가됩니다</target>
        </trans-unit>
        <trans-unit id="674d7115644f88b378cc58e55b691d817654dfdd" translate="yes" xml:space="preserve">
          <source>If hooks is true then beforeSync, afterSync, beforeBulkSync, afterBulkSync hooks will be called</source>
          <target state="translated">후크가 true이면 beforeSync, afterSync, beforeBulkSync, afterBulkSync 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2e6f9f406f5bd815e7f824d0bfb0ffc5524dc505" translate="yes" xml:space="preserve">
          <source>If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key.</source>
          <target state="translated">키가 주어지고 키에 대한 필드 또는 가상 게터가 있으면 해당 게터를 호출합니다. 그렇지 않으면 키의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="128a3eaafb2aa713f5d89656e1b713c3a3e56e43" translate="yes" xml:space="preserve">
          <source>If no key is given, returns all values of the instance, also invoking virtual getters.</source>
          <target state="translated">키가 제공되지 않으면 인스턴스의 모든 값을 반환하고 가상 게터도 호출합니다.</target>
        </trans-unit>
        <trans-unit id="894bd939fc9fbd940725facf4300464356fb6a66" translate="yes" xml:space="preserve">
          <source>If no transaction is passed in the &lt;code&gt;options&lt;/code&gt; object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call. However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize. TimeoutError will be thrown instead. If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 오브젝트 에 트랜잭션이 전달되지 않으면 찾기 후 삽입 호출 전에 다른 연결에 의해 일치하는 행이 작성되는 경쟁 조건을 방지하기 위해 내부적으로 새 트랜잭션이 작성됩니다. 그러나 SQLite에서이 경우를 처리하는 것이 항상 가능한 것은 아닙니다. 특히 첫 번째 트랜잭션이 커밋되기 전에 한 트랜잭션이 삽입되고 다른 트랜잭션이 선택하려고하는 경우입니다. 이 경우, 후유증의 인스턴스입니다. 대신 TimeoutError가 발생합니다. 트랜잭션이 생성되면 대신 세이브 포인트가 생성되고 고유 제약 조건 위반이 내부적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="55f7b072e47da9d3a76ee479789dd9f0b9a7718b" translate="yes" xml:space="preserve">
          <source>If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be set directly to the object passed, or used to extend dataValues, if dataValues already contain values.</source>
          <target state="translated">set을 객체와 함께 호출하면 객체를 반복하고 각 키, 값 쌍에 대해 반복적으로 set을 호출합니다. raw를 true로 설정하면 기본 dataValues는 전달 된 객체로 직접 설정되거나 dataValues에 이미 값이 포함 된 경우 dataValues를 확장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="391fbbeca7f5b84a6e11a9f54c2e0f1487c1d4cc" translate="yes" xml:space="preserve">
          <source>If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row</source>
          <target state="translated">true로 설정하면 destroy는 where 매개 변수와 일치하는 모든 레코드를 선택하고 각 행에서 destroy 후크 전후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="06b008b34268e778c426cab5ae74a85c1075bda2" translate="yes" xml:space="preserve">
          <source>If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored</source>
          <target state="translated">true로 설정하면이를 지원하는 방언은 DELETE FROM 대신 TRUNCATE를 사용합니다. 테이블이 잘 리면 where 및 limit 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="38d8c40738b16274aefd629da92a6bb29ab47eb3" translate="yes" xml:space="preserve">
          <source>If set to true, field and virtual setters will be ignored</source>
          <target state="translated">true로 설정하면 필드 및 가상 세터가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="27b3827a991183e8f28bbcc85806f70fa71c8f62" translate="yes" xml:space="preserve">
          <source>If set to true, included instances will be returned as plain objects</source>
          <target state="translated">true로 설정하면 포함 된 인스턴스가 일반 객체로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="eb40b80fd32cf8e71525ff0fe2f8efca5a8f93fe" translate="yes" xml:space="preserve">
          <source>If set to true, paranoid models will actually be deleted</source>
          <target state="translated">true로 설정하면 편집증 모델이 실제로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a720a3ae5cb54b9f1a92c2a8683add3f1fa36c95" translate="yes" xml:space="preserve">
          <source>If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row</source>
          <target state="translated">true로 설정하면 restore는 where 매개 변수 내에서 모든 레코드를 찾고 bulkRestore가 각 행에서 후크 전후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f750e72324e6657c8b56d788253264d692f468" translate="yes" xml:space="preserve">
          <source>If set to true, values will ignore field and virtual setters.</source>
          <target state="translated">true로 설정하면 값이 필드 및 가상 세터를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="2a225688455376882530e8dba312211d2bcbc470" translate="yes" xml:space="preserve">
          <source>If set, sequelize will map the attribute name to a different name in the database</source>
          <target state="translated">설정되면, sequelize는 속성 이름을 데이터베이스의 다른 이름에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="cc207bb584dc6def0a25ec33cd2870eeed91a21b" translate="yes" xml:space="preserve">
          <source>If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify '/path/to/pg.js' here</source>
          <target state="translated">지정된 경우이 경로에서 방언 라이브러리를로드하십시오. 예를 들어, pg 데이터베이스에 연결할 때 pg 대신 pg.js를 사용하려면 여기에 '/path/to/pg.js'를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5220457eb8ff7b1a3c9c11e68260aadf24c052ae" translate="yes" xml:space="preserve">
          <source>If specified, use this dialect library. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'require(&quot;pg.js&quot;)' here</source>
          <target state="translated">지정된 경우이 언어 라이브러리를 사용하십시오. 예를 들어, pg 데이터베이스에 연결할 때 pg 대신 pg.js를 사용하려면 여기에 'require ( &quot;pg.js&quot;)'를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1dae209bc98d06b2e47281691116b5fbe149490d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;paranoid&lt;/code&gt; options is true, the object will not be deleted, instead the &lt;code&gt;deletedAt&lt;/code&gt; column will be set to the current timestamp. To force the deletion, you can pass &lt;code&gt;force: true&lt;/code&gt; to the destroy call:</source>
          <target state="translated">경우 &lt;code&gt;paranoid&lt;/code&gt; 옵션에 해당하는 객체 대신, 삭제되지 않습니다 &lt;code&gt;deletedAt&lt;/code&gt; 의 열이 현재 타임 스탬프로 설정됩니다. 삭제를 강제 실행하려면 destroy 호출에 &lt;code&gt;force: true&lt;/code&gt; 를 전달하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="89216aed70fb8c41aa23d73029989645c25f0d2e" translate="yes" xml:space="preserve">
          <source>If the hook has been called in the process of a transacted operation, this makes sure that your dependent read/write is a part of that same transaction. If the hook is not transacted, you have simply specified &lt;code&gt;{ transaction: null }&lt;/code&gt; and can expect the default behaviour.</source>
          <target state="translated">트랜잭션 조작 프로세스에서 후크가 호출 된 경우 종속 읽기 / 쓰기가 동일한 트랜잭션의 일부인지 확인합니다. 후크가 처리되지 않은 경우, 간단히 &lt;code&gt;{ transaction: null }&lt;/code&gt; 지정 했으며 기본 동작을 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2755694b8eb30539d0dbf98759fe01c4187fb45f" translate="yes" xml:space="preserve">
          <source>If this column references another table, provide it here as a Model, or a string</source>
          <target state="translated">이 열이 다른 테이블을 참조하는 경우 여기에 모델 또는 문자열로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="1c2890cf339691d4d47faf2398abe6e1b023205e" translate="yes" xml:space="preserve">
          <source>If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes)</source>
          <target state="translated">true 인 경우 사용 된 외래 키에서 고유 키가 생성됩니다 (범위를 사용할 때이 키를 끄고 특정 고유 키를 생성 할 수 있음)</target>
        </trans-unit>
        <trans-unit id="2856a473591152d31ef4a0266e32a8671fc7732b" translate="yes" xml:space="preserve">
          <source>If true, append RETURNING &amp;lt;model columns&amp;gt; to get back all defined values; if an array of column names, append RETURNING &amp;lt;columns&amp;gt; to get back specific columns (Postgres only)</source>
          <target state="translated">true 인 경우 RETURNING &amp;lt;모델 열&amp;gt;을 추가하여 정의 된 모든 값을 가져옵니다. 열 이름 배열 인 경우 RETURNING &amp;lt;columns&amp;gt;를 추가하여 특정 열을 가져옵니다 (Postgres 만 해당)</target>
        </trans-unit>
        <trans-unit id="ac32e94080083f62fd15d534737523a9a47f0b0e" translate="yes" xml:space="preserve">
          <source>If true, combined with autoIncrement=true, will use Postgres &lt;code&gt;GENERATED BY DEFAULT AS IDENTITY&lt;/code&gt; instead of &lt;code&gt;SERIAL&lt;/code&gt;. Postgres 10+ only.</source>
          <target state="translated">true 인 경우 autoIncrement = true와 함께 사용 하면 &lt;code&gt;SERIAL&lt;/code&gt; 대신 Postgres &lt;code&gt;GENERATED BY DEFAULT AS IDENTITY&lt;/code&gt; 를 사용 합니다. Postgres 10 이상 만.</target>
        </trans-unit>
        <trans-unit id="4df84c739c5fec04cd33156cf8d026bf97b1a13f" translate="yes" xml:space="preserve">
          <source>If true, converts to a right join if dialect support it. Ignored if &lt;code&gt;include.required&lt;/code&gt; is true.</source>
          <target state="translated">참이면, 방언이 지원하는 경우 오른쪽 조인으로 변환합니다. &lt;code&gt;include.required&lt;/code&gt; 가 true이면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e0dc1c538227d7485952dc6d28c4c1abd9d5955" translate="yes" xml:space="preserve">
          <source>If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if &lt;code&gt;include.where&lt;/code&gt; is set, false otherwise.</source>
          <target state="translated">true 인 경우 내부 조인으로 변환됩니다. 즉, 상위 모델에 일치하는 하위가있는 경우에만 상위 모델이로드됩니다. &lt;code&gt;include.where&lt;/code&gt; 가 설정되어 있으면 true이고 , 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="81d2e26a6f45fb983320c358ee03e36d4177246b" translate="yes" xml:space="preserve">
          <source>If true, fetches back auto generated values (Postgres only)</source>
          <target state="translated">true 인 경우 자동 생성 된 값을 가져옵니다 (Postgres 만 해당)</target>
        </trans-unit>
        <trans-unit id="9493e0278e049ef4ff4652a3baff31d06e297e09" translate="yes" xml:space="preserve">
          <source>If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if &lt;code&gt;options.paranoid&lt;/code&gt; is true for the model.</source>
          <target state="translated">true 인 경우 삭제되지 않은 레코드 만 반환됩니다. False이면 삭제 된 레코드와 삭제되지 않은 레코드가 모두 반환됩니다. &lt;code&gt;options.paranoid&lt;/code&gt; 가 모델에 해당하는 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ce8f96e01d05bf135e8ac150e4e97d603a39cd8" translate="yes" xml:space="preserve">
          <source>If true, only non-deleted records will be updated. If false, both deleted and non-deleted records will be updated. Only applies if &lt;code&gt;options.paranoid&lt;/code&gt; is true for the model.</source>
          <target state="translated">true 인 경우 삭제되지 않은 레코드 만 업데이트됩니다. False이면 삭제 된 레코드와 삭제되지 않은 레코드가 모두 업데이트됩니다. &lt;code&gt;options.paranoid&lt;/code&gt; 가 모델에 해당하는 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6c3614407ad68627e43871b206c08231a35fcb2" translate="yes" xml:space="preserve">
          <source>If true, runs a separate query to fetch the associated instances, only supported for hasMany associations</source>
          <target state="translated">true 인 경우 별도의 쿼리를 실행하여 관련 인스턴스를 가져 오며 hasMany 연관에 대해서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="647d7c653d76bc8224e8446161299293bf7a8229" translate="yes" xml:space="preserve">
          <source>If true, sequelize will not try to format the results of the query, or build an instance of a model from the result</source>
          <target state="translated">true 인 경우 sequelize는 쿼리 결과의 형식을 지정하거나 결과에서 모델 인스턴스를 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ba0bbc2d0ad37b59e2f4202a1fa65789943978b" translate="yes" xml:space="preserve">
          <source>If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index</source>
          <target state="translated">true 인 경우 열에 고유 제한 조건이 적용됩니다. 문자열이 제공되면 열은 복합 고유 인덱스의 일부가됩니다. 여러 열에 동일한 문자열이 있으면 동일한 고유 인덱스의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="beb79f16ad3fb0f8cdb6f793480ca423b3cb5429" translate="yes" xml:space="preserve">
          <source>If true, the updatedAt timestamp will not be updated.</source>
          <target state="translated">true이면 updatedAt 타임 스탬프가 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d05e957cd328c4b4ff8ea91a8a38cc0b12d2f924" translate="yes" xml:space="preserve">
          <source>If true, this attribute will be marked as primary key</source>
          <target state="translated">true 인 경우이 속성은 기본 키로 표시됩니다</target>
        </trans-unit>
        <trans-unit id="08f9a9c95786ae05c26d607345400a2e23ad1516" translate="yes" xml:space="preserve">
          <source>If true, this column will be set to auto increment</source>
          <target state="translated">true 인 경우이 열은 자동 증분으로 설정됩니다</target>
        </trans-unit>
        <trans-unit id="75c4ea047705366df87e56ce4937449851e86344" translate="yes" xml:space="preserve">
          <source>If true, transforms objects with &lt;code&gt;.&lt;/code&gt; separated property names into nested objects using &lt;a href=&quot;https://github.com/mickhansen/dottie.js&quot;&gt;dottie.js&lt;/a&gt;. For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When &lt;code&gt;nest&lt;/code&gt; is true, the query type is assumed to be &lt;code&gt;'SELECT'&lt;/code&gt;, unless otherwise specified</source>
          <target state="translated">true 인 경우 객체를로 변환합니다 &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;https://github.com/mickhansen/dottie.js&quot;&gt;dottie.js를&lt;/a&gt; 사용하여 속성 이름을 중첩 객체로 분리했습니다 . 예를 들어 { 'user.username': 'john'}은 {user : {username : 'john'}}이됩니다. 때 &lt;code&gt;nest&lt;/code&gt; 사실, 질의 유형으로 가정 &lt;code&gt;'SELECT'&lt;/code&gt; 달리 명시되지 않는 한,</target>
        </trans-unit>
        <trans-unit id="32198f81d975b55d40ec70c7e2308553a94edcba" translate="yes" xml:space="preserve">
          <source>If validation fails, the promise is rejected with an array-like &lt;a href=&quot;http://bluebirdjs.com/docs/api/aggregateerror.html&quot;&gt;AggregateError&lt;/a&gt;</source>
          <target state="translated">유효성 검사가 실패하면 배열과 같은 &lt;a href=&quot;http://bluebirdjs.com/docs/api/aggregateerror.html&quot;&gt;AggregateError로&lt;/a&gt; 약속이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="0186aab835641bad03f7589f88e576215349c709" translate="yes" xml:space="preserve">
          <source>If we had not included the transaction option in our call to &lt;code&gt;User.update&lt;/code&gt; in the preceding code, no change would have occurred, since our newly created user does not exist in the database until the pending transaction has been committed.</source>
          <target state="translated">앞의 코드에서 &lt;code&gt;User.update&lt;/code&gt; 호출에 트랜잭션 옵션을 포함시키지 않은 경우 새로 생성 된 사용자가 보류중인 트랜잭션이 커밋 될 때까지 데이터베이스에 존재하지 않으므로 변경이 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bb6b5c50fe4ab3f465e27baa8bc48b315568f529" translate="yes" xml:space="preserve">
          <source>If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert.&lt;code&gt;bulkCreate()&lt;/code&gt;accepts an options object as the second parameter. The object can have a &lt;code&gt;fields&lt;/code&gt; parameter, (an array) to let it know which fields you want to build explicitly</source>
          <target state="translated">사용자로부터 직접 값을 수락하는 경우 실제로 삽입하려는 열을 제한하는 것이 좋습니다. &lt;code&gt;bulkCreate()&lt;/code&gt; 는 옵션 객체를 두 번째 매개 변수로 사용합니다. 객체에는 &lt;code&gt;fields&lt;/code&gt; 매개 변수 (배열)가있어 명시 적으로 만들려는 필드를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="5ac8d819fedae82d2ebf0ab77182ee9f429b9d81" translate="yes" xml:space="preserve">
          <source>If you are running a type of query where you don't need the metadata, for example a &lt;code&gt;SELECT&lt;/code&gt; query, you can pass in a query type to make sequelize format the results:</source>
          <target state="translated">메타 데이터가 필요하지 않은 쿼리 유형 (예 : &lt;code&gt;SELECT&lt;/code&gt; 쿼리)을 실행중인 경우 쿼리 유형을 전달하여 결과 형식을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6462f72311ba7a8cddf624ea0257e29162d1f7f" translate="yes" xml:space="preserve">
          <source>If you are working with the PostgreSQL TIMESTAMP WITHOUT TIME ZONE and you need to parse it to a different timezone, please use the pg library's own parser:</source>
          <target state="translated">시간대없이 PostgreSQL TIMESTAMP를 사용하여 다른 시간대로 구문 분석해야하는 경우 pg 라이브러리의 자체 구문 분석기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="74ddcd65a25eb03b0ad2ef462e8d2c98a3998a61" translate="yes" xml:space="preserve">
          <source>If you do not want timestamps on your models, only want some timestamps, or you are working with an existing database where the columns are named something else, jump straight on to &lt;a href=&quot;models-definition#configuration&quot;&gt;configuration&lt;/a&gt; to see how to do that.</source>
          <target state="translated">모델에 타임 스탬프를 원하지 않거나 타임 스탬프 만 원하거나 열 이름이 다른 기존 데이터베이스를 사용하는 경우 &lt;a href=&quot;models-definition#configuration&quot;&gt;구성&lt;/a&gt; 으로 바로 이동하여 해당 방법을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f3c5e7d03c6a36a4f0cced22fb56e3a7206de7ed" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;CLS&lt;/a&gt; enabled, the transaction will automatically be passed to any query that runs within the callback</source>
          <target state="translated">당신이 경우 &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;CLS는&lt;/a&gt; 활성화 된 트랜잭션이 자동으로 콜백 내의 모든 쿼리에 그 실행을 전달합니다</target>
        </trans-unit>
        <trans-unit id="89ecba0f6c4969c1946f16a7277505b83b58a142" translate="yes" xml:space="preserve">
          <source>If you have any general settings that apply to all replicas you do not need to provide them for each instance. In the code above, database name and port is propagated to all replicas. The same will happen for user and password, if you leave them out for any of the replicas. Each replica has the following options:&lt;code&gt;host&lt;/code&gt;,&lt;code&gt;port&lt;/code&gt;,&lt;code&gt;username&lt;/code&gt;,&lt;code&gt;password&lt;/code&gt;,&lt;code&gt;database&lt;/code&gt;.</source>
          <target state="translated">모든 복제본에 적용되는 일반 설정이 있으면 각 인스턴스에 해당 설정을 제공 할 필요가 없습니다. 위 코드에서 데이터베이스 이름과 포트는 모든 복제본으로 전파됩니다. 복제본에 대해 사용자 및 비밀번호를 제외하면 동일한 결과가 발생합니다. 각 복제본에는 &lt;code&gt;host&lt;/code&gt; , &lt;code&gt;port&lt;/code&gt; , &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;password&lt;/code&gt; , &lt;code&gt;database&lt;/code&gt; 옵션이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bb5e89572ab05d67a9192d69c8e80c0b0d84ee4" translate="yes" xml:space="preserve">
          <source>If you have soft-deleted an instance of a model with &lt;code&gt;paranoid: true&lt;/code&gt;, and would like to undo the deletion, use the &lt;code&gt;restore&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;paranoid: true&lt;/code&gt; 인 모델의 인스턴스를 일시 삭제하고 삭제를 취소하려면 &lt;code&gt;restore&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="83a275a19fc7524ebcb47eee01b5247c06418a43" translate="yes" xml:space="preserve">
          <source>If you know that a model will always use the same alias in associations, you can provide it when creating the model</source>
          <target state="translated">모델이 항상 같은 별칭을 연결에 사용한다는 것을 알고 있다면 모델을 만들 때 제공 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d0d51269897d4509e5bc63cdb1763b5e6f2abee2" translate="yes" xml:space="preserve">
          <source>If you log an instance you will notice, that there is a lot of additional stuff. In order to hide such stuff and reduce it to the very interesting information, you can use the&lt;code&gt;get&lt;/code&gt;-attribute. Calling it with the option &lt;code&gt;plain&lt;/code&gt; = true will only return the values of an instance.</source>
          <target state="translated">인스턴스를 기록하면 추가 항목이 많이 있음을 알 수 있습니다. 그러한 것들을 숨기고 매우 흥미로운 정보로 줄이기 위해 &lt;code&gt;get&lt;/code&gt; -attribute를 사용할 수 있습니다 . &lt;code&gt;plain&lt;/code&gt; = true 옵션으로 호출 하면 인스턴스의 값만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6b08bb3d2e947f978268c076db082fbb034c017e" translate="yes" xml:space="preserve">
          <source>If you need to get your instance in sync, you can use the method&lt;code&gt;reload&lt;/code&gt;. It will fetch the current data from the database and overwrite the attributes of the model on which the method has been called on.</source>
          <target state="translated">인스턴스를 동기화해야하는 경우 &lt;code&gt;reload&lt;/code&gt; 메소드를 사용할 수 있습니다 . 데이터베이스에서 현재 데이터를 가져 와서 메소드가 호출 된 모델의 속성을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="2916bd0b55b8aca641a06d58426ff56557b254b3" translate="yes" xml:space="preserve">
          <source>If you only need some of the attributes from the join table, you can provide an array with the attributes you want:</source>
          <target state="translated">조인 테이블의 일부 속성 만 필요한 경우 원하는 속성이있는 배열을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa84e598877d14dc3cb73bc586151be45d2ecb1a" translate="yes" xml:space="preserve">
          <source>If you provide an &lt;code&gt;include&lt;/code&gt; option, the number of matching associations will be counted instead.</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; 옵션 을 제공하면 일치하는 연결 수가 대신 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d863b772f59c7c1fea122e1663917c43efb011ee" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; with the &lt;code&gt;updateOnDuplicate&lt;/code&gt; option, changes made in the hook to fields that aren't given in the &lt;code&gt;updateOnDuplicate&lt;/code&gt; array will not be persisted to the database. However it is possible to change the updateOnDuplicate option inside the hook if this is what you want.</source>
          <target state="translated">&lt;code&gt;updateOnDuplicate&lt;/code&gt; 옵션 과 함께 &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; 를 사용 하면 &lt;code&gt;updateOnDuplicate&lt;/code&gt; 배열에 제공되지 않은 필드에 대한 후크 변경 사항 이 데이터베이스에 유지되지 않습니다. 그러나 원하는 경우 후크 내에서 updateOnDuplicate 옵션을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afab7da99be65b4a2073f953b17af81dc02a3ed5" translate="yes" xml:space="preserve">
          <source>If you want Sequelize to automatically create the table (or modify it as needed) according to your model definition, you can use the &lt;code&gt;sync&lt;/code&gt; method, as follows:</source>
          <target state="translated">Sequelize가 모델 정의에 따라 테이블을 자동으로 작성하거나 필요에 따라 수정하도록하려면 다음과 같이 &lt;code&gt;sync&lt;/code&gt; 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f75ef969d5f06d081d766c60d1dd21fc30d0d354" translate="yes" xml:space="preserve">
          <source>If you want additional attributes in your join table, you can define a model for the join table in sequelize, before you define the association, and then tell sequelize that it should use that model for joining, instead of creating a new one:</source>
          <target state="translated">조인 테이블에 추가 속성을 원할 경우 연결을 정의하기 전에 순서에 따라 조인 테이블의 모델을 정의한 다음 새 모델을 만드는 대신 조인에 해당 모델을 사용해야한다고 sequelize에 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cb72ec6577efe47bd8b75930fe054e841bde6bc" translate="yes" xml:space="preserve">
          <source>If you want sequelize to handle timestamps, but only want some of them, or want your timestamps to be called something else, you can override each column individually:</source>
          <target state="translated">sequelize가 타임 스탬프를 처리하고 싶지만 그 중 일부만 원하거나 타임 스탬프를 다른 것으로 호출하려는 경우 각 열을 개별적으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b777ec494ddce543c16902d51c471905b16fa9a5" translate="yes" xml:space="preserve">
          <source>If you want to apply another scope alongside the default scope, pass the key &lt;code&gt;defaultScope&lt;/code&gt; to &lt;code&gt;.scope&lt;/code&gt;:</source>
          <target state="translated">기본 범위와 함께 다른 범위를 적용하려면 &lt;code&gt;defaultScope&lt;/code&gt; 키 를 &lt;code&gt;.scope&lt;/code&gt; 에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e3d2491ffbe91ae6541c30645933c5644c07ab6" translate="yes" xml:space="preserve">
          <source>If you want to create a belongs to many relationship that does not use the default primary key some setup work is required. You must set the &lt;code&gt;sourceKey&lt;/code&gt; (optionally &lt;code&gt;targetKey&lt;/code&gt;) appropriately for the two ends of the belongs to many. Further you must also ensure you have appropriate indexes created on your relationships. For example:</source>
          <target state="translated">기본 기본 키를 사용하지 않는 많은 관계에 속하려면 일부 설정 작업이 필요합니다. 소속의 두 끝에 대해 &lt;code&gt;sourceKey&lt;/code&gt; (선택적으로 &lt;code&gt;targetKey&lt;/code&gt; )를 적절히 설정해야합니다 . 또한 관계에 대해 적절한 색인을 작성했는지 확인해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f61f98f630678b685e1f3828dff3238a64205ed5" translate="yes" xml:space="preserve">
          <source>If you want to create a shortcut method to a scope on an associated model, you can pass the scoped model to the association. Consider a shortcut to get all deleted posts for a user:</source>
          <target state="translated">연관된 모델의 범위에 대한 바로 가기 메소드를 작성하려는 경우 범위가 지정된 모델을 연관에 전달할 수 있습니다. 사용자에 대해 삭제 된 모든 게시물을 가져 오는 바로 가기를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3b08f9c79138d7fcde3ec61eeae485a38887f673" translate="yes" xml:space="preserve">
          <source>If you want to emit hooks for each individual record, along with the bulk hooks you can pass &lt;code&gt;individualHooks: true&lt;/code&gt; to the call.</source>
          <target state="translated">각 개별 레코드에 대해 후크를 생성하고 벌크 후크와 함께 &lt;code&gt;individualHooks: true&lt;/code&gt; 후크를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b540c12693f5dbf831dc4cc9ca6c1eee425fd4d" translate="yes" xml:space="preserve">
          <source>If you want to modify these, you can pass pool as an options when instantiating Sequelize, as shown above.</source>
          <target state="translated">이를 수정하려면 위와 같이 Sequelize를 인스턴스화 할 때 풀을 옵션으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32c8896a0675e31aae1b24c2ac3e8559745e143a" translate="yes" xml:space="preserve">
          <source>If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:</source>
          <target state="translated">여러 대상 인스턴스를 설정하려고하지만 속성이 다른 경우 스루 모델 이름의 속성을 사용하여 인스턴스에서 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ef93ea1c2614431873c694ec0744cd661b60763" translate="yes" xml:space="preserve">
          <source>If you wish to undo a specific seed</source>
          <target state="translated">특정 종자를 취소하려면</target>
        </trans-unit>
        <trans-unit id="af863edfd5d71d3f8a26804bb152ee2c2da87ad3" translate="yes" xml:space="preserve">
          <source>If you wish to undo all seeds</source>
          <target state="translated">모든 씨앗을 취소하려면</target>
        </trans-unit>
        <trans-unit id="c9da777accf0b16f64be8bca9d27fc688c0fd0ba" translate="yes" xml:space="preserve">
          <source>If you wish to undo most recent seed</source>
          <target state="translated">가장 최근의 씨앗을 취소하려면</target>
        </trans-unit>
        <trans-unit id="90e2d3d4a47e5a21011e831e9e97b42a42afde35" translate="yes" xml:space="preserve">
          <source>If you're connecting to the database from a single process, you should create only one Sequelize instance. Sequelize will set up a connection pool on initialization. This connection pool can be configured through the constructor's &lt;code&gt;options&lt;/code&gt; parameter (using &lt;code&gt;options.pool&lt;/code&gt;), as is shown in the following example:</source>
          <target state="translated">단일 프로세스에서 데이터베이스에 연결하는 경우 하나의 Sequelize 인스턴스 만 만들어야합니다. Sequelize는 초기화시 연결 풀을 설정합니다. 이 연결 풀은 다음 예제와 같이 생성자의 &lt;code&gt;options&lt;/code&gt; 매개 변수 ( &lt;code&gt;options.pool&lt;/code&gt; 사용 )를 통해 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6291ffc47760cc842fcd3a2e455f4f99cfb8ed05" translate="yes" xml:space="preserve">
          <source>If you're using SQLite, you should use the following instead:</source>
          <target state="translated">SQLite를 사용하는 경우 다음을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a343e00321955b7beffbdeeb13a0fcb432790e92" translate="yes" xml:space="preserve">
          <source>If your association is of type &lt;code&gt;n:m&lt;/code&gt;, you may be interested in firing hooks on the through model when using the &lt;code&gt;remove&lt;/code&gt; call. Internally, sequelize is using &lt;code&gt;Model.destroy&lt;/code&gt; resulting in calling the &lt;code&gt;bulkDestroy&lt;/code&gt; instead of the &lt;code&gt;before/afterDestroy&lt;/code&gt; hooks on each through instance.</source>
          <target state="translated">연결 유형이 &lt;code&gt;n:m&lt;/code&gt; 인 경우 &lt;code&gt;remove&lt;/code&gt; 호출을 사용할 때 스루 모델의 후크 연결에 관심이있을 수 있습니다 . 내부적 sequelize는 사용 &lt;code&gt;Model.destroy&lt;/code&gt; 를 호출 결과 &lt;code&gt;bulkDestroy&lt;/code&gt; 대신의가 &lt;code&gt;before/afterDestroy&lt;/code&gt; 예를 통해 각 후크.</target>
        </trans-unit>
        <trans-unit id="833407a04cbfb532aa3ab0eb509e48f853b7c95d" translate="yes" xml:space="preserve">
          <source>Ignore duplicate values for primary keys? (not supported by MSSQL or Postgres &amp;lt; 9.5)</source>
          <target state="translated">기본 키의 중복 값을 무시 하시겠습니까? (MSSQL 또는 Postgres &amp;lt;9.5에서는 지원되지 않음)</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="b24a78bf1cbe20b658f9d8b812c79312cafb4997" translate="yes" xml:space="preserve">
          <source>Imported model, returned from cache if was already imported</source>
          <target state="translated">가져온 모델, 이미 가져온 경우 캐시에서 반환</target>
        </trans-unit>
        <trans-unit id="42ef05cf1be558b6ed91a4aeffccb1e4cfc64023" translate="yes" xml:space="preserve">
          <source>Imports a model defined in another file.</source>
          <target state="translated">다른 파일에 정의 된 모델을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4561455fcd06ac6b99fef1b4ec3f086730adf57a" translate="yes" xml:space="preserve">
          <source>Imports a model defined in another file. Imported models are cached, so multiple calls to import with the same path will not load the file multiple times.</source>
          <target state="translated">다른 파일에 정의 된 모델을 가져옵니다. 가져온 모델은 캐시되므로 동일한 경로를 사용하여 여러 번 가져 오면 파일이 여러 번로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc449382c5d7c01bc4ed7505e87c889bf281a9c7" translate="yes" xml:space="preserve">
          <source>In PostGIS, the GeoJSON is parsed using the PostGIS function &lt;code&gt;ST_GeomFromGeoJSON&lt;/code&gt;. In MySQL it is parsed using the function &lt;code&gt;GeomFromText&lt;/code&gt;.</source>
          <target state="translated">PostGIS에서 GeoJSON은 PostGIS 함수 &lt;code&gt;ST_GeomFromGeoJSON&lt;/code&gt; 을 사용하여 구문 분석됩니다 . MySQL에서는 &lt;code&gt;GeomFromText&lt;/code&gt; 함수를 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc15714391598577351e70a8f34d6238fcc77cd0" translate="yes" xml:space="preserve">
          <source>In Sequelize 1:1 relationship can be set using HasOne and BelongsTo. They are suitable for different scenarios. Lets study this difference using an example.</source>
          <target state="translated">Sequelize에서 1 : 1 관계는 HasOne 및 BelongsTo를 사용하여 설정할 수 있습니다. 서로 다른 시나리오에 적합합니다. 예제를 사용하여이 차이점을 연구 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="774bb87b46000c449a45f969a8e44a0806f3930d" translate="yes" xml:space="preserve">
          <source>In addition to the type mentioned above, integer, bigint, float and double also support unsigned and zerofill properties, which can be combined in any order: Be aware that this does not apply for PostgreSQL!</source>
          <target state="translated">위에서 언급 한 유형 외에도 integer, bigint, float 및 double은 부호없는 속성과 zerofill 속성을 지원하며 어떤 순서로든 결합 할 수 있습니다. PostgreSQL에는 적용되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="4af5be18db1ad6a1a653687156ac599be363d197" translate="yes" xml:space="preserve">
          <source>In addition to updating a single instance, you can also create, update, and delete multiple instances at once. The functions you are looking for are called</source>
          <target state="translated">단일 인스턴스를 업데이트하는 것 외에도 여러 인스턴스를 한 번에 생성, 업데이트 및 삭제할 수 있습니다. 찾고있는 기능을 호출</target>
        </trans-unit>
        <trans-unit id="608a03c2fd0a19b5347676b81f1f4afcab08cd8a" translate="yes" xml:space="preserve">
          <source>In all cases the default foreign key can be overwritten with the &lt;code&gt;foreignKey&lt;/code&gt; option. When the foreign key option is used, Sequelize will use it as-is:</source>
          <target state="translated">모든 경우에 기본 외래 키를 &lt;code&gt;foreignKey&lt;/code&gt; 옵션 으로 덮어 쓸 수 있습니다 . 외래 키 옵션을 사용하면 Sequelize는 그대로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="95d034948d56093f4fd3a267db42db031dc3b1e0" translate="yes" xml:space="preserve">
          <source>In case you want to eager load soft deleted records you can do that by setting &lt;code&gt;include.paranoid&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">소프트 삭제 된 레코드를 열망하려는 경우 &lt;code&gt;include.paranoid&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="779cd792541f894ff6ecc7d1a09d6d1d76f26c8a" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;as&lt;/code&gt; has been defined it will be used in place of the target model name.</source>
          <target state="translated">경우 &lt;code&gt;as&lt;/code&gt; 정의되어이 대상 모델 이름 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6e18661df62cf03ad1b8c1dfaac6d64093d6a9e" translate="yes" xml:space="preserve">
          <source>In cases where you don't need to access the metadata you can pass in a query type to tell sequelize how to format the results. For example, for a simple select query you could do:</source>
          <target state="translated">메타 데이터에 액세스 할 필요가없는 경우 쿼리 형식을 전달하여 결과의 ​​형식을 지정하는 방법을 시퀀스에 전달할 수 있습니다. 예를 들어 간단한 선택 쿼리의 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="038d4951b867c417185b9b9bd15b882b51593a33" translate="yes" xml:space="preserve">
          <source>In either case &lt;code&gt;$$&lt;/code&gt; can be used to escape a literal &lt;code&gt;$&lt;/code&gt; sign.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;$$&lt;/code&gt; 를 사용하여 리터럴 &lt;code&gt;$&lt;/code&gt; 기호 를 이스케이프 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb22fea74b5a18e9648dd5f3f86b3ca5f73fef84" translate="yes" xml:space="preserve">
          <source>In last step you have create a seed file. It's still not committed to database. To do that we need to run a simple command.</source>
          <target state="translated">마지막 단계에서 시드 파일을 작성했습니다. 여전히 데이터베이스에 커밋되지 않았습니다. 그렇게하려면 간단한 명령을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="555e8f73359937df389576f9575dd78b1cbb04a0" translate="yes" xml:space="preserve">
          <source>In most case you won't need to access &lt;code&gt;namespace.get('transaction')&lt;/code&gt; directly, since all queries will automatically look for a transaction on the namespace:</source>
          <target state="translated">모든 쿼리는 네임 스페이스에서 자동으로 트랜잭션을 찾기 때문에 대부분의 경우 &lt;code&gt;namespace.get('transaction')&lt;/code&gt; 에 직접 액세스 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0ffa4116223b3446ad2774ab40fc1bea5b948a6e" translate="yes" xml:space="preserve">
          <source>In order to alleviate that, we can pass &lt;code&gt;constraints: false&lt;/code&gt; to one of the associations:</source>
          <target state="translated">이를 완화하기 위해 &lt;code&gt;constraints: false&lt;/code&gt; 중 하나를 연관 중 하나에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc83ae9f1cd3ae67a5a6e4bc972a56286990ab33" translate="yes" xml:space="preserve">
          <source>In order to avoid installation bloat for non TS users, you must install the following typing packages manually:</source>
          <target state="translated">TS 사용자가 아닌 사용자를위한 설치 팽창을 피하려면 다음 유형의 패키지를 수동으로 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6af6a905ac1e115cb3fd844cc79b49b4cf1c9fa" translate="yes" xml:space="preserve">
          <source>In order to calculate the sum over a specific column of a table, you can use the &lt;code&gt;sum&lt;/code&gt; method.</source>
          <target state="translated">테이블의 특정 열에 대한 합계를 계산하기 위해 &lt;code&gt;sum&lt;/code&gt; 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba6b9538578934a76cde7cf0edf5896fb565e928" translate="yes" xml:space="preserve">
          <source>In order to create instances of defined classes just do as follows. You might recognize the syntax if you coded Ruby in the past. Using the &lt;code&gt;build&lt;/code&gt;-method will return an unsaved object, which you explicitly have to save.</source>
          <target state="translated">정의 된 클래스의 인스턴스를 만들려면 다음과 같이하십시오. 과거에 Ruby를 코딩 한 경우 구문을 인식 할 수 있습니다. &lt;code&gt;build&lt;/code&gt; -method를 사용하면 저장되지 않은 객체가 반환되며이를 명시 적으로 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf259232b5059754d2a1edf8525451aaa2799fec" translate="yes" xml:space="preserve">
          <source>In order to decrement values of an instance without running into concurrency issues, you may use &lt;code&gt;decrement&lt;/code&gt;.</source>
          <target state="translated">동시성 문제로 실행하지 않고 인스턴스의 값을 감소하기 위해, 당신은 사용할 수 &lt;code&gt;decrement&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca261ceb2eaf2ec423490304b525cf11f77c0268" translate="yes" xml:space="preserve">
          <source>In order to get Sequelize working nicely together with MySQL, you'll need to install&lt;code&gt;mysql2@^1.5.2&lt;/code&gt;or higher. Once that's done you can use it like this:</source>
          <target state="translated">Sequelize가 MySQL과 잘 작동하게하려면 &lt;code&gt;mysql2@^1.5.2&lt;/code&gt; 이상 을 설치해야합니다 . 완료되면 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d50628c2ff499beb4c82368b3c407f6af0a795fe" translate="yes" xml:space="preserve">
          <source>In order to increment values of an instance without running into concurrency issues, you may use &lt;code&gt;increment&lt;/code&gt;.</source>
          <target state="translated">동시성 문제로 실행하지 않고 인스턴스의 증가 값을 위해, 당신은 사용할 수 &lt;code&gt;increment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="149d9edd63e09e594388c8c59f6205a3c7d42014" translate="yes" xml:space="preserve">
          <source>In production, you might want to consider using Migrations instead of calling &lt;code&gt;sync()&lt;/code&gt; in your code. Learn more in the &lt;a href=&quot;migrations&quot;&gt;Migrations&lt;/a&gt; guide.</source>
          <target state="translated">프로덕션에서는 코드에서 &lt;code&gt;sync()&lt;/code&gt; 를 호출하는 대신 마이그레이션을 사용하는 것이 좋습니다 . &lt;a href=&quot;migrations&quot;&gt;마이그레이션&lt;/a&gt; 가이드 에서 자세히 알아보세요 .</target>
        </trans-unit>
        <trans-unit id="c86642a07888e6db73277af0c0eaac74cefb4e90" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.belongsTo(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProject()&lt;/code&gt;.</source>
          <target state="translated">아래의 API 참조에서 메소드에 연관 이름을 추가하십시오 &lt;code&gt;User.belongsTo(Project)&lt;/code&gt; 예 : User.belongsTo (Project)의 경우 getter는 &lt;code&gt;user.getProject()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cef52cd717c629d67a98f43d7d2a3b36773181e1" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.belongsToMany(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProjects()&lt;/code&gt;.</source>
          <target state="translated">아래의 API 참조에서 메소드에 연관 이름을 추가하십시오 &lt;code&gt;User.belongsToMany(Project)&lt;/code&gt; 예 : User.belongsToMany (Project)의 경우 getter는 &lt;code&gt;user.getProjects()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b69de6ffb712491cc4ee70ce75bcc223197f419" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.hasMany(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProjects()&lt;/code&gt;. If the association is aliased, use the alias instead, e.g. &lt;code&gt;User.hasMany(Project, { as: 'jobs' })&lt;/code&gt; will be &lt;code&gt;user.getJobs()&lt;/code&gt;.</source>
          <target state="translated">아래의 API 참조에서 메소드에 연관 이름을 추가하십시오 &lt;code&gt;User.hasMany(Project)&lt;/code&gt; 예 : User.hasMany (Project)의 경우 getter는 &lt;code&gt;user.getProjects()&lt;/code&gt; 입니다. 연관이 별명 인 경우 별명을 대신 사용하십시오. 예를 들어 &lt;code&gt;User.hasMany(Project, { as: 'jobs' })&lt;/code&gt; 는 &lt;code&gt;user.getJobs()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b19bcc7ba2b18c1f0e8b5d37540fdada124f6fcc" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.hasOne(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProject()&lt;/code&gt;. This is almost the same as &lt;code&gt;belongsTo&lt;/code&gt; with one exception - The foreign key will be defined on the target model.</source>
          <target state="translated">아래 API 참조에서 메소드에 연관 이름을 추가하십시오 &lt;code&gt;User.hasOne(Project)&lt;/code&gt; 예 : User.hasOne (Project)의 경우 getter는 &lt;code&gt;user.getProject()&lt;/code&gt; 입니다. 이것은 거의 동일 &lt;code&gt;belongsTo&lt;/code&gt; 를 한 가지 예외 - 외부 키는 대상 모델에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="02da87402808a84b0a74230cb43a995fdad4b31d" translate="yes" xml:space="preserve">
          <source>In the case of a one-to-many relationship.</source>
          <target state="translated">일대 다 관계의 경우.</target>
        </trans-unit>
        <trans-unit id="5ae509345fb49ae661568fc4744caa7cb1b9656b" translate="yes" xml:space="preserve">
          <source>In the case of many-to-many joins, you are also able to sort by attributes in the through table.</source>
          <target state="translated">다 대다 조인의 경우, 스루 테이블의 속성을 기준으로 정렬 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="317c1f0442c62b94ccf6c9fc8c9140770a26fb3e" translate="yes" xml:space="preserve">
          <source>In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it.</source>
          <target state="translated">위의 예에서 사용자는 자신의 프로필 사진에 속하도록 지정했습니다. 개념적으로는 이치에 맞지 않을 수도 있지만, 외래 키를 사용자 모델에 추가하려고하므로 이것이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ce0b3ed97c0ca3b3cfb4f4a1a06ba62b0ecd8f3c" translate="yes" xml:space="preserve">
          <source>In the examples above, the transaction is still manually passed, by passing &lt;code&gt;{ transaction: t }&lt;/code&gt; as the second argument. To automatically pass the transaction to all queries you must install the &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;cls-hooked&lt;/a&gt; (CLS) module and instantiate a namespace in your own code:</source>
          <target state="translated">위의 예에서 트랜잭션은 두 번째 인수로 &lt;code&gt;{ transaction: t }&lt;/code&gt; 를 전달하여 여전히 수동으로 전달됩니다 . 트랜잭션을 모든 쿼리에 자동으로 전달하려면 &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;cls-hooked&lt;/a&gt; (CLS) 모듈을 설치하고 고유 코드에서 네임 스페이스를 인스턴스화해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a0dce9e1d09c8edbde67374cb81c49870755238" translate="yes" xml:space="preserve">
          <source>In this document we'll explore what finder methods can do:</source>
          <target state="translated">이 문서에서는 파인더 메소드가 수행 할 수있는 작업을 살펴 ​​봅니다.</target>
        </trans-unit>
        <trans-unit id="8ccb67d5f9158b5bfef3f61c07b44ac9e4f30373" translate="yes" xml:space="preserve">
          <source>In this example the name of the postgres range type is &lt;code&gt;newtype_range&lt;/code&gt; and the name of the underlying postgres datatype is &lt;code&gt;pg_new_type&lt;/code&gt;. The key of &lt;code&gt;subtypes&lt;/code&gt; and &lt;code&gt;castTypes&lt;/code&gt; is the key of the Sequelize datatype &lt;code&gt;DataTypes.NEWTYPE.key&lt;/code&gt;, in lower case.</source>
          <target state="translated">이 예제에서 postgres 범위 유형 의 이름 은 &lt;code&gt;newtype_range&lt;/code&gt; 이고 기본 postgres 데이터 유형의 이름은 &lt;code&gt;pg_new_type&lt;/code&gt; 입니다. 키의 &lt;code&gt;subtypes&lt;/code&gt; 과 &lt;code&gt;castTypes&lt;/code&gt; 는 Sequelize 데이터 유형의 핵심 &lt;code&gt;DataTypes.NEWTYPE.key&lt;/code&gt; 소문자.</target>
        </trans-unit>
        <trans-unit id="f06d44df54aba38c2a1a5e52366770a4c55d5686" translate="yes" xml:space="preserve">
          <source>In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, &lt;code&gt;raging_bullock_arms.validate()&lt;/code&gt; might return</source>
          <target state="translated">이 간단한 경우 위도 또는 경도가 제공되지만 둘 다가 아닌 경우 객체의 유효성 검사에 실패합니다. 범위를 벗어난 위도와 경도가없는 건물을 만들려고하면 &lt;code&gt;raging_bullock_arms.validate()&lt;/code&gt; 가 반환 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3851d0f94c7be9ec7c5ead977d92fb894f0d89fb" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn to make a simple setup of Sequelize to learn the basics.</source>
          <target state="translated">이 자습서에서는 기본을 배우기 위해 Sequelize를 간단하게 설정하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="4f5430a6a9d01363455824822c75737cf9c8f435" translate="yes" xml:space="preserve">
          <source>Include all also supports nested loading:</source>
          <target state="translated">모두 포함은 중첩 로딩도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ee22d111d4c8367bcfece43e25265c1b1b970179" translate="yes" xml:space="preserve">
          <source>Include options. See &lt;code&gt;find&lt;/code&gt; for details</source>
          <target state="translated">옵션을 포함하십시오. 자세한 내용은 &lt;code&gt;find&lt;/code&gt; 를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="f4eea4e4d711cc1ecb5cda0e5dbfb9571c247ac3" translate="yes" xml:space="preserve">
          <source>Includes are merged recursively based on the models being included. This is a very powerful merge, added on v5, and is better understood with an example.</source>
          <target state="translated">포함은 포함되는 모델을 기반으로 재귀 적으로 병합됩니다. 이것은 v5에 추가 된 매우 강력한 병합이며 예제를 통해 더 잘 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="027827ecd07b15695c7b030f1a2f763df4b19097" translate="yes" xml:space="preserve">
          <source>Including everything</source>
          <target state="translated">모든 것을 포함하여</target>
        </trans-unit>
        <trans-unit id="c00227cf95dc381c6c30d2e5768223f461bcb57c" translate="yes" xml:space="preserve">
          <source>Including soft deleted records</source>
          <target state="translated">소프트 삭제 된 레코드 포함</target>
        </trans-unit>
        <trans-unit id="54a09acba666b3479a71fa90551496293ff3b39c" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns.</source>
          <target state="translated">하나 이상의 열 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="787e3b938ace632df3c30ed406921fc264679317" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a</source>
          <target state="translated">하나 이상의 열 값을 증가시킵니다. 이는 데이터베이스에서 수행되므로 현재 인스턴스에 저장된 값을 사용하지 않습니다. 증분은</target>
        </trans-unit>
        <trans-unit id="76bdd22b4e3260f69cfe386f60459acba6de3c0d" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a &lt;code&gt;SET column = column + X WHERE foo = 'bar'&lt;/code&gt; query. To get the correct value after an increment into the Instance you should do a reload.</source>
          <target state="translated">하나 이상의 열 값을 증가시킵니다. 이는 데이터베이스에서 수행되므로 현재 인스턴스에 저장된 값을 사용하지 않습니다. 증분은 &lt;code&gt;SET column = column + X WHERE foo = 'bar'&lt;/code&gt; 쿼리를 사용하여 수행됩니다 . 인스턴스로 증가한 후 올바른 값을 얻으려면 다시로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8ff72a665bb30731770e7705fe338083cf89b76" translate="yes" xml:space="preserve">
          <source>Incrementing</source>
          <target state="translated">Incrementing</target>
        </trans-unit>
        <trans-unit id="60049830fb2701db5de1c9bccb71b67fcbb23036" translate="yes" xml:space="preserve">
          <source>Index Hints</source>
          <target state="translated">색인 힌트</target>
        </trans-unit>
        <trans-unit id="15ed187841ecb74c7b628c9d39e663a146a445d1" translate="yes" xml:space="preserve">
          <source>Index hints &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;override the default behavior of the mysql query optimizer&lt;/a&gt;.</source>
          <target state="translated">인덱스 힌트 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;는 mysql 쿼리 옵티마이 저의 기본 동작을 무시합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27bf949a8c6bbf392cd9bbfb0a23ac87298c9ae6" translate="yes" xml:space="preserve">
          <source>Index name</source>
          <target state="translated">색인 이름</target>
        </trans-unit>
        <trans-unit id="2a9a9e601e879f8a25e6b88cecfaa9477d0b69b6" translate="yes" xml:space="preserve">
          <source>Index operator</source>
          <target state="translated">인덱스 연산자</target>
        </trans-unit>
        <trans-unit id="3db988cf9ae171debdcc20214fccade20a6d5743" translate="yes" xml:space="preserve">
          <source>Index type. Only used by mysql. One of &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;FULLTEXT&lt;/code&gt; and &lt;code&gt;SPATIAL&lt;/code&gt;</source>
          <target state="translated">인덱스 타입. mysql에서만 사용됩니다. &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;FULLTEXT&lt;/code&gt; 및 &lt;code&gt;SPATIAL&lt;/code&gt; 중 하나</target>
        </trans-unit>
        <trans-unit id="cbd5e44bf0af97c76997bc5bf5b67484d7bd41fd" translate="yes" xml:space="preserve">
          <source>IndexHints</source>
          <target state="translated">IndexHints</target>
        </trans-unit>
        <trans-unit id="f642ee196088372ea886186c6c617515599afd3f" translate="yes" xml:space="preserve">
          <source>Indexes</source>
          <target state="translated">Indexes</target>
        </trans-unit>
        <trans-unit id="d546d086737ecd71ea685f7ecca5e406efe04475" translate="yes" xml:space="preserve">
          <source>Indirect Subclass:</source>
          <target state="translated">간접 서브 클래스 :</target>
        </trans-unit>
        <trans-unit id="5f86be890f5fca505337bd96fadab61d81d1721f" translate="yes" xml:space="preserve">
          <source>Inherited Summary</source>
          <target state="translated">상속 요약</target>
        </trans-unit>
        <trans-unit id="31f1c8a556d0112856c008a3ad8749f41bf60b3f" translate="yes" xml:space="preserve">
          <source>Initialize a model, representing a table in the DB, with attributes and options.</source>
          <target state="translated">속성 및 옵션을 사용하여 DB의 테이블을 나타내는 모델을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="34082efdebc41766317697316140da8f26c3e107" translate="yes" xml:space="preserve">
          <source>Insert multiple records into a table</source>
          <target state="translated">테이블에 여러 레코드 삽입</target>
        </trans-unit>
        <trans-unit id="7ec8753d3a44c87c9473adfa6c44b60942d04fe3" translate="yes" xml:space="preserve">
          <source>Insert or update a single row.</source>
          <target state="translated">단일 행을 삽입하거나 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="2dd5c9df09dccb9c155c03e0ece1aeed6a35cf5c" translate="yes" xml:space="preserve">
          <source>Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated.</source>
          <target state="translated">단일 행을 삽입하거나 업데이트하십시오. 기본 키 또는 고유 키의 제공된 값과 일치하는 행을 찾으면 업데이트가 실행됩니다. 고유 인덱스는 테이블뿐만 아니라 시퀀싱 모델에서도 정의해야합니다. 그렇지 않으면 sequelize가 업데이트해야 할 행을 식별하지 못하기 때문에 고유 제약 조건 위반이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fcf41de510c5775db6e05c056c7c1d5562270b3" translate="yes" xml:space="preserve">
          <source>Insert several rows and return all columns (Postgres only):</source>
          <target state="translated">여러 행을 삽입하고 모든 열을 반환합니다 (Postgres 만 해당).</target>
        </trans-unit>
        <trans-unit id="82c27a49773b27db4a4892eb51537165bf561a05" translate="yes" xml:space="preserve">
          <source>Insert several rows and return specific columns (Postgres only):</source>
          <target state="translated">여러 행을 삽입하고 특정 열을 반환합니다 (Postgres 만 해당).</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">Installing</target>
        </trans-unit>
        <trans-unit id="738e880dd4e789ec957d300caa68fee228a78956" translate="yes" xml:space="preserve">
          <source>Installing CLI</source>
          <target state="translated">CLI 설치</target>
        </trans-unit>
        <trans-unit id="ccb890bc332682567d34290c45bd65a654e962bd" translate="yes" xml:space="preserve">
          <source>Instance build options</source>
          <target state="translated">인스턴스 빌드 옵션</target>
        </trans-unit>
        <trans-unit id="5ac629af8667053ca02646726c3c988282dc7f26" translate="yes" xml:space="preserve">
          <source>Instance hooks</source>
          <target state="translated">인스턴스 훅</target>
        </trans-unit>
        <trans-unit id="274ad4dd86f2d3421e19dbc845f0539216d205f2" translate="yes" xml:space="preserve">
          <source>InstanceError</source>
          <target state="translated">InstanceError</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="9e8467d590d4be1587eaf02bbcf552bcc1c6e813" translate="yes" xml:space="preserve">
          <source>Instantiate sequelize with name of database, username and password.</source>
          <target state="translated">데이터베이스 이름, 사용자 이름 및 비밀번호로 순서를 인스턴스화하십시오.</target>
        </trans-unit>
        <trans-unit id="b3094ee388cfb121e08aa8acc192a2cdfc0b8210" translate="yes" xml:space="preserve">
          <source>Instead of calling &lt;code&gt;sync()&lt;/code&gt; for every model, you can call &lt;code&gt;sequelize.sync()&lt;/code&gt; which will automatically sync all models.</source>
          <target state="translated">모든 모델 에 대해 &lt;code&gt;sync()&lt;/code&gt; 를 호출하는 대신 &lt;code&gt;sequelize.sync()&lt;/code&gt; 를 호출하면 모든 모델이 자동으로 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="490af473232b6a93643f272bee98388cd223e9fd" translate="yes" xml:space="preserve">
          <source>Internal Transactions</source>
          <target state="translated">내부 거래</target>
        </trans-unit>
        <trans-unit id="3d3960679eb413b74946e3c8863bed548577df5d" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;sequelize.define&lt;/code&gt; calls &lt;code&gt;Model.init&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;sequelize.define&lt;/code&gt; 은 Model.init를 호출 &lt;code&gt;Model.init&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a26b8650a9de522981bcafa08f85067a7ddceb6" translate="yes" xml:space="preserve">
          <source>InvalidConnectionError</source>
          <target state="translated">InvalidConnectionError</target>
        </trans-unit>
        <trans-unit id="9211e9fa56459ab7c08f8f8f8b73301a55b7ccfe" translate="yes" xml:space="preserve">
          <source>Is this a new record</source>
          <target state="translated">이것은 새로운 기록입니까</target>
        </trans-unit>
        <trans-unit id="afe7a6e84bced131db798b6f4a5218b8ba604521" translate="yes" xml:space="preserve">
          <source>Is this binary?</source>
          <target state="translated">이 바이너리입니까?</target>
        </trans-unit>
        <trans-unit id="6930c839f5926a5dbc3973abed70a968ebe27fcd" translate="yes" xml:space="preserve">
          <source>Is this new record</source>
          <target state="translated">이 새로운 기록인가요</target>
        </trans-unit>
        <trans-unit id="ff65e83635da6a16fc4326dabfbf055783a3b67f" translate="yes" xml:space="preserve">
          <source>Is unsigned?</source>
          <target state="translated">서명이 없습니까?</target>
        </trans-unit>
        <trans-unit id="e43b3654cb7e64fdddd41aa99284538c43372f9f" translate="yes" xml:space="preserve">
          <source>Is zero filled?</source>
          <target state="translated">0이 채워져 있습니까?</target>
        </trans-unit>
        <trans-unit id="bc950c72cafdb1b72d875b5f0116396b3dcf31bd" translate="yes" xml:space="preserve">
          <source>Isolation levels</source>
          <target state="translated">격리 수준</target>
        </trans-unit>
        <trans-unit id="ceb55c4968b36fcfbb8bfa38dd67ef748266db4a" translate="yes" xml:space="preserve">
          <source>Isolation levels can be set per-transaction by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; to &lt;code&gt;sequelize.transaction&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options.isolationLevel&lt;/code&gt; 을 &lt;code&gt;sequelize.transaction&lt;/code&gt; 로 전달 하여 트랜잭션별로 격리 레벨을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7de7da7cce1fe9bf748f458bb4ef7c345ecf4b72" translate="yes" xml:space="preserve">
          <source>Isolation levels can be set per-transaction by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; to &lt;code&gt;sequelize.transaction&lt;/code&gt;. Sequelize uses the default isolation level of the database, you can override this by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; in Sequelize constructor options.</source>
          <target state="translated">&lt;code&gt;options.isolationLevel&lt;/code&gt; 을 &lt;code&gt;sequelize.transaction&lt;/code&gt; 로 전달 하여 트랜잭션별로 격리 레벨을 설정할 수 있습니다 . Sequelize는 데이터베이스의 기본 격리 수준을 사용하므로 Sequelize 생성자 옵션에서 &lt;code&gt;options.isolationLevel&lt;/code&gt; 을 전달하여이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c4c047702785b929a273515b1a82e520030e139" translate="yes" xml:space="preserve">
          <source>It is also possible to define which attributes can be set via the create method. This can be especially very handy if you create database entries based on a form which can be filled by a user. Using that would for example allow you to restrict the &lt;code&gt;User&lt;/code&gt; model to set only a username and an address but not an admin flag:</source>
          <target state="translated">create 메소드를 통해 설정할 수있는 속성을 정의 할 수도 있습니다. 사용자가 채울 수있는 양식을 기반으로 데이터베이스 항목을 작성하는 경우 특히 유용합니다. 예를 들어 &lt;code&gt;User&lt;/code&gt; 모델을 사용하여 사용자 이름과 주소 만 설정하고 관리자 플래그는 설정하지 못하도록 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="458150e56a3d316de3d7363070d164f7fb22c292" translate="yes" xml:space="preserve">
          <source>It is also possible to include scoped models in a scope definition. This allows you to avoid duplicating &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt; definitions. Using the above example, and invoking the &lt;code&gt;active&lt;/code&gt; scope on the included User model (rather than specifying the condition directly in that include object):</source>
          <target state="translated">범위 정의에 범위가 지정된 모델을 포함시킬 수도 있습니다. 이것은 당신이 복제는 피할 수 &lt;code&gt;include&lt;/code&gt; , &lt;code&gt;attributes&lt;/code&gt; 또는 &lt;code&gt;where&lt;/code&gt; 정의합니다. 위의 예제를 사용하고 포함 오브젝트에 직접 조건을 지정하지 않고 포함 된 사용자 모델 에서 &lt;code&gt;active&lt;/code&gt; 범위를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ddee74f90f8a0f9498567c187f111536a9989a76" translate="yes" xml:space="preserve">
          <source>It is possible to define 'object-property' getters and setter functions on your models, these can be used both for 'protecting' properties that map to database fields and for defining 'pseudo' properties.</source>
          <target state="translated">모델에서 '객체 속성'게터와 세터 함수를 정의 할 수 있습니다. 데이터베이스 필드에 매핑되는 '보호'속성과 '의사'속성을 정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74a71f5d94391e3a53655bde1f0b03cfbba3c3e0" translate="yes" xml:space="preserve">
          <source>It is very important to recognize that sequelize may make use of transactions internally for certain operations such as &lt;code&gt;Model.findOrCreate&lt;/code&gt;. If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt;.</source>
          <target state="translated">sequelize가 &lt;code&gt;Model.findOrCreate&lt;/code&gt; 와 같은 특정 작업에 내부적으로 트랜잭션을 사용할 수 있다는 것을 인식하는 것이 매우 중요합니다 . 후크 함수가 데이터베이스에서 오브젝트의 존재에 의존하는 읽기 또는 쓰기 조작을 실행하거나 이전 섹션의 예제와 같이 오브젝트의 저장된 값을 수정하는 경우 항상 &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f7799cf6357af0cca9dd406aa99d1e281329530" translate="yes" xml:space="preserve">
          <source>It support includes. Only the includes that are marked as &lt;code&gt;required&lt;/code&gt; will be added to the count part:</source>
          <target state="translated">지원합니다. &lt;code&gt;required&lt;/code&gt; 것으로 표시된 포함 만 카운트 부분에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="01152ec68278f8c0093062867b00c1b97313670b" translate="yes" xml:space="preserve">
          <source>It's also possible to define which attributes should be saved when calling &lt;code&gt;save&lt;/code&gt;, by passing an array of column names. This is useful when you set attributes based on a previously defined object. E.g. if you get the values of an object via a form of a web app. Furthermore this is used internally for &lt;code&gt;update&lt;/code&gt;. This is how it looks like:</source>
          <target state="translated">열 이름 배열을 전달하여 &lt;code&gt;save&lt;/code&gt; 를 호출 할 때 저장해야 할 속성을 정의 할 수도 있습니다 . 이것은 이전에 정의 된 객체를 기반으로 속성을 설정할 때 유용합니다. 예를 들어 웹 앱 형식을 통해 객체의 값을 얻는 경우. 또한 이것은 &lt;code&gt;update&lt;/code&gt; 위해 내부적으로 사용 됩니다 . 이것은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="186c4dfd035ca2147d8122391c159c1157303e72" translate="yes" xml:space="preserve">
          <source>It's also possible to generate complex AND/OR conditions by nesting sets of &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt;&lt;code&gt;Operators&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 및 &lt;code&gt;and&lt;/code&gt; &lt;code&gt;Operators&lt;/code&gt; 세트를 중첩하여 복잡한 AND / OR 조건을 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad75613877702555cf316afa651fd68d8ed8a686" translate="yes" xml:space="preserve">
          <source>It's possible to do complex where queries with multiple levels of nested AND, OR and NOT conditions. In order to do that you can use &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt;&lt;code&gt;Operators&lt;/code&gt;:</source>
          <target state="translated">여러 수준의 중첩 AND, OR 및 NOT 조건을 가진 쿼리를 복잡한 위치에서 수행 할 수 있습니다. 당신이 사용할 수있는 그렇게하기 위해서는 &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; 나 &lt;code&gt;not&lt;/code&gt; &lt;code&gt;Operators&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="33734b6b70c0dff634a36534b531693609e70498" translate="yes" xml:space="preserve">
          <source>Its only supported with PostgreSQL.</source>
          <target state="translated">PostgreSQL에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="6a54171212861b9d4356ac5edc1e9c7b38716888" translate="yes" xml:space="preserve">
          <source>JSONB</source>
          <target state="translated">JSONB</target>
        </trans-unit>
        <trans-unit id="8f235f39a2853ef490db9713b7ebbf2012bdcd6a" translate="yes" xml:space="preserve">
          <source>JSONB can be queried in three different ways.</source>
          <target state="translated">JSONB는 세 가지 방법으로 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6b46dddcae84eab844147b41df08409aa05a20dc" translate="yes" xml:space="preserve">
          <source>JSONTYPE</source>
          <target state="translated">JSONTYPE</target>
        </trans-unit>
        <trans-unit id="b7bddeac6e43c3fc69422d0e6157627a2408995d" translate="yes" xml:space="preserve">
          <source>Just like you use Git / SVN to manage changes in your source code, you can use migrations to keep track of changes to the database. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe how to get to the new state and how to revert the changes in order to get back to the old state.</source>
          <target state="translated">Git / SVN을 사용하여 소스 코드의 변경 사항을 관리하는 것처럼 마이그레이션을 사용하여 데이터베이스의 변경 사항을 추적 할 수 있습니다. 마이그레이션을 사용하면 기존 데이터베이스를 다른 상태로 또는 그 반대로 전송할 수 있습니다. 이러한 상태 전환은 마이그레이션 파일에 저장됩니다. 마이그레이션 파일은 새 상태로 이동하는 방법과 이전 상태로 돌아 가기 위해 변경 사항을 되 돌리는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7a005acb56700e9225239e9495e645f1d56cb1fd" translate="yes" xml:space="preserve">
          <source>KEY_SHARE</source>
          <target state="translated">KEY_SHARE</target>
        </trans-unit>
        <trans-unit id="1aad7db5cd6d6405bc949aa858fe80dadf3e960b" translate="yes" xml:space="preserve">
          <source>Keep in mind, the provided range value can &lt;a href=&quot;data-types#range-types&quot;&gt;define the bound inclusion/exclusion&lt;/a&gt; as well.</source>
          <target state="translated">제공된 범위 값은 &lt;a href=&quot;data-types#range-types&quot;&gt;바운드 포함 / 제외&lt;/a&gt; 도 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a251ad95f6b7bd7655523b67ea7799fe5cf895ed" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;API Reference for the Sequelize constructor&lt;/a&gt;. If you're connecting to the database from multiple processes, you'll have to create one instance per process, but each instance should have a maximum connection pool size of such that the total maximum size is respected. For example, if you want a max connection pool size of 90 and you have three processes, the Sequelize instance of each process should have a max connection pool size of 30.</source>
          <target state="translated">&lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;Sequelize 생성자 용 API 참조 서&lt;/a&gt; 에서 자세히 알아보십시오 . 여러 프로세스에서 데이터베이스에 연결하는 경우 프로세스 당 하나의 인스턴스를 작성해야하지만 각 인스턴스의 최대 연결 풀 크기는 총 최대 크기를 준수해야합니다. 예를 들어 최대 연결 풀 크기가 90이고 세 개의 프로세스가있는 경우 각 프로세스의 Sequelize 인스턴스의 최대 연결 풀 크기는 30이어야합니다.</target>
        </trans-unit>
        <trans-unit id="485d34bd5489f8e0226bedab13b81d0bca93aff5" translate="yes" xml:space="preserve">
          <source>Let's assume we have an empty database with a &lt;code&gt;User&lt;/code&gt; model which has a &lt;code&gt;username&lt;/code&gt; and a &lt;code&gt;job&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;username&lt;/code&gt; 과 &lt;code&gt;job&lt;/code&gt; 을 가진 &lt;code&gt;User&lt;/code&gt; 모델을 가진 빈 데이터베이스가 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="a2203a28193ce384212442ecbf1bb9f0fad5d8a3" translate="yes" xml:space="preserve">
          <source>Let's create a model named &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;User&lt;/code&gt; 라는 모델을 만들어 봅시다 .</target>
        </trans-unit>
        <trans-unit id="f35d6d8183466326bcc0a6d0a3f462695c8d381b" translate="yes" xml:space="preserve">
          <source>Let's create a seed file which will add a demo user to our &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">&lt;code&gt;User&lt;/code&gt; 테이블에 데모 사용자를 추가 할 seed 파일을 만들어 봅시다 .</target>
        </trans-unit>
        <trans-unit id="be20a5757d775035047e08bf42879daa6e2f59aa" translate="yes" xml:space="preserve">
          <source>Let's first begin with a basic concept that you will see used in most associations, &lt;strong&gt;source&lt;/strong&gt; and &lt;strong&gt;target&lt;/strong&gt; model. Suppose you are trying to add an association between two Models. Here we are adding a &lt;code&gt;hasOne&lt;/code&gt; association between &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Project&lt;/code&gt;.</source>
          <target state="translated">먼저 대부분의 연관, &lt;strong&gt;소스&lt;/strong&gt; 및 &lt;strong&gt;대상&lt;/strong&gt; 모델 에서 사용되는 기본 개념으로 시작하겠습니다 . 두 모델 사이에 연관을 추가하려고한다고 가정하십시오. 여기서 &lt;code&gt;User&lt;/code&gt; 와 &lt;code&gt;Project&lt;/code&gt; 사이에 &lt;code&gt;hasOne&lt;/code&gt; 연관을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="1c450eed0e9c2a25ffab9271fad2fadc6b27a9d2" translate="yes" xml:space="preserve">
          <source>Let's introduce the ability to associate a product with many tags. Setting up the models could look like:</source>
          <target state="translated">제품을 여러 태그와 연결하는 기능을 소개하겠습니다. 모델 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87aac229dd1d4995475dbcc51641de5b2c4552f0" translate="yes" xml:space="preserve">
          <source>Let's modify last example to use &lt;code&gt;underscored&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;underscored&lt;/code&gt; 옵션 을 사용하도록 마지막 예를 수정하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5a82db14e28117aaba1b3a12ce0a9553639d87b7" translate="yes" xml:space="preserve">
          <source>Let's say the name of the new datatype is &lt;code&gt;pg_new_type&lt;/code&gt; in the postgres database. That name has to be mapped to &lt;code&gt;DataTypes.NEWTYPE&lt;/code&gt;. Additionally, it is required to create a child postgres-specific datatype.</source>
          <target state="translated">postgres 데이터베이스에서 새 데이터 유형의 이름이 &lt;code&gt;pg_new_type&lt;/code&gt; 이라고 가정 해 봅시다 . 이 이름은 &lt;code&gt;DataTypes.NEWTYPE&lt;/code&gt; 에 매핑되어야 합니다. 또한 하위 postgres 관련 데이터 유형을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="46dbb18d37841e79a9d96e647e55be1608250c26" translate="yes" xml:space="preserve">
          <source>Let's start with installing CLI, you can find instructions &lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;here&lt;/a&gt;. Most preferred way is installing locally like this</source>
          <target state="translated">CLI 설치부터 시작하겠습니다 . &lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;여기에서&lt;/a&gt; 지침을 찾을 수 있습니다 . 가장 선호되는 방법은 다음과 같이 로컬로 설치하는 것입니다</target>
        </trans-unit>
        <trans-unit id="3dc80430a2ae5ef7084165f4e5c699da1d9acc78" translate="yes" xml:space="preserve">
          <source>Library for MariaDB is &lt;code&gt;mariadb&lt;/code&gt;.</source>
          <target state="translated">MariaDB 용 라이브러리는 &lt;code&gt;mariadb&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="c0f639fe70cb19d3a7d5bb33f35f4fcb35b0d6fb" translate="yes" xml:space="preserve">
          <source>Limit for result</source>
          <target state="translated">결과 한도</target>
        </trans-unit>
        <trans-unit id="1aeadbc7b1706711e989275655be9254c82690d6" translate="yes" xml:space="preserve">
          <source>Limit the joined rows, only supported with include.separate=true</source>
          <target state="translated">include.separate = true로만 지원되는 결합 된 행을 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="c6fd3870c86e7422a0146e1e2a052437fb8e51e2" translate="yes" xml:space="preserve">
          <source>Lines</source>
          <target state="translated">Lines</target>
        </trans-unit>
        <trans-unit id="9dab3b0aa2150bf658272546827c1ef560b7cbe7" translate="yes" xml:space="preserve">
          <source>List of attributes to add index on</source>
          <target state="translated">인덱스를 추가 할 속성 목록</target>
        </trans-unit>
        <trans-unit id="3ce91f8ce5685aa3c7ae6bebf7959c99739d2884" translate="yes" xml:space="preserve">
          <source>List of declared variables. Each variable should be an object with string fields &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;, and optionally having a &lt;code&gt;default&lt;/code&gt; field as well.</source>
          <target state="translated">선언 된 변수 목록 각 변수는 문자열 필드 &lt;code&gt;type&lt;/code&gt; 과 &lt;code&gt;name&lt;/code&gt; 을 갖는 객체 여야하며 선택적으로 &lt;code&gt;default&lt;/code&gt; 필드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="075dd91e787bf6243a7752780ea0c8bba33ec184" translate="yes" xml:space="preserve">
          <source>List of objects (key/value pairs) to create instances from</source>
          <target state="translated">인스턴스를 생성 할 객체 목록 (키 / 값 쌍)</target>
        </trans-unit>
        <trans-unit id="efd6defff3588a82427cedf6cb66687edafa5f0a" translate="yes" xml:space="preserve">
          <source>List of parameters declared for SQL function</source>
          <target state="translated">SQL 함수에 선언 된 매개 변수 목록</target>
        </trans-unit>
        <trans-unit id="a01e2b9e9c9931427b664651a40032e3447516ac" translate="yes" xml:space="preserve">
          <source>List of records to insert</source>
          <target state="translated">삽입 할 레코드 목록</target>
        </trans-unit>
        <trans-unit id="756dc1b93051a84503f4ee0647cfc663c3af6b9d" translate="yes" xml:space="preserve">
          <source>List of table to skip</source>
          <target state="translated">건너 뛸 테이블 목록</target>
        </trans-unit>
        <trans-unit id="a516eb0d586f3d22305a538c09c709ee6782c824" translate="yes" xml:space="preserve">
          <source>Load further nested related models</source>
          <target state="translated">더 중첩 된 관련 모델로드</target>
        </trans-unit>
        <trans-unit id="3c9c5fc6308d5bcf9e048b826209d636266946b5" translate="yes" xml:space="preserve">
          <source>Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins. See &lt;a href=&quot;../../transaction#lock&quot;&gt;transaction.LOCK for an example&lt;/a&gt;</source>
          <target state="translated">선택한 행을 잠급니다. 가능한 옵션은 transaction.LOCK.UPDATE 및 transaction.LOCK.SHARE입니다. Postgres는 transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE 및 조인이있는 특정 모델 잠금도 지원합니다. &lt;a href=&quot;../../transaction#lock&quot;&gt;예제는 transaction.LOCK을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="01175ae5bc13842f1a68f275d49e45971292d2c1" translate="yes" xml:space="preserve">
          <source>Locks</source>
          <target state="translated">Locks</target>
        </trans-unit>
        <trans-unit id="381f51fe7d2e48a40efecb0f6ec5b0e10560328f" translate="yes" xml:space="preserve">
          <source>MACADDR</source>
          <target state="translated">MACADDR</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="5e10df029a02645d6284a04ec967bdb813352d80" translate="yes" xml:space="preserve">
          <source>MSSQL</source>
          <target state="translated">MSSQL</target>
        </trans-unit>
        <trans-unit id="d338a8206f4d51fb083279011e9504adb9b8bc21" translate="yes" xml:space="preserve">
          <source>MSSQL - Implemented as a single query using &lt;code&gt;MERGE&lt;/code&gt; and &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt;&lt;strong&gt;Note&lt;/strong&gt; that SQLite returns undefined for created, no matter if the row was created or updated. This is because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know whether the row was inserted or not.</source>
          <target state="translated">MSSQL는 - 사용하여 단일 쿼리로 구현 &lt;code&gt;MERGE&lt;/code&gt; 하고 &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt; &lt;strong&gt;참고&lt;/strong&gt; 행을 만들거나 업데이트 할 경우 생성에 상관없이 대한 정의되지 않은 그 SQLite는 돌아갑니다. SQLite는 항상 단일 쿼리에서 INSERT OR IGNORE + UPDATE를 실행하기 때문에 행이 삽입되었는지 여부를 알 수있는 방법이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="991df59282ae7659f4a3c3ddbd655d8dab601328" translate="yes" xml:space="preserve">
          <source>MSSQL does not have a JSON data type, however it does provide support for JSON stored as strings through certain functions since SQL Server 2016. Using these functions, you will be able to query the JSON stored in the string, but any returned values will need to be parsed seperately.</source>
          <target state="translated">MSSQL에는 JSON 데이터 형식이 없지만 SQL Server 2016 이후 특정 함수를 통해 문자열로 저장된 JSON을 지원합니다.이 함수를 사용하면 문자열에 저장된 JSON을 쿼리 할 수 ​​있지만 반환 된 값은 모두 필요합니다. 별도로 구문 분석해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2b1fa2c3a6d1e1afc6275611ca02b5fdffb139c" translate="yes" xml:space="preserve">
          <source>Managed transaction (auto-callback)</source>
          <target state="translated">관리 트랜잭션 (자동 콜백)</target>
        </trans-unit>
        <trans-unit id="8ea330d8bd2304f1ff715165a6ab5db327917663" translate="yes" xml:space="preserve">
          <source>Managed transactions handle committing or rolling back the transaction automatically. You start a managed transaction by passing a callback to &lt;code&gt;sequelize.transaction&lt;/code&gt;.</source>
          <target state="translated">관리 트랜잭션은 트랜잭션 커밋 또는 롤백을 자동으로 처리합니다. &lt;code&gt;sequelize.transaction&lt;/code&gt; 에 콜백을 전달하여 관리 트랜잭션을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="0cc59cf8eacc13611e26eb5e7be4726fc40e2011" translate="yes" xml:space="preserve">
          <source>Manipulating the dataset with limit, offset, order and group</source>
          <target state="translated">한계, 오프셋, 순서 및 그룹으로 데이터 세트 조작</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="377bf4b05aa29004e36d9244e2d88732601654cd" translate="yes" xml:space="preserve">
          <source>Many-to-many association with a join table.</source>
          <target state="translated">조인 테이블과 다 대다 연결.</target>
        </trans-unit>
        <trans-unit id="a2c278e4b750406933592c346d173c2e67747cad" translate="yes" xml:space="preserve">
          <source>Map returned fields to arbitrary names for &lt;code&gt;SELECT&lt;/code&gt; query type.</source>
          <target state="translated">리턴 된 필드를 &lt;code&gt;SELECT&lt;/code&gt; 조회 유형의 임의의 이름으로 맵핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="be596405e95a78e6e3fd716d1f964da33dac24e3" translate="yes" xml:space="preserve">
          <source>Map returned fields to model's fields if &lt;code&gt;options.model&lt;/code&gt; or &lt;code&gt;options.instance&lt;/code&gt; is present. Mapping will occur before building the model instance.</source>
          <target state="translated">&lt;code&gt;options.model&lt;/code&gt; 또는 &lt;code&gt;options.instance&lt;/code&gt; 가있는 경우 반환 된 필드를 모델의 필드에 매핑합니다 . 모델 인스턴스를 작성하기 전에 매핑이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7f00002bb6ad2eec19a19de8a03c7d6fad15adff" translate="yes" xml:space="preserve">
          <source>MariaDB</source>
          <target state="translated">MariaDB</target>
        </trans-unit>
        <trans-unit id="8f7e6ef50178ceaac3c27a6e48b1989cccb85ff6" translate="yes" xml:space="preserve">
          <source>Mark the include as duplicating, will prevent a subquery from being used.</source>
          <target state="translated">포함을 중복으로 표시하면 하위 쿼리가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1da7a96c09b4e4634e58cd74016bd7905cd29f3a" translate="yes" xml:space="preserve">
          <source>Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code</source>
          <target state="translated">동기화하기 전에 데이터베이스 이름과 정규식을 일치 시키십시오 (강제 : true는 테스트에 사용되지만 라이브 코드는 사용되지 않는 경우에 대한 안전 점검).</target>
        </trans-unit>
        <trans-unit id="47f4c6f36bdf82bb2ab12a74bce5359bd3e3baea" translate="yes" xml:space="preserve">
          <source>Maximum number of connection in pool</source>
          <target state="translated">풀의 최대 연결 수</target>
        </trans-unit>
        <trans-unit id="97738b59f60343e4146991bad8d071fcf74e0ab8" translate="yes" xml:space="preserve">
          <source>Member Summary</source>
          <target state="translated">회원 요약</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="5646c6f729482a25c89d910db627247645097c06" translate="yes" xml:space="preserve">
          <source>Merging includes</source>
          <target state="translated">병합 포함</target>
        </trans-unit>
        <trans-unit id="8102ea6074090f4681ab70e02ebe6ece740ec91c" translate="yes" xml:space="preserve">
          <source>Method Summary</source>
          <target state="translated">방법 요약</target>
        </trans-unit>
        <trans-unit id="7ee71f3365c47f24bea17f31665feff788530ffb" translate="yes" xml:space="preserve">
          <source>Migration Skeleton</source>
          <target state="translated">마이그레이션 스켈레톤</target>
        </trans-unit>
        <trans-unit id="c32d7ce630147bbc439f44b57c3dd404394c0d9b" translate="yes" xml:space="preserve">
          <source>Migration Storage</source>
          <target state="translated">마이그레이션 스토리지</target>
        </trans-unit>
        <trans-unit id="dca984afd74a0089c1d5a5816e4de2e8d46a60b5" translate="yes" xml:space="preserve">
          <source>Migrations</source>
          <target state="translated">Migrations</target>
        </trans-unit>
        <trans-unit id="fdaa1ef022ef7283a9b451dc1daff1a42f1e129d" translate="yes" xml:space="preserve">
          <source>Minimum number of connection in pool</source>
          <target state="translated">풀의 최소 연결 수</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="68c2cc7f0ceaa3e499ecb4db331feb4debbbcc23" translate="yes" xml:space="preserve">
          <source>Model</source>
          <target state="translated">Model</target>
        </trans-unit>
        <trans-unit id="4142158426158729ca79c5ce805fd286f210430c" translate="yes" xml:space="preserve">
          <source>Model definition</source>
          <target state="translated">모델 정의</target>
        </trans-unit>
        <trans-unit id="d5b42cbdc48b29ec85aa8da6533d3aa5c7e63a91" translate="yes" xml:space="preserve">
          <source>Model hooks</source>
          <target state="translated">모델 고리</target>
        </trans-unit>
        <trans-unit id="0a75c07ee5b0146bfd4157f900acbbac80d86138" translate="yes" xml:space="preserve">
          <source>Model instances operate with the concept of a &lt;code&gt;dataValues&lt;/code&gt; property, which stores the actual values represented by the instance. By default, the values from dataValues can also be accessed directly from the Instance, that is:</source>
          <target state="translated">모델 인스턴스는 인스턴스가 나타내는 실제 값을 저장 하는 &lt;code&gt;dataValues&lt;/code&gt; 속성 의 개념으로 작동 합니다. 기본적으로 dataValues의 값은 인스턴스에서 직접 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b86c2670dd4b42d8a914c0eec8b73c34afe4cef4" translate="yes" xml:space="preserve">
          <source>Model to upsert on</source>
          <target state="translated">upsert 할 모델</target>
        </trans-unit>
        <trans-unit id="a07e44c48da57fac1360b4b859e20027ab13a678" translate="yes" xml:space="preserve">
          <source>Model usage</source>
          <target state="translated">모델 사용법</target>
        </trans-unit>
        <trans-unit id="a53b41efe74bb25e6882a6eee3070bdffdb51b7f" translate="yes" xml:space="preserve">
          <source>Model validations allow you to specify format/content/inheritance validations for each attribute of the model.</source>
          <target state="translated">모델 검증을 통해 모델의 각 속성에 대한 형식 / 콘텐츠 / 상속 검증을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ce518813b59ff7892d35ddffbbfb5e60400474" translate="yes" xml:space="preserve">
          <source>Model validator methods are called with the model object's context and are deemed to fail if they throw an error, otherwise pass. This is just the same as with custom field-specific validators.</source>
          <target state="translated">모델 유효성 검사기 메서드는 모델 개체의 컨텍스트와 함께 호출되며 오류가 발생하면 실패한 것으로 간주하고 그렇지 않으면 전달합니다. 이것은 사용자 정의 필드 별 유효성 검사기와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a823acb606efcdb0eb853730193b3ca0d95a9686" translate="yes" xml:space="preserve">
          <source>Model#create for a full explanation of options</source>
          <target state="translated">옵션에 대한 자세한 설명은 Model # create를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8af76ef4fdb319b9698a20f8340797dab906080c" translate="yes" xml:space="preserve">
          <source>Model#get</source>
          <target state="translated">Model#get</target>
        </trans-unit>
        <trans-unit id="3cb30668d05a4e893eb0a96404decd8e56821285" translate="yes" xml:space="preserve">
          <source>Model#reload</source>
          <target state="translated">Model#reload</target>
        </trans-unit>
        <trans-unit id="4f584a3efe16470d969227bf5c8fd863f8da7ead" translate="yes" xml:space="preserve">
          <source>Model#save</source>
          <target state="translated">Model#save</target>
        </trans-unit>
        <trans-unit id="4d5283314738ecf76503ebc98257bde975737cb3" translate="yes" xml:space="preserve">
          <source>Model#set</source>
          <target state="translated">Model#set</target>
        </trans-unit>
        <trans-unit id="7fcf673bb86044c610823a0d2fc30026edfb6398" translate="yes" xml:space="preserve">
          <source>Model#where</source>
          <target state="translated">Model#where</target>
        </trans-unit>
        <trans-unit id="9e763be04a0228a99af47fdea7072bbd2305daba" translate="yes" xml:space="preserve">
          <source>Model-wide validations</source>
          <target state="translated">모델 전체 검증</target>
        </trans-unit>
        <trans-unit id="8253b756d3ad33e6e7017ccdafc1a90fc90f96c7" translate="yes" xml:space="preserve">
          <source>Model.belongsTo</source>
          <target state="translated">Model.belongsTo</target>
        </trans-unit>
        <trans-unit id="454a1355d18fe035a3d709bc71b45145b8aa70a6" translate="yes" xml:space="preserve">
          <source>Model.belongsToMany</source>
          <target state="translated">Model.belongsToMany</target>
        </trans-unit>
        <trans-unit id="338a4bdb9701251c42339f0107d0cab2dfc70bd6" translate="yes" xml:space="preserve">
          <source>Model.build</source>
          <target state="translated">Model.build</target>
        </trans-unit>
        <trans-unit id="e1b94c3211965ce0df3e43428bf03ab75c9411f6" translate="yes" xml:space="preserve">
          <source>Model.findAll</source>
          <target state="translated">Model.findAll</target>
        </trans-unit>
        <trans-unit id="e1b2d659c60c1fcfe515ae54f50c22008b1758d0" translate="yes" xml:space="preserve">
          <source>Model.hasMany</source>
          <target state="translated">Model.hasMany</target>
        </trans-unit>
        <trans-unit id="4c16d25a9fc250497c7ca38d6f46e1f59a466e24" translate="yes" xml:space="preserve">
          <source>Model.hasOne</source>
          <target state="translated">Model.hasOne</target>
        </trans-unit>
        <trans-unit id="fae0e3c371dd4093bef01bf73725ab76001c9cc8" translate="yes" xml:space="preserve">
          <source>Model.increment</source>
          <target state="translated">Model.increment</target>
        </trans-unit>
        <trans-unit id="098dd694d5c2ce27262982062cf5e8f57cabde98" translate="yes" xml:space="preserve">
          <source>Model.save</source>
          <target state="translated">Model.save</target>
        </trans-unit>
        <trans-unit id="fefb16c53c032c568ad0842061992d2b085291e3" translate="yes" xml:space="preserve">
          <source>Model.schema</source>
          <target state="translated">Model.schema</target>
        </trans-unit>
        <trans-unit id="c9a517d625d0bd2320f055ed68c71f3399c8a1e1" translate="yes" xml:space="preserve">
          <source>Modeling a table</source>
          <target state="translated">테이블 모델링</target>
        </trans-unit>
        <trans-unit id="b8ac15e7b4962a2e2baf204f84d2215049c4ac38" translate="yes" xml:space="preserve">
          <source>Models are stored here under the name given to &lt;code&gt;sequelize.define&lt;/code&gt;</source>
          <target state="translated">모델은 &lt;code&gt;sequelize.define&lt;/code&gt; 에 지정된 이름으로 여기에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="cc9169ab2687ee0ff11fb74d9665fc408f0ddcdc" translate="yes" xml:space="preserve">
          <source>More examples, &lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html&quot;&gt;Model Definition&lt;/a&gt;</source>
          <target state="translated">더 많은 예제, &lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html&quot;&gt;모델 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7e49c63d7a388fe61b0e185917e856c5555045a" translate="yes" xml:space="preserve">
          <source>More scopes, defined in the same way as defaultScope above. See &lt;code&gt;Model.scope&lt;/code&gt; for more information about how scopes are defined, and what you can do with them</source>
          <target state="translated">위의 defaultScope와 동일한 방식으로 정의 된 추가 범위 범위 정의 방법 및 범위로 수행 할 수있는 작업에 대한 자세한 내용은 &lt;code&gt;Model.scope&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06e96031e3182ce6001f4ff143c003c41585330f" translate="yes" xml:space="preserve">
          <source>Most likely the type you are trying to implement is already included in &lt;a href=&quot;data-types&quot;&gt;DataTypes&lt;/a&gt;. If a new datatype is not included, this manual will show how to write it yourself.</source>
          <target state="translated">구현하려는 유형이 &lt;a href=&quot;data-types&quot;&gt;DataTypes에&lt;/a&gt; 이미 포함되어있을 가능성이 높습니다 . 새 데이터 유형이 포함되지 않은 경우이 매뉴얼은 직접 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="d9d495ec80ad0df93c05d8abe97089135bb60400" translate="yes" xml:space="preserve">
          <source>MySQL - Implemented as a single query &lt;code&gt;INSERT values ON DUPLICATE KEY UPDATE values&lt;/code&gt;</source>
          <target state="translated">MySQL-단일 쿼리로 구현 &lt;code&gt;INSERT values ON DUPLICATE KEY UPDATE values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd408e0f9d0af499eda4bb5b3feec4a587a895de" translate="yes" xml:space="preserve">
          <source>NOEXPAND</source>
          <target state="translated">NOEXPAND</target>
        </trans-unit>
        <trans-unit id="75b8d58ed5ac16a53fb00f7e374f5a6e16d7f254" translate="yes" xml:space="preserve">
          <source>NOLOCK</source>
          <target state="translated">NOLOCK</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="9841c4209305816a8e9adbf24362646952f05b27" translate="yes" xml:space="preserve">
          <source>NOW</source>
          <target state="translated">NOW</target>
        </trans-unit>
        <trans-unit id="a2af9a6115134a71b0d62f68e143c19efff1f954" translate="yes" xml:space="preserve">
          <source>NOWAIT</source>
          <target state="translated">NOWAIT</target>
        </trans-unit>
        <trans-unit id="b26f87d0c59f90fdc5143250b4f83e7b4def44dc" translate="yes" xml:space="preserve">
          <source>NO_KEY_UPDATE</source>
          <target state="translated">NO_KEY_UPDATE</target>
        </trans-unit>
        <trans-unit id="6c2496a022b02739f43ed430676315b0c3b34a08" translate="yes" xml:space="preserve">
          <source>NUMBER</source>
          <target state="translated">NUMBER</target>
        </trans-unit>
        <trans-unit id="42ead8566c2a2f546d0123a49496ab3f43750da0" translate="yes" xml:space="preserve">
          <source>NUMBER#constructor</source>
          <target state="translated">NUMBER#constructor</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="ed585ba39b11c2180b849eb53de424e3c71e081f" translate="yes" xml:space="preserve">
          <source>Name of SQL function to create</source>
          <target state="translated">작성할 SQL 함수의 이름</target>
        </trans-unit>
        <trans-unit id="ec874e4030f9772c022ffc4fd75b709664407142" translate="yes" xml:space="preserve">
          <source>Name of SQL function to drop</source>
          <target state="translated">제거 할 SQL 함수의 이름</target>
        </trans-unit>
        <trans-unit id="1dc36a90ec6c0522dcf70c1022a4f52a8ebd611e" translate="yes" xml:space="preserve">
          <source>Name of table to create</source>
          <target state="translated">작성할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="b1fb57d5dc0386d03765076aea0e86c354422228" translate="yes" xml:space="preserve">
          <source>Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table &amp;amp; column names</source>
          <target state="translated">구속 조건의 이름. 지정하지 않으면 sequelize는 제약 조건 유형, 테이블 및 열 이름을 기반으로 명명 된 제약 조건을 자동으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4f9d1ae98e9da4b2bbe6a3af8fc9c757c82ce573" translate="yes" xml:space="preserve">
          <source>Name of the index. Default is &amp;lt;table&amp;gt;&lt;em&gt;&amp;lt;attr1&amp;gt;&lt;/em&gt;&amp;lt;attr2&amp;gt;</source>
          <target state="translated">색인의 이름입니다. 기본값은 &amp;lt;table&amp;gt; &lt;em&gt;&amp;lt;attr1&amp;gt;&lt;/em&gt; &amp;lt;attr2&amp;gt;입니다.</target>
        </trans-unit>
        <trans-unit id="2caed30fdd66bcf9c63c21b3cf8cfd9c614e4500" translate="yes" xml:space="preserve">
          <source>Name of the schema</source>
          <target state="translated">스키마 이름</target>
        </trans-unit>
        <trans-unit id="83417c5bdb0fb8b5e66747ac85c9affcdf83a6c6" translate="yes" xml:space="preserve">
          <source>Naming strategy</source>
          <target state="translated">명명 전략</target>
        </trans-unit>
        <trans-unit id="e3dc9c09a90c87b9a68571340476b7334d583546" translate="yes" xml:space="preserve">
          <source>Nested eager loading</source>
          <target state="translated">중첩 된 열망 로딩</target>
        </trans-unit>
        <trans-unit id="a04f6031a8e00febd6c589cf09c4d65ef201ad6b" translate="yes" xml:space="preserve">
          <source>Nested key</source>
          <target state="translated">중첩 키</target>
        </trans-unit>
        <trans-unit id="fb2662973950c773f223cbb622d456ea8595339e" translate="yes" xml:space="preserve">
          <source>Nested object</source>
          <target state="translated">중첩 된 객체</target>
        </trans-unit>
        <trans-unit id="03677879a39a6dfcf623a67df9dc3d5704326271" translate="yes" xml:space="preserve">
          <source>New column name</source>
          <target state="translated">새로운 열 이름</target>
        </trans-unit>
        <trans-unit id="8708814fcaebc0970f0c7c817ceb87f8487aaf17" translate="yes" xml:space="preserve">
          <source>New name from table</source>
          <target state="translated">테이블에서 새로운 이름</target>
        </trans-unit>
        <trans-unit id="6201a9f7432baaca8091c6a78cc0f9fb26eaa3a1" translate="yes" xml:space="preserve">
          <source>New name of function</source>
          <target state="translated">새로운 기능 이름</target>
        </trans-unit>
        <trans-unit id="ed47500954469451016c880a7f5051ccc16a64cf" translate="yes" xml:space="preserve">
          <source>Newly defined model</source>
          <target state="translated">새로 정의 된 모델</target>
        </trans-unit>
        <trans-unit id="fb17233bc810f24085dbf005a9031819e384f852" translate="yes" xml:space="preserve">
          <source>Next thing: Loading of data with many-to-something associations!</source>
          <target state="translated">다음으로 : 다 대다 연관이있는 데이터로드!</target>
        </trans-unit>
        <trans-unit id="e16b1a945e5b22bb16b245f22dd7211090c45d44" translate="yes" xml:space="preserve">
          <source>Normally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want to garbage collect some of them.</source>
          <target state="translated">일반적으로 이는 프로세스 종료시 수행되므로 여러 인스턴스를 작성하고 일부 인스턴스를 가비지 수집하려는 경우에만이 메소드를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="44df5fc237f6e69bd9d791f7eb38e4498268a792" translate="yes" xml:space="preserve">
          <source>Note for production</source>
          <target state="translated">생산 노트</target>
        </trans-unit>
        <trans-unit id="6c85945356462ad75525821c104b7dfcd213da7d" translate="yes" xml:space="preserve">
          <source>Note how &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; are overwritten by &lt;code&gt;scope2&lt;/code&gt;, while &lt;code&gt;firstName&lt;/code&gt; is preserved. The &lt;code&gt;limit&lt;/code&gt;, &lt;code&gt;offset&lt;/code&gt;, &lt;code&gt;order&lt;/code&gt;, &lt;code&gt;paranoid&lt;/code&gt;, &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;raw&lt;/code&gt; fields are overwritten, while &lt;code&gt;where&lt;/code&gt; is shallowly merged (meaning that identical keys will be overwritten). The merge strategy for &lt;code&gt;include&lt;/code&gt; will be discussed later on.</source>
          <target state="translated">참고 방법 &lt;code&gt;limit&lt;/code&gt; 과 &lt;code&gt;age&lt;/code&gt; 을 덮어 씁니다 &lt;code&gt;scope2&lt;/code&gt; 동안, &lt;code&gt;firstName&lt;/code&gt; 을가 보존됩니다. &lt;code&gt;limit&lt;/code&gt; , &lt;code&gt;offset&lt;/code&gt; , &lt;code&gt;order&lt;/code&gt; , &lt;code&gt;paranoid&lt;/code&gt; , &lt;code&gt;lock&lt;/code&gt; 및 &lt;code&gt;raw&lt;/code&gt; 상태 필드는 덮어있는 &lt;code&gt;where&lt;/code&gt; 얕게 병합 (동일한 키 덮어 것을 의미 함). &lt;code&gt;include&lt;/code&gt; 을 위한 병합 전략은 나중에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ef9ad9b0ed9a592756067e7688004b19c87f4919" translate="yes" xml:space="preserve">
          <source>Note how we also specified &lt;code&gt;constraints: false&lt;/code&gt; for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of &lt;code&gt;Error: Cyclic dependency found. 'users' is dependent of itself&lt;/code&gt;. If you encounter this, you should either disable some constraints, or rethink your associations completely.</source>
          <target state="translated">우리는 또한 &lt;code&gt;constraints: false&lt;/code&gt; 어떻게 지정했는지 주목하십시오 : 프로필 사진에는 false . 사용자에서 그림 (profilePictureId)으로, 그림에서 사용자 (userId)로 외래 키를 추가하기 때문입니다. 외래 키를 둘 다 추가하면 순환 종속성이 생성되고 시퀀스는 사용자가 그림에 의존하고 그림이 사용자에 의존하므로 먼저 만들 테이블을 알지 못합니다. 이러한 종류의 문제는 모델이 데이터베이스에 동기화되기 전에 sequelize에 의해 감지되며 &lt;code&gt;Error: Cyclic dependency found. 'users' is dependent of itself&lt;/code&gt; 에 오류 가 발생합니다 . '사용자'는 자신에 의존합니다 . 이 문제가 발생하면 일부 제약 조건을 비활성화하거나 연결을 완전히 다시 생각해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb9144a05775de68ebca958a87e5360db80e40b3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;attributes&lt;/code&gt; keys of multiple applied scopes are merged in such a way that &lt;code&gt;attributes.exclude&lt;/code&gt; are always preserved. This allows merging several scopes and never leaking sensitive fields in final scope.</source>
          <target state="translated">주 &lt;code&gt;attributes&lt;/code&gt; 여러 응용 범위의 키는 것과 같은 방식으로 병합 &lt;code&gt;attributes.exclude&lt;/code&gt; 가 항상 유지됩니다. 이를 통해 여러 범위를 병합하고 최종 범위에서 민감한 필드를 유출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85958c9a7874f5c0d22b6bd6bca1113ce4f88dd0" translate="yes" xml:space="preserve">
          <source>Note that if you are using Sequelize migrations you will need to add the &lt;code&gt;createdAt&lt;/code&gt; and &lt;code&gt;updatedAt&lt;/code&gt; fields to your migration definition:</source>
          <target state="translated">Sequelize 마이그레이션을 사용하는 경우 &lt;code&gt;createdAt&lt;/code&gt; 및 &lt;code&gt;updatedAt&lt;/code&gt; 필드를 마이그레이션 정의 에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="107947aedcad482a28cbbd5ea34b917a3cb7b194" translate="yes" xml:space="preserve">
          <source>Note that many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction _is_ specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet:</source>
          <target state="translated">Sequelize의 많은 모델 작업을 통해 메소드의 옵션 매개 변수에 트랜잭션을 지정할 수 있습니다. 원래 호출에 트랜잭션 _is_이 지정된 경우 후크 함수에 전달 된 옵션 매개 변수에 나타납니다. 예를 들어 다음 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e4a2d5cf04ad438df329fae57d33930a1cee82dc" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;this.firstname&lt;/code&gt; and &lt;code&gt;this.lastname&lt;/code&gt; references in the &lt;code&gt;fullName&lt;/code&gt; getter function will trigger a call to the respective getter functions. If you do not want that then use the &lt;code&gt;getDataValue()&lt;/code&gt; method to access the raw value (see below).</source>
          <target state="translated">점을 유의 &lt;code&gt;this.firstname&lt;/code&gt; 및 &lt;code&gt;this.lastname&lt;/code&gt; 언급 &lt;code&gt;fullName&lt;/code&gt; 의 용 게터 기능은 각 게터 함수 호출을 트리거링한다. 원하지 않으면 &lt;code&gt;getDataValue()&lt;/code&gt; 메소드를 사용하여 원시 값에 액세스하십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="c3f41755f136f1dc7c83971f78c9422549830be4" translate="yes" xml:space="preserve">
          <source>Note that the Image -&amp;gt; Comment and Post -&amp;gt; Comment relations define a scope, &lt;code&gt;commentable: 'image'&lt;/code&gt; and &lt;code&gt;commentable: 'post'&lt;/code&gt; respectively. This scope is automatically applied when using the association functions:</source>
          <target state="translated">Image-&amp;gt; Comment 및 Post-&amp;gt; Comment 관계는 각각 &lt;code&gt;commentable: 'image'&lt;/code&gt; 및 &lt;code&gt;commentable: 'post'&lt;/code&gt; 범위를 정의합니다 . 이 범위는 연관 기능을 사용할 때 자동으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f0b731694e383aebdfdb192c03dcf6b1ffbcb0d" translate="yes" xml:space="preserve">
          <source>Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for &lt;code&gt;isIn&lt;/code&gt;, this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as &lt;code&gt;[['one', 'two']]&lt;/code&gt; as shown above.</source>
          <target state="translated">내장 된 유효성 검사 함수에 여러 인수를 전달해야하는 경우 전달할 인수는 배열에 있어야합니다. 그러나 단일 배열 인수 (예 : &lt;code&gt;isIn&lt;/code&gt; 에 허용되는 문자열 배열)가 전달되는 경우 하나의 배열 인수 대신 여러 문자열 인수로 해석됩니다. 이 문제를 해결하려면 위에 표시된 대로 &lt;code&gt;[['one', 'two']]&lt;/code&gt; 와 같은 단일 길이의 인수 배열을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="acc671783544f4659031c39424988278f5682f5d" translate="yes" xml:space="preserve">
          <source>Note: connection pool (production)</source>
          <target state="translated">참고 : 연결 풀 (프로덕션)</target>
        </trans-unit>
        <trans-unit id="f17a025ad4dbded90c801ce4da0060642aed6add" translate="yes" xml:space="preserve">
          <source>Note: setting up SQLite</source>
          <target state="translated">참고 : SQLite 설정</target>
        </trans-unit>
        <trans-unit id="598ee651f3662bc62e474c319bd8bfacefa4b7fa" translate="yes" xml:space="preserve">
          <source>Notice how in the two examples above, the string provided is inserted verbatim into the query, i.e. column names are not escaped. When you provide a string to order/group, this will always be the case. If you want to escape column names, you should provide an array of arguments, even though you only want to order/group by a single column</source>
          <target state="translated">위의 두 예제에서 제공된 문자열이 쿼리에 그대로 삽입되는 방식을 확인하십시오. 즉, 열 이름이 이스케이프되지 않습니다. 주문 / 그룹에 문자열을 제공 할 때 항상 그렇습니다. 열 이름을 이스케이프하려는 경우 단일 열로만 주문 / 그룹화하려는 경우에도 인수 배열을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea75bd7ff48126d9026a71c0c8a132e1bf24ae80" translate="yes" xml:space="preserve">
          <source>Notice how the callback passed to &lt;code&gt;transaction&lt;/code&gt; returns a promise chain, and does not explicitly call &lt;code&gt;t.commit()&lt;/code&gt; nor &lt;code&gt;t.rollback()&lt;/code&gt;. If all promises in the returned chain are resolved successfully the transaction is committed. If one or several of the promises are rejected, the transaction is rolled back.</source>
          <target state="translated">&lt;code&gt;transaction&lt;/code&gt; 전달 된 콜백이 어떻게 약속 체인을 반환하고 &lt;code&gt;t.commit()&lt;/code&gt; 또는 &lt;code&gt;t.rollback()&lt;/code&gt; 명시 적으로 호출 하지 않는지 확인하십시오 . 리턴 된 체인의 모든 약속이 성공적으로 해결되면 트랜잭션이 커미트됩니다. 하나 이상의 약속이 거부되면 트랜잭션이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="11f0b22a1229e459ff86618d87a61e6308c98004" translate="yes" xml:space="preserve">
          <source>Notice that the accessor (the &lt;code&gt;Tasks&lt;/code&gt; property in the resulting instance) is plural because the association is many-to-something.</source>
          <target state="translated">연결은 다 대다이기 때문에 접근 자 ( 결과 인스턴스 의 &lt;code&gt;Tasks&lt;/code&gt; 속성)는 복수형입니다.</target>
        </trans-unit>
        <trans-unit id="db89be52a41833866fcb78f0286f7fdf07513336" translate="yes" xml:space="preserve">
          <source>Notice that the accessor (the &lt;code&gt;User&lt;/code&gt; property in the resulting instance) is singular because the association is one-to-something.</source>
          <target state="translated">연결이 일대일이기 때문에 접근 자 ( 결과 인스턴스 의 &lt;code&gt;User&lt;/code&gt; 속성)는 특이합니다.</target>
        </trans-unit>
        <trans-unit id="4848a0b9c04bb727fb8adec90477785147fef5df" translate="yes" xml:space="preserve">
          <source>Notice that the scoped column (&lt;code&gt;taggable&lt;/code&gt;) is now on the through model (&lt;code&gt;ItemTag&lt;/code&gt;).</source>
          <target state="translated">범위가 지정된 열 ( &lt;code&gt;taggable&lt;/code&gt; )이 이제 관통 모델 ( &lt;code&gt;ItemTag&lt;/code&gt; )에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cf25bfe98d9e52a1f895ec51fb4362193792880" translate="yes" xml:space="preserve">
          <source>Notice, that the &lt;code&gt;useCLS()&lt;/code&gt; method is on the &lt;em&gt;constructor&lt;/em&gt;, not on an instance of sequelize. This means that all instances will share the same namespace, and that CLS is all-or-nothing - you cannot enable it only for some instances.</source>
          <target state="translated">공지의 것을 &lt;code&gt;useCLS()&lt;/code&gt; 메소드는에 &lt;em&gt;생성자&lt;/em&gt; 하지 sequelize의 인스턴스. 이는 모든 인스턴스가 동일한 네임 스페이스를 공유하고 CLS가 전부 또는 아무것도 없음을 의미하므로 일부 인스턴스에 대해서만 활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e2ed15a30fc301b436665dd5c0c8498b757d5988" translate="yes" xml:space="preserve">
          <source>Now CLI will be able to run ES6/ES7 code from migrations/seeders etc. Please keep in mind this depends upon your configuration of &lt;code&gt;.babelrc&lt;/code&gt;. Please read more about that at &lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.io&lt;/a&gt;.</source>
          <target state="translated">이제 CLI는 마이그레이션 / 시더 등에서 ES6 / ES7 코드를 실행할 수 있습니다 . 이는 &lt;code&gt;.babelrc&lt;/code&gt; 구성에 따라 다릅니다 . &lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.io&lt;/a&gt; 에서 자세한 내용을 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="0dda3fffe72b1e2fffc081cac72bf40762b93a93" translate="yes" xml:space="preserve">
          <source>Now Sequelize CLI will load &lt;code&gt;config/config.js&lt;/code&gt; for getting configuration options. Since this is a JS file you can have any code executed and export final dynamic configuration file.</source>
          <target state="translated">이제 Sequelize CLI는 구성 옵션을 얻기 위해 &lt;code&gt;config/config.js&lt;/code&gt; 를 로드 합니다. 이 파일은 JS 파일이므로 모든 코드를 실행하고 최종 동적 구성 파일을 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95b3edba890e41548c10bf9b3b3625f9aa2f773c" translate="yes" xml:space="preserve">
          <source>Now edit this file and set correct database credentials and dialect. The keys of the objects(ex. &quot;development&quot;) are used on &lt;code&gt;model/index.js&lt;/code&gt; for matching &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; (When undefined, &quot;development&quot; is a default value.).</source>
          <target state="translated">이제이 파일을 편집하고 올바른 데이터베이스 신임 정보 및 방언을 설정하십시오. 객체의 키 (예 : &quot;development&quot;)는 &lt;code&gt;model/index.js&lt;/code&gt; 에서 &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 와 일치시키기 위해 사용됩니다 (정의되지 않은 경우 &quot;development&quot;가 기본값 임).</target>
        </trans-unit>
        <trans-unit id="8bcf1d33260995a6c3b8643c00cc70d1a34e6ef9" translate="yes" xml:space="preserve">
          <source>Now include &lt;code&gt;babel-register&lt;/code&gt; setup in this file</source>
          <target state="translated">이제이 파일에 &lt;code&gt;babel-register&lt;/code&gt; 설정을 포함 시키십시오</target>
        </trans-unit>
        <trans-unit id="464a349af324240ebd3cbae6fce3308732c7d91a" translate="yes" xml:space="preserve">
          <source>Now let's create &lt;code&gt;.sequelizerc&lt;/code&gt; file, it can include any configuration you may want to change for &lt;code&gt;sequelize-cli&lt;/code&gt; but in addition to that we want it to register babel for our codebase. Something like this</source>
          <target state="translated">이제 &lt;code&gt;.sequelizerc&lt;/code&gt; 파일을 만들어 봅시다. &lt;code&gt;sequelize-cli&lt;/code&gt; 를 위해 변경하고 싶을 뿐 아니라 코드베이스에 babel을 등록하기를 원하는 구성을 포함 할 수 있습니다 . 이 같은</target>
        </trans-unit>
        <trans-unit id="20a6638a8729006ac3616971ef324f0cd3930e50" translate="yes" xml:space="preserve">
          <source>Now let's work with an example config.</source>
          <target state="translated">이제 구성 예를 사용해 봅시다.</target>
        </trans-unit>
        <trans-unit id="aff9acc4bc5c9d94727af20f35602137e8690ce9" translate="yes" xml:space="preserve">
          <source>Now lets change some values and save changes to the database... There are two ways to do that:</source>
          <target state="translated">이제 일부 값을 변경하고 데이터베이스에 변경 사항을 저장하겠습니다. 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4fb15abf10ea3e08624eaff19cd79bb8fba56a4" translate="yes" xml:space="preserve">
          <source>Now our table has been created and saved in database. With migration you can revert to old state by just running a command.</source>
          <target state="translated">이제 테이블이 생성되어 데이터베이스에 저장되었습니다. 마이그레이션을 사용하면 명령을 실행하여 이전 상태로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548b3c2a852af460195d73e56956f24676cc3d49" translate="yes" xml:space="preserve">
          <source>Now we can create a product with multiple tags in the following way:</source>
          <target state="translated">이제 다음과 같은 방법으로 여러 태그가있는 제품을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f114dbd008171ea170c4bc3c4396af90c7dda1af" translate="yes" xml:space="preserve">
          <source>Now we should edit this file to insert demo user to &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">이제이 파일을 편집하여 데모 사용자를 &lt;code&gt;User&lt;/code&gt; 테이블 에 삽입해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5fbb7a53e1f2decb02a350e377272f4a1343c317" translate="yes" xml:space="preserve">
          <source>Now you know how to use &lt;code&gt;.sequelizerc&lt;/code&gt; file. Now let's see how to use this file to use babel with &lt;code&gt;sequelize-cli&lt;/code&gt; setup. This will allow you to write migrations and seeders with ES6/ES7 syntax.</source>
          <target state="translated">이제 &lt;code&gt;.sequelizerc&lt;/code&gt; 파일 사용법을 알았습니다 . 이제이 파일을 사용하여 &lt;code&gt;sequelize-cli&lt;/code&gt; 설정 과 함께 babel을 사용하는 방법을 살펴 보겠습니다 . 이를 통해 ES6 / ES7 구문으로 마이그레이션 및 시드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa5d7518e3108590d0f1160b265811a870cd538d" translate="yes" xml:space="preserve">
          <source>Now, consider the following four scopes defined on Foo:</source>
          <target state="translated">이제 Foo에 정의 된 다음 네 가지 범위를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5582432c4864632f5e1a23cfc9dcba9e1ce92437" translate="yes" xml:space="preserve">
          <source>OK. So, first of all, let's load all tasks with their associated user.</source>
          <target state="translated">확인. 우선, 모든 작업을 관련 사용자와 함께로드하십시오.</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="524631efa40fbbd074c7d379858504a629448858" translate="yes" xml:space="preserve">
          <source>Object -</source>
          <target state="translated">객체-</target>
        </trans-unit>
        <trans-unit id="7798f73e59ce895af4d9b669167864b8821ca276" translate="yes" xml:space="preserve">
          <source>Object representing a list of table attributes to create</source>
          <target state="translated">작성할 테이블 속성 목록을 나타내는 오브젝트</target>
        </trans-unit>
        <trans-unit id="a7b5e01cccb77400ad2465a66ef4eff96ddff3da" translate="yes" xml:space="preserve">
          <source>Object specifying target table, column name to create foreign key constraint</source>
          <target state="translated">외래 키 제약 조건을 만들기위한 대상 테이블, 열 이름을 지정하는 개체</target>
        </trans-unit>
        <trans-unit id="c785ae6c15b6aed10bfae737959e2db229782bf3" translate="yes" xml:space="preserve">
          <source>Object with multiple variables.</source>
          <target state="translated">여러 변수가있는 객체.</target>
        </trans-unit>
        <trans-unit id="e3816c117ac9693a36bb6ad26b815f39c6a83f3f" translate="yes" xml:space="preserve">
          <source>Observe how the four scopes were merged into one. The includes of scopes are merged based on the model being included. If one scope includes model A and another includes model B, the merged result will include both models A and B. On the other hand, if both scopes include the same model A, but with different options (such as nested includes or other attributes), those will be merged recursively, as shown above.</source>
          <target state="translated">네 가지 스코프가 어떻게 하나로 통합되었는지 관찰하십시오. 범위 포함은 포함되는 모델을 기반으로 병합됩니다. 한 범위에 모델 A가 포함되고 다른 하나에 모델 B가 포함 된 경우 병합 된 결과에는 모델 A와 B가 모두 포함됩니다. 반면, 두 범위에 모두 동일한 모델 A가 포함되지만 옵션이 다른 경우 (중첩 포함 또는 기타 속성) 위와 같이 재귀 적으로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="3ec9751cae190e1dbc9d9b803b5cc2115aae8a88" translate="yes" xml:space="preserve">
          <source>Of course you can also access the instance's data and generate virtual getters:</source>
          <target state="translated">물론 인스턴스 데이터에 액세스하여 가상 게터를 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef0e1f62d7337f2b1182d77e752df8ade90bdfe4" translate="yes" xml:space="preserve">
          <source>Of course you can also define self references with belongsToMany:</source>
          <target state="translated">물론 belongsToMany로 자기 참조를 정의 할 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fb5654b91a94e76ab0d91f9617ed39a9eb1b3449" translate="yes" xml:space="preserve">
          <source>Offset for result</source>
          <target state="translated">결과에 대한 오프셋</target>
        </trans-unit>
        <trans-unit id="6a8127eb43bf543e2cf1dbb0892cd7b8b334689a" translate="yes" xml:space="preserve">
          <source>On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of &lt;code&gt;Sequelize.ValidationError&lt;/code&gt;. This error will have a property for each of the fields for which validation failed, with the error message for that field.</source>
          <target state="translated">성공하면이 인스턴스로 콜백이 호출됩니다. 유효성 검사 오류가 발생하면 &lt;code&gt;Sequelize.ValidationError&lt;/code&gt; 인스턴스로 콜백이 호출됩니다 . 이 오류에는 해당 필드에 대한 오류 메시지와 함께 유효성 검사에 실패한 각 필드에 대한 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6e8712ec2c54c580ef45527e2407d442845c74b" translate="yes" xml:space="preserve">
          <source>On the other hand, if it is set to allow null (with &lt;code&gt;allowNull: true&lt;/code&gt;) and that value has been set to &lt;code&gt;null&lt;/code&gt;, only the built-in validators will be skipped, while the custom validators will still run.</source>
          <target state="translated">반면, null 허용 ( &lt;code&gt;allowNull: true&lt;/code&gt; )으로 설정되고 해당 값이 &lt;code&gt;null&lt;/code&gt; 로 설정된 경우 내장 유효성 검증기만 건너 뛰고 사용자 정의 유효성 검증기는 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="07f665a8c99eed865083f085d98ec8fca0015d7c" translate="yes" xml:space="preserve">
          <source>Once you created an object and got a reference to it, you can delete it from the database. The relevant method is &lt;code&gt;destroy&lt;/code&gt;:</source>
          <target state="translated">객체를 생성하고 이에 대한 참조를 얻으면 데이터베이스에서 객체를 삭제할 수 있습니다. 관련 방법은 &lt;code&gt;destroy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f9b5321949a967ef42f55010f8e75dec29c3613" translate="yes" xml:space="preserve">
          <source>Once you have properly configured CLI config file you are ready to create your first migration. It's as simple as executing a simple command.</source>
          <target state="translated">CLI 구성 파일을 올바르게 구성했으면 첫 번째 마이그레이션을 작성할 준비가되었습니다. 간단한 명령을 실행하는 것만 큼 간단합니다.</target>
        </trans-unit>
        <trans-unit id="a99024618c2527f3bc655af2bf9a61a350050032" translate="yes" xml:space="preserve">
          <source>One-To-Many associations (hasMany)</source>
          <target state="translated">일대 다 협회 (hasMany)</target>
        </trans-unit>
        <trans-unit id="b04078f82acb5642e470ea54f09be546dc7432a7" translate="yes" xml:space="preserve">
          <source>One-To-Many associations are connecting one source with multiple targets. The targets however are again connected to exactly one specific source.</source>
          <target state="translated">일대 다 연결은 하나의 소스를 여러 대상과 연결합니다. 그러나 대상은 다시 정확히 하나의 특정 소스에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="159ce298fdb55c0ace2cae5b9eeddb9085ed1b07" translate="yes" xml:space="preserve">
          <source>One-To-One associations</source>
          <target state="translated">일대일 협회</target>
        </trans-unit>
        <trans-unit id="7ac7134636ef26e8db79e47ff7c804d75176aa8d" translate="yes" xml:space="preserve">
          <source>One-To-One associations are associations between exactly two models connected by a single foreign key.</source>
          <target state="translated">일대일 연관은 단일 외래 키로 연결된 정확히 두 모델 간의 연관입니다.</target>
        </trans-unit>
        <trans-unit id="2309e67cc0497393678cf4861e18785cba42982e" translate="yes" xml:space="preserve">
          <source>One-to-many association</source>
          <target state="translated">일대 다 협회</target>
        </trans-unit>
        <trans-unit id="52422157c5551a74edd9efae050fd0cbd45e6b6a" translate="yes" xml:space="preserve">
          <source>One-to-one association</source>
          <target state="translated">일대일 협회</target>
        </trans-unit>
        <trans-unit id="80c2f522b0cc71f97fccf4d0cc3b4b1a1a723e86" translate="yes" xml:space="preserve">
          <source>Only a hook with name param can be removed.</source>
          <target state="translated">이름이 param 인 후크 만 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7c3ed5082d4c21101247c805bae6a1b4e6471d0" translate="yes" xml:space="preserve">
          <source>Only available for Postgres</source>
          <target state="translated">Postgres에서만 사용 가능</target>
        </trans-unit>
        <trans-unit id="78606afd96fe0f52ff679e248222b3ca8c9d2f35" translate="yes" xml:space="preserve">
          <source>Only retry a query if the error matches one of these strings.</source>
          <target state="translated">오류가 이러한 문자열 중 하나와 일치하는 경우에만 쿼리를 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="ef20bd5977f69845fb3605c4d34d8da2e99079ec" translate="yes" xml:space="preserve">
          <source>Only used by sqlite. Defaults to ':memory:'</source>
          <target state="translated">sqlite에서만 사용됩니다. 기본값은 ': memory :'</target>
        </trans-unit>
        <trans-unit id="72994e2f28b83f1f262ee9b3a2e57ad75ee09f35" translate="yes" xml:space="preserve">
          <source>Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.</source>
          <target state="translated">TRUNCATE와 함께 사용해야합니다. 잘린 테이블의 열이 소유 한 시퀀스를 자동으로 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="659fa6ab2bfaf4a00c71607875bf9ee544072de3" translate="yes" xml:space="preserve">
          <source>Only used in conjunction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.</source>
          <target state="translated">TRUNCATE와 함께 사용해야합니다. 명명 된 테이블 또는 CASCADE로 인해 그룹에 추가 된 테이블에 대한 외래 키 참조가있는 모든 테이블을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="1e5c03c4ca5dbc17c5a6129ff8dbe16f01a71ebd" translate="yes" xml:space="preserve">
          <source>Op</source>
          <target state="translated">Op</target>
        </trans-unit>
        <trans-unit id="8fe26ec471775c33716aff2e25b307500cb8f70b" translate="yes" xml:space="preserve">
          <source>Operator symbols to be used when querying data</source>
          <target state="translated">데이터를 쿼리 할 때 사용되는 연산자 기호</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="7cbeab9a20efe2e2217d5d299f851a542c5447fe" translate="yes" xml:space="preserve">
          <source>Operators Aliases</source>
          <target state="translated">연산자 별칭</target>
        </trans-unit>
        <trans-unit id="72687734b357dface3249321a849ea8462093c98" translate="yes" xml:space="preserve">
          <source>Operators for possible operators __Alias__: _all_ The promise is resolved with an array of Model instances if the query succeeds._</source>
          <target state="translated">가능한 연산자의 연산자 __Alias__ : _all_ 쿼리가 성공하면 약속은 Model 인스턴스 배열로 해결됩니다 ._</target>
        </trans-unit>
        <trans-unit id="09a779d716fb827fb88714d6257f33d91fa93ea1" translate="yes" xml:space="preserve">
          <source>Operators security</source>
          <target state="translated">운영자 보안</target>
        </trans-unit>
        <trans-unit id="778c618117429ef2dedad8c828b71d5371cf6e0f" translate="yes" xml:space="preserve">
          <source>Optimistic Locking</source>
          <target state="translated">낙관적 잠금</target>
        </trans-unit>
        <trans-unit id="6140cd6be492f81e9de5ce4e733267b4f93e5075" translate="yes" xml:space="preserve">
          <source>Optimistic locking allows concurrent access to model records for edits and prevents conflicts from overwriting data. It does this by checking whether another process has made changes to a record since it was read and throws an OptimisticLockError when a conflict is detected.</source>
          <target state="translated">낙관적 잠금을 통해 편집을 위해 모델 레코드에 동시에 액세스 할 수 있으며 충돌로 인한 데이터 덮어 쓰기를 방지 할 수 있습니다. 다른 프로세스가 읽은 이후 레코드를 변경했는지 확인하여 충돌이 감지되면 OptimisticLockError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="a45991670c71fc0c7f3eb11ef210b0020884d66a" translate="yes" xml:space="preserve">
          <source>OptimisticLockError</source>
          <target state="translated">OptimisticLockError</target>
        </trans-unit>
        <trans-unit id="5182cc6f458b27f798ef769e48426d170adaca6f" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;returning: true&lt;/code&gt; will no longer return attributes that are not defined in the model. Old behavior can be restored by using &lt;code&gt;returning: ['*']&lt;/code&gt;</source>
          <target state="translated">옵션 &lt;code&gt;returning: true&lt;/code&gt; 는 더 이상 모델에 정의되지 않은 속성을 반환하지 않습니다. 다음을 &lt;code&gt;returning: ['*']&lt;/code&gt; 하여 이전 동작을 복원 할 수 있습니다 . [ '*']</target>
        </trans-unit>
        <trans-unit id="2573f9c5c9739bda23063f4ec6575c5d4fcbe3c1" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.create&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;target.create&lt;/code&gt; 에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="fc281780c58169a65a5387bce961e7af93c4bb24" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.create&lt;/code&gt; and setAssociation.</source>
          <target state="translated">&lt;code&gt;target.create&lt;/code&gt; 및 setAssociation에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="40b503e9df444ee2d315f6badf5d3e76b933fb08" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.findAll&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;.</source>
          <target state="translated">옵션에 전달 &lt;code&gt;target.findAll&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f7d5ec9760408cef1a3917f12f6c577fe6b6b15" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.update&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;target.update&lt;/code&gt; 에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="5943acc368ef8e8a62d06081b8cac9a14bc7c85f" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.update&lt;/code&gt;.</source>
          <target state="translated">옵션이 &lt;code&gt;target.update&lt;/code&gt; 로 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6a4f8685a8ba251504870ba17fa94124cb574705" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.destroy&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;through.destroy&lt;/code&gt; 에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="0115f779a0e49b0656989e51e294eb81c64793d7" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.findAll&lt;/code&gt;, &lt;code&gt;bulkCreate&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;</source>
          <target state="translated">전달 옵션 &lt;code&gt;through.findAll&lt;/code&gt; , &lt;code&gt;bulkCreate&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26176f8cc30b890f9a9b8e35a52a1de2b863ffe7" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.findAll&lt;/code&gt;, &lt;code&gt;bulkCreate&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt;</source>
          <target state="translated">옵션에 전달 &lt;code&gt;through.findAll&lt;/code&gt; , &lt;code&gt;bulkCreate&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;destroy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a4b33ed3ca527fbd4b9245bafffeee52768cf1a" translate="yes" xml:space="preserve">
          <source>Options passed to create and add</source>
          <target state="translated">작성 및 추가하기 위해 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="474d03cde40320ee091013efe8d0db26cc7d0b45" translate="yes" xml:space="preserve">
          <source>Options passed to getAssociation and &lt;code&gt;target.save&lt;/code&gt;</source>
          <target state="translated">getAssociation 및 &lt;code&gt;target.save&lt;/code&gt; 에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="fee507ed9dc18ea297e1ba8190f5aa49edd68423" translate="yes" xml:space="preserve">
          <source>Options passed to getAssociations</source>
          <target state="translated">getAssociations에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="06fee8d775b90a83eb6e0500643ad5937a039f32" translate="yes" xml:space="preserve">
          <source>Options that are passed on to &lt;code&gt;Model.find&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Model.find&lt;/code&gt; 에 전달되는 옵션</target>
        </trans-unit>
        <trans-unit id="ee8bbce524fef6ba7c6dbac58492250221aae721" translate="yes" xml:space="preserve">
          <source>Options that are passed to the validator</source>
          <target state="translated">유효성 검증기에 전달되는 옵션</target>
        </trans-unit>
        <trans-unit id="a2025fe246c877972310ec609eb48f54489ec039" translate="yes" xml:space="preserve">
          <source>Options to describe the scope of the search.</source>
          <target state="translated">검색 범위를 설명하는 옵션.</target>
        </trans-unit>
        <trans-unit id="bec1ed99ae879b5c4b91ae857a753fb5fb51217b" translate="yes" xml:space="preserve">
          <source>Or you can use a connection string as well with a path:</source>
          <target state="translated">또는 경로와 함께 연결 문자열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f1762b33b20d79d93b528934ab2323b45f0b56c" translate="yes" xml:space="preserve">
          <source>Order of Operations</source>
          <target state="translated">작업 순서</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="7c3e631356b9b789997f759381378ec61789d79c" translate="yes" xml:space="preserve">
          <source>Ordering Eager Loaded Associations</source>
          <target state="translated">열망하는로드 된 주문 주문</target>
        </trans-unit>
        <trans-unit id="96c2ab3009653c0dea9ef2fbe566de5309b08a8e" translate="yes" xml:space="preserve">
          <source>Other instance to compare against</source>
          <target state="translated">비교할 다른 인스턴스</target>
        </trans-unit>
        <trans-unit id="79eda91bb3b93164ab196b3ef5ed4437b5cbffeb" translate="yes" xml:space="preserve">
          <source>Our goal is to use environment variables for various database secrets and not accidentally check them in to source control.</source>
          <target state="translated">우리의 목표는 다양한 데이터베이스 비밀에 환경 변수를 사용하고 실수로 소스 제어에 체크인하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2fe96ce51692a16cb282a2ceab2dbe87dd4dadd4" translate="yes" xml:space="preserve">
          <source>Override the name of the createdAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.</source>
          <target state="translated">문자열이 제공되면 createdAt 속성의 이름을 대체하거나 false이면 비활성화하십시오. 타임 스탬프는 true 여야합니다. 밑줄 필드는 밑줄 설정으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="573d8c9affd76cce2150107ed262b77798164d37" translate="yes" xml:space="preserve">
          <source>Override the name of the deletedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.</source>
          <target state="translated">문자열이 제공되면 deletedAt 속성의 이름을 대체하거나 false이면 비활성화하십시오. 타임 스탬프는 true 여야합니다. 밑줄 필드는 밑줄 설정으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9f80d4c656e4b0f6cdab55224c8d4d9902552192" translate="yes" xml:space="preserve">
          <source>Override the name of the updatedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.</source>
          <target state="translated">문자열이 제공되면 updatedAt 속성의 이름을 대체하거나 false 인 경우 비활성화하십시오. 타임 스탬프는 true 여야합니다. 밑줄 필드는 밑줄 설정으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f94554b14ce5d5015d5ba9e9470606d7ad0f4f6f" translate="yes" xml:space="preserve">
          <source>Override:</source>
          <target state="translated">Override:</target>
        </trans-unit>
        <trans-unit id="191bd4c23022d0bfd4c0afc357cdedc311221c89" translate="yes" xml:space="preserve">
          <source>PAGLOCK</source>
          <target state="translated">PAGLOCK</target>
        </trans-unit>
        <trans-unit id="6216de0ea276035ad6c650404d1fb576170506d9" translate="yes" xml:space="preserve">
          <source>PRIMARY KEY</source>
          <target state="translated">기본 키</target>
        </trans-unit>
        <trans-unit id="a39ae88eaa033344f483111a662c38ecc2c9da40" translate="yes" xml:space="preserve">
          <source>Pagination / Limiting</source>
          <target state="translated">페이지 매김 / 제한</target>
        </trans-unit>
        <trans-unit id="23c7082125dc9cf874bbe14ba3786fba1a079619" translate="yes" xml:space="preserve">
          <source>Parameters used with the BUILT-IN validator function, if applicable</source>
          <target state="translated">적용 가능한 경우 BUILT-IN 유효성 검증기 기능과 함께 사용되는 매개 변수</target>
        </trans-unit>
        <trans-unit id="ad73fd1a2c6d31eae746e734e09a693793745bd9" translate="yes" xml:space="preserve">
          <source>Params:</source>
          <target state="translated">Params:</target>
        </trans-unit>
        <trans-unit id="ca1853065cda963bd9f055b6bd7dc1d954164536" translate="yes" xml:space="preserve">
          <source>Pass CONCURRENT so other operations run while the index is created</source>
          <target state="translated">인덱스가 생성되는 동안 다른 작업이 실행되도록 CONCURRENT를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="482ca0567201b23a9b0f90cc3e4ca6ff3ea7504f" translate="yes" xml:space="preserve">
          <source>Pass in the desired level as the first argument:</source>
          <target state="translated">첫 번째 인수로 원하는 수준으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="d0b6a5930843ead542631eccaa522d64b6f4c225" translate="yes" xml:space="preserve">
          <source>Pass query execution time in milliseconds as second argument to logging function (options.logging).</source>
          <target state="translated">로깅 기능 (options.logging)의 두 번째 인수로 쿼리 실행 시간을 밀리 초 단위로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="72708499ef443e45b95abcad90f88639d4ced03b" translate="yes" xml:space="preserve">
          <source>Passing Dialect Specific Options</source>
          <target state="translated">방언 별 옵션 전달</target>
        </trans-unit>
        <trans-unit id="0427d4c2f4fb6701afcb9d1d7b13d90257f569fd" translate="yes" xml:space="preserve">
          <source>Per-attribute validations</source>
          <target state="translated">속성 별 검증</target>
        </trans-unit>
        <trans-unit id="ad41972eed6cb608026300559fabcca9c731ee78" translate="yes" xml:space="preserve">
          <source>Per-attribute validators and &lt;code&gt;allowNull&lt;/code&gt;</source>
          <target state="translated">속성 별 유효성 검사기 및 &lt;code&gt;allowNull&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9808bafa8bd1f406e228ff5597a4f9e053ba72a0" translate="yes" xml:space="preserve">
          <source>Permanent Hooks (Sequelize.addHook)</source>
          <target state="translated">영구 고리 (Sequelize.addHook)</target>
        </trans-unit>
        <trans-unit id="323bca2fecb8aed065297c5c4721eea1b95a7140" translate="yes" xml:space="preserve">
          <source>Permanent hooks may also be defined in &lt;code&gt;Sequelize.options&lt;/code&gt;:</source>
          <target state="translated">영구 후크는 &lt;code&gt;Sequelize.options&lt;/code&gt; 에서 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63d6ff4863ed30fb76c61de7b9ed4a9c45048878" translate="yes" xml:space="preserve">
          <source>Please note that this function will return &lt;code&gt;false&lt;/code&gt; when a property from a nested (for example JSON) property was edited manually, you must call &lt;code&gt;changed('key', true)&lt;/code&gt; manually in these cases. Writing an entirely new object (eg. deep cloned) will be detected.</source>
          <target state="translated">중첩 된 (예 : JSON) 속성의 속성을 수동으로 편집 한 경우이 함수는 &lt;code&gt;false&lt;/code&gt; 를 반환 하므로 이러한 경우 수동으로 &lt;code&gt;changed('key', true)&lt;/code&gt; 호출해야합니다 . 완전히 새로운 객체 (예 : 딥 클론)를 작성하는 것이 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="ea229a60fffb397f7382a9347e16ab4efb875578" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;transaction.js~transaction#static-get-LOCK&quot;&gt;Transaction.LOCK&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;transaction.js~transaction#static-get-LOCK&quot;&gt;거래를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a633c5c9226ef96e26ef67982c0b1fbf31148bdb" translate="yes" xml:space="preserve">
          <source>Plural name for model</source>
          <target state="translated">모델의 복수 명</target>
        </trans-unit>
        <trans-unit id="6b41bd077261ccb7ed7f04853c7e531e9e12131b" translate="yes" xml:space="preserve">
          <source>Possible options for row locking.</source>
          <target state="translated">행 잠금에 가능한 옵션.</target>
        </trans-unit>
        <trans-unit id="16e0a7b633c76d649ce1e522d7ec681ae462f811" translate="yes" xml:space="preserve">
          <source>Possible options for row locking. Used in conjunction with &lt;code&gt;find&lt;/code&gt; calls:</source>
          <target state="translated">행 잠금에 가능한 옵션. &lt;code&gt;find&lt;/code&gt; 호출 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="620b5af6e3139187a47774b9079769bc03158a5a" translate="yes" xml:space="preserve">
          <source>PostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement. Coordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326), but measurement functions and relationships ST_Distance, ST_DWithin, ST_Length, and ST_Area always return answers in meters or assume inputs in meters.</source>
          <target state="translated">PostGIS 1.5에는 지리학이라는 새로운 공간 유형이 도입되었습니다. 지리학 적 측정 대신 측지 측정을 사용합니다. 지역 유형의 좌표 점은 항상 WGS 84 론 위도 (SRID 4326)로 표시되지만 측정 함수 및 관계 ST_Distance, ST_DWithin, ST_Length 및 ST_Area는 항상 미터 단위로 응답을 반환하거나 미터 단위로 입력을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="073df06d9f717170d0ac65398d7e552d09431498" translate="yes" xml:space="preserve">
          <source>PostgreSQL - Implemented as a temporary function with exception handling: INSERT EXCEPTION WHEN unique_constraint UPDATE</source>
          <target state="translated">PostgreSQL-예외 처리와 함께 임시 함수로 구현되었습니다. unique_constraint UPDATE시 예외 삽입</target>
        </trans-unit>
        <trans-unit id="1502dc34bce3e1346fc0014a7cc5ee3e3ea95fbe" translate="yes" xml:space="preserve">
          <source>Postgres 9.3+ only</source>
          <target state="translated">Postgres 9.3 이상</target>
        </trans-unit>
        <trans-unit id="b8ce2814112b89374b10c38bb5cca295a3fcd5eb" translate="yes" xml:space="preserve">
          <source>Postgres also supports specific locks while eager loading by using OF:</source>
          <target state="translated">Postgres는 OF를 사용하여 열망하는 동안 특정 잠금을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2a407251115e1be28c5504b5f9e9199614279ede" translate="yes" xml:space="preserve">
          <source>PostgresSQL will build the index without taking any write locks. Postgres only</source>
          <target state="translated">PostgresSQL은 쓰기 잠금을 수행하지 않고 인덱스를 빌드합니다. Postgres 만</target>
        </trans-unit>
        <trans-unit id="69f98f62216cced84a4a7664fbea7b244d38cc2f" translate="yes" xml:space="preserve">
          <source>Primary Key</source>
          <target state="translated">기본 키</target>
        </trans-unit>
        <trans-unit id="e517ee5fd3782b5ee136558aa5e08fab77ad1688" translate="yes" xml:space="preserve">
          <source>Primary keys</source>
          <target state="translated">기본 키</target>
        </trans-unit>
        <trans-unit id="9ab910186508b83730a0e5f6ef1718f45b1e0c1c" translate="yes" xml:space="preserve">
          <source>Production Usages</source>
          <target state="translated">생산 용도</target>
        </trans-unit>
        <trans-unit id="554abf30e877116873c3de42924d6ac948059d03" translate="yes" xml:space="preserve">
          <source>Programmatic use</source>
          <target state="translated">프로그래밍 방식의 사용</target>
        </trans-unit>
        <trans-unit id="fe5671922bc7f67cfabfa60ab97a9542ac21f39f" translate="yes" xml:space="preserve">
          <source>Promise</source>
          <target state="translated">Promise</target>
        </trans-unit>
        <trans-unit id="75f955c70fe0ea79083fa7fabe3a05900585c010" translate="yes" xml:space="preserve">
          <source>Promises and async/await</source>
          <target state="translated">약속과 비동기 / 기다리기</target>
        </trans-unit>
        <trans-unit id="351f56a6fefd5127c90506d3e91990f1d7631787" translate="yes" xml:space="preserve">
          <source>Properties:</source>
          <target state="translated">Properties:</target>
        </trans-unit>
        <trans-unit id="ee08d4050cbb6098526e1137d5e2d585350759ed" translate="yes" xml:space="preserve">
          <source>Property name of the BUILT-IN validator function that caused the validation error (e.g.</source>
          <target state="translated">유효성 검사 오류를 일으킨 BUILT-IN 유효성 검사기 기능의 속성 이름 (예 :</target>
        </trans-unit>
        <trans-unit id="21dd1ed33063eaf0fec2b627562e02d732b0d02a" translate="yes" xml:space="preserve">
          <source>Property name of the BUILT-IN validator function that caused the validation error (e.g. &quot;in&quot; or &quot;len&quot;), if applicable</source>
          <target state="translated">적용 가능한 경우 유효성 검사 오류를 일으킨 BUILT-IN 유효성 검사기 기능의 속성 이름 (예 : &quot;in&quot;또는 &quot;len&quot;)</target>
        </trans-unit>
        <trans-unit id="b39befe85559d7a7d7f870921dd09f561ee705ee" translate="yes" xml:space="preserve">
          <source>Provide a custom getter for this column. Use &lt;code&gt;this.getDataValue(String)&lt;/code&gt; to manipulate the underlying values.</source>
          <target state="translated">이 열에 대한 사용자 지정 게터를 제공하십시오. 사용 &lt;code&gt;this.getDataValue(String)&lt;/code&gt; 기본 값을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="b5698adaf1c9e505751601dcfd1ade05d46fb2b2" translate="yes" xml:space="preserve">
          <source>Provide a custom setter for this column. Use &lt;code&gt;this.setDataValue(String, Value)&lt;/code&gt; to manipulate the underlying values.</source>
          <target state="translated">이 열에 대한 사용자 정의 세터를 제공하십시오. 사용 &lt;code&gt;this.setDataValue(String, Value)&lt;/code&gt; 기본 값을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="7806d20a5b3b834f1cf4cd79c6e14a14852dd900" translate="yes" xml:space="preserve">
          <source>Public Constructor</source>
          <target state="translated">공공 생성자</target>
        </trans-unit>
        <trans-unit id="f98f741af3e683a633762397b6b19a8a0d84038a" translate="yes" xml:space="preserve">
          <source>Public Constructors</source>
          <target state="translated">공공 생성자</target>
        </trans-unit>
        <trans-unit id="6e05889c9b4dc3e125f9019b8d38b3bb729194a7" translate="yes" xml:space="preserve">
          <source>Public Members</source>
          <target state="translated">공개 회원</target>
        </trans-unit>
        <trans-unit id="400be4997716cf3bb5a0c05bf961e2a62c95f6c8" translate="yes" xml:space="preserve">
          <source>Public Methods</source>
          <target state="translated">공개 방법</target>
        </trans-unit>
        <trans-unit id="63d5fc813429798ad09082a4ce6d7789993afa8a" translate="yes" xml:space="preserve">
          <source>Queries using OR</source>
          <target state="translated">OR을 사용한 쿼리</target>
        </trans-unit>
        <trans-unit id="23495b5214e112ada524d83f47869be27fbc912f" translate="yes" xml:space="preserve">
          <source>Queries within a &lt;code&gt;transaction&lt;/code&gt; can be performed with locks</source>
          <target state="translated">&lt;code&gt;transaction&lt;/code&gt; 내 쿼리 는 잠금으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9240311f3ef167d8f58165e9bce953c0badf6a4a" translate="yes" xml:space="preserve">
          <source>Queries within a transaction can skip locked rows</source>
          <target state="translated">트랜잭션 내의 쿼리는 잠긴 행을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d12354bd5e0d0c4f4a34bf8e9705cc16c24598ce" translate="yes" xml:space="preserve">
          <source>Query Interface</source>
          <target state="translated">쿼리 인터페이스</target>
        </trans-unit>
        <trans-unit id="0969ef4dddd33716783dd28b66ec0aaeafb4bd86" translate="yes" xml:space="preserve">
          <source>Query option</source>
          <target state="translated">쿼리 옵션</target>
        </trans-unit>
        <trans-unit id="720143b0891d96ea816e381d60d6c88f81a3db6f" translate="yes" xml:space="preserve">
          <source>Query options</source>
          <target state="translated">쿼리 옵션</target>
        </trans-unit>
        <trans-unit id="e078f5ce4da3bbd9092168dc7caa7d58d0c3218d" translate="yes" xml:space="preserve">
          <source>Query options.</source>
          <target state="translated">쿼리 옵션.</target>
        </trans-unit>
        <trans-unit id="aacae2c5528cab9ee4d1056bb3fe97d662b13033" translate="yes" xml:space="preserve">
          <source>Query options. See sequelize.query for full options</source>
          <target state="translated">쿼리 옵션. 전체 옵션은 sequelize.query를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e0418715c69e9b17e7730738c56f3d4f4b9d704" translate="yes" xml:space="preserve">
          <source>QueryError</source>
          <target state="translated">QueryError</target>
        </trans-unit>
        <trans-unit id="e0905a933a3f10834e2d58cddd1bfbace4c6ce1e" translate="yes" xml:space="preserve">
          <source>QueryInterface</source>
          <target state="translated">QueryInterface</target>
        </trans-unit>
        <trans-unit id="956e52cb6dce6420ffdbd1c53f487158ffdca0ce" translate="yes" xml:space="preserve">
          <source>QueryTypes</source>
          <target state="translated">QueryTypes</target>
        </trans-unit>
        <trans-unit id="cc6835ce045ca407e1aa42cf034a40b2dc968c7d" translate="yes" xml:space="preserve">
          <source>Querying</source>
          <target state="translated">Querying</target>
        </trans-unit>
        <trans-unit id="8f1e1ff9d000b44617e8ef8f0ce02e30146ecaef" translate="yes" xml:space="preserve">
          <source>Quick example</source>
          <target state="translated">빠른 예</target>
        </trans-unit>
        <trans-unit id="578e6dad8d99e7211a3086f6ebcd1836a6b2b2b0" translate="yes" xml:space="preserve">
          <source>RANGE</source>
          <target state="translated">RANGE</target>
        </trans-unit>
        <trans-unit id="c5db7969dcd30635e5d7867040b6cc76158dd175" translate="yes" xml:space="preserve">
          <source>RAW</source>
          <target state="translated">RAW</target>
        </trans-unit>
        <trans-unit id="85071fc9642a31aeb812a32870f392506932a628" translate="yes" xml:space="preserve">
          <source>READCOMMITTED</source>
          <target state="translated">READCOMMITTED</target>
        </trans-unit>
        <trans-unit id="c81fcd11275974e0c42fe3b69f4579fb5562a008" translate="yes" xml:space="preserve">
          <source>READPAST</source>
          <target state="translated">READPAST</target>
        </trans-unit>
        <trans-unit id="0c97d219d43b5c2d780f866829caf6659ccd95b4" translate="yes" xml:space="preserve">
          <source>READUNCOMMITTED</source>
          <target state="translated">READUNCOMMITTED</target>
        </trans-unit>
        <trans-unit id="98576b173a3704ed9c7a7b2cf51bf056c70f0d68" translate="yes" xml:space="preserve">
          <source>READ_COMMITTED</source>
          <target state="translated">READ_COMMITTED</target>
        </trans-unit>
        <trans-unit id="61855051443526ce1354c6dfbbb1385589d20c72" translate="yes" xml:space="preserve">
          <source>READ_UNCOMMITTED</source>
          <target state="translated">READ_UNCOMMITTED</target>
        </trans-unit>
        <trans-unit id="3b330731a188b19fdf61999609e5e9b932bb400b" translate="yes" xml:space="preserve">
          <source>REAL</source>
          <target state="translated">REAL</target>
        </trans-unit>
        <trans-unit id="35818f41399b7623be79d4ece6708799ff65422b" translate="yes" xml:space="preserve">
          <source>REPEATABLEREAD</source>
          <target state="translated">REPEATABLEREAD</target>
        </trans-unit>
        <trans-unit id="7933c8f4eeae479160924ccc01192513271103d0" translate="yes" xml:space="preserve">
          <source>REPEATABLE_READ</source>
          <target state="translated">REPEATABLE_READ</target>
        </trans-unit>
        <trans-unit id="d2de16710476e50096c7fcc23018a457762110cf" translate="yes" xml:space="preserve">
          <source>ROWLOCK</source>
          <target state="translated">ROWLOCK</target>
        </trans-unit>
        <trans-unit id="639e3ac9bf3c15f412dffa9f6f9c04017303eefc" translate="yes" xml:space="preserve">
          <source>Range Operators</source>
          <target state="translated">범위 연산자</target>
        </trans-unit>
        <trans-unit id="48652fff66c0aa4370d5c8fba0d573037de8ea3f" translate="yes" xml:space="preserve">
          <source>Range types</source>
          <target state="translated">범위 유형</target>
        </trans-unit>
        <trans-unit id="96c99c450dc81023477ef685e69a7671928973e9" translate="yes" xml:space="preserve">
          <source>Range types are data types representing a range of values of some element type (called the range's subtype). Only available in Postgres. See &lt;a href=&quot;http://www.postgresql.org/docs/9.4/static/rangetypes.html&quot;&gt;the Postgres documentation&lt;/a&gt; for more details</source>
          <target state="translated">범위 유형은 일부 요소 유형의 값 범위 (범위 하위 유형이라고 함)를 나타내는 데이터 유형입니다. Postgres에서만 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;http://www.postgresql.org/docs/9.4/static/rangetypes.html&quot;&gt;은 Postgres 설명서&lt;/a&gt; 를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="5a7377dcba549345dfcab0dfa8460d8f871eb24f" translate="yes" xml:space="preserve">
          <source>Range types can be queried with all supported operators.</source>
          <target state="translated">지원되는 모든 연산자를 사용하여 범위 유형을 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="0d5fda95e3940bc09dc1ccc22666813c0b54f73d" translate="yes" xml:space="preserve">
          <source>Ranges</source>
          <target state="translated">Ranges</target>
        </trans-unit>
        <trans-unit id="9f5ef9cd3f272e59c3c26c12902db3ba7d565d10" translate="yes" xml:space="preserve">
          <source>Raw queries</source>
          <target state="translated">원시 쿼리</target>
        </trans-unit>
        <trans-unit id="4248bae998e3d216240b6c47e05b15e9130b7194" translate="yes" xml:space="preserve">
          <source>Raw will be added verbatim without quoting</source>
          <target state="translated">Raw는 따옴표없이 그대로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9663c8f2ab80910477b1274bc8c092ea181f86b5" translate="yes" xml:space="preserve">
          <source>Read replication</source>
          <target state="translated">읽기 복제</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="031a37f39bcb7e10adf807d3e8cce401989e3336" translate="yes" xml:space="preserve">
          <source>Refresh the current instance in-place, i.e.</source>
          <target state="translated">현재 인스턴스를 제자리에서 새로 고칩니다.</target>
        </trans-unit>
        <trans-unit id="e3bead0d664a82f06306287d9173002e149764e1" translate="yes" xml:space="preserve">
          <source>Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object. This is different from doing a &lt;code&gt;find(Instance.id)&lt;/code&gt;, because that would create and return a new instance. With this method, all references to the Instance are updated with the new data and no new objects are created.</source>
          <target state="translated">현재 인스턴스를 제자리에서 새로 고칩니다. 즉, DB의 현재 데이터로 객체를 업데이트하고 동일한 객체를 반환합니다. &lt;code&gt;find(Instance.id)&lt;/code&gt; 를 수행하는 것과는 다릅니다 . 새 인스턴스를 생성하고 반환하기 때문입니다. 이 방법을 사용하면 인스턴스에 대한 모든 참조가 새 데이터로 업데이트되고 새 객체가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca5db4fe93ba98fe1b576309acf2388052f2a36a" translate="yes" xml:space="preserve">
          <source>RegExp</source>
          <target state="translated">RegExp</target>
        </trans-unit>
        <trans-unit id="1e86d1ab3e14027eebaead6774b3afb37da45758" translate="yes" xml:space="preserve">
          <source>Relations / Associations</source>
          <target state="translated">관계 / 협회</target>
        </trans-unit>
        <trans-unit id="bc1c1bb509a7c9eefcd8074bcef69cd86f8f19ac" translate="yes" xml:space="preserve">
          <source>Reloading instances</source>
          <target state="translated">인스턴스 재로드</target>
        </trans-unit>
        <trans-unit id="14458dc7478ac57fde39eddb8f546bb3fd24be23" translate="yes" xml:space="preserve">
          <source>Remember, that using &lt;code&gt;as&lt;/code&gt; to change the name of the association will also change the name of the foreign key. When using &lt;code&gt;as&lt;/code&gt;, it is safest to also specify the foreign key.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 를 사용 하여 연결 이름을 변경하면 외래 키의 이름도 변경됩니다. 사용하는 경우 &lt;code&gt;as&lt;/code&gt; , 또한 외래 키를 지정하는 것이 가장 안전하다.</target>
        </trans-unit>
        <trans-unit id="6d92b3105e7267474045640ff596b8906e7af063" translate="yes" xml:space="preserve">
          <source>Remove a column from a table</source>
          <target state="translated">테이블에서 열 제거</target>
        </trans-unit>
        <trans-unit id="bff645f20c7a1972d6d88b3b0359efc0ee0f30bb" translate="yes" xml:space="preserve">
          <source>Remove a constraint from a table</source>
          <target state="translated">테이블에서 제약 조건 제거</target>
        </trans-unit>
        <trans-unit id="cb9d2380c9de310077c9efa21538ee05180de069" translate="yes" xml:space="preserve">
          <source>Remove an already existing index from a table</source>
          <target state="translated">테이블에서 이미 존재하는 인덱스 제거</target>
        </trans-unit>
        <trans-unit id="ab78daa0ae196a56f47e13a630c4d49dbadeaa77" translate="yes" xml:space="preserve">
          <source>Remove attribute from model definition</source>
          <target state="translated">모델 정의에서 속성 제거</target>
        </trans-unit>
        <trans-unit id="2973fb8de042ab579cc70360faec4d4d03145016" translate="yes" xml:space="preserve">
          <source>Removing hooks</source>
          <target state="translated">후크 제거</target>
        </trans-unit>
        <trans-unit id="91662afa90e2669fafb0bf327ba36d683b24d55a" translate="yes" xml:space="preserve">
          <source>Rename a column</source>
          <target state="translated">열 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="ef6f539bacc24cc94df1896ca6fcc25c1857460e" translate="yes" xml:space="preserve">
          <source>Rename a table</source>
          <target state="translated">테이블 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="5c789b825fe6ffb7af34dec8ebebc9922c5740fd" translate="yes" xml:space="preserve">
          <source>Rename an SQL function</source>
          <target state="translated">SQL 함수 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="844abd7b464a7e3dcdf7de2a8921961f223adea8" translate="yes" xml:space="preserve">
          <source>Replacements</source>
          <target state="translated">Replacements</target>
        </trans-unit>
        <trans-unit id="d70b63d60d5bb03bf369a3221e7e9fa6befeb5ae" translate="yes" xml:space="preserve">
          <source>Replacements in a query can be done in two different ways, either using named parameters (starting with &lt;code&gt;:&lt;/code&gt;), or unnamed, represented by a &lt;code&gt;?&lt;/code&gt;. Replacements are passed in the options object.</source>
          <target state="translated">쿼리에서 대체는 명명 된 매개 변수 ( &lt;code&gt;:&lt;/code&gt; 로 시작 ) 또는 &lt;code&gt;?&lt;/code&gt; 로 표시되는 명명되지 않은 두 가지 방법으로 수행 할 수 있습니다 . . 교체는 옵션 개체에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c8dd3270a29ae39ef2c23cbc1c10e9c2f5688a7c" translate="yes" xml:space="preserve">
          <source>Resolves an array with &amp;lt;created, primaryKey&amp;gt;</source>
          <target state="translated">&amp;lt;created, primaryKey&amp;gt;로 배열을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="bc5668827c21fe1f8f36ea7324d4d8a3dcb11ecd" translate="yes" xml:space="preserve">
          <source>Restore multiple instances if &lt;code&gt;paranoid&lt;/code&gt; is enabled.</source>
          <target state="translated">&lt;code&gt;paranoid&lt;/code&gt; 이 활성화 된 경우 여러 인스턴스를 복원하십시오 .</target>
        </trans-unit>
        <trans-unit id="37be80d158033bb193c3d7ed1a4181d957c6440e" translate="yes" xml:space="preserve">
          <source>Restore the row corresponding to this instance.</source>
          <target state="translated">이 인스턴스에 해당하는 행을 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="d2363df61524d7567e5af8c230d6ffbc8c9156fc" translate="yes" xml:space="preserve">
          <source>Restore the row corresponding to this instance. Only available for paranoid models.</source>
          <target state="translated">이 인스턴스에 해당하는 행을 복원하십시오. 편집증 모델에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4634f89378d1924436e5804ae4532bb1debc2947" translate="yes" xml:space="preserve">
          <source>Restoring soft-deleted instances</source>
          <target state="translated">일시 삭제 된 인스턴스 복원</target>
        </trans-unit>
        <trans-unit id="f26f5c5c95a911b7185dd088fa0b3f892ac47881" translate="yes" xml:space="preserve">
          <source>Return Properties:</source>
          <target state="translated">반품 속성 :</target>
        </trans-unit>
        <trans-unit id="f664f9ed85db7232f7addc0c9bbae995ff292379" translate="yes" xml:space="preserve">
          <source>Return raw result. See sequelize.query for more information.</source>
          <target state="translated">원시 결과를 반환합니다. 자세한 내용은 sequelize.query를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d2d96565dc06a866465216373028dc31bfc11ee" translate="yes" xml:space="preserve">
          <source>Return:</source>
          <target state="translated">Return:</target>
        </trans-unit>
        <trans-unit id="a1d9b7652dc04e48059f4b18dea69d8b483420d4" translate="yes" xml:space="preserve">
          <source>ReturnType</source>
          <target state="translated">ReturnType</target>
        </trans-unit>
        <trans-unit id="f32e3242c5f0d8fcfb58c28d4f50b845b239aea2" translate="yes" xml:space="preserve">
          <source>Returns a boolean indicating whether the row was created or updated. For MySQL/MariaDB, it returns &lt;code&gt;true&lt;/code&gt; when inserted and &lt;code&gt;false&lt;/code&gt; when updated. For Postgres/MSSQL with &lt;code&gt;options.returning&lt;/code&gt; true, it returns record and created boolean with signature &lt;code&gt;&amp;lt;Model, created&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">행이 작성 또는 업데이트되었는지 여부를 나타내는 부울을 리턴합니다. MySQL / MariaDB의 경우 삽입하면 &lt;code&gt;true&lt;/code&gt; 를 , 업데이트하면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . &lt;code&gt;options.returning&lt;/code&gt; 이 true 인 Postgres / MSSQL의 경우 &lt;code&gt;&amp;lt;Model, created&amp;gt;&lt;/code&gt; 서명을 사용하여 레코드 및 작성된 부울을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="92777933f98de40e5798a074519518b08312bfd8" translate="yes" xml:space="preserve">
          <source>Returns an instance of QueryInterface.</source>
          <target state="translated">QueryInterface의 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c322d13eab7a672964dca2772283f58dabee793f" translate="yes" xml:space="preserve">
          <source>Returns the aggregate result cast to &lt;code&gt;options.dataType&lt;/code&gt;, unless &lt;code&gt;options.plain&lt;/code&gt; is false, in which case the complete data result is returned.</source>
          <target state="translated">&lt;code&gt;options.plain&lt;/code&gt; 이 false가 아닌 경우 전체 데이터 결과가 반환 되지 않는 경우, 집계 결과를 &lt;code&gt;options.dataType&lt;/code&gt; 으로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="103e0065273bcd078037909cef8d4cc766b70922" translate="yes" xml:space="preserve">
          <source>Returns the database name.</source>
          <target state="translated">데이터베이스 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a10c7b621ae5ef9b30ad1471df3f082cfe770ea5" translate="yes" xml:space="preserve">
          <source>Returns the previous value for key from &lt;code&gt;_previousDataValues&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;_previousDataValues&lt;/code&gt; 에서 키의 이전 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9099a16ce517a4d9ac59414ac4a523117d0007b1" translate="yes" xml:space="preserve">
          <source>Returns the specified dialect.</source>
          <target state="translated">지정된 방언을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4310720bd11331b7ae73d54f73813dcad1e1e28a" translate="yes" xml:space="preserve">
          <source>Returns true if model is already defined, otherwise false</source>
          <target state="translated">모델이 이미 정의되어 있으면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf0e4991b938c50573d09edc06ace4eb0dbd811c" translate="yes" xml:space="preserve">
          <source>Returns true if this instance has not yet been persisted to the database</source>
          <target state="translated">이 인스턴스가 아직 데이터베이스에 유지되지 않은 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2007b5e3da27ad8963cdb311ba2a3128e7cda7e9" translate="yes" xml:space="preserve">
          <source>Rollback (abort) the transaction</source>
          <target state="translated">트랜잭션 롤백 (중단)</target>
        </trans-unit>
        <trans-unit id="8e0cccf120979b3af77ad8a694a8e18cdc3b513e" translate="yes" xml:space="preserve">
          <source>Run a describe query on the table.</source>
          <target state="translated">테이블에서 설명 쿼리를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8169f81a04275d99535c5a4211bee013dce2d9d3" translate="yes" xml:space="preserve">
          <source>Run an aggregation method on the specified field</source>
          <target state="translated">지정된 필드에서 집계 방법을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3439b8e48e17b209e3887f10db99898a3f33d4e1" translate="yes" xml:space="preserve">
          <source>Run before / after bulk create hooks?</source>
          <target state="translated">대량 후크 생성 전후에 실행 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="5a75a9b600e3260d17089015df07ae23e6d3703c" translate="yes" xml:space="preserve">
          <source>Run before / after bulk destroy hooks?</source>
          <target state="translated">대량 파괴 후크 전후에 실행합니까?</target>
        </trans-unit>
        <trans-unit id="e52da5177ddbb46f0bf29b8b84e6c8fb0b7bd630" translate="yes" xml:space="preserve">
          <source>Run before / after bulk restore hooks?</source>
          <target state="translated">대량 복원 후크 전후에 실행 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="58269ada070e42bd9ffb7febed75e9d2c7c689e1" translate="yes" xml:space="preserve">
          <source>Run before / after bulk update hooks?</source>
          <target state="translated">대량 업데이트 후크 전후에 실행 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="18d6ef3bc4c10e371b0cd91efbfe8df85e68a008" translate="yes" xml:space="preserve">
          <source>Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true.</source>
          <target state="translated">각 개별 인스턴스에 대한 후크를 생성하기 전 / 후에 실행 하시겠습니까? options.hooks가 true이면 BulkCreate 후크가 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0b8459e34068807e1eb3c85fad215b35c650ee7e" translate="yes" xml:space="preserve">
          <source>Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks</source>
          <target state="translated">업데이트 후크 전 / 후 실행?. true이면 SELECT와 개별 UPDATE가 차례로 실행됩니다. 행 데이터를 후크로 전달해야하므로 선택이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e5cedd10390a9d3b239800334f224886fe370712" translate="yes" xml:space="preserve">
          <source>Run before / after upsert hooks?</source>
          <target state="translated">업 서트 후크 전 / 후에 실행 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="a944f09a5a793cb75f92d040f95fa4f35da5420c" translate="yes" xml:space="preserve">
          <source>Run before and after create / update + validate hooks</source>
          <target state="translated">생성 / 업데이트 후 + 후크 확인 후 실행</target>
        </trans-unit>
        <trans-unit id="2ae7654b4055b38aa79d971e21b65027b2ca1df7" translate="yes" xml:space="preserve">
          <source>Run before and after validate hooks</source>
          <target state="translated">유효성 검사 후크 전후에 실행</target>
        </trans-unit>
        <trans-unit id="eb7bcd25188536a53fb43bbd3bb4651b7f53eae7" translate="yes" xml:space="preserve">
          <source>Run built-in type validators on insert and update, and select with where clause, e.g. validate that arguments passed to integer fields are integer-like.</source>
          <target state="translated">삽입 및 업데이트시 내장 유형 유효성 검증기를 실행하고 where 절을 선택하십시오. 예를 들어 정수 필드에 전달 된 인수가 정수와 같은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b6577a96503f5049bd73f30cf24b51eebe5f6b78" translate="yes" xml:space="preserve">
          <source>Run validation for the join model</source>
          <target state="translated">조인 모델에 대한 유효성 검사 실행</target>
        </trans-unit>
        <trans-unit id="85489a3587bf76a40730b08a2f8006ba1c2c454c" translate="yes" xml:space="preserve">
          <source>Run validation for the join model.</source>
          <target state="translated">결합 모델에 대한 유효성 검증을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8b1ee002e28b50380a23fec36c627e6248c45e67" translate="yes" xml:space="preserve">
          <source>Run validations before the row is inserted</source>
          <target state="translated">행이 삽입되기 전에 유효성 검사를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="309084555a84115c15bd76ae9ab2d30a30649897" translate="yes" xml:space="preserve">
          <source>Running Migrations</source>
          <target state="translated">마이그레이션 실행</target>
        </trans-unit>
        <trans-unit id="c58ea185833c0872e448165cd1c7703ab76a90b8" translate="yes" xml:space="preserve">
          <source>Running Seeds</source>
          <target state="translated">씨앗을 실행</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="d5a57bf501dacfbda90f27fd318b8cd457a96a1b" translate="yes" xml:space="preserve">
          <source>SERIALIZABLE</source>
          <target state="translated">SERIALIZABLE</target>
        </trans-unit>
        <trans-unit id="a9b25d35e6e01edfdd65178492d182aba6d34218" translate="yes" xml:space="preserve">
          <source>SET NULL if foreignKey allows nulls, CASCADE if otherwise</source>
          <target state="translated">foreignKey가 널을 허용하면 SET NULL, 그렇지 않으면 CASCADE</target>
        </trans-unit>
        <trans-unit id="516cdbb3e5db4db95fd51e4b0171ee222656aff6" translate="yes" xml:space="preserve">
          <source>SET NULL if foreignKey allows nulls, NO ACTION if otherwise</source>
          <target state="translated">foreignKey가 널을 허용하면 NULL을, 그렇지 않으면 NO ACTION을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4171eb087f6af62c707c7159e3b00d2346badde5" translate="yes" xml:space="preserve">
          <source>SET_DEFERRED</source>
          <target state="translated">SET_DEFERRED</target>
        </trans-unit>
        <trans-unit id="68149187501fb70315f6e8131bbf9fe48348ed17" translate="yes" xml:space="preserve">
          <source>SET_IMMEDIATE</source>
          <target state="translated">SET_IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="dd19b86ae45a271261a2769df9693b7eeeac1d33" translate="yes" xml:space="preserve">
          <source>SHARE</source>
          <target state="translated">SHARE</target>
        </trans-unit>
        <trans-unit id="212e619789f81c3e0d20848be5f4e29b8020d588" translate="yes" xml:space="preserve">
          <source>SHOWCONSTRAINTS</source>
          <target state="translated">SHOWCONSTRAINTS</target>
        </trans-unit>
        <trans-unit id="f7b0cacf516079a8ab39ad0cda85a7099d7671b2" translate="yes" xml:space="preserve">
          <source>SHOWINDEXES</source>
          <target state="translated">SHOWINDEXES</target>
        </trans-unit>
        <trans-unit id="e786763f51c96fb966cfe9993f619969600fcb2d" translate="yes" xml:space="preserve">
          <source>SHOWTABLES</source>
          <target state="translated">SHOWTABLES</target>
        </trans-unit>
        <trans-unit id="9e170c7c7025a1a5f7c3857f8315cf4ac6db1d72" translate="yes" xml:space="preserve">
          <source>SMALLINT</source>
          <target state="translated">SMALLINT</target>
        </trans-unit>
        <trans-unit id="f956ed3dc3c576285c7137ae67e24c69f9266d1d" translate="yes" xml:space="preserve">
          <source>SNAPSHOT</source>
          <target state="translated">SNAPSHOT</target>
        </trans-unit>
        <trans-unit id="fb9477462cfa5f60b14431efb98e90a54887f14e" translate="yes" xml:space="preserve">
          <source>SQL type of function returned value</source>
          <target state="translated">SQL 유형의 함수 리턴 값</target>
        </trans-unit>
        <trans-unit id="9f09ccbd1cfb65aced3eb531305e671e40b95dd3" translate="yes" xml:space="preserve">
          <source>SQLite</source>
          <target state="translated">SQLite</target>
        </trans-unit>
        <trans-unit id="b751b9c16bf3667739f71a4e1c056e70944f0120" translate="yes" xml:space="preserve">
          <source>SQLite - Implemented as two queries &lt;code&gt;INSERT; UPDATE&lt;/code&gt;. This means that the update is executed regardless of whether the row already existed or not</source>
          <target state="translated">SQLite-두 개의 쿼리로 구현 &lt;code&gt;INSERT; UPDATE&lt;/code&gt; . 이것은 행이 이미 존재하는지 여부에 관계없이 업데이트가 실행됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="adfd5586a4984b594806377be1a9f4e09a8df4c1" translate="yes" xml:space="preserve">
          <source>SRID of type</source>
          <target state="translated">유형의 SRID</target>
        </trans-unit>
        <trans-unit id="da5aba16204ebd88821d2bbf3642268c4231fb1f" translate="yes" xml:space="preserve">
          <source>STRING</source>
          <target state="translated">STRING</target>
        </trans-unit>
        <trans-unit id="1d61ec39e663f6e58702a7ad1738531fa768fb9c" translate="yes" xml:space="preserve">
          <source>STRING A variable length string</source>
          <target state="translated">STRING 가변 길이 문자열</target>
        </trans-unit>
        <trans-unit id="d41f19dfee39725e336978083f9a8c5f6b3be7a4" translate="yes" xml:space="preserve">
          <source>STRING#constructor</source>
          <target state="translated">STRING#constructor</target>
        </trans-unit>
        <trans-unit id="0bf4823535962139cb43d7dd88554175707982d1" translate="yes" xml:space="preserve">
          <source>Schema name to create</source>
          <target state="translated">작성할 스키마 이름</target>
        </trans-unit>
        <trans-unit id="6c80a5b04edfdb2a6f83ba6280a271386f52ac29" translate="yes" xml:space="preserve">
          <source>Schema name to drop</source>
          <target state="translated">제거 할 스키마 이름</target>
        </trans-unit>
        <trans-unit id="6e28871105300b1a9e39344d8c2f862f59f05a20" translate="yes" xml:space="preserve">
          <source>Scope Error.</source>
          <target state="translated">범위 오류.</target>
        </trans-unit>
        <trans-unit id="89f9f3e1b3d3732f4f20df80017d0f8219871f92" translate="yes" xml:space="preserve">
          <source>Scope Error. Thrown when the sequelize cannot query the specified scope.</source>
          <target state="translated">범위 오류. 후행이 지정된 범위를 쿼리 할 수 ​​없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c23540e5fb551edff0ac95649a1d551f9736d55e" translate="yes" xml:space="preserve">
          <source>Scopes</source>
          <target state="translated">Scopes</target>
        </trans-unit>
        <trans-unit id="0da8a5956aaa3c85b91d3f215267b4fade7bdd85" translate="yes" xml:space="preserve">
          <source>Scopes apply to &lt;code&gt;.find&lt;/code&gt;, &lt;code&gt;.findAll&lt;/code&gt;, &lt;code&gt;.count&lt;/code&gt;, &lt;code&gt;.update&lt;/code&gt;, &lt;code&gt;.increment&lt;/code&gt; and &lt;code&gt;.destroy&lt;/code&gt;.</source>
          <target state="translated">스코프에 적용 &lt;code&gt;.find&lt;/code&gt; , &lt;code&gt;.findAll&lt;/code&gt; , &lt;code&gt;.count&lt;/code&gt; , &lt;code&gt;.update&lt;/code&gt; 를 , &lt;code&gt;.increment&lt;/code&gt; 및 &lt;code&gt;.destroy&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7e8a81b0184917a8413801eb97f5c4f1a30e16de" translate="yes" xml:space="preserve">
          <source>Scopes are applied by calling &lt;code&gt;.scope&lt;/code&gt; on the model definition, passing the name of one or more scopes. &lt;code&gt;.scope&lt;/code&gt; returns a fully functional model instance with all the regular methods: &lt;code&gt;.findAll&lt;/code&gt;, &lt;code&gt;.update&lt;/code&gt;, &lt;code&gt;.count&lt;/code&gt;, &lt;code&gt;.destroy&lt;/code&gt; etc. You can save this model instance and reuse it later:</source>
          <target state="translated">범위는 모델 정의에서 &lt;code&gt;.scope&lt;/code&gt; 를 호출하여 적용되며 하나 이상의 범위 이름을 전달합니다. &lt;code&gt;.scope&lt;/code&gt; 는 &lt;code&gt;.findAll&lt;/code&gt; , &lt;code&gt;.update&lt;/code&gt; , &lt;code&gt;.count&lt;/code&gt; , .destroy 등 모든 일반 메소드가 포함 된 완전한 기능의 모델 인스턴스를 리턴 &lt;code&gt;.destroy&lt;/code&gt; .이 모델 인스턴스를 저장 한 후 나중에 다시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="120923523c35c563d8ac081091bf3511da3a4321" translate="yes" xml:space="preserve">
          <source>Scopes are defined in the model definition and can be finder objects, or functions returning finder objects - except for the default scope, which can only be an object:</source>
          <target state="translated">범위는 모델 정의에 정의되며 파인더 오브젝트 또는 파인더 오브젝트를 리턴하는 함수일 수 있습니다 (기본 범위를 제외하고 오브젝트 만 가능).</target>
        </trans-unit>
        <trans-unit id="c3a5b1f2c5fdd9c8b47aa2b2dc6c11a18f6dd918" translate="yes" xml:space="preserve">
          <source>Scopes which are functions can be invoked in two ways. If the scope does not take any arguments it can be invoked as normally. If the scope takes arguments, pass an object:</source>
          <target state="translated">함수 인 스코프는 두 가지 방법으로 호출 할 수 있습니다. 범위가 인수를 취하지 않으면 정상적으로 호출 될 수 있습니다. 범위가 인수를 사용하는 경우 객체를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="a39e965661725cc234f9253f0b7566cfa5aa18e4" translate="yes" xml:space="preserve">
          <source>Scoping allows you to define commonly used queries that you can easily use later. Scopes can include all the same attributes as regular finders, &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;limit&lt;/code&gt; etc.</source>
          <target state="translated">범위를 지정하면 나중에 쉽게 사용할 수있는 일반적으로 사용되는 쿼리를 정의 할 수 있습니다. 범위에는 일반 파인더와 동일한 속성이 모두 포함될 수 있습니다. &lt;code&gt;where&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; , &lt;code&gt;limit&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="28a2e804b07e3185be2ca5de143ec18a821eeacf" translate="yes" xml:space="preserve">
          <source>Search for a single instance by its primary key._</source>
          <target state="translated">기본 키로 단일 인스턴스를 검색하십시오 ._</target>
        </trans-unit>
        <trans-unit id="fab27cb2bedf60f526ca0afd3fc62f8ddebfb13b" translate="yes" xml:space="preserve">
          <source>Search for a single instance.</source>
          <target state="translated">단일 인스턴스를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="960425bfa22ad385f9c4f8d364ce932418a965ec" translate="yes" xml:space="preserve">
          <source>Search for a single instance. This applies LIMIT 1, so the listener will always be called with a single instance.</source>
          <target state="translated">단일 인스턴스를 검색하십시오. LIMIT 1이 적용되므로 리스너는 항상 단일 인스턴스로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="069d800301b1242814d076a9ba69c25a797f1f8e" translate="yes" xml:space="preserve">
          <source>Search for multiple instances.</source>
          <target state="translated">여러 인스턴스를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="8993db7b4561dcbe3dd7ed07347b984ed185c0d8" translate="yes" xml:space="preserve">
          <source>Second, you can define multiple fields and the value you want to add to them.</source>
          <target state="translated">둘째, 여러 필드와 추가 할 값을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec7f6561b6ed5b2dc36973b0b6a102cca134bcc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;the validator.js project&lt;/a&gt; for more details on the built in validation methods.</source>
          <target state="translated">참조 &lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;validator.js 프로젝트&lt;/a&gt; 검증 방법 내장에 대한 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="07e8786ffa4a2d3cefb67f6c2682f38e69cd4492" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/sequelize/sequelize/issues/9421&quot;&gt;Issue #9421&lt;/a&gt; for the original API proposal.</source>
          <target state="translated">원래 API 제안에 대해서는 &lt;a href=&quot;https://github.com/sequelize/sequelize/issues/9421&quot;&gt;Issue # 9421&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1351883340089e7a2bcb762253ecf4041042e52a" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;Sequelize.Transaction.ISOLATION_LEVELS&lt;/code&gt; for possible options</source>
          <target state="translated">가능한 옵션 은 &lt;code&gt;Sequelize.Transaction.ISOLATION_LEVELS&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e4393e4d3bf760304fc86105ac68898ba048a63" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;Sequelize.Transaction.TYPES&lt;/code&gt; for possible options. Sqlite only.</source>
          <target state="translated">가능한 옵션 은 &lt;code&gt;Sequelize.Transaction.TYPES&lt;/code&gt; 를 참조하십시오 . Sqlite 만.</target>
        </trans-unit>
        <trans-unit id="3d323498fbf8da4d96a2d24a82b136e39ed2843c" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;save&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; 참조</target>
        </trans-unit>
        <trans-unit id="ace885d5833656cb1c6adb455769af99c14b9057" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;set&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 참조</target>
        </trans-unit>
        <trans-unit id="024d73cf82d16e67fc37c547b52a0b71943ce794" translate="yes" xml:space="preserve">
          <source>See aggregate</source>
          <target state="translated">집계 참조</target>
        </trans-unit>
        <trans-unit id="4bd3fe9b400efeaa997586b22cc7de7636c4dc47" translate="yes" xml:space="preserve">
          <source>See findAll options</source>
          <target state="translated">찾기 모든 옵션보기</target>
        </trans-unit>
        <trans-unit id="c877fd0b0a721c9f9e045768cc3bad7950900f4d" translate="yes" xml:space="preserve">
          <source>See more options in the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-method-query&quot;&gt;query API reference&lt;/a&gt;. Some examples below:</source>
          <target state="translated">&lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-method-query&quot;&gt;쿼리 API 참조&lt;/a&gt; 에서 추가 옵션을 참조하십시오 . 아래 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="497dea2253a9763272c1d3ca91776ece14a847f1" translate="yes" xml:space="preserve">
          <source>See:</source>
          <target state="translated">See:</target>
        </trans-unit>
        <trans-unit id="70fdde700db9f86cb1ddf1248d1df7f946f66ee1" translate="yes" xml:space="preserve">
          <source>Seed Storage</source>
          <target state="translated">종자 저장</target>
        </trans-unit>
        <trans-unit id="e0b6db6ffee2cbd17752e8f5ccec39fea1096673" translate="yes" xml:space="preserve">
          <source>Seeders can be undone if they are using any storage. There are two commands available for that:</source>
          <target state="translated">시더는 스토리지를 사용하는 경우 취소 할 수 있습니다. 사용할 수있는 두 가지 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5746f22dcc2f068faa833d6223ba0cc62b54931a" translate="yes" xml:space="preserve">
          <source>Select all the attributes of the model, except some few. Useful for security purposes e.g. &lt;code&gt;{ attributes: { exclude: ['password'] } }&lt;/code&gt;</source>
          <target state="translated">몇 가지를 제외하고 모델의 모든 속성을 선택하십시오. 보안 목적에 유용합니다. 예 : &lt;code&gt;{ attributes: { exclude: ['password'] } }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41a8019f87ab381882d8e3b6b81923fda67be63c" translate="yes" xml:space="preserve">
          <source>Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. &lt;code&gt;{ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] }&lt;/code&gt;</source>
          <target state="translated">모델의 모든 속성과 추가 속성을 선택하십시오. &lt;code&gt;{ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] }&lt;/code&gt; 과 같은 집계에 유용합니다 .}</target>
        </trans-unit>
        <trans-unit id="32248b4544c4dacee860f46416e5a89b6310bc5c" translate="yes" xml:space="preserve">
          <source>Sequelize</source>
          <target state="translated">Sequelize</target>
        </trans-unit>
        <trans-unit id="e2146c89a9fedc9608681248e18eec20d2a15b61" translate="yes" xml:space="preserve">
          <source>Sequelize CLI can read from both &lt;code&gt;JSON&lt;/code&gt; and &lt;code&gt;JS&lt;/code&gt; files. This can be setup with &lt;code&gt;.sequelizerc&lt;/code&gt; file. Let see how</source>
          <target state="translated">Sequelize CLI는 &lt;code&gt;JSON&lt;/code&gt; 및 &lt;code&gt;JS&lt;/code&gt; 파일 모두에서 읽을 수 있습니다. &lt;code&gt;.sequelizerc&lt;/code&gt; 파일 로 설정할 수 있습니다 . 방법을 보자</target>
        </trans-unit>
        <trans-unit id="d4e7d933f4662f9cc8cb13c8bed0106857a7e2e5" translate="yes" xml:space="preserve">
          <source>Sequelize Models are ES6 classes. You can very easily add custom instance or class level methods.</source>
          <target state="translated">Sequelize Model은 ES6 클래스입니다. 사용자 정의 인스턴스 또는 클래스 레벨 메소드를 매우 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42cba3a975a7135ac3fdb91096b3ca70b1caed5b" translate="yes" xml:space="preserve">
          <source>Sequelize allow setting &lt;code&gt;underscored&lt;/code&gt; option for Model. When &lt;code&gt;true&lt;/code&gt; this option will set the &lt;code&gt;field&lt;/code&gt; option on all attributes to the underscored version of its name. This also applies to foreign keys generated by associations.</source>
          <target state="translated">Sequelize에서는 모델에 &lt;code&gt;underscored&lt;/code&gt; 옵션을 설정할 수 있습니다. 때 &lt;code&gt;true&lt;/code&gt; 이 옵션을 설정합니다 &lt;code&gt;field&lt;/code&gt; 이름의 밑줄 버전의 모든 속성에 대한 옵션을 선택합니다. 이는 연결에 의해 생성 된 외래 키에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3618d92886b90e0ab93af574f3df0c6f87d7dfdb" translate="yes" xml:space="preserve">
          <source>Sequelize allows setting specific strings as aliases for operators. With v5 this will give you deprecation warning.</source>
          <target state="translated">Sequelize를 사용하면 특정 문자열을 연산자의 별칭으로 설정할 수 있습니다. v5에서는 사용 중단 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e1a257d276e4f1e9e9194ab2befc2ae82a6fdc63" translate="yes" xml:space="preserve">
          <source>Sequelize also defines by default the fields &lt;code&gt;id&lt;/code&gt; (primary key), &lt;code&gt;createdAt&lt;/code&gt; and &lt;code&gt;updatedAt&lt;/code&gt; to every model. This behavior can also be changed, of course (check the API Reference to learn more about the available options).</source>
          <target state="translated">Sequelize는 기본적 으로 모든 모델에 대해 &lt;code&gt;id&lt;/code&gt; 필드 (기본 키), &lt;code&gt;createdAt&lt;/code&gt; 및 &lt;code&gt;updatedAt&lt;/code&gt; 를 정의합니다. 물론이 동작은 변경 될 수 있습니다 (사용 가능한 옵션에 대한 자세한 내용은 API 참조를 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="721ff79958c22990fcc428727c9a1a0b30bc8dc9" translate="yes" xml:space="preserve">
          <source>Sequelize constructor</source>
          <target state="translated">시퀀시 생성자</target>
        </trans-unit>
        <trans-unit id="7b4a61bf7618bb5f80a735c5adcc86dc7d0d54b9" translate="yes" xml:space="preserve">
          <source>Sequelize doesn't create new datatypes in the database. This tutorial explains how to make Sequelize recognize new datatypes and assumes that those new datatypes are already created in the database.</source>
          <target state="translated">Sequelize는 데이터베이스에서 새 데이터 유형을 만들지 않습니다. 이 학습서에서는 Sequelize가 새 데이터 유형을 인식하도록하는 방법을 설명하고 해당 새 데이터 유형이 데이터베이스에 이미 작성되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4d7b6d0de168876f640bde5fff3cf527c4f93ef6" translate="yes" xml:space="preserve">
          <source>Sequelize exposes symbol operators that can be used for to create more complex comparisons -</source>
          <target state="translated">Sequelize는보다 복잡한 비교를 생성하는 데 사용할 수있는 기호 연산자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bfdf0968a46e379a3d919cbabea542fb8b4773b7" translate="yes" xml:space="preserve">
          <source>Sequelize follows &lt;a href=&quot;http://semver.org&quot;&gt;SEMVER&lt;/a&gt;. Supports Node v10 and above to use ES6 features.</source>
          <target state="translated">Sequelize는 &lt;a href=&quot;http://semver.org&quot;&gt;SEMVER를 따릅니다&lt;/a&gt; . ES6 기능을 사용하기 위해 Node v10 이상을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="582d78da6df00a995534b3b583b979009f68d4d2" translate="yes" xml:space="preserve">
          <source>Sequelize has a &lt;a href=&quot;https://github.com/sequelize/umzug&quot;&gt;sister library&lt;/a&gt; for programmatically handling execution and logging of migration tasks.</source>
          <target state="translated">Sequelize에는 프로그래밍 방식으로 마이그레이션 작업의 실행 및 로깅을 처리하기위한 &lt;a href=&quot;https://github.com/sequelize/umzug&quot;&gt;자매 라이브러리&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f211261e93475264da544d79e18f72b323197b2" translate="yes" xml:space="preserve">
          <source>Sequelize has a lot of options for querying. You will learn more about those in the next tutorials. It is also possible to make raw SQL queries, if you really need them.</source>
          <target state="translated">Sequelize에는 많은 쿼리 옵션이 있습니다. 다음 자습서에서 이에 대해 자세히 알아볼 것입니다. 실제로 필요한 경우 원시 SQL 쿼리를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7263ca838cabf21a169aeceea9b8f1d1793343c6" translate="yes" xml:space="preserve">
          <source>Sequelize has built-in support for optimistic locking through a model instance version count. Optimistic locking is disabled by default and can be enabled by setting the &lt;code&gt;version&lt;/code&gt; property to true in a specific model definition or global model configuration. See &lt;a href=&quot;models-definition#configuration&quot;&gt;model configuration&lt;/a&gt; for more details.</source>
          <target state="translated">Sequelize는 모델 인스턴스 버전 수를 통한 낙관적 잠금을 기본적으로 지원합니다. 낙관적 잠금은 기본적으로 비활성화 되어 있으며 특정 모델 정의 또는 전역 모델 구성에서 &lt;code&gt;version&lt;/code&gt; 속성을 true 로 설정하여 활성화 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;models-definition#configuration&quot;&gt;모델 구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a8d11578adeef3bffa53be612d3c8ec4ca15c7f" translate="yes" xml:space="preserve">
          <source>Sequelize has two different but related scope concepts in relation to associations. The difference is subtle but important:</source>
          <target state="translated">Sequelize에는 연관성과 관련하여 서로 다른 두 가지 범위 개념이 있습니다. 차이점은 미묘하지만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="4ba21fa010de136fd468609c0c7c0382ac4107cd" translate="yes" xml:space="preserve">
          <source>Sequelize is a promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server. It features solid transaction support, relations, eager and lazy loading, read replication and more.</source>
          <target state="translated">Sequelize는 Postgres, MySQL, MariaDB, SQLite 및 Microsoft SQL Server를위한 약속 기반 Node.js ORM입니다. 견고한 트랜잭션 지원, 관계, 열성 및 지연 로딩, 읽기 복제 등이 특징입니다.</target>
        </trans-unit>
        <trans-unit id="4f3657d8fd42ca903f769974a0aa3a98de7ae752" translate="yes" xml:space="preserve">
          <source>Sequelize is available via &lt;a href=&quot;https://www.npmjs.com/package/sequelize&quot;&gt;npm&lt;/a&gt; (or &lt;a href=&quot;https://yarnpkg.com/package/sequelize&quot;&gt;yarn&lt;/a&gt;).</source>
          <target state="translated">Sequelize는 &lt;a href=&quot;https://www.npmjs.com/package/sequelize&quot;&gt;npm&lt;/a&gt; (또는 &lt;a href=&quot;https://yarnpkg.com/package/sequelize&quot;&gt;원사&lt;/a&gt; )을 통해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="18b9d1b705db8b8f2a74b7b8fef93c710c1730a2" translate="yes" xml:space="preserve">
          <source>Sequelize is independent from specific dialects. This means that you'll have to install the respective connector library to your project yourself.</source>
          <target state="translated">후유증은 특정 방언과 무관합니다. 즉, 해당 커넥터 라이브러리를 프로젝트에 직접 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a6b2a1acf807c379b8c8b09642b38a4ae6ec2eb" translate="yes" xml:space="preserve">
          <source>Sequelize provides a host of custom error classes, to allow you to do easier debugging.</source>
          <target state="translated">Sequelize는 더 쉽게 디버깅 할 수 있도록 다양한 사용자 정의 오류 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2aa8bb1c410e7760da89fe1a39dd3cd6a3e6c8b6" translate="yes" xml:space="preserve">
          <source>Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor. All sequelize errors inherit from the base JS error object.</source>
          <target state="translated">Sequelize는 더 쉽게 디버깅 할 수 있도록 다양한 사용자 정의 오류 클래스를 제공합니다. 이러한 모든 오류는 sequelize 객체와 sequelize 생성자에 노출됩니다. 모든 연속 오류는 기본 JS 오류 객체에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="a36909b9f875b9c379cfbfd57865704470509efb" translate="yes" xml:space="preserve">
          <source>Sequelize provides four hooks that are executed immediately before and after a database connection is obtained or released:</source>
          <target state="translated">Sequelize는 데이터베이스 연결을 얻거나 해제하기 직전과 직후에 실행되는 네 가지 후크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e0048a920cbe256e0d63314bbc8a801ba350b416" translate="yes" xml:space="preserve">
          <source>Sequelize supports adding indexes to the model definition which will be created during &lt;code&gt;Model.sync()&lt;/code&gt; or &lt;code&gt;sequelize.sync&lt;/code&gt;.</source>
          <target state="translated">Sequelize는 &lt;code&gt;Model.sync()&lt;/code&gt; 또는 &lt;code&gt;sequelize.sync&lt;/code&gt; 중에 생성 될 모델 정의에 인덱스 추가를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e4b3b84765405016ac507be4f755d3663a4fd35c" translate="yes" xml:space="preserve">
          <source>Sequelize supports read replication, i.e. having multiple servers that you can connect to when you want to do a SELECT query. When you do read replication, you specify one or more servers to act as read replicas, and one server to act as the write master, which handles all writes and updates and propagates them to the replicas (note that the actual replication process is &lt;strong&gt;not&lt;/strong&gt; handled by Sequelize, but should be set up by database backend).</source>
          <target state="translated">Sequelize는 읽기 복제를 지원합니다. 예를 들어 SELECT 쿼리를 수행 할 때 연결할 수있는 여러 서버가 있습니다. 읽기 복제를 수행하면 읽기 복제본으로 작동 할 하나 이상의 서버와 쓰기 마스터로 작동 할 하나의 서버를 지정합니다.이 서버는 모든 쓰기 및 업데이트를 처리하고 복제본에 전파합니다 (실제 복제 프로세스는 처리 &lt;strong&gt;되지 않음에&lt;/strong&gt; 유의하십시오) Sequelize에 의해 작성되지만 데이터베이스 백엔드에 의해 설정되어야합니다).</target>
        </trans-unit>
        <trans-unit id="006e3c87cc46067f193d6da3dab1bfcaffa32b0b" translate="yes" xml:space="preserve">
          <source>Sequelize supports two ways of using transactions:</source>
          <target state="translated">Sequelize는 트랜잭션을 사용하는 두 가지 방법을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="036964a4746f86bd146c4ce057424fa1c7bc9c18" translate="yes" xml:space="preserve">
          <source>Sequelize uses a pool to manage connections to your replicas. Internally Sequelize will maintain two pools created using &lt;code&gt;pool&lt;/code&gt; configuration.</source>
          <target state="translated">Sequelize는 풀을 사용하여 복제본에 대한 연결을 관리합니다. 내부적으로 Sequelize는 &lt;code&gt;pool&lt;/code&gt; 구성을 사용하여 생성 된 두 개의 풀을 유지 관리 합니다.</target>
        </trans-unit>
        <trans-unit id="f3e08a634ed03d6ae6ccb3b71d35f62d841795e4" translate="yes" xml:space="preserve">
          <source>Sequelize v6 is the next major release after v5</source>
          <target state="translated">Sequelize v6은 v5 이후의 다음 주요 릴리스입니다.</target>
        </trans-unit>
        <trans-unit id="ccdb0706a39fddeebf0c225ab4959b82d3aa0355" translate="yes" xml:space="preserve">
          <source>Sequelize v6 will only support Node 10 and up &lt;a href=&quot;https://github.com/sequelize/sequelize/issues/10821&quot;&gt;#10821&lt;/a&gt;</source>
          <target state="translated">Sequelize v6은 노드 10 이상 만 지원합니다 &lt;a href=&quot;https://github.com/sequelize/sequelize/issues/10821&quot;&gt;# 10821&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c102a252e5d170808923d2726cbd5f00c38cafd" translate="yes" xml:space="preserve">
          <source>Sequelize will assume your table has a &lt;code&gt;id&lt;/code&gt; primary key property by default.</source>
          <target state="translated">Sequelize는 기본적으로 테이블에 &lt;code&gt;id&lt;/code&gt; 기본 키 속성 이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="6741146fb708be669cc08fc88bbcd0daae0ce352" translate="yes" xml:space="preserve">
          <source>Sequelize will keep the connection open by default, and use the same connection for all queries. If you need to close the connection, call &lt;code&gt;sequelize.close()&lt;/code&gt; (which is asynchronous and returns a Promise).</source>
          <target state="translated">Sequelize는 기본적으로 연결을 열어두고 모든 쿼리에 동일한 연결을 사용합니다. 연결을 닫아야하는 경우 &lt;code&gt;sequelize.close()&lt;/code&gt; 호출 하십시오 ( 비동기 적이며 약속을 반환 함).</target>
        </trans-unit>
        <trans-unit id="a12449a9563abf0e30ea48fb1e83208aaaae5d36" translate="yes" xml:space="preserve">
          <source>Sequelize will warn you if you're using the default aliases and not limiting them if you want to keep using all default aliases (excluding legacy ones) without the warning you can pass the following operatorsAliases option -</source>
          <target state="translated">경고없이 모든 기본 별칭 (기존 별칭 제외)을 계속 사용하려는 경우 기본 별칭을 사용하고 제한하지 않는 경우 Sequelize에서 경고합니다. 다음 연산자를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="552ca2f07a1fa7b5f7f41ab559cdc21d42d9ce70" translate="yes" xml:space="preserve">
          <source>Sequelize#fn</source>
          <target state="translated">Sequelize#fn</target>
        </trans-unit>
        <trans-unit id="61837406268cdb0d0b12c58a96e894f36f68cffc" translate="yes" xml:space="preserve">
          <source>Sequelize#query</source>
          <target state="translated">Sequelize#query</target>
        </trans-unit>
        <trans-unit id="c1b1daf0403c51efc06b9fcce975a7758d97a2aa" translate="yes" xml:space="preserve">
          <source>Sequelize-fixture</source>
          <target state="translated">Sequelize-fixture</target>
        </trans-unit>
        <trans-unit id="eed9460d8f90f2047f6e2bc967a20ec28c21c2e5" translate="yes" xml:space="preserve">
          <source>Sequelize-fixtures</source>
          <target state="translated">Sequelize-fixtures</target>
        </trans-unit>
        <trans-unit id="1a72bb27f77c646d89aab78edf53acbb911b806d" translate="yes" xml:space="preserve">
          <source>Sequelize.col</source>
          <target state="translated">Sequelize.col</target>
        </trans-unit>
        <trans-unit id="665023dac1be695aaeba85969fe1a94f8c091b07" translate="yes" xml:space="preserve">
          <source>Sequelize.define</source>
          <target state="translated">Sequelize.define</target>
        </trans-unit>
        <trans-unit id="730bfedd2958c7bec5b31d0621a9c26c5d74f1d4" translate="yes" xml:space="preserve">
          <source>Sequelize.fn and Sequelize.col returns functions and quoted column names</source>
          <target state="translated">Sequelize.fn 및 Sequelize.col은 함수와 인용 된 열 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78fe18b652a0073892cad047536d322fec1fca96" translate="yes" xml:space="preserve">
          <source>Sequelize.transaction</source>
          <target state="translated">Sequelize.transaction</target>
        </trans-unit>
        <trans-unit id="9dfa6b97e674513041a192d1bad9a14a9b372dd7" translate="yes" xml:space="preserve">
          <source>SequelizeScopeError</source>
          <target state="translated">SequelizeScopeError</target>
        </trans-unit>
        <trans-unit id="ae2472523ae42a6de56284d423ed256bd57c04c4" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;ON UPDATE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ON UPDATE&lt;/code&gt; 로 설정</target>
        </trans-unit>
        <trans-unit id="13bb92f3b76236bb6144fe9938c93ab1f1cbbd61" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;true&lt;/code&gt; to count only non-deleted records. Can be used on models with &lt;code&gt;paranoid&lt;/code&gt; enabled</source>
          <target state="translated">삭제되지 않은 레코드 만 계산하려면 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . &lt;code&gt;paranoid&lt;/code&gt; 활성화 된 모델에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="7afb64c86c07a6c269b9973a9ba25a4abf859068" translate="yes" xml:space="preserve">
          <source>Set can also be used to build instances for associations, if you have values for those. When using set with associations you need to make sure the property key matches the alias of the association while also making sure that the proper include options have been set (from .build() or .findOne())</source>
          <target state="translated">Set은 또한 값이있는 경우 연관 인스턴스를 빌드하는 데 사용될 수 있습니다. 연관과 함께 세트를 사용하는 경우 특성 키가 연관의 별명과 일치하는지 확인하고 올바른 포함 옵션이 설정되어 있는지 확인해야합니다 (.build () 또는 .findOne ()).</target>
        </trans-unit>
        <trans-unit id="166866de4829b605ddb977194d8b9388922cde2a" translate="yes" xml:space="preserve">
          <source>Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call &lt;code&gt;save&lt;/code&gt;).</source>
          <target state="translated">Set은 인스턴스의 값을 업데이트하는 데 사용됩니다 (인스턴스의 시퀀스 표현, 즉 실제로 &lt;code&gt;save&lt;/code&gt; 호출하기 전에 아무것도 유지되지 않음을 기억하십시오 ).</target>
        </trans-unit>
        <trans-unit id="c61e103be0166178bd44bf7b48ee8f40f2dad972" translate="yes" xml:space="preserve">
          <source>Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call &lt;code&gt;save&lt;/code&gt;). In its most basic form &lt;code&gt;set&lt;/code&gt; will update a value stored in the underlying &lt;code&gt;dataValues&lt;/code&gt; object. However, if a custom setter function is defined for the key, that function will be called instead. To bypass the setter, you can pass &lt;code&gt;raw: true&lt;/code&gt; in the options object.</source>
          <target state="translated">Set은 인스턴스의 값을 업데이트하는 데 사용됩니다 (인스턴스의 시퀀스 표현, 즉 실제로 호출하기 전에 아무것도 유지되지 않음을 기억하십시오) &lt;code&gt;save&lt;/code&gt; ). 가장 기본적인 형태의에서 &lt;code&gt;set&lt;/code&gt; 기본에 저장된 값을 업데이트합니다 &lt;code&gt;dataValues&lt;/code&gt; 의 개체를. 그러나 키에 대해 사용자 정의 설정 기 함수가 정의 된 경우 해당 함수가 대신 호출됩니다. setter를 무시하기 위해 options 객체에서 &lt;code&gt;raw: true&lt;/code&gt; 를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63bb957bd4f2485eebebbe454a8b69e791949044" translate="yes" xml:space="preserve">
          <source>Set name of the model. By default its same as Class name.</source>
          <target state="translated">모델명을 설정합니다. 기본적으로 클래스 이름과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fb94cec61d3a9dbb28107d775ffb15026c33626f" translate="yes" xml:space="preserve">
          <source>Set of flags that control when a query is automatically retried.</source>
          <target state="translated">쿼리가 자동으로 재 시도되는시기를 제어하는 ​​플래그 세트입니다.</target>
        </trans-unit>
        <trans-unit id="d3489274cb42c90bb36ad36d4038ec5bb58f7ba1" translate="yes" xml:space="preserve">
          <source>Set the associated model.</source>
          <target state="translated">연관된 모델을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cbde947d0c7d02a7c6c0d54175f289fc8bd46ae8" translate="yes" xml:space="preserve">
          <source>Set the associated models by passing an array of instances or their primary keys.</source>
          <target state="translated">인스턴스 또는 기본 키 배열을 전달하여 연관된 모델을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="28afce742822bda7ac3a2f32d5cd41e9419a35e7" translate="yes" xml:space="preserve">
          <source>Set the associated models by passing an array of instances or their primary keys. Everything that it not in the passed array will be un-associated.</source>
          <target state="translated">인스턴스 또는 기본 키 배열을 전달하여 연관된 모델을 설정하십시오. 전달 된 배열에없는 모든 항목은 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4659b18c90bdf2bdf8128c7828c1888d45a44b43" translate="yes" xml:space="preserve">
          <source>Set the associated models by passing an array of persisted instances or their primary keys.</source>
          <target state="translated">지속 형 인스턴스 또는 기본 키 배열을 전달하여 연관된 모델을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="068e7c3551ea386b519bbe3de0e4543eabfc2396" translate="yes" xml:space="preserve">
          <source>Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated</source>
          <target state="translated">지속 형 인스턴스 또는 기본 키 배열을 전달하여 연관된 모델을 설정하십시오. 전달 된 배열에없는 모든 항목은 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97d0bf148a15e487d3493ba0c0a64bd2ffe4c813" translate="yes" xml:space="preserve">
          <source>Set the constraints to not deferred. This is the default in PostgreSQL and it make it impossible to dynamically defer the constraints within a transaction.</source>
          <target state="translated">제한 조건이 지연되지 않도록 설정하십시오. 이것이 PostgreSQL의 기본값이며 트랜잭션 내에서 제약 조건을 동적으로 연기 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="107b4c048cafd6f18d89bbdc4fb5cd9bc242b490" translate="yes" xml:space="preserve">
          <source>Set the default transaction isolation level. See &lt;code&gt;Sequelize.Transaction.ISOLATION_LEVELS&lt;/code&gt; for possible options.</source>
          <target state="translated">기본 트랜잭션 격리 수준을 설정하십시오. &lt;code&gt;Sequelize.Transaction.ISOLATION_LEVELS&lt;/code&gt; 를 참조하십시오 .가능한 옵션 를 .</target>
        </trans-unit>
        <trans-unit id="8a7b3220b9496281536f2b1d365289c693c1b5dc" translate="yes" xml:space="preserve">
          <source>Set the default transaction type. See &lt;code&gt;Sequelize.Transaction.TYPES&lt;/code&gt; for possible options. Sqlite only.</source>
          <target state="translated">기본 거래 유형을 설정하십시오. &lt;code&gt;Sequelize.Transaction.TYPES&lt;/code&gt; 를 참조하십시오 .가능한 옵션 를 . Sqlite 만.</target>
        </trans-unit>
        <trans-unit id="e32c8401f834466947bfc307cba05a4f5d4d4ee8" translate="yes" xml:space="preserve">
          <source>Set the initial AUTO_INCREMENT value for the table in MySQL.</source>
          <target state="translated">MySQL에서 테이블의 초기 AUTO_INCREMENT 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2142490858241f5b04e051a62de526c24ed0e592" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;false&lt;/code&gt; to make table names and attributes case-insensitive on Postgres and skip double quoting of them. WARNING: Setting this to false may expose vulnerabilities and is not recommended!</source>
          <target state="translated">로 설정 &lt;code&gt;false&lt;/code&gt; 테이블 이름을 확인하고 포스트 그레스에 대소 문자를 구별 특성 및 그들의 인용을 두 번 건너 뜁니다. 경고 :이 값을 false로 설정하면 취약점이 노출 될 수 있으므로 권장하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="354c30cb0ad082bba494c5b29c973069e05d6c82" translate="yes" xml:space="preserve">
          <source>Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if &lt;code&gt;User.hasOne(Profile, {onDelete: 'cascade', hooks:true})&lt;/code&gt;, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks</source>
          <target state="translated">계단식으로 인해 연관된 모델이 삭제 될 때 before / afterDestroy 후크를 실행하려면 true로 설정하십시오. 예를 들어 &lt;code&gt;User.hasOne(Profile, {onDelete: 'cascade', hooks:true})&lt;/code&gt; 인 경우 사용자를 삭제하면 프로필의 before / afterDestroy 후크가 호출됩니다. 그렇지 않으면 후크를 호출하지 않고 프로파일이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1c4f50d2829a25de027786fbdce72e5b78d07194" translate="yes" xml:space="preserve">
          <source>Sets 'ON UPDATE'</source>
          <target state="translated">'ON UPDATE'설정</target>
        </trans-unit>
        <trans-unit id="8ba2182b55b33f33f3359d2be48577029cff400f" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;ON UPDATE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ON UPDATE&lt;/code&gt; 로 설정</target>
        </trans-unit>
        <trans-unit id="18972919efe0a74faf9c8fee85561d96ee6ef6d3" translate="yes" xml:space="preserve">
          <source>Sets the constraints to be deferred or immediately checked. PostgreSQL only</source>
          <target state="translated">구속 조건이 연기되거나 즉시 점검되도록 설정합니다. PostgreSQL 만</target>
        </trans-unit>
        <trans-unit id="fd789d936fbe1c06427e2b854a8677e439ab83d7" translate="yes" xml:space="preserve">
          <source>Sets the constraints to be deferred or immediately checked. See &lt;code&gt;Sequelize.Deferrable&lt;/code&gt;. PostgreSQL Only</source>
          <target state="translated">구속 조건이 연기되거나 즉시 점검되도록 설정합니다. &lt;code&gt;Sequelize.Deferrable&lt;/code&gt; 을 참조하십시오 . PostgreSQL 만</target>
        </trans-unit>
        <trans-unit id="0f49e7ccb9839aa302b4098fa4e81d7d66544064" translate="yes" xml:space="preserve">
          <source>Sets the isolation level of the transaction.</source>
          <target state="translated">트랜잭션의 격리 수준을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bdfc96c36f0f4dfb42251486fcfd7e6409571de8" translate="yes" xml:space="preserve">
          <source>Sets the query type to &lt;code&gt;SELECT&lt;/code&gt; and return a single row</source>
          <target state="translated">쿼리 유형을 &lt;code&gt;SELECT&lt;/code&gt; 로 설정하고 단일 행을 반환</target>
        </trans-unit>
        <trans-unit id="48e50206ef8d2f4278a730b2e028d7da0eeac616" translate="yes" xml:space="preserve">
          <source>Sets the type of the transaction. Sqlite only</source>
          <target state="translated">거래 유형을 설정합니다. Sqlite 만</target>
        </trans-unit>
        <trans-unit id="3d974d0bf03a57c01c4f20dcbb4527dcbfa503e9" translate="yes" xml:space="preserve">
          <source>Setting up a connection</source>
          <target state="translated">연결 설정</target>
        </trans-unit>
        <trans-unit id="f1f1f62ad1a95c21c649b09609e964e4f011ab41" translate="yes" xml:space="preserve">
          <source>Several other query types are available. &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/query-types.js&quot;&gt;Peek into the source for details&lt;/a&gt;</source>
          <target state="translated">몇 가지 다른 쿼리 유형을 사용할 수 있습니다. &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/query-types.js&quot;&gt;자세한 내용은 소스를 살펴보세요&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aea9a5880bd2b9832a731121a6d7390e206c1927" translate="yes" xml:space="preserve">
          <source>Several scopes can be applied simultaneously by passing an array of scopes to &lt;code&gt;.scope&lt;/code&gt;, or by passing the scopes as consecutive arguments.</source>
          <target state="translated">범위 배열을 &lt;code&gt;.scope&lt;/code&gt; 에 전달하거나 범위를 연속 인수로 전달하여 여러 범위를 동시에 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1cc34d5862bb6623cb8eb39094c2ba84d0c3557b" translate="yes" xml:space="preserve">
          <source>Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation</source>
          <target state="translated">각 행을 삽입하기 전에 유효성 검사를 받아야합니다. 하나의 행이 유효성 검사에 실패하면 전체 삽입이 실패합니다</target>
        </trans-unit>
        <trans-unit id="fccc812dc5f2a57c8829818b8c7f9aa953df663f" translate="yes" xml:space="preserve">
          <source>Should on update and on delete constraints be enabled on the foreign key.</source>
          <target state="translated">외래 키에서 업데이트 및 삭제시 제약 조건을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c55603b3eb9b5b1700bdfca388933033c5267cc" translate="yes" xml:space="preserve">
          <source>Should the index by unique? Can also be triggered by setting type to &lt;code&gt;UNIQUE&lt;/code&gt;</source>
          <target state="translated">인덱스는 고유해야합니까? 유형을 &lt;code&gt;UNIQUE&lt;/code&gt; 로 설정하여 트리거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9430fbff299935c8d01d77d60a80c20db8af97f" translate="yes" xml:space="preserve">
          <source>Should the join model have timestamps</source>
          <target state="translated">조인 모델에 타임 스탬프가 있어야합니다</target>
        </trans-unit>
        <trans-unit id="e89c05ba6758d6c1df5321149b427c4c24dc77a5" translate="yes" xml:space="preserve">
          <source>Show all defined schemas</source>
          <target state="translated">정의 된 모든 스키마 표시</target>
        </trans-unit>
        <trans-unit id="a8230afc301654f9c5847932109ae42f577ad544" translate="yes" xml:space="preserve">
          <source>Show all schemas</source>
          <target state="translated">모든 스키마 표시</target>
        </trans-unit>
        <trans-unit id="5c66f69bd4f8cb33cd2b7d50b7fe30afddb3d653" translate="yes" xml:space="preserve">
          <source>Similarly, it's also possible to remove a selected few attributes:</source>
          <target state="translated">마찬가지로 선택된 몇 가지 속성을 제거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="26f9660bf122890dd24a48101e8f7f0554e9803f" translate="yes" xml:space="preserve">
          <source>Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.</source>
          <target state="translated">마찬가지로 사용자 지정 특성이있는 조인 테이블을 통해 가져 오는 경우 이러한 특성을 통과 모델 이름을 가진 개체로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="696ea9d6cd2e74a5c976cb995c1b0d7d4e1edac0" translate="yes" xml:space="preserve">
          <source>Simple search using AND and =</source>
          <target state="translated">AND와 =를 사용한 간단한 검색</target>
        </trans-unit>
        <trans-unit id="8e0eaf977d4539a1c708998caf904e6bb9df2978" translate="yes" xml:space="preserve">
          <source>Since range types have extra information for their bound inclusion/exclusion it's not very straightforward to just use a tuple to represent them in javascript.</source>
          <target state="translated">범위 유형에는 바인딩 포함 / 제외에 대한 추가 정보가 있으므로 튜플을 사용하여 자바 스크립트로 표시하는 것은 매우 간단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b601167a7cd382d7cbe566ee42e4b7536768d3ad" translate="yes" xml:space="preserve">
          <source>Since v5, Sequelize provides its own TypeScript definitions. Please note that only TS &amp;gt;= 3.1 is supported.</source>
          <target state="translated">v5부터 Sequelize는 고유 한 TypeScript 정의를 제공합니다. TS&amp;gt; = 3.1 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f436c13844b216967ae563c043203b695079ce01" translate="yes" xml:space="preserve">
          <source>Since you are working with multiple models, the callbacks will not return DAO instances. BulkCreate will return an array of model instances/DAOs, they will however, unlike &lt;code&gt;create&lt;/code&gt;, not have the resulting values of autoIncrement attributes.&lt;code&gt;update&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt; will return the number of affected rows.</source>
          <target state="translated">여러 모델로 작업하므로 콜백은 DAO 인스턴스를 반환하지 않습니다. BulkCreate는 모델 인스턴스 / DAO의 배열을 반환하지만 &lt;code&gt;create&lt;/code&gt; 와 달리 autoIncrement 특성의 결과 값을 갖지 않습니다. &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;destroy&lt;/code&gt; 는 영향을받는 행 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d0a120c4b4160f315ab6b9691b248b295b04acec" translate="yes" xml:space="preserve">
          <source>Singular name for model</source>
          <target state="translated">모델의 단수 이름</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="dbe291e0d821c92f6b4f3902eec2a5914db65996" translate="yes" xml:space="preserve">
          <source>Skip locked rows. Only supported in Postgres.</source>
          <target state="translated">잠긴 행을 건너 뜁니다. Postgres에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b066e9f045fec6926b3eb8e24e878587821bf646" translate="yes" xml:space="preserve">
          <source>Skip saving this after setting the foreign key if false.</source>
          <target state="translated">false 인 경우 외래 키를 설정 한 후 저장하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9081562512b5ff709e3b937fef72e774f6407d16" translate="yes" xml:space="preserve">
          <source>Slugification</source>
          <target state="translated">Slugification</target>
        </trans-unit>
        <trans-unit id="e5e3a2d0b71e212514381c92fbda84f40194f41d" translate="yes" xml:space="preserve">
          <source>So far we dealt with a one-way association. But we want more! Let's define it the other way around by creating a many to many association in the next section.</source>
          <target state="translated">지금까지 우리는 일방적 인 협회를 다루었습니다. 그러나 우리는 더 많은 것을 원합니다! 다음 섹션에서 다 대다 연관을 만들어서 다른 방법으로 정의 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="4e42dc224648ef387be0eb7a267a923a15e1bc3c" translate="yes" xml:space="preserve">
          <source>So this enum name must follow this pattern &lt;code&gt;enum_&amp;lt;table_name&amp;gt;_&amp;lt;col_name&amp;gt;&lt;/code&gt;. If you are using &lt;code&gt;sync&lt;/code&gt; then correct name will automatically be generated.</source>
          <target state="translated">따라서이 열거 이름은이 패턴 &lt;code&gt;enum_&amp;lt;table_name&amp;gt;_&amp;lt;col_name&amp;gt;&lt;/code&gt; 을 따라야합니다 . &lt;code&gt;sync&lt;/code&gt; 사용하는 경우 를 올바른 이름이 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0e78ec0d8156cc0f2bf3c598c9044e39bfa2947e" translate="yes" xml:space="preserve">
          <source>Some data types have special properties that can be accessed in order to change the data type. For example, to get an unsigned integer with zerofill you can do &lt;code&gt;DataTypes.INTEGER.UNSIGNED.ZEROFILL&lt;/code&gt;. The order you access the properties in do not matter, so &lt;code&gt;DataTypes.INTEGER.ZEROFILL.UNSIGNED&lt;/code&gt; is fine as well.</source>
          <target state="translated">일부 데이터 유형에는 데이터 유형을 변경하기 위해 액세스 할 수있는 특수 특성이 있습니다. 예를 들어, 0으로 채워진 부호없는 정수를 얻으려면 &lt;code&gt;DataTypes.INTEGER.UNSIGNED.ZEROFILL&lt;/code&gt; 을 수행 할 수 있습니다 . 속성에 액세스하는 순서는 중요하지 않으므로 &lt;code&gt;DataTypes.INTEGER.ZEROFILL.UNSIGNED&lt;/code&gt; 도 좋습니다.</target>
        </trans-unit>
        <trans-unit id="47aac3e3ea46b8003010b5a72dada7a63be999b8" translate="yes" xml:space="preserve">
          <source>Some frameworks automatically parse user input into js objects and if you fail to sanitize your input it might be possible to inject an Object with string operators to Sequelize.</source>
          <target state="translated">일부 프레임 워크는 사용자 입력을 자동으로 js 객체로 구문 분석하고 입력을 위생 처리하지 않으면 문자열 연산자가 포함 된 객체를 Sequelize에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="506695fe4bca93a04e723ee3f23405d882143d94" translate="yes" xml:space="preserve">
          <source>Some scenarios where you can use it.</source>
          <target state="translated">사용할 수있는 일부 시나리오.</target>
        </trans-unit>
        <trans-unit id="45519e97c243c8c894e455e42e2f4ddf34c0f43c" translate="yes" xml:space="preserve">
          <source>Some tips around using CLI and migration setup in production environment.</source>
          <target state="translated">프로덕션 환경에서 CLI 및 마이그레이션 설정 사용에 대한 팁.</target>
        </trans-unit>
        <trans-unit id="cce1d48d901d42375d87783743924bc41a147483" translate="yes" xml:space="preserve">
          <source>Sometime you want to specify a dialectOption, if it's a general config you can just add it in &lt;code&gt;config/config.json&lt;/code&gt;. Sometime you want to execute some code to get dialectOptions, you should use dynamic config file for those cases.</source>
          <target state="translated">때로는 dialectOption을 지정하고 싶습니다. 일반 구성이라면 &lt;code&gt;config/config.json&lt;/code&gt; 에 추가 할 수 있습니다 . 때로는 dialectOptions를 얻기 위해 일부 코드를 실행하려는 경우 이러한 경우 동적 구성 파일을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e9158873a51d40de8fc8b6422e47f75fed10c82" translate="yes" xml:space="preserve">
          <source>Sometimes it may be tiresome to list all the attributes of the model if you only want to add an aggregation:</source>
          <target state="translated">집계 만 추가하려는 경우 모델의 모든 속성을 나열하는 것이 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c76c8272fccf13128629164c9a771b6e879c7bc4" translate="yes" xml:space="preserve">
          <source>Sometimes you may need to associate records on different columns, you may use &lt;code&gt;sourceKey&lt;/code&gt; option:</source>
          <target state="translated">때로는 다른 열의 레코드를 연결해야 할 수도 있습니다. &lt;code&gt;sourceKey&lt;/code&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84420187eb6990ad41032d3ccbebefd68bfee436" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to reference another table, without adding any constraints, or associations. In that case you can manually add the reference attributes to your schema definition, and mark the relations between them.</source>
          <target state="translated">제한 조건이나 연관을 추가하지 않고 다른 테이블을 참조하려는 경우가 있습니다. 이 경우 참조 속성을 스키마 정의에 수동으로 추가하고 이들 사이의 관계를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a4cd094326d31853e0865b4f6a87a79be6da8e" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to rename your models when using them in associations. Let's define users as workers and projects as tasks by using the alias (&lt;code&gt;as&lt;/code&gt;) option. We will also manually define the foreign keys to use:</source>
          <target state="translated">때때로 연관에서 사용할 때 모델의 이름을 바꾸려고 할 수 있습니다. 별명 ( &lt;code&gt;as&lt;/code&gt; ) 옵션 을 사용하여 사용자를 작업자 및 프로젝트로 작업으로 정의합시다 . 사용할 외래 키도 수동으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ca0f78496da4f38b504892d451c90fe377acf862" translate="yes" xml:space="preserve">
          <source>Sometimes you might be expecting a massive dataset that you just want to display, without manipulation. For each row you select, Sequelize creates an instance with functions for update, delete, get associations etc. If you have thousands of rows, this might take some time. If you only need the raw data and don't want to update anything, you can do like this to get the raw data.</source>
          <target state="translated">때로는 조작하지 않고 방금 표시하려는 방대한 데이터 세트를 기대할 수 있습니다. 선택한 각 행에 대해 Sequelize는 업데이트, 삭제, 연결 가져 오기 등의 기능이있는 인스턴스를 만듭니다. 수천 개의 행이있는 경우 시간이 다소 걸릴 수 있습니다. 원시 데이터 만 필요하고 아무것도 업데이트하지 않으려는 경우 원시 데이터를 가져 오기 위해 이와 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6e10c8d1ee0e110a949c1dd33ee734b90e8b619" translate="yes" xml:space="preserve">
          <source>Sometimes you'll be editing more than one record at a time by utilizing the &lt;code&gt;bulkCreate, update, destroy&lt;/code&gt; methods on the model. The following will emit whenever you're using one of those methods:</source>
          <target state="translated">모델 에서 &lt;code&gt;bulkCreate, update, destroy&lt;/code&gt; 메소드를 사용하여 한 번에 두 개 이상의 레코드를 편집하는 경우 가 있습니다. 이러한 방법 중 하나를 사용할 때마다 다음이 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="cec1acf567fe5032c7ccbe6f0c04bec9827cd692" translate="yes" xml:space="preserve">
          <source>Source &amp;amp; Target</source>
          <target state="translated">소스 및 대상</target>
        </trans-unit>
        <trans-unit id="7969aba3e7f08bea9e13ad506421e1ecfd565291" translate="yes" xml:space="preserve">
          <source>Source and target keys</source>
          <target state="translated">소스 및 대상 키</target>
        </trans-unit>
        <trans-unit id="d8a00d1571c48d768984321da51fe70137af999f" translate="yes" xml:space="preserve">
          <source>Source code of function</source>
          <target state="translated">기능의 소스 코드</target>
        </trans-unit>
        <trans-unit id="1499c6d6e22facebb12a10f560d4082a7ba88a6f" translate="yes" xml:space="preserve">
          <source>Source keys</source>
          <target state="translated">소스 키</target>
        </trans-unit>
        <trans-unit id="59f265692e8532f3f9f4cf8098a358d626fbb2eb" translate="yes" xml:space="preserve">
          <source>Special Cases</source>
          <target state="translated">특수한 상황들</target>
        </trans-unit>
        <trans-unit id="7610310be61095c09812768c8c3df51ade223444" translate="yes" xml:space="preserve">
          <source>Specified model</source>
          <target state="translated">지정된 모델</target>
        </trans-unit>
        <trans-unit id="ef957adb2faf323c7b629c9477baa8a72aec3b29" translate="yes" xml:space="preserve">
          <source>Specifies an ordering. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: &lt;code&gt;order: [['name', 'DESC']]&lt;/code&gt;. In this way the column will be escaped, but the direction will not.</source>
          <target state="translated">순서를 지정합니다. 배열을 사용하여 주문할 여러 열 / 함수를 제공 할 수 있습니다. 각 요소는 2 요소 배열로 더 래핑 될 수 있습니다. 첫 번째 요소는 정렬 할 열 / 함수이고 두 번째 요소는 방향입니다. 예를 들면 다음과 같습니다. &lt;code&gt;order: [['name', 'DESC']]&lt;/code&gt; . 이러한 방식으로 컬럼이 이스케이프되지만 방향은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab91a1aa22860a5be44f1c7d0e5a41f40ac0899d" translate="yes" xml:space="preserve">
          <source>Specify charset for model's table</source>
          <target state="translated">모델 테이블에 대한 문자셋 지정</target>
        </trans-unit>
        <trans-unit id="05c45a92124ec5ecf33e03c985ae55ccc15f268e" translate="yes" xml:space="preserve">
          <source>Specify collation for model's table</source>
          <target state="translated">모델 테이블의 데이터 정렬 지정</target>
        </trans-unit>
        <trans-unit id="6e7c3b352c76886bab8a11641294e51528c63905" translate="yes" xml:space="preserve">
          <source>Specify comment for model's table</source>
          <target state="translated">모델 테이블에 주석을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="6c874f64189ebc73fd18bd05f2dd405ac52c8396" translate="yes" xml:space="preserve">
          <source>Specify engine for model's table</source>
          <target state="translated">모델 테이블에 대한 엔진 지정</target>
        </trans-unit>
        <trans-unit id="93cb6f0d1b5094f7a606c75c41e39f3729456b42" translate="yes" xml:space="preserve">
          <source>Specify index operator.</source>
          <target state="translated">인덱스 연산자를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="1b468bd525de3aeadbdf80f3d9c458fbcaefa38a" translate="yes" xml:space="preserve">
          <source>Specifying Dialect Options</source>
          <target state="translated">방언 옵션 지정</target>
        </trans-unit>
        <trans-unit id="789445bbe2e230b404b0877611cb047ff79a2a8a" translate="yes" xml:space="preserve">
          <source>Start a transaction.</source>
          <target state="translated">거래를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="d18d875cf4fc5fcecf6b711eae14645c02d6e1f3" translate="yes" xml:space="preserve">
          <source>Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction @see &lt;a href=&quot;transaction.js~transaction&quot;&gt;Transaction&lt;/a&gt;</source>
          <target state="translated">거래를 시작하십시오. 트랜잭션을 사용하는 경우, 해당 트랜잭션 @see의에서 일어날 수있는 쿼리 위해서는 옵션 인수 거래를 통과해야 &lt;a href=&quot;transaction.js~transaction&quot;&gt;거래&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="767db5397ee3f3f1fc518ea59e55ef68e66c4e49" translate="yes" xml:space="preserve">
          <source>Start looking for any migration files which haven't run yet. This is possible by checking &lt;code&gt;SequelizeMeta&lt;/code&gt; table. In this case it will run &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; migration, which we created in last step.</source>
          <target state="translated">아직 실행되지 않은 마이그레이션 파일을 찾기 시작하십시오. &lt;code&gt;SequelizeMeta&lt;/code&gt; 테이블 을 확인하면 가능 합니다. 이 경우 마지막 단계에서 만든 &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; 마이그레이션을 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="3e2ca76b869d4fc44471d269e7d021b82eb5e2e7" translate="yes" xml:space="preserve">
          <source>Static Member Summary</source>
          <target state="translated">정적 멤버 요약</target>
        </trans-unit>
        <trans-unit id="93974c74e2583ae745e2a4d05185ce35cbce3dda" translate="yes" xml:space="preserve">
          <source>Static Method Summary</source>
          <target state="translated">정적 메소드 요약</target>
        </trans-unit>
        <trans-unit id="5d93069d69d10dd364cb5869055e39be7a82df7b" translate="yes" xml:space="preserve">
          <source>Static Public</source>
          <target state="translated">정적 공개</target>
        </trans-unit>
        <trans-unit id="071f6dc8b2e654ff72e19d9c2affa12acd8cad3b" translate="yes" xml:space="preserve">
          <source>Static Public Members</source>
          <target state="translated">정적 공개 멤버</target>
        </trans-unit>
        <trans-unit id="fd87df2a091c294a3be14e721270cc5cb9005586" translate="yes" xml:space="preserve">
          <source>Static Public Methods</source>
          <target state="translated">정적 퍼블릭 메소드</target>
        </trans-unit>
        <trans-unit id="e54d0c6ac86b830fabe7f13edf805a4e9b1dee3e" translate="yes" xml:space="preserve">
          <source>Static Public Summary</source>
          <target state="translated">정적 공개 요약</target>
        </trans-unit>
        <trans-unit id="9e092dda4f0e27d0c7686ddd00272079e678b6e6" translate="yes" xml:space="preserve">
          <source>Storage</source>
          <target state="translated">Storage</target>
        </trans-unit>
        <trans-unit id="65fa5a3000720098c1dca59b70a7d76a6fd2c4c2" translate="yes" xml:space="preserve">
          <source>String - will be quoted</source>
          <target state="translated">문자열-인용됩니다</target>
        </trans-unit>
        <trans-unit id="daceb9a0562946d158de84d0526f6149910187cc" translate="yes" xml:space="preserve">
          <source>String based operator alias. Pass object to limit set of aliased operators.</source>
          <target state="translated">문자열 기반 연산자 별명. 별명 연산자 세트를 제한하기 위해 오브젝트를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="6ada010a4af6877d578b83c2221b03cd216ad0ed" translate="yes" xml:space="preserve">
          <source>Such validation could have also been done with a custom validator defined on a single attribute (such as the &lt;code&gt;latitude&lt;/code&gt; attribute, by checking &lt;code&gt;(value === null) !== (this.longitude === null)&lt;/code&gt;), but the model-wide validation approach is cleaner.</source>
          <target state="translated">이러한 유효성 검사는 단일 속성 (예 : &lt;code&gt;(value === null) !== (this.longitude === null)&lt;/code&gt; ) 을 확인 하여 &lt;code&gt;latitude&lt;/code&gt; 속성 과 같은 단일 속성에 정의 된 사용자 지정 유효성 검사기로도 수행 할 수 있었지만 모델은 광범위한 검증 방법이 더 깨끗합니다.</target>
        </trans-unit>
        <trans-unit id="666e6b745c699158426c5ad099759c71dae3993c" translate="yes" xml:space="preserve">
          <source>Supply your own ON condition for the join.</source>
          <target state="translated">조인에 대한 자체 ON 조건을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="144046b1bd7badefc4d65fecc8afd75a78d5b865" translate="yes" xml:space="preserve">
          <source>Support for Node 10 and up</source>
          <target state="translated">노드 10 이상 지원</target>
        </trans-unit>
        <trans-unit id="cd906bb957f4dba88a7d677004f6055dd11d4afc" translate="yes" xml:space="preserve">
          <source>Suppose our &lt;code&gt;Player&lt;/code&gt; model has information about its team as &lt;code&gt;teamId&lt;/code&gt; column. Information about each Team's &lt;code&gt;Coach&lt;/code&gt; is stored in the &lt;code&gt;Team&lt;/code&gt; model as &lt;code&gt;coachId&lt;/code&gt; column. These both scenarios requires different kind of 1:1 relation because foreign key relation is present on different models each time.</source>
          <target state="translated">&lt;code&gt;Player&lt;/code&gt; 모델에 &lt;code&gt;teamId&lt;/code&gt; 열로 팀에 대한 정보가 있다고 가정하십시오 . 각 팀 &lt;code&gt;Coach&lt;/code&gt; 에 대한 정보 는 &lt;code&gt;Team&lt;/code&gt; 모델에 &lt;code&gt;coachId&lt;/code&gt; 열로 저장 됩니다. 외래 키 관계는 매번 다른 모델에 존재하기 때문에이 두 시나리오에는 서로 다른 종류의 1 : 1 관계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ef80b7fed8338d93416cd79ad36e89fa6b35d973" translate="yes" xml:space="preserve">
          <source>Suppose we have two tables to link &lt;strong&gt;Player&lt;/strong&gt; and &lt;strong&gt;Team&lt;/strong&gt;. Lets define their models.</source>
          <target state="translated">&lt;strong&gt;Player&lt;/strong&gt; 와 &lt;strong&gt;Team&lt;/strong&gt; 을 연결하는 두 개의 테이블이 있다고 가정하십시오 . 모델을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d1b98193b4347c9a63a9bbb4d39a13215749194" translate="yes" xml:space="preserve">
          <source>Suppose we want to insert some data into a few tables by default. If we follow up on previous example we can consider creating a demo user for &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">기본적으로 일부 데이터를 몇 개의 테이블에 삽입하려고한다고 가정하십시오. 이전 예제를 따라 가면 &lt;code&gt;User&lt;/code&gt; 테이블에 대한 데모 사용자를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63f13894b7179290120a467d9f756197261eb48d" translate="yes" xml:space="preserve">
          <source>Suppose you want to find all users who have a profile attached:</source>
          <target state="translated">프로파일이 첨부 된 모든 사용자를 찾으려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="1e4961c4fd4c50f3974bcbc462ffabf9d11b7e41" translate="yes" xml:space="preserve">
          <source>Sync all defined models to the DB.</source>
          <target state="translated">정의 된 모든 모델을 DB에 동기화하십시오.</target>
        </trans-unit>
        <trans-unit id="d295b7c124f450a0ae7db9e0dd4371d5a908e16c" translate="yes" xml:space="preserve">
          <source>Sync this Model to the DB, that is create the table.</source>
          <target state="translated">이 모델을 DB와 동기화하면 테이블이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="49b4cf438c26e221dcf5c35f1bb5388e58acc6de" translate="yes" xml:space="preserve">
          <source>Synchronizing all models at once</source>
          <target state="translated">모든 모델을 한 번에 동기화</target>
        </trans-unit>
        <trans-unit id="7754c8e786d3eca650ff1b582693fa0714a38764" translate="yes" xml:space="preserve">
          <source>Synchronizing the model with the database</source>
          <target state="translated">데이터베이스와 모델 동기화</target>
        </trans-unit>
        <trans-unit id="e834f99dcb78400f4c128fb50e4f83eea4bd65b6" translate="yes" xml:space="preserve">
          <source>TABLOCK</source>
          <target state="translated">TABLOCK</target>
        </trans-unit>
        <trans-unit id="dcb435e28d2012463d8e6def6d52b91b7d81a93f" translate="yes" xml:space="preserve">
          <source>TABLOCKX</source>
          <target state="translated">TABLOCKX</target>
        </trans-unit>
        <trans-unit id="7d4e42ef9d04a046b5679f952cb0b6b5c498c73c" translate="yes" xml:space="preserve">
          <source>TEXT</source>
          <target state="translated">TEXT</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="4fe5a3682f8029783789ec9b3abba10f67f03ffa" translate="yes" xml:space="preserve">
          <source>TINYINT</source>
          <target state="translated">TINYINT</target>
        </trans-unit>
        <trans-unit id="521cc63843abd0f34c261968e1d32a7dc9f6c198" translate="yes" xml:space="preserve">
          <source>Table Hint</source>
          <target state="translated">테이블 힌트</target>
        </trans-unit>
        <trans-unit id="22ba75a57550188d799bd1e025b7db1fda0a2d3e" translate="yes" xml:space="preserve">
          <source>Table hints override the default behavior of mssql query optimizer by specifing certain options. They only affect the table or view referenced in that clause.</source>
          <target state="translated">테이블 힌트는 특정 옵션을 지정하여 mssql 쿼리 최적화 프로그램의 기본 동작을 재정의합니다. 해당 절에서 참조 된 테이블이나 뷰에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="0cb75dbc5813b569590e4ea143ce823027afbc1b" translate="yes" xml:space="preserve">
          <source>Table name to add index on, can be a object with schema</source>
          <target state="translated">인덱스를 추가 할 테이블 이름이며 스키마가있는 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fab7b43bc054cab875b79b2a0d5940d09c13933" translate="yes" xml:space="preserve">
          <source>Table name to change from</source>
          <target state="translated">변경할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="2cdfba3e5bff8000906d5f3be065833e214bd7be" translate="yes" xml:space="preserve">
          <source>Table name to drop</source>
          <target state="translated">제거 할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="a0d7075f146f8e02ece5c3b5bc8db30590e1c72b" translate="yes" xml:space="preserve">
          <source>Table name to drop constraint from</source>
          <target state="translated">제한 조건을 제거 할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="45bc0fc9921d956e87501c72f3c69e96310abf0b" translate="yes" xml:space="preserve">
          <source>Table name to drop index from</source>
          <target state="translated">인덱스를 제거 할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="b0e1e1e10f09068f7cae45a1dace79b0d9a82486" translate="yes" xml:space="preserve">
          <source>Table name to insert record to</source>
          <target state="translated">레코드를 삽입 할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="f255cd8680539b5bbf5bb6cf0e61d456d5c89103" translate="yes" xml:space="preserve">
          <source>Table name to update</source>
          <target state="translated">업데이트 할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="dd22d9e56c5cb140764fa721de7a45f25fe6d977" translate="yes" xml:space="preserve">
          <source>Table name where you want to add a constraint</source>
          <target state="translated">제약 조건을 추가하려는 테이블 이름</target>
        </trans-unit>
        <trans-unit id="25ca34d81d29fd398bf9c4ba66b56be70861a874" translate="yes" xml:space="preserve">
          <source>Table name whose column to rename</source>
          <target state="translated">열 이름을 바꿀 테이블 이름</target>
        </trans-unit>
        <trans-unit id="dbed374b26ccca4bdab96f82c9f48630ce076773" translate="yes" xml:space="preserve">
          <source>Table name, for backward compatibility</source>
          <target state="translated">이전 버전과의 호환성을위한 테이블 이름</target>
        </trans-unit>
        <trans-unit id="d210072aac6aa90c45934daef475a90e10b81e26" translate="yes" xml:space="preserve">
          <source>Table to add column to</source>
          <target state="translated">열을 추가 할 테이블</target>
        </trans-unit>
        <trans-unit id="8ebb87b4f0d6b0bd82f500cb89d5d63fe2b3bb66" translate="yes" xml:space="preserve">
          <source>Table to remove column from</source>
          <target state="translated">열을 제거 할 테이블</target>
        </trans-unit>
        <trans-unit id="c30f8dfdb7e7408d778802c6ee43b43deb695358" translate="yes" xml:space="preserve">
          <source>TableHints</source>
          <target state="translated">TableHints</target>
        </trans-unit>
        <trans-unit id="193daf137ed8b89de36d47c3df5fd8f66c0e1d14" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="translated">Tables</target>
        </trans-unit>
        <trans-unit id="e396b94e25d4b0c0ef34b12c624dbfa7272476fb" translate="yes" xml:space="preserve">
          <source>Target column name</source>
          <target state="translated">대상 열 이름</target>
        </trans-unit>
        <trans-unit id="975ce3d3070b51cecd838e1da8d21e0ef5ce9336" translate="yes" xml:space="preserve">
          <source>Target keys</source>
          <target state="translated">대상 키</target>
        </trans-unit>
        <trans-unit id="5c068aa69f6d4ef42a8389abe9cd810232caae05" translate="yes" xml:space="preserve">
          <source>Target model</source>
          <target state="translated">대상 모델</target>
        </trans-unit>
        <trans-unit id="2f66e0e68c2c913dd1bf905e22855cbb450958e6" translate="yes" xml:space="preserve">
          <source>Target table name</source>
          <target state="translated">대상 테이블 이름</target>
        </trans-unit>
        <trans-unit id="0672d7ed7ed6afdfd270b53235aa08ccc0eed98a" translate="yes" xml:space="preserve">
          <source>Test the connection by trying to authenticate.</source>
          <target state="translated">인증을 시도하여 연결을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="20b77d389f5e8c5e987282b922a807df1f9260e2" translate="yes" xml:space="preserve">
          <source>Test the connection by trying to authenticate. It runs &lt;code&gt;SELECT 1+1 AS result&lt;/code&gt; query.</source>
          <target state="translated">인증을 시도하여 연결을 테스트하십시오. &lt;code&gt;SELECT 1+1 AS result&lt;/code&gt; 쿼리를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="e0143c072d5ac7b543f7a97b25b22cf87a465c03" translate="yes" xml:space="preserve">
          <source>Testing the connection</source>
          <target state="translated">연결 테스트</target>
        </trans-unit>
        <trans-unit id="c363795bd7fa8fcfababae3f9976a3e94d298a31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.sequelizerc&lt;/code&gt; File</source>
          <target state="translated">&lt;code&gt;.sequelizerc&lt;/code&gt; 의 파일</target>
        </trans-unit>
        <trans-unit id="52fdd6c7b19c53e9c7650c11a173d0518be4c70c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHAR&lt;/code&gt; and &lt;code&gt;STRING&lt;/code&gt; types expose the &lt;code&gt;BINARY&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;CHAR&lt;/code&gt; 및 &lt;code&gt;STRING&lt;/code&gt; 유형은 노출 &lt;code&gt;BINARY&lt;/code&gt; 속성을</target>
        </trans-unit>
        <trans-unit id="96604eb0bb158befed8a640da0e7f3054be98f32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fullName&lt;/code&gt; getter, is an example of how you can define pseudo properties on your models - attributes which are not actually part of your database schema. In fact, pseudo properties can be defined in two ways: using model getters, or by using a column with the &lt;a href=&quot;https://sequelize.org/variable/index.html#static-variable-DataTypes&quot;&gt;&lt;code&gt;VIRTUAL&lt;/code&gt; datatype&lt;/a&gt;. Virtual datatypes can have validations, while getters for virtual attributes cannot.</source>
          <target state="translated">&lt;code&gt;fullName&lt;/code&gt; 의의 실제 데이터베이스 스키마의 일부가 아닌 속성 - 게터는, 당신이 당신의 모델에 의사의 속성을 정의 할 수있는 방법의 예입니다. 실제로 의사 특성은 두 가지 방법으로 정의 될 수 있습니다. 모델 게터 사용 또는 &lt;a href=&quot;https://sequelize.org/variable/index.html#static-variable-DataTypes&quot;&gt; &lt;code&gt;VIRTUAL&lt;/code&gt; 데이터 유형&lt;/a&gt; 의 열 사용 . 가상 데이터 유형에는 유효성 검사가 가능하지만 가상 속성에 대한 Getter는 유효성 검사가 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="b44f8380a2468cdb72b9deb6e94e4793fc900145" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getItem&lt;/code&gt; utility function on &lt;code&gt;Comment&lt;/code&gt; completes the picture - it simply converts the &lt;code&gt;commentable&lt;/code&gt; string into a call to either &lt;code&gt;getImage&lt;/code&gt; or &lt;code&gt;getPost&lt;/code&gt;, providing an abstraction over whether a comment belongs to a post or an image. You can pass a normal options object as a parameter to &lt;code&gt;getItem(options)&lt;/code&gt; to specify any where conditions or includes.</source>
          <target state="translated">&lt;code&gt;Comment&lt;/code&gt; 의 &lt;code&gt;getItem&lt;/code&gt; 유틸리티 함수 는 그림을 완성합니다. &lt;code&gt;commentable&lt;/code&gt; 문자열을 &lt;code&gt;getImage&lt;/code&gt; 또는 &lt;code&gt;getPost&lt;/code&gt; 호출로 변환하여 주석 이 게시물 또는 이미지에 속하는지 여부에 대한 추상화를 제공합니다. 일반 옵션 오브젝트를 매개 변수로 &lt;code&gt;getItem(options)&lt;/code&gt; 하여 위치 또는 조건을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5af38db2b9d87be8fca742043ab85cd54ed8644" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; method can also accept a callback as an argument.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 방법은 인수로 콜백을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c66c416ba19dd8a604d0fa8c48849d0b7770c55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isolationLevel&lt;/code&gt; can either be set globally when initializing the Sequelize instance or locally for every transaction:</source>
          <target state="translated">&lt;code&gt;isolationLevel&lt;/code&gt; 는 모든 트랜잭션에 대한 로컬 Sequelize 인스턴스를 초기화하거나 전역으로 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="aded916b2d52b83cbd3a306bbcaac58553342812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; argument of hook method would be the second argument provided to the corresponding method or its cloned and extended version.</source>
          <target state="translated">hook 메소드 의 &lt;code&gt;options&lt;/code&gt; 인수는 해당 메소드 또는 복제 및 확장 버전에 제공된 두 번째 인수입니다.</target>
        </trans-unit>
        <trans-unit id="6e08cedd8bd068ee0e858ac36cf905e6a6544cca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transaction&lt;/code&gt; option goes with most other options, which are usually the first argument of a method. For methods that take values, like &lt;code&gt;.create&lt;/code&gt;, &lt;code&gt;.update()&lt;/code&gt;, etc. &lt;code&gt;transaction&lt;/code&gt; should be passed to the option in the second argument. If unsure, refer to the API documentation for the method you are using to be sure of the signature.</source>
          <target state="translated">&lt;code&gt;transaction&lt;/code&gt; 옵션은 일반적으로 방법의 첫 번째 인수 대부분의 다른 옵션으로 이동합니다. 같은 값을 메소드의 &lt;code&gt;.create&lt;/code&gt; , &lt;code&gt;.update()&lt;/code&gt; 등의 &lt;code&gt;transaction&lt;/code&gt; 두 번째 인수에 옵션을 전달해야합니다. 확실하지 않은 경우 서명을 확인하는 데 사용하는 방법에 대한 API 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b9b49b97c6dcd275458969fdd514038c0782971" translate="yes" xml:space="preserve">
          <source>The BLOB datatype allows you to insert data both as strings and as buffers. When you do a find or findAll on a model which has a BLOB column, that data will always be returned as a buffer.</source>
          <target state="translated">BLOB 데이터 유형을 사용하면 데이터를 문자열과 버퍼로 삽입 할 수 있습니다. BLOB 열이있는 모델에서 find 또는 findAll을 수행하면 해당 데이터는 항상 버퍼로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0d6ca5d74c8816ae0ded15e2a7a5beeecbf88579" translate="yes" xml:space="preserve">
          <source>The CLI</source>
          <target state="translated">CLI</target>
        </trans-unit>
        <trans-unit id="7543057877a60db6d5a05a1ccb4e14c360eef266" translate="yes" xml:space="preserve">
          <source>The DAO instance that caused the validation error</source>
          <target state="translated">유효성 검사 오류를 일으킨 DAO 인스턴스</target>
        </trans-unit>
        <trans-unit id="5c2f82b73e030655c59432ce481b35adff70c042" translate="yes" xml:space="preserve">
          <source>The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes</source>
          <target state="translated">INET 유형에는 IPv4 또는 IPv6 호스트 주소와 선택적으로 해당 서브넷이 있습니다. 7 또는 19 바이트 소요</target>
        </trans-unit>
        <trans-unit id="35c885e3e1208b7964c450f516be8caa8371b964" translate="yes" xml:space="preserve">
          <source>The JSON data type in PostgreSQL stores the value as plain text, as opposed to binary representation. If you simply want to store and retrieve a JSON representation, using JSON will take less disk space and less time to build from its input representation. However, if you want to do any operations on the JSON value, you should prefer the JSONB data type described below.</source>
          <target state="translated">PostgreSQL의 JSON 데이터 형식은 이진 표현이 아닌 일반 텍스트로 값을 저장합니다. 단순히 JSON 표현을 저장하고 검색하려는 경우 JSON을 사용하면 입력 표현에서 작성하는 데 필요한 디스크 공간과 시간이 줄어 듭니다. 그러나 JSON 값에 대한 조작을 수행하려면 아래 설명 된 JSONB 데이터 유형을 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f1ca89726cfb75c61b955405275bfa81fa8f0e1" translate="yes" xml:space="preserve">
          <source>The JSON data type is supported by the PostgreSQL, SQLite, MySQL and MariaDB dialects only.</source>
          <target state="translated">JSON 데이터 유형은 PostgreSQL, SQLite, MySQL 및 MariaDB 방언에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b4c18d45f4c7b31dc5aabb26fb9a9e22f31ce7cc" translate="yes" xml:space="preserve">
          <source>The MACADDR type stores MAC addresses. Takes 6 bytes</source>
          <target state="translated">MACADDR 유형은 MAC 주소를 저장합니다. 6 바이트 소요</target>
        </trans-unit>
        <trans-unit id="6e037bc95bcf7d5b574c2d17b15f920746d615f7" translate="yes" xml:space="preserve">
          <source>The PostgreSQL &lt;code&gt;client_min_messages&lt;/code&gt; session parameter. Set to &lt;code&gt;false&lt;/code&gt; to not override the database's default.</source>
          <target state="translated">PostgreSQL &lt;code&gt;client_min_messages&lt;/code&gt; 세션 매개 변수입니다. 데이터베이스의 기본값을 무시하지 않으 려면 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="92dcd073ff1557550a8981af1e6e839e5e4fae74" translate="yes" xml:space="preserve">
          <source>The PostgreSQL &lt;code&gt;standard_conforming_strings&lt;/code&gt; session parameter. Set to &lt;code&gt;false&lt;/code&gt; to not set the option. WARNING: Setting this to false may expose vulnerabilities and is not recommended!</source>
          <target state="translated">PostgreSQL &lt;code&gt;standard_conforming_strings&lt;/code&gt; 세션 매개 변수입니다. 옵션을 설정하지 않으 려면 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오. 경고 :이 값을 false로 설정하면 취약점이 노출 될 수 있으므로 권장하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="ea2917bca3214c2f94009ee7f7e0ef5cef7ed728" translate="yes" xml:space="preserve">
          <source>The SQL that triggered the error</source>
          <target state="translated">오류를 유발 한 SQL</target>
        </trans-unit>
        <trans-unit id="fdfcd4dec9f023d328d1c29bf2ce667d576056f9" translate="yes" xml:space="preserve">
          <source>The Sequelize constructor takes a &lt;code&gt;define&lt;/code&gt; option which will change the default options for all defined models.</source>
          <target state="translated">Sequelize 생성자는 &lt;code&gt;define&lt;/code&gt; 옵션을 사용하여 정의 된 모든 모델의 기본 옵션을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f021a2b45ae6896b6bc054e8bd5ccd034b732703" translate="yes" xml:space="preserve">
          <source>The Sequelize constructor takes a whole slew of options that are documented in the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;API Reference for the Sequelize constructor&lt;/a&gt;.</source>
          <target state="translated">Sequelize 생성자는 Sequelize 생성자에 대한 &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;API 참조 서에&lt;/a&gt; 설명 된 다양한 옵션을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c3f32fc062713c89992127673f0ff266e4a6d880" translate="yes" xml:space="preserve">
          <source>The above code tells Sequelize to expect a table named &lt;code&gt;users&lt;/code&gt; in the database with the fields &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt;. The table name is automatically pluralized by default (a library called &lt;a href=&quot;https://www.npmjs.com/package/inflection&quot;&gt;inflection&lt;/a&gt; is used under the hood to do this). This behavior can be stopped for a specific model by using the &lt;code&gt;freezeTableName: true&lt;/code&gt; option, or for all models by using the &lt;code&gt;define&lt;/code&gt; option from the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;Sequelize constructor&lt;/a&gt;.</source>
          <target state="translated">위의 코드는 Sequelize에게 &lt;code&gt;firstName&lt;/code&gt; 및 &lt;code&gt;lastName&lt;/code&gt; 필드를 가진 데이터베이스에서 &lt;code&gt;users&lt;/code&gt; 라는 테이블을 예상하도록 지시 합니다. 테이블 이름이 자동으로 (라이브러리라는 기본적으로 복수로되는 &lt;a href=&quot;https://www.npmjs.com/package/inflection&quot;&gt;변곡점이&lt;/a&gt; 이렇게 후드 사용된다). 이 동작은 &lt;code&gt;freezeTableName: true&lt;/code&gt; 옵션 을 사용하여 특정 모델 또는 &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;Sequelize 생성자&lt;/a&gt; 의 &lt;code&gt;define&lt;/code&gt; 옵션을 사용하여 모든 모델에 대해 중지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f72de844a359ac7b2754481a3ae1e21505a5382" translate="yes" xml:space="preserve">
          <source>The alias of the relation, in case the model you want to eagerly load is aliased. For &lt;code&gt;hasOne&lt;/code&gt; / &lt;code&gt;belongsTo&lt;/code&gt;, this should be the singular name, and for &lt;code&gt;hasMany&lt;/code&gt;, it should be the plural</source>
          <target state="translated">간절히로드하려는 모델의 별칭이 지정된 경우 관계의 별칭입니다. 들어 &lt;code&gt;hasOne&lt;/code&gt; 의 / &lt;code&gt;belongsTo&lt;/code&gt; 를 ,이 단수 이름이어야하고, 위해 &lt;code&gt;hasMany&lt;/code&gt; , 그것은 복수해야한다</target>
        </trans-unit>
        <trans-unit id="99efeea290301860aca947970c356a75d984412b" translate="yes" xml:space="preserve">
          <source>The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with &lt;code&gt;plural&lt;/code&gt; and &lt;code&gt;singular&lt;/code&gt; keys. See also the &lt;code&gt;name&lt;/code&gt; option passed to &lt;code&gt;sequelize.define&lt;/code&gt;. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target</source>
          <target state="translated">이 연관의 별명. 문자열을 제공하면 복수 여야하며 node.inflection을 사용하여 단 수화됩니다. 단일 버전을 직접 제어하려면 객체에 &lt;code&gt;plural&lt;/code&gt; 및 &lt;code&gt;singular&lt;/code&gt; 키를 제공하십시오. &lt;code&gt;sequelize.define&lt;/code&gt; 에 전달 된 &lt;code&gt;name&lt;/code&gt; 옵션 도 참조하십시오 . 동일한 테이블간에 여러 개의 연관을 작성하는 경우이를 구별 할 수 있도록 별명을 제공해야합니다. 연관을 작성할 때 별명을 제공하는 경우,로드가 열리고 연관 모델을 가져올 때 동일한 별명을 제공해야합니다. 복수의 대상 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b8b5837eb09b93962a6de59344369c9b2dc0dea6" translate="yes" xml:space="preserve">
          <source>The alias of this model, in singular form. See also the &lt;code&gt;name&lt;/code&gt; option passed to &lt;code&gt;sequelize.define&lt;/code&gt;. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target</source>
          <target state="translated">이 모델의 별명은 단일 형식입니다. &lt;code&gt;sequelize.define&lt;/code&gt; 에 전달 된 &lt;code&gt;name&lt;/code&gt; 옵션 도 참조하십시오 . 동일한 테이블간에 여러 개의 연관을 작성하는 경우이를 구별 할 수 있도록 별명을 제공해야합니다. 연관을 작성할 때 별명을 제공하는 경우,로드가 열리고 연관 모델을 가져올 때 동일한 별명을 제공해야합니다. 단일 대상 이름으로 기본 설정</target>
        </trans-unit>
        <trans-unit id="6fcf9c630d31ebc1d75eae65eb6c73992888621e" translate="yes" xml:space="preserve">
          <source>The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with &lt;code&gt;plural&lt;/code&gt; and &lt;code&gt;singular&lt;/code&gt; keys. See also the &lt;code&gt;name&lt;/code&gt; option passed to &lt;code&gt;sequelize.define&lt;/code&gt;. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target</source>
          <target state="translated">이 모델의 별명입니다. 문자열을 제공하면 문자열이 복수 여야하며 node.inflection을 사용하여 단일화됩니다. 단일 버전을 직접 제어하려면 객체에 &lt;code&gt;plural&lt;/code&gt; 및 &lt;code&gt;singular&lt;/code&gt; 키를 제공하십시오. &lt;code&gt;sequelize.define&lt;/code&gt; 에 전달 된 &lt;code&gt;name&lt;/code&gt; 옵션 도 참조하십시오 . 동일한 테이블간에 여러 개의 연관을 작성하는 경우이를 구별 할 수 있도록 별명을 제공해야합니다. 연관을 작성할 때 별명을 제공하는 경우,로드가 필요할 때와 연관된 모델을 가져올 때 동일한 별명을 제공해야합니다. 복수의 대상 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="6723f18b3bbf968c425605ca9dc759577bfe8738" translate="yes" xml:space="preserve">
          <source>The array or object must contain all bound values or Sequelize will throw an exception. This applies even to cases in which the database may ignore the bound parameter.</source>
          <target state="translated">배열이나 객체는 모든 바운드 값을 포함해야합니다. 그렇지 않으면 Sequelize에서 예외가 발생합니다. 이는 데이터베이스가 바운드 매개 변수를 무시할 수있는 경우에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0ad94612989aa9f318b27d4d20664339044c9613" translate="yes" xml:space="preserve">
          <source>The association you want to eagerly load. (This can be used instead of providing a model/as pair)</source>
          <target state="translated">열심히로드하려는 연결입니다. (이것은 모델을 제공하는 대신 / 쌍으로 사용할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="eeb0e6deb9b0e80d8f8265fdbac4c078f3171b7b" translate="yes" xml:space="preserve">
          <source>The attr can either be an object taken from &lt;code&gt;Model.rawAttributes&lt;/code&gt; (for example &lt;code&gt;Model.rawAttributes.id&lt;/code&gt; or &lt;code&gt;Model.rawAttributes.name&lt;/code&gt;). The attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions (&lt;code&gt;sequelize.fn&lt;/code&gt;, &lt;code&gt;sequelize.col&lt;/code&gt; etc.)</source>
          <target state="translated">attr은 &lt;code&gt;Model.rawAttributes&lt;/code&gt; 에서 가져온 객체 (예 : &lt;code&gt;Model.rawAttributes.id&lt;/code&gt; 또는 &lt;code&gt;Model.rawAttributes.name&lt;/code&gt; ) 일 수 있습니다. 속성은 모델 정의에서 정의해야합니다. 이 속성은 sequelize 유틸리티 함수 ( &lt;code&gt;sequelize.fn&lt;/code&gt; , &lt;code&gt;sequelize.col&lt;/code&gt; 등) 중 하나의 객체 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f1a633ffadc1e2c2bc95e3c735fd1cf866d44c8" translate="yes" xml:space="preserve">
          <source>The attribute to aggregate over. Can be a field name or *</source>
          <target state="translated">집계 할 속성입니다. 필드 이름이거나 * 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22739ed01f959f4fdce30289f8b662f6f4a480e5" translate="yes" xml:space="preserve">
          <source>The attribute, which can be either an attribute object from &lt;code&gt;Model.rawAttributes&lt;/code&gt; or a sequelize object, for example an instance of &lt;code&gt;sequelize.fn&lt;/code&gt;. For simple string attributes, use the POJO syntax</source>
          <target state="translated">속성. &lt;code&gt;Model.rawAttributes&lt;/code&gt; 의 속성 객체 이거나 sequelize 객체 (예 : &lt;code&gt;sequelize.fn&lt;/code&gt; 인스턴스) 일 수 있습니다. 간단한 문자열 속성의 경우 POJO 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2729266f67f2a23ec11b7b4334746cfee6eef44b" translate="yes" xml:space="preserve">
          <source>The callback is called with the transaction object, and should return a promise. If the promise is resolved, the transaction commits; if the promise rejects, the transaction rolls back</source>
          <target state="translated">콜백은 트랜잭션 객체와 함께 호출되며 약속을 반환해야합니다. 약속이 해결되면 트랜잭션이 커밋됩니다. 약속이 거부되면 트랜잭션이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="89f67ef86d7f079615ec0e89c9fb9283c0562afc" translate="yes" xml:space="preserve">
          <source>The character(s) that separates the schema name from the table name</source>
          <target state="translated">스키마 이름과 테이블 이름을 구분하는 문자</target>
        </trans-unit>
        <trans-unit id="7bffb68a98cf41f92a6a5b6847d45ca564723683" translate="yes" xml:space="preserve">
          <source>The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.</source>
          <target state="translated">cidr 유형에는 IPv4 또는 IPv6 네트워크 사양이 있습니다. 7 또는 19 바이트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="08288fcdafa5090ff642d3378e7c64c514abd839" translate="yes" xml:space="preserve">
          <source>The code created a new instance. So when we already have an instance ...</source>
          <target state="translated">코드는 새로운 인스턴스를 만들었습니다. 따라서 이미 인스턴스가 있으면 ...</target>
        </trans-unit>
        <trans-unit id="86c3eb751548d29886ece41261fcf102e99bb6c1" translate="yes" xml:space="preserve">
          <source>The column of the foreign table that this column references</source>
          <target state="translated">이 열이 참조하는 외부 테이블의 열</target>
        </trans-unit>
        <trans-unit id="086f5b689f580197262a5b2e07b9612e1b03fe5b" translate="yes" xml:space="preserve">
          <source>The comment option can also be used on a table, see &lt;a href=&quot;models-definition#configuration&quot;&gt;model configuration&lt;/a&gt;.</source>
          <target state="translated">주석 옵션은 테이블에서도 사용할 수 있습니다 ( &lt;a href=&quot;models-definition#configuration&quot;&gt;모델 구성&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="307ca9cde38886869f5fa3f4a7f13e21882c3f36" translate="yes" xml:space="preserve">
          <source>The condition. Can be both a simply type, or a further condition (&lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;.literal&lt;/code&gt; etc.)</source>
          <target state="translated">조건. 단순 유형이거나 추가 조건 ( &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; . &lt;code&gt;.literal&lt;/code&gt; 등) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b12da706808f947908ea3c7e4a43a6c6df973b54" translate="yes" xml:space="preserve">
          <source>The connection specific error which triggered this one</source>
          <target state="translated">이 오류를 발생시킨 연결 특정 오류</target>
        </trans-unit>
        <trans-unit id="f11daf184810825d2e034f106bcdd1a52e3ca438" translate="yes" xml:space="preserve">
          <source>The constraints can be configured in a transaction like this. It will trigger a query once the transaction has been started and set the constraints to be checked at the very end of the transaction.</source>
          <target state="translated">이와 같은 트랜잭션에서 제약 조건을 구성 할 수 있습니다. 트랜잭션이 시작되면 쿼리를 트리거하고 트랜잭션이 끝날 때 제약 조건을 확인하도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7f82e34423c4aa983880f84a931ac15a57ef5e9c" translate="yes" xml:space="preserve">
          <source>The created target model</source>
          <target state="translated">생성 된 대상 모델</target>
        </trans-unit>
        <trans-unit id="8365a8cc325cbcee0b79e12d5dd24da474986bd1" translate="yes" xml:space="preserve">
          <source>The custom name for unique constraint.</source>
          <target state="translated">고유 제한 조건의 사용자 정의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="26d8528d64198217cd0a2792bd30ba499b76275f" translate="yes" xml:space="preserve">
          <source>The database may add further restrictions to this. Bind parameters cannot be SQL keywords, nor table or column names. They are also ignored in quoted text or data. In PostgreSQL it may also be needed to typecast them, if the type cannot be inferred from the context &lt;code&gt;$1::varchar&lt;/code&gt;.</source>
          <target state="translated">데이터베이스에 이에 대한 추가 제한 사항이 추가 될 수 있습니다. 바인드 매개 변수는 SQL 키워드 나 테이블 또는 열 이름이 될 수 없습니다. 인용 된 텍스트 나 데이터에서도 무시됩니다. PostgreSQL에서는 &lt;code&gt;$1::varchar&lt;/code&gt; 컨텍스트에서 형식을 유추 할 수없는 경우 형식을 변환해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="133c42933eb9f6bdcc738e29e1ecb28fe8f85820" translate="yes" xml:space="preserve">
          <source>The database name.</source>
          <target state="translated">데이터베이스 이름</target>
        </trans-unit>
        <trans-unit id="c7b14aedd0c4e517f0bbd0dc1afb0301b4627da0" translate="yes" xml:space="preserve">
          <source>The default casing is &lt;code&gt;camelCase&lt;/code&gt;. If the source model is configured with &lt;code&gt;underscored: true&lt;/code&gt; the foreignKey will be created with field &lt;code&gt;snake_case&lt;/code&gt;.</source>
          <target state="translated">기본 케이스는 &lt;code&gt;camelCase&lt;/code&gt; 입니다. 소스 모델이 &lt;code&gt;underscored: true&lt;/code&gt; 로 구성된 경우 : true foreignKey는 필드 &lt;code&gt;snake_case&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab6a1cee9dd55a28134e5eb727ede271bd531534" translate="yes" xml:space="preserve">
          <source>The default scope can be removed by calling &lt;code&gt;.unscoped()&lt;/code&gt;, &lt;code&gt;.scope(null)&lt;/code&gt;, or by invoking another scope:</source>
          <target state="translated">&lt;code&gt;.unscoped()&lt;/code&gt; , &lt;code&gt;.scope(null)&lt;/code&gt; 을 호출하거나 다른 범위를 호출 하여 기본 범위를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7386af5698cd007ddf66e78123acc72fab2f4ea" translate="yes" xml:space="preserve">
          <source>The default scope is always applied. This means, that with the model definition above, &lt;code&gt;Project.findAll()&lt;/code&gt; will create the following query:</source>
          <target state="translated">기본 범위는 항상 적용됩니다. 즉, 위의 모델 정의를 사용하면 &lt;code&gt;Project.findAll()&lt;/code&gt; 이 다음 쿼리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="665cbb172b6490eaddc986b85ff39499207a5181" translate="yes" xml:space="preserve">
          <source>The description of a database column</source>
          <target state="translated">데이터베이스 열에 대한 설명</target>
        </trans-unit>
        <trans-unit id="d84e52eb436e545fc5c78ff373642e0e5f89fc49" translate="yes" xml:space="preserve">
          <source>The dialect of the database you are connecting to. One of mysql, postgres, sqlite and mssql.</source>
          <target state="translated">연결중인 데이터베이스의 방언 mysql, postgres, sqlite 및 mssql 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="88d26fe16e5692696255a5355d0f4f8be2e688ab" translate="yes" xml:space="preserve">
          <source>The field that triggered the validation error</source>
          <target state="translated">유효성 검사 오류를 일으킨 필드</target>
        </trans-unit>
        <trans-unit id="dc12ac79eaf881af2a210995e506e55117bb8e15" translate="yes" xml:space="preserve">
          <source>The fields to insert / update. Defaults to all changed fields</source>
          <target state="translated">삽입 / 업데이트 할 필드입니다. 변경된 모든 필드의 기본값</target>
        </trans-unit>
        <trans-unit id="82b4a90983df6d340d9ebb2913376b001f99f3b5" translate="yes" xml:space="preserve">
          <source>The following example would return successful:</source>
          <target state="translated">다음 예제는 성공을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="280f1e7b08f7b7110bec1c76d91b0af4a17b5d16" translate="yes" xml:space="preserve">
          <source>The following hooks will emit whenever you're editing a single object</source>
          <target state="translated">단일 객체를 편집 할 때마다 다음 후크가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0e6a1b0b86882a21b759b1ffd75f905d1a7598a6" translate="yes" xml:space="preserve">
          <source>The following is an example of a migration that performs two changes in the database, using a transaction to ensure that all instructions are successfully executed or rolled back in case of failure:</source>
          <target state="translated">다음은 트랜잭션을 사용하여 데이터베이스에서 두 가지 변경을 수행하여 실패시 모든 명령이 성공적으로 실행 또는 롤백되도록하는 마이그레이션의 예입니다.</target>
        </trans-unit>
        <trans-unit id="3dc82f0763e4ab04ff35cac14d85b168f30e6b9f" translate="yes" xml:space="preserve">
          <source>The following skeleton shows a typical migration file.</source>
          <target state="translated">다음 스켈레톤은 일반적인 마이그레이션 파일을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a10c7d3ee357a66ed02d0cefd56151488e7581d5" translate="yes" xml:space="preserve">
          <source>The foreign key column in Picture will now be called &lt;code&gt;uid&lt;/code&gt; instead of the default &lt;code&gt;userId&lt;/code&gt;.</source>
          <target state="translated">Picture의 외래 키 열은 이제 기본 &lt;code&gt;userId&lt;/code&gt; 대신 &lt;code&gt;uid&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="529cad56c0cb70caba210ae4d8aa6458b6284149" translate="yes" xml:space="preserve">
          <source>The foreign keys can be configured like this. It will create a foreign key that will check the constraints immediately when the data was inserted.</source>
          <target state="translated">외래 키는 이와 같이 구성 할 수 있습니다. 데이터가 삽입되면 즉시 제약 조건을 검사하는 외래 키를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="793f0633fe67cfcf9f0c69748cf2894da9604c8b" translate="yes" xml:space="preserve">
          <source>The function passed to &lt;code&gt;afterCommit&lt;/code&gt; can optionally return a promise that will resolve before the promise chain that created the transaction resolves</source>
          <target state="translated">&lt;code&gt;afterCommit&lt;/code&gt; 에 전달 된 함수 는 트랜잭션을 작성한 약속 체인이 해결되기 전에 해결할 약속을 선택적으로 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="391fd95e64f40aa9733294c80cb361252d715dc2" translate="yes" xml:space="preserve">
          <source>The function to use for aggregation, e.g. sum, max etc.</source>
          <target state="translated">집계에 사용할 함수 (예 : sum, max 등)</target>
        </trans-unit>
        <trans-unit id="000d55600122d86f1eba23f47b3d17f67612ff60" translate="yes" xml:space="preserve">
          <source>The function you want to call</source>
          <target state="translated">호출하려는 기능</target>
        </trans-unit>
        <trans-unit id="90c3ebe86ec649ba3e67ec8bd89813b5825ec277" translate="yes" xml:space="preserve">
          <source>The host of the relational database.</source>
          <target state="translated">관계형 데이터베이스의 호스트.</target>
        </trans-unit>
        <trans-unit id="078148a6e892df7a20d488625d335ca2bfefddd8" translate="yes" xml:space="preserve">
          <source>The interface that Sequelize uses to talk to all databases</source>
          <target state="translated">Sequelize가 모든 데이터베이스와 통신하는 데 사용하는 인터페이스</target>
        </trans-unit>
        <trans-unit id="0b73ca2f73dbf5fbdcb5f9c41700b408a0e80f3d" translate="yes" xml:space="preserve">
          <source>The key difference is that the managed transaction uses a callback that expects a promise to be returned to it while the unmanaged transaction returns a promise.</source>
          <target state="translated">주요 차이점은 관리 트랜잭션은 약속이 반환 될 것으로 예상되는 콜백을 사용하고 관리되지 않는 트랜잭션은 약속을 반환한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="78ad99f68c3f49de5dac894a3e535c3b22d08e81" translate="yes" xml:space="preserve">
          <source>The last option is the default in PostgreSQL and won't allow you to dynamically change the rule in a transaction. See &lt;a href=&quot;transactions#options&quot;&gt;the transaction section&lt;/a&gt; for further information.</source>
          <target state="translated">마지막 옵션은 PostgreSQL의 기본값이며 트랜잭션에서 규칙을 동적으로 변경할 수 없습니다. 자세한 내용 &lt;a href=&quot;transactions#options&quot;&gt;은 거래 섹션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec4984d2ddd30205a2e231be149e2871ddd539b9" translate="yes" xml:space="preserve">
          <source>The library for MSSQL is&lt;code&gt;tedious@^6.0.0&lt;/code&gt; You'll just need to define the dialect. Please note: &lt;code&gt;tedious@^6.0.0&lt;/code&gt; requires you to nest MSSQL specific options inside an additional &lt;code&gt;options&lt;/code&gt;-object inside the &lt;code&gt;dialectOptions&lt;/code&gt;-object.</source>
          <target state="translated">MSSQL의 라이브러리는 &lt;code&gt;tedious@^6.0.0&lt;/code&gt; 입니다. 방언을 정의하기 만하면됩니다. : 참고 &lt;code&gt;tedious@^6.0.0&lt;/code&gt; 은 추가 내부에 둥지 MSSQL의 특정 옵션에 당신을 필요로 &lt;code&gt;options&lt;/code&gt; 내부 -object &lt;code&gt;dialectOptions&lt;/code&gt; 가 -object.</target>
        </trans-unit>
        <trans-unit id="1658788de2d8228e11cec2bccf15ee08bd03c17f" translate="yes" xml:space="preserve">
          <source>The maximum time, in milliseconds, that a connection can be idle before being released.</source>
          <target state="translated">연결이 해제되기 전에 유휴 상태가 될 수있는 최대 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="ba55d264e60dd5d5b5ddf45b2ce564066fb762a9" translate="yes" xml:space="preserve">
          <source>The maximum time, in milliseconds, that pool will try to get connection before throwing error</source>
          <target state="translated">해당 풀이 오류를 발생시키기 전에 연결을 시도하는 최대 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="5ee71bd71da0b1e5f70afac2c78ad97814aea849" translate="yes" xml:space="preserve">
          <source>The merge illustrated above works in the exact same way regardless of the order applied to the scopes. The order would only make a difference if a certain option was set by two different scopes - which is not the case of the above example, since each scope does a different thing.</source>
          <target state="translated">위에 설명 된 병합은 범위에 적용되는 순서에 관계없이 동일한 방식으로 작동합니다. 특정 옵션이 두 개의 다른 범위로 설정된 경우에만 순서가 달라집니다. 각 범위가 다른 일을하기 때문에 위의 예에서는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="768b334f10219b8ad448c59e67cb8742c9f47374" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;findOrCreate&lt;/code&gt; can be used to check if a certain element already exists in the database. If that is the case the method will result in a respective instance. If the element does not yet exist, it will be created.</source>
          <target state="translated">&lt;code&gt;findOrCreate&lt;/code&gt; 메소드를 사용하여 데이터베이스에 특정 요소가 이미 존재하는지 확인할 수 있습니다. 이 경우이 방법으로 각 인스턴스가 생성됩니다. 요소가 아직 없으면 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3d86660c6baef8b679849a118c8e3209fbf8ab29" translate="yes" xml:space="preserve">
          <source>The method to create the index by (&lt;code&gt;USING&lt;/code&gt; statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN.</source>
          <target state="translated">( SQL의 &lt;code&gt;USING&lt;/code&gt; 문)으로 색인을 작성하는 방법 . BTREE 및 HASH는 mysql 및 postgres에서 지원되며 postgres는 GIST 및 GIN을 추가로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2ba17aa0bb5f9dc7d5841a219c942e597585fcbc" translate="yes" xml:space="preserve">
          <source>The model used to join both sides of the N:M association.</source>
          <target state="translated">N : M 연관의 양쪽을 결합하는 데 사용 된 모델입니다.</target>
        </trans-unit>
        <trans-unit id="344f38a91e7d9dc5d063993463bcdaa555327fc6" translate="yes" xml:space="preserve">
          <source>The model you want to eagerly load</source>
          <target state="translated">간절히로드하려는 모델</target>
        </trans-unit>
        <trans-unit id="7958ce6ba41d78327583cdbfd8cb6017bf350a54" translate="yes" xml:space="preserve">
          <source>The name of a model defined with Sequelize.define</source>
          <target state="translated">Sequelize.define으로 정의 된 모델의 이름</target>
        </trans-unit>
        <trans-unit id="20779cb99d8b313c45bb680661f5068180a4b366" translate="yes" xml:space="preserve">
          <source>The name of the attribute to use as the key for the association in the source table. Defaults to the primary key of the source table</source>
          <target state="translated">소스 테이블에서 연관의 키로 사용할 속성의 이름입니다. 기본적으로 소스 테이블의 기본 키</target>
        </trans-unit>
        <trans-unit id="2c370d4fbb6793a135a98f2d34ffdc1efa7aa44d" translate="yes" xml:space="preserve">
          <source>The name of the attribute to use as the key for the association in the target table. Defaults to the primary key of the target table</source>
          <target state="translated">대상 테이블에서 연관의 키로 사용할 속성의 이름입니다. 대상 테이블의 기본 키가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="93c15edec87bb8d344200119a7dc2a4a142ddf00" translate="yes" xml:space="preserve">
          <source>The name of the column</source>
          <target state="translated">열의 이름</target>
        </trans-unit>
        <trans-unit id="8c4f59698903f75b8bd6022cb4552203a39c97a3" translate="yes" xml:space="preserve">
          <source>The name of the database</source>
          <target state="translated">데이터베이스 이름</target>
        </trans-unit>
        <trans-unit id="22a68705226fe8673395221999a0d393f6c5865e" translate="yes" xml:space="preserve">
          <source>The name of the field to use as the key for the association in the source table. Defaults to the primary key of the source table</source>
          <target state="translated">소스 테이블에서 연관의 키로 사용할 필드 이름입니다. 기본적으로 소스 테이블의 기본 키</target>
        </trans-unit>
        <trans-unit id="15885ab4b151a1a790fcb10a8b5e2b0d66ba2eec" translate="yes" xml:space="preserve">
          <source>The name of the foreign key attribute in the source table or an object representing the type definition for the foreign column (see &lt;code&gt;Sequelize.define&lt;/code&gt; for syntax). When using an object, you can add a &lt;code&gt;name&lt;/code&gt; property to set the name of the column. Defaults to the name of target + primary key of target</source>
          <target state="translated">소스 테이블의 외래 키 속성 이름 또는 외래 열의 유형 정의를 나타내는 개체 입니다 (구문 은 &lt;code&gt;Sequelize.define&lt;/code&gt; 참조 ). 객체를 사용할 때 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하여 열 이름을 설정할 수 있습니다 . 기본적으로 대상 이름 + 대상의 기본 키</target>
        </trans-unit>
        <trans-unit id="eb6459fe5afc725ce007c909a06d98e3db4d2d06" translate="yes" xml:space="preserve">
          <source>The name of the foreign key attribute in the target model or an object representing the type definition for the foreign column (see &lt;code&gt;Sequelize.define&lt;/code&gt; for syntax). When using an object, you can add a &lt;code&gt;name&lt;/code&gt; property to set the name of the column. Defaults to the name of source + primary key of source</source>
          <target state="translated">대상 모델의 외래 키 속성 이름 또는 외래 열의 형식 정의를 나타내는 개체 입니다 (구문 은 &lt;code&gt;Sequelize.define&lt;/code&gt; 참조 ). 객체를 사용할 때 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하여 열 이름을 설정할 수 있습니다 . 기본적으로 소스 이름 + 소스의 기본 키</target>
        </trans-unit>
        <trans-unit id="42469972a87959d8071e3f01dc78f6c8d2553e4f" translate="yes" xml:space="preserve">
          <source>The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see &lt;code&gt;Sequelize.define&lt;/code&gt; for syntax). When using an object, you can add a &lt;code&gt;name&lt;/code&gt; property to set the name of the column. Defaults to the name of source + primary key of source</source>
          <target state="translated">조인 테이블의 외부 키 이름 (소스 모델을 나타냄) 또는 외부 열에 대한 유형 정의를 나타내는 객체 ( 구문 은 &lt;code&gt;Sequelize.define&lt;/code&gt; 참조 ). 객체를 사용할 때 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하여 열 이름을 설정할 수 있습니다 . 기본적으로 소스 이름 + 소스의 기본 키</target>
        </trans-unit>
        <trans-unit id="fe4d422c72187bb994f27a984373dd051447a90f" translate="yes" xml:space="preserve">
          <source>The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see &lt;code&gt;Sequelize.define&lt;/code&gt; for syntax). When using an object, you can add a &lt;code&gt;name&lt;/code&gt; property to set the name of the column. Defaults to the name of target + primary key of target</source>
          <target state="translated">조인 테이블의 외래 키 이름 (대상 모델을 나타냄) 또는 다른 열의 유형 정의를 나타내는 객체 입니다 (구문 은 &lt;code&gt;Sequelize.define&lt;/code&gt; 참조 ). 객체를 사용할 때 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하여 열 이름을 설정할 수 있습니다 . 기본적으로 대상 이름 + 대상의 기본 키</target>
        </trans-unit>
        <trans-unit id="38709c5641379045db5e5d83ba646ba0c902d682" translate="yes" xml:space="preserve">
          <source>The name of the foreign key in the target table or an object representing the type definition for the foreign column (see &lt;code&gt;Sequelize.define&lt;/code&gt; for syntax). When using an object, you can add a &lt;code&gt;name&lt;/code&gt; property to set the name of the column. Defaults to the name of source + primary key of source</source>
          <target state="translated">대상 테이블의 외래 키 이름 또는 외래 열의 형식 정의를 나타내는 개체 입니다 (구문 은 &lt;code&gt;Sequelize.define&lt;/code&gt; 참조 ). 객체를 사용할 때 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하여 열 이름을 설정할 수 있습니다 . 기본적으로 소스 이름 + 소스의 기본 키</target>
        </trans-unit>
        <trans-unit id="7a7cf09bcd6575bf593ecb7e44a875789583a801" translate="yes" xml:space="preserve">
          <source>The name of the index. Defaults to model name + _ + fields concatenated</source>
          <target state="translated">색인의 이름입니다. 연결된 모델 이름 + _ + 필드의 기본값</target>
        </trans-unit>
        <trans-unit id="e0dee175f7513db4bb65e2da34923be2d4fb8f8d" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in</source>
          <target state="translated">함수가 구현되는 언어의 이름</target>
        </trans-unit>
        <trans-unit id="901c3e2315864e0cfc881f469ee9e42e145e1941" translate="yes" xml:space="preserve">
          <source>The name of the model on which the update was attempted</source>
          <target state="translated">업데이트가 시도 된 모델의 이름</target>
        </trans-unit>
        <trans-unit id="4ea96b65632c0d275cf41855cbbc4cfc2e78bbea" translate="yes" xml:space="preserve">
          <source>The name of the model. The model will be stored in &lt;code&gt;sequelize.models&lt;/code&gt; under this name</source>
          <target state="translated">모델의 이름입니다. 모델은 이 이름 으로 &lt;code&gt;sequelize.models&lt;/code&gt; 에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="fa9b6db53f226bce8b7814cf4cd827147473b678" translate="yes" xml:space="preserve">
          <source>The name of the schema</source>
          <target state="translated">스키마의 이름</target>
        </trans-unit>
        <trans-unit id="4a337049980fb26ef87b1957b77e10b1adaa13d4" translate="yes" xml:space="preserve">
          <source>The name of the scope. Use &lt;code&gt;defaultScope&lt;/code&gt; to override the default scope</source>
          <target state="translated">범위의 이름입니다. &lt;code&gt;defaultScope&lt;/code&gt; 를 사용 하여 기본 범위를 재정의</target>
        </trans-unit>
        <trans-unit id="689b7c83b43fba0e2101546e9d74f61d1a062d93" translate="yes" xml:space="preserve">
          <source>The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it.</source>
          <target state="translated">n : m 연관에서 소스와 대상을 결합하는 데 사용되는 테이블의 이름입니다. 정션 테이블을 직접 정의하고 추가 속성을 추가하려는 경우 순차 모델 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6408e2ecf1340ab31daec80973b0b23a6dc6fdf2" translate="yes" xml:space="preserve">
          <source>The name of the template from which to create the new database, PostgreSQL only</source>
          <target state="translated">새 데이터베이스를 생성 할 템플릿 이름 (PostgreSQL 만 해당)</target>
        </trans-unit>
        <trans-unit id="3af644ca8cb4bd3901646f8c9686c10ad3f438f9" translate="yes" xml:space="preserve">
          <source>The new range can be used in model definitions as &lt;code&gt;Sequelize.RANGE(Sequelize.NEWTYPE)&lt;/code&gt; or &lt;code&gt;DataTypes.RANGE(DataTypes.NEWTYPE)&lt;/code&gt;.</source>
          <target state="translated">새 범위는 모델 정의에서 &lt;code&gt;Sequelize.RANGE(Sequelize.NEWTYPE)&lt;/code&gt; 또는 &lt;code&gt;DataTypes.RANGE(DataTypes.NEWTYPE)&lt;/code&gt; 로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3d7de3db43f176261838315f9462534066abc21" translate="yes" xml:space="preserve">
          <source>The next is an example of a migration that has a foreign key. You can use references to specify a foreign key:</source>
          <target state="translated">다음은 외래 키가있는 마이그레이션의 예입니다. 참조를 사용하여 외래 키를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90d9ad1b9b3b4f1a236dc0cc182271fbe723b0e" translate="yes" xml:space="preserve">
          <source>The next is an example of a migration that has uses async/await where you create an unique index on a new column:</source>
          <target state="translated">다음은 async / await를 사용하여 새 열에 고유 인덱스를 생성하는 마이그레이션의 예입니다.</target>
        </trans-unit>
        <trans-unit id="5bfd201c5d2f64d334aaed75ca93f6250c27f3e0" translate="yes" xml:space="preserve">
          <source>The number of destroyed rows</source>
          <target state="translated">파괴 된 행의 수</target>
        </trans-unit>
        <trans-unit id="6081ff3872966efe1d8dfd421d4fb7860123280f" translate="yes" xml:space="preserve">
          <source>The number to decrement by</source>
          <target state="translated">감소 할 숫자</target>
        </trans-unit>
        <trans-unit id="30c2b338b0c6fb53c4b5c1dd307e605378770430" translate="yes" xml:space="preserve">
          <source>The number to increment by</source>
          <target state="translated">증가 할 숫자</target>
        </trans-unit>
        <trans-unit id="5519b26afd29019553644d95f3657c0b4ef9b9ea" translate="yes" xml:space="preserve">
          <source>The only way to call beforeDestroy/afterDestroy hooks are on associations with &lt;code&gt;onDelete: 'cascade'&lt;/code&gt; and the option &lt;code&gt;hooks: true&lt;/code&gt;. For instance:</source>
          <target state="translated">beforeDestroy / afterDestroy 후크를 호출하는 유일한 방법은 &lt;code&gt;onDelete: 'cascade'&lt;/code&gt; 및 옵션 &lt;code&gt;hooks: true&lt;/code&gt; 와의 연관에 있습니다 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="c69a63575e1fb55daa7f9a2dfde0c6053bf26ef6" translate="yes" xml:space="preserve">
          <source>The options object that you pass to &lt;code&gt;findAndCountAll&lt;/code&gt; is the same as for &lt;code&gt;findAll&lt;/code&gt; (described below).</source>
          <target state="translated">&lt;code&gt;findAndCountAll&lt;/code&gt; 에 전달하는 옵션 객체는 &lt;code&gt;findAll&lt;/code&gt; (아래 설명)과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a45202cbcffdecef1bfb35227b61eaaaeef09d0e" translate="yes" xml:space="preserve">
          <source>The options passed to Model.destroy in addition to truncate</source>
          <target state="translated">자르는 것 외에도 Model.destroy에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="3f3dcd71f3878dfff6b16011edbaab2ef1e64db1" translate="yes" xml:space="preserve">
          <source>The options passed to each call to Model.drop</source>
          <target state="translated">Model.drop에 대한 각 호출에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="b843160b62331068336d27cc8d45b2412cdff08d" translate="yes" xml:space="preserve">
          <source>The parameters for the sql that triggered the error</source>
          <target state="translated">오류를 유발 한 SQL의 매개 변수</target>
        </trans-unit>
        <trans-unit id="b7e618cc7e765bd054110930a05bbf6f5cafdacb" translate="yes" xml:space="preserve">
          <source>The passed &lt;code&gt;queryInterface&lt;/code&gt; object can be used to modify the database. The &lt;code&gt;Sequelize&lt;/code&gt; object stores the available data types such as &lt;code&gt;STRING&lt;/code&gt; or &lt;code&gt;INTEGER&lt;/code&gt;. Function &lt;code&gt;up&lt;/code&gt; or &lt;code&gt;down&lt;/code&gt; should return a &lt;code&gt;Promise&lt;/code&gt;. Let's look at an example:</source>
          <target state="translated">전달 된 &lt;code&gt;queryInterface&lt;/code&gt; 오브젝트를 사용하여 데이터베이스를 수정할 수 있습니다. &lt;code&gt;Sequelize&lt;/code&gt; 의 같은 객체를 저장 가능한 데이터 유형 &lt;code&gt;STRING&lt;/code&gt; 또는 &lt;code&gt;INTEGER&lt;/code&gt; . &lt;code&gt;up&lt;/code&gt; 또는 &lt;code&gt;down&lt;/code&gt; 기능 은 &lt;code&gt;Promise&lt;/code&gt; 를 반환해야합니다 . 예를 보자.</target>
        </trans-unit>
        <trans-unit id="d2533745943844afbedf7eb8255a5190f883bdec" translate="yes" xml:space="preserve">
          <source>The password which is used to authenticate against the database.</source>
          <target state="translated">데이터베이스를 인증하는 데 사용되는 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="e964b1bc1afa7e133edcfa208521202aaf1336e1" translate="yes" xml:space="preserve">
          <source>The password which is used to authenticate against the database. Supports SQLCipher encryption for SQLite.</source>
          <target state="translated">데이터베이스를 인증하는 데 사용되는 비밀번호입니다. SQLite에 대한 SQLCipher 암호화를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d1f9da31741290e9b21dee89de285e5d49b6e9b8" translate="yes" xml:space="preserve">
          <source>The path to be checked for error items</source>
          <target state="translated">오류 항목을 확인할 경로</target>
        </trans-unit>
        <trans-unit id="e666a85eaccb1faddd6ef50cb44be68ea6f3ce05" translate="yes" xml:space="preserve">
          <source>The path to the file that holds the model you want to import. If the part is relative, it will be resolved relatively to the calling file</source>
          <target state="translated">가져올 모델이 들어있는 파일의 경로입니다. 부품이 상대적인 경우 호출 파일을 기준으로 상대적으로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="52ec3b98cef1dcaeea55cc63084c0f82417242c6" translate="yes" xml:space="preserve">
          <source>The polymorphic association can be implemented with an &lt;em&gt;association scope&lt;/em&gt; :</source>
          <target state="translated">다형성 연관은 &lt;em&gt;연관 범위&lt;/em&gt; 로 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccdd83d9259d4f504d2c47076b673df711befe8f" translate="yes" xml:space="preserve">
          <source>The port of the relational database.</source>
          <target state="translated">관계형 데이터베이스의 포트입니다.</target>
        </trans-unit>
        <trans-unit id="9a65ac5ab95179f410b68d283a2ce4caa4e100b0" translate="yes" xml:space="preserve">
          <source>The possible isolations levels to use when starting a transaction:</source>
          <target state="translated">트랜잭션을 시작할 때 사용할 수있는 격리 수준 :</target>
        </trans-unit>
        <trans-unit id="cadc5244d3fbd7d24b1c5864d52995cd667e11c7" translate="yes" xml:space="preserve">
          <source>The previous example can be extended to support an association alias.</source>
          <target state="translated">이전 예는 연관 별명을 지원하도록 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e7860e1e9fe6157f068d6e05ea4c9ba937f1820" translate="yes" xml:space="preserve">
          <source>The promise fulfills if and only if validation successful; otherwise it rejects an Error instance containing { field name : [error msgs] } entries.</source>
          <target state="translated">약속은 검증이 성공한 경우에만 이행합니다. 그렇지 않으면 {field name : [error msgs]} 항목을 포함하는 Error 인스턴스를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="c7345c3a97b1369d2ea2bf0cee0e1778a424ab23" translate="yes" xml:space="preserve">
          <source>The promise returns an array with one or two elements. The first element is always the number of affected rows, while the second element is the actual affected rows (only supported in postgres with &lt;code&gt;options.returning&lt;/code&gt; true).</source>
          <target state="translated">promise는 하나 또는 두 개의 요소가있는 배열을 반환합니다. 첫 번째 요소는 항상 영향을받는 행 수이고 두 번째 요소는 실제 영향을받는 행입니다 ( &lt;code&gt;options.returning&lt;/code&gt; true를 사용 하여 postgres에서만 지원됨 ).</target>
        </trans-unit>
        <trans-unit id="b66998033b01ad0f71a1f99fd1205004d74f54f7" translate="yes" xml:space="preserve">
          <source>The protocol of the relational database.</source>
          <target state="translated">관계형 데이터베이스의 프로토콜.</target>
        </trans-unit>
        <trans-unit id="9b65629117d86e6ea7f1be1d190a811c13b665fb" translate="yes" xml:space="preserve">
          <source>The query above will only count users who have an active profile, because &lt;code&gt;required&lt;/code&gt; is implicitly set to true when you add a where clause to the include.</source>
          <target state="translated">때문에 위의 질의는 단지, 활성화 된 프로필을 가진 사용자를 계산합니다 &lt;code&gt;required&lt;/code&gt; (가) 포함에 당신이 어디에 절을 추가 할 때 암시 적으로 true로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f17651b8defa7a688a238ee9c850c88d216bbd4b" translate="yes" xml:space="preserve">
          <source>The query above will return all users, and all their instruments, but only those teachers associated with &lt;code&gt;Woodstock Music School&lt;/code&gt;.</source>
          <target state="translated">위의 쿼리는 모든 사용자와 모든 악기를 반환하지만 &lt;code&gt;Woodstock Music School&lt;/code&gt; 과 관련된 교사 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="882e95417cd6d361e8a21202698fdccdb38d7585" translate="yes" xml:space="preserve">
          <source>The relation between &lt;code&gt;tasks&lt;/code&gt; and &lt;code&gt;users&lt;/code&gt; model injects the &lt;code&gt;userId&lt;/code&gt; foreign key on &lt;code&gt;tasks&lt;/code&gt; table, and marks it as a reference to the &lt;code&gt;users&lt;/code&gt; table. By default &lt;code&gt;userId&lt;/code&gt; will be set to &lt;code&gt;NULL&lt;/code&gt; if the referenced user is deleted, and updated if the id of the &lt;code&gt;userId&lt;/code&gt; updated. These options can be overridden by passing &lt;code&gt;onUpdate&lt;/code&gt; and &lt;code&gt;onDelete&lt;/code&gt; options to the association calls. The validation options are &lt;code&gt;RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL&lt;/code&gt;.</source>
          <target state="translated">관계 &lt;code&gt;tasks&lt;/code&gt; 및 &lt;code&gt;users&lt;/code&gt; 모델이 주입 &lt;code&gt;userId&lt;/code&gt; 를 외국 키 &lt;code&gt;tasks&lt;/code&gt; 받는 참조 표를 표시하고이를 &lt;code&gt;users&lt;/code&gt; 테이블. 기본적으로 &lt;code&gt;userId&lt;/code&gt; 를 설정됩니다 &lt;code&gt;NULL&lt;/code&gt; 참조 된 사용자가 삭제 된 경우, 그리고의 ID 경우 업데이트 &lt;code&gt;userId&lt;/code&gt; 를가 업데이트되었습니다. &lt;code&gt;onUpdate&lt;/code&gt; 및 &lt;code&gt;onDelete&lt;/code&gt; 옵션을 연관 호출 에 전달 하여이 옵션을 대체 할 수 있습니다 . 유효성 검사 옵션은 &lt;code&gt;RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b9f7f5e66de32f9f00b194b0d793b58686e0548" translate="yes" xml:space="preserve">
          <source>The same merge logic applies when passing a find object directly to &lt;code&gt;findAll&lt;/code&gt; (and similar finders) on a scoped model:</source>
          <target state="translated">범위가 지정된 모델의 &lt;code&gt;findAll&lt;/code&gt; (및 유사한 파인더)에 찾기 오브젝트를 직접 전달할 때 동일한 병합 논리가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="97ab6aa4ba7990a147bb964cdd7e87d1f62efe69" translate="yes" xml:space="preserve">
          <source>The schema that the tables should be created in. This can be overridden for each table in sequelize.define</source>
          <target state="translated">테이블을 작성해야하는 스키마. sequelize.define의 각 테이블에 대해이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c43a2f21b215e63de5816eae94cb4b78d64ee9df" translate="yes" xml:space="preserve">
          <source>The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a &lt;code&gt;method&lt;/code&gt; property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default.</source>
          <target state="translated">적용 할 범위. 범위는 연속 인수 또는 인수 배열로 전달 될 수 있습니다. 인수없이 간단한 범위와 범위 함수를 적용하려면 문자열로 전달하십시오. 범위 함수의 경우 &lt;code&gt;method&lt;/code&gt; 특성 과 함께 오브젝트를 전달하십시오 . 메소드가 인수를 취하지 않는 경우 값은 문자열이거나 첫 번째 요소가 메소드의 이름이고 연속 요소가 해당 메소드의 인수 인 배열 일 수 있습니다. 기본값을 포함하여 모든 범위를 제거하려면 null을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="e118bc1e681bc034058a8bda4bc03316fe86fe78" translate="yes" xml:space="preserve">
          <source>The socket path must start with &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">소켓 경로는 &lt;code&gt;/&lt;/code&gt; 로 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5a2ca207850bf8f92ef8c79ea6faebe0a9682e77" translate="yes" xml:space="preserve">
          <source>The source key is the attribute on the source model that the foreign key attribute on the target model points to. By default the source key for a &lt;code&gt;hasOne&lt;/code&gt; relation will be the source model's primary attribute. To use a custom attribute, use the &lt;code&gt;sourceKey&lt;/code&gt; option.</source>
          <target state="translated">소스 키는 대상 모델의 외래 키 속성이 가리키는 소스 모델의 속성입니다. 기본적으로 &lt;code&gt;hasOne&lt;/code&gt; 관계 의 소스 키 는 소스 모델의 기본 속성입니다. 사용자 정의 속성을 사용하려면 &lt;code&gt;sourceKey&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f620901a19bb7656abbdf382102fb74721c6995b" translate="yes" xml:space="preserve">
          <source>The specified dialect.</source>
          <target state="translated">지정된 방언.</target>
        </trans-unit>
        <trans-unit id="55da2b2d35bc1e7629eadbe7b1ec3caa26f12e10" translate="yes" xml:space="preserve">
          <source>The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records. To obtain Instances for the newly created values, you will need to query for them again.</source>
          <target state="translated">성공 처리기는 인스턴스 배열로 전달되지만, DB의 행 상태를 완전히 나타내지 않을 수도 있습니다. MySQL과 SQLite는 자동으로 생성 된 ID와 다른 기본값을 여러 레코드에 매핑 할 수있는 방식으로 쉽게 다시 얻을 수 없기 때문입니다. 새로 생성 된 값에 대한 인스턴스를 얻으려면 다시 쿼리해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca8c1cb986bae7a03abb7e55f466bf12bd7f5b9d" translate="yes" xml:space="preserve">
          <source>The success handler will always receive an object with two properties:</source>
          <target state="translated">성공 처리기는 항상 두 가지 속성을 가진 개체를받습니다.</target>
        </trans-unit>
        <trans-unit id="34579639c463106f1a03eee66559cab728f1641b" translate="yes" xml:space="preserve">
          <source>The syntax for grouping and ordering are equal, so below it is only explained with a single example for group, and the rest for order. Everything you see below can also be done for group</source>
          <target state="translated">그룹화 및 순서화 구문은 동일하므로 아래에서는 그룹에 대한 단일 예제와 순서에 대한 나머지 예제 만 설명합니다. 아래에서 볼 수있는 모든 것은 그룹에 대해서도 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="58b66076bf28d404e11394816918b9debbdb35f5" translate="yes" xml:space="preserve">
          <source>The table columns are defined by the hash that is given as the first argument. Each attribute of the hash represents a column.</source>
          <target state="translated">테이블 열은 첫 번째 인수로 제공되는 해시에 의해 정의됩니다. 해시의 각 속성은 열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0333c25506d7b965b09277d6ee324cf0849f0c73" translate="yes" xml:space="preserve">
          <source>The table columns are defined by the object that is given as the second argument. Each key of the object represents a column</source>
          <target state="translated">테이블 열은 두 번째 인수로 제공되는 개체에 의해 정의됩니다. 객체의 각 키는 열을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="1b918538dbc34fd935439f872ac510ed2a15c0e0" translate="yes" xml:space="preserve">
          <source>The target key is the column on the target model that the foreign key column on the source model points to. By default the target key for a belongsTo relation will be the target model's primary key. To define a custom column, use the &lt;code&gt;targetKey&lt;/code&gt; option.</source>
          <target state="translated">대상 키는 소스 모델의 외래 키 열이 가리키는 대상 모델의 열입니다. 기본적으로 belongsTo 관계의 대상 키는 대상 모델의 기본 키입니다. 사용자 정의 열을 정의하려면 &lt;code&gt;targetKey&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="491b59fdd8f66fe0f7f13309b9f00701386dcec7" translate="yes" xml:space="preserve">
          <source>The target model</source>
          <target state="translated">대상 모델</target>
        </trans-unit>
        <trans-unit id="c366e237ccd3fa7a5cf3767dcbd191713159c4d1" translate="yes" xml:space="preserve">
          <source>The time interval, in milliseconds, after which sequelize-pool will remove idle connections.</source>
          <target state="translated">Sequelize-pool이 유휴 연결을 제거한 후의 시간 간격 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="49180f7e5b04ba9d5019142b532f40f579f312c3" translate="yes" xml:space="preserve">
          <source>The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes.</source>
          <target state="translated">데이터베이스에서 날짜를 JavaScript 날짜로 변환 할 때 사용되는 시간대입니다. 시간대는 또한 서버에 연결할 때 TIMEZONE을 설정하여 NOW, CURRENT_TIMESTAMP 및 기타 시간 관련 기능의 결과가 올바른 시간대에 있는지 확인하는 데 사용됩니다. 최고의 크로스 플랫폼 성능을 위해서는 +/- HH : MM 형식을 사용하십시오. moment.js에서 사용하는 시간대의 문자열 버전도 허용합니다 (예 : 'America / Los_Angeles'). 일광 절약 시간제 변경 사항을 캡처하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="22d5c59623d5082e86fcb983d4ab3c203156259b" translate="yes" xml:space="preserve">
          <source>The transaction object is used to identify a running transaction.</source>
          <target state="translated">트랜잭션 오브젝트는 실행중인 트랜잭션을 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f0edfec2d8f7bf8e0afc41f8155d0fe4c8968331" translate="yes" xml:space="preserve">
          <source>The transaction object is used to identify a running transaction. It is created by calling &lt;code&gt;Sequelize.transaction()&lt;/code&gt;. To run a query under a transaction, you should pass the transaction in the options object.</source>
          <target state="translated">트랜잭션 오브젝트는 실행중인 트랜잭션을 식별하는 데 사용됩니다. &lt;code&gt;Sequelize.transaction()&lt;/code&gt; 을 호출하여 생성됩니다 . 트랜잭션에서 쿼리를 실행하려면 옵션 개체에서 트랜잭션을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="1beb1efd0f8f2a80414557b5c568ecb7d3c36cb7" translate="yes" xml:space="preserve">
          <source>The transaction that the query should be executed under</source>
          <target state="translated">쿼리를 실행해야하는 트랜잭션</target>
        </trans-unit>
        <trans-unit id="d7eaaa527b737eaa8f46f1460009ff30ab80523a" translate="yes" xml:space="preserve">
          <source>The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but &lt;code&gt;Sequelize.QueryTypes&lt;/code&gt; is provided as convenience shortcuts.</source>
          <target state="translated">실행중인 쿼리 유형입니다. 쿼리 유형은 결과가 다시 전달되기 전에 형식이 지정되는 방식에 영향을줍니다. 형식은 문자열이지만 &lt;code&gt;Sequelize.QueryTypes&lt;/code&gt; 는 편의 단축키로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6ac3e6aea5927228f941582e70503ef95b61da85" translate="yes" xml:space="preserve">
          <source>The type of the association.</source>
          <target state="translated">연관 유형.</target>
        </trans-unit>
        <trans-unit id="c3a22137eb7f0a4c6f818bf5181fd51cda693d63" translate="yes" xml:space="preserve">
          <source>The type of the association. One of &lt;code&gt;HasMany&lt;/code&gt;, &lt;code&gt;BelongsTo&lt;/code&gt;, &lt;code&gt;HasOne&lt;/code&gt;, &lt;code&gt;BelongsToMany&lt;/code&gt;</source>
          <target state="translated">연관 유형. &lt;code&gt;HasMany&lt;/code&gt; 중 하나 , &lt;code&gt;BelongsTo&lt;/code&gt; , &lt;code&gt;HasOne&lt;/code&gt; , &lt;code&gt;BelongsToMany&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a84720b6e6d1abe177c213ae349687b9ecbd326e" translate="yes" xml:space="preserve">
          <source>The type of the result. If &lt;code&gt;field&lt;/code&gt; is a field in this Model, the default will be the type of that field, otherwise defaults to float.</source>
          <target state="translated">결과의 유형입니다. 경우 &lt;code&gt;field&lt;/code&gt; 이 모델의 필드이며, 기본값은 해당 필드의 종류, 플로트에, 그렇지 않으면 기본값이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="183dc3fd6b319dae15e0ede29af243c273ee8685" translate="yes" xml:space="preserve">
          <source>The type to cast it to</source>
          <target state="translated">캐스트 할 유형</target>
        </trans-unit>
        <trans-unit id="0ba8f3d4b3e41ec8a080d8bbbadbfdd6e148ee51" translate="yes" xml:space="preserve">
          <source>The type/origin of the validation error</source>
          <target state="translated">유효성 검사 오류의 유형 / 원점</target>
        </trans-unit>
        <trans-unit id="5888d90beb856504f26606caf21620cfa8966739" translate="yes" xml:space="preserve">
          <source>The username which is used to authenticate against the database.</source>
          <target state="translated">데이터베이스를 인증하는 데 사용되는 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ef65704c728b311b6675bea469007ef92576b56c" translate="yes" xml:space="preserve">
          <source>The value for the default constraint</source>
          <target state="translated">기본 구속 조건의 값</target>
        </trans-unit>
        <trans-unit id="87fb8dc5fc6bc1f9c662d78e53814299d9b4d67e" translate="yes" xml:space="preserve">
          <source>The value of the desired instance's primary key.</source>
          <target state="translated">원하는 인스턴스의 기본 키 값입니다.</target>
        </trans-unit>
        <trans-unit id="2e4d8e128c9a5a1ffd3c715a791ace7b6e2f0e51" translate="yes" xml:space="preserve">
          <source>The value that generated the error</source>
          <target state="translated">오류를 생성 한 값</target>
        </trans-unit>
        <trans-unit id="281466e75fbe944a95c1f47673ac3a4b4a7aac99" translate="yes" xml:space="preserve">
          <source>The value to cast</source>
          <target state="translated">캐스트 할 가치</target>
        </trans-unit>
        <trans-unit id="4becd373a9abdf90daf7afd7952190cfbdb6a722" translate="yes" xml:space="preserve">
          <source>The values of the attempted update</source>
          <target state="translated">시도한 업데이트의 값</target>
        </trans-unit>
        <trans-unit id="8879fe3df52b3bfc453dc46fb7061554a846b88a" translate="yes" xml:space="preserve">
          <source>Then you can just expose file with proper environment variables.</source>
          <target state="translated">그런 다음 적절한 환경 변수로 파일을 노출시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43f2635dbec46649203b3c3aa4d04bf38df84e6b" translate="yes" xml:space="preserve">
          <source>There are currently three ways to programmatically add hooks:</source>
          <target state="translated">프로그래밍 방식으로 후크를 추가하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c7e03a8c32ed1f6358530c8e620ba1250325a0a" translate="yes" xml:space="preserve">
          <source>There are several ways to update and add new associations. Continuing with our example of users and pictures:</source>
          <target state="translated">새 연결을 업데이트하고 추가하는 방법에는 여러 가지가 있습니다. 사용자와 사진의 예를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="a36b1d5200c1e31ac985860d6dd0f09141f565f9" translate="yes" xml:space="preserve">
          <source>There are three types of storage that you can use: &lt;code&gt;sequelize&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, and &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">사용할 수있는 세 가지 유형의 스토리지가 있습니다 : &lt;code&gt;sequelize&lt;/code&gt; , &lt;code&gt;json&lt;/code&gt; 및 &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27fdccefc377e17f5a26fc7558b9e7867964fb5d" translate="yes" xml:space="preserve">
          <source>There is also a method for counting database objects:</source>
          <target state="translated">데이터베이스 객체를 계산하는 방법도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cd8a91416dbf4cf3a9c701869ca2f37c200a92ff" translate="yes" xml:space="preserve">
          <source>There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value from a function.</source>
          <target state="translated">다른 알고리즘에 맞는 고유 한 UUID를 생성하려는 경우가 있습니다. defaultValue 속성도 사용하지만 제공된 UUID 유형 중 하나를 지정하는 대신 함수에서 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55682363d7e0f2ffc9293ceaaddad46cafb5c483" translate="yes" xml:space="preserve">
          <source>Therefore, one can just follow the &lt;a href=&quot;http://geojson.org/geojson-spec.html&quot;&gt;GeoJSON spec&lt;/a&gt; for handling geometry objects. See the following examples:</source>
          <target state="translated">따라서 &lt;a href=&quot;http://geojson.org/geojson-spec.html&quot;&gt;GeoJSON 사양&lt;/a&gt; 을 따라 지오메트리 객체를 처리 할 수 있습니다 . 다음 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="02cc698e9e580c5b08002ced8ca01c4ddd96bbfc" translate="yes" xml:space="preserve">
          <source>These four scopes can be deeply merged easily, for example by calling &lt;code&gt;Foo.scope('includeEverything', 'limitedBars', 'limitedBazs', 'excludeBazName').findAll()&lt;/code&gt;, which would be entirely equivalent to calling the following:</source>
          <target state="translated">이 네 가지 범위는 &lt;code&gt;Foo.scope('includeEverything', 'limitedBars', 'limitedBazs', 'excludeBazName').findAll()&lt;/code&gt; 을 호출하여 쉽게 병합 할 수 있습니다 . 이는 다음을 호출하는 것과 완전히 같습니다.</target>
        </trans-unit>
        <trans-unit id="af59fc7567d7e359f06c4a1e994f367061e3a2b5" translate="yes" xml:space="preserve">
          <source>These hooks can be useful if you need to asynchronously obtain database credentials, or need to directly access the low-level database connection after it has been created.</source>
          <target state="translated">이 후크는 데이터베이스 신임 정보를 비동기 적으로 확보해야하거나 저수준 데이터베이스 연결이 작성된 후 직접 액세스해야하는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c2d955f8a133fd17bc66cfb7a3733b5cd31863d" translate="yes" xml:space="preserve">
          <source>These hooks may &lt;em&gt;only&lt;/em&gt; be declared as a permanent global hook, as the connection pool is shared by all models.</source>
          <target state="translated">연결 풀은 모든 모델에서 공유 &lt;em&gt;되므로&lt;/em&gt; 이러한 후크는 영구 전역 후크 &lt;em&gt;로만&lt;/em&gt; 선언 될 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c389d6b65a20f268408819e6a860c1a7c78109f" translate="yes" xml:space="preserve">
          <source>These options are merged with the default define options provided to the Sequelize constructor</source>
          <target state="translated">이러한 옵션은 Sequelize 생성자에 제공된 기본 정의 옵션과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="5c4f7d575b88a1fe31445dc78190b51d6048577f" translate="yes" xml:space="preserve">
          <source>These options are merged with the default define options provided to the Sequelize constructor and passed to Model.init()</source>
          <target state="translated">이러한 옵션은 Sequelize 생성자에 제공된 기본 정의 옵션과 병합되어 Model.init ()에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5072453b0e64084c89bc87592d919214af9d10e1" translate="yes" xml:space="preserve">
          <source>Third, you can define an object containing fields and its decrement values.</source>
          <target state="translated">셋째, 필드와 그 감소 값을 포함하는 개체를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcc27019080f65da23ea2d1c9787f788f23d98f5" translate="yes" xml:space="preserve">
          <source>Third, you can define an object containing fields and its increment values.</source>
          <target state="translated">셋째, 필드와 증분 값을 포함하는 객체를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e0152b992d8dcce6cbd8bc1cda5d54dde247ffb" translate="yes" xml:space="preserve">
          <source>This adds a default hook to all models, which is run if the model does not define its own &lt;code&gt;beforeCreate&lt;/code&gt; hook:</source>
          <target state="translated">이렇게하면 모든 모델에 기본 후크가 추가됩니다. 이는 모델이 자체 &lt;code&gt;beforeCreate&lt;/code&gt; 후크를 정의하지 않은 경우 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="727c4075b5f4eb6d72cffa60b8be8ca9040e313f" translate="yes" xml:space="preserve">
          <source>This can be simply solved by passing &lt;code&gt;{individualHooks: true}&lt;/code&gt; to the &lt;code&gt;remove&lt;/code&gt; call, resulting on each hook to be called on each removed through instance object.</source>
          <target state="translated">&lt;code&gt;{individualHooks: true}&lt;/code&gt; 를 &lt;code&gt;remove&lt;/code&gt; 호출 에 전달하여 간단하게 해결할 수 있으므로 인스턴스 객체를 통해 제거 될 때마다 각 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e7dd309e7a42d2a5b7a13fba0fcf976b9b08e4f8" translate="yes" xml:space="preserve">
          <source>This code will run beforeDestroy/afterDestroy on the Tasks table. Sequelize, by default, will try to optimize your queries as much as possible. When calling cascade on delete, Sequelize will simply execute a</source>
          <target state="translated">이 코드는 작업 테이블에서 beforeDestroy / afterDestroy를 실행합니다. Sequelize는 기본적으로 쿼리를 최대한 최적화하려고 시도합니다. 삭제시 캐스케이드를 호출하면 Sequelize는 단순히</target>
        </trans-unit>
        <trans-unit id="18c9fea6466ac62731b3270babfae248a5a4f00c" translate="yes" xml:space="preserve">
          <source>This command will create a seed file in &lt;code&gt;seeders&lt;/code&gt; folder. File name will look something like &lt;code&gt;XXXXXXXXXXXXXX-demo-user.js&lt;/code&gt;. It follows the same &lt;code&gt;up / down&lt;/code&gt; semantics as the migration files.</source>
          <target state="translated">이 명령은 &lt;code&gt;seeders&lt;/code&gt; 폴더에 seed 파일을 작성 합니다. 파일 이름은 &lt;code&gt;XXXXXXXXXXXXXX-demo-user.js&lt;/code&gt; 와 비슷 합니다. 마이그레이션 파일 과 동일한 &lt;code&gt;up / down&lt;/code&gt; 시맨틱을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="99b346a29a6d16c0ff1ed00bc189c11d20ca7b4d" translate="yes" xml:space="preserve">
          <source>This command will execute these steps:</source>
          <target state="translated">이 명령은 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c63d621f524bac03f030a99ca6604e6cf1edd0b4" translate="yes" xml:space="preserve">
          <source>This example will return an error:</source>
          <target state="translated">이 예제는 오류를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="1a7c83b5a5af156c9b822efe6ff13494455e205c" translate="yes" xml:space="preserve">
          <source>This extra capability is useful when, for example, &lt;code&gt;Error: Cannot find module&lt;/code&gt; is thrown even though &lt;code&gt;/path/to/models/project&lt;/code&gt; seems to be correct. Some frameworks, such as Meteor, overload &lt;code&gt;require&lt;/code&gt;, and spit out &quot;surprise&quot; results like :</source>
          <target state="translated">예를 들어, 때, 이러한 추가 기능은 유용 &lt;code&gt;Error: Cannot find module&lt;/code&gt; 비록 발생합니다 &lt;code&gt;/path/to/models/project&lt;/code&gt; 올바른 것 같다. Meteor와 같은 일부 프레임 워크에는 과부하가 &lt;code&gt;require&lt;/code&gt; 하며 다음과 같은 &quot;놀라운&quot;결과를 내뱉습니다.</target>
        </trans-unit>
        <trans-unit id="ce7f17201e64eb37f1103f4b3786c11feb4123ee" translate="yes" xml:space="preserve">
          <source>This hook is always run before create, regardless of whether the model specifies its own &lt;code&gt;beforeCreate&lt;/code&gt; hook. Local hooks are always run before global hooks:</source>
          <target state="translated">이 후크는 모델이 고유 한 &lt;code&gt;beforeCreate&lt;/code&gt; 후크를 지정하는지 여부에 관계없이 항상 작성 전에 실행 됩니다. 로컬 후크는 항상 글로벌 후크보다 먼저 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="360cb791231c2363b1194e7b256c83b51766b491" translate="yes" xml:space="preserve">
          <source>This is a convenience method that combines&lt;code&gt;findAll&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; (see below) this is useful when dealing with queries related to pagination where you want to retrieve data with a &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; but also need to know the total number of records that match the query:</source>
          <target state="translated">이것은 &lt;code&gt;findAll&lt;/code&gt; 과 &lt;code&gt;count&lt;/code&gt; (아래 참조) 를 결합한 편리한 방법 으로, &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; 데이터를 검색하려고 하지만 쿼리와 일치하는 총 레코드 수를 알아야하는 페이지 매김 관련 쿼리를 처리 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="0e6e7c29c6f7275c747733e61664e0b1a268e99f" translate="yes" xml:space="preserve">
          <source>This is a special configuration file. It lets you specify following options that you would usually pass as arguments to CLI:</source>
          <target state="translated">이것은 특수 구성 파일입니다. 일반적으로 CLI에 인수로 전달할 다음 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55bdb2f2ecde4b760da3d764aa2f4098da22b6d1" translate="yes" xml:space="preserve">
          <source>This is solved by passing in Meteor's version of &lt;code&gt;require&lt;/code&gt;. So, while this probably fails ...</source>
          <target state="translated">이것은 Meteor의 &lt;code&gt;require&lt;/code&gt; 버전을 전달함으로써 해결됩니다 . 따라서 이것이 실패하는 동안 ...</target>
        </trans-unit>
        <trans-unit id="d228ea5a39b7651eb309d93cc8036fdcc5148f0e" translate="yes" xml:space="preserve">
          <source>This is the main class, the entry point to sequelize.</source>
          <target state="translated">이것이 주요 클래스이며, 시퀀싱 할 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="818eb257f30469f3bc2e4ca907767013465c744e" translate="yes" xml:space="preserve">
          <source>This is the same as calling &lt;code&gt;set&lt;/code&gt; and then calling &lt;code&gt;save&lt;/code&gt; but it only saves the exact values passed to it, making it more atomic and safer.</source>
          <target state="translated">이것은 &lt;code&gt;set&lt;/code&gt; 호출 후 &lt;code&gt;save&lt;/code&gt; 호출과 동일 하지만 전달 된 정확한 값만 저장하므로보다 원자적이고 안전합니다.</target>
        </trans-unit>
        <trans-unit id="60296b6b0d7e855566b012be2c4526118c0d9f5e" translate="yes" xml:space="preserve">
          <source>This means that errors can be accessed using &lt;code&gt;Sequelize.ValidationError&lt;/code&gt; The Base Error all Sequelize Errors inherit from.</source>
          <target state="translated">이는 &lt;code&gt;Sequelize.ValidationError&lt;/code&gt; 를 사용하여 오류에 액세스 할 수 있음을 의미합니다 . 모든 Sequelize 오류에서 상속 된 기본 오류입니다.</target>
        </trans-unit>
        <trans-unit id="448935a1c8176ac36ebc22b0c9a61a4f6c534df7" translate="yes" xml:space="preserve">
          <source>This means you can, for instance, have a string field which validates its length to be between 5 and 10 characters, but which also allows &lt;code&gt;null&lt;/code&gt; (since the length validator will be skipped automatically when the value is &lt;code&gt;null&lt;/code&gt;):</source>
          <target state="translated">즉, 예를 들어 길이가 5 ~ 10 자 사이인지 유효성을 검사하지만 &lt;code&gt;null&lt;/code&gt; 을 허용하는 문자열 필드를 가질 수 있습니다 (값이 &lt;code&gt;null&lt;/code&gt; 일 때 길이 유효성 검사기가 자동으로 건너 뛰기 때문에 ).</target>
        </trans-unit>
        <trans-unit id="f467b722eea19d74de979567087d7f5e134044a3" translate="yes" xml:space="preserve">
          <source>This merge strategy also works in the exact same way with options passed to &lt;code&gt;.findAll&lt;/code&gt;, &lt;code&gt;.findOne&lt;/code&gt; and the like.</source>
          <target state="translated">이 병합 전략은 &lt;code&gt;.findAll&lt;/code&gt; , &lt;code&gt;.findOne&lt;/code&gt; 등에 전달 된 옵션과 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="59bd238f74715c77711ae06cecfc32b0565a57cb" translate="yes" xml:space="preserve">
          <source>This method is intended for use cases where the same model is needed in multiple schemas. In such a use case it is important to call &lt;code&gt;model.schema(schema, [options]).sync()&lt;/code&gt; for each model to ensure the models are created in the correct schema.</source>
          <target state="translated">이 방법은 여러 스키마에서 동일한 모델이 필요한 사용 사례를위한 것입니다. 이러한 사용 사례 에서는 모델이 올바른 스키마로 작성되도록 각 모델에 대해 &lt;code&gt;model.schema(schema, [options]).sync()&lt;/code&gt; 를 호출하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="a61048d15d1fb9bb46b03055071e6483faf68341" translate="yes" xml:space="preserve">
          <source>This method now tests for equality with &lt;code&gt;_.isEqual&lt;/code&gt; and is now deep aware. Modifying nested value for JSON object won't mark them as changed, because it is still the same object.</source>
          <target state="translated">이 메소드 는 이제 &lt;code&gt;_.isEqual&lt;/code&gt; 과의 동등성을 테스트하며 이제는 깊이 인식하고 있습니다. JSON 객체의 중첩 값을 수정해도 여전히 동일한 객체이므로 변경된 것으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab79309eddccd5e656cb0c27289b25d6187e3837" translate="yes" xml:space="preserve">
          <source>This method returns an array of hashes containing information about all attributes in the table.</source>
          <target state="translated">이 메소드는 테이블의 모든 속성에 대한 정보가 포함 된 해시 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d7799f45dcea4d7688e16027f4fe2c94d214d595" translate="yes" xml:space="preserve">
          <source>This section concerns association scopes. For a definition of association scopes vs. scopes on associated models, see &lt;a href=&quot;scopes&quot;&gt;Scopes&lt;/a&gt;.</source>
          <target state="translated">이 섹션은 연결 범위와 관련이 있습니다. 관련 모델 협회 범위 대 범위에 대한 정의, 참조 &lt;a href=&quot;scopes&quot;&gt;범위를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8afc09530510c13953a1c7a8aa226af2c4660e35" translate="yes" xml:space="preserve">
          <source>This section describes the various association types in sequelize. There are four types of associations available in Sequelize</source>
          <target state="translated">이 섹션에서는 다양한 연결 유형에 대해 설명합니다. Sequelize에는 4 가지 유형의 연결이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5db820e5273e88ea3c74abb859bd5e860f6a011" translate="yes" xml:space="preserve">
          <source>This specifies that the &lt;code&gt;uid&lt;/code&gt; column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see &lt;code&gt;constraints: false&lt;/code&gt; below).</source>
          <target state="translated">이는 &lt;code&gt;uid&lt;/code&gt; 열이 널이 될 수 없도록 지정합니다 . 대부분의 경우이 이미 sequelize가 자동으로 생성 외래 키 제약 조건이 적용되지만, 외부 키 때문에 순환 참조로 예를 들면, 사용할 수있는 경우에 유용 할 수 있습니다 ( &lt;code&gt;constraints: false&lt;/code&gt; 아래 참조).</target>
        </trans-unit>
        <trans-unit id="b0748e5edf89087179c3ffcbaa9289fdfc2bb735" translate="yes" xml:space="preserve">
          <source>This will add methods &lt;code&gt;getUsers&lt;/code&gt;, &lt;code&gt;setUsers&lt;/code&gt;, &lt;code&gt;addUser&lt;/code&gt;,&lt;code&gt;addUsers&lt;/code&gt; to &lt;code&gt;Project&lt;/code&gt;, and &lt;code&gt;getProjects&lt;/code&gt;, &lt;code&gt;setProjects&lt;/code&gt;, &lt;code&gt;addProject&lt;/code&gt;, and &lt;code&gt;addProjects&lt;/code&gt; to &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">이 방법의 추가합니다 &lt;code&gt;getUsers&lt;/code&gt; , &lt;code&gt;setUsers&lt;/code&gt; , &lt;code&gt;addUser&lt;/code&gt; , &lt;code&gt;addUsers&lt;/code&gt; 에 &lt;code&gt;Project&lt;/code&gt; 및 &lt;code&gt;getProjects&lt;/code&gt; , &lt;code&gt;setProjects&lt;/code&gt; , &lt;code&gt;addProject&lt;/code&gt; 및 &lt;code&gt;addProjects&lt;/code&gt; 을 에 &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a6e951fad358490ec5b1a5a9c3f372af691a820" translate="yes" xml:space="preserve">
          <source>This will add the attribute &lt;code&gt;projectId&lt;/code&gt; to User. Depending on your setting for underscored the column in the table will either be called &lt;code&gt;projectId&lt;/code&gt; or &lt;code&gt;project_id&lt;/code&gt;. Instances of Project will get the accessors &lt;code&gt;getWorkers&lt;/code&gt; and &lt;code&gt;setWorkers&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;projectId&lt;/code&gt; 속성 이 User에 추가됩니다 . 밑줄로 표시된 설정에 따라 테이블의 열을 &lt;code&gt;projectId&lt;/code&gt; 또는 &lt;code&gt;project_id&lt;/code&gt; 로 지정 합니다. Project 인스턴스는 접근 자 &lt;code&gt;getWorkers&lt;/code&gt; 및 &lt;code&gt;setWorkers&lt;/code&gt; 를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="fb8b8f31c57ee6c953321682693ac70ebefd2921" translate="yes" xml:space="preserve">
          <source>This will add the functions &lt;code&gt;add/set/get Tasks&lt;/code&gt; to user instances.</source>
          <target state="translated">그러면 &lt;code&gt;add/set/get Tasks&lt;/code&gt; 기능 이 사용자 인스턴스에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3463bc037bb376387fd4ec78e9ecc3a0802278d7" translate="yes" xml:space="preserve">
          <source>This will create a new model called UserProject with the equivalent foreign keys &lt;code&gt;projectId&lt;/code&gt; and &lt;code&gt;userId&lt;/code&gt;. Whether the attributes are camelcase or not depends on the two models joined by the table (in this case User and Project).</source>
          <target state="translated">외래 키 &lt;code&gt;projectId&lt;/code&gt; 및 &lt;code&gt;userId&lt;/code&gt; 와 함께 UserProject라는 새 모델이 생성됩니다 . 속성이 camelcase인지 여부는 테이블에 의해 결합 된 두 모델 (이 경우 사용자 및 프로젝트)에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9218fafa583e55dc7276e3c7c13b1abc3b031c76" translate="yes" xml:space="preserve">
          <source>This will create following folders</source>
          <target state="translated">이것은 다음 폴더를 생성합니다</target>
        </trans-unit>
        <trans-unit id="77d3388ed7356b4ccde3d30587156a82a628f725" translate="yes" xml:space="preserve">
          <source>This will do following</source>
          <target state="translated">이것은 다음을 할 것입니다</target>
        </trans-unit>
        <trans-unit id="b9cd56142426d9d64bccca3cb45bcbe0b6b31b91" translate="yes" xml:space="preserve">
          <source>This will execute that seed file and you will have a demo user inserted into &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">그러면 시드 파일이 실행되고 데모 테이블이 &lt;code&gt;User&lt;/code&gt; 테이블에 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="17023fd3d297e103adfb2cd08cb3d64972ed6758" translate="yes" xml:space="preserve">
          <source>This will produce an outer join. However, a &lt;code&gt;where&lt;/code&gt; clause on a related model will create an inner join and return only the instances that have matching sub-models. To return all parent instances, you should add &lt;code&gt;required: false&lt;/code&gt;.</source>
          <target state="translated">외부 조인이 생성됩니다. 그러나 관련 모델 의 &lt;code&gt;where&lt;/code&gt; 절은 내부 조인을 만들고 일치하는 하위 모델이있는 인스턴스 만 반환합니다. 모든 부모 인스턴스를 반환하려면 &lt;code&gt;required: false&lt;/code&gt; 추가 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="587b8c9b10a65cfc3263ff9ed36c73f795eee87e" translate="yes" xml:space="preserve">
          <source>Those details contains constraintSchema, constraintName, constraintCatalog tableCatalog, tableSchema, tableName, columnName, referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName. Remind: constraint informations won't return if it's sqlite.</source>
          <target state="translated">이러한 세부 사항에는 constraintSchema, constraintName, constraintCatalog tableCatalog, tableSchema, tableName, columnName, ReferenceTableCatalog, ReferenceTableCatalog, ReferenceTableSchema, ReferenceTableName, ReferenceColumnName이 포함됩니다. 주의 : 제약 정보는 sqlite이면 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4210ffe78330b024ede5237dbfe86d9b9b93cd25" translate="yes" xml:space="preserve">
          <source>Three of the values provided here (&lt;code&gt;NOW&lt;/code&gt;, &lt;code&gt;UUIDV1&lt;/code&gt; and &lt;code&gt;UUIDV4&lt;/code&gt;) are special default values, that should not be used to define types. Instead they are used as shorthands for defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:</source>
          <target state="translated">여기에 제공된 세 개의 값 ( &lt;code&gt;NOW&lt;/code&gt; , &lt;code&gt;UUIDV1&lt;/code&gt; 및 &lt;code&gt;UUIDV4&lt;/code&gt; )은 특수 기본값이며 유형을 정의하는 데 사용해서는 안됩니다. 대신 기본값을 정의하기위한 속기로 사용됩니다. 예를 들어, UUID 표준 v1에 따라 생성 된 기본값으로 uuid 필드를 가져 오려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="91f71b1ba50409fa2b7c9ba85860ac52be6266d4" translate="yes" xml:space="preserve">
          <source>Throw errors to rollback</source>
          <target state="translated">롤백 오류 발생</target>
        </trans-unit>
        <trans-unit id="aa4f8c68ebe136d0527ece013ceac731e1a278f9" translate="yes" xml:space="preserve">
          <source>Throw:</source>
          <target state="translated">Throw:</target>
        </trans-unit>
        <trans-unit id="23d750e22af391e584ca1e4a39c95bd2fb56383e" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database has a hostname that was not found</source>
          <target state="translated">데이터베이스 연결에 찾을 수없는 호스트 이름이있는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d2625383a632bae08070641f222b8caa05d99960" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database has a hostname that was not reachable</source>
          <target state="translated">데이터베이스에 연결할 수없는 호스트 이름이있는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="87034a0755bcd6f36454ca6ff35ee17a4ff4e0e8" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database has invalid values for any of the connection parameters</source>
          <target state="translated">데이터베이스 연결에 연결 매개 변수에 대해 유효하지 않은 값이있는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="32d6e188736023fe8847cd2d2013f87cf98d8009" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database is refused</source>
          <target state="translated">데이터베이스 연결이 거부되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b9258c976382ddb24c62d8d005000b6a6fe5d6f6" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database is refused due to insufficient privileges</source>
          <target state="translated">권한이 부족하여 데이터베이스 연결이 거부 된 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2043393f9e3b9fda84e6662489c8d9c0829b258d" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database times out</source>
          <target state="translated">데이터베이스 연결 시간이 초과되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7bc64491ce5ca9b21f53e4cdc887f0f85bc7a079" translate="yes" xml:space="preserve">
          <source>Thrown when a database query times out because of a deadlock</source>
          <target state="translated">교착 상태로 인해 데이터베이스 쿼리 시간이 초과되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="679f3a1755d005602bfa972024e02b80ed5161dc" translate="yes" xml:space="preserve">
          <source>Thrown when a foreign key constraint is violated in the database</source>
          <target state="translated">데이터베이스에서 외래 키 제약 조건을 위반하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c84afedad343819211df62f9869172701d2dd1e5" translate="yes" xml:space="preserve">
          <source>Thrown when a query is passed invalid options (see message for details)</source>
          <target state="translated">쿼리에 유효하지 않은 옵션이 전달되면 발생합니다 (자세한 내용은 메시지 참조).</target>
        </trans-unit>
        <trans-unit id="7fabff6c09f652154afe11474aa9248b265cfe1c" translate="yes" xml:space="preserve">
          <source>Thrown when a record was not found, Usually used with rejectOnEmpty mode (see message for details)</source>
          <target state="translated">레코드를 찾을 수 없을 때 발생하며 일반적으로 rejectOnEmpty 모드와 함께 사용됩니다 (자세한 내용은 메시지 참조).</target>
        </trans-unit>
        <trans-unit id="c3c1771c4a29df5e79cf3befa41cf4598a7dee58" translate="yes" xml:space="preserve">
          <source>Thrown when a some problem occurred with Instance methods (see message for details)</source>
          <target state="translated">인스턴스 메소드에 문제가 발생했을 때 발생합니다 (자세한 내용은 메시지 참조).</target>
        </trans-unit>
        <trans-unit id="95bb12467ace2eea8fc434c8b6c9df4d88b333d1" translate="yes" xml:space="preserve">
          <source>Thrown when a unique constraint is violated in the database</source>
          <target state="translated">데이터베이스에서 고유 제한 조건을 위반하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80ae4ddebfd7c82c02a5f23fec873816cf61746c" translate="yes" xml:space="preserve">
          <source>Thrown when an association is improperly constructed (see message for details)</source>
          <target state="translated">연결이 잘못 구성되면 발생합니다 (자세한 내용은 메시지 참조).</target>
        </trans-unit>
        <trans-unit id="89746572ae55e12747db0aea1e20bddf39ed7d39" translate="yes" xml:space="preserve">
          <source>Thrown when an exclusion constraint is violated in the database</source>
          <target state="translated">데이터베이스에서 제외 제약 조건을 위반하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8f157735ee3bf7ab21bc6f16555acb23bc8c29f3" translate="yes" xml:space="preserve">
          <source>Thrown when an include statement is improperly constructed (see message for details)</source>
          <target state="translated">include 문이 잘못 구성되면 발생합니다 (자세한 내용은 메시지 참조).</target>
        </trans-unit>
        <trans-unit id="0fd16d932a52421ae2e328140ee63e38a615cfb3" translate="yes" xml:space="preserve">
          <source>Thrown when attempting to update a stale model instance</source>
          <target state="translated">오래된 모델 인스턴스를 업데이트하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7bc42c3b804e8b465e46ba8bd9b5e3206dc76ac4" translate="yes" xml:space="preserve">
          <source>Thrown when bulk operation fails, it represent per record level error.</source>
          <target state="translated">대량 작업이 실패하면 발생하며 이는 레코드 수준 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ae1229aaedb2ae0a2feaf4bc910bd5a9a676762a" translate="yes" xml:space="preserve">
          <source>Thrown when bulk operation fails, it represent per record level error. Used with Promise.AggregateError</source>
          <target state="translated">대량 작업이 실패하면 발생하며 이는 레코드 수준 오류를 나타냅니다. Promise.AggregateError와 함께 사용</target>
        </trans-unit>
        <trans-unit id="f9edfc205cf5a5c20603f1d3b7c72767c3a4d4b9" translate="yes" xml:space="preserve">
          <source>Thrown when connection is not acquired due to timeout</source>
          <target state="translated">시간 초과로 인해 연결을 얻지 못한 경우 발생</target>
        </trans-unit>
        <trans-unit id="7fceaebd6f438961290420060fe3b510c240b8f3" translate="yes" xml:space="preserve">
          <source>Thrown when constraint name is not found in the database</source>
          <target state="translated">데이터베이스에서 제약 조건 이름을 찾을 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c1175bafb21b858838d4ed47ad6843f2f62f711c" translate="yes" xml:space="preserve">
          <source>Throws an error when no records found</source>
          <target state="translated">레코드를 찾지 못하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="22a4ad2c60d9b1a4a4ab47810c732e12faec00b0" translate="yes" xml:space="preserve">
          <source>TimeoutError</source>
          <target state="translated">TimeoutError</target>
        </trans-unit>
        <trans-unit id="c04ed1238a14de2b02d7fd14a7e9605bb1b10b96" translate="yes" xml:space="preserve">
          <source>Timestamps</source>
          <target state="translated">Timestamps</target>
        </trans-unit>
        <trans-unit id="852d13828c37fb9d96ffea0f8ba5d4177325009c" translate="yes" xml:space="preserve">
          <source>To add a new project to a user and set its status, you pass extra &lt;code&gt;options.through&lt;/code&gt; to the setter, which contains the attributes for the join table</source>
          <target state="translated">사용자에게 새 프로젝트를 추가하고 상태를 설정하려면 추가 &lt;code&gt;options.through&lt;/code&gt; 을 통해 결합 테이블에 대한 속성이 포함 된 setter로 전달 하십시오.</target>
        </trans-unit>
        <trans-unit id="ac8fd1770455d2404985a693194adf77d45c1bff" translate="yes" xml:space="preserve">
          <source>To connect over a unix domain socket, specify the path to the socket directory in the &lt;code&gt;host&lt;/code&gt; option.</source>
          <target state="translated">유닉스 도메인 소켓을 통해 연결하려면 &lt;code&gt;host&lt;/code&gt; 옵션 에서 소켓 디렉토리의 경로를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="062d1b4f01aa30692a7d36958d9c8a163ef0fa87" translate="yes" xml:space="preserve">
          <source>To connect to the database, you must create a Sequelize instance. This can be done by either passing the connection parameters separately to the Sequelize constructor or by passing a single connection URI:</source>
          <target state="translated">데이터베이스에 연결하려면 Sequelize 인스턴스를 작성해야합니다. 연결 매개 변수를 Sequelize 생성자에 개별적으로 전달하거나 단일 연결 URI를 전달하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da44e1aec269feef0bce9b3580109c553da536c7" translate="yes" xml:space="preserve">
          <source>To create an empty project you will need to execute &lt;code&gt;init&lt;/code&gt; command</source>
          <target state="translated">빈 프로젝트를 만들려면 &lt;code&gt;init&lt;/code&gt; 명령 을 실행해야합니다</target>
        </trans-unit>
        <trans-unit id="71fb99144f8e1ab035cde5271b9fd31e7e57bd68" translate="yes" xml:space="preserve">
          <source>To define mappings between a model and a table, use the &lt;code&gt;define&lt;/code&gt; method. Each column must have a datatype, see more about &lt;a href=&quot;data-types&quot;&gt;datatypes&lt;/a&gt;.</source>
          <target state="translated">모델과 테이블 사이의 매핑을 정의하기 위해 사용하는 &lt;code&gt;define&lt;/code&gt; 방법을. 각 열은 데이터 형식이에 대한 자세한보고해야 &lt;a href=&quot;data-types&quot;&gt;데이터 유형&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dda2146b56aea2f43e17df568053cae2211defe9" translate="yes" xml:space="preserve">
          <source>To define your own primary key:</source>
          <target state="translated">자신의 기본 키를 정의하려면</target>
        </trans-unit>
        <trans-unit id="f0c9aa566dd042ca2109aefb26d5db9701348ed9" translate="yes" xml:space="preserve">
          <source>To disable the default scope, pass &lt;code&gt;scope: null&lt;/code&gt; to the getter: &lt;code&gt;User.getPosts({ scope: null })&lt;/code&gt;. Similarly, if you want to apply other scopes, pass an array like you would to &lt;code&gt;.scope&lt;/code&gt;:</source>
          <target state="translated">기본 범위를 비활성화하려면 &lt;code&gt;scope: null&lt;/code&gt; 을 getter : &lt;code&gt;User.getPosts({ scope: null })&lt;/code&gt; . 마찬가지로 다른 범위를 적용하려면 &lt;code&gt;.scope&lt;/code&gt; 와 같이 배열을 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6463d8d9d72d8a88eca88bfd39719af73a2f3fb1" translate="yes" xml:space="preserve">
          <source>To enable CLS you must tell sequelize which namespace to use by using a static method of the sequelize constructor:</source>
          <target state="translated">CLS를 사용하려면 sequelize 생성자의 정적 메서드를 사용하여 sequelize에 사용할 네임 스페이스를 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="87f6d681b01751ff8331a911939a0019959ee185" translate="yes" xml:space="preserve">
          <source>To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor:</source>
          <target state="translated">CLS를 사용 가능하게하려면 프로젝트에 추가하고 네임 스페이스를 작성한 후 시퀀스 생성자에서 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6e021f11d5b93d2d56eff3f6527dc41d1add80d2" translate="yes" xml:space="preserve">
          <source>To extend Sequelize datatypes, do it before any instance is created. This example creates a dummy &lt;code&gt;NEWTYPE&lt;/code&gt; that replicates the built-in datatype &lt;code&gt;Sequelize.INTEGER(11).ZEROFILL.UNSIGNED&lt;/code&gt;.</source>
          <target state="translated">Sequelize 데이터 유형을 확장하려면 인스턴스를 작성하기 전에 수행하십시오. 이 예제 는 내장 데이터 유형 &lt;code&gt;Sequelize.INTEGER(11).ZEROFILL.UNSIGNED&lt;/code&gt; 를 복제 하는 더미 &lt;code&gt;NEWTYPE&lt;/code&gt; 을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="08fd9370c478abbfbe5b9098d6a2c2698f6d2737" translate="yes" xml:space="preserve">
          <source>To get full control over the foreign key column added by sequelize, you can use the &lt;code&gt;foreignKey&lt;/code&gt; option. It can either be a string, that specifies the name, or and object type definition, equivalent to those passed to &lt;code&gt;sequelize.define&lt;/code&gt;.</source>
          <target state="translated">sequelize로 추가 된 외래 키 열을 완전히 제어하려면 &lt;code&gt;foreignKey&lt;/code&gt; 옵션을 사용할 수 있습니다 . 이름을 지정하는 문자열이거나 &lt;code&gt;sequelize.define&lt;/code&gt; 에 전달 된 것과 동등한 오브젝트 유형 정의 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b302c9710f47440c1d0dbf353af407bf35573b5" translate="yes" xml:space="preserve">
          <source>To get it stored in the database, use the &lt;code&gt;save&lt;/code&gt;-method and catch the events ... if needed:</source>
          <target state="translated">데이터베이스에 저장하려면 &lt;code&gt;save&lt;/code&gt; -method를 사용하고 필요한 경우 이벤트를 포착하십시오.</target>
        </trans-unit>
        <trans-unit id="81359c1e15ebff6b36cb1d90106dde4b80bd06a7" translate="yes" xml:space="preserve">
          <source>To get more relevant data, you can use limit, offset, order and grouping:</source>
          <target state="translated">보다 관련성이 높은 데이터를 얻으려면 한계, 오프셋, 순서 및 그룹화를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fb9a241f10c959268058c116425f0667f1b4bdc" translate="yes" xml:space="preserve">
          <source>To include all attributes, you can pass a single object with &lt;code&gt;all: true&lt;/code&gt;:</source>
          <target state="translated">모든 속성을 포함시키기 위해 모두 단일 객체를 전달할 수 있습니다 &lt;code&gt;all: true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="41a7882efafea18d939a044b5476e2e2db5db42b" translate="yes" xml:space="preserve">
          <source>To invoke scope functions you can do</source>
          <target state="translated">범위 함수를 호출하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6ff66a578ca5331ff221d03e2780d2b820c5ce62" translate="yes" xml:space="preserve">
          <source>To learn more about how to use Sequelize, read the tutorials available in the left menu. Begin with &lt;a href=&quot;manual/getting-started&quot;&gt;Getting Started&lt;/a&gt;.</source>
          <target state="translated">Sequelize 사용 방법에 대한 자세한 내용은 왼쪽 메뉴에서 제공되는 자습서를 읽으십시오. 시작 &lt;a href=&quot;manual/getting-started&quot;&gt;하기로 시작하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82a28ba40b57129812c63ec44c7e5de69d719c98" translate="yes" xml:space="preserve">
          <source>To manage all data migrations you can use seeders. Seed files are some change in data that can be used to populate database table with sample data or test data.</source>
          <target state="translated">모든 데이터 마이그레이션을 관리하기 위해 파종기를 사용할 수 있습니다. 시드 파일은 데이터베이스 테이블을 샘플 데이터 또는 테스트 데이터로 채우는 데 사용할 수있는 일부 데이터 변경입니다.</target>
        </trans-unit>
        <trans-unit id="d41c172a89209d5b09fd5ea5fc82930a6a93002c" translate="yes" xml:space="preserve">
          <source>To move the where conditions from an included model from the &lt;code&gt;ON&lt;/code&gt; condition to the top level &lt;code&gt;WHERE&lt;/code&gt; you can use the &lt;code&gt;'$nested.column$'&lt;/code&gt; syntax:</source>
          <target state="translated">로부터는 포함 된 모델에서 어디 조건을 이동하려면 &lt;code&gt;ON&lt;/code&gt; 의 최고 수준의 조건 당신이 사용할 수있는 &lt;code&gt;'$nested.column$'&lt;/code&gt; 구문 : &lt;code&gt;WHERE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43c3e345f72eba5c3efd1485f74d109a6eedabc7" translate="yes" xml:space="preserve">
          <source>To provide a length for the data type, you can invoke it like a function: &lt;code&gt;INTEGER(2)&lt;/code&gt;</source>
          <target state="translated">데이터 유형의 길이를 제공하기 위해 함수처럼 호출 할 수 있습니다. &lt;code&gt;INTEGER(2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c3ee3dbbd358f5ea3a5375e13ef5d5f193d5514" translate="yes" xml:space="preserve">
          <source>To recap, the elements of the order/group array can be the following:</source>
          <target state="translated">요약하면 주문 / 그룹 배열의 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f0557f6152bcc28fed2088bbb5968f3d7399eb3" translate="yes" xml:space="preserve">
          <source>To remove created associations you can just call the set method without a specific id:</source>
          <target state="translated">생성 된 연결을 제거하려면 특정 ID없이 set 메소드를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ed480fdfa306848b35b4f98b434fd446ccbad0" translate="yes" xml:space="preserve">
          <source>To select only some attributes, you can use the &lt;code&gt;attributes&lt;/code&gt; option. Most often, you pass an array:</source>
          <target state="translated">일부 속성 만 선택하려면 &lt;code&gt;attributes&lt;/code&gt; 옵션을 사용할 수 있습니다 . 대부분 배열을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9c0b1f31729f10174367599cf32209d59219dfc3" translate="yes" xml:space="preserve">
          <source>To update several rows at once:</source>
          <target state="translated">한 번에 여러 행을 업데이트하려면</target>
        </trans-unit>
        <trans-unit id="22b7aa8cde8674fa4a729793b1a6cd316bfb540d" translate="yes" xml:space="preserve">
          <source>To use a custom error message instead of that provided by &lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;validator.js&lt;/a&gt;, use an object instead of the plain value or array of arguments, for example a validator which needs no argument can be given a custom message with</source>
          <target state="translated">&lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;validator.js&lt;/a&gt; 가 제공하는 오류 메시지 대신 사용자 정의 오류 메시지를 사용하려면 일반 값 또는 인수 배열 대신 객체를 사용하십시오 (예 : 인수가 필요없는 유효성 검사기)</target>
        </trans-unit>
        <trans-unit id="75c5403dcfb5bf72f31f2a3c2d7f2fe263d46ed4" translate="yes" xml:space="preserve">
          <source>To use the wildcard operator %, append it to your replacement. The following query matches users with names that start with 'ben'.</source>
          <target state="translated">와일드 카드 연산자 %를 사용하려면이를 대체 문자에 추가하십시오. 다음 쿼리는 이름이 'ben'으로 시작하는 사용자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="c38c6c1f3a2743f8626703abb302e403d20ff81c" translate="yes" xml:space="preserve">
          <source>Tokens</source>
          <target state="translated">Tokens</target>
        </trans-unit>
        <trans-unit id="603270749de0b8c5d657407d142a68e2bd894051" translate="yes" xml:space="preserve">
          <source>Top level where with eagerly loaded models</source>
          <target state="translated">열심히로드 된 모델의 최상위</target>
        </trans-unit>
        <trans-unit id="1a7b7c1b33d161f45804730c70b75175dccd9883" translate="yes" xml:space="preserve">
          <source>Transaction</source>
          <target state="translated">Transaction</target>
        </trans-unit>
        <trans-unit id="4560532617032eba3499944208e1c914b037e0c9" translate="yes" xml:space="preserve">
          <source>Transaction options</source>
          <target state="translated">거래 옵션</target>
        </trans-unit>
        <trans-unit id="9c5a9f64903010dca00f0ffdf25ae4dd43e00a52" translate="yes" xml:space="preserve">
          <source>Transaction to run query under</source>
          <target state="translated">아래에서 쿼리를 실행할 트랜잭션</target>
        </trans-unit>
        <trans-unit id="1e3281a962e6db2e54e787f796eb7d2b1582389a" translate="yes" xml:space="preserve">
          <source>Transactions</source>
          <target state="translated">Transactions</target>
        </trans-unit>
        <trans-unit id="af4419640cc9b72a684777bff88307c334556deb" translate="yes" xml:space="preserve">
          <source>Trigger the constraint checks immediately</source>
          <target state="translated">구속 조건 검사를 즉시 트리거</target>
        </trans-unit>
        <trans-unit id="fbfa67ef4fc863ae5513f819aa79809b0312945b" translate="yes" xml:space="preserve">
          <source>Truncate all instances of the model.</source>
          <target state="translated">모델의 모든 인스턴스를 자릅니다.</target>
        </trans-unit>
        <trans-unit id="41ba9fe559f96b6c33ced14f4f229126b6f945ea" translate="yes" xml:space="preserve">
          <source>Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }).</source>
          <target state="translated">모델의 모든 인스턴스를 자릅니다. 이것은 Model.destroy ({truncate : true})에 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="db65c7ad58c51cfb9b81db0635cd9fbad284458d" translate="yes" xml:space="preserve">
          <source>Truncate all tables defined through the sequelize models.</source>
          <target state="translated">순서 모델을 통해 정의 된 모든 테이블을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="bebb9195a206168efd2a5b7fe2975178574e742a" translate="yes" xml:space="preserve">
          <source>Truncate all tables defined through the sequelize models. This is done by calling &lt;code&gt;Model.truncate()&lt;/code&gt; on each model.</source>
          <target state="translated">순서 모델을 통해 정의 된 모든 테이블을 자릅니다. 각 모델에서 &lt;code&gt;Model.truncate()&lt;/code&gt; 를 호출 하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="548046a99a144543148a41922751851ef4f108e1" translate="yes" xml:space="preserve">
          <source>Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.</source>
          <target state="translated">명명 된 테이블 또는 CASCADE로 인해 그룹에 추가 된 테이블에 대한 외래 키 참조가있는 모든 테이블을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="2b125b0e14258280c33525f42d8874d816aafa25" translate="yes" xml:space="preserve">
          <source>Type of constraint. One of the values in available constraints(case insensitive)</source>
          <target state="translated">구속 조건의 유형. 사용 가능한 제약 조건 중 하나 (대소 문자 구분)</target>
        </trans-unit>
        <trans-unit id="02466358e536c7941ae60bb0d80b0e5f61e9ca27" translate="yes" xml:space="preserve">
          <source>Type of geography data</source>
          <target state="translated">지리 데이터의 유형</target>
        </trans-unit>
        <trans-unit id="80639b7816c71c1eb7b8fd0ef7324c7ca20ec91d" translate="yes" xml:space="preserve">
          <source>Type of geometry data</source>
          <target state="translated">지오메트리 데이터의 유형</target>
        </trans-unit>
        <trans-unit id="657bf8cc823055c20626d868fa847d4cfc53f2f0" translate="yes" xml:space="preserve">
          <source>Type of index, available options are UNIQUE|FULLTEXT|SPATIAL</source>
          <target state="translated">인덱스 유형, 사용 가능한 옵션은 UNIQUE | FULLTEXT | SPATIAL입니다.</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="37dd88d1763196449c23edd76686c9e9f0cfc42d" translate="yes" xml:space="preserve">
          <source>TypeScript doesn't know how to generate a &lt;code&gt;class&lt;/code&gt; definition when we use the &lt;code&gt;sequelize.define&lt;/code&gt; method to define a Model. Therefore, we need to do some manual work and declare an interface and a type, and eventually cast the result of &lt;code&gt;.define&lt;/code&gt; to the &lt;em&gt;static&lt;/em&gt; type.</source>
          <target state="translated">TypeScript는 &lt;code&gt;sequelize.define&lt;/code&gt; 메서드를 사용하여 모델을 정의 할 때 &lt;code&gt;class&lt;/code&gt; 정의 를 생성하는 방법을 모릅니다 . 따라서, 우리는 몇 가지 수동 작업을 수행하고, 인터페이스 및 유형을 선언 할 필요가, 결국의 결과를 캐스팅 &lt;code&gt;.define&lt;/code&gt; 받는 &lt;em&gt;정적의&lt;/em&gt; 유형입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e49081c4bde9e1cfe58939ea3a16f1c972606e9a" translate="yes" xml:space="preserve">
          <source>Types can be set per-transaction by passing &lt;code&gt;options.type&lt;/code&gt; to &lt;code&gt;sequelize.transaction&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options.type&lt;/code&gt; 을 &lt;code&gt;sequelize.transaction&lt;/code&gt; 로 전달 하여 트랜잭션별로 유형을 설정할 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
