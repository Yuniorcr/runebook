<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="a32e1b58a6927fc4bde376b513f387688a487fb0" translate="yes" xml:space="preserve">
          <source>3,4) Returns a range containing all elements in the container with key equivalent to &lt;code&gt;x&lt;/code&gt;. This overload only participates in overload resolution if the qualified-id &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; is valid and denotes a type. This assumes that such Hash is callable with both K and Key type, and that its key_equal is transparent, which, together, allows calling this function without constructing an instance of &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">3,4) &lt;code&gt;x&lt;/code&gt; 에 해당하는 키를 가진 컨테이너의 모든 요소를 ​​포함하는 범위를 반환합니다 . 규정 된 ID &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; 이 유효하고 유형을 나타내는 경우이 과부하는 과부하 해결에만 참여 합니다. 이것은 그러한 해시가 K와 Key 타입으로 호출 가능하고 key_equal이 투명하고 &lt;code&gt;Key&lt;/code&gt; 인스턴스를 구성하지 않고이 함수를 호출 할 수 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="ddb4f0bc6dcb6b70bf535b432a100ad5d9adf555" translate="yes" xml:space="preserve">
          <source>3,4) Same as (1,2), except called if the alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;</source>
          <target state="translated">3,4) 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 경우 호출되는 것을 제외하고 (1,2)와 동일</target>
        </trans-unit>
        <trans-unit id="38bb83557d6479ad102b3fb626b55ee9dfee1949" translate="yes" xml:space="preserve">
          <source>3,4) Same as for &lt;a href=&quot;emplace_hint&quot;&gt;emplace_hint&lt;/a&gt;</source>
          <target state="translated">3,4) &lt;a href=&quot;emplace_hint&quot;&gt;emplace_hint&lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="150759430fdecd7019b5508228ee074d08072287" translate="yes" xml:space="preserve">
          <source>3,4) The first operand must be an expression of scalar type (see below)</source>
          <target state="translated">3,4) 첫 번째 피연산자는 스칼라 유형의 표현식이어야합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="e7cce351a17710ec655abf56217936e72a1709c7" translate="yes" xml:space="preserve">
          <source>3,5) O(N) comparisons, where N is &lt;code&gt;cont.size()&lt;/code&gt;.</source>
          <target state="translated">3,5) O (N) 비교, 여기서 N은 &lt;code&gt;cont.size()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dac53dbc13f509b01aa59207b847ff625c259d04" translate="yes" xml:space="preserve">
          <source>3,5)&lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; if the operating system has no locale named &lt;code&gt;std_name&lt;/code&gt; or if &lt;code&gt;std_name&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">3,5) &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; 운영 체제 로케일 이름이없는 경우 &lt;code&gt;std_name&lt;/code&gt; 을 경우 또는 &lt;code&gt;std_name&lt;/code&gt; 가 있다 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="b7ea1f6c8350778a0e654939a40d325bbaebbd66" translate="yes" xml:space="preserve">
          <source>3,5,7,9) A &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; object containing copies of the selected items</source>
          <target state="translated">3,5,7,9) 선택된 항목의 사본을 포함 하는 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="4eea58c77011cc55ef9133525ea3f97446e05af3" translate="yes" xml:space="preserve">
          <source>3,6) Construction of arrays of known bound is disallowed.</source>
          <target state="translated">3,6) 알려진 경계의 어레이 구성은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2f47332dd6741edae4fc4ee664b89783bbae2ed" translate="yes" xml:space="preserve">
          <source>3,6) O(last - first) applications each of &lt;code&gt;unary_op&lt;/code&gt; and &lt;code&gt;binary_op&lt;/code&gt;.</source>
          <target state="translated">3,6) &lt;code&gt;unary_op&lt;/code&gt; 및 &lt;code&gt;binary_op&lt;/code&gt; 각각의 O (last-first) 응용 프로그램 .</target>
        </trans-unit>
        <trans-unit id="61e9fbb24ea432febda92fb79a215c99c3bce145" translate="yes" xml:space="preserve">
          <source>3,6) rvalue reference wrapper is deleted.</source>
          <target state="translated">3,6) rvalue 참조 래퍼가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="763c9c75fa75b5feee45cb9b104200c26581a133" translate="yes" xml:space="preserve">
          <source>3,6)&lt;code&gt;&lt;a href=&quot;month_day&quot;&gt;std::chrono::month_day&lt;/a&gt;(m, d)&lt;/code&gt;</source>
          <target state="translated">3,6) &lt;code&gt;&lt;a href=&quot;month_day&quot;&gt;std::chrono::month_day&lt;/a&gt;(m, d)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6de319b0a3fdd17a4a4679fabde29bb9a3ccace0" translate="yes" xml:space="preserve">
          <source>3,7) Elements are compared using the given binary predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">3,7) 주어진 2 진 술어 &lt;code&gt;p&lt;/code&gt; 를 사용하여 요소를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="614b1e9a26bfe645ff4259f07309d0b015a28d1c" translate="yes" xml:space="preserve">
          <source>3,7) Multiplies &lt;code&gt;*this&lt;/code&gt; by &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">3,7) &lt;code&gt;*this&lt;/code&gt; 에 &lt;code&gt;other&lt;/code&gt; 를 곱 합니다.</target>
        </trans-unit>
        <trans-unit id="e3ca17af48add66d28f234144b6336cb0a2ed79a" translate="yes" xml:space="preserve">
          <source>3,7) when a non-static data member or a base class is initialized using a &lt;a href=&quot;constructor&quot;&gt;member initializer&lt;/a&gt; with an empty pair of parentheses or braces(since C++11);</source>
          <target state="translated">3,7) 빈 괄호 또는 중괄호가 있는 &lt;a href=&quot;constructor&quot;&gt;멤버 이니셜&lt;/a&gt; 라이저를 사용하여 비 정적 데이터 멤버 또는 기본 클래스를 초기화하는 경우 (C ++ 11부터);</target>
        </trans-unit>
        <trans-unit id="39849cde9da6cef1ad1d41af51629230e8e2d256" translate="yes" xml:space="preserve">
          <source>3,8,9) Does not throw if &lt;code&gt;other&lt;/code&gt;'s</source>
          <target state="translated">3,8,9) 경우가 발생하지 않는 &lt;code&gt;other&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="5f1336e00c3753ce2bf5b774199a7e466f179e8b" translate="yes" xml:space="preserve">
          <source>3-4) (none)</source>
          <target state="translated">3-4) (없음)</target>
        </trans-unit>
        <trans-unit id="820f4f52647d6cc529f84397b31dfb1490a5df47" translate="yes" xml:space="preserve">
          <source>3-4) A &lt;code&gt;year_month&lt;/code&gt; value &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;z - ym == dm&lt;/code&gt; and &lt;code&gt;z.ok() == true&lt;/code&gt;.</source>
          <target state="translated">3-4)는의 &lt;code&gt;year_month&lt;/code&gt; 의 값 &lt;code&gt;z&lt;/code&gt; 되도록 &lt;code&gt;z - ym == dm&lt;/code&gt; 과 &lt;code&gt;z.ok() == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e831e49f0126d28b490b0afad069ef63c0180127" translate="yes" xml:space="preserve">
          <source>3-4) A normal path of the form &lt;code&gt;canonical(x)/y&lt;/code&gt;, where x is a path composed of the longest leading sequence of elements in p that exist, and y is a path composed of the remaining trailing non-existent elements of p</source>
          <target state="translated">3-4) &lt;code&gt;canonical(x)/y&lt;/code&gt; 형식의 일반 경로 . 여기서 x는 존재하는 p에서 가장 긴 선행 요소 시퀀스로 구성된 경로이고, y는 나머지 후행 존재하지 않는 요소로 구성된 경로입니다. 피</target>
        </trans-unit>
        <trans-unit id="ae9e1a56a1bb823d97e30295bd40a51021deacf7" translate="yes" xml:space="preserve">
          <source>3-4) A pair with the smallest value in &lt;code&gt;ilist&lt;/code&gt; as the first element and the greatest as the second. If several elements are equivalent to the smallest, the leftmost such element is returned. If several elements are equivalent to the largest, the rightmost such element is returned.</source>
          <target state="translated">3-4) 첫 번째 요소로 &lt;code&gt;ilist&lt;/code&gt; 에서 가장 작은 값 과 두 번째 요소로 가장 큰 값을 가진 쌍입니다 . 여러 요소가 가장 작은 요소와 같은 경우 가장 왼쪽에있는 해당 요소가 반환됩니다. 여러 요소가 가장 큰 요소와 같은 경우 가장 오른쪽에있는 해당 요소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="98fe3f83353c779b420baa7b766da42150d0951c" translate="yes" xml:space="preserve">
          <source>3-4) Adds &lt;code&gt;dm.count()&lt;/code&gt; months to &lt;code&gt;ym&lt;/code&gt;.</source>
          <target state="translated">3-4) &lt;code&gt;dm.count()&lt;/code&gt; 개월을 &lt;code&gt;ym&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="ff58ff769268133326f91b795d9367e3eda95355" translate="yes" xml:space="preserve">
          <source>3-4) Adds &lt;code&gt;dy.count()&lt;/code&gt; years to the date represented by &lt;code&gt;ymd&lt;/code&gt;. The result is equivalent to &lt;code&gt;&lt;a href=&quot;../year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(ymd.year() + dy, ymd.month(), ymd.day()&lt;/code&gt;.</source>
          <target state="translated">3-4) &lt;code&gt;ymd&lt;/code&gt; 로 표시된 날짜에 &lt;code&gt;dy.count()&lt;/code&gt; 년을 추가합니다 . 결과는 &lt;code&gt;&lt;a href=&quot;../year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(ymd.year() + dy, ymd.month(), ymd.day()&lt;/code&gt; (ymd.year () + dy, ymd.month (), ymd.day ()와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d028cd1c6183a808e32ecef916d34512a4344188" translate="yes" xml:space="preserve">
          <source>3-4) Adds &lt;code&gt;dy.count()&lt;/code&gt; years to the date represented by &lt;code&gt;ymdl&lt;/code&gt;. The result is equivalent to &lt;code&gt;&lt;a href=&quot;../year_month_day_last&quot;&gt;std::chrono::year_month_day_last&lt;/a&gt;(ymdl.year() + dy, ymdl.month_day_last())&lt;/code&gt;.</source>
          <target state="translated">3-4)를 추가의 &lt;code&gt;dy.count()&lt;/code&gt; 날짜 년은으로 표시 &lt;code&gt;ymdl&lt;/code&gt; . 결과는 &lt;code&gt;&lt;a href=&quot;../year_month_day_last&quot;&gt;std::chrono::year_month_day_last&lt;/a&gt;(ymdl.year() + dy, ymdl.month_day_last())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96ee7f9bfdf60dcddd4127e922993313e740dda8" translate="yes" xml:space="preserve">
          <source>3-4) Adds &lt;code&gt;dy.count()&lt;/code&gt; years to the date represented by &lt;code&gt;ymwd&lt;/code&gt;. The result is equivalent to &lt;code&gt;&lt;a href=&quot;../year_month_weekday&quot;&gt;std::chrono::year_month_weekday&lt;/a&gt;(ymwd.year() + dy, ymwd.month(), ymwd.weekday_indexed())&lt;/code&gt;.</source>
          <target state="translated">3-4)를 추가의 &lt;code&gt;dy.count()&lt;/code&gt; 날짜 년은으로 표시 &lt;code&gt;ymwd&lt;/code&gt; . 결과는 &lt;code&gt;&lt;a href=&quot;../year_month_weekday&quot;&gt;std::chrono::year_month_weekday&lt;/a&gt;(ymwd.year() + dy, ymwd.month(), ymwd.weekday_indexed())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bb653bdbd13d056a82a2ee30bb46b21a3b28850" translate="yes" xml:space="preserve">
          <source>3-4) Adds &lt;code&gt;dy.count()&lt;/code&gt; years to the date represented by &lt;code&gt;ymwdl&lt;/code&gt;. The result is equivalent to &lt;code&gt;&lt;a href=&quot;../year_month_weekday_last&quot;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;(ymwdl.year() + dy, ymwdl.month(), ymwd.weekday_last())&lt;/code&gt;.</source>
          <target state="translated">3-4)를 추가의 &lt;code&gt;dy.count()&lt;/code&gt; 날짜 년은으로 표시 &lt;code&gt;ymwdl&lt;/code&gt; . 결과는 &lt;code&gt;&lt;a href=&quot;../year_month_weekday_last&quot;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;(ymwdl.year() + dy, ymwdl.month(), ymwd.weekday_last())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24d9c16b5ed7318e44232de93a2e8a092709936b" translate="yes" xml:space="preserve">
          <source>3-4) Amortized constant if the insertion happens in the position just</source>
          <target state="translated">3-4) 삽입이 바로 그 위치에서 발생하면 상각 상수</target>
        </trans-unit>
        <trans-unit id="db01e9559fb4cc39a31afeec998ab02d5cbbfa45" translate="yes" xml:space="preserve">
          <source>3-4) At most &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - n&lt;/code&gt; assignment or swaps.</source>
          <target state="translated">3-4) 최대 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - n&lt;/code&gt; 할당 또는 스왑.</target>
        </trans-unit>
        <trans-unit id="31e0f38666a2c752c34270d644856d979af1d7c5" translate="yes" xml:space="preserve">
          <source>3-4) At most &lt;code&gt;ilist.size() * 3 / 2&lt;/code&gt; comparisons</source>
          <target state="translated">3-4) 최대 &lt;code&gt;ilist.size() * 3 / 2&lt;/code&gt; 비교</target>
        </trans-unit>
        <trans-unit id="b2cfeb281080921f93a78fe531ca893cc3cbd379" translate="yes" xml:space="preserve">
          <source>3-4) Changes the current working directory to &lt;code&gt;p&lt;/code&gt;, as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/chdir.html&quot;&gt;chdir&lt;/a&gt;.</source>
          <target state="translated">3-4) POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/chdir.html&quot;&gt;chdir에&lt;/a&gt; 의한 것처럼 현재 작업 디렉토리를 &lt;code&gt;p&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="8848d7063bb91a554480a7a33c92e8dac01c14f8" translate="yes" xml:space="preserve">
          <source>3-4) Constructs a &lt;code&gt;std::unique_ptr&lt;/code&gt; object which owns &lt;code&gt;p&lt;/code&gt;, initializing the stored pointer with &lt;code&gt;p&lt;/code&gt; and initializing a deleter &lt;code&gt;D&lt;/code&gt; as below (depends upon whether &lt;code&gt;D&lt;/code&gt; is a reference type)</source>
          <target state="translated">3-4) &lt;code&gt;p&lt;/code&gt; 를 소유 한 &lt;code&gt;std::unique_ptr&lt;/code&gt; 객체를 구성 하여 &lt;code&gt;p&lt;/code&gt; 로 저장된 포인터를 초기화하고 아래와 같이 삭제 자 &lt;code&gt;D&lt;/code&gt; 를 초기화 합니다 ( &lt;code&gt;D&lt;/code&gt; 가 참조 유형 인지에 따라 다름 )</target>
        </trans-unit>
        <trans-unit id="4e0e034a11a816cfed860af109a6d4b353a8eb68" translate="yes" xml:space="preserve">
          <source>3-4) Constructs a copy of the system locale with specified &lt;code&gt;std_name&lt;/code&gt; (such as &quot;C&quot;, or &quot;POSIX&quot;, or &quot;en_US.UTF-8&quot;, or &quot;English_US.1251&quot;), if such locale is supported by the operating system. The locale constructed in this manner has a name.</source>
          <target state="translated">3-4) 지정된 로케일이 해당 &lt;code&gt;std_name&lt;/code&gt; (예 : &quot;C&quot;또는 &quot;POSIX&quot;또는 &quot;en_US.UTF-8&quot;또는 &quot;English_US.1251&quot;)으로 시스템 로케일의 사본을 구성합니다 . 운영 체제. 이러한 방식으로 구성된 로캘에는 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa2401d3ed7fbb88abdb78d81b277284065ca33a" translate="yes" xml:space="preserve">
          <source>3-4) Constructs an empty string &lt;code&gt;result&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT, ST, SA&amp;gt;&lt;/code&gt; and calls &lt;code&gt;std::regex_replace(&lt;a href=&quot;../iterator/back_inserter&quot;&gt;std::back_inserter&lt;/a&gt;(result), s.begin(), s.end(), re, fmt, flags)&lt;/code&gt;.</source>
          <target state="translated">3-4) &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT, ST, SA&amp;gt;&lt;/code&gt; &amp;lt;CharT, ST, SA&amp;gt; 유형 의 빈 문자열 &lt;code&gt;result&lt;/code&gt; 를 구성 하고 &lt;code&gt;std::regex_replace(&lt;a href=&quot;../iterator/back_inserter&quot;&gt;std::back_inserter&lt;/a&gt;(result), s.begin(), s.end(), re, fmt, flags)&lt;/code&gt; &lt;a href=&quot;../iterator/back_inserter&quot;&gt;std :: back_inserter&lt;/a&gt; (result), s.begin (), s.end (), re를 호출합니다. , fmt, flags) .</target>
        </trans-unit>
        <trans-unit id="d64f5c690da2d01136106211af57bcfab3680b4a" translate="yes" xml:space="preserve">
          <source>3-4) Converts the duration &lt;code&gt;d&lt;/code&gt; to one whose &lt;code&gt;rep&lt;/code&gt; is the common type between &lt;code&gt;Rep1&lt;/code&gt; and &lt;code&gt;Rep2&lt;/code&gt;, and multiples the number of ticks after conversion by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">3-4) 지속 시간 &lt;code&gt;d&lt;/code&gt; 를 &lt;code&gt;Rep1&lt;/code&gt; 과 &lt;code&gt;Rep2&lt;/code&gt; 사이의 공통 유형 인 &lt;code&gt;rep&lt;/code&gt; 로 변환하고 &lt;code&gt;s&lt;/code&gt; 로 변환 한 후 틱 수를 곱합니다 .</target>
        </trans-unit>
        <trans-unit id="5c9f9d4e2eeffadbbabcae5e1ac196ff1f75c6fe" translate="yes" xml:space="preserve">
          <source>3-4) Copies (3) or moves (4) the</source>
          <target state="translated">3-4) 복사 (3) 또는 이동 (4)</target>
        </trans-unit>
        <trans-unit id="16b91f16831c79383c67c836c0245c51e50cff03" translate="yes" xml:space="preserve">
          <source>3-4) Effectively calls (1-2) as if by &lt;code&gt;open(filename.c_str(), mode)&lt;/code&gt;.</source>
          <target state="translated">3-4) &lt;code&gt;open(filename.c_str(), mode)&lt;/code&gt; 의한 것처럼 (1-2)를 효과적으로 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="60074a4d340ce951df385e7710772c1c94381c2d" translate="yes" xml:space="preserve">
          <source>3-4) Exactly &lt;code&gt;(last - first)&lt;/code&gt; applications of the predicate, between &lt;code&gt;​0​&lt;/code&gt; and &lt;code&gt;(last - first)&lt;/code&gt; assignments (assignment for every element for which predicate is equal to true, dependent on predicate and input data)</source>
          <target state="translated">3-4) 정확히 &lt;code&gt;(last - first)&lt;/code&gt; 의 술어 애플리케이션, &lt;code&gt;​0​&lt;/code&gt; 과 &lt;code&gt;(last - first)&lt;/code&gt; 술어, 술어 및 입력 데이터)에 의존하는 사실과 동일하다있는 요소마다 배정 (할당</target>
        </trans-unit>
        <trans-unit id="dd1c9bf54eb6bf0fb14690dbca5292e22b74eda6" translate="yes" xml:space="preserve">
          <source>3-4) Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; applications of &lt;code&gt;binary_op&lt;/code&gt;</source>
          <target state="translated">3-4) &lt;code&gt;binary_op&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; &lt;a href=&quot;../iterator/distance&quot;&gt;std :: distance&lt;/a&gt; (first1, last1) 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="e7884049cf4d64a8b5670cff89b81eb034484a9c" translate="yes" xml:space="preserve">
          <source>3-4) Exactly &lt;code&gt;ilist.size() - 1&lt;/code&gt; comparisons</source>
          <target state="translated">3-4) 정확히 &lt;code&gt;ilist.size() - 1&lt;/code&gt; 비교</target>
        </trans-unit>
        <trans-unit id="6985fe1111174484edb4ef9bc2a3276c369a4830" translate="yes" xml:space="preserve">
          <source>3-4) Inserts &lt;code&gt;value&lt;/code&gt;, using &lt;code&gt;hint&lt;/code&gt; as a non-binding suggestion to where the search should start.</source>
          <target state="translated">3-4) 검색을 시작할 위치에 &lt;code&gt;hint&lt;/code&gt; 를 구속력없는 제안으로 사용하여 &lt;code&gt;value&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="a3203e361f590b10d4af0c979f34e99171140129" translate="yes" xml:space="preserve">
          <source>3-4) Inserts &lt;code&gt;value&lt;/code&gt;, using &lt;code&gt;hint&lt;/code&gt; as a non-binding suggestion to where the search should start. The overload (4) is equivalent to &lt;code&gt;emplace_hint(hint, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; and only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">3-4) 검색을 시작할 위치에 &lt;code&gt;hint&lt;/code&gt; 를 구속력이없는 제안으로 사용하여 &lt;code&gt;value&lt;/code&gt; 를 삽입합니다 . 과부하 (4)는 &lt;code&gt;emplace_hint(hint, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;P&amp;gt; (value)) 와 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt; &amp;lt;value_type, P &amp;amp;&amp;amp;&amp;gt; :: value == true 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="c0e5c9cb3c3cf52b92e5960e26d01f97cdcf2f0d" translate="yes" xml:space="preserve">
          <source>3-4) Partial specializations &lt;code&gt;std::atomic&amp;lt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;std::atomic&amp;lt;&lt;a href=&quot;../memory/weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../memory/weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">3-4) 부분 전문화 &lt;code&gt;std::atomic&amp;lt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;std::atomic&amp;lt;&lt;a href=&quot;../memory/weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../memory/weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="6ba2eb6a723690c12df54b8f0359e1f42c5a11db" translate="yes" xml:space="preserve">
          <source>3-4) Performs &lt;code&gt;*this -= &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;{1};&lt;/code&gt;</source>
          <target state="translated">3-4) &lt;code&gt;*this -= &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;{1};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4df067815c6e70959bf963e7101747cc30ef5a83" translate="yes" xml:space="preserve">
          <source>3-4) Performs &lt;code&gt;*this -= &lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;{1};&lt;/code&gt;</source>
          <target state="translated">3-4) &lt;code&gt;*this -= &lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;{1};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="299cd6ad3e5484fc3203e4cb7d3ef44862c483cf" translate="yes" xml:space="preserve">
          <source>3-4) Performs &lt;code&gt;*this -= &lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;{1};&lt;/code&gt;</source>
          <target state="translated">3-4) &lt;code&gt;*this -= &lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;{1};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0083849b9d67fba9c6ba9bc426062ec475bfc977" translate="yes" xml:space="preserve">
          <source>3-4) Performs binary shift right. The (4) version is destructive, i.e. performs the shift to the current object.</source>
          <target state="translated">3-4) 이진 시프트 오른쪽을 수행합니다. (4) 버전은 파괴적입니다. 즉, 현재 객체로의 이동을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d13169d226907e88906ffe351f93e62156035ffc" translate="yes" xml:space="preserve">
          <source>3-4) Post-increments or post-decrements by one respectively.</source>
          <target state="translated">3-4) 사후 증가 또는 사후 감소.</target>
        </trans-unit>
        <trans-unit id="3ce8931331c3cf4f72f0fe814e3a0924415b66e4" translate="yes" xml:space="preserve">
          <source>3-4) Reads characters from the input iterator &lt;code&gt;beg&lt;/code&gt;, expecting to find a monetary value formatted according to the rules specified by the &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet imbued in &lt;code&gt;str.getloc()&lt;/code&gt; (&lt;code&gt;ct&lt;/code&gt; for the rest of this page), the &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; facet imbued in &lt;code&gt;str.getloc()&lt;/code&gt; (&lt;code&gt;mp&lt;/code&gt; for the rest of this page), and the stream formatting flags obtained from &lt;code&gt;str.flags()&lt;/code&gt;.</source>
          <target state="translated">3-4) 입력 반복자의 문자 읽 &lt;code&gt;beg&lt;/code&gt; 포맷에 의해 지정된 규칙에 따라 금전적 가치를 찾을 것으로 예상, &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 면 마력 깃든에서 &lt;code&gt;str.getloc()&lt;/code&gt; ( &lt;code&gt;ct&lt;/code&gt; 이 페이지의 나머지)의 &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; 패싯은 &lt;code&gt;str.getloc()&lt;/code&gt; ( 이 페이지의 나머지 부분에서는 &lt;code&gt;mp&lt;/code&gt; )에 포함되어 있으며 &lt;code&gt;str.flags()&lt;/code&gt; 에서 얻은 스트림 형식 플래그 입니다.</target>
        </trans-unit>
        <trans-unit id="b9d6e86faf16d44321a203f19d8dba3e6757fbd4" translate="yes" xml:space="preserve">
          <source>3-4) Returns &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">3-4) &lt;code&gt;N&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b7e4f00e727b090afe880ef903f3b88ece9a6947" translate="yes" xml:space="preserve">
          <source>3-4) Returns a path composed by &lt;code&gt;operator/=&lt;/code&gt; from the result of calling &lt;code&gt;canonical()&lt;/code&gt; with a path argument composed of the leading elements of &lt;code&gt;p&lt;/code&gt; that exist (as determined by &lt;code&gt;status(p)&lt;/code&gt; or &lt;code&gt;status(p, ec)&lt;/code&gt;), if any, followed by the elements of &lt;code&gt;p&lt;/code&gt; that do not exist, if any. The resulting path is in &lt;a href=&quot;path&quot;&gt;normal form&lt;/a&gt;.</source>
          <target state="translated">3-4) 존재 하는 &lt;code&gt;p&lt;/code&gt; 의 선행 요소 &lt;code&gt;status(p)&lt;/code&gt; 또는 &lt;code&gt;status(p, ec)&lt;/code&gt; 의해 결정됨) 로 구성된 경로 인수와 함께 &lt;code&gt;canonical()&lt;/code&gt; 을 호출 한 결과로부터 &lt;code&gt;operator/=&lt;/code&gt; 로 구성된 경로를 리턴합니다 . 존재하는 경우 존재하지 않는 &lt;code&gt;p&lt;/code&gt; 의 요소가 뒤에옵니다 . 결과 경로는 &lt;a href=&quot;path&quot;&gt;정상적인 형태&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c21af29e5a7e79bd2cca1483d97280f77dca6f6" translate="yes" xml:space="preserve">
          <source>3-4) Returns an iterator to the inserted element, or to the element that prevented the insertion.</source>
          <target state="translated">3-4) 반복자를 삽입 된 요소 또는 삽입을 방해 한 요소로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98da2f424cce2266e837a228687e626ef644981f" translate="yes" xml:space="preserve">
          <source>3-4) Returns the greatest of the values in initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">3-4) 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 가장 큰 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8508393ecd3cc7bae4f1301debaddae0e8649369" translate="yes" xml:space="preserve">
          <source>3-4) Returns the smallest and the greatest of the values in initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">3-4) 이니셜 라이저 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 가장 작은 값과 가장 큰 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6b540e1a1aad91083218702044ed8da31ae5baa0" translate="yes" xml:space="preserve">
          <source>3-4) Returns the smallest of the values in initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">3-4) 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 가장 작은 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="968a24bdb5de90d98c91760e6f80d468b0f62e8e" translate="yes" xml:space="preserve">
          <source>3-4) Sets the</source>
          <target state="translated">3-4) 설정</target>
        </trans-unit>
        <trans-unit id="296f1bdfda20e6e41e9d9cfa9ab233bd78250537" translate="yes" xml:space="preserve">
          <source>3-4) The beginning of the resulting range. If &lt;code&gt;n&lt;/code&gt; is positive and less than &lt;code&gt;last - first&lt;/code&gt;, returns &lt;code&gt;first + n&lt;/code&gt;. Otherwise if &lt;code&gt;n&lt;/code&gt; is positive, returns &lt;code&gt;last&lt;/code&gt;. Otherwise, returns &lt;code&gt;first&lt;/code&gt;.</source>
          <target state="translated">3-4) 결과 범위의 시작. 경우 &lt;code&gt;n&lt;/code&gt; 긍정적 인 미만입니다 &lt;code&gt;last - first&lt;/code&gt; , 반환 &lt;code&gt;first + n&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;n&lt;/code&gt; 이 양수이면 &lt;code&gt;last&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 &lt;code&gt;first&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="09abc5d631c447f3a5a44f30c70749c192c4d056" translate="yes" xml:space="preserve">
          <source>3-4) The behavior is undefined unless &lt;code&gt;dynamic_cast&amp;lt;T*&amp;gt;((U*)nullptr)&lt;/code&gt; is well formed.</source>
          <target state="translated">3-4) &lt;code&gt;dynamic_cast&amp;lt;T*&amp;gt;((U*)nullptr)&lt;/code&gt; 가 제대로 형성 되지 않으면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2d2818c01d6f07fd2fb2919e07dd9b57f926ee05" translate="yes" xml:space="preserve">
          <source>3-4) The format character sequence is defined by the characters in &lt;code&gt;fmt&lt;/code&gt; and &lt;code&gt;fmt_s&lt;/code&gt; respectively. The resulting character sequence is copied to a newly constructed &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;, which is returned.</source>
          <target state="translated">3-4) 형식 문자 순서는 각각 &lt;code&gt;fmt&lt;/code&gt; 및 &lt;code&gt;fmt_s&lt;/code&gt; 의 문자로 정의됩니다 . 결과 문자 시퀀스가 ​​새로 생성 된 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 복사되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d59573892ccfad694c725a3c52480924ab3d9ba5" translate="yes" xml:space="preserve">
          <source>3-4) The greatest value in &lt;code&gt;ilist&lt;/code&gt;. If several values are equivalent to the greatest, returns the leftmost one.</source>
          <target state="translated">3-4) &lt;code&gt;ilist&lt;/code&gt; 에서 가장 큰 가치 . 여러 값이 가장 큰 값과 같은 경우 가장 왼쪽에있는 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f81a6130180b84d74789aa1cef7bee42bc9da88" translate="yes" xml:space="preserve">
          <source>3-4) The newly constructed string containing resulting character sequence.</source>
          <target state="translated">3-4) 결과 문자 시퀀스를 포함하는 새로 구성된 문자열.</target>
        </trans-unit>
        <trans-unit id="9eb2384ce3691f5d7883c1c6dd3de130bc36e556" translate="yes" xml:space="preserve">
          <source>3-4) The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">3-4) &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 오버로드는 기본 OS API 오류에서 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. &lt;code&gt;p&lt;/code&gt; 는 첫 번째 경로 인수로, OS 오류 코드는 오류 코드 인수로 구성됩니다. &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79248b0b7313a9802d03a62773dbec0846012a09" translate="yes" xml:space="preserve">
          <source>3-4) The smallest value in &lt;code&gt;ilist&lt;/code&gt;. If several values are equivalent to the smallest, returns the leftmost such value.</source>
          <target state="translated">3-4) &lt;code&gt;ilist&lt;/code&gt; 에서 가장 작은 값 . 여러 값이 가장 작은 값과 같은 경우 가장 왼쪽 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2617b5451fd5e622dd950aa177eebb36f40d12ce" translate="yes" xml:space="preserve">
          <source>3-4) These overloads only participate in overload resolution if &lt;code&gt;to_stream(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;&lt;a href=&quot;../io/basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&amp;lt;CharT, Traits, Alloc&amp;gt;&amp;amp;&amp;gt;(), fmt.c_str(), s)&lt;/code&gt; is a valid expression.</source>
          <target state="translated">3-4) &lt;code&gt;to_stream(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;&lt;a href=&quot;../io/basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&amp;lt;CharT, Traits, Alloc&amp;gt;&amp;amp;&amp;gt;(), fmt.c_str(), s)&lt;/code&gt; 이 유효한 표현식 인 경우 이러한 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="bebf786406cdce44266e4a5c7bf47a944efb0d36" translate="yes" xml:space="preserve">
          <source>3-4) Transfers the shared state held by &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. After the construction, &lt;code&gt;other.valid() == false&lt;/code&gt;, and &lt;code&gt;this-&amp;gt;valid()&lt;/code&gt; returns the same value as &lt;code&gt;other.valid()&lt;/code&gt; would have returned before the construction.</source>
          <target state="translated">3-4) &lt;code&gt;other&lt;/code&gt; 가 보유한 공유 상태 를 &lt;code&gt;*this&lt;/code&gt; 로 전송합니다 . 생성 후 &lt;code&gt;other.valid() == false&lt;/code&gt; 이고 &lt;code&gt;this-&amp;gt;valid()&lt;/code&gt; 는 &lt;code&gt;other.valid()&lt;/code&gt; 가 생성 전에 반환 한 것과 동일한 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cd9a88a03b9dfdf48f1549c6bbcff052bfb6ddf2" translate="yes" xml:space="preserve">
          <source>3-4) a copy of &lt;code&gt;*this&lt;/code&gt; that was made before the change</source>
          <target state="translated">3-4) 변경 전에 작성된 &lt;code&gt;*this&lt;/code&gt; 사본</target>
        </trans-unit>
        <trans-unit id="3a5a416d663a38d9e1e157083333aadc86487f5f" translate="yes" xml:space="preserve">
          <source>3-4) inserts &lt;code&gt;value&lt;/code&gt; in the position as close as possible, just prior(since C++11), to &lt;code&gt;hint&lt;/code&gt;.</source>
          <target state="translated">3-4) C ++ 11 이후로 가능한 한 가까운 위치에 &lt;code&gt;value&lt;/code&gt; 을 삽입 하여 &lt;code&gt;hint&lt;/code&gt; 줍니다.</target>
        </trans-unit>
        <trans-unit id="bfd9d68e543d431f65ee23db1c7a48b53ef810a7" translate="yes" xml:space="preserve">
          <source>3-4) inserts &lt;code&gt;value&lt;/code&gt; in the position as close as possible, just prior(since C++11), to &lt;code&gt;hint&lt;/code&gt;. The overload (4) is equivalent to &lt;code&gt;emplace_hint(hint, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; and only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">3-4) C ++ 11 이후로 가능한 한 가까운 위치에 &lt;code&gt;value&lt;/code&gt; 을 삽입 하여 &lt;code&gt;hint&lt;/code&gt; 줍니다. 과부하 (4)는 &lt;code&gt;emplace_hint(hint, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt; 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="78917531c581f24e324a3d8a8f6709d3cdc43ab4" translate="yes" xml:space="preserve">
          <source>3-4) inserts &lt;code&gt;value&lt;/code&gt;, using &lt;code&gt;hint&lt;/code&gt; as a non-binding suggestion to where the search should start. The overload (4) is equivalent to &lt;code&gt;emplace_hint(hint, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; and only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">3-4) 검색을 시작할 위치에 &lt;code&gt;hint&lt;/code&gt; 를 구속력이없는 제안으로 사용하여 &lt;code&gt;value&lt;/code&gt; 를 삽입 합니다 . 과부하 (4)는 &lt;code&gt;emplace_hint(hint, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;P&amp;gt; (value)) 와 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt; &amp;lt;value_type, P &amp;amp;&amp;amp;&amp;gt; :: value == true 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="20082c51bbf29d37f1479959e1e7136350ab0c7f" translate="yes" xml:space="preserve">
          <source>3-4)&lt;code&gt;(bool) f&lt;/code&gt;</source>
          <target state="translated">3-4) &lt;code&gt;(bool) f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc0c93619ac779bd52bea3f0cc4429c83254a6cf" translate="yes" xml:space="preserve">
          <source>3-4)&lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if required additional memory could not be obtained. May throw implementation-defined exception for other errors. &lt;code&gt;d(ptr)&lt;/code&gt; is called if an exception occurs.</source>
          <target state="translated">3-4) &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 필요한 경우 추가 메모리를 얻을 수 없습니다. 다른 오류에 대해서는 구현 정의 예외가 발생할 수 있습니다. 예외가 발생하면 &lt;code&gt;d(ptr)&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="be833089278cf34fedb9b2f6dcae633fa0eb7aeb" translate="yes" xml:space="preserve">
          <source>3-4)&lt;code&gt;CD(CD(d).count() * s)&lt;/code&gt;</source>
          <target state="translated">3-4) &lt;code&gt;CD(CD(d).count() * s)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f7253d022c0c0d2aec9c77312bdd89c0322278a" translate="yes" xml:space="preserve">
          <source>3-4)&lt;code&gt;dynamic_cast&amp;lt;Y*&amp;gt;(r.get())&lt;/code&gt; (If the result of the &lt;code&gt;dynamic_cast&lt;/code&gt; is a null pointer value, the returned &lt;code&gt;shared_ptr&lt;/code&gt; will be empty.)</source>
          <target state="translated">3-4) &lt;code&gt;dynamic_cast&amp;lt;Y*&amp;gt;(r.get())&lt;/code&gt; ( &lt;code&gt;dynamic_cast&lt;/code&gt; 의 결과 가 널 포인터 값이면 리턴 된 &lt;code&gt;shared_ptr&lt;/code&gt; 은 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="cd1541f9188e86387c384db8074c12f998b9f833" translate="yes" xml:space="preserve">
          <source>3-4)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(pred, &lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(proj, *i)) != false&lt;/code&gt; for at least one iterator &lt;code&gt;i&lt;/code&gt; in the range, &lt;code&gt;false&lt;/code&gt; otherwise. Returns &lt;code&gt;false&lt;/code&gt; if the range is empty.</source>
          <target state="translated">3-4) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;&lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(pred, &lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(proj, *i)) != false&lt;/code&gt; 반복자 적어도 하나 &lt;code&gt;i&lt;/code&gt; 범위, &lt;code&gt;false&lt;/code&gt; 그렇지. 범위가 비어 있으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="84e53e062f78532ae5c08a91413a328c1222f6c0" translate="yes" xml:space="preserve">
          <source>3-4)&lt;code&gt;true&lt;/code&gt; if unary predicate returns &lt;code&gt;true&lt;/code&gt; for at least one element in the range, &lt;code&gt;false&lt;/code&gt; otherwise. Returns &lt;code&gt;false&lt;/code&gt; if the range is empty.</source>
          <target state="translated">3-4) 단항 술어가 범위 내의 하나 이상의 요소에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴하면 &lt;code&gt;true&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다. 범위가 비어 있으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6b92354532b988c8077cc02e5ba6d6d1384c4655" translate="yes" xml:space="preserve">
          <source>3-5) Constructs a &lt;code&gt;std::strstreambuf&lt;/code&gt; object in following steps:</source>
          <target state="translated">3-5) 다음 단계에서 &lt;code&gt;std::strstreambuf&lt;/code&gt; 객체를 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="ff0d983d4446f127472fa68e9c2b30f1ba96d27b" translate="yes" xml:space="preserve">
          <source>3-5)&lt;code&gt;&lt;a href=&quot;../regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; if the supplied regular expression is not valid. The object is not modified in that case.</source>
          <target state="translated">3-5) &lt;code&gt;&lt;a href=&quot;../regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; 제공된 정규식이 유효하지 않은 경우. 이 경우 개체가 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df5f47066140e1dbb3e6ad1d5be5e29180895262" translate="yes" xml:space="preserve">
          <source>3-6) (none).</source>
          <target state="translated">3-6) (없음).</target>
        </trans-unit>
        <trans-unit id="8bccf532b9baf1d9d8241c277ad9e061dd949032" translate="yes" xml:space="preserve">
          <source>3-6) &lt;code&gt;true&lt;/code&gt; if the types referred by the underlying &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; objects are ordered by corresponding order, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">3-6) &lt;code&gt;true&lt;/code&gt; 종류가 기본으로 언급 된 경우 &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 객체가, 순서를 해당 정렬됩니다 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="e970192ad21ae059009884f18918401e77ce9511" translate="yes" xml:space="preserve">
          <source>3-6) Compares &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; in such a way, that &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are totally ordered.</source>
          <target state="translated">3-6) 비교 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 것을, 같은 방식으로 &lt;code&gt;lhs&lt;/code&gt; 과 &lt;code&gt;rhs&lt;/code&gt; 완전히 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="df7a0c3aa783a914021f50e54b7c2af7e6bccda1" translate="yes" xml:space="preserve">
          <source>3-6) Compares &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; lexicographically, that is, compares the first elements and only if they are equivalent, compares the second elements.</source>
          <target state="translated">3-6) 사전 순으로 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 를 비교합니다. 즉, 첫 번째 요소를 비교하고 동일한 경우에만 두 번째 요소를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="3c2be389969cb954c6b44b0e9bafbc24a9db1dfb" translate="yes" xml:space="preserve">
          <source>3-6) Compares &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; lexicographically, that is, compares the first elements, if they are equivalent, compares the second elements, if those are equivalent, compares the third elements, and so on.</source>
          <target state="translated">3-6) 사전 순으로 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 를 비교합니다. 즉, 첫 번째 요소가 동일한 경우 비교하고 두 번째 요소가 동등한 경우 두 번째 요소를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="40c2a2eb6e1667ed787e309e8625ccd1d6b43611" translate="yes" xml:space="preserve">
          <source>3-6) Compares &lt;code&gt;lhs&lt;/code&gt; to &lt;code&gt;rhs&lt;/code&gt;, i.e. compares the number of ticks for the type common to both durations.</source>
          <target state="translated">3-6) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 를 비교합니다. 즉, 두 지속 시간에 공통적 인 유형의 틱 수를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="fc9ec3575961faeaa4f8e6959a6639eac8a498c9" translate="yes" xml:space="preserve">
          <source>3-6) Compares the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; lexicographically. The comparison is performed by a function equivalent to &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">3-6) 어휘 와 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 비교합니다 . 비교는 &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt; 와 동등한 함수로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="77d722861baf30c8bc14382bb6b788bfd141b454" translate="yes" xml:space="preserve">
          <source>3-6) Compares the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; lexicographically. The comparison is performed by a function equivalent to &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt;. This comparison ignores the container's ordering Compare.</source>
          <target state="translated">3-6) 어휘 와 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 비교합니다 . 비교는 &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt; 와 동등한 함수로 수행됩니다 . 이 비교는 컨테이너의 순서 비교를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="c15e5a0d3824286b86f22c3440f42662a5905326" translate="yes" xml:space="preserve">
          <source>3-6) Compares the time points &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">3-6) 시점 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="0ab9b958d3706ff11b9db707166aee1c3e56a4fe" translate="yes" xml:space="preserve">
          <source>3-6) Compares the underlying &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; objects as defined by an implementation-defined ordering. The comparison is done by &lt;a href=&quot;../type_info/before&quot;&gt;&lt;code&gt;type_info::before&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">3-6) 구현 정의 순서에 의해 정의 된 기본 &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 객체를 비교합니다 . 비교는 &lt;a href=&quot;../type_info/before&quot;&gt; &lt;code&gt;type_info::before&lt;/code&gt; &lt;/a&gt; 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7a61a8b9570417a22cf5efee43717a62a321e99" translate="yes" xml:space="preserve">
          <source>3-6) If &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;TimeZonePtrOrName, &lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the deduced second template argument is &lt;code&gt;const &lt;a href=&quot;../time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt;. Otherwise it is &lt;code&gt;TimeZonePtrOrName&lt;/code&gt;.</source>
          <target state="translated">3-6) 만약 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;TimeZonePtrOrName, &lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&amp;gt;&lt;/code&gt; 되는 &lt;code&gt;true&lt;/code&gt; , 도출 된 두 번째 템플릿 인수가 &lt;code&gt;const &lt;a href=&quot;../time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;TimeZonePtrOrName&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0cbf4eb4dfa8d1af84d2687284d33126e8cb9294" translate="yes" xml:space="preserve">
          <source>3-6) Linear in the size of the container</source>
          <target state="translated">3-6) 컨테이너 크기의 선형</target>
        </trans-unit>
        <trans-unit id="841d069152845caa6a5d54b5ed794074460399cb" translate="yes" xml:space="preserve">
          <source>3-6) Returns the string &lt;code&gt;result&lt;/code&gt; which contains the output.</source>
          <target state="translated">3-6) 출력이 포함 된 문자열 &lt;code&gt;result&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="75a8b725ed27c0ce3746806ff40a80ad47df2b5c" translate="yes" xml:space="preserve">
          <source>3-7) Assigns a sequence of characters to the regular expression. The syntax flags are set to &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; returns the number of marked subexpressions within the resulting subexpression after the call.</source>
          <target state="translated">3-7) 일련의 문자를 정규식에 지정합니다. 구문 플래그는 &lt;code&gt;f&lt;/code&gt; 로 설정됩니다 . &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; 는 호출 후 결과 하위 표현식 내에서 표시된 하위 표현식 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1226585074195763b92c7cbdc16577b5fe386084" translate="yes" xml:space="preserve">
          <source>3-7) Behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, inserts an integer, floating point, boolean or generic pointer value by calling &lt;a href=&quot;../../locale/num_put/put&quot;&gt;&lt;code&gt;num_put::put()&lt;/code&gt;&lt;/a&gt;. If the end of file condition was encountered during output (&lt;code&gt;put().failed() == true&lt;/code&gt;), sets &lt;code&gt;ios::badbit&lt;/code&gt;.</source>
          <target state="translated">3-7) &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction으로&lt;/a&gt; 작동합니다 . 센트리 객체를 구성하고 확인한 후 &lt;a href=&quot;../../locale/num_put/put&quot;&gt; &lt;code&gt;num_put::put()&lt;/code&gt; &lt;/a&gt; 을 호출하여 정수, 부동 소수점, 부울 또는 일반 포인터 값을 삽입합니다 . 출력 ( &lt;code&gt;put().failed() == true&lt;/code&gt; ) 중에 파일 끝 조건이 발견 되면 &lt;code&gt;ios::badbit&lt;/code&gt; 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="f9a4e6f226f12510c10fcce05a8098d8886aacb7" translate="yes" xml:space="preserve">
          <source>3-7) Constructs a &lt;code&gt;shared_ptr&lt;/code&gt; with &lt;code&gt;ptr&lt;/code&gt; as the pointer to the managed object.</source>
          <target state="translated">3-7) &lt;code&gt;ptr&lt;/code&gt; 을 관리 객체에 대한 포인터로 사용하여 &lt;code&gt;shared_ptr&lt;/code&gt; 을 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="bac4188ea1454668b8f7103f2da21fceba35d335" translate="yes" xml:space="preserve">
          <source>3-7)&lt;code&gt;&lt;a href=&quot;../regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; if the supplied regular expression is not valid. The object is not modified in that case.</source>
          <target state="translated">제공된 정규식이 유효하지 않은 경우 3-7) &lt;code&gt;&lt;a href=&quot;../regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; . 이 경우 개체가 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="725c41183fc008f47345fbf6c3de83a84f91fb5c" translate="yes" xml:space="preserve">
          <source>3-8) (none)</source>
          <target state="translated">3-8) (없음)</target>
        </trans-unit>
        <trans-unit id="441e48f586b1412242637d7bad65e7063a1defd7" translate="yes" xml:space="preserve">
          <source>3-8) Constructs a &lt;code&gt;shared_lock&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; as the associated mutex. Additionally:</source>
          <target state="translated">3-8) &lt;code&gt;m&lt;/code&gt; 을 연관된 뮤텍스로 사용하여 &lt;code&gt;shared_lock&lt;/code&gt; 을 구성합니다 . 또한 :</target>
        </trans-unit>
        <trans-unit id="baa61a852562b75e9328c1b53a305d3dcad21343" translate="yes" xml:space="preserve">
          <source>3-8) Constructs a &lt;code&gt;unique_lock&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; as the associated mutex. Additionally:</source>
          <target state="translated">3-8) &lt;code&gt;m&lt;/code&gt; 을 관련 mutex로하여 &lt;code&gt;unique_lock&lt;/code&gt; 을 구성합니다 . 또한 :</target>
        </trans-unit>
        <trans-unit id="958e49775c11814714efd04f9b34cbe13caca3e5" translate="yes" xml:space="preserve">
          <source>3-argument overload of &lt;code&gt;&lt;a href=&quot;numeric/math/hypot&quot;&gt;std::hypot&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;numeric/math/hypot&quot;&gt;std::hypot&lt;/a&gt;&lt;/code&gt; 의 3- 인수 과부하</target>
        </trans-unit>
        <trans-unit id="fd7e8ea86d4173971eeb01579836b94c9e3721d7" translate="yes" xml:space="preserve">
          <source>3. Does not throw exceptions when called.</source>
          <target state="translated">3. 호출 될 때 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7adb6719e13625a8f5bc685380bdd91baeb22643" translate="yes" xml:space="preserve">
          <source>3. Otherwise, if either argument is &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;float&amp;gt;&lt;/code&gt;, then both arguments are cast to &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;float&amp;gt;&lt;/code&gt;</source>
          <target state="translated">3. 그렇지 않으면, 인수가 &lt;code&gt;float&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;float&amp;gt;&lt;/code&gt; 인 경우 두 인수 모두 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;float&amp;gt;&lt;/code&gt; &amp;lt;float&amp;gt; 로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="17528ce339462d431fccfe7901d8665ba6c3d5cb" translate="yes" xml:space="preserve">
          <source>3.1) If &lt;code&gt;Y&lt;/code&gt; is an lvalue, the target type is &lt;code&gt;TY&amp;amp;&lt;/code&gt;, and the reference must bind directly to an lvalue;</source>
          <target state="translated">3.1) &lt;code&gt;Y&lt;/code&gt; 가 lvalue 인 경우 대상 유형은 &lt;code&gt;TY&amp;amp;&lt;/code&gt; 이며 참조는 lvalue에 직접 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c3b328b213918e1439cce7ab7569b6a71f561c7" translate="yes" xml:space="preserve">
          <source>3.2 One definition rule [basic.def.odr]</source>
          <target state="translated">3.2 하나의 정의 규칙 [basic.def.odr]</target>
        </trans-unit>
        <trans-unit id="e86feac38772f1aa322e3db85f79cf597aa58fb6" translate="yes" xml:space="preserve">
          <source>3.2) If &lt;code&gt;Y&lt;/code&gt; is an xvalue, the target type is &lt;code&gt;TY&amp;amp;&amp;amp;&lt;/code&gt;, and the reference must bind directly;</source>
          <target state="translated">3.2) &lt;code&gt;Y&lt;/code&gt; 가 xvalue 인 경우 대상 유형은 &lt;code&gt;TY&amp;amp;&amp;amp;&lt;/code&gt; 이며 참조는 직접 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f0f4bbe86fa8417f7a3e3b50e6df88a51d08cdb" translate="yes" xml:space="preserve">
          <source>3.3 Declarative regions and scopes [basic.scope]</source>
          <target state="translated">3.3 선언 영역 및 범위 [basic.scope]</target>
        </trans-unit>
        <trans-unit id="66b067e250a65f46e2c17d128ab341809385dd53" translate="yes" xml:space="preserve">
          <source>3.3 Scope [basic.scope]</source>
          <target state="translated">3.3 범위 [basic.scope]</target>
        </trans-unit>
        <trans-unit id="7a695619c7b2130fa98a43b5dab076e253318a29" translate="yes" xml:space="preserve">
          <source>3.3) If &lt;code&gt;Y&lt;/code&gt; is a prvalue, or if neither the above conversion sequences can be formed and at least one of &lt;code&gt;TX&lt;/code&gt; and &lt;code&gt;TY&lt;/code&gt; is a (possibly cv-qualified) class type,</source>
          <target state="translated">3.3) &lt;code&gt;Y&lt;/code&gt; 가 prvalue이거나 위의 변환 시퀀스가 ​​형성 될 수없고 &lt;code&gt;TX&lt;/code&gt; 및 &lt;code&gt;TY&lt;/code&gt; 중 하나 이상 이 (cv-qualified) 클래스 유형 인 경우,</target>
        </trans-unit>
        <trans-unit id="55065eba2c345cd4d2eede502beb8bb952282f31" translate="yes" xml:space="preserve">
          <source>3.3.1) if &lt;code&gt;TX&lt;/code&gt; and &lt;code&gt;TY&lt;/code&gt; are the same class type (ignoring cv-qualification) and &lt;code&gt;TY&lt;/code&gt; is at least as cv-qualified as &lt;code&gt;TX&lt;/code&gt;, the target type is &lt;code&gt;TY&lt;/code&gt;,</source>
          <target state="translated">3.3.1) &lt;code&gt;TX&lt;/code&gt; 와 &lt;code&gt;TY&lt;/code&gt; 가 동일한 클래스 유형 (cv-qualification 무시)이고 &lt;code&gt;TY&lt;/code&gt; 가 적어도 &lt;code&gt;TX&lt;/code&gt; 와 cv-qualified 인 경우 대상 유형은 &lt;code&gt;TY&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6afd35c1eb0b91a0b7d208db6f220e0a9942558f" translate="yes" xml:space="preserve">
          <source>3.3.2) otherwise, if &lt;code&gt;TY&lt;/code&gt; is a base class of &lt;code&gt;TX&lt;/code&gt;, the target type is &lt;code&gt;TY&lt;/code&gt; with the cv-qualifiers of &lt;code&gt;TX&lt;/code&gt;</source>
          <target state="translated">3.3.2) 그렇지 않은 경우, &lt;code&gt;TY&lt;/code&gt; 가 &lt;code&gt;TX&lt;/code&gt; 의 기본 클래스 인 경우 대상 유형은 &lt;code&gt;TX&lt;/code&gt; 의 cv 규정 &lt;code&gt;TY&lt;/code&gt; 가진 TY 입니다.</target>
        </trans-unit>
        <trans-unit id="985fb4d281490e8ea83d05dbe02b7fbc61ffd007" translate="yes" xml:space="preserve">
          <source>3.3.3) otherwise, the target type is the type that &lt;code&gt;Y&lt;/code&gt; would have after applying the lvalue-to-rvalue, array-to-pointer, and function-to-pointer &lt;a href=&quot;implicit_cast&quot;&gt;standard conversions&lt;/a&gt;</source>
          <target state="translated">3.3.3) 그렇지 않은 경우 대상 유형은 lvalue-to-rvalue, array-to-pointer 및 function-to-pointer &lt;a href=&quot;implicit_cast&quot;&gt;표준 변환&lt;/a&gt; 을 적용한 후 &lt;code&gt;Y&lt;/code&gt; 가 갖는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="82d38dd41d2325cf502db24a9e1edb4a17705a53" translate="yes" xml:space="preserve">
          <source>3.4 Name lookup [basic.lookup]</source>
          <target state="translated">3.4 이름 조회 [basic.lookup]</target>
        </trans-unit>
        <trans-unit id="d81d3597deb4f5b22c3d9c8e2c13ec27cfd1260d" translate="yes" xml:space="preserve">
          <source>3.4) If both sequences can be formed (E2 to target type of E3 and E3 to target type of E2), or only one can be formed but it is the ambiguous conversion sequence, the program is ill-formed.</source>
          <target state="translated">3.4) 두 시퀀스가 ​​형성 될 수 있거나 (E2에서 E3의 대상 유형으로, E3에서 E2의 대상 유형으로) 또는 하나만 형성 될 수 있지만 모호한 변환 시퀀스 인 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="04bac39e18bf178181ba9246859daefab448d88a" translate="yes" xml:space="preserve">
          <source>3.4.4 Elaborated type specifiers [basic.lookup.elab]</source>
          <target state="translated">3.4.4 정교한 타입 지정자 [basic.lookup.elab]</target>
        </trans-unit>
        <trans-unit id="f20ecf122316780e359c44ab1c585a66e547904b" translate="yes" xml:space="preserve">
          <source>3.5) If exactly one conversion sequence can be formed (note that it may still be ill-formed e.g. due to access violation), that conversion sequence is applied and the converted operand is used in place of the original operand for the remained of this description (starting at (4))</source>
          <target state="translated">3.5) 정확히 하나의 변환 시퀀스가 ​​형성 될 수있는 경우 (예 : 액세스 위반으로 인해 여전히 잘못된 형식 일 수 있음) 변환 시퀀스가 ​​적용되고 변환 된 피연산자가이 설명의 나머지 부분에 대해 원래 피연산자 대신 사용됩니다. ((4)에서 시작)</target>
        </trans-unit>
        <trans-unit id="372a26abb8bfc8a6259f2d2eb40911553024769c" translate="yes" xml:space="preserve">
          <source>3.6) If no conversion sequence can be formed, the operands are left unchanged for the remainder of this description</source>
          <target state="translated">3.6) 변환 시퀀스가 ​​형성 될 수없는 경우,이 설명의 나머지 부분에서 피연산자는 변경되지 않은 채로 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e26700e83864ccbb7a7802d50491919dfe06289" translate="yes" xml:space="preserve">
          <source>3.6.1 Main function (p: 43)</source>
          <target state="translated">3.6.1 주요 기능 (p : 43)</target>
        </trans-unit>
        <trans-unit id="273864160ba1bfc2ef057747517114e82ee70b11" translate="yes" xml:space="preserve">
          <source>3.6.1 Main function (p: 58)</source>
          <target state="translated">3.6.1 주요 기능 (p : 58)</target>
        </trans-unit>
        <trans-unit id="3e8ffd414bc58122a97b3991ccd2b4c64bfdc91f" translate="yes" xml:space="preserve">
          <source>3.6.1 Main function (p: 62)</source>
          <target state="translated">3.6.1 주요 기능 (p : 62)</target>
        </trans-unit>
        <trans-unit id="de88e8468487c0ded0a84c275c3ed12f863ce593" translate="yes" xml:space="preserve">
          <source>30) Returns &lt;code&gt;bool(opt) ? value &amp;gt;= *opt : true&lt;/code&gt;.</source>
          <target state="translated">30) &lt;code&gt;bool(opt) ? value &amp;gt;= *opt : true&lt;/code&gt; 리턴합니다 . value&amp;gt; = * opt : true 입니다.</target>
        </trans-unit>
        <trans-unit id="905aee4c9868edbb556736c04d7f2dbfb7806de0" translate="yes" xml:space="preserve">
          <source>30.3.1.2 thread constructors [thread.thread.constr]</source>
          <target state="translated">30.3.1.2 스레드 생성자 [thread.thread.constr]</target>
        </trans-unit>
        <trans-unit id="c9585ea6c38279fb6e0631e9265894b54cc51668" translate="yes" xml:space="preserve">
          <source>30.3.1.5 thread members [thread.thread.member]</source>
          <target state="translated">30.3.1.5 스레드 멤버 [thread.thread.member]</target>
        </trans-unit>
        <trans-unit id="68c95b6d4c026f24530bd18973b13ae3c1e207fc" translate="yes" xml:space="preserve">
          <source>31)&lt;code&gt;&lt;a href=&quot;year_month_weekday&quot;&gt;std::chrono::year_month_weekday&lt;/a&gt;(ym.year(), ym.month(), wdi)&lt;/code&gt;</source>
          <target state="translated">31) &lt;code&gt;&lt;a href=&quot;year_month_weekday&quot;&gt;std::chrono::year_month_weekday&lt;/a&gt;(ym.year(), ym.month(), wdi)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="448fd08b580d8047e7df22198e345f8fd46fe836" translate="yes" xml:space="preserve">
          <source>31-42) Compares a &lt;code&gt;sub_match&lt;/code&gt; with a character. Implemented as if by &lt;code&gt;sm.compare(typename sub_match&amp;lt;BidirIt&amp;gt;::string_type(1, ch))&lt;/code&gt;, where &lt;code&gt;sm&lt;/code&gt; is a &lt;code&gt;sub_match&lt;/code&gt; and &lt;code&gt;ch&lt;/code&gt; is a character.</source>
          <target state="translated">31-42) &lt;code&gt;sub_match&lt;/code&gt; 를 문자와 비교합니다 . &lt;code&gt;sm.compare(typename sub_match&amp;lt;BidirIt&amp;gt;::string_type(1, ch))&lt;/code&gt; 의해 구현되며 , 여기서 &lt;code&gt;sm&lt;/code&gt; 은 &lt;code&gt;sub_match&lt;/code&gt; 이고 &lt;code&gt;ch&lt;/code&gt; 는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="cb4e5208b4cd87268b208e49452ed6e89a68e0b8" translate="yes" xml:space="preserve">
          <source>32</source>
          <target state="translated">32</target>
        </trans-unit>
        <trans-unit id="06e6c1113c2f4580d7903420158b27e7b8a665dc" translate="yes" xml:space="preserve">
          <source>32 bit systems:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6ee11de8b8b94f2fe3985e577ac7a3b0cc3e81" translate="yes" xml:space="preserve">
          <source>32,34)&lt;code&gt;&lt;a href=&quot;year_month_weekday&quot;&gt;std::chrono::year_month_weekday&lt;/a&gt;(y, mwd.month(), mwd.weekday_indexed())&lt;/code&gt;</source>
          <target state="translated">32,34) &lt;code&gt;&lt;a href=&quot;year_month_weekday&quot;&gt;std::chrono::year_month_weekday&lt;/a&gt;(y, mwd.month(), mwd.weekday_indexed())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b13714d4b23bb860e86eac46d326466697202fc7" translate="yes" xml:space="preserve">
          <source>32-bit Mersenne Twister by Matsumoto and Nishimura, 1998.</source>
          <target state="translated">1998 년 Matsumoto와 Nishimura의 32 비트 Mersenne Twister</target>
        </trans-unit>
        <trans-unit id="8d722ddc76a98c8bd0825292353d73caeec2bfca" translate="yes" xml:space="preserve">
          <source>33&amp;ndash;47</source>
          <target state="translated">33&amp;ndash;47</target>
        </trans-unit>
        <trans-unit id="81bcd9116ea78ede1d98011774ec2516cdd89731" translate="yes" xml:space="preserve">
          <source>33,35)&lt;code&gt;&lt;a href=&quot;year_month_weekday&quot;&gt;std::chrono::year_month_weekday&lt;/a&gt;(&lt;a href=&quot;year&quot;&gt;std::chrono::year&lt;/a&gt;(y), mwd.month(), mwd.weekday_indexed())&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;year_month_weekday&quot;&gt;std::chrono::year_month_weekday&lt;/a&gt;(&lt;a href=&quot;year&quot;&gt;std::chrono::year&lt;/a&gt;(y), mwd.month(), mwd.weekday_indexed())&lt;/code&gt; ) std :: chrono :: year_month_weekday ( &lt;a href=&quot;year&quot;&gt;std :: chrono :: year&lt;/a&gt; (y), mwd.month (), mwd.weekday_indexed ())</target>
        </trans-unit>
        <trans-unit id="2ade72f519c3d442623ede9f5a91a8a1a4558604" translate="yes" xml:space="preserve">
          <source>36)&lt;code&gt;&lt;a href=&quot;year_month_weekday_last&quot;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;(ym.year(), ym.month(), wdl)&lt;/code&gt;</source>
          <target state="translated">36) &lt;code&gt;&lt;a href=&quot;year_month_weekday_last&quot;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;(ym.year(), ym.month(), wdl)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8e480c64f53f53b9ccead2e3aed623d13f44141" translate="yes" xml:space="preserve">
          <source>37,39)&lt;code&gt;&lt;a href=&quot;year_month_weekday_last&quot;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;(y, mwdl.month(), mwdl.weekday_last())&lt;/code&gt;</source>
          <target state="translated">37,39) &lt;code&gt;&lt;a href=&quot;year_month_weekday_last&quot;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;(y, mwdl.month(), mwdl.weekday_last())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3235e8bad3d9db1c92b96031a07e818251f09ba2" translate="yes" xml:space="preserve">
          <source>38,40)&lt;code&gt;&lt;a href=&quot;year_month_weekday_last&quot;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;(&lt;a href=&quot;year&quot;&gt;std::chrono::year&lt;/a&gt;(y), mwdl.month(), mwdl.weekday_last())&lt;/code&gt;</source>
          <target state="translated">38,40) &lt;code&gt;&lt;a href=&quot;year_month_weekday_last&quot;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;(&lt;a href=&quot;year&quot;&gt;std::chrono::year&lt;/a&gt;(y), mwdl.month(), mwdl.weekday_last())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b6453892473a467d07372d45eb05abc2031647a" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>
        </trans-unit>
        <trans-unit id="03ae8e0477066003edd21ad44eac3d8a1ed90378" translate="yes" xml:space="preserve">
          <source>4&amp;pi;(l+m)!</source>
          <target state="translated">4&amp;pi;(l+m)!</target>
        </trans-unit>
        <trans-unit id="d797022af3ca599340ac89d033012006afce7940" translate="yes" xml:space="preserve">
          <source>4) (none)</source>
          <target state="translated">4) (없음)</target>
        </trans-unit>
        <trans-unit id="d9b577c8cd1747a9cd10f59696c5c23f1a7354d9" translate="yes" xml:space="preserve">
          <source>4) &lt;code&gt;!(rhs &amp;lt; lhs)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;!(rhs &amp;lt; lhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff4afd3f5f537d6a6e9efa8b261c017d15a31801" translate="yes" xml:space="preserve">
          <source>4) &lt;code&gt;!(y &amp;lt; x)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;!(y &amp;lt; x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d125067b9c34edc9a820ee87ad37397f68cf6f7e" translate="yes" xml:space="preserve">
          <source>4) A &lt;code&gt;&quot;C&quot;&lt;/code&gt; variable and a &lt;code&gt;&quot;C&quot;&lt;/code&gt; function cannot have the same name, regardless if they are defined in the same or different namespaces.</source>
          <target state="translated">4) &lt;code&gt;&quot;C&quot;&lt;/code&gt; 변수와 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 함수는 동일하거나 다른 네임 스페이스에 정의되어 있는지 여부에 관계없이 동일한 이름을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb1516b5fc95f69740a7980370e3e291df67e3ad" translate="yes" xml:space="preserve">
          <source>4) A &lt;code&gt;std::chrono::days&lt;/code&gt; representing the distance between &lt;code&gt;wd1&lt;/code&gt; and &lt;code&gt;wd2&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;std::chrono::days&lt;/code&gt; 사이의 거리를 나타내는 &lt;code&gt;wd1&lt;/code&gt; 및 &lt;code&gt;wd2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5c6e03859f45600da43906f2bd52eac480450c" translate="yes" xml:space="preserve">
          <source>4) A &lt;code&gt;std::chrono::month_day_last&lt;/code&gt; constructed from &lt;code&gt;month()&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;std::chrono::month_day_last&lt;/code&gt; 는 &lt;code&gt;month()&lt;/code&gt; 에서 생성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6bb156d5df7ab606fc894b18b245f3cbf1aa482a" translate="yes" xml:space="preserve">
          <source>4) A &lt;code&gt;std::chrono::months&lt;/code&gt; representing the distance between &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;std::chrono::months&lt;/code&gt; 는 &lt;code&gt;m1&lt;/code&gt; 과 &lt;code&gt;m2&lt;/code&gt; 사이의 거리를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="6a1a75f2b52eb899d2f6e823c95caf3c0416c8d0" translate="yes" xml:space="preserve">
          <source>4) A function parameter pack with an optional name</source>
          <target state="translated">4) 선택적인 이름을 가진 기능 매개 변수 팩</target>
        </trans-unit>
        <trans-unit id="4e25fa1fb5afabb2c867b04353ba9f50714cf1ec" translate="yes" xml:space="preserve">
          <source>4) A is</source>
          <target state="translated">4) A는</target>
        </trans-unit>
        <trans-unit id="4183e45376e1459d5fd0b5f6ac6a73073c290221" translate="yes" xml:space="preserve">
          <source>4) A non-type template parameter with a placeholder type. placeholder may be any type that includes the placeholder &lt;a href=&quot;auto&quot;&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/a&gt; (such as plain &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;auto **&lt;/code&gt; or &lt;code&gt;auto &amp;amp;&lt;/code&gt;), a &lt;a href=&quot;deduction_guide&quot;&gt;placeholder for a deduced class type&lt;/a&gt;(since C++20), or &lt;code&gt;decltype(auto)&lt;/code&gt;.</source>
          <target state="translated">4) 플레이스 홀더 유형이있는 유형이 아닌 템플리트 매개 변수. 플레이스 홀더는 플레이스 홀더 &lt;a href=&quot;auto&quot;&gt; &lt;code&gt;auto&lt;/code&gt; &lt;/a&gt; (일반 &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;auto **&lt;/code&gt; 또는 &lt;code&gt;auto &amp;amp;&lt;/code&gt; ), &lt;a href=&quot;deduction_guide&quot;&gt;추론 된 클래스 유형&lt;/a&gt; 의 플레이스 홀더 (C ++ 20 이후) 또는 &lt;code&gt;decltype(auto)&lt;/code&gt; 을 포함하는 모든 유형일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d79fa059d8c1ee0d12e5380ef59d25f92eb137d" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template accepting an argument of any &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;. Equivalent to (2) (the argument is cast to &lt;code&gt;double&lt;/code&gt;).</source>
          <target state="translated">4) &lt;a href=&quot;../../types/is_integral&quot;&gt;일체형&lt;/a&gt; 의 인수를 허용하는 과부하 세트 또는 함수 템플릿 . (2)와 같습니다 (인수가 &lt;code&gt;double&lt;/code&gt; 로 캐스트 됨 ).</target>
        </trans-unit>
        <trans-unit id="9d0295f0a66ebe646fe3e8bb471499e13c43231c" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template accepting an argument of any &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;. Equivalent to 2) (the argument is cast to &lt;code&gt;double&lt;/code&gt;).</source>
          <target state="translated">4) &lt;a href=&quot;../../types/is_integral&quot;&gt;일체형&lt;/a&gt; 의 인수를 허용하는 과부하 세트 또는 함수 템플릿 . 2)와 같습니다 (인수가 &lt;code&gt;double&lt;/code&gt; 로 캐스트 됨 ).</target>
        </trans-unit>
        <trans-unit id="df89cd7d5e5042ba836aeab57d3001b3ed0545a2" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template accepting the &lt;code&gt;arg&lt;/code&gt; argument of any &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;. Equivalent to (2) (the argument is cast to &lt;code&gt;double&lt;/code&gt;).</source>
          <target state="translated">4) &lt;a href=&quot;../../types/is_integral&quot;&gt;일체형&lt;/a&gt; 의 &lt;code&gt;arg&lt;/code&gt; 인수를 받아들이는 과부하 또는 함수 템플릿 집합 . (2)와 같습니다 (인수가 &lt;code&gt;double&lt;/code&gt; 로 캐스트 됨 ).</target>
        </trans-unit>
        <trans-unit id="6807cc0466902312055b60d74ad66c5c06ed8306" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template accepting the &lt;code&gt;from&lt;/code&gt; argument of any &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;. Equivalent to (2) (the argument is cast to &lt;code&gt;double&lt;/code&gt;).</source>
          <target state="translated">4) &lt;a href=&quot;../../types/is_integral&quot;&gt;일체형&lt;/a&gt; 의 &lt;code&gt;from&lt;/code&gt; 인수를 허용하는 과부하 세트 또는 함수 템플릿 . (2)와 같습니다 (인수가 &lt;code&gt;double&lt;/code&gt; 로 캐스트 됨 ).</target>
        </trans-unit>
        <trans-unit id="c4039560076fbd6689f8c627742548bb7854e1ad" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template for all combinations of arguments of &lt;a href=&quot;../../types/is_arithmetic&quot;&gt;arithmetic type&lt;/a&gt; not covered by (1-3). If any argument has &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;. If any other argument is &lt;code&gt;long double&lt;/code&gt;, then the return type is &lt;code&gt;long double&lt;/code&gt;, otherwise it is &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">4) (1-3)에서 다루지 않은 &lt;a href=&quot;../../types/is_arithmetic&quot;&gt;산술 유형&lt;/a&gt; 의 모든 인수 조합에 대한 과부하 세트 또는 함수 템플릿 . 인수에 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 . 다른 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 반환 유형은 &lt;code&gt;long double&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed537b457c5988a5259f92fd2b0b04de225d931e" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template for all combinations of arguments of &lt;a href=&quot;../../types/is_arithmetic&quot;&gt;arithmetic type&lt;/a&gt; not covered by (1-3). If any non-pointer argument has &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;. If any other non-pointer argument is &lt;code&gt;long double&lt;/code&gt;, then the return type is &lt;code&gt;long double&lt;/code&gt;, otherwise it is &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">4) (1-3)에서 다루지 않은 &lt;a href=&quot;../../types/is_arithmetic&quot;&gt;산술 유형&lt;/a&gt; 의 모든 인수 조합에 대한 과부하 세트 또는 함수 템플릿 . 포인터가 아닌 인수에 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 . 포인터가 아닌 다른 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 반환 유형은 &lt;code&gt;long double&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d238ac3fd85745f84fd7c30cf50ae53eba38826" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template for all combinations of arguments of &lt;a href=&quot;../../types/is_arithmetic&quot;&gt;arithmetic type&lt;/a&gt; not covered by 1-3). If any argument has &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;. If any argument is &lt;code&gt;long double&lt;/code&gt;, then the return type &lt;code&gt;Promoted&lt;/code&gt; is also &lt;code&gt;long double&lt;/code&gt;, otherwise the return type is always &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">4) 1-3에 포함되지 않은 모든 &lt;a href=&quot;../../types/is_arithmetic&quot;&gt;산술 유형&lt;/a&gt; 의 인수 조합에 대한 과부하 세트 또는 함수 템플릿 . 인수에 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 . 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 &lt;code&gt;Promoted&lt;/code&gt; 유형 인 리턴 유형 도 &lt;code&gt;long double&lt;/code&gt; 이며, 그렇지 않으면 반환 유형이 항상 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74e679f41907cffded95edb4e3dc0847fe440390" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template for all combinations of arguments of &lt;a href=&quot;../../types/is_arithmetic&quot;&gt;arithmetic type&lt;/a&gt; not covered by 1-3). If any argument has &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;. If any other argument is &lt;code&gt;long double&lt;/code&gt;, then the return type is &lt;code&gt;long double&lt;/code&gt;, otherwise it is &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">4) 1-3에 포함되지 않은 모든 &lt;a href=&quot;../../types/is_arithmetic&quot;&gt;산술 유형&lt;/a&gt; 의 인수 조합에 대한 과부하 세트 또는 함수 템플릿 . 인수에 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 . 다른 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 반환 유형은 &lt;code&gt;long double&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="231a6d4cf9dd730451fd97c7b1c2d1f3b901a2cf" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template for all combinations of arguments of &lt;a href=&quot;../types/is_arithmetic&quot;&gt;arithmetic type&lt;/a&gt; not covered by 1-3). If any argument has &lt;a href=&quot;../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;. If any other argument is &lt;code&gt;long double&lt;/code&gt;, then the return type is &lt;code&gt;long double&lt;/code&gt;, otherwise it is &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">4) 1-3에 포함되지 않은 모든 &lt;a href=&quot;../types/is_arithmetic&quot;&gt;산술 유형&lt;/a&gt; 의 인수 조합에 대한 과부하 세트 또는 함수 템플릿 . 인수에 &lt;a href=&quot;../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 . 다른 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 반환 유형은 &lt;code&gt;long double&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5fc72aff4b5046a934e8539ab6418e5d0414c52a" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template for all combinations of arguments of arithmetic type not covered by (1-3). If any argument has &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">4) (1-3)에서 다루지 않은 산술 유형의 모든 인수 조합에 대한 과부하 세트 또는 함수 템플릿. 인수에 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="754a27cd2601f871bca8cee1c8c9664be701a7f5" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template for all combinations of arguments of arithmetic type not covered by (1-3). If any argument has &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;. If any argument is &lt;code&gt;long double&lt;/code&gt;, then the return type &lt;code&gt;Promoted&lt;/code&gt; is also &lt;code&gt;long double&lt;/code&gt;, otherwise the return type is always &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">4) (1-3)에서 다루지 않은 산술 유형의 모든 인수 조합에 대한 과부하 세트 또는 함수 템플릿. 인수에 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 . 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 &lt;code&gt;Promoted&lt;/code&gt; 유형 인 리턴 유형 도 &lt;code&gt;long double&lt;/code&gt; 이며, 그렇지 않으면 반환 유형이 항상 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6644b291b0e42f7011bb996792a695d6f39ab651" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template for all combinations of arguments of arithmetic type not covered by (1-3). If any argument has &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;. If any other argument is &lt;code&gt;long double&lt;/code&gt;, then the return type is &lt;code&gt;long double&lt;/code&gt;, otherwise it is &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">4) (1-3)에서 다루지 않은 산술 유형의 모든 인수 조합에 대한 과부하 세트 또는 함수 템플릿. 인수에 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 . 다른 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 반환 유형은 &lt;code&gt;long double&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be3251316d6acd3f0225019598c2cd9c177791a8" translate="yes" xml:space="preserve">
          <source>4) A set of overloads or a function template for all combinations of arguments of arithmetic type not covered by 1-3). If any argument has &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;. If any argument is &lt;code&gt;long double&lt;/code&gt;, then the return type &lt;code&gt;Promoted&lt;/code&gt; is also &lt;code&gt;long double&lt;/code&gt;, otherwise the return type is always &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">4) 1-3에 포함되지 않은 모든 산술 유형의 인수 조합에 대한 과부하 세트 또는 함수 템플릿. 인수에 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 . 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 &lt;code&gt;Promoted&lt;/code&gt; 유형 인 리턴 유형 도 &lt;code&gt;long double&lt;/code&gt; 이며, 그렇지 않으면 반환 유형이 항상 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="46d703211c14aa5f1ddafe0880c7a9ea0bdd6232" translate="yes" xml:space="preserve">
          <source>4) A template parameter used in the parameter type of a function parameter that has a default argument that is being used in the call for which argument deduction is being done:</source>
          <target state="translated">4) 인수 추론이 수행되는 호출에 사용되는 기본 인수가있는 함수 매개 변수의 매개 변수 유형에 사용되는 템플릿 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="ecb0f191dd2b67d2a854106d6c1fe239d8471d91" translate="yes" xml:space="preserve">
          <source>4) A user-defined conversion sequence &lt;code&gt;U1&lt;/code&gt; is</source>
          <target state="translated">4) 사용자 정의 변환 시퀀스 &lt;code&gt;U1&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="e8c28d74a8685615f91858f93c329024d17b6081" translate="yes" xml:space="preserve">
          <source>4) All other pointers compare unequal</source>
          <target state="translated">4) 다른 모든 포인터는 불평등하다</target>
        </trans-unit>
        <trans-unit id="f3384e039a792825af10237bc2fd2cfc34dceb68" translate="yes" xml:space="preserve">
          <source>4) Any value of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, including &lt;code&gt;nullptr&lt;/code&gt; can be converted to any integral type as if it were &lt;code&gt;(void*)0&lt;/code&gt;, but no value, not even &lt;code&gt;nullptr&lt;/code&gt; can be converted to &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;static_cast&lt;/code&gt; should be used for that purpose. (since C++11)</source>
          <target state="translated">4) &lt;code&gt;nullptr&lt;/code&gt; 을 포함하여 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 유형의 모든 값은 마치 &lt;code&gt;(void*)0&lt;/code&gt; 인 것처럼 일체형 유형으로 변환 될 수 있지만 &lt;code&gt;nullptr&lt;/code&gt; 조차 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 로 변환 할 수 없는 값은 없습니다 : &lt;code&gt;static_cast&lt;/code&gt; 를 사용해야합니다 그 목적을 위해. (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="0da412d13b988f08cffde72e8976e1dc3cdb3f43" translate="yes" xml:space="preserve">
          <source>4) Appends characters in the range &lt;code&gt;[s, s + count)&lt;/code&gt;. This range can contain null characters.</source>
          <target state="translated">4) &lt;code&gt;[s, s + count)&lt;/code&gt; 범위의 문자를 추가합니다 . 이 범위는 널 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d60837008c8ff810c5a56cd0c2424b4374ac78ee" translate="yes" xml:space="preserve">
          <source>4) Assigns &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U1&amp;gt;(p.first)&lt;/code&gt; to &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U2&amp;gt;(p.second)&lt;/code&gt; to &lt;code&gt;second&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U1&amp;gt;(p.first)&lt;/code&gt; 를 &lt;code&gt;first&lt;/code&gt; 에 지정 하고 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U2&amp;gt;(p.second)&lt;/code&gt; 를 &lt;code&gt;second&lt;/code&gt; 에 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="013167bb06058b3a34657ffb149d00e7a45fdfad" translate="yes" xml:space="preserve">
          <source>4) Assigns a sequence of &lt;code&gt;count&lt;/code&gt; characters, pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;s&lt;/code&gt; 가 가리키는 일련의 &lt;code&gt;count&lt;/code&gt; 문자를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="21a5654b285c47d5e8084472b19207d35ef16dff" translate="yes" xml:space="preserve">
          <source>4) Assigns characters contained in initializer list &lt;code&gt;il&lt;/code&gt;. Equivalent to &lt;code&gt;assign(il);&lt;/code&gt;.</source>
          <target state="translated">4)를 할당 문자는 초기화 목록에 포함 &lt;code&gt;il&lt;/code&gt; . 등가 &lt;code&gt;assign(il);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9abec77f3406edbc00ca9f3b38aea059c4b3a5d1" translate="yes" xml:space="preserve">
          <source>4) Binary integer literal (base 2, the first digit is the most significant)</source>
          <target state="translated">4) 이진 정수 리터럴 (기수 2, 첫 번째 숫자가 가장 중요)</target>
        </trans-unit>
        <trans-unit id="bafe0324a21bf995c38afa18d2287e25e3d0a928" translate="yes" xml:space="preserve">
          <source>4) Binary left fold (I op ... op E) becomes ((((I op E</source>
          <target state="translated">4) 이진 왼쪽 접기 (I op ... op E)는 ((((op op E)</target>
        </trans-unit>
        <trans-unit id="2a23fd19b36c3ad4e3a802467d21af3a4f7607b9" translate="yes" xml:space="preserve">
          <source>4) Calculate the difference, in days, between two &lt;code&gt;day&lt;/code&gt;&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">4) 계산 일 둘 사이의 차이, &lt;code&gt;day&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c11164b5f963c9b3555f8e377310cfd5a5a2d6b" translate="yes" xml:space="preserve">
          <source>4) Called by the array form of &lt;a href=&quot;../../language/new&quot;&gt;new[]-expressions&lt;/a&gt; to allocate all storage required for an array of objects whose alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;</source>
          <target state="translated">4) 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 객체 배열에 필요한 모든 저장소를 할당하기 위해 &lt;a href=&quot;../../language/new&quot;&gt;new [] &lt;/a&gt;-expression 의 배열 형식으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="66e3f5b651483d4837b4502454c2d18ba52318b0" translate="yes" xml:space="preserve">
          <source>4) Checks whether &lt;a href=&quot;relative_path&quot;&gt;&lt;code&gt;relative_path()&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">4) &lt;a href=&quot;relative_path&quot;&gt; &lt;code&gt;relative_path()&lt;/code&gt; &lt;/a&gt; 가 비어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="81cbf9801ac3b3d369b41bd18b0159f2f3cb7962" translate="yes" xml:space="preserve">
          <source>4) Checks whether &lt;code&gt;code&lt;/code&gt; is a semantic match for &lt;code&gt;cond&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;code&lt;/code&gt; 가 &lt;code&gt;cond&lt;/code&gt; 와 의미 적으로 일치 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e7d89d054ff65ee6efe6865f62a0a7b86c4cb3a7" translate="yes" xml:space="preserve">
          <source>4) Checks whether &lt;code&gt;lhs&lt;/code&gt; is less than or equal to &lt;code&gt;rhs&lt;/code&gt;. Equivalent to &lt;code&gt;!(rhs &amp;lt; lhs)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;lhs&lt;/code&gt; 가 &lt;code&gt;rhs&lt;/code&gt; 보다 작거나 같은지 확인합니다 . &lt;code&gt;!(rhs &amp;lt; lhs)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6a9fb915d497687634a65446ec08b41ee4cd3b09" translate="yes" xml:space="preserve">
          <source>4) Compares this string to the null-terminated character sequence beginning at the character pointed to by</source>
          <target state="translated">4)이 문자열을로 가리키는 문자에서 시작하는 null로 끝나는 문자 시퀀스와 비교합니다.</target>
        </trans-unit>
        <trans-unit id="d97f384d69981d18a3120bf699cc5b5859ed6731" translate="yes" xml:space="preserve">
          <source>4) Computes the</source>
          <target state="translated">4) 계산</target>
        </trans-unit>
        <trans-unit id="1d505d59fc7cf1f6f9cfa726196c87e55f3fb7bb" translate="yes" xml:space="preserve">
          <source>4) Computes the difference between &lt;code&gt;pt_lhs&lt;/code&gt; and &lt;code&gt;pt_rhs&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;pt_lhs&lt;/code&gt; 와 &lt;code&gt;pt_rhs&lt;/code&gt; 의 차이를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="82ad096a5788fd414c46f59747b65bbdc83ef368" translate="yes" xml:space="preserve">
          <source>4) Constant. If &lt;code&gt;alloc&lt;/code&gt; is given and &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt;, then linear.</source>
          <target state="translated">4) 상수. 경우 &lt;code&gt;alloc&lt;/code&gt; 제공되고 &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt; , 다음 선형.</target>
        </trans-unit>
        <trans-unit id="49a639c96567d54cd1ca5a5ded58ef77a5fdf4cc" translate="yes" xml:space="preserve">
          <source>4) Constructs a &lt;code&gt;polymorphic_allocator&lt;/code&gt; using &lt;code&gt;r&lt;/code&gt; as the underlying memory resource. This constructor provides an implicit conversion from &lt;code&gt;memory_resource*&lt;/code&gt;.</source>
          <target state="translated">4) 기본 메모리 자원으로 &lt;code&gt;r&lt;/code&gt; 을 사용하여 &lt;code&gt;polymorphic_allocator&lt;/code&gt; 를 구성 합니다. 이 생성자는 &lt;code&gt;memory_resource*&lt;/code&gt; 에서 암시 적 변환을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="495c996a7e6317593bf4373c1c26feb7f8a4aa4d" translate="yes" xml:space="preserve">
          <source>4) Constructs a &lt;code&gt;weekday&lt;/code&gt; object representing the day of the week &lt;code&gt;dp&lt;/code&gt; corresponds to, as if by &lt;code&gt;weekday(&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_days&lt;/a&gt;(dp.time_since_epoch()))&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;weekday(&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_days&lt;/a&gt;(dp.time_since_epoch()))&lt;/code&gt; &lt;a href=&quot;../system_clock&quot;&gt;std :: chrono :: sys_days&lt;/a&gt; (dp.time_since_epoch ())) 처럼 &lt;code&gt;dp&lt;/code&gt; 에 해당 하는 &lt;code&gt;weekday&lt;/code&gt; 나타내는 요일 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="cb7c4d98e587114d3a9ad7dff9b2d022dc3bc131" translate="yes" xml:space="preserve">
          <source>4) Constructs a &lt;code&gt;year_month_day&lt;/code&gt; object that represent the same date as the one represented by &lt;code&gt;dp&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;dp&lt;/code&gt; 로 표시되는 날짜와 동일한 날짜를 나타내는 &lt;code&gt;year_month_day&lt;/code&gt; 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="6d3572e0d0fc036a58dfb667f929627dec296db9" translate="yes" xml:space="preserve">
          <source>4) Constructs a &lt;code&gt;year_month_weekday&lt;/code&gt; object corresponding to the date represented by &lt;code&gt;dp&lt;/code&gt;. Equivalent to &lt;code&gt;year_month_weekday(sys_days(dp.time_since_epoch()))&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;dp&lt;/code&gt; 로 나타내는 날짜에 해당 하는 &lt;code&gt;year_month_weekday&lt;/code&gt; 객체를 구성합니다 . 상당 &lt;code&gt;year_month_weekday(sys_days(dp.time_since_epoch()))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8023c8110060d179ccd2c47d35d8b122840ce418" translate="yes" xml:space="preserve">
          <source>4) Constructs a directory iterator that refers to the first directory entry of a directory identified by &lt;code&gt;p&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; refers to an non-existing file or not a directory, returns the end iterator and sets &lt;code&gt;ec&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;p&lt;/code&gt; 로 식별되는 디렉토리의 첫 번째 디렉토리 항목을 참조하는 디렉토리 반복자를 구성합니다 . 경우 &lt;code&gt;p&lt;/code&gt; 는 존재하지 않는 파일이나하지 디렉토리를 참조, 끝 반복자를 반환하고 설정 &lt;code&gt;ec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1404f1b25a551baae15745f650f42e3a16639e3" translate="yes" xml:space="preserve">
          <source>4) Constructs a distribution object with the &lt;code&gt;fw&lt;/code&gt; intervals distributed uniformly over &lt;code&gt;[xmin, xmax]&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;fw&lt;/code&gt; 간격이 &lt;code&gt;[xmin, xmax]&lt;/code&gt; 균일하게 분포 된 분포 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="425e0ca67018a775da85f21a2564853814d598ad" translate="yes" xml:space="preserve">
          <source>4) Constructs a distribution object with the &lt;code&gt;nw&lt;/code&gt; intervals distributed uniformly over &lt;code&gt;[xmin, xmax]&lt;/code&gt; and the weights generated by the function &lt;code&gt;fw&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;[xmin, xmax]&lt;/code&gt; &lt;code&gt;nw&lt;/code&gt; 간격이 균일하게 분포 되고 함수 &lt;code&gt;fw&lt;/code&gt; 에 의해 생성 된 가중치 로 분포 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="6ffda4193e2bb4227a733413985a842275f13ffe" translate="yes" xml:space="preserve">
          <source>4) Constructs a duration by converting &lt;code&gt;d&lt;/code&gt; to an appropriate period and tick count, as if by &lt;code&gt;&lt;a href=&quot;duration_cast&quot;&gt;std::chrono::duration_cast&lt;/a&gt;&amp;lt;duration&amp;gt;(d).count()&lt;/code&gt;. In order to prevent truncation during conversion, this constructor only participates in overload resolution if computation of the conversion factor (by &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio_divide&quot;&gt;std::ratio_divide&lt;/a&gt;&amp;lt;Period2, Period&amp;gt;&lt;/code&gt;) does not overflow and:</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;duration_cast&quot;&gt;std::chrono::duration_cast&lt;/a&gt;&amp;lt;duration&amp;gt;(d).count()&lt;/code&gt; &amp;lt;duration&amp;gt; (d) .count () 처럼 &lt;code&gt;d&lt;/code&gt; 를 적절한 기간과 틱 수로 변환하여 지속 시간을 구성합니다 . 변환 중 잘림을 방지하기 위해이 생성자는 변환 계수 계산 ( &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio_divide&quot;&gt;std::ratio_divide&lt;/a&gt;&amp;lt;Period2, Period&amp;gt;&lt;/code&gt; &amp;lt;Period2, Period&amp;gt; )이 오버 플로우되지 않고 다음과 같은 경우 과부하 해결에만 참여합니다 .</target>
        </trans-unit>
        <trans-unit id="42f4e5d73588638b6ea5258d7cfb200b4d9bea98" translate="yes" xml:space="preserve">
          <source>4) Constructs a numeric array with copies of &lt;code&gt;count&lt;/code&gt; values from an array pointed to by &lt;code&gt;vals&lt;/code&gt;. If this array contains less than &lt;code&gt;count&lt;/code&gt; values, the behavior is undefined.</source>
          <target state="translated">4) &lt;code&gt;vals&lt;/code&gt; 지정된 배열 의 &lt;code&gt;count&lt;/code&gt; 값 사본으로 숫자 배열을 구성합니다 . 이 배열에 &lt;code&gt;count&lt;/code&gt; 보다 작은 값 이 포함 된 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c41fe05b7b8aa1bdf8ff815edd25868cb56a8b0d" translate="yes" xml:space="preserve">
          <source>4) Constructs a view of the null-terminated character string pointed to by &lt;code&gt;s&lt;/code&gt;, not including the terminating null character. The length of the view is determined as if by &lt;code&gt;Traits::length(s)&lt;/code&gt;. The behavior is undefined if &lt;code&gt;[s, s+Traits::length(s))&lt;/code&gt; is not a valid range. After construction, &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;s&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;Traits::length(s)&lt;/code&gt;.</source>
          <target state="translated">4) 종료 널 문자를 포함하지 않고 &lt;code&gt;s&lt;/code&gt; 가 가리키는 널 종료 문자 스트링의보기를 구성합니다 . 뷰의 길이는 &lt;code&gt;Traits::length(s)&lt;/code&gt; 의해 결정됩니다 . &lt;code&gt;[s, s+Traits::length(s))&lt;/code&gt; 가 유효한 범위가 아닌 경우 동작이 정의되지 않습니다. 생성 후 &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 와 같고 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;Traits::length(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2eddf472a7a99b7e0b6fb65afe95364954ec260" translate="yes" xml:space="preserve">
          <source>4) Constructs an object with initial content an object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt;, &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;ValueType&amp;gt;(value)&lt;/code&gt;. If &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the program is ill-formed. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; is not the same type as &lt;code&gt;any&lt;/code&gt; nor a specialization of &lt;code&gt;&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type_t&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">4) 초기 콘텐츠 개체를 유형의 객체를 생성 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; , &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;ValueType&amp;gt;(value)&lt;/code&gt; . 만약 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;::value&lt;/code&gt; 이다 &lt;code&gt;false&lt;/code&gt; 프로그램이 잘못 형성된다. 이 오버로드는 오버로드 확인에 참여하는 경우 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; IS하지 동일한 유형의 &lt;code&gt;any&lt;/code&gt; 도의 전문 &lt;code&gt;&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type_t&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a52183e79243b7f3cf701951760411c7e1f03f74" translate="yes" xml:space="preserve">
          <source>4) Constructs the &lt;code&gt;auto_ptr&lt;/code&gt; with the pointer held in the &lt;code&gt;auto_ptr&lt;/code&gt; instance referred to by &lt;code&gt;m&lt;/code&gt;. &lt;code&gt;p.release()&lt;/code&gt; is called for the &lt;code&gt;auto_ptr p&lt;/code&gt; that &lt;code&gt;m&lt;/code&gt; holds to acquire the ownership of the object.</source>
          <target state="translated">4) 구축 &lt;code&gt;auto_ptr&lt;/code&gt; 은 에 유지 포인터 &lt;code&gt;auto_ptr&lt;/code&gt; 은에 의해 참조 된 인스턴스 &lt;code&gt;m&lt;/code&gt; 을 . &lt;code&gt;p.release()&lt;/code&gt; 대해 호출 &lt;code&gt;auto_ptr p&lt;/code&gt; 것으로 &lt;code&gt;m&lt;/code&gt; 은 물체의 소유권을 획득하기 위해 보유하고있다.</target>
        </trans-unit>
        <trans-unit id="216fac8adc62f012e5246575fcb6079adaf8c5f0" translate="yes" xml:space="preserve">
          <source>4) Constructs the &lt;code&gt;wstring_convert&lt;/code&gt; object with specified error strings, using &lt;code&gt;new Codecvt&lt;/code&gt; as the conversion facet and the default-constructed &lt;code&gt;state_type&lt;/code&gt; as shift state.</source>
          <target state="translated">4) &lt;code&gt;new Codecvt&lt;/code&gt; 를 변환 패싯으로 사용하고 기본 구성된 &lt;code&gt;state_type&lt;/code&gt; 을 시프트 상태 로 사용하여 지정된 오류 문자열로 &lt;code&gt;wstring_convert&lt;/code&gt; 객체를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="4f6ff3f7e950f21b5fa54c482801a8003faf6e7f" translate="yes" xml:space="preserve">
          <source>4) Constructs the container with the contents of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 내용으로 컨테이너를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="e470c2c2fbe15ad33f20181f46b20774427535cd" translate="yes" xml:space="preserve">
          <source>4) Constructs the string with the first &lt;code&gt;count&lt;/code&gt; characters of character string pointed to by &lt;code&gt;s&lt;/code&gt;. &lt;code&gt;s&lt;/code&gt; can contain null characters. The length of the string is &lt;code&gt;count&lt;/code&gt;. The behavior is undefined if &lt;code&gt;[s, s + count)&lt;/code&gt; is not a valid range.</source>
          <target state="translated">4) 문자열의 첫 번째 &lt;code&gt;count&lt;/code&gt; 문자가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자열을 구성합니다 . &lt;code&gt;s&lt;/code&gt; 는 널 문자를 포함 할 수 있습니다. 문자열의 길이는 &lt;code&gt;count&lt;/code&gt; 입니다. &lt;code&gt;[s, s + count)&lt;/code&gt; 가 유효한 범위가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2778ea325a7056d6ceee6d27d9ab51117e94747" translate="yes" xml:space="preserve">
          <source>4) Constructs the underlying engine with a copy of &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;e&lt;/code&gt; 의 복사본으로 기본 엔진을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="e50ff5b0aa8f0c1f3f74e964cc30b0641f381078" translate="yes" xml:space="preserve">
          <source>4) Constructs with underlying error code &lt;code&gt;ev&lt;/code&gt;, associated error category &lt;code&gt;ecat&lt;/code&gt; and explanatory string &lt;code&gt;what_arg&lt;/code&gt;. The string returned by &lt;code&gt;&lt;a href=&quot;what&quot;&gt;what()&lt;/a&gt;&lt;/code&gt; is guaranteed to contain &lt;code&gt;what_arg&lt;/code&gt; as a substring.</source>
          <target state="translated">4) 기본 오류 코드 &lt;code&gt;ev&lt;/code&gt; , 관련 오류 범주 &lt;code&gt;ecat&lt;/code&gt; 및 설명 문자열 &lt;code&gt;what_arg&lt;/code&gt; 로 구성 합니다. &lt;code&gt;&lt;a href=&quot;what&quot;&gt;what()&lt;/a&gt;&lt;/code&gt; 의해 반환 된 문자열 은 &lt;code&gt;what_arg&lt;/code&gt; 를 하위 문자열 로 포함 하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="564d3980617aeedaf892f36d27e9b0d04ca6f2a1" translate="yes" xml:space="preserve">
          <source>4) Converting constructor. Constructs a variant holding the alternative type &lt;code&gt;T_j&lt;/code&gt; that would be selected by overload resolution for the expression &lt;code&gt;F(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t))&lt;/code&gt; if there was an overload of imaginary function &lt;code&gt;F(T_i)&lt;/code&gt; for every &lt;code&gt;T_i&lt;/code&gt; from &lt;code&gt;Types...&lt;/code&gt; in scope at the same time, except that:</source>
          <target state="translated">4) 변환 생성자. &lt;code&gt;Types...&lt;/code&gt; 에서 모든 &lt;code&gt;T_i&lt;/code&gt; 에 대해 가상 함수 &lt;code&gt;F(T_i)&lt;/code&gt; 의 과부하가 발생한 경우 &lt;code&gt;F(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t))&lt;/code&gt; &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;T&amp;gt; (t)) 표현식에 대한 과부하 해석에 의해 선택되는 대체 유형 &lt;code&gt;T_j&lt;/code&gt; 를 보유하는 변형을 구성합니다 . 다음을 제외하고 동시에 범위 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="47d9bbd867ade036248180ddc2709283a244ca5e" translate="yes" xml:space="preserve">
          <source>4) Converting copy constructor: If &lt;code&gt;other&lt;/code&gt; doesn't contain a value, constructs an optional object that does not contain a value. Otherwise, constructs an optional object that contains a value, initialized as if &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializing&lt;/a&gt; (but not direct-list-initializing) an object of type &lt;code&gt;T&lt;/code&gt; with the expression &lt;code&gt;*other&lt;/code&gt;. This constructor does not participate in overload resolution unless the following conditions are met:</source>
          <target state="translated">4) 복사 생성자 변환 : &lt;code&gt;other&lt;/code&gt; 에 값이 포함되어 있지 않으면 값이 포함되지 않은 선택적 객체를 생성합니다. 그렇지 않으면, &lt;code&gt;*other&lt;/code&gt; 표현식을 사용하여 &lt;code&gt;T&lt;/code&gt; 유형의 오브젝트를 직접 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;초기화&lt;/a&gt; (직접 목록 초기화하지는 않음)하는 것처럼 초기화되는 값을 포함하는 선택적 오브젝트를 구성합니다 . 이 생성자는 다음 조건이 충족되지 않으면 과부하 해결에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79516b1165e0cc27fb17c98e67889e216d6a3808" translate="yes" xml:space="preserve">
          <source>4) Converting copy-constructor. For all &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;sizeof...(UTypes)&lt;/code&gt;, initializes ith element of the tuple with &lt;code&gt;std::get&amp;lt;i&amp;gt;(other)&lt;/code&gt;.</source>
          <target state="translated">4) 복사 생성자 변환. &lt;code&gt;sizeof...(UTypes)&lt;/code&gt; 모든 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;std::get&amp;lt;i&amp;gt;(other)&lt;/code&gt; 튜플의 ith 요소를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="009f78aca9a07d1a234e568187ac0a0933c4fc32" translate="yes" xml:space="preserve">
          <source>4) Converts an unsigned decimal integer to a string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%u&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">4) 부호없는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%u&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 를 생성 할 내용과 동일한 내용의 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="5d2d91932e9c0bfa187e62329a98d01e4201196a" translate="yes" xml:space="preserve">
          <source>4) Converts an unsigned decimal integer to a wide string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%u&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">4) 부호없는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%u&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에 대해 생성하는 내용과 동일한 내용을 가진 넓은 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="52bf82b37062de5977ab1ab1fb539c406873df09" translate="yes" xml:space="preserve">
          <source>4) Converts the narrow multibyte character sequence &lt;code&gt;[first, last)&lt;/code&gt; to wide_string.</source>
          <target state="translated">4) 좁은 멀티 바이트 문자 시퀀스 &lt;code&gt;[first, last)&lt;/code&gt; 를 wide_string으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b896184a51501db5b652cfb0459a1b93142cbc93" translate="yes" xml:space="preserve">
          <source>4) Converts the wide character sequence &lt;code&gt;[first, last)&lt;/code&gt; to &lt;code&gt;byte_string&lt;/code&gt;.</source>
          <target state="translated">4) 와이드 문자 시퀀스 &lt;code&gt;[first, last)&lt;/code&gt; 를 &lt;code&gt;byte_string&lt;/code&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="c81aec7716b30ecfa3bd0369dc0c776037d5699a" translate="yes" xml:space="preserve">
          <source>4) Copies the exception mask from &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; as if by calling &lt;code&gt;exceptions(other.exceptions())&lt;/code&gt;</source>
          <target state="translated">4)로부터 복사 예외 마스크 &lt;code&gt;other&lt;/code&gt; 행 &lt;code&gt;*this&lt;/code&gt; 것처럼 호출하여 &lt;code&gt;exceptions(other.exceptions())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4e4627b1a8242d44777f4d587bf9f2e20bbbb32" translate="yes" xml:space="preserve">
          <source>4) Copy constructor. Constructs a regex by copying &lt;code&gt;other&lt;/code&gt;</source>
          <target state="translated">4) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 복사하여 정규 표현식을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7facaf913b5fe3e7ac35debbb7a20faa8cea54ba" translate="yes" xml:space="preserve">
          <source>4) Copy constructor. The adaptor is copy-constructed with the contents of &lt;code&gt;other.c&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">4) 복사 생성자. 어댑터는 &lt;code&gt;other.c&lt;/code&gt; 의 내용으로 복사 구성됩니다 . (내재적으로 선언)</target>
        </trans-unit>
        <trans-unit id="df21eb1df019ec5088e8fbea12ed5fcfe935a5b3" translate="yes" xml:space="preserve">
          <source>4) Declares an unnamed parameter with a &lt;a href=&quot;default_arguments&quot;&gt;default value&lt;/a&gt;</source>
          <target state="translated">4) 명명되지 않은 매개 변수를 &lt;a href=&quot;default_arguments&quot;&gt;기본값으로&lt;/a&gt; 선언</target>
        </trans-unit>
        <trans-unit id="d63dfb4c2fa6d80ae40bf29caf5297d1c185fa16" translate="yes" xml:space="preserve">
          <source>4) Defaulted default constructor: the compiler will define the implicit default constructor even if other constructors are present.</source>
          <target state="translated">4) 기본 생성자 : 다른 생성자가 존재하더라도 컴파일러는 암시 적 기본 생성자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="acc39cc54a10e2af8dd8da47a91c1e104265a420" translate="yes" xml:space="preserve">
          <source>4) Designates the type named by the simple-type-specifier or typename-specifier as a friend of this class if that type is a (possibly &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;) class, struct, or union; otherwise the &lt;code&gt;friend&lt;/code&gt; declaration is ignored. This declaration will not forward declare new type.</source>
          <target state="translated">4) 단순 형식 지정자 또는 형식 이름 지정자에 의해 명명 된 형식을이 클래스의 친구로 지정합니다. 해당 형식이 ( &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt; ) 클래스, 구조체 또는 공용체 인 경우; 그렇지 않으면 &lt;code&gt;friend&lt;/code&gt; 선언이 무시됩니다. 이 선언은 새로운 유형을 선언하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="daef86c492ab971173808d5378ec52cbeb561c1c" translate="yes" xml:space="preserve">
          <source>4) Determines whether &lt;code&gt;Fn&lt;/code&gt; can be invoked with the arguments &lt;code&gt;ArgTypes...&lt;/code&gt; to yield a result that is convertible to &lt;code&gt;R&lt;/code&gt; (same as (2)), and that such call (including the conversion) is known not to throw any exceptions.</source>
          <target state="translated">4) &lt;code&gt;ArgTypes...&lt;/code&gt; 인수를 사용하여 &lt;code&gt;Fn&lt;/code&gt; 을 호출 할 수 있는지 여부를 결정 하여 &lt;code&gt;R&lt;/code&gt; 로 변환 할 수있는 결과 ((2)와 동일) 및 이러한 호출 (변환 포함)이 예외를 발생시키지 않는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0e43796e16596e6cee8c60c6d112a9366cd2b54" translate="yes" xml:space="preserve">
          <source>4) Directly from within the body of a member function of a class derived from X</source>
          <target state="translated">4) X에서 파생 된 클래스의 멤버 함수 본문에서 직접</target>
        </trans-unit>
        <trans-unit id="f75542682517e3c4291096774d619127b1835d30" translate="yes" xml:space="preserve">
          <source>4) Disabling the implicit destructor</source>
          <target state="translated">4) 암시 적 소멸자 비활성화</target>
        </trans-unit>
        <trans-unit id="49d2b6b6abcf36f08f545144ed3c46e95e796f95" translate="yes" xml:space="preserve">
          <source>4) Discards the final (unescaped) &lt;code&gt;delim&lt;/code&gt; character.</source>
          <target state="translated">4) 최종 (이스케이프 처리되지 않은) 캐릭터를 &lt;code&gt;delim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50485874b68daa56610fd05cd63819bb284be4ea" translate="yes" xml:space="preserve">
          <source>4) Does not lock the associated mutex.</source>
          <target state="translated">4) 관련 뮤텍스를 잠그지 않습니다.</target>
        </trans-unit>
        <trans-unit id="364622adb649e1805d8eb4e98c3435f957c507bf" translate="yes" xml:space="preserve">
          <source>4) Does not throw if &lt;code&gt;other&lt;/code&gt;'s</source>
          <target state="translated">4) &lt;code&gt;other&lt;/code&gt; 의 경우 던지지 않습니다</target>
        </trans-unit>
        <trans-unit id="0bd467f1fb4977745ffaaed401a2f1da6dc7c323" translate="yes" xml:space="preserve">
          <source>4) Effectively call (3) with the &lt;code&gt;streambuf_type*&lt;/code&gt; pointer &lt;code&gt;p&lt;/code&gt; holds.</source>
          <target state="translated">4) &lt;code&gt;streambuf_type*&lt;/code&gt; 포인터 &lt;code&gt;p&lt;/code&gt; 를 유지 하면서 효과적으로 (3)을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="0624e56a63428f39e22b29a3513e9ff3c9811b1c" translate="yes" xml:space="preserve">
          <source>4) Effectively returns &lt;code&gt;weakly_canonical(p).lexically_proximate(weakly_canonical(base))&lt;/code&gt; or &lt;code&gt;weakly_canonical(p, ec).lexically_proximate(weakly_canonical(base, ec))&lt;/code&gt;, except the error code form returns &lt;code&gt;path()&lt;/code&gt; at the first error occurrence, if any.</source>
          <target state="translated">4) 오류 코드 형식 이 첫 번째 오류 발생시 &lt;code&gt;path()&lt;/code&gt; 를 반환하는 경우를 제외하고 &lt;code&gt;weakly_canonical(p).lexically_proximate(weakly_canonical(base))&lt;/code&gt; 또는 &lt;code&gt;weakly_canonical(p, ec).lexically_proximate(weakly_canonical(base, ec))&lt;/code&gt; 반환 합니다. 어떤.</target>
        </trans-unit>
        <trans-unit id="7bfb8994b593fee92bccdfe1547d9253e033bc26" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;*this = *this - dm;&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;*this = *this - dm;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f3adfa5591cb52a7307ee99c5fe91b289da829a" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;atomic_store_explicit(p, r, memory_order_seq_cst)&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;atomic_store_explicit(p, r, memory_order_seq_cst)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75218da45e16cdc9fe153f4ea8d15e1ecad0a9ab" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;compare(basic_string_view(s))&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;compare(basic_string_view(s))&lt;/code&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a3a6ce9f2fa9f0dcf27d5a42b3e55bca71dd96ea" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;find(basic_string_view(s), pos)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;find(basic_string_view(s), pos)&lt;/code&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="851bb9dc70df949c302433bfd0d8b9a71dae50ad" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;find_first_not_of(basic_string_view(s), pos)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;find_first_not_of(basic_string_view(s), pos)&lt;/code&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="294d73224b3527125dc6ac713f07046ebd89c153" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;find_first_of(basic_string_view(s), pos)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;find_first_of(basic_string_view(s), pos)&lt;/code&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a2de3b42c4b83c1f489013809ed3f4ae469c65a4" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;find_last_not_of(basic_string_view(s), pos)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;find_last_not_of(basic_string_view(s), pos)&lt;/code&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9151fbbbc1d2109eb701fe1392b636bc05d7b39f" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;find_last_of(basic_string_view(s), pos)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;find_last_of(basic_string_view(s), pos)&lt;/code&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="77630a4c72767f2edd3c673a87820f474430e070" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;rep_ /= rhs; return *this;&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;rep_ /= rhs; return *this;&lt;/code&gt; 와 동등 함 ; return * this;</target>
        </trans-unit>
        <trans-unit id="6433b6052ff4cbd0293d10504557d7bfef915bf5" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;reset(pointer())&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;reset(pointer())&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="1abe3842bd6e962259bd11b528ffee09c717dc6f" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;return duration(rep_--);&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;return duration(rep_--);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="026df60b797efbb601a915494c07b7aed4e5eb21" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;return time_point(d_--);&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;return time_point(d_--);&lt;/code&gt; 를 반환하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6715f22cb8bbab8091731bd7fda46354ed3a041d" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;rfind(basic_string_view(s), pos)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;rfind(basic_string_view(s), pos)&lt;/code&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="58222c59ce019f2bd7be89dfe431a977a867490a" translate="yes" xml:space="preserve">
          <source>4) Equivalent to &lt;code&gt;seed_seq(il.begin(), il.end())&lt;/code&gt;. This constructor enables &lt;a href=&quot;../../../language/list_initialization&quot;&gt;list-initialization&lt;/a&gt;.</source>
          <target state="translated">4) &lt;code&gt;seed_seq(il.begin(), il.end())&lt;/code&gt; 합니다. 이 생성자는 &lt;a href=&quot;../../../language/list_initialization&quot;&gt;list-initialization을&lt;/a&gt; 활성화 합니다 .</target>
        </trans-unit>
        <trans-unit id="7c45422de2565c5a8ef2998cc0c0b62474f14537" translate="yes" xml:space="preserve">
          <source>4) Equivalent to: &lt;code&gt;return compare_exchange_weak(expected, desired, order, fail_order);&lt;/code&gt; where &lt;code&gt;fail_order&lt;/code&gt; is the same as &lt;code&gt;order&lt;/code&gt; except that &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; is replaced by &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; is replaced by &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">4) 다음과 같습니다. &lt;code&gt;return compare_exchange_weak(expected, desired, order, fail_order);&lt;/code&gt; 여기서 &lt;code&gt;fail_order&lt;/code&gt; 는 것과 동일 &lt;code&gt;order&lt;/code&gt; 것을 제외하고는 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; 대체된다 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 로 대체 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50517cf56862ffa5557f4d0770eddf2a287d9beb" translate="yes" xml:space="preserve">
          <source>4) Equivalent to: &lt;code&gt;return std::byte(~static_cast&amp;lt;unsigned int&amp;gt;(b));&lt;/code&gt;</source>
          <target state="translated">4) 다음과 같습니다. &lt;code&gt;return std::byte(~static_cast&amp;lt;unsigned int&amp;gt;(b));&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf6b4e587fadf1d1d5288920c00bc06b8af07fee" translate="yes" xml:space="preserve">
          <source>4) Explicit instantiation declaration with template argument deduction for all parameters</source>
          <target state="translated">4) 모든 매개 변수에 대한 템플릿 인수 공제로 명시 적 인스턴스화 선언</target>
        </trans-unit>
        <trans-unit id="74e68f818ed33ea0690424cb28835c5cdc3fea28" translate="yes" xml:space="preserve">
          <source>4) Finally, the body of the constructor is executed</source>
          <target state="translated">4) 마지막으로 생성자의 본문이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6ab50fa6e22108d072eb2ee2c50c3b3825cd7347" translate="yes" xml:space="preserve">
          <source>4) Finds the first character &lt;code&gt;ch&lt;/code&gt; (treated as a single-character substring by the formal rules below).</source>
          <target state="translated">4) 첫 번째 문자 &lt;code&gt;ch&lt;/code&gt; 를 찾습니다 (아래 공식 규칙에 따라 단일 문자 하위 문자열로 처리됨).</target>
        </trans-unit>
        <trans-unit id="50d45aabd08d5113211acc738907d8f7a132f138" translate="yes" xml:space="preserve">
          <source>4) Finds the first character equal to &lt;code&gt;ch&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;ch&lt;/code&gt; 와 동일한 첫 문자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="6c94482b547f11143587b4a8c9ed3f07f55f92fe" translate="yes" xml:space="preserve">
          <source>4) Finds the first character not equal to &lt;code&gt;ch&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;ch&lt;/code&gt; 와 같지 않은 첫 번째 문자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="67db8ae1da5fa63a374ecf50d5da2d624de74d08" translate="yes" xml:space="preserve">
          <source>4) Finds the last character equal to &lt;code&gt;ch&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;ch&lt;/code&gt; 와 같은 마지막 문자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="709a91e223ea7b5cea96117671180eb2d9045fcc" translate="yes" xml:space="preserve">
          <source>4) Finds the last character not equal to &lt;code&gt;ch&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;ch&lt;/code&gt; 와 같지 않은 마지막 문자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="465100f84d5a8212df4d00bf60420c223580dcad" translate="yes" xml:space="preserve">
          <source>4) First, destroys the currently contained value (if any). Then &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializes&lt;/a&gt; the contained value as if constructing a value of type &lt;code&gt;T_I&lt;/code&gt; with the arguments &lt;code&gt;il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. If an exception is thrown, &lt;code&gt;*this&lt;/code&gt; may become &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt;. This overload only participates in overload resolution if &lt;code&gt;std::is_constructible_v&amp;lt;T_I, initializer_list&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. The behavior is undefined if &lt;code&gt;I&lt;/code&gt; is not less than &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">4) 먼저 현재 포함 된 값 (있는 경우)을 삭제합니다. 그런 다음 &lt;code&gt;il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;Args&amp;gt; (args) ... 인수를 사용하여 &lt;code&gt;T_I&lt;/code&gt; 유형의 값을 구성하는 것처럼 포함 된 값을 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 합니다 . 예외가 발생하면 &lt;code&gt;*this&lt;/code&gt; 는 &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception &lt;/a&gt;이 될 수 있습니다 . &lt;code&gt;std::is_constructible_v&amp;lt;T_I, initializer_list&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인경우이 과부하는 과부하 해결에만 참여 합니다 . 경우의 동작은 정의되지 않는다 &lt;code&gt;I&lt;/code&gt; 보다 작되지 &lt;code&gt;sizeof...(Types)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5aa39a0511fdad713438f008626fb98a9ed587e4" translate="yes" xml:space="preserve">
          <source>4) For all &lt;code&gt;i&lt;/code&gt;, assigns &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Ui&amp;gt;(std::get&amp;lt;i&amp;gt;(other))&lt;/code&gt; to &lt;code&gt;std::get&amp;lt;i&amp;gt;(*this)&lt;/code&gt;.</source>
          <target state="translated">4) 모든 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Ui&amp;gt;(std::get&amp;lt;i&amp;gt;(other))&lt;/code&gt; 를 &lt;code&gt;std::get&amp;lt;i&amp;gt;(*this)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b9b03b098b662b73934fdf0567e8381e5fd98440" translate="yes" xml:space="preserve">
          <source>4) For arguments of enumeration type, the namespace in which the enumeration is defined is added to the set. If the enumeration type is a member of a class, that class is added to the set.</source>
          <target state="translated">4) 열거 형 인수의 경우, 열거가 정의 된 네임 스페이스가 세트에 추가됩니다. 열거 유형이 클래스의 멤버 인 경우 해당 클래스가 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="827e3415b4e0eebb4f6a67cdc8020bc373ae44c6" translate="yes" xml:space="preserve">
          <source>4) For every character in the character array &lt;code&gt;[beg, end)&lt;/code&gt;, for which a lower case form exists, replaces the character with that lower case form.</source>
          <target state="translated">4) 소문자 형식이 존재 하는 문자 배열 &lt;code&gt;[beg, end)&lt;/code&gt; 의 모든 문자에 대해 문자를 해당 소문자 형식으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="defa883f263318b01a16ce4b895cd1d54950a568" translate="yes" xml:space="preserve">
          <source>4) For every character in the character array &lt;code&gt;[beg, end)&lt;/code&gt;, for which an upper case form exists, replaces the character with that upper case form.</source>
          <target state="translated">4) 대문자 배열이 존재하는 문자 배열 &lt;code&gt;[beg, end)&lt;/code&gt; 의 모든 문자에 대해 문자를 대문자로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="d9abf2e8e0343f622b2d4da10e59da9adb75661a" translate="yes" xml:space="preserve">
          <source>4) For every character in the character array &lt;code&gt;[beg, end)&lt;/code&gt;, writes narrowed characters (or &lt;code&gt;dflt&lt;/code&gt; whenever narrowing fails) to the successive locations in the character array pointed to by &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">4) 문자 배열 &lt;code&gt;[beg, end)&lt;/code&gt; 의 모든 문자에 대해 &lt;code&gt;dst&lt;/code&gt; 가 가리키는 문자 배열의 연속 위치에 좁은 문자 (또는 좁힘이 실패 할 때마다 &lt;code&gt;dflt&lt;/code&gt; ) 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="0608a9ec5fd605688571f34938053028f2fb3cf4" translate="yes" xml:space="preserve">
          <source>4) For every character in the character array &lt;code&gt;[beg, end)&lt;/code&gt;, writes the corresponding widened character to the successive locations in the character array pointed to by &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">4) 문자 배열 &lt;code&gt;[beg, end)&lt;/code&gt; 의 모든 문자에 대해 &lt;code&gt;dst&lt;/code&gt; 가 가리키는 문자 배열의 연속 된 위치에 해당 확장 문자를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="9d69e47546e1fdbb186c011640b6ff0298440857" translate="yes" xml:space="preserve">
          <source>4) For every character in the character array &lt;code&gt;[low, high)&lt;/code&gt;, identifies the complete classification mask (e.g. &lt;code&gt;digit|xdigit|alnum|print|graph&lt;/code&gt; for the digit &lt;code&gt;'0'&lt;/code&gt; in the default locale), and stores the masks in the corresponding elements of the array pointed to by &lt;code&gt;vec&lt;/code&gt;</source>
          <target state="translated">4) 문자 배열 &lt;code&gt;[low, high)&lt;/code&gt; 의 모든 문자에 대해 완전한 분류 마스크 (예 : 기본 로케일에서 숫자 &lt;code&gt;'0'&lt;/code&gt; 에 대한 &lt;code&gt;digit|xdigit|alnum|print|graph&lt;/code&gt; ) 를 식별 하고 해당하는 마스크를 마스크에 저장합니다. &lt;code&gt;vec&lt;/code&gt; 에 의해 지정된 배열의 요소</target>
        </trans-unit>
        <trans-unit id="9b0afb528c9891565ca22bd035222387f054df56" translate="yes" xml:space="preserve">
          <source>4) For user-defined character literals, the user-defined literal expression is treated as a function call &lt;code&gt;operator &quot;&quot; X(ch)&lt;/code&gt;, where &lt;code&gt;ch&lt;/code&gt; is the literal without ud-suffix</source>
          <target state="translated">4) 사용자 정의 문자 리터럴의 경우 사용자 정의 리터럴 표현식은 함수 호출 &lt;code&gt;operator &quot;&quot; X(ch)&lt;/code&gt; 로 처리됩니다. 여기서 &lt;code&gt;ch&lt;/code&gt; 는 ud- 접미사가없는 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="c29601bebdf4d3497ed308bcb41079928d938498" translate="yes" xml:space="preserve">
          <source>4) From the string argument &lt;code&gt;digits&lt;/code&gt;, only the optional leading minus sign (as determined by comparing to &lt;code&gt;ct.widen('-')&lt;/code&gt;, where &lt;code&gt;ct&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet imbued in &lt;code&gt;str.getloc()&lt;/code&gt;) and the immediately following digit characters (as classified by &lt;code&gt;ct&lt;/code&gt;) are taken as the character sequence to be processed, formatted, and output to &lt;code&gt;out&lt;/code&gt; as described below.</source>
          <target state="translated">4) 문자열 인수 &lt;code&gt;digits&lt;/code&gt; 에서 선택적인 선행 빼기 부호 만 ( &lt;code&gt;ct.widen('-')&lt;/code&gt; 과 비교하여 결정됨) 여기서 &lt;code&gt;ct&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet in &lt;code&gt;str.getloc()&lt;/code&gt; 포함되어 있고 바로 다음 숫자 문자 (분류로 &lt;code&gt;ct&lt;/code&gt; 문자 시퀀스로 간주된다)을 처리 포맷 및 출력 될 &lt;code&gt;out&lt;/code&gt; 후술.</target>
        </trans-unit>
        <trans-unit id="c4f5caed00c3d142b496af509b195cc3ead9e4f9" translate="yes" xml:space="preserve">
          <source>4) Functions are ODR-used if</source>
          <target state="translated">4) 함수는 다음과 같은 경우 ODR 사용</target>
        </trans-unit>
        <trans-unit id="2bdf31a48222efd6cdf333be9d4af77cf0c03b65" translate="yes" xml:space="preserve">
          <source>4) Greater-than operator for variants:</source>
          <target state="translated">4) 변형에 대한 연산자보다 큼 :</target>
        </trans-unit>
        <trans-unit id="a59b256d76453f3fb9174b02e3e2baba3d8c4f3e" translate="yes" xml:space="preserve">
          <source>4) Hexadecimal digit-sequence representing a whole number without a radix separator. The exponent is never optional for hexadecimal floating-point literals: &lt;code&gt;0x1ffp10&lt;/code&gt;, &lt;code&gt;0X0p-1&lt;/code&gt;</source>
          <target state="translated">4) 기수 구분 기호가없는 정수를 나타내는 16 진수 숫자 시퀀스. 16 진 부동 소수점 리터럴의 경우 지수는 선택 사항이 아닙니다. &lt;code&gt;0x1ffp10&lt;/code&gt; , &lt;code&gt;0X0p-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7eb38e23bbbfb5f8495a1647b223c0ca85fa4348" translate="yes" xml:space="preserve">
          <source>4) I/O mode: input, output, or update (both input and output).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e630b22d0770001dca1b746a10e0908b619895fc" translate="yes" xml:space="preserve">
          <source>4) If &lt;code&gt;E2&lt;/code&gt; and &lt;code&gt;E3&lt;/code&gt; are glvalues of the same type and the same value category, then the result has the same type and value category, and is a bit-field if at least one of &lt;code&gt;E2&lt;/code&gt; and &lt;code&gt;E3&lt;/code&gt; is a bit-field.</source>
          <target state="translated">4) &lt;code&gt;E2&lt;/code&gt; 및 &lt;code&gt;E3&lt;/code&gt; 이 동일한 유형 및 동일한 값 범주의 glvalue 인 경우 결과는 동일한 유형 및 값 범주를 가지며 &lt;code&gt;E2&lt;/code&gt; 및 &lt;code&gt;E3&lt;/code&gt; 중 하나 이상이 비트 필드 인 경우 비트 필드입니다.</target>
        </trans-unit>
        <trans-unit id="d4d4d1d67e92f1d6a34382e284648433cbbaee60" translate="yes" xml:space="preserve">
          <source>4) If &lt;code&gt;Mid&lt;/code&gt; is derived (directly or indirectly) from &lt;code&gt;Base&lt;/code&gt;, and &lt;code&gt;Derived&lt;/code&gt; is derived (directly or indirectly) from &lt;code&gt;Mid&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;Mid&lt;/code&gt; 가 &lt;code&gt;Base&lt;/code&gt; 에서 직접 또는 간접적으로 &lt;code&gt;Derived&lt;/code&gt; 되고 Derived 가 &lt;code&gt;Mid&lt;/code&gt; 에서 직접 또는 간접적으로 파생 된 경우</target>
        </trans-unit>
        <trans-unit id="fad7b8c3dc1451ead438d40fde6abde6c6ff9bdd" translate="yes" xml:space="preserve">
          <source>4) If &lt;code&gt;P&lt;/code&gt; is an rvalue reference to a cv-unqualified template parameter (so-called &lt;a href=&quot;reference#Forwarding_references&quot;&gt;forwarding reference&lt;/a&gt;), and the corresponding function call argument is an lvalue, the type lvalue reference to &lt;code&gt;A&lt;/code&gt; is used in place of &lt;code&gt;A&lt;/code&gt; for deduction (Note: this is the basis for the action of &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&lt;/code&gt;Note: in &lt;a href=&quot;deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;, template parameter of a class template is never a forwarding reference(since C++17)):</source>
          <target state="translated">경우 4) &lt;code&gt;P&lt;/code&gt; 는 이력서-비정규 템플릿 파라미터 (소위에 r- 수치 기준이다 &lt;a href=&quot;reference#Forwarding_references&quot;&gt;포워딩 참조&lt;/a&gt; )와 대응하는 함수 호출 인수 좌변이다의 유형 좌변 기준 &lt;code&gt;A&lt;/code&gt; 를 대신 사용한 공제 (참고 : 이것은 &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&lt;/code&gt; 의 동작에 대한 기초입니다. 참고 : &lt;a href=&quot;deduction_guide&quot;&gt;클래스 템플릿 인수 deduction&lt;/a&gt; 에서 클래스 템플릿의 템플릿 매개 변수는 결코 전달 참조가 아닙니다 (C ++ 17 이후). &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="213215edb770b9e33a5802628e0bf67c57a96a6d" translate="yes" xml:space="preserve">
          <source>4) If &lt;code&gt;bool(lhs) == false&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;bool(lhs) == false&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; 반환 합니다</target>
        </trans-unit>
        <trans-unit id="cb85a3bf949483abc595916b86241c4c8255319c" translate="yes" xml:space="preserve">
          <source>4) If &lt;code&gt;m1.ok()&lt;/code&gt; and &lt;code&gt;m2.ok()&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, returns a &lt;code&gt;std::chrono::months&lt;/code&gt; value &lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;m.count()&lt;/code&gt; is in the range [0, 11] and &lt;code&gt;m2 + m == m1&lt;/code&gt;. Otherwise the returned value is unspecified.</source>
          <target state="translated">4) 경우 &lt;code&gt;m1.ok()&lt;/code&gt; 와 &lt;code&gt;m2.ok()&lt;/code&gt; 모두 &lt;code&gt;true&lt;/code&gt; 반품이 &lt;code&gt;std::chrono::months&lt;/code&gt; 값 &lt;code&gt;m&lt;/code&gt; 되도록 &lt;code&gt;m.count()&lt;/code&gt; 범위 [0, 11] 및 &lt;code&gt;m2 + m == m1&lt;/code&gt; . 그렇지 않으면 반환 된 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c8175ce1ad175732c0a598cf3c03d3fcd5339b2" translate="yes" xml:space="preserve">
          <source>4) If &lt;code&gt;remote_version() != get_tzdb().version&lt;/code&gt;, pushes a new &lt;code&gt;tzdb&lt;/code&gt; object representing the remote database to the front of the &lt;code&gt;tzdb_list&lt;/code&gt; singleton referenced by &lt;code&gt;get_tzdb_list()&lt;/code&gt;. Otherwise there are no effects. No references, pointers or iterators are invalidated. Calling this function concurrently with &lt;code&gt;get_tzdb_list().front()&lt;/code&gt; or &lt;code&gt;get_tzdb_list().erase_after()&lt;/code&gt; does not introduce a data race.</source>
          <target state="translated">4) &lt;code&gt;remote_version() != get_tzdb().version&lt;/code&gt; 이면 원격 데이터베이스를 나타내는 새 &lt;code&gt;tzdb&lt;/code&gt; 객체 를 &lt;code&gt;get_tzdb_list()&lt;/code&gt; 참조 하는 &lt;code&gt;tzdb_list&lt;/code&gt; 싱글 톤 의 전면으로 푸시 합니다. 그렇지 않으면 효과가 없습니다. 참조, 포인터 또는 반복자가 무효화되지 않습니다. &lt;code&gt;get_tzdb_list().front()&lt;/code&gt; 또는 &lt;code&gt;get_tzdb_list().erase_after()&lt;/code&gt; 와 함께이 함수를 호출하면 데이터 경쟁이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bfaa01dbfba93ce1c44643fbfe3dbec660cb51c" translate="yes" xml:space="preserve">
          <source>4) If &lt;code&gt;wd1.ok()&lt;/code&gt; and &lt;code&gt;wd2.ok()&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, returns a &lt;code&gt;std::chrono::days&lt;/code&gt; value &lt;code&gt;d&lt;/code&gt; such that &lt;code&gt;d.count()&lt;/code&gt; is in the range [0, 6] and &lt;code&gt;wd2 + d == wd1&lt;/code&gt;. Otherwise the returned value is unspecified.</source>
          <target state="translated">4) 경우 &lt;code&gt;wd1.ok()&lt;/code&gt; 및 &lt;code&gt;wd2.ok()&lt;/code&gt; 모두 &lt;code&gt;true&lt;/code&gt; 반품은 &lt;code&gt;std::chrono::days&lt;/code&gt; 가치 &lt;code&gt;d&lt;/code&gt; 되도록 &lt;code&gt;d.count()&lt;/code&gt; 범위 [0, 6]에 &lt;code&gt;wd2 + d == wd1&lt;/code&gt; . 그렇지 않으면 반환 된 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5423fd95790573f0586d3031a47a9b60943e7dce" translate="yes" xml:space="preserve">
          <source>4) If a key equivalent to &lt;code&gt;k&lt;/code&gt; already exists in the container, does nothing. Otherwise, behaves like &lt;a href=&quot;emplace_hint&quot;&gt;emplace_hint&lt;/a&gt; except that the element is constructed as &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(std::move(k)), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;k&lt;/code&gt; 에 해당하는 키 가 컨테이너에 이미 존재하면 아무 것도 수행하지 않습니다. 그렇지 않으면 요소가 &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(std::move(k)), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt; 로 구성 &lt;a href=&quot;emplace_hint&quot;&gt;된다는&lt;/a&gt; 점을 제외하고 emplace_hint 와 같이 작동 합니다 . .))</target>
        </trans-unit>
        <trans-unit id="d633e15f960b55abe245d2aaa0bbd3f298714943" translate="yes" xml:space="preserve">
          <source>4) If both operands are pointers to the same type, with different cv-qualification, the composite is pointer to the same type with cv-qualification that is a union of the cv-qualifications of the arguments.</source>
          <target state="translated">4) 두 피연산자가 모두 다른 유형의 cv-qualification을 가진 동일한 유형에 대한 포인터 인 경우, 복합은 인수의 cv-qualifications의 결합 인 cv-qualification을 가진 동일한 유형을 가리키는 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="e7898ddfcc8ec4cda9adebeb0397ee628392fbb2" translate="yes" xml:space="preserve">
          <source>4) If expression is a pointer to a &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic type&lt;/a&gt;, and &lt;code&gt;new_type&lt;/code&gt; is a pointer to &lt;code&gt;void&lt;/code&gt;, the result is a pointer to the most derived object pointed or referenced by expression.</source>
          <target state="translated">4) expression이 &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;다형성 유형&lt;/a&gt; 에 대한 포인터 이고 &lt;code&gt;new_type&lt;/code&gt; 이 &lt;code&gt;void&lt;/code&gt; 에 대한 포인터 인 경우 결과는 expression이 가리 키거나 참조한 가장 파생 된 객체에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="23e03ef5abd3584189d77f7b55da5c8d1e20570e" translate="yes" xml:space="preserve">
          <source>4) If new_type is the type &lt;code&gt;void&lt;/code&gt; (possibly cv-qualified), &lt;code&gt;static_cast&lt;/code&gt; discards the value of expression after evaluating it.</source>
          <target state="translated">4) new_type이 &lt;code&gt;void&lt;/code&gt; 유형일 경우 (아마도 cv-qualified 일 수 있음) &lt;code&gt;static_cast&lt;/code&gt; 는 평가 후 expression의 값을 버립니다.</target>
        </trans-unit>
        <trans-unit id="429fb84b0916bfe1e9d93f7903c9276988247380" translate="yes" xml:space="preserve">
          <source>4) If new_type names a non-array complete object type, this expression is an prvalue of type new_type, designating a temporary(until C++17)whose result object is (possibly with added cv-qualifiers)(since C++17) of that type. If new_type is an object type, the object is &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;. If new_type is (possibly &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;) &lt;code&gt;void&lt;/code&gt;, the expression is a void prvalue without a result object(since C++17).</source>
          <target state="translated">4) new_type이 배열이 아닌 완전한 객체 유형의 이름을 갖는 경우,이 표현식은 new_type 유형의 prvalue로, 결과 객체가 (C ++ 한정자 이후에 추가됨) 임시 (C ++ 17까지)를 지정합니다. )를 해당 유형의 new_type이 객체 유형 인 경우 객체는 &lt;a href=&quot;value_initialization&quot;&gt;값으로 초기화&lt;/a&gt; 됩니다. new_type이 ( &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt; ) &lt;code&gt;void&lt;/code&gt; 인 경우 표현식은 결과 객체가없는 void prvalue입니다 (C ++ 17 이후).</target>
        </trans-unit>
        <trans-unit id="7aaac6a82f73e2679f6a80014f56daf8b600f673" translate="yes" xml:space="preserve">
          <source>4) If the ISO C pragma &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is supported and is set to &lt;code&gt;ON&lt;/code&gt;, the changes to the &lt;a href=&quot;../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; (floating-point exceptions and rounding modes) are guaranteed to be observed by the floating-point arithmetic operators and function calls as if executed as written, except that</source>
          <target state="translated">4) ISO C pragma &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt; 가 지원되고 &lt;code&gt;ON&lt;/code&gt; 으로 설정된 경우 &lt;a href=&quot;../numeric/fenv&quot;&gt;부동 소수점 환경&lt;/a&gt; (부동 소수점 예외 및 반올림 모드)의 변경은 부동 소수점 산술 연산자 및 함수에 의해 관찰됩니다. 서면으로 실행 된 것처럼 호출</target>
        </trans-unit>
        <trans-unit id="edce5c260804a73a3cda1248cfc0284ca8deea5a" translate="yes" xml:space="preserve">
          <source>4) If the argument is any other expression of type &lt;code&gt;T&lt;/code&gt;, and</source>
          <target state="translated">4) 인수 유형의 다른 표현 인 경우 &lt;code&gt;T&lt;/code&gt; 는 한</target>
        </trans-unit>
        <trans-unit id="d9b75da45774cf07c126c55291389d9b3d2f6fc6" translate="yes" xml:space="preserve">
          <source>4) If the function has an associated &lt;a href=&quot;constraints&quot;&gt;constraint&lt;/a&gt;, it must be satisfied</source>
          <target state="translated">4) 기능에 관련 &lt;a href=&quot;constraints&quot;&gt;구속 조건&lt;/a&gt; 이있는 경우 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e69cc9b073f7daee72cddd294c2f12130bb7d2aa" translate="yes" xml:space="preserve">
          <source>4) If the types of the operands are P1, a pointer to (possibly cv-qualified) T1, and P2, a pointer to (possibly cv-qualified) T2, and if T1 is the same as T2 or is a base class of T2, then the composite pointer type is the</source>
          <target state="translated">4) 피연산자의 유형이 P1 인 경우 (아마도 cv 규정 된) T1에 대한 포인터, P2, (아마도 cv 규정 된) T2에 대한 포인터, T1이 T2와 같거나 기본 클래스 인 경우 T2이면 복합 포인터 유형은</target>
        </trans-unit>
        <trans-unit id="f15c613f7b7b7f1f8ce19cb6418487d11046ff2b" translate="yes" xml:space="preserve">
          <source>4) If there is a directory separator after the last file-name in the path, the last element before the end iterator is an empty element.</source>
          <target state="translated">4) 경로에서 마지막 파일 이름 다음에 디렉토리 분리자가있는 경우, 마지막 반복기 앞의 마지막 요소는 빈 요소입니다.</target>
        </trans-unit>
        <trans-unit id="2ecaeecb3af9c8c73170e66be5ef9d509638077b" translate="yes" xml:space="preserve">
          <source>4) Implements &lt;code&gt;operator&amp;gt;=&lt;/code&gt; in terms of &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;operator&amp;lt;&lt;/code&gt; 와 관련하여 operator &lt;code&gt;operator&amp;gt;=&lt;/code&gt; 를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="68c312ff54c84ec433adfae1a0bd4b2a5976bddf" translate="yes" xml:space="preserve">
          <source>4) In all other cases, a call to &lt;code&gt;ranges::swap&lt;/code&gt; is ill-formed.</source>
          <target state="translated">4) 다른 모든 경우에는 &lt;code&gt;ranges::swap&lt;/code&gt; 호출 이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c5f887e8a49c447b67a95c46ca4f4e745bdb3d38" translate="yes" xml:space="preserve">
          <source>4) In the &lt;code&gt;return&lt;/code&gt; statement, when the function returns a reference type</source>
          <target state="translated">4) &lt;code&gt;return&lt;/code&gt; 문에서 함수가 참조 유형을 반환 할 때</target>
        </trans-unit>
        <trans-unit id="c2f2899f33615254a49f9abc8511bfb3e4d33f39" translate="yes" xml:space="preserve">
          <source>4) Initializes &lt;code&gt;first&lt;/code&gt; with &lt;code&gt;p.first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; with &lt;code&gt;p.second&lt;/code&gt;.</source>
          <target state="translated">4)를 초기화 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;p.first&lt;/code&gt; 및 &lt;code&gt;second&lt;/code&gt; 와 &lt;code&gt;p.second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82a17dcff3d80536c3facb8ab63a8091ab0e6ff" translate="yes" xml:space="preserve">
          <source>4) Initializes the directory entry with path &lt;code&gt;p&lt;/code&gt; and calls &lt;a href=&quot;refresh&quot;&gt;&lt;code&gt;refresh&lt;/code&gt;&lt;/a&gt; to update the cached attributes. If an error occurs, the non-throwing overload leaves the &lt;code&gt;directory_entry&lt;/code&gt; holding a default-constructed path.</source>
          <target state="translated">4) 경로 &lt;code&gt;p&lt;/code&gt; 를 사용 하여 디렉토리 항목을 초기화 하고 캐시 된 속성을 업데이트하기 위해 &lt;a href=&quot;refresh&quot;&gt; &lt;code&gt;refresh&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 오류가 발생하면 비 투사 과부하 가 기본 구성 경로를 유지하는 &lt;code&gt;directory_entry&lt;/code&gt; 를 떠나게 됩니다.</target>
        </trans-unit>
        <trans-unit id="eca315835ff458b57be3fa078531aaa00074be54" translate="yes" xml:space="preserve">
          <source>4) Initializes the error condition with enum &lt;code&gt;e&lt;/code&gt;. Effectively calls &lt;code&gt;make_error_condition()&lt;/code&gt;. Does not participate in the overload resolution unless &lt;code&gt;is_error_condition_enum&amp;lt;ErrorConditionEnum&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">4) 열거 형 &lt;code&gt;e&lt;/code&gt; 로 오류 조건을 초기화합니다 . 효과적으로 &lt;code&gt;make_error_condition()&lt;/code&gt; 호출합니다 . &lt;code&gt;is_error_condition_enum&amp;lt;ErrorConditionEnum&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 가 아니면 오버로드 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="493718c7f591b7bbf932628085a7dd652edb4e3d" translate="yes" xml:space="preserve">
          <source>4) Initializes the file status object with &lt;code&gt;type&lt;/code&gt; as type and &lt;code&gt;permissions&lt;/code&gt; as permissions.</source>
          <target state="translated">4) &lt;code&gt;type&lt;/code&gt; 을 type으로하고 &lt;code&gt;permissions&lt;/code&gt; 를 권한으로 사용 하여 파일 상태 객체를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="ee83ddcc36b2dfaead2d6b6311a7f5d7fc94f361" translate="yes" xml:space="preserve">
          <source>4) Inserts string &lt;code&gt;str&lt;/code&gt; at the position &lt;code&gt;index&lt;/code&gt;</source>
          <target state="translated">4) 위치 &lt;code&gt;index&lt;/code&gt; 문자열 &lt;code&gt;str&lt;/code&gt; 삽입</target>
        </trans-unit>
        <trans-unit id="63c389e1f2ebc618a20391616f388ecd06c5cdf0" translate="yes" xml:space="preserve">
          <source>4) Iterator pointing to the first element inserted, or &lt;code&gt;pos&lt;/code&gt; if &lt;code&gt;first==last&lt;/code&gt;.</source>
          <target state="translated">4) 제 요소 반복자 포인팅 삽입 또는 &lt;code&gt;pos&lt;/code&gt; 의 경우 &lt;code&gt;first==last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4615d5d21eb6098be7582bf5d52910f7d19828b9" translate="yes" xml:space="preserve">
          <source>4) Iterator to the last element inserted, or &lt;code&gt;pos&lt;/code&gt; if &lt;code&gt;first==last&lt;/code&gt;.</source>
          <target state="translated">4) 마지막으로 삽입 된 요소 반복자 또는 &lt;code&gt;pos&lt;/code&gt; 경우 &lt;code&gt;first==last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="191dfe25599e3f9220c6342951338ec8aea913ad" translate="yes" xml:space="preserve">
          <source>4) Linear in &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 선형 (처음, 마지막)</target>
        </trans-unit>
        <trans-unit id="c2091fb86bc9e2a956faff86c8c15466afb1c677" translate="yes" xml:space="preserve">
          <source>4) Linear in &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; plus linear in the distance between &lt;code&gt;pos&lt;/code&gt; and end of the container.</source>
          <target state="translated">4) 선형의 &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 사이의 거리를 더한 선형 &lt;code&gt;pos&lt;/code&gt; 용기의 단부.</target>
        </trans-unit>
        <trans-unit id="a58027e95eb8f8e6756dfd41980cdc49133e0b36" translate="yes" xml:space="preserve">
          <source>4) Linear in &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; plus linear in the lesser of the distances between &lt;code&gt;pos&lt;/code&gt; and either of the ends of the container.</source>
          <target state="translated">4) 선형 &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; + &lt;code&gt;pos&lt;/code&gt; 와 컨테이너의 양 끝 사이의 거리가 짧은 선형 .</target>
        </trans-unit>
        <trans-unit id="6490a6b4e48145359dfc201eec02d542c27ff863" translate="yes" xml:space="preserve">
          <source>4) Linear in distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 거리의 선형</target>
        </trans-unit>
        <trans-unit id="e617f68419c0b6c9bab7e5af1b1b72d77f2a1eaa" translate="yes" xml:space="preserve">
          <source>4) Makes the state ready</source>
          <target state="translated">4) 상태를 준비합니다</target>
        </trans-unit>
        <trans-unit id="974040d2887eac875a03daefc0867f117137d9c8" translate="yes" xml:space="preserve">
          <source>4) May throw any exception thrown by the initialization of the selected alternative &lt;code&gt;T_j&lt;/code&gt;.</source>
          <target state="translated">4) 선택된 대체 &lt;code&gt;T_j&lt;/code&gt; 의 초기화로 인해 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57ca63f14976e195a8cbf403d61df1c1c9a99c39" translate="yes" xml:space="preserve">
          <source>4) Move constructor. Constructs the container with the contents of &lt;code&gt;other&lt;/code&gt; using move semantics. If &lt;code&gt;alloc&lt;/code&gt; is not provided, allocator is obtained by move-construction from the allocator belonging to &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">4) 생성자를 이동하십시오. 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 내용으로 컨테이너를 구성합니다 . 경우 &lt;code&gt;alloc&lt;/code&gt; 제공되지 않고, 할당이 속하는 할당 이동할 시공함으로써 얻어지는 &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aca0e24560fa503225a91cac61581c2573e5f32" translate="yes" xml:space="preserve">
          <source>4) Move constructor. Constructs the string stream with the state of &lt;code&gt;other&lt;/code&gt; using move semantics.</source>
          <target state="translated">4) 생성자를 이동하십시오. 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 상태의 문자열 스트림을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="1d8188e188dcd21f29d53effdc8f34e030d5d351" translate="yes" xml:space="preserve">
          <source>4) Move-constructor. Constructs a match result with the contents of &lt;code&gt;rhs&lt;/code&gt; using move semantics. &lt;code&gt;rhs&lt;/code&gt; is in valid, but unspecified state after the call.</source>
          <target state="translated">4) 이동 생성자. 이동 의미론을 사용하여 &lt;code&gt;rhs&lt;/code&gt; 의 내용과 일치하는 결과를 구성합니다 . &lt;code&gt;rhs&lt;/code&gt; 는 호출 후 유효하지만 지정되지 않은 상태입니다.</target>
        </trans-unit>
        <trans-unit id="b6fb5c39c6084ce274d06a245c140854f32b3c66" translate="yes" xml:space="preserve">
          <source>4) Move-constructor: moves each allocator from the corresponding allocator of &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">4) 입주 생성자는 : 대응하는 할당의 각 할당 이동 &lt;code&gt;other&lt;/code&gt; 에 &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4470b8a15d06ec4d66868c03550b8c6d93bd8a3e" translate="yes" xml:space="preserve">
          <source>4) Move-constructs the underlying container &lt;code&gt;c&lt;/code&gt; with &lt;code&gt;std::move(cont)&lt;/code&gt;. Copy-constructs the comparison functor &lt;code&gt;comp&lt;/code&gt; with the contents of &lt;code&gt;compare&lt;/code&gt;. Calls &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp)&lt;/code&gt;.</source>
          <target state="translated">4) 기본 컨테이너 &lt;code&gt;c&lt;/code&gt; 를 &lt;code&gt;std::move(cont)&lt;/code&gt; 구성합니다 . 비교 functor &lt;code&gt;comp&lt;/code&gt; 를 &lt;code&gt;compare&lt;/code&gt; 의 내용으로 복사 합니다. &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp)&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="67bb7c4a0d06a2661628b83f8430ddfb2262bb0f" translate="yes" xml:space="preserve">
          <source>4) Namespace names (along with class names) can appear on the left hand side of the scope resolution operator, as part of &lt;a href=&quot;lookup&quot;&gt;qualified name lookup&lt;/a&gt;.</source>
          <target state="translated">4) 네임 스페이스 이름 (클래스 이름과 함께)은 &lt;a href=&quot;lookup&quot;&gt;정규화 된 이름 조회의&lt;/a&gt; 일부로 범위 확인 연산자의 왼쪽에 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4def9860240ffe6736126d88b0890e82ec2c9480" translate="yes" xml:space="preserve">
          <source>4) Non-type argument expression cannot use the name of the template parameter except when it is exactly the name of the template parameter(until C++14) Non-type argument expressions can use template parameters as long as the parameter appears at least once outside a &lt;a href=&quot;template_argument_deduction#Non-deduced_contexts&quot;&gt;non-deduced context&lt;/a&gt;(since C++14)</source>
          <target state="translated">4) 형식이 아닌 인수 표현식은 템플리트 매개 변수의 이름 인 경우를 제외하고 템플리트 매개 변수의 이름을 사용할 수 없습니다 (C ++ 14까지). 형식이 아닌 인수 표현식은 최소한 매개 변수가 나타나는 한 템플리트 매개 변수를 사용할 수 있습니다. 교육을받지 &lt;a href=&quot;template_argument_deduction#Non-deduced_contexts&quot;&gt;않은 컨텍스트&lt;/a&gt; 외부에서 한 번 (C ++ 14부터)</target>
        </trans-unit>
        <trans-unit id="1284db2cef0f87a80d3e82a1457d059e35f16f17" translate="yes" xml:space="preserve">
          <source>4) Number of characters that would have been written for a sufficiently large buffer if successful (not including the terminating null character), or a negative value if an error occurred. Thus, the (null-terminated) output has been completely written if and only if the returned value is nonnegative and less than &lt;code&gt;buf_size&lt;/code&gt;.</source>
          <target state="translated">4) 성공하면 충분히 큰 버퍼에 대해 기록 된 문자 수 (종료 널 문자 제외) 또는 오류가 발생한 경우 음수 값. 따라서, 리턴 된 값이 음이 &lt;code&gt;buf_size&lt;/code&gt; 보다 작은 경우에만 (널 종료) 출력이 완전히 기록되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8acc24c5c5ff9f9a3d10bea0aa1bffdd47cd973c" translate="yes" xml:space="preserve">
          <source>4) Number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to &lt;code&gt;buf_size&lt;/code&gt; limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed.</source>
          <target state="translated">4) 성공한 경우 쓰여진 문자 수 또는 오류가 발생한 경우 음수 값. &lt;code&gt;buf_size&lt;/code&gt; 한계 로 인해 결과 문자열이 잘리는 경우 함수는 한계가 적용되지 않은 경우 쓰여질 총 문자 수 (종료 널 바이트 제외)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c0a1497497c99264ef5f525873a68a07ee66b8be" translate="yes" xml:space="preserve">
          <source>4) O(N) comparisons, where N is &lt;code&gt;cont.size()&lt;/code&gt;.</source>
          <target state="translated">4) O (N) 비교, 여기서 N은 &lt;code&gt;cont.size()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="210ca1261a060d9e104515fd130236670c3f2589" translate="yes" xml:space="preserve">
          <source>4) Omitted parameter list: function takes no arguments, as if the parameter list was &lt;code&gt;()&lt;/code&gt;. This form can only be used if none of constexpr, mutable, exception specification, attributes, or trailing return type is used.</source>
          <target state="translated">4) 생략 된 매개 변수리스트 : 함수는 매개 변수리스트가 &lt;code&gt;()&lt;/code&gt; 인 것처럼 인수를 취하지 않습니다 . 이 형식은 constexpr, mutable, exception specification, attributes 또는 trailing return type이 사용되지 않는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78582170b911073276ca9eb19e339615ceeca7df" translate="yes" xml:space="preserve">
          <source>4) Otherwise, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">4) 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="303687a07dc038947aabee746d3ecd7746954889" translate="yes" xml:space="preserve">
          <source>4) Otherwise, the function reallocates (or initially allocates) a dynamic array large enough to hold the contents of the current dynamic array (if any) plus at least one additional write position. If a pointer to the allocating function &lt;code&gt;palloc&lt;/code&gt; was used in the constructor, that function is called with &lt;code&gt;(*palloc)(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of bytes to allocate, otherwise &lt;code&gt;new char[n]&lt;/code&gt; is used. If a pointer to the deallocating function &lt;code&gt;pfree&lt;/code&gt; was used in the constructor, that function is called with &lt;code&gt;(*pfree)(p)&lt;/code&gt; to deallocate the previous array, if needed, otherwise &lt;code&gt;delete[] p&lt;/code&gt; is used. If allocation fails, the function fails and returns &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">4) 그렇지 않으면, 함수는 현재 동적 배열 (있는 경우)의 내용과 하나 이상의 추가 쓰기 위치를 보유 할 수있을 정도로 큰 동적 배열을 재 할당 (또는 초기에 할당)합니다. 할당 함수 &lt;code&gt;palloc&lt;/code&gt; 에 대한 포인터가 생성자에서 사용 된 경우 해당 함수는 &lt;code&gt;(*palloc)(n)&lt;/code&gt; 으로 호출됩니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 할당 할 바이트 수입니다. 그렇지 않으면 &lt;code&gt;new char[n]&lt;/code&gt; 이 사용됩니다. 할당 해제 함수 &lt;code&gt;pfree&lt;/code&gt; 에 대한 포인터가 생성자에서 사용 된 경우, 해당 함수는 &lt;code&gt;(*pfree)(p)&lt;/code&gt; 와 함께 호출되어 이전 배열을 할당 해제합니다 (필요한 경우). 그렇지 않으면 &lt;code&gt;delete[] p&lt;/code&gt; 가 사용됩니다. 할당이 실패하면 함수가 실패하고 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bfafd73beda3d113870bb90e8a01949494063ac5" translate="yes" xml:space="preserve">
          <source>4) Otherwise, the pointer is assigned as if by &lt;code&gt;gptr() = eback() + newoff + off&lt;/code&gt; or &lt;code&gt;pptr() = pbase() + newoff + off&lt;/code&gt;</source>
          <target state="translated">4) 그렇지 않으면 포인터는 &lt;code&gt;gptr() = eback() + newoff + off&lt;/code&gt; 또는 &lt;code&gt;pptr() = pbase() + newoff + off&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b86f1cff44cf193dff984c7bfc703cedaa8cc7f" translate="yes" xml:space="preserve">
          <source>4) Otherwise, two pointers to member compare equal if and only if they would refer to the same member of the same most derived object or the same subobject if they were dereferenced with a hypothetical object of the associated class type</source>
          <target state="translated">4) 그렇지 않으면, 멤버에 대한 두 개의 포인터는 동일한 클래스 유형의 가상 오브젝트로 참조 해제 된 경우 동일한 가장 파생 된 오브젝트의 동일한 멤버 또는 동일한 서브 오브젝트를 참조하는 경우에만 동일하게 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="a14289cb24e965fd0cf9b09a0c41591634f47c5e" translate="yes" xml:space="preserve">
          <source>4) Perfect-forwarded assignment: depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value before the call, the contained value is either direct-initialized from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(value)&lt;/code&gt; or assigned from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(value)&lt;/code&gt;. The function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;(until C++20)&lt;code&gt;&lt;a href=&quot;../../types/remove_cvref&quot;&gt;std::remove_cvref_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;(since C++20) is not &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and at least one of the following is true:</source>
          <target state="translated">4) 완벽 감기 할당 : 여부에 따라 &lt;code&gt;*this&lt;/code&gt; 호출 전에 값을 포함하는 상기 포함 된 값이 다이렉트 초기화 내지 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(value)&lt;/code&gt; 이나에서 지정된 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(value)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; (C ++ 20까지) &lt;code&gt;&lt;a href=&quot;../../types/remove_cvref&quot;&gt;std::remove_cvref_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; (C ++ 20 이후)가 &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; 아니면 함수는 과부하 해결에 참여하지 않습니다. is_constructible_v &amp;lt;T, U&amp;gt; 는 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 이며 다음 중 하나 이상이 true입니다.</target>
        </trans-unit>
        <trans-unit id="1ddd72b0d4c864f21ab15e3a7d68d001f61c076d" translate="yes" xml:space="preserve">
          <source>4) Performs atomic bitwise or. Equivalent to &lt;code&gt;fetch_or(arg)&lt;/code&gt; | arg.</source>
          <target state="translated">4) 원자 비트 단위 또는 &lt;code&gt;fetch_or(arg)&lt;/code&gt; 와 동일 | 인수</target>
        </trans-unit>
        <trans-unit id="a853cf3a9a6c55331fc0ed7d5a6253d621b296d3" translate="yes" xml:space="preserve">
          <source>4) Performs atomic bitwise or. Equivalent to &lt;code&gt;return fetch_or(arg) | arg;&lt;/code&gt;.</source>
          <target state="translated">4) 원자 비트 단위 또는 &lt;code&gt;return fetch_or(arg) | arg;&lt;/code&gt; 를 반환하는 것과 동일 | 인수; .</target>
        </trans-unit>
        <trans-unit id="522fb5240c305e1448c3c9e10ee56eaa4380fc79" translate="yes" xml:space="preserve">
          <source>4) Performs atomic post-decrement. Equivalent to &lt;code&gt;fetch_sub(1)&lt;/code&gt;.</source>
          <target state="translated">4) 원자 후 감소를 수행합니다. 등가 &lt;code&gt;fetch_sub(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5faaf5815d329b681cf47021e5b890270a7a3b62" translate="yes" xml:space="preserve">
          <source>4) Performs atomic post-decrement. Equivalent to &lt;code&gt;return fetch_sub(1);&lt;/code&gt;.</source>
          <target state="translated">4) 원자 후 감소를 수행합니다. &lt;code&gt;return fetch_sub(1);&lt;/code&gt; 을 반환하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="a75babbc0a22a53e1619af8dc9b09f91ba51a99d" translate="yes" xml:space="preserve">
          <source>4) Reads characters and stores them into the successive locations of the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. Characters are extracted and stored until any of the following occurs:</source>
          <target state="translated">4) 문자를 읽고 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열의 연속 위치에 저장합니다 . 다음 중 하나가 발생할 때까지 문자가 추출되어 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a38e5af44ed6295f4534611d3da5b07b84307cdc" translate="yes" xml:space="preserve">
          <source>4) Remove each dot and any immediately following directory-separator.</source>
          <target state="translated">4) 디렉토리 구분 기호 바로 다음에있는 각 점과 모든 점을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="994f36bd46d687a24594d5be504f04d629419cfd" translate="yes" xml:space="preserve">
          <source>4) Replaces the contents of &lt;code&gt;*this&lt;/code&gt; with a new path value constructed from detected-format &lt;code&gt;source&lt;/code&gt; as if by overload (4) of the &lt;a href=&quot;path&quot;&gt;path constructor&lt;/a&gt;. Equivalent to &lt;code&gt;assign(source)&lt;/code&gt;.</source>
          <target state="translated">4)의 내용을 대체 &lt;code&gt;*this&lt;/code&gt; 검출 된 포맷으로 구성 새로운 경로 값과 &lt;code&gt;source&lt;/code&gt; 의 과부하 (4)에 의한 것처럼 &lt;a href=&quot;path&quot;&gt;경로 생성자&lt;/a&gt; . &lt;code&gt;assign(source)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="155d64bd2ac6afc214891fbbc4e1a6ef85531ed2" translate="yes" xml:space="preserve">
          <source>4) Replaces the contents with character &lt;code&gt;ch&lt;/code&gt; as if by &lt;code&gt;assign(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(ch), 1)&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;assign(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(ch), 1)&lt;/code&gt; &lt;a href=&quot;../../memory/addressof&quot;&gt;std :: addressof&lt;/a&gt; (ch), 1) 과 같이 내용을 문자 &lt;code&gt;ch&lt;/code&gt; 로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="02e72bb05dbed4c088d1833a866fb2acf51c0bf0" translate="yes" xml:space="preserve">
          <source>4) Replaces the contents with those of &lt;code&gt;str&lt;/code&gt; using move semantics. Equivalent to &lt;code&gt;*this = std::move(str)&lt;/code&gt;. In particular, allocator propagation may take place.</source>
          <target state="translated">4) 이동 의미를 사용하여 내용을 &lt;code&gt;str&lt;/code&gt; 의 내용으로 바꿉니다 . 상당 &lt;code&gt;*this = std::move(str)&lt;/code&gt; . 특히 할당 자 전파가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80ff44b4f1f1bac322280c8c6e8c5a01081c518b" translate="yes" xml:space="preserve">
          <source>4) Returns &lt;code&gt;&lt;a href=&quot;utc_clock/to_sys&quot;&gt;std::chrono::utc_clock::to_sys&lt;/a&gt;(t)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;utc_clock/to_sys&quot;&gt;std::chrono::utc_clock::to_sys&lt;/a&gt;(t)&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3375b383905482944de9a99133e577b578f2be15" translate="yes" xml:space="preserve">
          <source>4) Returns &lt;code&gt;std::regex_match(s.begin(), s.end(), m, e, flags)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;std::regex_match(s.begin(), s.end(), m, e, flags)&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="aa9d0e680e04e62d91cdbbe593ce83c2607cb633" translate="yes" xml:space="preserve">
          <source>4) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">4) 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;lhs&lt;/code&gt; 있다</target>
        </trans-unit>
        <trans-unit id="07034509d9fb3a0545414347cb5d0d9f9f93cf53" translate="yes" xml:space="preserve">
          <source>4) Returns &lt;code&gt;true&lt;/code&gt; if lhs is greater than or equal to rhs, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">4) 반환 &lt;code&gt;true&lt;/code&gt; 좌는,보다 큰 또는 우측에 동일 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="6ae5e53bb11e17bcc1c3ec26e617591570b8d1c5" translate="yes" xml:space="preserve">
          <source>4) Returns a temporary copy of &lt;code&gt;*this&lt;/code&gt; with all bits flipped (binary NOT).</source>
          <target state="translated">4) 모든 비트가 반전 된 (이진 NOT) &lt;code&gt;*this&lt;/code&gt; 의 임시 사본을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="94998bcb816a4b3ef8871cc3028ccaaded348493" translate="yes" xml:space="preserve">
          <source>4) Returns the difference in years between &lt;code&gt;y1&lt;/code&gt; and &lt;code&gt;y2&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;y1&lt;/code&gt; 과 &lt;code&gt;y2&lt;/code&gt; 사이의 연도 차이를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="73c00608d61ad1bdbeb53c91e99771217a4cd8c7" translate="yes" xml:space="preserve">
          <source>4) Returns the format structure (of type &lt;a href=&quot;../money_base&quot;&gt;&lt;code&gt;std::money_base::format&lt;/code&gt;&lt;/a&gt;) which describes the formatting of negative monetary values.</source>
          <target state="translated">4) 음의 통화 값의 형식을 설명 하는 형식 구조 ( &lt;a href=&quot;../money_base&quot;&gt; &lt;code&gt;std::money_base::format&lt;/code&gt; &lt;/a&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="faf50e4b8ae919c9eb2cfb96b0f3d70071ae6423" translate="yes" xml:space="preserve">
          <source>4) Returns the stored weekday index.</source>
          <target state="translated">4) 저장된 요일 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5045e78c6faebce3021f2b3d4c981764054d4303" translate="yes" xml:space="preserve">
          <source>4) Returns the string to be used as the representation of the boolean value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">4) 부울 값 &lt;code&gt;false&lt;/code&gt; 의 표현으로 사용될 문자열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6b21a578ab479c8334484e94dbc1f002240586fb" translate="yes" xml:space="preserve">
          <source>4) Same as (1), but accepts any iterator pair that designates a multicharacter string. Equivalent to &lt;code&gt;return operator/=(path(first, last));&lt;/code&gt;</source>
          <target state="translated">4) (1)과 동일하지만 다중 문자 문자열을 지정하는 반복자 쌍을 허용합니다. 동등 &lt;code&gt;return operator/=(path(first, last));&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7820c8b3bd9390641d2d875496b785905e263b12" translate="yes" xml:space="preserve">
          <source>4) Same as (1), except that the object is &lt;a href=&quot;../../language/default_initialization&quot;&gt;default-initialized&lt;/a&gt;. This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is not an array type. The function is equivalent to:</source>
          <target state="translated">4) 객체가 &lt;a href=&quot;../../language/default_initialization&quot;&gt;기본 초기화 된&lt;/a&gt; 것을 제외하고 (1)과 동일합니다 . 이 과부하 는 &lt;code&gt;T&lt;/code&gt; 가 배열 유형이 아닌 경우에만 과부하 해결에 참여 합니다. 이 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ebb1108fdb3deae92b519a9ad6f1f87a8295a3a" translate="yes" xml:space="preserve">
          <source>4) Same as (2), but uses &lt;code&gt;is_nothrow_swappable_with&lt;/code&gt;.</source>
          <target state="translated">4) (2)와 동일하지만 &lt;code&gt;is_nothrow_swappable_with&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="a89a6cb7cbfd9e109a4117f5148e800f7a80e635" translate="yes" xml:space="preserve">
          <source>4) Same as (3), but additionally uses a copy of &lt;code&gt;alloc&lt;/code&gt; for allocation of data for internal use. &lt;code&gt;Alloc&lt;/code&gt; must be a &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;. The copy constructor and destructor must not throw exceptions. Equivalent to &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(ptr, d, alloc).swap(*this);&lt;/code&gt;.</source>
          <target state="translated">4) ((3)과 동일), 그러나 부가의 복사본 사용 &lt;code&gt;alloc&lt;/code&gt; 내부의 데이터 할당. &lt;code&gt;Alloc&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; 여야합니다 . 복사 생성자와 소멸자는 예외를 발생시키지 않아야합니다. 당량 &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(ptr, d, alloc).swap(*this);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28cba68aeafbd94e92b23cf47121172dc36e4447" translate="yes" xml:space="preserve">
          <source>4) Sets the</source>
          <target state="translated">4) 설정</target>
        </trans-unit>
        <trans-unit id="4fb8745bc8157c30d59cda190281680d9b1e2fc1" translate="yes" xml:space="preserve">
          <source>4) Sets the &lt;code&gt;floatfield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to zero, as if by calling &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt;. This enables the default floating-point formatting, which is different from fixed and scientific.</source>
          <target state="translated">4) &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: floatfield&lt;/a&gt; ) 를 호출하는 것처럼 스트림 &lt;code&gt;str&lt;/code&gt; 의 &lt;code&gt;floatfield&lt;/code&gt; 를 0으로 설정합니다 . 고정 및 과학과 다른 기본 부동 소수점 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="38ca3bde31696c4eb777d63016f85cbe9b8610ed" translate="yes" xml:space="preserve">
          <source>4) Similar to (3), but uses a &lt;code&gt;CharT*&lt;/code&gt; instead of a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;. Equivalent to &lt;code&gt;bitset(n == basic_string&amp;lt;CharT&amp;gt;::npos ? basic_string&amp;lt;CharT&amp;gt;(str) : basic_string&amp;lt;CharT&amp;gt;(str, n), 0, n, zero, one)&lt;/code&gt;</source>
          <target state="translated">4) (3)과 유사하지만 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;CharT*&lt;/code&gt; 를 사용합니다 . 등가 &lt;code&gt;bitset(n == basic_string&amp;lt;CharT&amp;gt;::npos ? basic_string&amp;lt;CharT&amp;gt;(str) : basic_string&amp;lt;CharT&amp;gt;(str, n), 0, n, zero, one)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90c261ec5627fcfda4c7d40469ee938826a8ff5e" translate="yes" xml:space="preserve">
          <source>4) Specialization for const-qualified types.</source>
          <target state="translated">4) const 한정 타입의 전문화.</target>
        </trans-unit>
        <trans-unit id="df0b556bf54b063fa01b92c5af57e0a7dfe91603" translate="yes" xml:space="preserve">
          <source>4) Specialization for types that define a public and accessible member type &lt;code&gt;difference_type&lt;/code&gt;. Provides a member type &lt;code&gt;difference_type&lt;/code&gt; equal to &lt;code&gt;T::difference_type&lt;/code&gt;.</source>
          <target state="translated">4) 공개 및 액세스 가능한 멤버 유형 &lt;code&gt;difference_type&lt;/code&gt; 을 정의하는 유형의 전문화 . &lt;code&gt;T::difference_type&lt;/code&gt; 과 동일한 멤버 유형 &lt;code&gt;difference_type&lt;/code&gt; 을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d3c3f99f5382a6e786fa7cf4ccd92e0f8041b629" translate="yes" xml:space="preserve">
          <source>4) The &lt;code&gt;extern&lt;/code&gt; specifier is only allowed in the declarations of variables and functions (except class members or function parameters). It specifies external linkage, and does not technically affect storage duration, but it cannot be used in a definition of an automatic storage duration object, so all &lt;code&gt;extern&lt;/code&gt; objects have static or thread durations. In addition, a variable declaration that uses &lt;code&gt;extern&lt;/code&gt; and has no initializer is not a &lt;a href=&quot;definition&quot;&gt;definition&lt;/a&gt;.</source>
          <target state="translated">4) &lt;code&gt;extern&lt;/code&gt; 지정자는 변수 및 함수 선언에서만 허용됩니다 (클래스 멤버 또는 함수 매개 변수 제외). 외부 연결을 지정하고 기술적으로 저장 기간에 영향을 미치지 않지만 자동 저장 기간 개체의 정의에 사용할 수 없으므로 모든 &lt;code&gt;extern&lt;/code&gt; 객체에는 정적 또는 스레드 기간이 있습니다. 또한 &lt;code&gt;extern&lt;/code&gt; 을 사용 하고 이니셜 라이저가없는 변수 선언 은 &lt;a href=&quot;definition&quot;&gt;정의&lt;/a&gt; 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="509b36ec0ac4a7b51552520891faff83417b2e95" translate="yes" xml:space="preserve">
          <source>4) The body of the main function does not need to contain the &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;: if control reaches the end of &lt;code&gt;main&lt;/code&gt; without encountering a return statement, the effect is that of executing &lt;code&gt;return 0;&lt;/code&gt;.</source>
          <target state="translated">4) main 함수의 본문은 &lt;a href=&quot;return&quot;&gt;return 문&lt;/a&gt; 을 포함 할 필요가 없습니다. return 문이 발생하지 않고 제어가 &lt;code&gt;main&lt;/code&gt; 의 끝에 도달하면 그 결과는 &lt;code&gt;return 0;&lt;/code&gt; 을 실행하는 효과입니다 . .</target>
        </trans-unit>
        <trans-unit id="d54b209973df54464cce2aced653b5b6b96c3f81" translate="yes" xml:space="preserve">
          <source>4) The copy constructor is deleted, &lt;code&gt;std::packaged_task&lt;/code&gt; is move-only.</source>
          <target state="translated">4) 복사 생성자가 삭제되고 &lt;code&gt;std::packaged_task&lt;/code&gt; 는 이동 전용입니다.</target>
        </trans-unit>
        <trans-unit id="d5363f2507afe1548fa90e45167134f02f609105" translate="yes" xml:space="preserve">
          <source>4) The copy constructor is deleted; &lt;code&gt;std::basic_stringbuf&lt;/code&gt; is not &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">4) 복사 생성자가 삭제됩니다. &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible이 아님&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9be1fee9b730c2a07a8d61d19ac72bb73cd09ba" translate="yes" xml:space="preserve">
          <source>4) The copy constructor is deleted; threads are not copyable. No two &lt;code&gt;std::thread&lt;/code&gt; objects may represent the same thread of execution.</source>
          <target state="translated">4) 복사 생성자가 삭제됩니다. 스레드는 복사 할 수 없습니다. 두 개의 &lt;code&gt;std::thread&lt;/code&gt; 객체는 동일한 실행 스레드를 나타낼 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="699f0b55d97164120b6c12698f9cffe89eef2071" translate="yes" xml:space="preserve">
          <source>4) The duration between the time points.</source>
          <target state="translated">4) 시점 사이의 기간.</target>
        </trans-unit>
        <trans-unit id="75366b0e295dfda39b79e9a097e545635823bfc2" translate="yes" xml:space="preserve">
          <source>4) The execution policy type used as a unique type to disambiguate parallel algorithm overloading and indicate that a parallel algorithm's execution may be vectorized, e.g., executed on a single thread using instructions that operate on multiple data items.</source>
          <target state="translated">4) 병렬 알고리즘 오버로딩을 명확하게하기 위해 고유 한 유형으로 사용되는 실행 정책 유형이며 병렬 알고리즘의 실행이 벡터화 될 수 있음을 나타냅니다 (예 : 여러 데이터 항목에서 작동하는 명령을 사용하여 단일 스레드에서 실행될 수 있음).</target>
        </trans-unit>
        <trans-unit id="d331badcddb32c5a926ad8297b236f2e998da737" translate="yes" xml:space="preserve">
          <source>4) The overload 2 is not allowed to be called with a temporary regex, since the returned iterator would be immediately invalidated.</source>
          <target state="translated">4) 반환 된 반복자가 즉시 무효화되므로 과부하 2는 임시 정규식으로 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b58064c8bd1f87e9408abf23f60f09520755aa42" translate="yes" xml:space="preserve">
          <source>4) This overload only participates in overload resolution if T is a specialization of std::pair. Equivalent to</source>
          <target state="translated">4)이 과부하는 T가 std :: pair의 전문화 인 경우에만 과부하 해결에 참여합니다. 에 해당</target>
        </trans-unit>
        <trans-unit id="75dfa022fb2a40f8448848477f491aa5565fcabc" translate="yes" xml:space="preserve">
          <source>4) Throws nothing.</source>
          <target state="translated">4) 아무것도 던지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53d335551ecf573a26fb27824a1add2312c36366" translate="yes" xml:space="preserve">
          <source>4) Top-level cv-qualifiers are dropped from the parameter type (This adjustment only affects the function type, but doesn't modify the property of the parameter: &lt;code&gt;int f(const int p, decltype(p)*);&lt;/code&gt; and &lt;code&gt;int f(int, const int*);&lt;/code&gt; declare the same function)</source>
          <target state="translated">4) 상위 레벨 CV-한정자 (이 조정에만 함수 타입에 영향을 주지만 상기 파라미터의 속성을 변경하지 않는다 : 상기 파라미터 타입에서 제외된다 &lt;code&gt;int f(const int p, decltype(p)*);&lt;/code&gt; 및 &lt;code&gt;int f(int, const int*);&lt;/code&gt; 같은 함수를 선언하십시오)</target>
        </trans-unit>
        <trans-unit id="62b06a46d939d48a1403fe275493bef1ff1964f3" translate="yes" xml:space="preserve">
          <source>4) Transfers the ownership of the object managed by &lt;code&gt;r&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. The deleter associated to &lt;code&gt;r&lt;/code&gt; is stored for future deletion of the managed object. &lt;code&gt;r&lt;/code&gt; manages no object after the call. Equivalent to &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(std::move(r)).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;r&lt;/code&gt; &lt;code&gt;*this&lt;/code&gt; 관리하는 오브젝트의 소유권 을 * this로 전송합니다 . &lt;code&gt;r&lt;/code&gt; 과 연관된 삭제 기는 나중에 관리 대상 객체를 삭제하기 위해 저장됩니다. &lt;code&gt;r&lt;/code&gt; 은 호출 후 오브젝트를 관리하지 않습니다. 당량 &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(std::move(r)).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dca87cccd43bae1bb7e15d95ff111b63fddc6397" translate="yes" xml:space="preserve">
          <source>4) UTF-16 encoded string literal. The type of a &lt;code&gt;u&quot;...&quot;&lt;/code&gt; string literal is &lt;code&gt;const char16_t[N]&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the size of the string in UTF-16 code units including the null terminator.</source>
          <target state="translated">4) UTF-16 인코딩 문자열 리터럴. &lt;code&gt;u&quot;...&quot;&lt;/code&gt; 문자열 리터럴 의 유형 은 &lt;code&gt;const char16_t[N]&lt;/code&gt; 이며 여기서 &lt;code&gt;N&lt;/code&gt; 은 널 종료 자를 포함하여 UTF-16 코드 단위의 문자열 크기입니다.</target>
        </trans-unit>
        <trans-unit id="d29b31b11010807fd8d9ef7ecca4ed6c89ab60f3" translate="yes" xml:space="preserve">
          <source>4) UTF-32 character literal, e.g. &lt;code&gt;U'貓'&lt;/code&gt; or &lt;code&gt;U'🍌'&lt;/code&gt;. Such literal has type &lt;code&gt;char32_t&lt;/code&gt; and the value equal to the value and the value equal to ISO 10646 code point value of c-char.</source>
          <target state="translated">4) UTF-32 문자 리터럴 (예 : &lt;code&gt;U'貓'&lt;/code&gt; 또는 &lt;code&gt;U'🍌'&lt;/code&gt; . 이러한 리터럴에는 &lt;code&gt;char32_t&lt;/code&gt; 유형 과 값이 c-char의 ISO 10646 코드 포인트 값과 같은 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="01bac0f6b1383b9daa406663859bcfbb8461614a" translate="yes" xml:space="preserve">
          <source>4) When used in an expression &lt;code&gt;in &amp;gt;&amp;gt; quoted(s, delim, escape)&lt;/code&gt;, where &lt;code&gt;in&lt;/code&gt; is an input stream with &lt;code&gt;char_type&lt;/code&gt; equal to &lt;code&gt;CharT&lt;/code&gt; and &lt;code&gt;traits_type&lt;/code&gt; equal to &lt;code&gt;Traits&lt;/code&gt;, extracts characters from &lt;code&gt;in&lt;/code&gt;, using &lt;code&gt;&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;std::basic_istream::operator&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, according to the following rules:</source>
          <target state="translated">4) 식에 사용하는 경우 &lt;code&gt;in &amp;gt;&amp;gt; quoted(s, delim, escape)&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; 갖는 입력 스트림 &lt;code&gt;char_type&lt;/code&gt; 이 동일 &lt;code&gt;CharT&lt;/code&gt; 와 &lt;code&gt;traits_type&lt;/code&gt; 가 동일한 &lt;code&gt;Traits&lt;/code&gt; 으로부터 추출 된 문자 &lt;code&gt;in&lt;/code&gt; 사용하는 &lt;code&gt;&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;std::basic_istream::operator&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 다음 규칙에 따라</target>
        </trans-unit>
        <trans-unit id="a496b8a5d69a6a8418134d3db64bd5d9bc2a584d" translate="yes" xml:space="preserve">
          <source>4) Wraps a const member function with a single parameter.</source>
          <target state="translated">4) const 멤버 함수를 단일 매개 변수로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="593309bf80831e7ea5504a7869d2faa0e468ebe8" translate="yes" xml:space="preserve">
          <source>4) Writes the results to a character string &lt;code&gt;buffer&lt;/code&gt;. At most &lt;code&gt;buf_size-1&lt;/code&gt; characters are written. The resulting character string will be terminated with a null character, unless &lt;code&gt;buf_size&lt;/code&gt; is zero. If &lt;code&gt;buf_size&lt;/code&gt; is zero, nothing is written and &lt;code&gt;buffer&lt;/code&gt; may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.</source>
          <target state="translated">4) 결과를 문자열 &lt;code&gt;buffer&lt;/code&gt; 합니다. 최대 &lt;code&gt;buf_size-1&lt;/code&gt; 문자가 작성됩니다. &lt;code&gt;buf_size&lt;/code&gt; 가 0이 아니면 결과 문자열은 널 문자로 종료 됩니다. 경우 &lt;code&gt;buf_size&lt;/code&gt; 제로, 아무것도 기록되지 않고 &lt;code&gt;buffer&lt;/code&gt; 널 포인터, 그러나 반환 값 아직 계산 반환 (널 종료를 포함하지 않는 기록 될 것입니다 바이트 수) 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="e3c23a2e84b8ffaa413c061c2d1caed0bec5d66c" translate="yes" xml:space="preserve">
          <source>4) Writes the results to a character string &lt;code&gt;buffer&lt;/code&gt;. At most &lt;code&gt;buf_size&lt;/code&gt; - 1 characters are written. The resulting character string will be terminated with a null character, unless &lt;code&gt;buf_size&lt;/code&gt; is zero. If &lt;code&gt;buf_size&lt;/code&gt; is zero, nothing is written and &lt;code&gt;buffer&lt;/code&gt; may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.</source>
          <target state="translated">4) 결과를 문자열 &lt;code&gt;buffer&lt;/code&gt; 합니다. 최대 &lt;code&gt;buf_size&lt;/code&gt; -1자가 기록됩니다. &lt;code&gt;buf_size&lt;/code&gt; 가 0이 아니면 결과 문자열은 널 문자로 종료 됩니다. 경우 &lt;code&gt;buf_size&lt;/code&gt; 제로, 아무것도 기록되지 않고 &lt;code&gt;buffer&lt;/code&gt; 널 포인터, 그러나 반환 값 아직 계산 반환 (널 종료를 포함하지 않는 기록 될 것입니다 바이트 수) 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="ac629363af11bec9e4e8e637f3d2d0b7db67546f" translate="yes" xml:space="preserve">
          <source>4) a function registered with &lt;code&gt;&lt;a href=&quot;../utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; throws an exception</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;../utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; 등록 된 함수 에서 예외가 발생 함</target>
        </trans-unit>
        <trans-unit id="2a505576b3df887c3b28488076494e0922393d2e" translate="yes" xml:space="preserve">
          <source>4) arrays of one of the above</source>
          <target state="translated">4) 위 중 하나의 배열</target>
        </trans-unit>
        <trans-unit id="966a4314f4a60171721deb9da4f67228ca44ee46" translate="yes" xml:space="preserve">
          <source>4) as a user-defined operator argument</source>
          <target state="translated">4) 사용자 정의 연산자 인수로</target>
        </trans-unit>
        <trans-unit id="da029eefe29fd05bee4648d8f5eabe726faacfce" translate="yes" xml:space="preserve">
          <source>4) attribute with both a namespace and an argument list</source>
          <target state="translated">4) 네임 스페이스와 인수 목록이 모두있는 속성</target>
        </trans-unit>
        <trans-unit id="9c0cee11e6fe96e28f4630b025e5874647fbb32d" translate="yes" xml:space="preserve">
          <source>4) binary left fold</source>
          <target state="translated">4) 이진 왼쪽 폴드</target>
        </trans-unit>
        <trans-unit id="e8a471c794cf3ac2f6db73e86d13e5c4b53b8ca0" translate="yes" xml:space="preserve">
          <source>4) bitwise XOR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31a7533da07255b923f8a39d926881c5140c95a" translate="yes" xml:space="preserve">
          <source>4) callbacks: arbitrary number of user-defined functions to be called from imbue(), copyfmt(), and ~ios_base()</source>
          <target state="translated">4) 콜백 : imbue (), copyfmt () 및 ~ ios_base ()에서 호출 할 임의의 수의 사용자 정의 함수</target>
        </trans-unit>
        <trans-unit id="4ee87ea8154f0e91f271d4d839f86f3de124f7ac" translate="yes" xml:space="preserve">
          <source>4) characters in the range &lt;code&gt;[cstr, cstr + count2)&lt;/code&gt;;</source>
          <target state="translated">4) &lt;code&gt;[cstr, cstr + count2)&lt;/code&gt; 범위의 문자 ;</target>
        </trans-unit>
        <trans-unit id="34cb585496d7ac3226b9166341f8b9e157a8b3be" translate="yes" xml:space="preserve">
          <source>4) constant.</source>
          <target state="translated">4) 상수.</target>
        </trans-unit>
        <trans-unit id="c1f2fdbfca26c226489180f5ce0bdb3878b42fd9" translate="yes" xml:space="preserve">
          <source>4) constant. If &lt;code&gt;alloc&lt;/code&gt; is given and &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt;, then linear.</source>
          <target state="translated">4) 상수. 경우 &lt;code&gt;alloc&lt;/code&gt; 제공되고 &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt; , 다음 선형.</target>
        </trans-unit>
        <trans-unit id="53c7aeac213559da6228b6d1620af6464b7d464b" translate="yes" xml:space="preserve">
          <source>4) control is returned to the host environment. If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt;, an implementation-defined status indicating successful termination is returned. If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt;, an implementation-defined status indicating unsuccessful termination is returned. In other cases implementation-defined status value is returned.</source>
          <target state="translated">4) 제어가 호스트 환경으로 돌아갑니다. 경우 &lt;code&gt;exit_code&lt;/code&gt; 가 있다 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; , 성공적인 종료를 나타내는 구현 정의 상태가 반환됩니다. &lt;code&gt;exit_code&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; 인 경우 , 실패한 종료를 나타내는 구현 정의 상태가 리턴됩니다. 다른 경우 구현 정의 상태 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f2c9d7f1d91d38225efadc2f70392135aa2823c1" translate="yes" xml:space="preserve">
          <source>4) explicitly defaulted function definition, only allowed for &lt;a href=&quot;member_functions#Special_member_functions&quot;&gt;special member functions&lt;/a&gt;</source>
          <target state="translated">4) 명시 적으로 기본 함수 정의, &lt;a href=&quot;member_functions#Special_member_functions&quot;&gt;특수 멤버 함수&lt;/a&gt; 에만 허용</target>
        </trans-unit>
        <trans-unit id="e5e7ee3f47373bf5d2fbef60859a15ff9a2d84d0" translate="yes" xml:space="preserve">
          <source>4) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;member_functions&quot;&gt;non-static member function&lt;/a&gt; including a &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, the result is a special kind of prvalue designating that non-static member function of &lt;code&gt;E1&lt;/code&gt; that can only be used as the left-hand operand of a member function call operator, and for no other purpose;</source>
          <target state="translated">4) &lt;code&gt;E2&lt;/code&gt; 가 &lt;a href=&quot;destructor&quot;&gt;소멸자를&lt;/a&gt; 포함 하는 &lt;a href=&quot;member_functions&quot;&gt;비 정적 멤버 함수&lt;/a&gt; 인 경우 결과는 멤버 함수 호출 연산자의 왼쪽 피연산자로만 사용할 수 있는 &lt;code&gt;E1&lt;/code&gt; 의 비 정적 멤버 함수를 지정하는 특별한 종류의 전치입니다 . 그리고 다른 목적을 위해;</target>
        </trans-unit>
        <trans-unit id="44bed429fe7a2ad5168fb2847cd3fe37534f76c4" translate="yes" xml:space="preserve">
          <source>4) if &lt;code&gt;E2&lt;/code&gt; is a null pointer-to-member value, the behavior is undefined;</source>
          <target state="translated">4) &lt;code&gt;E2&lt;/code&gt; 가 널 포인터 대 멤버 값인 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2388ca811ae5872514e74b7737958a6c99308f1b" translate="yes" xml:space="preserve">
          <source>4) in a non-static &lt;a href=&quot;data_members#Member_initialization&quot;&gt;data member initializer&lt;/a&gt; that does not use the equals sign</source>
          <target state="translated">4) 등호를 사용하지 않는 비 정적 &lt;a href=&quot;data_members#Member_initialization&quot;&gt;데이터 멤버 이니셜 라이저&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="30a3344cbfcc3e4931bcd9a413d30dc7ca45688a" translate="yes" xml:space="preserve">
          <source>4) initialization of a prvalue temporary by a &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; expression</source>
          <target state="translated">4) &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; 표현식에 의한 임시 prvalue 초기화</target>
        </trans-unit>
        <trans-unit id="55ded8b84091f72a929eb97e053c874a8f15e0e3" translate="yes" xml:space="preserve">
          <source>4) inserts elements from range &lt;code&gt;[first, last)&lt;/code&gt; after the element pointed to by &lt;code&gt;pos&lt;/code&gt;. The behavior is undefined if &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; are iterators into &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 뒤에 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소를 삽입합니다 . &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 이 &lt;code&gt;*this&lt;/code&gt; 의 반복자 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9ca88f451752d5ae5afb9a42925f88770ecb7b0a" translate="yes" xml:space="preserve">
          <source>4) inserts elements from range &lt;code&gt;[first, last)&lt;/code&gt; before &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;pos&lt;/code&gt; 앞에 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="391b3c6097b3561de376f62e72c330bd28c05f82" translate="yes" xml:space="preserve">
          <source>4) iteration statements;</source>
          <target state="translated">4) 반복문;</target>
        </trans-unit>
        <trans-unit id="d9a754627238a669c1727385b87a7ee59b4af6b1" translate="yes" xml:space="preserve">
          <source>4) linear in length of &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">길이 4) 선형 &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9520e1ed348a426f6fcada039ce2de94447402ed" translate="yes" xml:space="preserve">
          <source>4) may throw exception.</source>
          <target state="translated">4) 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5544393e86c98860a7119effcfd83009172f0811" translate="yes" xml:space="preserve">
          <source>4) move constructor. Constructs the container with the contents of &lt;code&gt;other&lt;/code&gt; using move semantics. If &lt;code&gt;alloc&lt;/code&gt; is not provided, allocator is obtained by move-construction from the allocator belonging to &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">4) 생성자를 이동하십시오. 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 내용으로 컨테이너를 구성합니다 . 경우 &lt;code&gt;alloc&lt;/code&gt; 제공되지 않고, 할당이 속하는 할당 이동할 시공함으로써 얻어지는 &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d124492acc9d9eadf70543dc9956c2ecd7a7d36" translate="yes" xml:space="preserve">
          <source>4) null pointer value may be converted to the null pointer value of new_type</source>
          <target state="translated">4) 널 포인터 값은 new_type의 널 포인터 값으로 변환 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f7b7976caaf085b1dd9f35fc940c79176a6b2e63" translate="yes" xml:space="preserve">
          <source>4) or, if not that, F1 is a non-template function while F2 is a template specialization</source>
          <target state="translated">4) 그렇지 않은 경우 F1은 템플릿이 아닌 함수이고 F2는 템플릿 특수화입니다.</target>
        </trans-unit>
        <trans-unit id="8397d261f1a39bd808c8d692373a6301911ca724" translate="yes" xml:space="preserve">
          <source>4) otherwise, the object is zero-initialized.</source>
          <target state="translated">4) 그렇지 않으면 객체가 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="c644c11ecd3fe5c9682ee7c66849580ad5d5f8e0" translate="yes" xml:space="preserve">
          <source>4) pointer to user-provided deallocation function.</source>
          <target state="translated">4) 사용자가 제공 한 할당 해제 기능에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="9b44749a6c049c9d2fe6e36e0864e1199072bd11" translate="yes" xml:space="preserve">
          <source>4) returns &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::u32string&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::u32string&lt;/a&gt;{str, len}&lt;/code&gt; {str, len}을 반환합니다</target>
        </trans-unit>
        <trans-unit id="fddaf473b7b562897de0b0a93b478cd1f13a806b" translate="yes" xml:space="preserve">
          <source>4) returns &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::u32string_view&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::u32string_view&lt;/a&gt;{str, len}&lt;/code&gt; {str, len}을 반환합니다</target>
        </trans-unit>
        <trans-unit id="9812a95f7e9fd5f6655167f73e48b6c28d636a29" translate="yes" xml:space="preserve">
          <source>4) returns &lt;code&gt;il.begin()&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;il.begin()&lt;/code&gt; )을 반환</target>
        </trans-unit>
        <trans-unit id="d87d654ae0445905b2c08a889b13d39dbecc739f" translate="yes" xml:space="preserve">
          <source>4) same as (3), except the precision is specified by the parameter &lt;code&gt;precision&lt;/code&gt; rather than by the shortest representation requirement.</source>
          <target state="translated">4) 정밀도가 가장 짧은 표현 요구 사항이 아닌 매개 변수 &lt;code&gt;precision&lt;/code&gt; 지정된다는 점을 제외하고는 (3)과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e29d8e584e25e1d13bc86b52f4878ab1e44236c3" translate="yes" xml:space="preserve">
          <source>4) simple by-reference capture</source>
          <target state="translated">4) 간단한 비 참조 캡처</target>
        </trans-unit>
        <trans-unit id="b262468ffc57095b829bd77e32b41e5b53f6ca64" translate="yes" xml:space="preserve">
          <source>4) the integral number of fractional seconds &lt;code&gt;since_midnight&lt;/code&gt; is after &lt;code&gt;(00:00:00 + hours() + minutes() + seconds())&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;since_midnight&lt;/code&gt; 의 정수 초의 정수 는 &lt;code&gt;(00:00:00 + hours() + minutes() + seconds())&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="66626242cb3d2300f9485009be6804ae97ae236e" translate="yes" xml:space="preserve">
          <source>4) when &lt;a href=&quot;return&quot;&gt;returning&lt;/a&gt; from a function that returns by value</source>
          <target state="translated">4) 값으로 반환되는 함수에서 &lt;a href=&quot;return&quot;&gt;돌아올&lt;/a&gt; 때</target>
        </trans-unit>
        <trans-unit id="50c1a19b9d2b7fe57d26a830b38ef4979895b50b" translate="yes" xml:space="preserve">
          <source>4) when a &lt;a href=&quot;friend#Template_friends&quot;&gt;friend function declaration&lt;/a&gt;, an &lt;a href=&quot;function_template#Explicit_instantiation&quot;&gt;explicit instantiation&lt;/a&gt;, or an &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt; refers to a function template specialization</source>
          <target state="translated">4) &lt;a href=&quot;friend#Template_friends&quot;&gt;친구 함수 선언&lt;/a&gt; , &lt;a href=&quot;function_template#Explicit_instantiation&quot;&gt;명시 적 인스턴스화&lt;/a&gt; 또는 &lt;a href=&quot;template_specialization&quot;&gt;명시 적 특수화&lt;/a&gt; 가 함수 템플리트 전문화를 참조하는 경우</target>
        </trans-unit>
        <trans-unit id="f9f67ed170967858cb99ae524bd687894f6c6b4b" translate="yes" xml:space="preserve">
          <source>4) when a named variable (automatic, static, or thread-local) is declared with the initializer consisting of a pair of braces.</source>
          <target state="translated">4) 명명 된 변수 (자동, 정적 또는 스레드 로컬)가 한 쌍의 중괄호로 구성된 이니셜 라이저로 선언 된 경우.</target>
        </trans-unit>
        <trans-unit id="57cd5eeb211c43f199e27b74d9b5b7c12ab8022b" translate="yes" xml:space="preserve">
          <source>4) zero or one</source>
          <target state="translated">4) 0 또는 1</target>
        </trans-unit>
        <trans-unit id="22f45fe451b4982e76165f9a9423c8463294c8ba" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;../../language/move_constructor&quot;&gt;Move constructor&lt;/a&gt;. Constructs the container with the contents of &lt;code&gt;other&lt;/code&gt; using move semantics. If &lt;code&gt;alloc&lt;/code&gt; is not provided, allocator is obtained by move-construction from the allocator belonging to &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">4) &lt;a href=&quot;../../language/move_constructor&quot;&gt;생성자 이동&lt;/a&gt; . 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 내용으로 컨테이너를 구성합니다 . 경우 &lt;code&gt;alloc&lt;/code&gt; 제공되지 않고, 할당이 속하는 할당 이동할 시공함으로써 얻어지는 &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8db1823d901e2e473474c5fa3b717d4c57d7fc9" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt;;</source>
          <target state="translated">4) &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;할당 해제 기능&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="e2bb526cb62dc5a605e54a3bedfc2fa50433169d" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;derived_class#Public_inheritance&quot;&gt;Public inheritance&lt;/a&gt;: the public and protected members of the &lt;a href=&quot;derived_class&quot;&gt;base class&lt;/a&gt; listed after the specifier keep their member access in the derived class</source>
          <target state="translated">4) &lt;a href=&quot;derived_class#Public_inheritance&quot;&gt;공개 상속&lt;/a&gt; : 지정자 뒤에 나열된 &lt;a href=&quot;derived_class&quot;&gt;기본 클래스&lt;/a&gt; 의 공개 및 보호 멤버 는 파생 클래스에서 멤버 액세스를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="87b099a285be9277dc323fc192f89bbd17cfb36f" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;enum&quot;&gt;enumerators&lt;/a&gt; from all unscoped enumerations defined within the class</source>
          <target state="translated">4) &lt;a href=&quot;enum&quot;&gt;열거&lt;/a&gt; 클래스 내에서 정의 된 모든 범위가 지정되지 않은 열거에서</target>
        </trans-unit>
        <trans-unit id="4dec1f46f3b1592418fe8e5e9c6bc41ec12ee02a" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;lambda&quot;&gt;Lambda-expressions&lt;/a&gt;(C++11)</source>
          <target state="translated">4)&lt;a href=&quot;lambda&quot;&gt;Lambda-expressions&lt;/a&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="e980f5d11603cfa609fbe8e591199e8f63b7d3a3" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;pointer&quot;&gt;Pointer declarator&lt;/a&gt;: the declaration &lt;code&gt;S * D;&lt;/code&gt; declares &lt;code&gt;D&lt;/code&gt; as a pointer to the type determined by decl-specifier-seq&lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">4) &lt;a href=&quot;pointer&quot;&gt;포인터 선언자&lt;/a&gt; : 선언 &lt;code&gt;S * D;&lt;/code&gt; decl-specifier-seq &lt;code&gt;S&lt;/code&gt; 에 의해 결정된 유형에 대한 포인터로 &lt;code&gt;D&lt;/code&gt; 를 선언 합니다 .</target>
        </trans-unit>
        <trans-unit id="207fd7fddd4ab6b9e82f8a3e84ac3f718d537bd0" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;range-for&quot;&gt;range for&lt;/a&gt; loop.</source>
          <target state="translated">4) 루프 &lt;a href=&quot;range-for&quot;&gt;범위&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06c8b727b963479926cefb23e8bd3656f380bacf" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; statement using &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt;;</source>
          <target state="translated">4) &lt;a href=&quot;list_initialization&quot;&gt;리스트 초기화를&lt;/a&gt; 사용하여 &lt;a href=&quot;return&quot;&gt;리턴&lt;/a&gt; 문 ;</target>
        </trans-unit>
        <trans-unit id="0b70a62b37287bd97e460c4514c5d122492b530b" translate="yes" xml:space="preserve">
          <source>4)&lt;a href=&quot;using_declaration&quot;&gt;Using-declarations&lt;/a&gt;</source>
          <target state="translated">4)&lt;a href=&quot;using_declaration&quot;&gt;Using-declarations&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d83442a167ae57ffb46d018a206bea92b1d2f7ce" translate="yes" xml:space="preserve">
          <source>4)&lt;b&gt;Write-read coherence&lt;/b&gt;: if a side effect (a write) X on an atomic object M</source>
          <target state="translated">4) &lt;b&gt;쓰기-읽기 일관성&lt;/b&gt; : 원자 객체 M에 대한 부작용 (쓰기) X</target>
        </trans-unit>
        <trans-unit id="de5e8c1c5f30412235cd1a88a98a78bd274c9ffe" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt; if any character is not one or zero</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt; 문자가 하나 또는 0이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="75e37b57fed10abdc0d203004cf3533fca955488" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(int(unsigned(x)) - int(unsigned(y)))&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(int(unsigned(x)) - int(unsigned(y)))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e92d024be42fc33ca705eac3e73cb7fbebfcecc" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(int(y1) - int(y2))&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(int(y1) - int(y2))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a6de6b66f93ccb3c66751d42d7db789af860d73" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;&lt;a href=&quot;../weekday_last&quot;&gt;std::chrono::weekday_last&lt;/a&gt;(weekday())&lt;/code&gt;.</source>
          <target state="translated">4)&lt;code&gt;&lt;a href=&quot;../weekday_last&quot;&gt;std::chrono::weekday_last&lt;/a&gt;(weekday())&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="819b44abcb47124a915eb6cb4f897b712cb86e7d" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;&lt;a href=&quot;month_day&quot;&gt;std::chrono::month_day&lt;/a&gt;(m, &lt;a href=&quot;day&quot;&gt;std::chrono::day&lt;/a&gt;(d))&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;month_day&quot;&gt;std::chrono::month_day&lt;/a&gt;(m, &lt;a href=&quot;day&quot;&gt;std::chrono::day&lt;/a&gt;(d))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4a9028a8c12a20002896c04d00f923c04e80548" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;const T&amp;gt;(t)&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;const T&amp;gt;(t)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8114a2eb62a7072aa1aad652a0ec4c5ef03afaa" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;&lt;a href=&quot;utc_clock/to_sys&quot;&gt;std::chrono::utc_clock::to_sys&lt;/a&gt;(t)&lt;/code&gt;.</source>
          <target state="translated">4)&lt;code&gt;&lt;a href=&quot;utc_clock/to_sys&quot;&gt;std::chrono::utc_clock::to_sys&lt;/a&gt;(t)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="0a7243c24ec160d6ca7886b4859db1a96f7f2c01" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;bitset&amp;lt;N&amp;gt;(*this).flip()&lt;/code&gt;</source>
          <target state="translated">4)&lt;code&gt;bitset&amp;lt;N&amp;gt;(*this).flip()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e89827531c72a2c15061539bdfccd8d023ab0d9" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;cmp &amp;lt;= 0&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;cmp &amp;lt;= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c27f111d093cc3359df2f809cb88d8cd55b07b1" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;from_stream(is, fmt.c_str(), tp, &lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(abbrev), &amp;amp;offset)&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;from_stream(is, fmt.c_str(), tp, &lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(abbrev), &amp;amp;offset)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1159f7ae635b6776a6b2770eed9e18284bfae5aa" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;int(x) &amp;lt;= int(y)&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;int(x) &amp;lt;= int(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="246967dad43219ae08899a8093aa876995d14fa1" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;lhs.base() &amp;gt;= rhs.base()&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;lhs.base() &amp;gt;= rhs.base()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95bfb0364cef230a6a7ab864e3c5c1ad89619554" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;lhs.base() &amp;lt;= rhs.base()&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;lhs.base() &amp;lt;= rhs.base()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcda12c0c3917d3a545d7e3fd7ab6330ea2762f0" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;obj-&amp;gt;compare_exchange_strong(*expected, desired, succ, fail)&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;obj-&amp;gt;compare_exchange_strong(*expected, desired, succ, fail)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7aa9632eec3838ac16cf38c7fccc1672db50bc8b" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;promise&lt;/code&gt; is not copyable.</source>
          <target state="translated">4) &lt;code&gt;promise&lt;/code&gt; 은 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="daa686422ec58af8aa35cc13dec1cf91efde63a2" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;rhs &amp;lt; lhs&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;rhs &amp;lt; lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2254effc55e222db1a7f66a0844397dcc4df0ae" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;std::chrono::get_tzdb_list().front()&lt;/code&gt; (after any update made by this function).</source>
          <target state="translated">4) &lt;code&gt;std::chrono::get_tzdb_list().front()&lt;/code&gt; (이 함수로 업데이트 한 후)</target>
        </trans-unit>
        <trans-unit id="9707b6c463038fe734640705d09a37bc7ee6f8e3" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;path() &amp;lt;= rhs.path()&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">4) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;path() &amp;lt;= rhs.path()&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="0af0dee1b64c13740dca46a47fb183b232f1efc4" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;true&lt;/code&gt; if either &lt;code&gt;code.category().equivalent(code.value(), cond)&lt;/code&gt; or &lt;code&gt;cond.category().equivalent(code, cond.value())&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;true&lt;/code&gt; 하는 경우 어느 &lt;code&gt;code.category().equivalent(code.value(), cond)&lt;/code&gt; 또는 &lt;code&gt;cond.category().equivalent(code, cond.value())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1a08a129a36b0ddcfc4946390fa4ea04c4ea4c6" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;lhs&lt;/code&gt; refers to time point</source>
          <target state="translated">4) &lt;code&gt;lhs&lt;/code&gt; 가 시점을 참조 하면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad278c3ca3fe0e1c846cb486e29705e05dc87b83" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;true&lt;/code&gt; if the contents of the &lt;code&gt;lhs&lt;/code&gt; are lexicographically</source>
          <target state="translated">4) &lt;code&gt;lhs&lt;/code&gt; 의 내용 이 사전 식 으로되어 있으면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39f123895fdc0aad4e76a964b749b1ff218abdda" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;unsigned(x) &amp;lt;= unsigned(y)&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;unsigned(x) &amp;lt;= unsigned(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0724fe6a0771258743e81e22f7d2567ce389e414" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;x.date() &amp;gt; y.date()&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;x.date() &amp;gt; y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b33a7aa947bc495a4ac0dbed65318a26982cd565" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;x.month() &amp;gt; y.month()&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;x.month() &amp;gt; y.month()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbff1c4f2067dcc574f2a995d98853783135b859" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;x.name() &amp;gt; y.name()&lt;/code&gt;.</source>
          <target state="translated">4) &lt;code&gt;x.name() &amp;gt; y.name()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="221b5809ac55dd09cc48e4e7918fc8014e4e430b" translate="yes" xml:space="preserve">
          <source>4)&lt;code&gt;y &amp;lt; x&lt;/code&gt;</source>
          <target state="translated">4) &lt;code&gt;y &amp;lt; x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="708788dc265000bbfa0a6dcf200818b414052ac0" translate="yes" xml:space="preserve">
          <source>4,5) (none)</source>
          <target state="translated">4,5) (없음)</target>
        </trans-unit>
        <trans-unit id="d1fd1070151acf4a640c52e00fdf7fae74ab0198" translate="yes" xml:space="preserve">
          <source>4,5) Equivalent to &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(std::move(r)).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">4,5) &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(std::move(r)).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="405f6e8a4037f10a4a60a3ec3bfac298f868419f" translate="yes" xml:space="preserve">
          <source>4,5) Same as (2,3), but every element is initialized from the default value &lt;code&gt;u&lt;/code&gt;. If &lt;code&gt;U&lt;/code&gt; is not an array type, then this is performed as if by the same placement-new expression as in (1); otherwise, this is performed as if by initializing every non-array element of the (possibly multidimensional) array with the corresponding element from &lt;code&gt;u&lt;/code&gt; with the same placement-new expression as in (1). The overload (4) creates an array of size &lt;code&gt;N&lt;/code&gt; along the first dimension. The array elements are initialized in ascending order of their addresses, and when their lifetime ends are destroyed in the reverse order of their original construction.</source>
          <target state="translated">4,5) (2,3)과 동일하지만 모든 요소는 기본값 &lt;code&gt;u&lt;/code&gt; 에서 초기화됩니다 . 경우 &lt;code&gt;U&lt;/code&gt; 가 배열 형 있지 않은 경우, 이것과 같은 새로운 배치 식으로 행하는 경우로 (1); 그렇지 않으면, 이것은 (1)에서와 동일한 배치-새로운 표현을 갖는 &lt;code&gt;u&lt;/code&gt; 로부터 대응하는 요소로 (다차원 일 수도 있음) 어레이의 모든 비 배열 요소를 초기화함으로써 수행된다 . 과부하 (4) 는 첫 번째 차원을 따라 크기 &lt;code&gt;N&lt;/code&gt; 의 배열을 만듭니다 . 배열 요소는 주소의 오름차순으로 초기화되고 수명이 끝날 때 원래 구성의 역순으로 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="a73e0e8ac9a8f56468d0dbaca5feedb1aa437989" translate="yes" xml:space="preserve">
          <source>4,5) Same as (2,3), but the elements of the array are initialized from the default value &lt;code&gt;u&lt;/code&gt;. If &lt;code&gt;&lt;a href=&quot;../../types/remove_extent&quot;&gt;std::remove_extent_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is not itself an array type, then this is performed as if by the same allocator expression as in (1), except that the allocator is rebound to the &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. Otherwise, this is performed as if by initializing every non-array element of the (possibly multidimensional) array with the corresponding element from &lt;code&gt;u&lt;/code&gt; using the same allocator expression as in (1), except that the allocator is rebound to the type &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. The overload (4) creates an array of size &lt;code&gt;N&lt;/code&gt; along the first dimension. The array elements are initialized in ascending order of their addresses, and when their lifetime ends are destroyed in the reverse order of their original construction.</source>
          <target state="translated">4,5) (2,3)과 동일하지만 배열의 요소는 기본값 &lt;code&gt;u&lt;/code&gt; 에서 초기화됩니다 . 경우 &lt;code&gt;&lt;a href=&quot;../../types/remove_extent&quot;&gt;std::remove_extent_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; IS 그 자체 배열 형, 다음이 수행된다 (1)과 동일한 할당 식에서 것처럼, 할당이 리바운드되는 것을 제외 &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; . 그렇지 않으면 할당자가 &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 유형에 리바운드되는 것을 제외하고는 (1)과 동일한 할당 자 표현식을 사용하여 &lt;code&gt;u&lt;/code&gt; 에서 해당하는 요소로 (다차원) 배열의 모든 비 배열 요소를 초기화하는 것처럼 수행됩니다. remove_cv_t &amp;lt; &lt;a href=&quot;../../types/remove_all_extents&quot;&gt;std :: remove_all_extents_t&lt;/a&gt; &amp;lt;T &amp;gt;&amp;gt;. 과부하 (4) 는 첫 번째 차원을 따라 크기 &lt;code&gt;N&lt;/code&gt; 의 배열을 만듭니다 . 배열 요소는 주소의 오름차순으로 초기화되고 수명이 끝날 때 원래 구성의 역순으로 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="53ff29f25dea1089f357d169e8721c563171a54b" translate="yes" xml:space="preserve">
          <source>4,6)&lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; if the operating system has no locale named &lt;code&gt;std_name&lt;/code&gt;.</source>
          <target state="translated">4,6)는 &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; 운영 체제 로케일 이름이없는 경우 &lt;code&gt;std_name&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="470517a8e36c0dbbb2fd4368acd6ba8beefc79f3" translate="yes" xml:space="preserve">
          <source>4,6,8,10) The corresponding data structure containing references to the selected items</source>
          <target state="translated">4,6,8,10) 선택한 항목에 대한 참조를 포함하는 해당 데이터 구조</target>
        </trans-unit>
        <trans-unit id="bda84f525f099250859f45f346563f1b582ea1c4" translate="yes" xml:space="preserve">
          <source>4,8) A set of overloads or a function template accepting an argument of any &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;. Equivalent to (2) or (6) (the argument is cast to &lt;code&gt;double&lt;/code&gt;).</source>
          <target state="translated">4,8) &lt;a href=&quot;../../types/is_integral&quot;&gt;일체형&lt;/a&gt; 의 인수를 받아들이는 과부하 또는 함수 템플릿 집합 . (2) 또는 (6)에 해당합니다 (인수가 &lt;code&gt;double&lt;/code&gt; 로 캐스트 됨 ).</target>
        </trans-unit>
        <trans-unit id="a0cddb2b29db6a784ec04f8ec788a88637f62081" translate="yes" xml:space="preserve">
          <source>4,8) Divides &lt;code&gt;*this&lt;/code&gt; by &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">4,8) &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;other&lt;/code&gt; 것으로 나눕니다 .</target>
        </trans-unit>
        <trans-unit id="f1dfb5350078c05c16eeab73395953c4457b8f30" translate="yes" xml:space="preserve">
          <source>4,8,12) A set of overloads or a function template accepting an argument of any &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;. Equivalent to (2,6,10), respectively (the argument is cast to &lt;code&gt;double&lt;/code&gt;).</source>
          <target state="translated">4,8,12) &lt;a href=&quot;../../types/is_integral&quot;&gt;일체형&lt;/a&gt; 의 인수를 받아들이는 과부하 또는 함수 템플릿 세트 . 각각 (2,6,10)과 동일합니다 (인수가 &lt;code&gt;double&lt;/code&gt; 로 캐스트 됨 ).</target>
        </trans-unit>
        <trans-unit id="bf48400b8ffd44b806898ad67603e030e80369d3" translate="yes" xml:space="preserve">
          <source>4,8,12) A set of overloads or a function template accepting an argument of any &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;. Equivalent to 2), 6), or 10), respectively (the argument is cast to &lt;code&gt;double&lt;/code&gt;).</source>
          <target state="translated">4,8,12) &lt;a href=&quot;../../types/is_integral&quot;&gt;일체형&lt;/a&gt; 의 인수를 받아들이는 과부하 또는 함수 템플릿 세트 . 2), 6) 또는 10)에 각각 해당합니다 (인수가 &lt;code&gt;double&lt;/code&gt; 로 캐스트 됨 ).</target>
        </trans-unit>
        <trans-unit id="c9c142572d05a21c98eab06c0dde5234447dc7bc" translate="yes" xml:space="preserve">
          <source>4-5) (none)</source>
          <target state="translated">4-5) (없음)</target>
        </trans-unit>
        <trans-unit id="e3988dfd2665f144bf6fd30fbda588f769dc189e" translate="yes" xml:space="preserve">
          <source>4-5) Conversions between &lt;code&gt;std::chrono::sys_time&lt;/code&gt; and &lt;code&gt;std::chrono::utc_time&lt;/code&gt;: &lt;code&gt;operator()&lt;/code&gt; calls &lt;code&gt;std::chrono::utc_clock::to_sys&lt;/code&gt; and &lt;code&gt;std::chrono::utc_clock::from_sys&lt;/code&gt;, respectively.</source>
          <target state="translated">4-5 사이) 전환 &lt;code&gt;std::chrono::sys_time&lt;/code&gt; 및 &lt;code&gt;std::chrono::utc_time&lt;/code&gt; : &lt;code&gt;operator()&lt;/code&gt; 호출 &lt;code&gt;std::chrono::utc_clock::to_sys&lt;/code&gt; 및 &lt;code&gt;std::chrono::utc_clock::from_sys&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="ad5468f5b17dea4d60c60e3c74f0501a1e5782b1" translate="yes" xml:space="preserve">
          <source>4-5) If &lt;code&gt;operand&lt;/code&gt; is not a null pointer, and the &lt;code&gt;typeid&lt;/code&gt; of the requested &lt;code&gt;T&lt;/code&gt; matches that of the contents of &lt;code&gt;operand&lt;/code&gt;, a pointer to the value contained by operand, otherwise a null pointer.</source>
          <target state="translated">4-5) &lt;code&gt;operand&lt;/code&gt; 가 null 포인터가 아니고 요청 된 &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;typeid&lt;/code&gt; 가 &lt;code&gt;operand&lt;/code&gt; 의 내용과 일치하면 operand 에 포함 된 값에 대한 포인터이고, 그렇지 않으면 null 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="1b150669fcbe679bf472923d5ba5ae79c6cb4f79" translate="yes" xml:space="preserve">
          <source>4-5) Same as &lt;code&gt;basic_fstream(filename.c_str(), mode)&lt;/code&gt;.</source>
          <target state="translated">4-5) &lt;code&gt;basic_fstream(filename.c_str(), mode)&lt;/code&gt; )와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="efaf0c21ea449973ff95e3367b04f9ded2e59028" translate="yes" xml:space="preserve">
          <source>4-5) Same as &lt;code&gt;basic_ifstream(filename.c_str(), mode)&lt;/code&gt;.</source>
          <target state="translated">4-5) &lt;code&gt;basic_ifstream(filename.c_str(), mode)&lt;/code&gt; )와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="6af620bbd9ac7177f0aa7bef16791103f658e42b" translate="yes" xml:space="preserve">
          <source>4-5) Same as &lt;code&gt;basic_ofstream(filename.c_str(), mode)&lt;/code&gt;. Note that despite the default mode being &lt;code&gt;out&lt;/code&gt;, the effects are identical to the effects of &lt;code&gt;out|trunc&lt;/code&gt; as described in &lt;a href=&quot;../basic_filebuf/open&quot;&gt;&lt;code&gt;std::filebuf::open&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">4-5) &lt;code&gt;basic_ofstream(filename.c_str(), mode)&lt;/code&gt; )와 동일 합니다 . 기본 모드가 &lt;code&gt;out&lt;/code&gt; 에도 불구하고 &lt;a href=&quot;../basic_filebuf/open&quot;&gt; &lt;code&gt;std::filebuf::open&lt;/code&gt; &lt;/a&gt; 설명 된대로 &lt;code&gt;out|trunc&lt;/code&gt; 의 효과와 효과가 같습니다.</target>
        </trans-unit>
        <trans-unit id="86f11cce79fef2567d66c846631ad0b9fe2f370d" translate="yes" xml:space="preserve">
          <source>4-5) Uses the specified deleter &lt;code&gt;d&lt;/code&gt; as the deleter. The expression &lt;code&gt;d(ptr)&lt;/code&gt; must be well formed, have well-defined behavior and not throw any exceptions. The construction of &lt;code&gt;d&lt;/code&gt; and of the stored deleter from &lt;code&gt;d&lt;/code&gt; must not throw exceptions.</source>
          <target state="translated">4-5) 지정된 삭제 기 &lt;code&gt;d&lt;/code&gt; 를 삭제 기로 사용합니다 . &lt;code&gt;d(ptr)&lt;/code&gt; 표현식 은 올바르게 구성되어야하고 올바르게 정의 된 동작을 가지며 예외를 발생시키지 않아야합니다. 의 구조 &lt;code&gt;d&lt;/code&gt; 에서 저장된 Deleter가와의 &lt;code&gt;d&lt;/code&gt; 예외를 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="290143fb26b32fb3ad0010351ef5a5cb023a9fba" translate="yes" xml:space="preserve">
          <source>4-6) Additional overloads are provided for all arithmetic types, such that</source>
          <target state="translated">4-6) 모든 산술 유형에 대해 추가 과부하가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3cbf43429f9ecc8f3c22f3e8230decd2ae5fde33" translate="yes" xml:space="preserve">
          <source>4-6) Amortized constant if the insertion happens in the position just</source>
          <target state="translated">4-6) 삽입이 바로 그 위치에서 발생하면 상각 상수</target>
        </trans-unit>
        <trans-unit id="5f7e1f315d5e050f096bc1212170139ab22b5147" translate="yes" xml:space="preserve">
          <source>4-6) Compares &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; for inequality.</source>
          <target state="translated">4-6) 불평등에 대한 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 를 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="f24cc766dca250e26a128a7f98dffc67c909997a" translate="yes" xml:space="preserve">
          <source>4-6) Constructs a iterator that refers to the first entry in the directory that &lt;code&gt;p&lt;/code&gt; resolves to.</source>
          <target state="translated">4-6) &lt;code&gt;p&lt;/code&gt; 가 해결 하는 디렉토리의 첫 번째 항목을 참조하는 반복자를 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="3094fca4961c412b69d7de2a04df17a36de1a146" translate="yes" xml:space="preserve">
          <source>4-6) Constructs a span that is a view over the array &lt;code&gt;arr&lt;/code&gt;; the resulting span has &lt;code&gt;size() == N&lt;/code&gt; and &lt;code&gt;data() == &lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(arr)&lt;/code&gt;. These overloads only participate in overload resolution if &lt;code&gt;extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt; || N == extent&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/remove_pointer&quot;&gt;std::remove_pointer_t&lt;/a&gt;&amp;lt;decltype(&lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(arr))&amp;gt;(*)[]&lt;/code&gt; is convertible to &lt;code&gt;element_type (*)[]&lt;/code&gt;</source>
          <target state="translated">4-6) 배열 &lt;code&gt;arr&lt;/code&gt; 에 대한 뷰인 스팬을 구성합니다 . 결과 범위는 &lt;code&gt;size() == N&lt;/code&gt; 및 &lt;code&gt;data() == &lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(arr)&lt;/code&gt; 입니다. 이러한 과부하는 &lt;code&gt;extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt; || N == extent&lt;/code&gt; 경우 과부하 해결에만 참여합니다. N == Extent 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/remove_pointer&quot;&gt;std::remove_pointer_t&lt;/a&gt;&amp;lt;decltype(&lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(arr))&amp;gt;(*)[]&lt;/code&gt; 는 &lt;code&gt;element_type (*)[]&lt;/code&gt; 으로 변환 가능</target>
        </trans-unit>
        <trans-unit id="6416a501674e1ecbbdd2b08852b59c740bc90161" translate="yes" xml:space="preserve">
          <source>4-6) Constructs the path from a character sequence (format interpreted as specified by &lt;code&gt;fmt&lt;/code&gt;) provided by &lt;code&gt;source&lt;/code&gt;(4,5), which is a pointer or an input iterator to a null-terminated character/wide character sequence, an &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;, or represented as a pair of input iterators [&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;) (6). Any of the character types &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, (since C++20)&lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt; is allowed, and the method of conversion to the native character set depends on the character type used by &lt;code&gt;source&lt;/code&gt;</source>
          <target state="translated">4-6) &lt;code&gt;source&lt;/code&gt; (4,5)가 제공 하는 문자 시퀀스 ( &lt;code&gt;fmt&lt;/code&gt; 로 지정된 형식으로 )에서 널 종료 문자 / 와이드 문자 시퀀스에 대한 포인터 또는 입력 반복자 인 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 또는 입력 반복기 쌍으로 표시됩니다 ( &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;last&lt;/code&gt; ) (6). 문자 유형 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; , (C ++ 20부터) &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; 가 허용되며 기본 문자 세트로 변환하는 방법은 &lt;code&gt;source&lt;/code&gt; 사용하는 문자 유형에 따라 다릅니다</target>
        </trans-unit>
        <trans-unit id="ae86a6cebfdd268aedc7feab76d9a0cc118a99a6" translate="yes" xml:space="preserve">
          <source>4-6) Equivalent to (1-3), just omits the match results.</source>
          <target state="translated">4-6) (1-3)과 동일하며 일치 결과 만 생략합니다.</target>
        </trans-unit>
        <trans-unit id="f530e97ac26948617e4979c225e37597855c6da9" translate="yes" xml:space="preserve">
          <source>4-6) Inserts &lt;code&gt;value&lt;/code&gt; in the position as close as possible, just prior(since C++11), to &lt;code&gt;hint&lt;/code&gt;. The overload (5) is equivalent to &lt;code&gt;emplace_hint(hint, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; and only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">4-6) C ++ 11 이후로 가능한 한 가까운 위치에 &lt;code&gt;value&lt;/code&gt; 을 삽입 하여 &lt;code&gt;hint&lt;/code&gt; 줍니다. 과부하 (5)는 &lt;code&gt;emplace_hint(hint, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt; 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="3f07e2193eb73aafa03c92c615b8ed6c91468a5b" translate="yes" xml:space="preserve">
          <source>4-6) Returns an iterator to the inserted element, or to the element that prevented the insertion.</source>
          <target state="translated">4-6) 반복자를 삽입 된 요소 또는 삽입을 방해 한 요소로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0546f4c8361f9c525e0781a6f22cc33241b6ce89" translate="yes" xml:space="preserve">
          <source>4-6) Returns the result of subtracting &lt;code&gt;rhs&lt;/code&gt; from &lt;code&gt;lhs&lt;/code&gt;</source>
          <target state="translated">4-6) &lt;code&gt;lhs&lt;/code&gt; 에서 &lt;code&gt;rhs&lt;/code&gt; 를 뺀 결과를 반환</target>
        </trans-unit>
        <trans-unit id="5cd306e49971fd95e6c47bca719e5c9b804b6ce4" translate="yes" xml:space="preserve">
          <source>4-6) Same as (1-3), but executed according to &lt;code&gt;policy&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true</source>
          <target state="translated">4-6) (1-3)과 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true 인 경우에만 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="27cdcc0a64361b92a196a687c03f1dbeac6ff7d9" translate="yes" xml:space="preserve">
          <source>4-6)&lt;code&gt;!(lhs == rhs)&lt;/code&gt;</source>
          <target state="translated">4-6) &lt;code&gt;!(lhs == rhs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0226b4e9c3d6ba1250adbd49cc4b2c929de7d07" translate="yes" xml:space="preserve">
          <source>4-6)&lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) -= rhs&lt;/code&gt;</source>
          <target state="translated">4-6) &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) -= rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff1497817438848e79baeaf852afb23c69ffd97a" translate="yes" xml:space="preserve">
          <source>4-7) Replaces the contents of &lt;code&gt;*this&lt;/code&gt; with the result of a generalized subscripting operation. The behavior is undefined if the length of the argument does not equal the length of &lt;code&gt;*this&lt;/code&gt; or if any value on the left depends on the value on the right (e.g &lt;code&gt;v=v[v&amp;gt;2]&lt;/code&gt;).</source>
          <target state="translated">4-7) &lt;code&gt;*this&lt;/code&gt; 의 내용을 일반화 된 첨자 연산 결과로 대체합니다 . 인수의 길이가 &lt;code&gt;*this&lt;/code&gt; 의 길이와 같지 않거나 왼쪽의 값이 오른쪽의 값 (예 : &lt;code&gt;v=v[v&amp;gt;2]&lt;/code&gt; ) 에 종속되는 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f8167ebc9a9c914198df2146bb3fa146b62705a7" translate="yes" xml:space="preserve">
          <source>4-7)&lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if required additional memory could not be obtained. May throw implementation-defined exception for other errors. &lt;code&gt;d(ptr)&lt;/code&gt; is called if an exception occurs.</source>
          <target state="translated">4-7) &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 필요한 경우 추가 메모리를 얻을 수 없습니다. 다른 오류에 대해서는 구현 정의 예외가 발생할 수 있습니다. 예외가 발생하면 &lt;code&gt;d(ptr)&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="48d0f216f7eebba1cf072aa9b39b920bfad9e022" translate="yes" xml:space="preserve">
          <source>4-8) Literal operators with these parameter lists are called by user-defined character literals</source>
          <target state="translated">4-8) 이러한 매개 변수리스트를 가진 리터럴 연산자는 사용자 정의 문자 리터럴에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8b2391ab7e85d02889681bb759e7488ab54d30b9" translate="yes" xml:space="preserve">
          <source>4-8) Throws any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">4-8) &lt;code&gt;T&lt;/code&gt; 의 생성자가 던진 예외를 던집니다 .</target>
        </trans-unit>
        <trans-unit id="4592ed2d43dd8cdf04cf8132cdbe9cb4113b500e" translate="yes" xml:space="preserve">
          <source>4. For two parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are equal, &lt;code&gt;std::hash&amp;lt;Key&amp;gt;()(k1) == std::hash&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt;.</source>
          <target state="translated">4. 동일한 두 개의 매개 변수 &lt;code&gt;k1&lt;/code&gt; 및 &lt;code&gt;k2&lt;/code&gt; 의 경우 &lt;code&gt;std::hash&amp;lt;Key&amp;gt;()(k1) == std::hash&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f53128c69cbfcae770f516492d62532aa2953ff" translate="yes" xml:space="preserve">
          <source>4.1 Implementation compliance (p: 5)</source>
          <target state="translated">4.1 이행 준수 (p : 5)</target>
        </trans-unit>
        <trans-unit id="f22422878288ee0c08f3a0e49628247fa6bd0c2b" translate="yes" xml:space="preserve">
          <source>4.10 Pointer conversions [conv.ptr]</source>
          <target state="translated">4.10 포인터 변환 [conv.ptr]</target>
        </trans-unit>
        <trans-unit id="8829bb2785ec19489356bcdd129ee2dbd04025c6" translate="yes" xml:space="preserve">
          <source>4.7 Multi-threaded executions and data races (p: 15)</source>
          <target state="translated">4.7 멀티 스레드 실행 및 데이터 레이스 (p : 15)</target>
        </trans-unit>
        <trans-unit id="55f930a4a1b546536e762e13aa5102733aa015e7" translate="yes" xml:space="preserve">
          <source>48&amp;ndash;57</source>
          <target state="translated">48&amp;ndash;57</target>
        </trans-unit>
        <trans-unit id="57e56e7ba05263a34cde2450744eb63caba71116" translate="yes" xml:space="preserve">
          <source>48-bit RANLUX generator by Martin L&amp;uuml;scher and Fred James, 1994.</source>
          <target state="translated">Martin L&amp;uuml;scher와 Fred James의 1994 년 48 비트 RANLUX 생성기.</target>
        </trans-unit>
        <trans-unit id="ac3478d69a3c81fa62e60f5c3696165a4e5e6ac4" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>
        </trans-unit>
        <trans-unit id="0280be64eb08bfd1b34478181cef86007a3ed36f" translate="yes" xml:space="preserve">
          <source>5) &lt;code&gt;rhs &amp;lt; lhs&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;rhs &amp;lt; lhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd827bcd9ae39f47793000844f84416590529ae" translate="yes" xml:space="preserve">
          <source>5) &lt;code&gt;y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;y &amp;lt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91b7a7845b0b926cfdafb9e63a63086dc2c101ea" translate="yes" xml:space="preserve">
          <source>5) A</source>
          <target state="translated">5) A</target>
        </trans-unit>
        <trans-unit id="2b52dadcc332e9fa63a19f492b30c7635f6ea294" translate="yes" xml:space="preserve">
          <source>5) A list-initialization sequence &lt;code&gt;L1&lt;/code&gt; is</source>
          <target state="translated">5)리스트 초기화 순서 &lt;code&gt;L1&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="a246d380f50433b6acc20aa4c2ad57168a46c6dc" translate="yes" xml:space="preserve">
          <source>5) A single-word type name followed by a</source>
          <target state="translated">5) 단일 단어 유형 이름 다음에</target>
        </trans-unit>
        <trans-unit id="026be18bf7cecc83951d934c90a5edef82b8183f" translate="yes" xml:space="preserve">
          <source>5) Any object pointer type &lt;code&gt;T1*&lt;/code&gt; can be converted to another object pointer type &lt;code&gt;&lt;i&gt;cv&lt;/i&gt; T2*&lt;/code&gt;. This is exactly equivalent to &lt;code&gt;static_cast&amp;lt;cv T2*&amp;gt;(static_cast&amp;lt;cv void*&amp;gt;(expression))&lt;/code&gt; (which implies that if &lt;code&gt;T2&lt;/code&gt;'s alignment requirement is not stricter than &lt;code&gt;T1&lt;/code&gt;'s, the value of the pointer does not change and conversion of the resulting pointer back to its original type yields the original value). In any case, the resulting pointer may only be dereferenced safely if allowed by the</source>
          <target state="translated">5) 모든 객체 포인터 유형 &lt;code&gt;T1*&lt;/code&gt; 은 다른 객체 포인터 유형 &lt;code&gt;&lt;i&gt;cv&lt;/i&gt; T2*&lt;/code&gt; 로 변환 될 수 있습니다 . 이는 &lt;code&gt;static_cast&amp;lt;cv T2*&amp;gt;(static_cast&amp;lt;cv void*&amp;gt;(expression))&lt;/code&gt; ( &lt;code&gt;T2&lt;/code&gt; 의 정렬 요구 사항이 &lt;code&gt;T1&lt;/code&gt; 보다 엄격 하지 않은 경우 포인터 값이 변경되지 않고 변환되지 않음을 의미 함) 결과 포인터를 원래 유형으로 되 돌리면 원래 값이 생성됩니다. 어쨌든 결과 포인터는 허용 된 경우에만 안전하게 참조 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f66e9cb3557564b83da88127f3677003ba1824bc" translate="yes" xml:space="preserve">
          <source>5) Appends the null-terminated character string pointed to by &lt;code&gt;s&lt;/code&gt;. The length of the string is determined by the first null character using &lt;code&gt;Traits::length(s)&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;s&lt;/code&gt; 가 가리키는 널 종료 문자열을 추가합니다 . 문자열의 길이는 &lt;code&gt;Traits::length(s)&lt;/code&gt; 사용하여 첫 번째 널 문자로 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a1c165850db9663cb648574f851012316c549ff" translate="yes" xml:space="preserve">
          <source>5) Assigns &lt;code&gt;p.first&lt;/code&gt; to the first element of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;p.second&lt;/code&gt; to the second element of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;p.first&lt;/code&gt; 를 &lt;code&gt;*this&lt;/code&gt; 의 첫 번째 요소에 , &lt;code&gt;p.second&lt;/code&gt; 를 * this 의 두 번째 요소에 지정 &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d31380db1be69f36b94c25b2e083075981b4053" translate="yes" xml:space="preserve">
          <source>5) Assigns the contents of the string &lt;code&gt;p&lt;/code&gt;. Equivalent to &lt;code&gt;assign(p);&lt;/code&gt;.</source>
          <target state="translated">5) 문자열 &lt;code&gt;p&lt;/code&gt; 의 내용을 할당합니다 . &lt;code&gt;assign(p);&lt;/code&gt; 와 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="d18f3f223294fb2f10a2bc39529aad3407bd9dd7" translate="yes" xml:space="preserve">
          <source>5) Assigns the string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">5) 문자열 &lt;code&gt;str&lt;/code&gt; 을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="f8a3482ef0dbd9e7042e1d39d1f68b551fd688f5" translate="yes" xml:space="preserve">
          <source>5) Behaves as a &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, which may skip leading whitespace, extracts a floating point value by calling &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;std::num_get::get()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">5) &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction으로&lt;/a&gt; 동작합니다 . 선행 공백을 건너 뛸 수있는 센트리 객체를 구성하고 확인한 후 &lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;std::num_get::get()&lt;/code&gt; &lt;/a&gt; 을 호출하여 부동 소수점 값을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="e84470f442133eff3a13e779cd8d8687ea7f3c8c" translate="yes" xml:space="preserve">
          <source>5) Binary/text mode indicator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bc13869b818a32ddcb21863298775c8a6c9ee5" translate="yes" xml:space="preserve">
          <source>5) Called by the non-throwing non-array &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt;. The standard library implementation calls the version (1) and returns a null pointer on failure instead of propagating the exception.</source>
          <target state="translated">5) 비 투척 비 배열 &lt;a href=&quot;../../language/new&quot;&gt;새로운 표현에&lt;/a&gt; 의해 호출됩니다 . 표준 라이브러리 구현은 버전 (1)을 호출하고 예외를 전파하는 대신 실패시 널 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="df324198f830262bbe61a8430f2ed74b2ed4c3a2" translate="yes" xml:space="preserve">
          <source>5) Checks if unary predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for no elements in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">5) 단항 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;[first, last)&lt;/code&gt; 범위에있는 요소가없는 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="90ce3977620b306b8f9d110c11dc3b1ae68bf634" translate="yes" xml:space="preserve">
          <source>5) Checks if unary predicate &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for no elements in the range &lt;code&gt;[first, last)&lt;/code&gt; (after projecting with the projection &lt;code&gt;proj&lt;/code&gt;).</source>
          <target state="translated">5) 단항 술어 &lt;code&gt;pred&lt;/code&gt; 가 ( &lt;code&gt;proj&lt;/code&gt; 투영 한 후 &lt;code&gt;[first, last)&lt;/code&gt; 범위에있는 요소가없는 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="696ae64de0f40758d4cf7d007681b4fb64e70903" translate="yes" xml:space="preserve">
          <source>5) Checks whether &lt;a href=&quot;parent_path&quot;&gt;&lt;code&gt;parent_path()&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">5) &lt;a href=&quot;parent_path&quot;&gt; &lt;code&gt;parent_path()&lt;/code&gt; &lt;/a&gt; 가 비어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="8a1c89119ceb093642be8420fbb4f189440f89ee" translate="yes" xml:space="preserve">
          <source>5) Checks whether &lt;code&gt;code&lt;/code&gt; is not a semantic match for &lt;code&gt;cond&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;code&lt;/code&gt; 가 &lt;code&gt;cond&lt;/code&gt; 와 의미 적으로 일치하지 않는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="05be1b68d993d7db1d52bf34a93cbfe2ea17ff9b" translate="yes" xml:space="preserve">
          <source>5) Checks whether &lt;code&gt;lhs&lt;/code&gt; is greater than &lt;code&gt;rhs&lt;/code&gt;. Equivalent to &lt;code&gt;rhs &amp;lt; lhs&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;lhs&lt;/code&gt; 가 &lt;code&gt;rhs&lt;/code&gt; 보다 큰지 확인합니다 . &lt;code&gt;rhs &amp;lt; lhs&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="970484cd52e8e0155f84244d299ba03eabef1efb" translate="yes" xml:space="preserve">
          <source>5) Compares a &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; substring of this string to the null-terminated character sequence beginning at the character pointed to by</source>
          <target state="translated">5) 이 문자열 의 &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; 서브 스트링을 다음으로 가리키는 문자에서 시작하는 널 종료 문자 시퀀스와 비교합니다.</target>
        </trans-unit>
        <trans-unit id="c086e97f30b4f5a7c1e9c52f35ecd6b7da2fb187" translate="yes" xml:space="preserve">
          <source>5) Computes the</source>
          <target state="translated">5) 계산</target>
        </trans-unit>
        <trans-unit id="d4dd3a88baf8bdc7595a5f7f02f0f21ba864bf4e" translate="yes" xml:space="preserve">
          <source>5) Constructs a &lt;code&gt;std::packaged_task&lt;/code&gt; with the shared state and task formerly owned by &lt;code&gt;rhs&lt;/code&gt;, leaving &lt;code&gt;rhs&lt;/code&gt; with no shared state and a moved-from task.</source>
          <target state="translated">5) 구성하는 &lt;code&gt;std::packaged_task&lt;/code&gt; 공유 상태 및 작업 이전에 소유와 &lt;code&gt;rhs&lt;/code&gt; 떠나, &lt;code&gt;rhs&lt;/code&gt; 공유 된 상태로를 이동 한-에서 작업.</target>
        </trans-unit>
        <trans-unit id="32cd0a683ead7d53f597edeaa411c6afbbc1376e" translate="yes" xml:space="preserve">
          <source>5) Constructs a &lt;code&gt;unique_ptr&lt;/code&gt; by transferring ownership from &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. If &lt;code&gt;Deleter&lt;/code&gt; is not a reference type, requires that it is nothrow-&lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; (if &lt;code&gt;Deleter&lt;/code&gt; is a reference, &lt;code&gt;get_deleter()&lt;/code&gt; and &lt;code&gt;u.get_deleter()&lt;/code&gt; after move construction reference the same value)</source>
          <target state="translated">5) 소유권을 &lt;code&gt;u&lt;/code&gt; 에서 &lt;code&gt;*this&lt;/code&gt; 로 이전 하여 &lt;code&gt;unique_ptr&lt;/code&gt; 을 구성 합니다 . 경우 &lt;code&gt;Deleter&lt;/code&gt; 가이 기준 입력받지 못하면 nothrow- 것을 요구 &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; (경우 &lt;code&gt;Deleter&lt;/code&gt; 가이 기준이다 &lt;code&gt;get_deleter()&lt;/code&gt; 및 &lt;code&gt;u.get_deleter()&lt;/code&gt; 이동 건설 기준 동일한 값이 후)</target>
        </trans-unit>
        <trans-unit id="4969b45eff1ace673e12d2220a74426f27a88499" translate="yes" xml:space="preserve">
          <source>5) Constructs a &lt;code&gt;year_month_day&lt;/code&gt; object that represent the same date as the one represented by &lt;code&gt;dp&lt;/code&gt;, as if by &lt;code&gt;year_month_day(sys_days(dp.time_since_epoch()))&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;year_month_day(sys_days(dp.time_since_epoch()))&lt;/code&gt; 처럼 &lt;code&gt;dp&lt;/code&gt; 로 표시된 것과 동일한 날짜를 나타내는 &lt;code&gt;year_month_day&lt;/code&gt; 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="01fae7414120442e41f6bc492d7e5a4b1c8a6d98" translate="yes" xml:space="preserve">
          <source>5) Constructs a distribution object initialized with the parameters &lt;code&gt;param&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;param&lt;/code&gt; 파라미터로 초기화 된 분포 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="f6a5d02dbc566d24f3bd9298958ad43bb27cf650" translate="yes" xml:space="preserve">
          <source>5) Constructs a variant with the specified alternative &lt;code&gt;T&lt;/code&gt; and initializes the contained value with the arguments &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. If T's selected constructor is a constexpr constructor, this constructor is also a constexpr constructor. This overload only participates in overload resolution if there is exactly one occurrence of T in &lt;code&gt;Types...&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">5) 지정된 대체 &lt;code&gt;T&lt;/code&gt; 를 사용하여 변형을 구성하고 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 인수로 포함 된 값을 초기화합니다 . T의 선택된 생성자가 constexpr 생성자 인 경우이 생성자는 constexpr 생성자이기도합니다. 이 과부하는 &lt;code&gt;Types...&lt;/code&gt; 에서 T가 정확히 한 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; 발생 하고 std :: is_constructible_v &amp;lt;T, Args ...&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="016a917325a0dbdd0c97b9b5248615dd58e9e327" translate="yes" xml:space="preserve">
          <source>5) Constructs an object with initial content an object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt;, &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-non-list-initialized&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, Args...&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; &amp;lt;Args&amp;gt; (args) ... 에서 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 비리스트 초기화&lt;/a&gt; 된 std :: &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; 유형의 객체를 초기 내용으로 객체를 구성합니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, Args...&amp;gt;&lt;/code&gt; &amp;lt; &lt;a href=&quot;../../types/decay&quot;&gt;std :: decay_t&lt;/a&gt; &amp;lt;ValueType&amp;gt;, Args ...&amp;gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt; &lt;a href=&quot;../../types/decay&quot;&gt;std :: decay_t&lt;/a&gt; &amp;lt;ValueType &amp;gt;&amp;gt; 이 모두 &lt;code&gt;true&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="5e8e836ee76213d33605822a1a6a568dbcc8f397" translate="yes" xml:space="preserve">
          <source>5) Constructs the container with the contents of the initializer list &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">5) 초기화리스트 &lt;code&gt;init&lt;/code&gt; 의 내용으로 컨테이너를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="7304af2d0f87c1082aa90eb2ecfae254daff0595" translate="yes" xml:space="preserve">
          <source>5) Constructs the container with the contents of the initializer list &lt;code&gt;init&lt;/code&gt;. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;LWG2844&lt;/a&gt;).</source>
          <target state="translated">5) 초기화리스트 &lt;code&gt;init&lt;/code&gt; 의 내용으로 컨테이너를 구축합니다 . 범위의 여러 요소에 동등한 키가있는 경우 삽입 할 요소가 지정되지 &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;않습니다&lt;/a&gt; ( LWG2844 보류 중 ).</target>
        </trans-unit>
        <trans-unit id="931d9984a908ab81e6d0751cd48c18b481bb7b40" translate="yes" xml:space="preserve">
          <source>5) Constructs the distribution with &lt;code&gt;params&lt;/code&gt; as the distribution parameters.</source>
          <target state="translated">5) 분포 모수로 &lt;code&gt;params&lt;/code&gt; 를 사용하여 분포를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="21a4928714727b3dbe5bbffc42b520ab2e2ebc8a" translate="yes" xml:space="preserve">
          <source>5) Constructs the string with the contents initialized with a copy of the null-terminated character string pointed to by &lt;code&gt;s&lt;/code&gt;. The length of the string is determined by the first null character. The behavior is undefined if &lt;code&gt;[s, s + Traits::length(s))&lt;/code&gt; is not a valid range (for example, if &lt;code&gt;s&lt;/code&gt; is a null pointer). This constructor is not used for &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt; if the &lt;code&gt;Allocator&lt;/code&gt; type that would be deduced does not qualify as an allocator. (since C++17)</source>
          <target state="translated">5) &lt;code&gt;s&lt;/code&gt; 가 가리키는 null로 끝나는 문자열의 복사본으로 내용을 초기화하여 문자열을 구성합니다 . 문자열의 길이는 첫 번째 널 문자로 결정됩니다. &lt;code&gt;[s, s + Traits::length(s))&lt;/code&gt; 가 유효한 범위가 아닌 경우 (예 : &lt;code&gt;s&lt;/code&gt; 가 널 포인터 인 경우 ) 동작이 정의되지 않습니다 . &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론&lt;/a&gt; 할 &lt;code&gt;Allocator&lt;/code&gt; 유형이 할당 자로 자격 이없는 경우이 생성자는 클래스 템플리트 인수 공제에 사용 되지 않습니다. (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="3b16a5b044cae405c41a53dbe84d972a2cc6214c" translate="yes" xml:space="preserve">
          <source>5) Converting move constructor: If &lt;code&gt;other&lt;/code&gt; doesn't contain a value, constructs an optional object that does not contain a value. Otherwise, constructs an optional object that contains a value, initialized as if &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializing&lt;/a&gt; (but not direct-list-initializing) an object of type &lt;code&gt;T&lt;/code&gt; with the expression &lt;code&gt;std::move(*other)&lt;/code&gt;. This constructor does not participate in overload resolution unless the following conditions are met:</source>
          <target state="translated">5) 이동 생성자 변환 : &lt;code&gt;other&lt;/code&gt; 에 값이 포함되어 있지 않으면 값이 포함되지 않은 선택적 객체를 구성합니다. 그렇지 않으면, &lt;code&gt;std::move(*other)&lt;/code&gt; 표현식을 사용하여 &lt;code&gt;T&lt;/code&gt; 유형의 오브젝트를 직접 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;초기화&lt;/a&gt; (직접 목록 초기화하지는 않음)하는 것처럼 초기화되는 값을 포함하는 선택적 오브젝트를 구성합니다 . 이 생성자는 다음 조건이 충족되지 않으면 과부하 해결에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aaadf3d2e65e98fd8e9e7f1117d0809461b357e9" translate="yes" xml:space="preserve">
          <source>5) Converting move-constructor. For all &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;sizeof...(UTypes)&lt;/code&gt;, initializes ith element of the tuple with &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Ui&amp;gt;(std::get&amp;lt;i&amp;gt;(other))&lt;/code&gt;.</source>
          <target state="translated">5) 이동 생성자 변환. &lt;code&gt;sizeof...(UTypes)&lt;/code&gt; 모든 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Ui&amp;gt;(std::get&amp;lt;i&amp;gt;(other))&lt;/code&gt; &amp;lt;Ui&amp;gt; (std :: get &amp;lt;i&amp;gt; (other))으로 튜플의 ith 요소를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="d98d284309ce64c1bb3c124f3be5db84cc80a0d9" translate="yes" xml:space="preserve">
          <source>5) Converts an unsigned decimal integer to a string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%lu&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">5) 부호없는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%lu&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에서 생성하는 내용과 동일한 내용의 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="29d715181842fc5cc8c7528d2936103435422b12" translate="yes" xml:space="preserve">
          <source>5) Converts an unsigned decimal integer to a wide string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%lu&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">5) 부호없는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%lu&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에 대해 생성 할 내용과 동일한 내용을 가진 넓은 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2a81b33beb88933d460f2afc680c1c71d75cfc74" translate="yes" xml:space="preserve">
          <source>5) Converts the duration &lt;code&gt;d&lt;/code&gt; to one whose &lt;code&gt;rep&lt;/code&gt; is the common type between &lt;code&gt;Rep1&lt;/code&gt; and &lt;code&gt;Rep2&lt;/code&gt;, and divides the number of ticks after conversion by &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">5) 지속 시간 &lt;code&gt;d&lt;/code&gt; 를 &lt;code&gt;Rep1&lt;/code&gt; 과 &lt;code&gt;Rep2&lt;/code&gt; 사이에서 &lt;code&gt;rep&lt;/code&gt; 가 공통 유형 인 것으로 변환하고 변환 후 틱 수를 &lt;code&gt;s&lt;/code&gt; 로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="e5f03ca28ab3473ba3be06882b9f5581f78b3a85" translate="yes" xml:space="preserve">
          <source>5) Copy constructor is deleted.</source>
          <target state="translated">5) 복사 생성자가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="79d5d71541341822b23d10077f4e6aad80c883a5" translate="yes" xml:space="preserve">
          <source>5) Copy constructor. Constructs the container with the copy of the contents of &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;alloc&lt;/code&gt; is not provided, allocator is obtained as if by calling &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::select_on_container_copy_construction(other.get_allocator())&lt;/code&gt;.</source>
          <target state="translated">5) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 의 내용을 복사하여 컨테이너를 구성합니다 . 경우 &lt;code&gt;alloc&lt;/code&gt; 제공되지 않고, 할당이 호출 경우로서 수득 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::select_on_container_copy_construction(other.get_allocator())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e81261cde58ef86e4f9140d1d35148dda556b7b" translate="yes" xml:space="preserve">
          <source>5) Copy constructor. Constructs the numeric array with the copy of the contents of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">5) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 의 내용을 복사하여 숫자 형 배열을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="ddfc1f8af9864d0c7ef52ac6a3db6de7c5fd5ea4" translate="yes" xml:space="preserve">
          <source>5) Copy constructor. The adaptor is copy-constructed with the contents of &lt;code&gt;other.c&lt;/code&gt;. The comparison functor is constructed with &lt;code&gt;std::move(other.comp)&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">5) 복사 생성자. 어댑터는 &lt;code&gt;other.c&lt;/code&gt; 의 내용으로 복사 구성됩니다 . 비교 functor는 &lt;code&gt;std::move(other.comp)&lt;/code&gt; 됩니다. (내재적으로 선언)</target>
        </trans-unit>
        <trans-unit id="ea579ecab1baa7da5588b9694b6df23504948cd3" translate="yes" xml:space="preserve">
          <source>5) Defaulted default constructor outside of class definition (the class must contain a declaration (1)). Such constructor is treated as</source>
          <target state="translated">5) 클래스 정의 외부의 기본 기본 생성자 (클래스는 선언 (1)을 포함해야합니다). 이러한 생성자는</target>
        </trans-unit>
        <trans-unit id="c121a6c082780654f2e365e751487c77f3b34557" translate="yes" xml:space="preserve">
          <source>5) Depends on the searcher</source>
          <target state="translated">5) 검색 자에 따라 다름</target>
        </trans-unit>
        <trans-unit id="b8aca5f2256846a3632e11a12462f02fd87db1ae" translate="yes" xml:space="preserve">
          <source>5) Equivalent to</source>
          <target state="translated">5) 해당</target>
        </trans-unit>
        <trans-unit id="459ec88d18f9b812cfb4f14a36c7dd40704c9134" translate="yes" xml:space="preserve">
          <source>5) Equivalent to &lt;code&gt;rep_ %= rhs; return *this;&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;rep_ %= rhs; return *this;&lt;/code&gt; 와 동등 함 ; return * this;</target>
        </trans-unit>
        <trans-unit id="66c187a8b49bbcf6f6e153bcf7536eb96fc3481e" translate="yes" xml:space="preserve">
          <source>5) Equivalent to &lt;code&gt;substr(pos1, count1).compare(basic_string_view(s))&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;substr(pos1, count1).compare(basic_string_view(s))&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="40a43fbaee0338cbd281535274d09a1e24452b95" translate="yes" xml:space="preserve">
          <source>5) Execution of the return (or the implicit return upon reaching the end of main) is equivalent to first leaving the function normally (which destroys the objects with automatic storage duration) and then calling &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; with the same argument as the argument of the &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;. (&lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; then destroys static objects and terminates the program)</source>
          <target state="translated">5) 리턴 (또는 메인의 끝에 도달했을 때의 암시 적 리턴)의 실행은 먼저 함수를 정상적으로 떠나고 (자동 저장 시간으로 오브젝트를 파괴 함) 인수와 동일한 인수로 &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 를 호출 하는 것과 같습니다. 의 &lt;a href=&quot;return&quot;&gt;반환&lt;/a&gt; . ( &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 는 정적 객체를 파괴하고 프로그램을 종료합니다)</target>
        </trans-unit>
        <trans-unit id="e422c78697806c4cf9703a22efbb9ae1d5d192a3" translate="yes" xml:space="preserve">
          <source>5) Expands to integer constant expression whose value is either &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;-&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">5) 값 중 하나 인 정수 상수 식으로 확장 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;-&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f61ab7ea25d36b4619744818d9ecdb7c33bce3a" translate="yes" xml:space="preserve">
          <source>5) For arguments of type pointer to T or pointer to an array of T, the type T is examined and its associated set of classes and namespaces is added to the set.</source>
          <target state="translated">5) T에 대한 포인터 유형 또는 T의 배열에 대한 포인터의 경우, T 유형이 검사되고 연관된 클래스 및 네임 스페이스 세트가 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6812b9da8f80d2b525eecd207abc0c8d200f8a0e" translate="yes" xml:space="preserve">
          <source>5) For every argument there must be at least one implicit conversion sequence that converts it to the corresponding parameter.</source>
          <target state="translated">5) 모든 인수에 대해 해당 매개 변수로 변환하는 하나 이상의 내재적 변환 순서가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9e289808315e074183dfc8e99f410a7c61907264" translate="yes" xml:space="preserve">
          <source>5) Formal syntax of a destructor declaration</source>
          <target state="translated">5) 소멸자 선언의 형식적 구문</target>
        </trans-unit>
        <trans-unit id="95076dee8fe2d941438e3cda5e063c8695327b1c" translate="yes" xml:space="preserve">
          <source>5) Hexadecimal digit-sequence representing a whole number with a radix separator. The exponent is never optional for hexadecimal floating-point literals: &lt;code&gt;0x1.p0&lt;/code&gt;, &lt;code&gt;0xf.p-1&lt;/code&gt;</source>
          <target state="translated">5) 기수 구분 기호로 정수를 나타내는 16 진 숫자 시퀀스. 16 진 부동 소수점 리터럴의 경우 지수는 선택 사항이 아닙니다. &lt;code&gt;0x1.p0&lt;/code&gt; , &lt;code&gt;0xf.p-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="872d97bb9f8b08c2fb4be13abe9b5bfd0690d7ba" translate="yes" xml:space="preserve">
          <source>5) If &lt;code&gt;bool(lhs) == false&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">5) 만약 &lt;code&gt;bool(lhs) == false&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ec9eabce9183de0994d7cec8c6b14feef7c2b30" translate="yes" xml:space="preserve">
          <source>5) If a &lt;a href=&quot;implicit_cast&quot;&gt;standard conversion&lt;/a&gt; sequence from new_type to the type of expression exists, that does not include lvalue-to-rvalue, array-to-pointer, function-to-pointer, null pointer, null member pointer, function pointer,(since C++17) or boolean conversion, then &lt;code&gt;static_cast&lt;/code&gt; can perform the inverse of that implicit conversion.</source>
          <target state="translated">5) new_type에서 expression 유형으로의 &lt;a href=&quot;implicit_cast&quot;&gt;표준 변환&lt;/a&gt; 시퀀스가 존재하는 경우 lvalue-to-rvalue, array-to-pointer, function-to-pointer, null 포인터, null 멤버 포인터, 함수 포인터를 포함하지 않습니다. C ++ 17) 또는 부울 변환 인 경우 &lt;code&gt;static_cast&lt;/code&gt; 는 해당 암시 적 변환의 역수를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c7c89c4c9bed556d20c958230533bde55c36872" translate="yes" xml:space="preserve">
          <source>5) If expression is a pointer or reference to a &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic type&lt;/a&gt;&lt;code&gt;Base&lt;/code&gt;, and &lt;code&gt;new_type&lt;/code&gt; is a pointer or reference to the type &lt;code&gt;Derived&lt;/code&gt; a run-time check is performed:</source>
          <target state="translated">5) expression이 포인터 또는 &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;다형성 유형 &lt;/a&gt; &lt;code&gt;Base&lt;/code&gt; 에 대한 참조 이고 &lt;code&gt;new_type&lt;/code&gt; 이 포인터 또는 유형 &lt;code&gt;Derived&lt;/code&gt; 대한 참조 인 경우 런타임 검사가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="47c26266e3782ff93bbe0feadf8496f98eeba803" translate="yes" xml:space="preserve">
          <source>5) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then finds the first character equal to none of characters in &lt;code&gt;sv&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;sv&lt;/code&gt; 의 문자가없는 첫 번째 문자를 찾습니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="606da7419004772cfa9ddddf7bdbcbd6d3c2b40a" translate="yes" xml:space="preserve">
          <source>5) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then finds the first character equal to one of the characters in &lt;code&gt;sv&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;sv&lt;/code&gt; 의 문자 중 하나와 동일한 첫 번째 문자를 찾습니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="eb735f269c0b17c9a211422dd355cb458013eb60" translate="yes" xml:space="preserve">
          <source>5) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then finds the first substring equal to &lt;code&gt;sv&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;sv&lt;/code&gt; 과 동일한 첫 번째 하위 문자열을 찾습니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="448ed8f044eed28a0d22fc949a513f816d3c8702" translate="yes" xml:space="preserve">
          <source>5) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then finds the last character equal to none of characters in &lt;code&gt;sv&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;sv&lt;/code&gt; 의 문자가없는 마지막 문자를 찾습니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="cc4843cccef100f1a32187807141df3143b4c172" translate="yes" xml:space="preserve">
          <source>5) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then finds the last character equal to one of characters in &lt;code&gt;sv&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;sv&lt;/code&gt; 의 문자 중 하나와 같은 마지막 문자를 찾습니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="31d54582a5abb100c535450019ae5255fbd1c013" translate="yes" xml:space="preserve">
          <source>5) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then finds the last substring equal to the contents of &lt;code&gt;sv&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;sv&lt;/code&gt; 의 내용과 동일한 마지막 하위 문자열을 찾습니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="3ef5ac8b0a64e6d021fcb22ee0fb544f2892b236" translate="yes" xml:space="preserve">
          <source>5) Indicates that the function takes no parameters, it is the exact synonym for an empty parameter list: &lt;code&gt;int f(void);&lt;/code&gt; and &lt;code&gt;int f();&lt;/code&gt; declare the same function. Note that the type &lt;code&gt;void&lt;/code&gt; (possibly cv-qualified) cannot be used in a parameter list otherwise: &lt;code&gt;int f(void, int);&lt;/code&gt; and &lt;code&gt;int f(const void);&lt;/code&gt; are errors (although derived types, such as &lt;code&gt;void*&lt;/code&gt; can be used). In a template, only non-dependent void type can be used (a function taking a single parameter of type &lt;code&gt;T&lt;/code&gt; does not become a no-parameter function if instantiated with &lt;code&gt;T = void&lt;/code&gt;)(since C++11)</source>
          <target state="translated">5) 함수가 매개 변수를 사용하지 않음을 나타내며, 빈 매개 변수 목록의 정확한 동의어입니다. &lt;code&gt;int f(void);&lt;/code&gt; 그리고 &lt;code&gt;int f();&lt;/code&gt; 같은 함수를 선언하십시오. &lt;code&gt;void&lt;/code&gt; ( 유형 cv-qualified) 유형 은 매개 변수 목록에서 사용할 수 없습니다. &lt;code&gt;int f(void, int);&lt;/code&gt; 및 &lt;code&gt;int f(const void);&lt;/code&gt; &lt;code&gt;void*&lt;/code&gt; 와 같은 파생 유형을 사용할 수 있지만 오류 입니다. 템플릿에서는 비 종속적 공백 유형 만 사용할 수 있습니다 ( &lt;code&gt;T&lt;/code&gt; 유형의 단일 매개 변수를 사용하는 함수 는 &lt;code&gt;T = void&lt;/code&gt; 인스턴스화 된 경우 매개 변수가없는 기능이 아닙니다 ) (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="bb1f50c6a6f9a3559d5ece228103fbb7a66fd623" translate="yes" xml:space="preserve">
          <source>5) Initializes &lt;code&gt;first&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U1&amp;gt;(p.first)&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U2&amp;gt;(p.second)&lt;/code&gt;.</source>
          <target state="translated">5)를 초기화 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U1&amp;gt;(p.first)&lt;/code&gt; 및 &lt;code&gt;second&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U2&amp;gt;(p.second)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0b164b5b6caac9ec541ee388df71f2cd72ac2d3" translate="yes" xml:space="preserve">
          <source>5) Initializes each allocator from the corresponding allocator of &lt;code&gt;other&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;OuterAlloc, const OuterA2&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;other&lt;/code&gt; 할당 자에서 각 할당자를 초기화합니다 . &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;OuterAlloc, const OuterA2&amp;amp;&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인경우이 과부하는 과부하 해결에만 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="1176a5c0bf6264c62f1a634e98d8b11b1b49a796" translate="yes" xml:space="preserve">
          <source>5) Initializes the</source>
          <target state="translated">5) 초기화</target>
        </trans-unit>
        <trans-unit id="ad8cb10c961732125daea4e25e12e73ee72f4695" translate="yes" xml:space="preserve">
          <source>5) Inserts a string, obtained by &lt;code&gt;str.substr(index_str, count)&lt;/code&gt; at the position &lt;code&gt;index&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;str.substr(index_str, count)&lt;/code&gt; 에 의해 얻은 문자열을 위치 &lt;code&gt;index&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d338a49c38d04374ba136b64829eab59313c725" translate="yes" xml:space="preserve">
          <source>5) Inserts elements from range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="2eecd35e59a60debd305f47b807937fadbeaf43f" translate="yes" xml:space="preserve">
          <source>5) Inserts elements from range &lt;code&gt;[first, last)&lt;/code&gt;. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;LWG2844&lt;/a&gt;).</source>
          <target state="translated">5) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소를 삽입합니다 . 범위의 여러 요소에 동등한 키가있는 경우 삽입 할 요소가 지정되지 &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;않습니다&lt;/a&gt; ( LWG2844 보류 중 ).</target>
        </trans-unit>
        <trans-unit id="817379462a5070b9ed64ad4cfa9857fba27e33f1" translate="yes" xml:space="preserve">
          <source>5) Iterator pointing to the first element inserted, or &lt;code&gt;pos&lt;/code&gt; if &lt;code&gt;ilist&lt;/code&gt; is empty.</source>
          <target state="translated">5) 삽입 된 첫 번째 요소를 가리키는 반복자 또는 &lt;code&gt;ilist&lt;/code&gt; 가 비어있는 경우 &lt;code&gt;pos&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74b5f2eb9c657e592a833362b16052cd8ec917af" translate="yes" xml:space="preserve">
          <source>5) Iterator to the last element inserted, or &lt;code&gt;pos&lt;/code&gt; if &lt;code&gt;ilist&lt;/code&gt; is empty.</source>
          <target state="translated">5) 삽입 된 마지막 요소에 대한 반복자 또는 &lt;code&gt;ilist&lt;/code&gt; 가 비어있는 경우 &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecfff4a42a268b8a4ca06eecdb3e5329c7eb5d3e" translate="yes" xml:space="preserve">
          <source>5) Less-equal operator for variants:</source>
          <target state="translated">5) 변형에 대한 동등하지 않은 연산자 :</target>
        </trans-unit>
        <trans-unit id="0ad1a24145a4dd1131fe131bf87254f164b8ecc4" translate="yes" xml:space="preserve">
          <source>5) Linear in &lt;code&gt;ilist.size()&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;ilist.size()&lt;/code&gt; 선형</target>
        </trans-unit>
        <trans-unit id="c7117be06ca98676b032372e03435ed20fb0e3c2" translate="yes" xml:space="preserve">
          <source>5) Linear in &lt;code&gt;ilist.size()&lt;/code&gt; plus linear in the distance between &lt;code&gt;pos&lt;/code&gt; and end of the container.</source>
          <target state="translated">5) &lt;code&gt;ilist.size()&lt;/code&gt; 선형 + 컨테이너의 &lt;code&gt;pos&lt;/code&gt; 와 끝 사이의 거리에서 선형 .</target>
        </trans-unit>
        <trans-unit id="e53c586f0317bdfd42124d6160de28501f7ea317" translate="yes" xml:space="preserve">
          <source>5) Linear in &lt;code&gt;ilist.size()&lt;/code&gt; plus linear in the lesser of the distances between &lt;code&gt;pos&lt;/code&gt; and either of the ends of the container.</source>
          <target state="translated">5) &lt;code&gt;ilist.size()&lt;/code&gt; 선형 + &lt;code&gt;pos&lt;/code&gt; 와 컨테이너의 양쪽 끝 사이의 거리가 작은 선형 .</target>
        </trans-unit>
        <trans-unit id="c790dad5f054c4d020f26722417867e9839bea96" translate="yes" xml:space="preserve">
          <source>5) Linear in size of &lt;code&gt;other&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;other&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="86ee2d5575dcd968203c703d124d10f3ca667873" translate="yes" xml:space="preserve">
          <source>5) Move constructor. Constructs a regex by with the contents of &lt;code&gt;other&lt;/code&gt; using move semantics.</source>
          <target state="translated">5) 생성자를 이동합니다. 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 내용으로 정규 표현식을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="54660710e05c9b4279653c2659beda56843c0618" translate="yes" xml:space="preserve">
          <source>5) Move constructor. Move-constructs the std::basic_ostream base and the std::basic_syncbuf member from the corresponding subobjects of &lt;code&gt;other&lt;/code&gt;, then calls &lt;a href=&quot;../basic_ios/set_rdbuf&quot;&gt;&lt;code&gt;set_rdbuf&lt;/code&gt;&lt;/a&gt; with the pointer to the newly-constructed underlying std::basic_syncbuf to complete the initialization of the base. After this move constructor, &lt;code&gt;other.get_wrapped()&lt;/code&gt; returns &lt;code&gt;nullptr&lt;/code&gt; and destruction of &lt;code&gt;other&lt;/code&gt; produces no output.</source>
          <target state="translated">5) 생성자를 이동합니다. 성병 :: basic_ostream베이스와의 해당 하위 객체에서 표준 : basic_syncbuf 회원 이동은-구축 &lt;code&gt;other&lt;/code&gt; 다음 호출 &lt;a href=&quot;../basic_ios/set_rdbuf&quot;&gt; &lt;code&gt;set_rdbuf&lt;/code&gt; 를&lt;/a&gt; 베이스의 초기화를 완료하기 위해 새로 건설 기본 표준 : basic_syncbuf에 대한 포인터. 이 이동 생성자 후 &lt;code&gt;other.get_wrapped()&lt;/code&gt; 는 &lt;code&gt;nullptr&lt;/code&gt; 을 반환 하고 &lt;code&gt;other&lt;/code&gt; 를 삭제 하면 출력이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d7001fcd2e6b287dafbb5702a437353d344a6c1" translate="yes" xml:space="preserve">
          <source>5) Move constructor. The adaptor is constructed with &lt;code&gt;std::move(other.c)&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">5) 생성자를 이동합니다. 어댑터는 &lt;code&gt;std::move(other.c)&lt;/code&gt; 됩니다. (내재적으로 선언)</target>
        </trans-unit>
        <trans-unit id="dfac0566c4d0ae0d4d7857d7ab096f81e8821770" translate="yes" xml:space="preserve">
          <source>5) Move-constructs a &lt;code&gt;std::basic_stringbuf&lt;/code&gt; object by moving all state from another &lt;code&gt;std::basic_stringbuf&lt;/code&gt; object &lt;code&gt;rhs&lt;/code&gt;, including the associated string, the open mode, the locale, and all other state. After the move, the six pointers of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;*this&lt;/code&gt; are guaranteed to be different from the corresponding pointers in the moved-from &lt;code&gt;rhs&lt;/code&gt; unless null.</source>
          <target state="translated">5) &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 관련 문자열, 열린 모드, 로케일 및 기타 모든 상태를 포함하여 다른 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 객체 &lt;code&gt;rhs&lt;/code&gt; 에서 모든 상태를 이동 하여 std :: basic_stringbuf 객체를 구성합니다 . 이동 후, &lt;code&gt;*this&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 의 6 개의 포인터는 null이 아닌 경우 이동 된 &lt;code&gt;rhs&lt;/code&gt; 의 해당 포인터와 달라야합니다 .</target>
        </trans-unit>
        <trans-unit id="cd8fa6d6ed8b063e2916f68b54179a0c6293c227" translate="yes" xml:space="preserve">
          <source>5) Move-constructs the underlying engine with &lt;code&gt;e&lt;/code&gt;. &lt;code&gt;e&lt;/code&gt; holds unspecified, but valid state afterwards.</source>
          <target state="translated">5) &lt;code&gt;e&lt;/code&gt; 로 기본 엔진을 이동 구성합니다 . &lt;code&gt;e&lt;/code&gt; 는 나중에 지정되지 않았지만 유효한 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="88c7f2b9dca795490c094bfb3d47d9e03de3bbfd" translate="yes" xml:space="preserve">
          <source>5) N log(N) where &lt;code&gt;N = init.size())&lt;/code&gt; in general, linear in &lt;code&gt;N&lt;/code&gt; if &lt;code&gt;init&lt;/code&gt; is already sorted by &lt;code&gt;value_comp()&lt;/code&gt;.</source>
          <target state="translated">5) N log (N) 여기서 &lt;code&gt;N = init.size())&lt;/code&gt; , &lt;code&gt;init&lt;/code&gt; 가 &lt;code&gt;value_comp()&lt;/code&gt; 의해 이미 정렬 된 경우 &lt;code&gt;N&lt;/code&gt; 에 선형입니다 .</target>
        </trans-unit>
        <trans-unit id="fd09a9d3bb989b35a56a55b894d563e1b0222458" translate="yes" xml:space="preserve">
          <source>5) Non-type template argument cannot specialize a template parameter whose type depends on a parameter of the specialization:</source>
          <target state="translated">5) 유형이 아닌 템플릿 인수는 유형이 전문화의 매개 변수에 의존하는 템플릿 매개 변수를 특수화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6db96aa00477a5f1e3bc0956c3e3281e2453939d" translate="yes" xml:space="preserve">
          <source>5) Otherwise they compare unequal.</source>
          <target state="translated">5) 그렇지 않으면 그들은 불평등하다.</target>
        </trans-unit>
        <trans-unit id="6b8ba7437575d3133b53019f9b1c82198c770273" translate="yes" xml:space="preserve">
          <source>5) Otherwise, the result is a prvalue. If &lt;code&gt;E2&lt;/code&gt; and &lt;code&gt;E3&lt;/code&gt; do not have the same type, and either has (possibly cv-qualified) class type, overload resolution is performed using the built-in candidates below to attempt to convert the operands to built-in types. If the overload resolution fails, the program is ill-formed. Otherwise, the selected conversions are applied and the converted operands are used in place of the original operands for step 6.</source>
          <target state="translated">5) 그렇지 않으면 결과는 prvalue입니다. 경우 &lt;code&gt;E2&lt;/code&gt; 및 &lt;code&gt;E3&lt;/code&gt; 는 동일한 유형이 있고, 하나가없는 (아마도 이력서 자격) 클래스 유형, 과부하 해상도는 사용하여 수행됩니다 내장 된 아래의 후보 종류의 내장에 피연산자를 변환하려고 시도합니다. 과부하 해결에 실패하면 프로그램이 잘못 구성됩니다. 그렇지 않으면 선택한 변환이 적용되고 변환 된 피연산자가 6 단계의 원래 피연산자 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c858f4c924cc5aadb339a48c00c76ac44c5f5a6" translate="yes" xml:space="preserve">
          <source>5) Parameter pack expansion: expands to comma-separated list of zero or more &lt;code&gt;pattern&lt;/code&gt;s. Pattern must include at least one parameter pack.</source>
          <target state="translated">5) 파라미터 팩 확장 : 쉼표로 구분 된 0 개 이상의 &lt;code&gt;pattern&lt;/code&gt; 목록으로 확장됩니다 . 패턴에는 하나 이상의 매개 변수 팩이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0dc7cd7051a6cbef96897462555c686b02a04f67" translate="yes" xml:space="preserve">
          <source>5) Performs atomic bitwise exclusive or. Equivalent to &lt;code&gt;fetch_xor(arg)&lt;/code&gt; ^ arg.</source>
          <target state="translated">5) 원자 비트 단위 배타적 또는 &lt;code&gt;fetch_xor(arg)&lt;/code&gt; ^ arg 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="02d3153f91a7deb2d39fb9369f55fa64ddd497fd" translate="yes" xml:space="preserve">
          <source>5) Performs atomic bitwise exclusive or. Equivalent to &lt;code&gt;return fetch_xor(arg) ^ arg;&lt;/code&gt;.</source>
          <target state="translated">5) 원자 비트 단위 배타적 또는 &lt;code&gt;return fetch_xor(arg) ^ arg;&lt;/code&gt; 를 반환하는 것과 동일 ^ arg; .</target>
        </trans-unit>
        <trans-unit id="164aa3af5bea83411780272af94a14e888eb2f47" translate="yes" xml:space="preserve">
          <source>5) Reduces the range [first; last), possibly permuted and aggregated in unspecified manner, along with the initial value &lt;code&gt;init&lt;/code&gt; over &lt;code&gt;binary_op&lt;/code&gt;.</source>
          <target state="translated">5) 범위를 줄입니다 [먼저; ) 마지막으로, 아마도 순열 초기 값과 함께, 불특정하게 응집 &lt;code&gt;init&lt;/code&gt; 를 통해 &lt;code&gt;binary_op&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06329c852e7592210e140dea9972a8115eec57c6" translate="yes" xml:space="preserve">
          <source>5) Remove each non-dot-dot filename immediately followed by a directory-separator and a dot-dot, along with any immediately following directory-separator.</source>
          <target state="translated">5) 도트가 아닌 각 파일 이름 바로 다음에 디렉토리 구분 기호와 도트 점이 뒤 따르는 디렉토리 구분 기호와 함께 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="896a27e327ab6578ea0fceff4d84004e1a3cbc91" translate="yes" xml:space="preserve">
          <source>5) Replaces the contents with copies of the characters in the range &lt;code&gt;[s, s+count)&lt;/code&gt;. This range can contain null characters.</source>
          <target state="translated">5) 내용을 &lt;code&gt;[s, s+count)&lt;/code&gt; 범위의 문자 사본으로 바꿉니다 . 이 범위는 널 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b863247de5fd57926204690c1285f3e9cd2ba27" translate="yes" xml:space="preserve">
          <source>5) Replaces the contents with those of the initializer list &lt;code&gt;ilist&lt;/code&gt; as if by &lt;code&gt;assign(ilist.begin(), ilist.size())&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;assign(ilist.begin(), ilist.size())&lt;/code&gt; 의해 내용을 초기화리스트 &lt;code&gt;ilist&lt;/code&gt; 의 내용으로 대체</target>
        </trans-unit>
        <trans-unit id="4eeb68825d7935a72f237e389d94f712091e525c" translate="yes" xml:space="preserve">
          <source>5) Restores the &lt;code&gt;skipws&lt;/code&gt; flag on the input stream to its original value.</source>
          <target state="translated">5) 입력 스트림 의 &lt;code&gt;skipws&lt;/code&gt; 플래그를 원래 값으로 복원합니다 .</target>
        </trans-unit>
        <trans-unit id="bf7fac0007478f050a1bacb5e11276b8946af50f" translate="yes" xml:space="preserve">
          <source>5) Returns &lt;code&gt;&lt;a href=&quot;utc_clock/from_sys&quot;&gt;std::chrono::utc_clock::from_sys&lt;/a&gt;(t)&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;&lt;a href=&quot;utc_clock/from_sys&quot;&gt;std::chrono::utc_clock::from_sys&lt;/a&gt;(t)&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c012a431f1d9a4e3159a0ef4d14038b5b9cf549a" translate="yes" xml:space="preserve">
          <source>5) Returns &lt;code&gt;std::regex_match(str, str + &lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;charT&amp;gt;::length(str), e, flags)&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;std::regex_match(str, str + &lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;charT&amp;gt;::length(str), e, flags)&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e580e60b8cfa6ca7f601a3a418c35b363965fcb2" translate="yes" xml:space="preserve">
          <source>5) Returns &lt;code&gt;true&lt;/code&gt; if lhs is equal to rhs, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">5) lhs가 rhs와 같으면 &lt;code&gt;true&lt;/code&gt; 를, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="619ac5fe74fce774a4488d16bd374ef7f6e01822" translate="yes" xml:space="preserve">
          <source>5) Returns the result of &lt;code&gt;searcher.operator()&lt;/code&gt;, that is, an iterator to the location at which the substring is found or a copy of &lt;code&gt;last&lt;/code&gt; if it was not found.</source>
          <target state="translated">5) &lt;code&gt;searcher.operator()&lt;/code&gt; 의 결과 , 즉 하위 문자열이있는 위치의 반복자 또는 &lt;code&gt;last&lt;/code&gt; 찾지 못한 경우 사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d251711197e1afda2b30d1d03f90f1b04cdc4913" translate="yes" xml:space="preserve">
          <source>5) Same as (2), except that the array is default-initialized. This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is an array of unknown bound. The function is equivalent to:</source>
          <target state="translated">5) 배열이 기본 초기화 된 것을 제외하고 (2)와 동일합니다. &lt;code&gt;T&lt;/code&gt; 가 알려지지 않은 범위의 배열 인 경우이 과부하는 과부하 해결에만 참여 합니다. 이 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="444e1ade6da28e984e3b81c420f273a82b7bccff" translate="yes" xml:space="preserve">
          <source>5) Same as (4), but if &lt;code&gt;&lt;a href=&quot;../directory_options&quot;&gt;std::filesystem::directory_options::skip_permission_denied&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;options&lt;/code&gt; and construction encounters a permissions denied error, constructs the end iterator and does not report an error.</source>
          <target state="translated">5) (4)와 동일하지만 &lt;code&gt;options&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../directory_options&quot;&gt;std::filesystem::directory_options::skip_permission_denied&lt;/a&gt;&lt;/code&gt; 가 설정 되고 구성에 권한 거부 오류가 발생하면 종료 반복자를 구성하며 오류를보고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="448e92a587c2f153c28cdd8ec7045b5ba7224eb9" translate="yes" xml:space="preserve">
          <source>5) Searches the sequence [first, last) for the pattern specified in the constructor of &lt;code&gt;searcher&lt;/code&gt;. Effectively executes &lt;code&gt;return searcher(first, last).first;&lt;/code&gt;. &lt;code&gt;Searcher&lt;/code&gt; need not be &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">5) &lt;code&gt;searcher&lt;/code&gt; 의 생성자에 지정된 패턴에 대해 시퀀스 [first, last)를 검색 합니다. 효과적으로 &lt;code&gt;return searcher(first, last).first;&lt;/code&gt; . &lt;code&gt;Searcher&lt;/code&gt; 는 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible 일&lt;/a&gt; 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fc7802954a171e851fe9691c351d80cd27b2e8dd" translate="yes" xml:space="preserve">
          <source>5) Sets the</source>
          <target state="translated">5) 설정</target>
        </trans-unit>
        <trans-unit id="875b09c8c336ba3b7b0c7adf6563b1221eebf199" translate="yes" xml:space="preserve">
          <source>5) Specialization for types that define a public and accessible member type &lt;code&gt;value_type&lt;/code&gt;. If &lt;code&gt;T::value_type&lt;/code&gt; is an object type, provides a member type &lt;code&gt;value_type&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;typename T::value_type&amp;gt;&lt;/code&gt;. Otherwise, there is no member &lt;code&gt;value_type&lt;/code&gt;.</source>
          <target state="translated">5) 공개 및 액세스 가능한 멤버 유형 &lt;code&gt;value_type&lt;/code&gt; 을 정의하는 유형에 대한 전문화 . 경우 &lt;code&gt;T::value_type&lt;/code&gt; 개체 유형이며, 멤버 형 제공 &lt;code&gt;value_type&lt;/code&gt; 동일한 &lt;code&gt;&lt;a href=&quot;../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;typename T::value_type&amp;gt;&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;value_type&lt;/code&gt; 멤버가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="39ce0657db5851a914118e622ff40c59946e1ecd" translate="yes" xml:space="preserve">
          <source>5) Specialization for types that do not define a public and accessible member type &lt;code&gt;difference_type&lt;/code&gt; but do support subtraction. Provides a member type &lt;code&gt;difference_type&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;../types/make_signed&quot;&gt;std::make_signed_t&lt;/a&gt;&amp;lt;decltype(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;() - &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;())&amp;gt;&lt;/code&gt;. The implicit expression variations rule (see below) applies to the expression &lt;code&gt;a - b&lt;/code&gt;.</source>
          <target state="translated">5) 공개 및 액세스 가능한 멤버 유형 &lt;code&gt;difference_type&lt;/code&gt; 을 정의하지 않지만 빼기를 지원 하는 유형의 전문화 . &lt;code&gt;&lt;a href=&quot;../types/make_signed&quot;&gt;std::make_signed_t&lt;/a&gt;&amp;lt;decltype(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;() - &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;())&amp;gt;&lt;/code&gt; &amp;lt;decltype ( &lt;a href=&quot;../utility/declval&quot;&gt;std :: declval&lt;/a&gt; &amp;lt;T&amp;gt; () &lt;a href=&quot;../utility/declval&quot;&gt;-std :: declval&lt;/a&gt; &amp;lt;T&amp;gt; ())&amp;gt; &lt;code&gt;difference_type&lt;/code&gt; 동일한 멤버 유형 difference_type을 제공합니다 . 암시 적 표현식 변형 규칙 (아래 참조)은 표현식 &lt;code&gt;a - b&lt;/code&gt; 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="04fc752359d7ba911944160b35c08058d83d5a78" translate="yes" xml:space="preserve">
          <source>5) Stores the shared pointer &lt;code&gt;r&lt;/code&gt; in the shared pointer pointed-to by &lt;code&gt;p&lt;/code&gt; atomically, effectively executing &lt;code&gt;p-&amp;gt;swap(r)&lt;/code&gt;. As with the non-specialized &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store_explicit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;mo&lt;/code&gt; cannot be &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">5) 공유 포인터 &lt;code&gt;r&lt;/code&gt; 을 &lt;code&gt;p&lt;/code&gt; 가 가리키는 공유 포인터에 원자 적으로 저장하여 &lt;code&gt;p-&amp;gt;swap(r)&lt;/code&gt; 효과적으로 실행 합니다. 비 전문과 마찬가지로 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store_explicit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;mo&lt;/code&gt; 수 없습니다 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d82531d8f48e822de4438011a5e1d52338ce5a4" translate="yes" xml:space="preserve">
          <source>5) Subtracts &lt;code&gt;dm.count()&lt;/code&gt; months from the date represented by &lt;code&gt;ymd&lt;/code&gt;. Equivalent to &lt;code&gt;ymd + -dm&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;ymd&lt;/code&gt; 로 표시된 날짜에서 &lt;code&gt;dm.count()&lt;/code&gt; 개월을 뺍니다 . &lt;code&gt;ymd + -dm&lt;/code&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ff3be7b84fad89f4220d17fe390299e2e482b172" translate="yes" xml:space="preserve">
          <source>5) Subtracts &lt;code&gt;dm.count()&lt;/code&gt; months from the date represented by &lt;code&gt;ymdl&lt;/code&gt;. Equivalent to &lt;code&gt;ymdl + -dm&lt;/code&gt;.</source>
          <target state="translated">5) 뺍 &lt;code&gt;dm.count()&lt;/code&gt; 일로부터 개월로 표현 &lt;code&gt;ymdl&lt;/code&gt; . &lt;code&gt;ymdl + -dm&lt;/code&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="492fb93395abca99e5edca58e56d213bc862730a" translate="yes" xml:space="preserve">
          <source>5) Subtracts &lt;code&gt;dm.count()&lt;/code&gt; months from the date represented by &lt;code&gt;ymwd&lt;/code&gt;. Equivalent to &lt;code&gt;ymwd + -dm&lt;/code&gt;.</source>
          <target state="translated">5) 뺍 &lt;code&gt;dm.count()&lt;/code&gt; 일로부터 개월로 표현 &lt;code&gt;ymwd&lt;/code&gt; . &lt;code&gt;ymwd + -dm&lt;/code&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9bdbddd1e5dc7478067a29cb3e1cf44a41d3f8b0" translate="yes" xml:space="preserve">
          <source>5) Subtracts &lt;code&gt;dm.count()&lt;/code&gt; months from the date represented by &lt;code&gt;ymwdl&lt;/code&gt;. Equivalent to &lt;code&gt;ymwdl+ -dm&lt;/code&gt;.</source>
          <target state="translated">5) 뺍 &lt;code&gt;dm.count()&lt;/code&gt; 일로부터 개월로 표현 &lt;code&gt;ymwdl&lt;/code&gt; . &lt;code&gt;ymwdl+ -dm&lt;/code&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="397e71b40a492e037857a54b54c4768d5645654e" translate="yes" xml:space="preserve">
          <source>5) Subtracts &lt;code&gt;dy.count()&lt;/code&gt; years from &lt;code&gt;ym&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;ym&lt;/code&gt; 에서 &lt;code&gt;dy.count()&lt;/code&gt; 년을 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="d310d2ca1f14efcbeed3ea227990cf4453d49b5d" translate="yes" xml:space="preserve">
          <source>5) The &lt;code&gt;thread_local&lt;/code&gt; keyword is only allowed for objects declared at namespace scope, objects declared at block scope, and static data members. It indicates that the object has thread storage duration. It can be combined with &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;extern&lt;/code&gt; to specify internal or external linkage (except for static data members which always have external linkage), respectively, but that additional &lt;code&gt;static&lt;/code&gt; doesn't affect the storage duration.</source>
          <target state="translated">5) &lt;code&gt;thread_local&lt;/code&gt; 키워드는 네임 스페이스 범위에서 선언 된 객체, 블록 범위에서 선언 된 객체 및 정적 데이터 멤버에만 허용됩니다. 개체에 스레드 저장 기간이 있음을 나타냅니다. 내부 또는 외부 연결 (항상 외부 연결이있는 정적 데이터 멤버 제외)을 지정하기 위해 &lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;extern&lt;/code&gt; 과 결합 할 수 있지만 추가 &lt;code&gt;static&lt;/code&gt; 은 스토리지 기간에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bcae2d65ad7cf646a73245e3cb727836b914dd80" translate="yes" xml:space="preserve">
          <source>5) The copy constructor is deleted, wstring_convert is not &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">5) 생성자가 삭제되는 복사, wstring_convert은 아니다 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad6618ca638a194e7364157ad272db3f60ee2d42" translate="yes" xml:space="preserve">
          <source>5) The copy constructor is explicitly defaulted.</source>
          <target state="translated">5) 복사 생성자가 명시 적으로 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2922b675b4c827968351c97bca1778d22a7c7b02" translate="yes" xml:space="preserve">
          <source>5) The parameter &lt;code&gt;P&lt;/code&gt;, whose &lt;code&gt;A&lt;/code&gt; is a function or a set of overloads such that more than one function matches &lt;code&gt;P&lt;/code&gt; or no function matches &lt;code&gt;P&lt;/code&gt; or the set of overloads includes one or more function templates:</source>
          <target state="translated">5) 파라미터 &lt;code&gt;P&lt;/code&gt; 누구, &lt;code&gt;A&lt;/code&gt; 는 기능이나 과부하의 세트는 하나 개 이상의 기능이 일치되도록 &lt;code&gt;P&lt;/code&gt; 또는 함수가 일치하지 &lt;code&gt;P&lt;/code&gt; 또는 과부하들의 세트는 하나 이상의 기능 템플릿을 포함한다 :</target>
        </trans-unit>
        <trans-unit id="a802bfc55314a42fe53bfa7c2f055512c2c468b1" translate="yes" xml:space="preserve">
          <source>5) The return type (see Return value below)</source>
          <target state="translated">5) 반환 유형 (아래 반환 값 참조)</target>
        </trans-unit>
        <trans-unit id="caba53ef3326de402781a474a7df7100200eb2ea" translate="yes" xml:space="preserve">
          <source>5) This overload only participates in overload resolution if T is a specialization of std::pair. Equivalent to</source>
          <target state="translated">5)이 과부하는 T가 std :: pair의 전문화 인 경우에만 과부하 해결에 참여합니다. 에 해당</target>
        </trans-unit>
        <trans-unit id="0d2459491b96d1b7ababe00af6295534a62e99da" translate="yes" xml:space="preserve">
          <source>5) Throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;index &amp;gt; size()&lt;/code&gt; or if &lt;code&gt;index_str &amp;gt; str.size()&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;index &amp;gt; size()&lt;/code&gt; 또는 &lt;code&gt;index_str &amp;gt; str.size()&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="7287903a06e3cc64d92cadd2d74e6c532b4d4155" translate="yes" xml:space="preserve">
          <source>5) Tries to lock the associated mutex in shared mode without blocking by calling &lt;code&gt;m.try_lock_shared()&lt;/code&gt;. The behavior is undefined if this thread already owns the mutex in any mode.</source>
          <target state="translated">5) &lt;code&gt;m.try_lock_shared()&lt;/code&gt; 를 호출하여 차단하지 않고 공유 뮤텍스를 공유 모드로 잠그려고 시도합니다 . 이 스레드가 이미 모든 모드에서 뮤텍스를 소유 한 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="123118f05c4a179530707bca6d89a21c0429cd2c" translate="yes" xml:space="preserve">
          <source>5) Tries to lock the associated mutex without blocking by calling &lt;code&gt;m.try_lock()&lt;/code&gt;. The behavior is undefined if the current thread already owns the mutex except when the mutex is recursive.</source>
          <target state="translated">5) &lt;code&gt;m.try_lock()&lt;/code&gt; 을 호출하여 차단하지 않고 연관된 뮤텍스를 잠그려고 시도합니다 . 뮤텍스가 재귀적일 때를 제외하고 현재 스레드가 이미 뮤텍스를 소유 한 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7e4501661746e429d5a84c0f169aface9962cee" translate="yes" xml:space="preserve">
          <source>5) UTF-32 encoded string literal. The type of a &lt;code&gt;U&quot;...&quot;&lt;/code&gt; string literal is &lt;code&gt;const char32_t[N]&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the size of the string in UTF-32 code units including the null terminator.</source>
          <target state="translated">5) UTF-32 인코딩 문자열 리터럴. &lt;code&gt;U&quot;...&quot;&lt;/code&gt; 문자열 리터럴 의 유형 은 &lt;code&gt;const char32_t[N]&lt;/code&gt; . 여기서 &lt;code&gt;N&lt;/code&gt; 은 널 종료 자를 포함하여 UTF-32 코드 단위의 문자열 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f059f5f480058e1565700f191d5162442600cbe6" translate="yes" xml:space="preserve">
          <source>5) When a &lt;a href=&quot;data_members&quot;&gt;non-static data member&lt;/a&gt; of reference type is initialized using a &lt;a href=&quot;constructor&quot;&gt;member initializer&lt;/a&gt;</source>
          <target state="translated">5) &lt;a href=&quot;constructor&quot;&gt;멤버 이니셜&lt;/a&gt; 라이저를 사용하여 참조 유형 의 &lt;a href=&quot;data_members&quot;&gt;비 정적 데이터 멤버&lt;/a&gt; 가 초기화 된 경우</target>
        </trans-unit>
        <trans-unit id="b7104bdb96e1f7682860a3f6f850a805e5a14964" translate="yes" xml:space="preserve">
          <source>5) a &lt;a href=&quot;../language/noexcept_spec&quot;&gt;noexcept specification&lt;/a&gt; is violated (it is implementation-defined whether any stack unwinding is done in this case)</source>
          <target state="translated">5) &lt;a href=&quot;../language/noexcept_spec&quot;&gt;noexcept 사양&lt;/a&gt; 을 위반합니다 (이 경우 스택 해제가 수행되는지 여부는 구현에 따라 다릅니다 )</target>
        </trans-unit>
        <trans-unit id="c6438e84fecbd707b0f06572113c55e5958815d5" translate="yes" xml:space="preserve">
          <source>5) average case linear worst case quadratic in size of &lt;code&gt;init&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;init&lt;/code&gt; 크기의 평균 경우 선형 최악의 2 차</target>
        </trans-unit>
        <trans-unit id="b9f1ad5acade13e7a3df2e9d594ed8c05cd4cf1c" translate="yes" xml:space="preserve">
          <source>5) characters in the range &lt;code&gt;[cstr, cstr + Traits::length(cstr))&lt;/code&gt;;</source>
          <target state="translated">5) &lt;code&gt;[cstr, cstr + Traits::length(cstr))&lt;/code&gt; 범위의 문자 ;</target>
        </trans-unit>
        <trans-unit id="73fb71428eca9210bf31f4d72b14516f7f02b76a" translate="yes" xml:space="preserve">
          <source>5) constructs the container with the contents of the initializer list &lt;code&gt;init&lt;/code&gt;, same as unordered_map(init.begin(), init.end()).</source>
          <target state="translated">5) 이니셜 라이저리스트 &lt;code&gt;init&lt;/code&gt; 의 내용 으로 unordered_map (init.begin (), init.end ())와 같은 컨테이너를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="f18fc419099f0458c08928534925786e23ebd2f1" translate="yes" xml:space="preserve">
          <source>5) constructs the container with the contents of the initializer list &lt;code&gt;init&lt;/code&gt;, same as unordered_multimap(init.begin(), init.end()).</source>
          <target state="translated">5) 이니셜 라이저리스트 &lt;code&gt;init&lt;/code&gt; 의 내용으로 컨테이너를 구성합니다. un order_multimap (init.begin (), init.end ())</target>
        </trans-unit>
        <trans-unit id="b1e4f3b089d7246d2db1cff61ea7b78398615875" translate="yes" xml:space="preserve">
          <source>5) constructs the container with the contents of the initializer list &lt;code&gt;init&lt;/code&gt;, same as unordered_multiset(init.begin(), init.end()).</source>
          <target state="translated">5) 이니셜 라이저리스트 &lt;code&gt;init&lt;/code&gt; 의 내용으로 컨테이너를 구성합니다. uninst_multiset (init.begin (), init.end ())</target>
        </trans-unit>
        <trans-unit id="91d878411760cad875f5da0feb1006bbbfe7e196" translate="yes" xml:space="preserve">
          <source>5) constructs the container with the contents of the initializer list &lt;code&gt;init&lt;/code&gt;, same as unordered_set(init.begin(), init.end()).</source>
          <target state="translated">5) 이니셜 라이저리스트 &lt;code&gt;init&lt;/code&gt; 의 내용 으로 unordered_set (init.begin (), init.end ())와 같은 컨테이너를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="7f30623f10e9d9ed86e7e59f5be6fc2f8530265f" translate="yes" xml:space="preserve">
          <source>5) if &lt;code&gt;E2&lt;/code&gt; is a member enumerator, the result is a prvalue equal to that member enumerator of &lt;code&gt;E1&lt;/code&gt;;</source>
          <target state="translated">5) &lt;code&gt;E2&lt;/code&gt; 가 멤버 열거자인 경우 결과는 &lt;code&gt;E1&lt;/code&gt; 의 해당 멤버 열거 자와 동일한 prvalue입니다 .</target>
        </trans-unit>
        <trans-unit id="3e2b89df59f627941f2655a60490b52c2f88f3b2" translate="yes" xml:space="preserve">
          <source>5) if the &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;dynamic type&lt;/a&gt; of &lt;code&gt;E1&lt;/code&gt; does not contain the member to which &lt;code&gt;E2&lt;/code&gt; refers, the behavior is undefined;</source>
          <target state="translated">5) &lt;code&gt;E1&lt;/code&gt; 의 &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;동적 유형&lt;/a&gt; 에 &lt;code&gt;E2&lt;/code&gt; 가 참조 하는 구성원이 포함되어 있지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="464d1467a32873f9e760c6e4a6d3b959b563d23f" translate="yes" xml:space="preserve">
          <source>5) in a &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; of a constructor if</source>
          <target state="translated">5) 생성자 의 &lt;a href=&quot;constructor&quot;&gt;멤버 이니셜 라이저 목록&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="7517954b727767932ecad9c840d50e1e0b95228a" translate="yes" xml:space="preserve">
          <source>5) initialization of an object with dynamic storage duration by a new-expression with a non-empty initializer</source>
          <target state="translated">5) 비어 있지 않은 이니셜 라이저를 사용하여 새로운 표현식으로 동적 저장 시간이있는 객체 초기화</target>
        </trans-unit>
        <trans-unit id="1a5aff1f42fb8b7a4a4fa807e9d4a43badbc6849" translate="yes" xml:space="preserve">
          <source>5) inserts elements from initializer list &lt;code&gt;ilist&lt;/code&gt; before &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;pos&lt;/code&gt; 앞에 이니셜 라이저 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="b69cf7eb946acc2e1dc5569551c00118c1ab1a8c" translate="yes" xml:space="preserve">
          <source>5) inserts elements from initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">5) 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="b75f645585a49660dbf44053b43a7c822435e517" translate="yes" xml:space="preserve">
          <source>5) inserts elements from range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="b77c18f073e90c1a0baf03602711db1edaead596" translate="yes" xml:space="preserve">
          <source>5) jump statements;</source>
          <target state="translated">5) 점프 진술;</target>
        </trans-unit>
        <trans-unit id="cd92a127893bfbb093da10b4404c7edb33a8e709" translate="yes" xml:space="preserve">
          <source>5) linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;count&lt;/code&gt; 선형</target>
        </trans-unit>
        <trans-unit id="954d61ca6665dabc6ef568eb79256ca7fd9cd939" translate="yes" xml:space="preserve">
          <source>5) linear in length of &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">길이 5) 직선 &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39ada8c7056dac2506b13c940605a6442240be6e" translate="yes" xml:space="preserve">
          <source>5) linear in size of &lt;code&gt;ilist&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;ilist&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="d029bb55b73cb5c94af658141aa2fa1c6207b702" translate="yes" xml:space="preserve">
          <source>5) or, if not that, F1 and F2 are both template specializations and F1 is</source>
          <target state="translated">5) 또는 그렇지 않은 경우 F1과 F2는 모두 템플릿 전문화이고 F1은</target>
        </trans-unit>
        <trans-unit id="2546b839489b588a5bb18f5b67f87e2fb91ffde7" translate="yes" xml:space="preserve">
          <source>5) returns &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::wstring&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::wstring&lt;/a&gt;{str, len}&lt;/code&gt; {str, len}을 반환</target>
        </trans-unit>
        <trans-unit id="4ea0061cf0448e7630ccfa5d512bf47453091c56" translate="yes" xml:space="preserve">
          <source>5) returns &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::wstring_view&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::wstring_view&lt;/a&gt;{str, len}&lt;/code&gt; {str, len}을 반환</target>
        </trans-unit>
        <trans-unit id="5de25f0a3669b1fd1e0a9d5a77f0c72379be268b" translate="yes" xml:space="preserve">
          <source>5) same as &lt;code&gt;get(strbuf, widen('\n'))&lt;/code&gt;, that is, reads available characters and inserts them to the given &lt;a href=&quot;../basic_streambuf&quot;&gt;&lt;code&gt;basic_streambuf&lt;/code&gt;&lt;/a&gt; object until &lt;code&gt;'\n'&lt;/code&gt; is found.</source>
          <target state="translated">5) &lt;code&gt;get(strbuf, widen('\n'))&lt;/code&gt; 과 동일합니다. 즉, 사용 가능한 문자를 읽고 &lt;code&gt;'\n'&lt;/code&gt; 을 찾을 때까지 주어진 &lt;a href=&quot;../basic_streambuf&quot;&gt; &lt;code&gt;basic_streambuf&lt;/code&gt; &lt;/a&gt; 객체에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="7c149ac07932add93976c5fc10082d81e516f6af" translate="yes" xml:space="preserve">
          <source>5) simple by-reference capture that is a &lt;a href=&quot;parameter_pack&quot;&gt;pack expansion&lt;/a&gt;</source>
          <target state="translated">5) &lt;a href=&quot;parameter_pack&quot;&gt;팩 확장 인&lt;/a&gt; 간단한 참조 캡처</target>
        </trans-unit>
        <trans-unit id="6428adbd346e9cdf1c532304543759352b3651a1" translate="yes" xml:space="preserve">
          <source>5) the &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; statement</source>
          <target state="translated">5) &lt;a href=&quot;return&quot;&gt;반환&lt;/a&gt; 진술</target>
        </trans-unit>
        <trans-unit id="837e7c24de0ad3bda77c6b118c961790eab4c217" translate="yes" xml:space="preserve">
          <source>5) when &lt;a href=&quot;throw&quot;&gt;throwing&lt;/a&gt; or &lt;a href=&quot;try_catch&quot;&gt;catching&lt;/a&gt; an exception by value</source>
          <target state="translated">5) 가치에 의해 예외를 &lt;a href=&quot;throw&quot;&gt;던지&lt;/a&gt; 거나 &lt;a href=&quot;try_catch&quot;&gt;잡을&lt;/a&gt; 때</target>
        </trans-unit>
        <trans-unit id="ab6f43d9577c2727bbf7a45175b11edbced30ba7" translate="yes" xml:space="preserve">
          <source>5) wide character literal, e.g. &lt;code&gt;L'&amp;beta;'&lt;/code&gt; or &lt;code&gt;L'貓'&lt;/code&gt;. Such literal has type &lt;code&gt;wchar_t&lt;/code&gt; and the value equal to the value of c-char in the execution wide character set. If c-char is not representable in the execution character set (e.g. a non-BMP value on Windows where wchar_t is 16-bit), the value of the literal is implementation-defined.</source>
          <target state="translated">5) 넓은 문자 리터럴 (예 : &lt;code&gt;L'&amp;beta;'&lt;/code&gt; 또는 &lt;code&gt;L'貓'&lt;/code&gt; . 이러한 리터럴에는 &lt;code&gt;wchar_t&lt;/code&gt; 유형 과 실행 와이드 문자 세트의 c-char 값과 동일한 값이 있습니다. 실행 문자 세트에서 c-char를 표현할 수없는 경우 (예 : wchar_t가 16 비트 인 Windows의 BMP 이외의 값) 리터럴 값은 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="79becf5de541f3b81bd7f966f6e9ad3f12f605b6" translate="yes" xml:space="preserve">
          <source>5)&lt;a href=&quot;../../language/list_initialization&quot;&gt;Initializer-list constructor&lt;/a&gt;. Constructs the container with the contents of the initializer list &lt;code&gt;init&lt;/code&gt;. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;LWG2844&lt;/a&gt;).</source>
          <target state="translated">5) &lt;a href=&quot;../../language/list_initialization&quot;&gt;이니셜 라이저 목록 생성자&lt;/a&gt; . 이니셜 라이저리스트 &lt;code&gt;init&lt;/code&gt; 의 내용으로 컨테이너를 구축합니다 . 범위의 여러 요소에 동등한 키가있는 경우 삽입 할 요소가 지정되지 &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;않습니다&lt;/a&gt; ( LWG2844 보류 중 ).</target>
        </trans-unit>
        <trans-unit id="a7ab4edfd8b0470e43f2f7c5983c0736b1f26653" translate="yes" xml:space="preserve">
          <source>5)&lt;a href=&quot;derived_class#Protected_inheritance&quot;&gt;Protected inheritance&lt;/a&gt;: the public and protected members of the &lt;a href=&quot;derived_class&quot;&gt;base class&lt;/a&gt; listed after the specifier are protected members of the derived class</source>
          <target state="translated">5) &lt;a href=&quot;derived_class#Protected_inheritance&quot;&gt;상속 상속&lt;/a&gt; : 지정자 뒤에 나열된 &lt;a href=&quot;derived_class&quot;&gt;기본 클래스&lt;/a&gt; 의 공개 및 보호 멤버 는 파생 클래스의 보호 멤버입니다.</target>
        </trans-unit>
        <trans-unit id="3fc0347fc0a4c85ee7afb9b34278b306e8c89f48" translate="yes" xml:space="preserve">
          <source>5)&lt;a href=&quot;fold&quot;&gt;Fold-expressions&lt;/a&gt;(C++17)</source>
          <target state="translated">5)&lt;a href=&quot;fold&quot;&gt;Fold-expressions&lt;/a&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="71783b7ee6f3a7f7a5005886d186040fe7b5d58d" translate="yes" xml:space="preserve">
          <source>5)&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; statement.</source>
          <target state="translated">5) &lt;a href=&quot;goto&quot;&gt;고토&lt;/a&gt; 진술.</target>
        </trans-unit>
        <trans-unit id="75008421048c33fa26da233cee00966db8d4b246" translate="yes" xml:space="preserve">
          <source>5)&lt;a href=&quot;member_template&quot;&gt;member templates&lt;/a&gt; (variable templates, (since C++14)class templates or function templates) may appear in the body of any non-local class/struct/union.</source>
          <target state="translated">5) &lt;a href=&quot;member_template&quot;&gt;멤버 템플릿&lt;/a&gt; (가변 템플릿, (C ++ 14 이후) 클래스 템플릿 또는 함수 템플릿)은 로컬이 아닌 클래스 / 구조 / 연합의 본문에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="623850cbe722dc74cf9caba1bb2ec026d39a4e3a" translate="yes" xml:space="preserve">
          <source>5)&lt;a href=&quot;namespace#Using-directives&quot;&gt;using-directive&lt;/a&gt;: From the point of view of unqualified &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; of any name after a using-directive and until the end of the scope in which it appears, every name from ns_name is visible as if it were declared in the nearest enclosing namespace which contains both the using-directive and ns_name.</source>
          <target state="translated">5) &lt;a href=&quot;namespace#Using-directives&quot;&gt;using-directive&lt;/a&gt; : using-directive 이후의 &lt;a href=&quot;lookup&quot;&gt;이름에&lt;/a&gt; 대한 규정되지 않은 이름 조회 관점에서 이름 이 표시되는 범위 끝까지 ns_name의 모든 이름은 가장 가까운 엔 클로징에서 선언 된 것처럼 표시됩니다. using 지시문과 ns_name을 모두 포함하는 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="cdb96b96cddc6a663b3066e572ff653b35a1221a" translate="yes" xml:space="preserve">
          <source>5)&lt;a href=&quot;pointer&quot;&gt;Pointer to member declaration&lt;/a&gt;: the declaration &lt;code&gt;S C::* D;&lt;/code&gt; declares &lt;code&gt;D&lt;/code&gt; as a pointer to member of &lt;code&gt;C&lt;/code&gt; of type determined by decl-specifier-seq&lt;code&gt;S&lt;/code&gt;. nested-name-specifier is a &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;sequence of names and scope resolution operators &lt;code&gt;::&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">5) &lt;a href=&quot;pointer&quot;&gt;멤버 선언의 포인터&lt;/a&gt; : 선언 &lt;code&gt;S C::* D;&lt;/code&gt; decl-specifier-seq &lt;code&gt;S&lt;/code&gt; 에 의해 결정된 &lt;code&gt;C&lt;/code&gt; 유형의 멤버에 대한 포인터로 &lt;code&gt;D&lt;/code&gt; 를 선언 합니다 . 중첩 이름 지정자는 &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;일련의 이름 및 범위 확인 연산자입니다. &lt;/a&gt; &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5c59c59d5845b469e564c26fd8012cfeccd9c38" translate="yes" xml:space="preserve">
          <source>5)&lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; declarations</source>
          <target state="translated">5) &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; 선언</target>
        </trans-unit>
        <trans-unit id="a55ff9685555b602270d3c1faa45f371544be706" translate="yes" xml:space="preserve">
          <source>5)&lt;a href=&quot;user_literal&quot;&gt;user-defined literal&lt;/a&gt;.</source>
          <target state="translated">5) &lt;a href=&quot;user_literal&quot;&gt;사용자 정의 리터럴&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="372d66c158a94cfa9d9c82ea2fc143d144599944" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;!(rhs &amp;lt; lhs)&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;!(rhs &amp;lt; lhs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6abc09fd3f5dc42ba8a517b3f8f1972f467fee13" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;!(y &amp;lt; x)&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;!(y &amp;lt; x)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2bf60f45bf9500f708301813baaba05723732ff" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;&lt;a href=&quot;utc_clock/from_sys&quot;&gt;std::chrono::utc_clock::from_sys&lt;/a&gt;(t)&lt;/code&gt;.</source>
          <target state="translated">5)&lt;code&gt;&lt;a href=&quot;utc_clock/from_sys&quot;&gt;std::chrono::utc_clock::from_sys&lt;/a&gt;(t)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="55f5a5afbcac9a962110c2ead8b28e81bc6547e3" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;CD(CD(d).count() / s).&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;CD(CD(d).count() / s).&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70007c496049dcf55c8cb3ababdee25acba4328f" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;cmp &amp;gt; 0&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;cmp &amp;gt; 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55032028bf044073d8ff8a4d36118ddf61163192" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;cref(t.get())&lt;/code&gt;</source>
          <target state="translated">5)&lt;code&gt;cref(t.get())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90b476482f0715868391e9584bc5b228d0b1fa30" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;find_if_not&lt;/code&gt; searches for an element for which predicate &lt;code&gt;q&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;find_if_not&lt;/code&gt; 은 술어 &lt;code&gt;q&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는 요소를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="f91e9d42720355af506f0946e1175b318860bc01" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;int(x) &amp;gt; int(y)&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;int(x) &amp;gt; int(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e462ab28f2c82ae2ef054d1023d01b43d5ed99c1" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;lhs.base() &amp;gt; rhs.base()&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;lhs.base() &amp;gt; rhs.base()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0502d5d5dfcca793e4eb38c0bd9d103035e79579" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;lhs.base() &amp;lt; rhs.base()&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;lhs.base() &amp;lt; rhs.base()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264d7c06a8be576b831a8a4d469b07a2bb2a0b0b" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;path() &amp;gt; rhs.path()&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">5) &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;path() &amp;gt; rhs.path()&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="bd4e0a1ad59f2b3508cf49dc8404123b1e5228dc" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;true&lt;/code&gt; if neither &lt;code&gt;code.category().equivalent(code.value(), cond)&lt;/code&gt; nor &lt;code&gt;cond.category().equivalent(code, cond.value())&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;true&lt;/code&gt; 하는 경우도 &lt;code&gt;code.category().equivalent(code.value(), cond)&lt;/code&gt; 도 &lt;code&gt;cond.category().equivalent(code, cond.value())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d229d5cda6f7edbf2846c3db36a52c1649cefb7c" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;lhs&lt;/code&gt; refers to time point</source>
          <target state="translated">5) &lt;code&gt;lhs&lt;/code&gt; 가 시점을 참조 하면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fee74e705178352a63bff1e126ce562fa433a5d6" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;true&lt;/code&gt; if the contents of the &lt;code&gt;lhs&lt;/code&gt; are lexicographically</source>
          <target state="translated">5) &lt;code&gt;lhs&lt;/code&gt; 의 내용 이 사전 식 으로되어 있으면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9dca88eda9be56075f427fd8734475d6bc77ae3d" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;unsigned(x) &amp;gt; unsigned(y)&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;unsigned(x) &amp;gt; unsigned(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7afc3fa41b688f9caf4299fafed930b20f62e68" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;weekday()[index()]&lt;/code&gt;.</source>
          <target state="translated">5)&lt;code&gt;weekday()[index()]&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="96b83a13d27c5891e3c8abd050d81606c833c1fa" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;x.date() &amp;lt;= y.date()&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;x.date() &amp;lt;= y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef9c39af03d6a882cc48ce467466e90ec4fe55d9" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;x.month() &amp;lt;= y.month()&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;x.month() &amp;lt;= y.month()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f0dfa223d86298f1abb8535eb528b7a85b020f6" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;x.name() &amp;lt;= y.name()&lt;/code&gt;.</source>
          <target state="translated">5) &lt;code&gt;x.name() &amp;lt;= y.name()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2766cbf5c96d65c96344ffacb5bd6d9636de612d" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;ym + -dm&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;ym + -dm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7943e4e5eff0b1a04fbdd4af2cacf4921f4b4ee" translate="yes" xml:space="preserve">
          <source>5)&lt;code&gt;ym + -dy&lt;/code&gt;</source>
          <target state="translated">5) &lt;code&gt;ym + -dy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1762e2babbf600f37bee14337629a7193fa04138" translate="yes" xml:space="preserve">
          <source>5,10) Does not throw if &lt;code&gt;f&lt;/code&gt; is a function pointer or a &lt;code&gt;&lt;a href=&quot;../reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, otherwise may throw &lt;code&gt;&lt;a href=&quot;../../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or any exception thrown by the copy constructor of the stored callable object.</source>
          <target state="translated">5,10) &lt;code&gt;f&lt;/code&gt; 가 함수 포인터이거나 &lt;code&gt;&lt;a href=&quot;../reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; 이면 throw하지 않습니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 또는 저장된 호출 가능 객체의 복사 생성자가 던진 예외 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9253ca42846ce55db8efdd25c7cb4969fb859df8" translate="yes" xml:space="preserve">
          <source>5,7) At most min(&lt;code&gt;last1&lt;/code&gt; - &lt;code&gt;first1&lt;/code&gt;, &lt;code&gt;last2&lt;/code&gt; - &lt;code&gt;first2&lt;/code&gt;) applications of the predicate.</source>
          <target state="translated">5,7) 술어의 최대 최소 ( &lt;code&gt;last1&lt;/code&gt; - &lt;code&gt;first1&lt;/code&gt; , &lt;code&gt;last2&lt;/code&gt; - &lt;code&gt;first2&lt;/code&gt; ) 응용 프로그램.</target>
        </trans-unit>
        <trans-unit id="6f6b98ae71fc99eb2ed19166b966e50b106b6f2d" translate="yes" xml:space="preserve">
          <source>5,7) Returns &lt;code&gt;true&lt;/code&gt; if the range &lt;code&gt;[first1, last1)&lt;/code&gt; is equal to the range &lt;code&gt;[first2, last2)&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">5,7)를 반환 &lt;code&gt;true&lt;/code&gt; 범위 경우 &lt;code&gt;[first1, last1)&lt;/code&gt; 범위와 동일하다 &lt;code&gt;[first2, last2)&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="798af517c85eda53f42e59ed50e9639c04f3762f" translate="yes" xml:space="preserve">
          <source>5,7)&lt;code&gt;&lt;a href=&quot;month_day&quot;&gt;std::chrono::month_day&lt;/a&gt;(&lt;a href=&quot;month&quot;&gt;std::chrono::month&lt;/a&gt;(m), d)&lt;/code&gt;</source>
          <target state="translated">5,7) &lt;code&gt;&lt;a href=&quot;month_day&quot;&gt;std::chrono::month_day&lt;/a&gt;(&lt;a href=&quot;month&quot;&gt;std::chrono::month&lt;/a&gt;(m), d)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="230b52df33456809ce7b5e5d8ec93d5bf6adcffa" translate="yes" xml:space="preserve">
          <source>5-6) (none)</source>
          <target state="translated">5-6) (없음)</target>
        </trans-unit>
        <trans-unit id="3b8b8cae60dcf1d50a289a50bf314d08eece6b47" translate="yes" xml:space="preserve">
          <source>5-6) Assigns the state of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">5-6) &lt;code&gt;other&lt;/code&gt; 의 상태를 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="384070767fc2987336f2794c401f09762999c2cf" translate="yes" xml:space="preserve">
          <source>5-6) Average case: &lt;code&gt;O(N)&lt;/code&gt;, where N is the number of elements to insert. Worse case: &lt;code&gt;O(N*size()+N)&lt;/code&gt;</source>
          <target state="translated">5-6) 평균 사례 : &lt;code&gt;O(N)&lt;/code&gt; . 여기서 N은 삽입 할 요소 수입니다. 최악의 경우 : &lt;code&gt;O(N*size()+N)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8e773751a771ba3f9c727f0d7cfaf9a2fed3fe0" translate="yes" xml:space="preserve">
          <source>5-6) Average case: &lt;code&gt;O(N)&lt;/code&gt;, where N is the number of elements to insert. Worst case: &lt;code&gt;O(N*size()+N)&lt;/code&gt;</source>
          <target state="translated">5-6) 평균 사례 : &lt;code&gt;O(N)&lt;/code&gt; . 여기서 N은 삽입 할 요소 수입니다. 최악의 경우 : &lt;code&gt;O(N*size()+N)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f6da76834c8c096ab8b9fbf5c9a55fa84e19e5d" translate="yes" xml:space="preserve">
          <source>5-6) Called instead of (1-2) if a user-defined replacement is provided, except that it's unspecified whether (1-2) or (5-6) is called when deleting objects of incomplete type and arrays of non-class and trivially-destructible class types. A memory allocator can use the given size to be more efficient. The standard library implementations are identical to (1-2).</source>
          <target state="translated">5-6) 불완전한 유형의 객체와 비 배열의 배열을 삭제할 때 (1-2) 또는 (5-6)이 호출되는지 여부를 지정하지 않은 것을 제외하고 사용자 정의 대체가 제공되는 경우 (1-2) 대신 호출됩니다. 클래스 및 사소하게 파괴 가능한 클래스 유형. 메모리 할당자는 주어진 크기를보다 효율적으로 사용할 수 있습니다. 표준 라이브러리 구현은 (1-2)와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5bea2ec400fc3ed22b278e3d2eb2f66e89451cbd" translate="yes" xml:space="preserve">
          <source>5-6) Constructs a copy of &lt;code&gt;other&lt;/code&gt; except for all the facets identified by the &lt;code&gt;cat&lt;/code&gt; argument, which are copied from the system locale identified by its &lt;code&gt;std_name&lt;/code&gt;. The locale constructed in this manner has a name if and only if &lt;code&gt;other&lt;/code&gt; has a name.</source>
          <target state="translated">5-6) &lt;code&gt;cat&lt;/code&gt; 인수로 식별 된 모든 패싯을 제외 하고 &lt;code&gt;std_name&lt;/code&gt; 으로 식별 된 시스템 로케일에서 복사 된 &lt;code&gt;other&lt;/code&gt; 패싯을 제외한 다른 사본을 구성합니다 . 그리고 경우에만 경우 이러한 방식으로 구성된 로케일 이름을 가진 &lt;code&gt;other&lt;/code&gt; 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cebd5329e254b163adbe66195e04480e4c79d21" translate="yes" xml:space="preserve">
          <source>5-6) Constructs an empty string &lt;code&gt;result&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT&amp;gt;&lt;/code&gt; and calls &lt;code&gt;std::regex_replace(&lt;a href=&quot;../iterator/back_inserter&quot;&gt;std::back_inserter&lt;/a&gt;(result), s, s + &lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;CharT&amp;gt;::length(s), re, fmt, flags)&lt;/code&gt;.</source>
          <target state="translated">5-6) &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT&amp;gt;&lt;/code&gt; &amp;lt;CharT&amp;gt; 유형 의 빈 문자열 &lt;code&gt;result&lt;/code&gt; 를 구성 하고 &lt;code&gt;std::regex_replace(&lt;a href=&quot;../iterator/back_inserter&quot;&gt;std::back_inserter&lt;/a&gt;(result), s, s + &lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;CharT&amp;gt;::length(s), re, fmt, flags)&lt;/code&gt; &lt;a href=&quot;../iterator/back_inserter&quot;&gt;std :: back_inserter&lt;/a&gt; (result), s, s + &lt;a href=&quot;../string/char_traits&quot;&gt;std :: char_traits&lt;/a&gt; &amp;lt;CharT&amp;gt; :: length (s)를 호출합니다. , re, fmt, flags) .</target>
        </trans-unit>
        <trans-unit id="72649579a1392e666662f81b107e2955e1a94184" translate="yes" xml:space="preserve">
          <source>5-6) Returns an iterator which is advanced by &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;-n&lt;/code&gt; positions respectively.</source>
          <target state="translated">5-6) &lt;code&gt;n&lt;/code&gt; 또는 &lt;code&gt;-n&lt;/code&gt; 위치 씩 진행되는 반복자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ca67ad0f2db5762e29a2054e1ae3ebc8d53fb60e" translate="yes" xml:space="preserve">
          <source>5-6) Sets the</source>
          <target state="translated">5-6) 설정</target>
        </trans-unit>
        <trans-unit id="c69b50f799c81901c6f70299bb57bff143c67b25" translate="yes" xml:space="preserve">
          <source>5-6) The behavior is undefined unless &lt;code&gt;const_cast&amp;lt;T*&amp;gt;((U*)nullptr)&lt;/code&gt; is well formed.</source>
          <target state="translated">5-6) &lt;code&gt;const_cast&amp;lt;T*&amp;gt;((U*)nullptr)&lt;/code&gt; 가 제대로 형성 되지 않으면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="872dc95610a784a83267b402f1e363293a6fcbae" translate="yes" xml:space="preserve">
          <source>5-6) user-defined floating-point literals, such as &lt;code&gt;0.5_Pa&lt;/code&gt;</source>
          <target state="translated">5-6) 사용자 정의 부동 소수점 리터럴 (예 : &lt;code&gt;0.5_Pa&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="753ea2c6aab1c3fdad5b4e9a3b060d48fe388a22" translate="yes" xml:space="preserve">
          <source>5-6)&lt;code&gt;O(N*log(size() + N))&lt;/code&gt;, where N is the number of elements to insert.</source>
          <target state="translated">5-6) &lt;code&gt;O(N*log(size() + N))&lt;/code&gt; , 여기서 N은 삽입 할 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="58212558b556ea64a399dd9bcf70fabe4f4bca4f" translate="yes" xml:space="preserve">
          <source>5-6)&lt;code&gt;const_cast&amp;lt;Y*&amp;gt;(r.get())&lt;/code&gt;.</source>
          <target state="translated">5-6)&lt;code&gt;const_cast&amp;lt;Y*&amp;gt;(r.get())&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="8700255054995a733c54eaf02aa4cfbd91e5224c" translate="yes" xml:space="preserve">
          <source>5-6)&lt;code&gt;move_iterator(base()+n)&lt;/code&gt; or &lt;code&gt;move_iterator(base()-n)&lt;/code&gt; respectively.</source>
          <target state="translated">5-6) &lt;code&gt;move_iterator(base()+n)&lt;/code&gt; 또는 &lt;code&gt;move_iterator(base()-n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e368044129420e3e8682559b7355c71ae18c1258" translate="yes" xml:space="preserve">
          <source>5-6)&lt;code&gt;reverse_iterator(base()-n)&lt;/code&gt; or &lt;code&gt;reverse_iterator(base()+n)&lt;/code&gt; respectively.</source>
          <target state="translated">5-6) &lt;code&gt;reverse_iterator(base()-n)&lt;/code&gt; 또는 &lt;code&gt;reverse_iterator(base()+n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7905bc64dba4da032059e903b3edf4212b059e26" translate="yes" xml:space="preserve">
          <source>5-6)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(pred, &lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(proj, *i)) == false&lt;/code&gt; for every iterator &lt;code&gt;i&lt;/code&gt; in the range, &lt;code&gt;false&lt;/code&gt; otherwise. Returns &lt;code&gt;true&lt;/code&gt; if the range is empty.</source>
          <target state="translated">5-6) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;&lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(pred, &lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(proj, *i)) == false&lt;/code&gt; 모든 반복자 &lt;code&gt;i&lt;/code&gt; 범위, &lt;code&gt;false&lt;/code&gt; 그렇지. 범위가 비어 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="a7a7b830fe398109830c9798aa6e1bcc8e35cd9d" translate="yes" xml:space="preserve">
          <source>5-6)&lt;code&gt;true&lt;/code&gt; if unary predicate returns &lt;code&gt;true&lt;/code&gt; for no elements in the range, &lt;code&gt;false&lt;/code&gt; otherwise. Returns &lt;code&gt;true&lt;/code&gt; if the range is empty.</source>
          <target state="translated">5-6) 단항 술어가 범위 내의 요소가없는 &lt;code&gt;true&lt;/code&gt; 를 리턴하면 &lt;code&gt;true&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다. 범위가 비어 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="7f9608e2e47e29a923f99f018a81874395723be1" translate="yes" xml:space="preserve">
          <source>5-7) Computes the square root of the sum of the squares of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, without undue overflow or underflow at intermediate stages of the computation.</source>
          <target state="translated">5-7) 계산의 중간 단계에서 과도한 오버플로 또는 언더 플로없이 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 의 제곱의 합의 제곱근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="29746d5d9cc5b419db2a0645a418420f6a8f3643" translate="yes" xml:space="preserve">
          <source>5-7) If &lt;code&gt;from&lt;/code&gt; equals to &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt; is returned, converted from &lt;code&gt;long double&lt;/code&gt; to the return type of the function without loss of range or precision.</source>
          <target state="translated">경우 5-7) &lt;code&gt;from&lt;/code&gt; 같음에 &lt;code&gt;to&lt;/code&gt; , &lt;code&gt;to&lt;/code&gt; 반환, 변환 &lt;code&gt;long double&lt;/code&gt; 범위 또는 정밀도의 손실없이 함수의 반환 유형.</target>
        </trans-unit>
        <trans-unit id="0b26c2736d84765f58b00a8f2d22ddc436a6f10c" translate="yes" xml:space="preserve">
          <source>5-7) If the macro constants &lt;code&gt;FP_FAST_FMAF&lt;/code&gt;, &lt;code&gt;FP_FAST_FMA&lt;/code&gt;, or &lt;code&gt;FP_FAST_FMAL&lt;/code&gt; are defined, the function &lt;code&gt;std::fma&lt;/code&gt; evaluates faster (in addition to being more precise) than the expression &lt;code&gt;x*y+z&lt;/code&gt; for &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; arguments, respectively. If defined, these macros evaluate to integer &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">5-7) 매크로 상수 &lt;code&gt;FP_FAST_FMAF&lt;/code&gt; , &lt;code&gt;FP_FAST_FMA&lt;/code&gt; 또는 &lt;code&gt;FP_FAST_FMAL&lt;/code&gt; 이 정의 된 경우 &lt;code&gt;std::fma&lt;/code&gt; 함수 는 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;long double&lt;/code&gt; 인수에 대해 &lt;code&gt;x*y+z&lt;/code&gt; 표현식보다 더 정확하게 평가됩니다 (보다 정확함). 각각. 정의 된 경우 이러한 매크로는 정수 &lt;code&gt;1&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ef076e2148edb2b8b6a3f74ba415735c819ac00" translate="yes" xml:space="preserve">
          <source>5-7, 9-11) Computes the nearest integer value to &lt;code&gt;arg&lt;/code&gt; (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="074473701ce7374a5816169a68a48eec7d4b9e8e" translate="yes" xml:space="preserve">
          <source>5-7, 9-11) Rounds the floating-point argument &lt;code&gt;arg&lt;/code&gt; to an integer value, using the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;.</source>
          <target state="translated">5-7, 9-11) &lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드를&lt;/a&gt; 사용하여 부동 소수점 인수 &lt;code&gt;arg&lt;/code&gt; 를 정수 값으로 반올림합니다 .</target>
        </trans-unit>
        <trans-unit id="b456a54eb068f062ab4334bf309cb10ee05c6c60" translate="yes" xml:space="preserve">
          <source>5-8) At most min(&lt;code&gt;last1&lt;/code&gt; - &lt;code&gt;first1&lt;/code&gt;, &lt;code&gt;last2&lt;/code&gt; - &lt;code&gt;first2&lt;/code&gt;) applications of &lt;code&gt;operator==&lt;/code&gt; or the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">5-8) &lt;code&gt;operator==&lt;/code&gt; 또는 술어 &lt;code&gt;p&lt;/code&gt; 의 최대 min ( &lt;code&gt;last1&lt;/code&gt; - &lt;code&gt;first1&lt;/code&gt; , &lt;code&gt;last2&lt;/code&gt; - &lt;code&gt;first2&lt;/code&gt; ) 어플리케이션 .</target>
        </trans-unit>
        <trans-unit id="7fffb2d497810451216336d250d87d9a6d0d5504" translate="yes" xml:space="preserve">
          <source>5-8) Extracts the element of the tuple &lt;code&gt;t&lt;/code&gt; whose type is &lt;code&gt;T&lt;/code&gt;. Fails to compile unless the tuple has exactly one element of that type.</source>
          <target state="translated">5-8) 유형이 &lt;code&gt;T&lt;/code&gt; 인 튜플 &lt;code&gt;t&lt;/code&gt; 의 요소를 추출합니다 . 튜플에 해당 유형의 요소가 정확히 하나 있지 않으면 컴파일에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="cd0d0755e40bb29a0aff2f5aba87c7b412b77b8d" translate="yes" xml:space="preserve">
          <source>5-8) If no errors occur, the distance from origin in 3D space, &amp;radic;x2</source>
          <target state="translated">5-8) 오류가 발생하지 않으면 3D 공간에서 원점과의 거리, &amp;radic;x2</target>
        </trans-unit>
        <trans-unit id="a1fe2f9c007188169338f1c1a168782d13c0b626" translate="yes" xml:space="preserve">
          <source>5-8) If the length of the range &lt;code&gt;[first1, last1)&lt;/code&gt; does not equal the length of the range &lt;code&gt;[first2, last2)&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">5-8) &lt;code&gt;[first1, last1)&lt;/code&gt; 범위의 길이가 &lt;code&gt;[first2, last2)&lt;/code&gt; 범위의 길이와 같지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3c27b492123aae0789b3890ca0c89c5ecabe8bef" translate="yes" xml:space="preserve">
          <source>5-8) May throw any exception thrown by calling the selected constructor of the selected alternative</source>
          <target state="translated">5-8) 선택된 대안의 선택된 생성자를 호출하여 예외를 던질 수 있음</target>
        </trans-unit>
        <trans-unit id="d3c521bb6a237ee1eb25e409f89aed1afc1bbd81" translate="yes" xml:space="preserve">
          <source>5-8) Returns a reference to &lt;code&gt;p.first&lt;/code&gt;.</source>
          <target state="translated">5-8) &lt;code&gt;p.first&lt;/code&gt; 에 대한 참조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bf5a89936c8a56fe729cc8cfd7477e45efce4410" translate="yes" xml:space="preserve">
          <source>5-8) non-null pointer to suitably aligned memory of size at least &lt;code&gt;size&lt;/code&gt;, or null pointer on allocation failure</source>
          <target state="translated">5-8) 최소 &lt;code&gt;size&lt;/code&gt; 크기의 메모리를 적절히 정렬하기위한 null이 아닌 포인터 또는 할당 실패시 null 포인터</target>
        </trans-unit>
        <trans-unit id="7d4d3a3d960f94339f7f358d7169d184515c6d4d" translate="yes" xml:space="preserve">
          <source>5. For two different parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are not equal, the probability that &lt;code&gt;std::hash&amp;lt;Key&amp;gt;()(k1) == std::hash&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; should be very small, approaching &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">5. 같지 않은 두 개의 다른 매개 변수 &lt;code&gt;k1&lt;/code&gt; 및 &lt;code&gt;k2&lt;/code&gt; 의 경우 &lt;code&gt;std::hash&amp;lt;Key&amp;gt;()(k1) == std::hash&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; 의 확률이 &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt; 에 가까워 야합니다 / std :: numeric_limits &amp;lt; std :: size_t &amp;gt; :: max () .</target>
        </trans-unit>
        <trans-unit id="96f2f740214b0f0c65ad51937c95922aaf8cf883" translate="yes" xml:space="preserve">
          <source>5.10 Equality operators [expr.eq](p: 2)</source>
          <target state="translated">5.10 평등 연산자 [expr.eq] (p : 2)</target>
        </trans-unit>
        <trans-unit id="c35a6b53d145565f42a92312225f774858b25006" translate="yes" xml:space="preserve">
          <source>5.2.3 Explicit type conversion (functional notation) [expr.type.conv]</source>
          <target state="translated">5.2.3 명시 적 타입 변환 (함수 표기법) [expr.type.conv]</target>
        </trans-unit>
        <trans-unit id="0071e9214528245b573b76c15c6743f91827d124" translate="yes" xml:space="preserve">
          <source>5.3.3 Sizeof [expr.sizeof](p: 2)</source>
          <target state="translated">5.3.3 [expr.sizeof]의 크기 (p : 2)</target>
        </trans-unit>
        <trans-unit id="3d60e1721223ba26629795d4ea696903ca8c3f22" translate="yes" xml:space="preserve">
          <source>5.4 Explicit type conversion (cast notation) [expr.cast]</source>
          <target state="translated">5.4 명시 적 타입 변환 (캐스트 표기법) [expr.cast]</target>
        </trans-unit>
        <trans-unit id="323e903001f9c3efa22757ff24d9953373e226a7" translate="yes" xml:space="preserve">
          <source>58&amp;ndash;64</source>
          <target state="translated">58&amp;ndash;64</target>
        </trans-unit>
        <trans-unit id="c1dfd96eea8cc2b62785275bca38ac261256e278" translate="yes" xml:space="preserve">
          <source>6</source>
          <target state="translated">6</target>
        </trans-unit>
        <trans-unit id="5dad2ddfa3861259e3bfebb27a5b3ac99784e129" translate="yes" xml:space="preserve">
          <source>6) &lt;code&gt;!(lhs &amp;lt; rhs)&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;!(lhs &amp;lt; rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88e1ea261b4ff6befc9cf253d06b46f6b003d62e" translate="yes" xml:space="preserve">
          <source>6) &lt;code&gt;!(x &amp;lt; y)&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;!(x &amp;lt; y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b78b0a089be32a7b8c83f6bfae1feff271722201" translate="yes" xml:space="preserve">
          <source>6) A list-initialization sequence &lt;code&gt;L1&lt;/code&gt; is</source>
          <target state="translated">6)리스트 초기화 순서 &lt;code&gt;L1&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="56bf2685d65d4933d516ee1e556bc2114ef680f9" translate="yes" xml:space="preserve">
          <source>6) An lvalue expression of type &lt;code&gt;T1&lt;/code&gt; can be converted to reference to another type &lt;code&gt;T2&lt;/code&gt;. The result is an lvalue or xvalue referring to the same object as the original lvalue, but with a different type. No temporary is created, no copy is made, no constructors or conversion functions are called. The resulting reference can only be accessed safely if allowed by the</source>
          <target state="translated">6) 유형 &lt;code&gt;T1&lt;/code&gt; 의 lvalue 표현식은 다른 유형 &lt;code&gt;T2&lt;/code&gt; 를 참조하도록 변환 될 수 있습니다 . 결과는 원래 lvalue와 동일한 객체를 참조하지만 다른 유형을 갖는 lvalue 또는 xvalue입니다. 임시 생성, 복사, 생성자 또는 변환 함수가 호출되지 않습니다. 결과 참조는 허용 된 경우에만 안전하게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c85780d3a0f96f0da50375309828e20a265f726c" translate="yes" xml:space="preserve">
          <source>6) Appends characters in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 문자를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="bfb96ba296924581b6cc301df6881dc6165b3cf2" translate="yes" xml:space="preserve">
          <source>6) Assigns &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U1&amp;gt;(p.first)&lt;/code&gt; to the first element of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U2&amp;gt;(p.second)&lt;/code&gt; to the second element of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U1&amp;gt;(p.first)&lt;/code&gt; 를 &lt;code&gt;*this&lt;/code&gt; 의 첫 번째 요소에 지정 하고 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U2&amp;gt;(p.second)&lt;/code&gt; 를 &lt;code&gt;*this&lt;/code&gt; 의 두 번째 요소에 지정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e3fe4a6b1893cd8070c62a2d0f938817def13eb" translate="yes" xml:space="preserve">
          <source>6) Assigns the characters in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 문자를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="f04d270c046fef19cffece13f809b8cc905f6d43" translate="yes" xml:space="preserve">
          <source>6) Assumes the calling thread already owns &lt;code&gt;m&lt;/code&gt; in shared mode.</source>
          <target state="translated">6) 호출 스레드가 이미 공유 모드에서 &lt;code&gt;m&lt;/code&gt; 을 소유한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="9a27080f9013e82798cb1a7781194d77193df630" translate="yes" xml:space="preserve">
          <source>6) Assumes the calling thread already owns &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">6) 호출 스레드가 이미 &lt;code&gt;m&lt;/code&gt; 을 소유하고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="0b4fb6653432f6aae5c04f79cb53035c83248ed0" translate="yes" xml:space="preserve">
          <source>6) Behaves as a &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, which may skip leading whitespace, extracts &lt;code&gt;bool&lt;/code&gt; value by calling &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;std::num_get::get()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">6) &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction으로&lt;/a&gt; 동작합니다 . 앞 공백을 건너 뛸 수있는 센트리 객체를 구성하고 확인한 후 &lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;std::num_get::get()&lt;/code&gt; &lt;/a&gt; 을 호출하여 &lt;code&gt;bool&lt;/code&gt; 값을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c3f8b96c148953e3e27c29db93a4ceeb06dd1ebc" translate="yes" xml:space="preserve">
          <source>6) Called by the non-throwing array form of &lt;a href=&quot;../../language/new&quot;&gt;new[]-expressions&lt;/a&gt;. The standard library implementation calls the version (2) and returns a null pointer on failure instead of propagating the exception.</source>
          <target state="translated">6) 비 &lt;a href=&quot;../../language/new&quot;&gt;[&lt;/a&gt; throwing] 배열 형식의 new [] -expressions에 의해 호출됩니다 . 표준 라이브러리 구현은 버전 (2)을 호출하고 예외를 전파하는 대신 실패시 널 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e46dce21372710b628dda09dcbdefce8e3b909c1" translate="yes" xml:space="preserve">
          <source>6) Checks whether &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">6) &lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt; 이 비어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="9e73f35b9b4557cc59bf3f21ca6d4cef46e7297e" translate="yes" xml:space="preserve">
          <source>6) Checks whether &lt;code&gt;lhs&lt;/code&gt; is greater than or equal to &lt;code&gt;rhs&lt;/code&gt;. Equivalent to &lt;code&gt;!(lhs &amp;lt; rhs)&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;lhs&lt;/code&gt; 가 &lt;code&gt;rhs&lt;/code&gt; 이상 인지 확인합니다 . &lt;code&gt;!(lhs &amp;lt; rhs)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="18a3ecbb157afbbbc4c383fe9438967fee66baa0" translate="yes" xml:space="preserve">
          <source>6) Compares a &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; substring of this string to the characters in the range &lt;code&gt;[s, s + count2)&lt;/code&gt;. If &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; the substring is &lt;code&gt;[pos1, size())&lt;/code&gt;. (Note: the characters in the range &lt;code&gt;[s, s + count2)&lt;/code&gt; may include null characters.)</source>
          <target state="translated">6) 이 문자열 의 &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; 하위 문자열을 &lt;code&gt;[s, s + count2)&lt;/code&gt; 범위의 문자와 비교합니다 . 경우 &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; 문자열이다 &lt;code&gt;[pos1, size())&lt;/code&gt; . (참고 : &lt;code&gt;[s, s + count2)&lt;/code&gt; 범위의 문자 는 null 문자를 포함 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d2669e00047b16143751aa30373aad0399cd296a" translate="yes" xml:space="preserve">
          <source>6) Constant.</source>
          <target state="translated">6) 상수.</target>
        </trans-unit>
        <trans-unit id="3267021366c9f594e204d68a7839f9006e58b101" translate="yes" xml:space="preserve">
          <source>6) Constructs a &lt;code&gt;unique_ptr&lt;/code&gt; by transferring ownership from &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, where &lt;code&gt;u&lt;/code&gt; is constructed with a specified deleter (&lt;code&gt;E&lt;/code&gt;). It depends upon whether &lt;code&gt;E&lt;/code&gt; is a reference type, as following:</source>
          <target state="translated">6) 소유권을 &lt;code&gt;u&lt;/code&gt; 에서 &lt;code&gt;*this&lt;/code&gt; 로 이전 하여 &lt;code&gt;unique_ptr&lt;/code&gt; 을 구성 합니다 . 여기서 &lt;code&gt;u&lt;/code&gt; 는 지정된 삭제 기 ( &lt;code&gt;E&lt;/code&gt; )로 구성됩니다. 다음과 같이 &lt;code&gt;E&lt;/code&gt; 가 참조 유형 인지 여부에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="ecd026a1b64065da6969327f02f908c4c1720e7e" translate="yes" xml:space="preserve">
          <source>6) Constructs a regex from a string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">6) 문자열 &lt;code&gt;str&lt;/code&gt; 로부터 정규 표현식을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="3bd276aa3118d69ef2886b03854e0979d34210f3" translate="yes" xml:space="preserve">
          <source>6) Constructs a variant with the specified alternative &lt;code&gt;T&lt;/code&gt; and initializes the contained value with the arguments &lt;code&gt;il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)....&lt;/code&gt;. If T's selected constructor is a constexpr constructor, this constructor is also a constexpr constructor. This overload only participates in overload resolution if there is exactly one occurrence of T in &lt;code&gt;Types...&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, initializer_list&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">6) 지정된 대체 &lt;code&gt;T&lt;/code&gt; 로 변형을 구성하고 인수 &lt;code&gt;il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)....&lt;/code&gt; 포함 된 값을 초기화합니다 . T의 선택된 생성자가 constexpr 생성자 인 경우이 생성자는 constexpr 생성자이기도합니다. 이 과부하는 &lt;code&gt;Types...&lt;/code&gt; 에 T가 정확히 한 번만 발생 하고 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, initializer_list&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="e51132b3afcdc96a4dfe8313726cc5884b92ca13" translate="yes" xml:space="preserve">
          <source>6) Constructs an object with initial content an object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt;, &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-non-list-initialized&lt;/a&gt; from &lt;code&gt;il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, &lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">6) 초기 콘텐츠 개체를 유형의 객체를 생성 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; , &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 비리스트 초기화&lt;/a&gt; 에서 &lt;code&gt;il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, &lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; 이있는 경우이 과부하는 과부하 해결에만 참여합니다. 둘 다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5ad4901e335b4831508618e68c095fcf6e82d30" translate="yes" xml:space="preserve">
          <source>6) Constructs an optional object that</source>
          <target state="translated">6) 다음과 같은 선택적 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="59c46cc5495c7dec1aad197195bad209e09ac88a" translate="yes" xml:space="preserve">
          <source>6) Constructs the string with the contents of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 내용으로 문자열을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="4dec2e97a7a553745123ee44fb299960c63d002f" translate="yes" xml:space="preserve">
          <source>6) Constructs the underlying container using &lt;code&gt;alloc&lt;/code&gt; as allocator, as if by &lt;code&gt;c(alloc)&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;c(alloc)&lt;/code&gt; 의한 것처럼 &lt;code&gt;alloc&lt;/code&gt; 을 할당 자로 사용하여 기본 컨테이너를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="d34991555e021f5fb01b9d363002595a5db93efe" translate="yes" xml:space="preserve">
          <source>6) Converts an unsigned decimal integer to a string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%llu&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">6) 부호없는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%llu&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에 대해 생성 할 내용과 동일한 내용을 가진 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="79f19f61980831e3b34fcf283ade4895713e4a4e" translate="yes" xml:space="preserve">
          <source>6) Converts an unsigned decimal integer to a wide string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%llu&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">6) 부호없는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%llu&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에 대해 생성 할 내용과 동일한 내용을 가진 넓은 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="26e263826bd50a442e97b3748691a22ef899aee8" translate="yes" xml:space="preserve">
          <source>6) Converts the two durations to their common type and divides the tick count of &lt;code&gt;lhs&lt;/code&gt; after conversion by the tick count of &lt;code&gt;rhs&lt;/code&gt; after conversion. Note that the return value of this operator is not a duration.</source>
          <target state="translated">6) 두 지속 시간을 공통 유형으로 변환하고 변환 후 &lt;code&gt;lhs&lt;/code&gt; 의 틱 수를 변환 후 &lt;code&gt;rhs&lt;/code&gt; 의 틱 수로 나눕니다 . 이 연산자의 반환 값은 기간이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f1dfcb0db203da5731e3d2f9b5d34257f5a04ae4" translate="yes" xml:space="preserve">
          <source>6) Copy constructor: performs member-wise copy (including making a copy of the member &lt;code&gt;regex_iterator&lt;/code&gt; and the member pointer to current &lt;code&gt;sub_match&lt;/code&gt;).</source>
          <target state="translated">6) 복사 생성자 : 멤버 &lt;code&gt;regex_iterator&lt;/code&gt; 및 현재 &lt;code&gt;sub_match&lt;/code&gt; 에 대한 멤버 포인터 의 복사를 포함하여 멤버 별 복사를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="6d1a6e6beeb8c2e27cc4caa0a059c9cdd0f68929" translate="yes" xml:space="preserve">
          <source>6) End-of-file status indicator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a12ca53080e1d31fae44b92c0093e2a2c827401" translate="yes" xml:space="preserve">
          <source>6) Equivalent to</source>
          <target state="translated">6) 해당</target>
        </trans-unit>
        <trans-unit id="497c001cf81c2ab91ee43423bc90e89a98574689" translate="yes" xml:space="preserve">
          <source>6) Equivalent to &lt;code&gt;atomic_exchange_explicit(p, r, memory_order_seq_cst)&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;atomic_exchange_explicit(p, r, memory_order_seq_cst)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09b86eb226793c02c522950fa2b0a70f67903439" translate="yes" xml:space="preserve">
          <source>6) Equivalent to &lt;code&gt;rep_ %= d.count(); return *this;&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;rep_ %= d.count(); return *this;&lt;/code&gt; )와 동일 ; return * this;</target>
        </trans-unit>
        <trans-unit id="01d4f467999198107b8159a4996334d1807a2a23" translate="yes" xml:space="preserve">
          <source>6) Equivalent to &lt;code&gt;substr(pos1, count1).compare(basic_string_view(s, count2))&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;substr(pos1, count1).compare(basic_string_view(s, count2))&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ddfda7c8f37b1f26302e3d99efcce95445bcb952" translate="yes" xml:space="preserve">
          <source>6) Expands to integer constant expression whose value is either &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;+&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">6) 값이 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;+&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 인 정수 상수 표현식으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="a43643b47c37fd76dadae6e3777922cc34693472" translate="yes" xml:space="preserve">
          <source>6) For arguments of function type, the function parameter types and the function return type are examined and their associated set of classes and namespaces are added to the set.</source>
          <target state="translated">6) 함수 유형의 인수의 경우, 함수 매개 변수 유형 및 함수 리턴 유형이 검사되고 연관된 클래스 및 네임 스페이스 세트가 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4088133b12a68c709f3e573a427625c19d449e3b" translate="yes" xml:space="preserve">
          <source>6) Forwards the elements of &lt;code&gt;first_args&lt;/code&gt; to the constructor of &lt;code&gt;first&lt;/code&gt; and forwards the elements of &lt;code&gt;second_args&lt;/code&gt; to the constructor of &lt;code&gt;second&lt;/code&gt;. This is the only non-default constructor that can be used to create a pair of non-copyable non-movable types.</source>
          <target state="translated">6) &lt;code&gt;first_args&lt;/code&gt; 의 요소를 &lt;code&gt;first&lt;/code&gt; 의 생성자로 전달하고 &lt;code&gt;second_args&lt;/code&gt; 의 요소 를 &lt;code&gt;second&lt;/code&gt; 의 생성자로 전달합니다 . 이것은 복사 불가능한 움직일 수없는 유형 쌍을 작성하는 데 사용할 수있는 기본이 아닌 유일한 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="75dfd66fe66b6c5d26b18109994abd44dd36ed43" translate="yes" xml:space="preserve">
          <source>6) Greater-equal operator for variants:</source>
          <target state="translated">6) 변형에 대한 더 큰 연산자 :</target>
        </trans-unit>
        <trans-unit id="bcac79fefc7e63a0b7ad0cb4424af07e3786786a" translate="yes" xml:space="preserve">
          <source>6) Hexadecimal digit-sequence representing a fractional number with a radix separator. The exponent is never optional for hexadecimal floating-point literals: &lt;code&gt;0x0.123p-1&lt;/code&gt;, &lt;code&gt;0xa.bp10l&lt;/code&gt;</source>
          <target state="translated">6) 기수 구분 기호가있는 소수를 나타내는 16 진수 숫자 시퀀스. 16 진 부동 소수점 리터럴의 경우 지수는 선택 사항이 아닙니다. &lt;code&gt;0x0.123p-1&lt;/code&gt; , &lt;code&gt;0xa.bp10l&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="764de9477047bc81ec1a01662a78c50434d9056e" translate="yes" xml:space="preserve">
          <source>6) If &lt;code&gt;bool(rhs) == false&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;bool(rhs) == false&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; 반환 합니다</target>
        </trans-unit>
        <trans-unit id="219123f4ef9617eff0415da0ad72ccf9ced953ff" translate="yes" xml:space="preserve">
          <source>6) If any parameter has reference type, reference binding is accounted for at this step: if an rvalue argument corresponds to non-const lvalue reference parameter or an lvalue argument corresponds to rvalue reference parameter, the function is not viable.</source>
          <target state="translated">6) 매개 변수에 참조 유형이있는 경우이 단계에서 참조 바인딩이 설명됩니다. rvalue 인수가 상수가 아닌 lvalue 참조 매개 변수에 해당하거나 lvalue 인수가 rvalue 참조 매개 변수에 해당하면 함수를 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d81eb37aed81f84ee1f28548ee7c4334db8cb26" translate="yes" xml:space="preserve">
          <source>6) If conversion of expression to new_type involves lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversion, it can be performed explicitly by &lt;code&gt;static_cast&lt;/code&gt;.</source>
          <target state="translated">6) expression을 new_type으로 변환 할 때 lvalue-to-rvalue, array-to-pointer 또는 function-to-pointer 변환이 관련된 경우 &lt;code&gt;static_cast&lt;/code&gt; 로 명시 적으로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50f19e3403d3b20832cd4f2b6057e5ed06797f31" translate="yes" xml:space="preserve">
          <source>6) If there is root-directory, remove all dot-dots and any directory-separators immediately following them.</source>
          <target state="translated">6) 루트 디렉토리가 있으면 바로 뒤에있는 모든 점과 디렉토리 분리자를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="2e61e4b42017f98c1aebda5dceb6845204730a09" translate="yes" xml:space="preserve">
          <source>6) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then replaces the contents with those of the &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;assign(sv)&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;assign(sv)&lt;/code&gt; 의해 내용을 &lt;code&gt;sv&lt;/code&gt; 의 내용으로 바꿉니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="63399d30c9be20a029c27f893189cbae9df2d1f6" translate="yes" xml:space="preserve">
          <source>6) Initializes each allocator from the corresponding allocator of &lt;code&gt;other&lt;/code&gt;, using move semantics. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;OuterAlloc, OuterA2&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">6) 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 할당 자의 할당 자에서 각 할당자를 초기화합니다 . &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;OuterAlloc, OuterA2&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우이 과부하는 과부하 해결에만 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="658b5d628d923a47fbb00f21a48b1abead41d7eb" translate="yes" xml:space="preserve">
          <source>6) Inserts character &lt;code&gt;ch&lt;/code&gt; before the character pointed by &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;pos&lt;/code&gt; 가 가리키는 문자 앞에 문자 &lt;code&gt;ch&lt;/code&gt; 를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="1609ddd295220ad96ea8c8daacdb7fffed6811dc" translate="yes" xml:space="preserve">
          <source>6) Inserts elements from initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">6) 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="816cb7ad5c2c7a2c5a65ce728c33fca1090cc316" translate="yes" xml:space="preserve">
          <source>6) Inserts elements from initializer list &lt;code&gt;ilist&lt;/code&gt;. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;LWG2844&lt;/a&gt;).</source>
          <target state="translated">6) 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 요소를 삽입합니다 . 범위의 여러 요소에 동등한 키가있는 경우 삽입 할 요소가 지정되지 &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;않습니다&lt;/a&gt; ( LWG2844 보류 중 ).</target>
        </trans-unit>
        <trans-unit id="47b0b574a33e15c9321c806b99914e63e1e4c988" translate="yes" xml:space="preserve">
          <source>6) Move constructor. Constructs the container with the contents of &lt;code&gt;other&lt;/code&gt; using move semantics.</source>
          <target state="translated">6) 생성자를 이동하십시오. 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 내용으로 컨테이너를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="b5d9a210ba1c8720dc146aa4fc34784030a9e3fc" translate="yes" xml:space="preserve">
          <source>6) Move constructor. Constructs the container with the contents of &lt;code&gt;other&lt;/code&gt; using move semantics. Allocator is obtained by move-construction from the allocator belonging to &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">6) 생성자를 이동하십시오. 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 내용으로 컨테이너를 구성합니다 . 할당자는 &lt;code&gt;other&lt;/code&gt; 에 속한 할당 자로부터 이동 구성에 의해 획득됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2174348d3fc1e5b8a16fcece06215c89b1b6105" translate="yes" xml:space="preserve">
          <source>6) Move constructor. Constructs the container with the contents of &lt;code&gt;other&lt;/code&gt; using move semantics. Allocator is obtained by move-construction from the allocator belonging to &lt;code&gt;other&lt;/code&gt;. After the move, &lt;code&gt;other&lt;/code&gt; is guaranteed to be &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">6) 생성자를 이동하십시오. 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 내용으로 컨테이너를 구성합니다 . 할당자는 &lt;code&gt;other&lt;/code&gt; 에 속한 할당 자로부터 이동 구성에 의해 획득됩니다 . 이동 후 &lt;code&gt;other&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="07599bdd22e6cc9822f406b645c8432c32145920" translate="yes" xml:space="preserve">
          <source>6) Move constructor. First, move-constructs the base class from &lt;code&gt;other&lt;/code&gt; (which does not affect the &lt;code&gt;rdbuf()&lt;/code&gt; pointer), then move-constructs the &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; member, then calls &lt;code&gt;this-&amp;gt;set_rdbuf()&lt;/code&gt; to install the new &lt;code&gt;basic_filebuf&lt;/code&gt; as the &lt;code&gt;rdbuf()&lt;/code&gt; pointer in the base class.</source>
          <target state="translated">6) 생성자를 이동하십시오. 먼저, &lt;code&gt;rdbuf()&lt;/code&gt; 포인터에 영향을 미치지 않는 &lt;code&gt;other&lt;/code&gt; 클래스에서 기본 클래스 를 이동 구성한 다음 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 멤버 를 이동 구성한 다음 &lt;code&gt;this-&amp;gt;set_rdbuf()&lt;/code&gt; 를 호출 하여 새 &lt;code&gt;basic_filebuf&lt;/code&gt; 를 &lt;code&gt;rdbuf()&lt;/code&gt; 기본 클래스의 포인터.</target>
        </trans-unit>
        <trans-unit id="b0498b5ac8b3ffa325e4dd924ca76e11377740b2" translate="yes" xml:space="preserve">
          <source>6) Move constructor. The adaptor is constructed with &lt;code&gt;std::move(other.c)&lt;/code&gt;.The comparison functor is constructed with &lt;code&gt;std::move(other.comp)&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">6) 생성자를 이동하십시오. 어댑터는 &lt;code&gt;std::move(other.c)&lt;/code&gt; 로 구성되고 비교 기능은 &lt;code&gt;std::move(other.comp)&lt;/code&gt; 됩니다. (내재적으로 선언)</target>
        </trans-unit>
        <trans-unit id="39cb7edf7a2f908e6ce3742967e21755e9c3c906" translate="yes" xml:space="preserve">
          <source>6) Multicharacter literal, e.g. &lt;code&gt;'AB'&lt;/code&gt;, has type &lt;code&gt;int&lt;/code&gt; and implementation-defined value.</source>
          <target state="translated">6) 다중 문자 리터럴 (예 : &lt;code&gt;'AB'&lt;/code&gt; )은 &lt;code&gt;int&lt;/code&gt; 유형 과 구현 정의 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9c5efc78c43bd554f3e5b834ed16cb114f22eacb" translate="yes" xml:space="preserve">
          <source>6) Pair copy constructor. Constructs a 2-element tuple with the first element constructed from &lt;code&gt;p.first&lt;/code&gt; and the second element from &lt;code&gt;p.second&lt;/code&gt;</source>
          <target state="translated">6) 페어 카피 생성자. 로 구성되는 제 2 요소와 요소 튜플 구축 &lt;code&gt;p.first&lt;/code&gt; 로부터 두 번째 요소 &lt;code&gt;p.second&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="39416280a9c16a2def1ab7f1ba9cb37759e89b43" translate="yes" xml:space="preserve">
          <source>6) Raw string literal. Used to avoid escaping of any character. Anything between the delimiters becomes part of the string. prefix, if present, has the same meaning as described above.</source>
          <target state="translated">6) 원시 문자열 리터럴. 모든 문자의 이탈을 피하기 위해 사용됩니다. 분리 문자 사이의 모든 것은 문자열의 일부가됩니다. 접두사가있는 경우 위에서 설명한 것과 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="346768694491378fb8519a40b519536e98080594" translate="yes" xml:space="preserve">
          <source>6) Replaces the contents with those of null-terminated character string pointed to by &lt;code&gt;s&lt;/code&gt;. The length of the string is determined by the first null character using &lt;code&gt;Traits::length(s)&lt;/code&gt;.</source>
          <target state="translated">6) 내용이 &lt;code&gt;s&lt;/code&gt; 로 가리키는 null로 끝나는 문자열로 바꿉니다 . 문자열의 길이는 &lt;code&gt;Traits::length(s)&lt;/code&gt; 사용하여 첫 번째 널 문자로 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="007cc91afd9d0a1d4786e5045d146daa24399eed" translate="yes" xml:space="preserve">
          <source>6) Returns &lt;code&gt;Clock::from_sys(t)&lt;/code&gt;. This overload only participates in overload resolution if the expression &lt;code&gt;Clock::from_sys(t)&lt;/code&gt; is well-formed. The program is ill-formed if &lt;code&gt;Clock::from_sys(t)&lt;/code&gt; does not return &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Clock, Duration&amp;gt;&lt;/code&gt; where &lt;code&gt;Duration&lt;/code&gt; is some valid specialization of &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;Clock::from_sys(t)&lt;/code&gt; )를 반환 합니다. &lt;code&gt;Clock::from_sys(t)&lt;/code&gt; 표현식의 형식이 올바른 경우이 과부하는 과부하 해결에만 참여 합니다. &lt;code&gt;Clock::from_sys(t)&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Clock, Duration&amp;gt;&lt;/code&gt; 반환하지 않으면 프로그램이 잘못 구성됩니다. 여기서 &lt;code&gt;Duration&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 의 유효한 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="c656995e412086d68f99a60ba1297e811b666b06" translate="yes" xml:space="preserve">
          <source>6) Returns &lt;code&gt;std::regex_match(s.begin(), s.end(), e, flags)&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;std::regex_match(s.begin(), s.end(), e, flags)&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9ac3d83713e97d44fdc3275d63864e31c4bbc91c" translate="yes" xml:space="preserve">
          <source>6) Returns &lt;code&gt;true&lt;/code&gt; if lhs is not equal to rhs, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">6) 반환 &lt;code&gt;true&lt;/code&gt; 좌하지 우 동일한 인 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="52d308f39267faeadf88be828a81ff3dd8264934" translate="yes" xml:space="preserve">
          <source>6) Same as (1) if &lt;code&gt;T&lt;/code&gt; is not an array type and (3) if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;U[N]&lt;/code&gt;, except that the created object is &lt;a href=&quot;../../language/default_initialization&quot;&gt;default-initialized&lt;/a&gt;.</source>
          <target state="translated">6) (1) &lt;code&gt;T&lt;/code&gt; 가 배열 유형이 아닌 경우 (3) &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;U[N]&lt;/code&gt; 인 경우와 동일하지만 생성 된 객체는 &lt;a href=&quot;../../language/default_initialization&quot;&gt;기본적으로 초기화&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e211005cd6e4219c7e5d705a4163c9922a7d2b46" translate="yes" xml:space="preserve">
          <source>6) Specialization for types that define a public and accessible member type &lt;code&gt;element_type&lt;/code&gt; (e.g., &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;T::element_type&lt;/code&gt; is an object type, provides a member type &lt;code&gt;value_type&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;typename T::element_type&amp;gt;&lt;/code&gt;. Otherwise, there is no member &lt;code&gt;value_type&lt;/code&gt;.</source>
          <target state="translated">6) 공개되고 액세스 가능한 멤버 유형 &lt;code&gt;element_type&lt;/code&gt; 을 정의하는 유형에 대한 전문화 (예 : &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; ). 경우 &lt;code&gt;T::element_type&lt;/code&gt; 개체 유형이며, 멤버 형 제공 &lt;code&gt;value_type&lt;/code&gt; 동일한 &lt;code&gt;&lt;a href=&quot;../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;typename T::element_type&amp;gt;&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;value_type&lt;/code&gt; 멤버가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c2530e85047847f078da6d976d9d6a39dbe00f51" translate="yes" xml:space="preserve">
          <source>6) Subtracts &lt;code&gt;dm.count()&lt;/code&gt; months from &lt;code&gt;ym&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;ym&lt;/code&gt; 에서 &lt;code&gt;dm.count()&lt;/code&gt; 개월을 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="baad07c9c83e59115dadc13222caaa491c631f26" translate="yes" xml:space="preserve">
          <source>6) Subtracts &lt;code&gt;dy.count()&lt;/code&gt; years from the date represented by &lt;code&gt;ymd&lt;/code&gt;. Equivalent to &lt;code&gt;ymd + -dy&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;ymd&lt;/code&gt; 로 표시된 날짜에서 &lt;code&gt;dy.count()&lt;/code&gt; 년을 뺍니다 . &lt;code&gt;ymd + -dy&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8acd45ccc0e6023f7b749477d213284c0aae4a69" translate="yes" xml:space="preserve">
          <source>6) Subtracts &lt;code&gt;dy.count()&lt;/code&gt; years from the date represented by &lt;code&gt;ymdl&lt;/code&gt;. Equivalent to &lt;code&gt;ymdl + -dy&lt;/code&gt;.</source>
          <target state="translated">6) 뺍 &lt;code&gt;dy.count()&lt;/code&gt; 일로부터 년으로 표시 &lt;code&gt;ymdl&lt;/code&gt; . &lt;code&gt;ymdl + -dy&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="386aa932238f71335db2ab74f6544ad76421c63a" translate="yes" xml:space="preserve">
          <source>6) Subtracts &lt;code&gt;dy.count()&lt;/code&gt; years from the date represented by &lt;code&gt;ymwd&lt;/code&gt;. Equivalent to &lt;code&gt;ymwd + -dy&lt;/code&gt;.</source>
          <target state="translated">6) 뺍 &lt;code&gt;dy.count()&lt;/code&gt; 일로부터 년으로 표시 &lt;code&gt;ymwd&lt;/code&gt; . &lt;code&gt;ymwd + -dy&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a2184c9da0689201a28ecc0fca09c853b323fbcb" translate="yes" xml:space="preserve">
          <source>6) Subtracts &lt;code&gt;dy.count()&lt;/code&gt; years from the date represented by &lt;code&gt;ymwdl&lt;/code&gt;. Equivalent to &lt;code&gt;ymwdl + -dy&lt;/code&gt;.</source>
          <target state="translated">6) 뺍 &lt;code&gt;dy.count()&lt;/code&gt; 일로부터 년으로 표시 &lt;code&gt;ymwdl&lt;/code&gt; . &lt;code&gt;ymwdl + -dy&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cab114bed3ef489084dc0acd970f384a204b0c95" translate="yes" xml:space="preserve">
          <source>6) The lvalue-to-rvalue, array-to-pointer, and function-to-pointer conversions are applied to the second and third operands. Then,</source>
          <target state="translated">6) lvalue-to-rvalue, array-to-pointer 및 function-to-pointer 변환은 두 번째 및 세 번째 피연산자에 적용됩니다. 그때,</target>
        </trans-unit>
        <trans-unit id="dec3ee1f82f40e8dde4c6fb2d86864339139710a" translate="yes" xml:space="preserve">
          <source>6) The parameter &lt;code&gt;P&lt;/code&gt;, whose &lt;code&gt;A&lt;/code&gt; is a braced-init-list, but &lt;code&gt;P&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;, a reference to one (possibly cv-qualified), or a reference to an array:</source>
          <target state="translated">6) 매개 변수 &lt;code&gt;P&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 가 braced-init-list이지만 &lt;code&gt;P&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 가 아니 거나, 하나에 대한 참조 (아마도 cv-qualified) 또는 배열에 대한 참조 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="baf5baed462387e47e61359ac46001dd7c088b75" translate="yes" xml:space="preserve">
          <source>6) This overload only participates in overload resolution if T is a specialization of std::pair. Equivalent to</source>
          <target state="translated">6)이 과부하는 T가 std :: pair의 전문화 인 경우에만 과부하 해결에 참여합니다. 에 해당</target>
        </trans-unit>
        <trans-unit id="3ea203503134c44e5c47a584792bc999c06a2f70" translate="yes" xml:space="preserve">
          <source>6) When &lt;code&gt;dynamic_cast&lt;/code&gt; is used in a constructor or a destructor (directly or indirectly), and expression refers to the object that's currently under construction/destruction, the object is considered to be the most derived object. If new_type is not a pointer or reference to the constructor's/destructor's own class or one of its bases, the behavior is undefined.</source>
          <target state="translated">6) 생성자 또는 소멸자 (직접 또는 간접)에서 &lt;code&gt;dynamic_cast&lt;/code&gt; 를 사용하고 expression이 현재 생성 / 파괴중인 객체를 참조하는 경우 객체는 가장 파생 된 객체로 간주됩니다. new_type이 생성자 / 소멸자 자신의 클래스 또는 해당 기본 중 하나에 대한 포인터 또는 참조가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3abd0b554f468cb520e129dfd942216816f2f0e1" translate="yes" xml:space="preserve">
          <source>6) a &lt;a href=&quot;../language/except_spec&quot;&gt;dynamic exception specification&lt;/a&gt; is violated and the default handler for &lt;code&gt;&lt;a href=&quot;exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; is executed 7) a non-default handler for &lt;code&gt;&lt;a href=&quot;exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; throws an exception that violates the previously violated dynamic exception specification, if the specification does not include &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">6) &lt;a href=&quot;../language/except_spec&quot;&gt;동적 예외 스펙&lt;/a&gt; 이 위반되고 &lt;code&gt;&lt;a href=&quot;exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 대한 기본 핸들러 가 실행됩니다. 7) &lt;code&gt;&lt;a href=&quot;exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 대한 기본이 아닌 핸들러 는 스펙에 &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 가 포함되지 않은 경우 이전에 위반 된 동적 예외 스펙을 위반하는 예외를 처리합니다. :: bad_exception</target>
        </trans-unit>
        <trans-unit id="6fac6480de0dc55e93848699dc3657b66696692c" translate="yes" xml:space="preserve">
          <source>6) as part of &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, to initialize each element for which an initializer is provided</source>
          <target state="translated">6) &lt;a href=&quot;aggregate_initialization&quot;&gt;집합 초기화의&lt;/a&gt; 일부 로서, 이니셜 라이저가 제공되는 각 요소를 초기화</target>
        </trans-unit>
        <trans-unit id="3cbc30e35e8714ab85287f217fcce2e7d8164034" translate="yes" xml:space="preserve">
          <source>6) by-reference capture with an initializer</source>
          <target state="translated">6) 이니셜 라이저를 통한 참조 캡처</target>
        </trans-unit>
        <trans-unit id="ce48b9718404092013610833a13412914957991d" translate="yes" xml:space="preserve">
          <source>6) declaration statements;</source>
          <target state="translated">6) 선언문;</target>
        </trans-unit>
        <trans-unit id="409e451d3a09c1f0408540f4a1eb9a98215d34fa" translate="yes" xml:space="preserve">
          <source>6) if &lt;code&gt;E1&lt;/code&gt; is an rvalue and &lt;code&gt;E2&lt;/code&gt; points to a member function with ref-qualifier &amp;amp;, the program is ill-formed unless the member function is also &lt;code&gt;const&lt;/code&gt;-qualified but is not &lt;code&gt;volatile&lt;/code&gt;-qualified(since C++20);</source>
          <target state="translated">6) &lt;code&gt;E1&lt;/code&gt; 이 rvalue이고 &lt;code&gt;E2&lt;/code&gt; 가 참조 한정자 &amp;amp;를 갖는 멤버 함수를 가리키는 경우 멤버 함수도 &lt;code&gt;const&lt;/code&gt; -qualified이지만 &lt;code&gt;volatile&lt;/code&gt; 이 아닌 경우가 아니라면 프로그램이 잘못 구성 됩니다 (C ++ 20 이후).</target>
        </trans-unit>
        <trans-unit id="c107bcfbb53e4c6c5a52f1de23af26dca42362b0" translate="yes" xml:space="preserve">
          <source>6) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;nested_classes&quot;&gt;nested type&lt;/a&gt;, the program is ill-formed (won't compile);</source>
          <target state="translated">6) &lt;code&gt;E2&lt;/code&gt; 가 &lt;a href=&quot;nested_classes&quot;&gt;중첩 유형&lt;/a&gt; 인 경우 프로그램이 잘못 작성됩니다 (컴파일되지 않음).</target>
        </trans-unit>
        <trans-unit id="f272acb521046c948322fc9716c303a9aeabf7b8" translate="yes" xml:space="preserve">
          <source>6) in the specialization for arrays behaves the same as in the primary template, except that it will only participate in overload resolution if all of the following is true</source>
          <target state="translated">6) 배열의 전문화에서 다음과 같은 경우 모두 오버로드 확인에 참여한다는 점을 제외하고 기본 템플릿과 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="e33e166920b5c41751e1eee005b878c903df0a30" translate="yes" xml:space="preserve">
          <source>6) initialization of a base or a non-static member by constructor &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt;</source>
          <target state="translated">6) 생성자 &lt;a href=&quot;constructor&quot;&gt;이니셜 라이저 목록&lt;/a&gt; 으로 기본 또는 비 정적 멤버 초기화</target>
        </trans-unit>
        <trans-unit id="aa43de04e8d7e21fccb9790dd35d54d65342267f" translate="yes" xml:space="preserve">
          <source>6) initialization of a named variable with a</source>
          <target state="translated">6) 명명 된 변수의 초기화</target>
        </trans-unit>
        <trans-unit id="1b4da36356eaee091cdd1c3f6d92add8c6c3626e" translate="yes" xml:space="preserve">
          <source>6) inserts elements from initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">6) 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="bbc1e6f4b79824c3f3a7d90e2dd79cf5cb7a13d1" translate="yes" xml:space="preserve">
          <source>6) linear in distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 사이의 거리에 선형</target>
        </trans-unit>
        <trans-unit id="c9a28e1e9c710dfed0962c915392337576c57eaa" translate="yes" xml:space="preserve">
          <source>6) linear in size of &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;s&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="1b14afd05a5e067706a6e82c1bc4f1054275c1d7" translate="yes" xml:space="preserve">
          <source>6) or, if not that, F1 and F2 are non-template functions with the same parameter-type-lists, and F1 is more constrained than F2 according to the &lt;a href=&quot;constraints&quot;&gt;partial ordering of constraints&lt;/a&gt;</source>
          <target state="translated">6) 그렇지 않은 경우 F1과 F2는 동일한 매개 변수 유형 목록을 가진 템플릿이 아닌 함수이며 F1은 제약 조건의 &lt;a href=&quot;constraints&quot;&gt;부분 순서에&lt;/a&gt; 따라 F2보다 더 제한적 입니다.</target>
        </trans-unit>
        <trans-unit id="b7af9e0e8b0138194c7a145b906d7c9634b0a6fd" translate="yes" xml:space="preserve">
          <source>6) reads characters and inserts them to the output sequence controlled by the given &lt;a href=&quot;../basic_streambuf&quot;&gt;&lt;code&gt;basic_streambuf&lt;/code&gt;&lt;/a&gt; object. Characters are extracted and inserted into &lt;code&gt;strbuf&lt;/code&gt; until any of the following occurs:</source>
          <target state="translated">6) 문자를 읽고 주어진 &lt;a href=&quot;../basic_streambuf&quot;&gt; &lt;code&gt;basic_streambuf&lt;/code&gt; &lt;/a&gt; 객체에 의해 제어되는 출력 시퀀스에 삽입 합니다. 다음 중 하나가 발생할 때까지 문자가 추출되어 &lt;code&gt;strbuf&lt;/code&gt; 에 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="679e6c5b3892c534a9499b0b40faa86733d0d123" translate="yes" xml:space="preserve">
          <source>6)(since C++14) The return type of the main function cannot be deduced (&lt;code&gt;auto main() {...&lt;/code&gt; is not allowed)</source>
          <target state="translated">6) (C ++ 14부터) main 함수의 리턴 유형을 추론 할 수 없습니다 ( &lt;code&gt;auto main() {...&lt;/code&gt; 은 허용되지 않습니다)</target>
        </trans-unit>
        <trans-unit id="88eedae576915c3dfe77b629489c675fd6ccf7da" translate="yes" xml:space="preserve">
          <source>6)&lt;a href=&quot;constraints&quot;&gt;Requires-expressions&lt;/a&gt;(C++20)</source>
          <target state="translated">6)&lt;a href=&quot;constraints&quot;&gt;Requires-expressions&lt;/a&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="267bf08b004b63af606312c2bc9950d0b813ba11" translate="yes" xml:space="preserve">
          <source>6)&lt;a href=&quot;derived_class#Private_inheritance&quot;&gt;Private inheritance&lt;/a&gt;: the public and protected members of the &lt;a href=&quot;derived_class&quot;&gt;base class&lt;/a&gt; listed after the specifier are private members of the derived class</source>
          <target state="translated">6) &lt;a href=&quot;derived_class#Private_inheritance&quot;&gt;개인 상속&lt;/a&gt; : 지정자 뒤에 나열된 &lt;a href=&quot;derived_class&quot;&gt;기본 클래스&lt;/a&gt; 의 공용 및 보호 멤버 는 파생 클래스의 개인 멤버입니다.</target>
        </trans-unit>
        <trans-unit id="49e46848eb1266fdfb77940176c18225a3414f40" translate="yes" xml:space="preserve">
          <source>6)&lt;a href=&quot;explicit_cast&quot;&gt;explicit cast&lt;/a&gt; or &lt;a href=&quot;static_cast&quot;&gt;static cast&lt;/a&gt; argument</source>
          <target state="translated">6) &lt;a href=&quot;explicit_cast&quot;&gt;명시 적 캐스트&lt;/a&gt; 또는 &lt;a href=&quot;static_cast&quot;&gt;정적 캐스트&lt;/a&gt; 인수</target>
        </trans-unit>
        <trans-unit id="c1317963d519eafd0ae014fdbd71a06022775ed9" translate="yes" xml:space="preserve">
          <source>6)&lt;a href=&quot;member_template&quot;&gt;member template declarations&lt;/a&gt;</source>
          <target state="translated">6) &lt;a href=&quot;member_template&quot;&gt;회원 템플릿 선언&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aac7c0b66774d057f36bb8008a06eb7df1de50ce" translate="yes" xml:space="preserve">
          <source>6)&lt;a href=&quot;namespace#Using-declarations&quot;&gt;using-declaration&lt;/a&gt;: makes the symbol name from the namespace ns_name accessible for &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; as if declared in the same class scope, block scope, or namespace as where this using-declaration appears.</source>
          <target state="translated">6) &lt;a href=&quot;namespace#Using-declarations&quot;&gt;using-declaration&lt;/a&gt; : 네임 스페이스 ns_name의 심볼 이름 이이 클래스가 사용되는 선언과 동일한 클래스 범위, 블록 범위 또는 네임 스페이스에서 선언 된 것처럼 &lt;a href=&quot;lookup&quot;&gt;규정되지 않은 조회에&lt;/a&gt; 액세스 할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="39ab92b9f2812ca026ef4725fcc92f7c6634b9d9" translate="yes" xml:space="preserve">
          <source>6)&lt;a href=&quot;reference&quot;&gt;Lvalue reference declarator&lt;/a&gt;: the declaration &lt;code&gt;S &amp;amp; D;&lt;/code&gt; declares &lt;code&gt;D&lt;/code&gt; as an lvalue reference to the type determined by decl-specifier-seq&lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">6) &lt;a href=&quot;reference&quot;&gt;Lvalue 참조 선언자&lt;/a&gt; : 선언 &lt;code&gt;S &amp;amp; D;&lt;/code&gt; decl-specifier-seq &lt;code&gt;S&lt;/code&gt; 에 의해 결정된 유형에 대한 lvalue 참조로 &lt;code&gt;D&lt;/code&gt; 를 선언 합니다 .</target>
        </trans-unit>
        <trans-unit id="6c4a97d06cc0195a456021f68760f8b83be8fb7f" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;!(lhs &amp;lt; rhs)&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;!(lhs &amp;lt; rhs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e5408db2bd9c4b3298fa6324e0c75a0111a016f" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;!(x &amp;lt; y)&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;!(x &amp;lt; y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="373087b98660543ba92523c6f66f14336f351fd9" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;CD(lhs).count() / CD(rhs).count()&lt;/code&gt; (the return type of this operator is not a duration)</source>
          <target state="translated">6) &lt;code&gt;CD(lhs).count() / CD(rhs).count()&lt;/code&gt; (이 연산자의 리턴 유형은 지속 기간이 아님)</target>
        </trans-unit>
        <trans-unit id="3bf298333241753c3b7ca50f2595a671ff613187" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;Clock::from_sys(t)&lt;/code&gt;.</source>
          <target state="translated">6)&lt;code&gt;Clock::from_sys(t)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="e5d360eec84bd8bf4e52260f0e640661e938cef7" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;cmp &amp;gt;= 0&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;cmp &amp;gt;= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a6d02cad0ee6cff10031bb47a5c63ba1d706d8a" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;count2&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt;;</source>
          <target state="translated">6) 문자 &lt;code&gt;ch&lt;/code&gt; 의 &lt;code&gt;count2&lt;/code&gt; 사본 ;</target>
        </trans-unit>
        <trans-unit id="b5a4e553cd6023b3bf3481d42959d817f8508fac" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;int(x) &amp;gt;= int(y)&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;int(x) &amp;gt;= int(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b31a8b633ae77ff4a17ccd8f38e76dde9f4dd9f0" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;lhs.base() &amp;gt;= rhs.base()&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;lhs.base() &amp;gt;= rhs.base()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2818f5a2cce3bda339313b486130927db60274a" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;lhs.base() &amp;lt;= rhs.base()&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;lhs.base() &amp;lt;= rhs.base()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53e483d97cd0d674b9a0e23007c0c34bfb1c07a6" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;path() &amp;gt;= rhs.path()&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">6) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;path() &amp;gt;= rhs.path()&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="09c610d6fb7d7e29c571bcdadcf3f5126c21a13f" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;lhs&lt;/code&gt; refers to time point</source>
          <target state="translated">6) &lt;code&gt;lhs&lt;/code&gt; 가 시점을 참조 하면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c88813f92eeed2dfc50e2a0e0a0a2932bf20936" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;true&lt;/code&gt; if the contents of the &lt;code&gt;lhs&lt;/code&gt; are lexicographically</source>
          <target state="translated">6) &lt;code&gt;lhs&lt;/code&gt; 의 내용 이 사전 식 으로되어 있으면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eaa132dada271265232bad508c2f210d814dbbdb" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;unsigned(x) &amp;gt;= unsigned(y)&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;unsigned(x) &amp;gt;= unsigned(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4472d6049d964aa3587beac2c9dc3c4ff5454e8" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;x.date() &amp;gt;= y.date()&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;x.date() &amp;gt;= y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ae4ed8fd061b682ccc736aaa606292a5b9242a0" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;x.month() &amp;gt;= y.month()&lt;/code&gt;</source>
          <target state="translated">6) &lt;code&gt;x.month() &amp;gt;= y.month()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33ce60fd3a3881e1a275135b1c53c4c36ffaf823" translate="yes" xml:space="preserve">
          <source>6)&lt;code&gt;x.name() &amp;gt;= y.name()&lt;/code&gt;.</source>
          <target state="translated">6) &lt;code&gt;x.name() &amp;gt;= y.name()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4995c636b119370fc85d0dded2e09f01a5ff025" translate="yes" xml:space="preserve">
          <source>6,7) A copy of the formerly pointed-to shared pointer</source>
          <target state="translated">6,7) 이전에 지적한 공유 포인터의 사본</target>
        </trans-unit>
        <trans-unit id="72ebefc382e80e8495680c0ccf14de94ceffda20" translate="yes" xml:space="preserve">
          <source>6,7) Same as (2-5), except first performs &lt;a href=&quot;deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;,</source>
          <target state="translated">6, 7)과 동일 (2-5), 최초의 수행을 제외하고 &lt;a href=&quot;deduction_guide&quot;&gt;클래스 템플릿 인수 공제&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="3973f993856f35419f926ce7b1d9aa6a1e04dcaa" translate="yes" xml:space="preserve">
          <source>6-10) Same as (1-5) except that &lt;code&gt;alloc&lt;/code&gt; is used to allocate memory for any internal data structures that the &lt;code&gt;function&lt;/code&gt; might use.</source>
          <target state="translated">6-10) &lt;code&gt;alloc&lt;/code&gt; 을 사용하여 &lt;code&gt;function&lt;/code&gt; 가 사용할 수 있는 내부 데이터 구조에 메모리를 할당 한다는 점을 제외하고 (1-5)와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="51deff4172dbe02081ec58a82d4c18683bc29417" translate="yes" xml:space="preserve">
          <source>6-10) The following constructors are only defined if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;container_type, Alloc&amp;gt;::value == true&lt;/code&gt;, that is, if the underlying container is an allocator-aware container (true for all standard library containers that can be used with &lt;code&gt;queue&lt;/code&gt;).</source>
          <target state="translated">6-10) 다음 생성자는 &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;container_type, Alloc&amp;gt;::value == true&lt;/code&gt; 인 경우 , 즉 기본 컨테이너가 할당 자 인식 컨테이너 인 경우에만 정의됩니다 (모든 표준 라이브러리 컨테이너에 대해 true &lt;code&gt;queue&lt;/code&gt; 와 함께 사용 ).</target>
        </trans-unit>
        <trans-unit id="846c83237292bcdc5df6e7c35effcc6763f6d97d" translate="yes" xml:space="preserve">
          <source>6-10) The following constructors are only defined if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;container_type, Alloc&amp;gt;::value == true&lt;/code&gt;, that is, if the underlying container is an allocator-aware container (true for all standard library containers that can be used with &lt;code&gt;stack&lt;/code&gt;).</source>
          <target state="translated">6-10) 다음 생성자는 &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;container_type, Alloc&amp;gt;::value == true&lt;/code&gt; 인 경우 , 즉 기본 컨테이너가 할당 자 인식 컨테이너 인 경우에만 정의됩니다 (모든 표준 라이브러리 컨테이너에 대해 true &lt;code&gt;stack&lt;/code&gt; 과 함께 사용 ).</target>
        </trans-unit>
        <trans-unit id="bbfd8d940476d79f8c7dad4999eb544533b0d8a6" translate="yes" xml:space="preserve">
          <source>6-7) Conversions to and from &lt;code&gt;std::chrono::sys_time&lt;/code&gt; when &lt;code&gt;Clock&lt;/code&gt; supports &lt;code&gt;from_sys&lt;/code&gt; and &lt;code&gt;to_sys&lt;/code&gt;: &lt;code&gt;operator()&lt;/code&gt; calls &lt;code&gt;Clock::to_sys&lt;/code&gt; and &lt;code&gt;Clock::from_sys&lt;/code&gt;, respectively.</source>
          <target state="translated">6-7) &lt;code&gt;Clock&lt;/code&gt; 이 &lt;code&gt;from_sys&lt;/code&gt; 및 &lt;code&gt;to_sys&lt;/code&gt; 를 지원할 때 &lt;code&gt;std::chrono::sys_time&lt;/code&gt; 으로 /에서 변환 : &lt;code&gt;operator()&lt;/code&gt; 는 각각 &lt;code&gt;Clock::to_sys&lt;/code&gt; 및 &lt;code&gt;Clock::from_sys&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5ed1745ebbd972345bc29d3e167364213c346b50" translate="yes" xml:space="preserve">
          <source>6-7) Same as (4-5), but additionally uses a copy of &lt;code&gt;alloc&lt;/code&gt; for allocation of data for internal use. &lt;code&gt;Alloc&lt;/code&gt; must be an &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">6-7) (4-5)와 동일하지만 내부 용으로 데이터를 &lt;code&gt;alloc&lt;/code&gt; 하기 위해 할당 사본을 추가로 사용합니다 . &lt;code&gt;Alloc&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f0dbd685c36874da9cdb19506a59f28ded100af" translate="yes" xml:space="preserve">
          <source>6-8) Constant.</source>
          <target state="translated">6-8) 상수.</target>
        </trans-unit>
        <trans-unit id="d47982d562d2388a117ee9422f1b4ab7eb44577f" translate="yes" xml:space="preserve">
          <source>6-8) Same as &lt;code&gt;strstreambuf((char*)gnext, n)&lt;/code&gt;, except the &quot;constant&quot; bit is set in the buffer state bitmask (output to this buffer is not allowed)</source>
          <target state="translated">6-8) &quot;constant&quot;비트가 버퍼 상태 비트 마스크에 설정되어 있다는 점을 제외하고 &lt;code&gt;strstreambuf((char*)gnext, n)&lt;/code&gt; 과 동일 (이 버퍼로의 출력은 허용되지 않음)</target>
        </trans-unit>
        <trans-unit id="b6023f9d01fb30701914d07f472b965ca8400d10" translate="yes" xml:space="preserve">
          <source>6-8)&lt;code&gt;&lt;a href=&quot;../regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; if the supplied regular expression is not valid.</source>
          <target state="translated">6-8) 제공된 정규식이 유효하지 않으면 &lt;code&gt;&lt;a href=&quot;../regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="799b3f397474ee9ee72305c7f25127a7996447f7" translate="yes" xml:space="preserve">
          <source>6-9) An iterator which refers to the copy of the first inserted character or &lt;code&gt;pos&lt;/code&gt; if no characters were inserted (&lt;code&gt;count==0&lt;/code&gt; or &lt;code&gt;first==last&lt;/code&gt; or &lt;code&gt;ilist.size()==0&lt;/code&gt;)</source>
          <target state="translated">6-9) 삽입 된 문자 가없는 경우 첫 번째 삽입 된 문자 또는 &lt;code&gt;pos&lt;/code&gt; 의 사본을 참조하는 반복자 ( &lt;code&gt;count==0&lt;/code&gt; 또는 &lt;code&gt;first==last&lt;/code&gt; 또는 &lt;code&gt;ilist.size()==0&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f4b1fdcf6dea0a5eb0ad763cb8508bfa636b2ae3" translate="yes" xml:space="preserve">
          <source>6.1) If both &lt;code&gt;E2&lt;/code&gt; and &lt;code&gt;E3&lt;/code&gt; now have the same type, the result is a prvalue of that type designating a temporary object(until C++17)whose result object is(since C++17) copy-initialized from whatever operand was selected after evaluating &lt;code&gt;E1&lt;/code&gt;.</source>
          <target state="translated">6.1) &lt;code&gt;E2&lt;/code&gt; 와 &lt;code&gt;E3&lt;/code&gt; 이 모두 같은 유형을 가지면 결과는 (C ++ 17부터) 피연산자에서 복사 초기화 된 임시 객체 (C ++ 17까지)를 지정하는 해당 유형의 prvalue입니다. &lt;code&gt;E1&lt;/code&gt; 평가 후 선택됨 .</target>
        </trans-unit>
        <trans-unit id="b0c874261a137004f2be6b8f2b98271e068a676a" translate="yes" xml:space="preserve">
          <source>6.2) If both &lt;code&gt;E2&lt;/code&gt; and &lt;code&gt;E3&lt;/code&gt; have arithmetic or enumeration type: the &lt;a href=&quot;operator_arithmetic#conversions&quot;&gt;&lt;i&gt;usual arithmetic conversions&lt;/i&gt;&lt;/a&gt; are applied to bring them to</source>
          <target state="translated">6.2) &lt;code&gt;E2&lt;/code&gt; 와 &lt;code&gt;E3&lt;/code&gt; 에 모두 산술 또는 열거 유형이있는 경우 : &lt;a href=&quot;operator_arithmetic#conversions&quot;&gt;&lt;i&gt;일반적인 산술 변환&lt;/i&gt;&lt;/a&gt; 이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e551965fa19d611854e6eee5de6c783d78fce64" translate="yes" xml:space="preserve">
          <source>6.3) If both &lt;code&gt;E2&lt;/code&gt; and &lt;code&gt;E3&lt;/code&gt; are pointers, or one is a pointer and the other is a null pointer constant, then pointer conversions and qualification conversions are applied to bring them to common type, and that type is the result.</source>
          <target state="translated">6.3) &lt;code&gt;E2&lt;/code&gt; 와 &lt;code&gt;E3&lt;/code&gt; 가 모두 포인터이거나 하나가 포인터이고 다른 하나가 널 포인터 상수 인 경우, 포인터 변환과 제한 변환이 적용되어 공통 유형으로 전환되고 그 유형이 결과입니다.</target>
        </trans-unit>
        <trans-unit id="1e50a3a37924e6ae1070a390e681f631b9a08e5f" translate="yes" xml:space="preserve">
          <source>6.4) If both &lt;code&gt;E2&lt;/code&gt; and &lt;code&gt;E3&lt;/code&gt; are pointers to members, or one is a pointer to member and the other is a null pointer constant, then pointer-to-member conversions and qualification conversions are applied to bring them to common type, and that type is the result.</source>
          <target state="translated">6.4) &lt;code&gt;E2&lt;/code&gt; 와 &lt;code&gt;E3&lt;/code&gt; 이 모두 멤버를 가리키는 포인터이거나 하나가 멤버를 가리키는 포인터이고 다른 하나가 널 포인터 상수 인 경우, 포인터 대 멤버 변환 및 제한 변환을 적용하여 공통 유형으로 변환합니다. 결과입니다.</target>
        </trans-unit>
        <trans-unit id="ec4db8b29f8954d7e2dc1343c6b71f2ed7fb9882" translate="yes" xml:space="preserve">
          <source>6.5) If both &lt;code&gt;E2&lt;/code&gt; and &lt;code&gt;E3&lt;/code&gt; are null pointer constants, and at least one of which is of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, then the result's type is &lt;code&gt;std::nullptr_t&lt;/code&gt;.</source>
          <target state="translated">6.5) 두 경우 &lt;code&gt;E2&lt;/code&gt; 및 &lt;code&gt;E3&lt;/code&gt; 가 널 포인터 상수이고, 적어도 타입입니다 어느 하나에 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , 결과의 유형입니다 &lt;code&gt;std::nullptr_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94e1e829595edc61799b9eeaec5e3fbac1deb53d" translate="yes" xml:space="preserve">
          <source>6.6) In all other cases, the program is ill-formed.</source>
          <target state="translated">6.6) 다른 모든 경우에는 프로그램이 잘못 형성됩니다.</target>
        </trans-unit>
        <trans-unit id="ae77fc952e7061f865ad3bacd928039d4de0ab9d" translate="yes" xml:space="preserve">
          <source>6.6.1 Main function (p: 66)</source>
          <target state="translated">6.6.1 주요 기능 (p : 66)</target>
        </trans-unit>
        <trans-unit id="c66c65175fecc3103b3b587be9b5b230889c8628" translate="yes" xml:space="preserve">
          <source>64</source>
          <target state="translated">64</target>
        </trans-unit>
        <trans-unit id="4832ef1d5006ce865748530e8f09ff7d2e02f29f" translate="yes" xml:space="preserve">
          <source>64 bit systems:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf24fa59a1190ea3fb320a6124062c37e8132e1" translate="yes" xml:space="preserve">
          <source>64-bit Mersenne Twister by Matsumoto and Nishimura, 2000.</source>
          <target state="translated">2000 년 Matsumoto와 Nishimura의 64 비트 Mersenne Twister</target>
        </trans-unit>
        <trans-unit id="23530cc9c0730b90287c4b59ac8e487ccf46d5c3" translate="yes" xml:space="preserve">
          <source>65&amp;ndash;70</source>
          <target state="translated">65&amp;ndash;70</target>
        </trans-unit>
        <trans-unit id="902ba3cda1883801594b6e1b452790cc53948fda" translate="yes" xml:space="preserve">
          <source>7</source>
          <target state="translated">7</target>
        </trans-unit>
        <trans-unit id="a4432d6a5dff8fd6d76e568b89a9cbc087f25718" translate="yes" xml:space="preserve">
          <source>7) A set of overloads or a function template accepting an argument of any &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;. Equivalent to (5) (the argument is cast to &lt;code&gt;double&lt;/code&gt;).</source>
          <target state="translated">7) &lt;a href=&quot;../../types/is_integral&quot;&gt;일체형&lt;/a&gt; 의 인수를 받아들이는 과부하 또는 함수 템플릿 집합 . (5)와 같습니다 (인수가 &lt;code&gt;double&lt;/code&gt; 로 캐스트 됨 ).</target>
        </trans-unit>
        <trans-unit id="5e090a1de6bee9c83f88a89ecfa34a144b9134ef" translate="yes" xml:space="preserve">
          <source>7) A set of overloads or a function template for all combinations of arguments of arithmetic type not covered by 1-3). If any argument has &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;. If any argument is &lt;code&gt;long double&lt;/code&gt;, then the return type &lt;code&gt;Promoted&lt;/code&gt; is also &lt;code&gt;long double&lt;/code&gt;, otherwise the return type is always &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">7) 1-3에 포함되지 않은 모든 산술 유형의 인수 조합에 대한 과부하 세트 또는 함수 템플릿. 인수에 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 . 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 &lt;code&gt;Promoted&lt;/code&gt; 유형 인 리턴 유형 도 &lt;code&gt;long double&lt;/code&gt; 이며, 그렇지 않으면 반환 유형이 항상 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8225635f06d76daa9e47e45db30245333acce7c3" translate="yes" xml:space="preserve">
          <source>7) Allocator-extended move constructor. Using &lt;code&gt;alloc&lt;/code&gt; as the allocator for the new container, moving the contents from &lt;code&gt;other&lt;/code&gt;; if &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt;, this results in an element-wise move.</source>
          <target state="translated">7) 할당 자 확장 이동 생성자. &lt;code&gt;alloc&lt;/code&gt; 을 새 컨테이너의 할당 자로 사용 하여 내용을 &lt;code&gt;other&lt;/code&gt; 컨테이너에서 이동 ; 만약 &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt; , 요소 - 현명한이 결과.</target>
        </trans-unit>
        <trans-unit id="fd12576c3d56f90d6f228a4c5d98594e6ae413d6" translate="yes" xml:space="preserve">
          <source>7) Allocator-extended move constructor. Using &lt;code&gt;alloc&lt;/code&gt; as the allocator for the new container, moving the contents from &lt;code&gt;other&lt;/code&gt;; if &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt;, this results in an element-wise move. (in that case, &lt;code&gt;other&lt;/code&gt; is not guaranteed to be empty after the move)</source>
          <target state="translated">7) 할당 자 확장 이동 생성자. &lt;code&gt;alloc&lt;/code&gt; 을 새 컨테이너의 할당 자로 사용 하여 내용을 &lt;code&gt;other&lt;/code&gt; 컨테이너에서 이동 ; 만약 &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt; , 요소 - 현명한이 결과. (이 경우 이동 후 &lt;code&gt;other&lt;/code&gt; 것은 비워 둘 수 없습니다)</target>
        </trans-unit>
        <trans-unit id="e566bd7b5a50fb99304af754f915092fc12c2483" translate="yes" xml:space="preserve">
          <source>7) Any pointer to function can be converted to a pointer to a different function type. Calling the function through a pointer to a different function type is undefined, but converting such pointer back to pointer to the original function type yields the pointer to the original function.</source>
          <target state="translated">7) 함수에 대한 포인터는 다른 함수 유형에 대한 포인터로 변환 될 수 있습니다. 다른 함수 유형에 대한 포인터를 통해 함수를 호출하는 것은 정의되어 있지 않지만 해당 포인터를 원래 함수 유형으로 다시 변환하면 원래 함수에 대한 포인터가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="781c117d3a0d5f6caecb2e853604c5e010c4c8a9" translate="yes" xml:space="preserve">
          <source>7) Appends characters from the initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">7) 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 문자를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="cf250e6f5d53c0899a94bff5484349a0ad668b7c" translate="yes" xml:space="preserve">
          <source>7) Assigns the characters in the initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">7) 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 에 문자를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="4a93966568820ea3bb6651ed6a4d221ef5695d39" translate="yes" xml:space="preserve">
          <source>7) Behaves as a &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, which may skip leading whitespace, extracts a generic pointer value by calling &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;std::num_get::get()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">7) &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction으로&lt;/a&gt; 동작합니다 . 선행 공백을 건너 뛸 수있는 센트리 객체를 구성하고 확인한 후 &lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;std::num_get::get()&lt;/code&gt; &lt;/a&gt; 을 호출하여 일반 포인터 값을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="2d512999a36270926a0e3e8d9fd917b1e11136e6" translate="yes" xml:space="preserve">
          <source>7) Called by the non-throwing non-array &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; when the object's alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;. The standard library implementation calls the version (3) and returns a null pointer on failure instead of propagating the exception.</source>
          <target state="translated">7) 객체의 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하면 비 투사 비 배열 &lt;a href=&quot;../../language/new&quot;&gt;새로운 표현에&lt;/a&gt; 의해 호출됩니다 . 표준 라이브러리 구현은 버전 (3)을 호출하고 예외를 전파하는 대신 실패시 널 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a23e66d14089771bef9143063b9575633f4a138a" translate="yes" xml:space="preserve">
          <source>7) Checks whether &lt;a href=&quot;stem&quot;&gt;&lt;code&gt;stem()&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">7) &lt;a href=&quot;stem&quot;&gt; &lt;code&gt;stem()&lt;/code&gt; &lt;/a&gt; 이 비어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="78b158b9fb598bbc6e3c05a8eada91e32d9703ec" translate="yes" xml:space="preserve">
          <source>7) Constructs a &lt;code&gt;unique_ptr&lt;/code&gt; where the stored pointer is initialized with &lt;code&gt;u.release()&lt;/code&gt; and the stored deleter is value-initialized. This constructor only participates in overload resolution if &lt;code&gt;U*&lt;/code&gt; is implicitly convertible to &lt;code&gt;T*&lt;/code&gt; and &lt;code&gt;Deleter&lt;/code&gt; is the same type as &lt;code&gt;std::default_delete&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">7) 저장된 포인터가 &lt;code&gt;u.release()&lt;/code&gt; 초기화되고 저장된 삭제 기가 값으로 초기화 되는 &lt;code&gt;unique_ptr&lt;/code&gt; 을 구성합니다 . 이 생성자 는 &lt;code&gt;U*&lt;/code&gt; 가 암시 적으로 &lt;code&gt;T*&lt;/code&gt; 로 변환 가능 하고 &lt;code&gt;Deleter&lt;/code&gt; 가 &lt;code&gt;std::default_delete&amp;lt;T&amp;gt;&lt;/code&gt; 와 동일한 유형 인 경우에만 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="f6456a6ad00328fd3cff0effaf63d08dfa620101" translate="yes" xml:space="preserve">
          <source>7) Constructs a copy of &lt;code&gt;other&lt;/code&gt; except for the facet of type &lt;code&gt;Facet&lt;/code&gt; (typically deduced from the type of the argument) which is installed from the argument &lt;code&gt;facet&lt;/code&gt;. If &lt;code&gt;facet&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the constructed locale is a full copy of &lt;code&gt;other&lt;/code&gt;. The locale constructed in this manner has no name.</source>
          <target state="translated">7)의 복사본 구축 &lt;code&gt;other&lt;/code&gt; 유형의 일면을 제외한 &lt;code&gt;Facet&lt;/code&gt; 인수로부터 설치된 통상적 인수의 타입 추론 () &lt;code&gt;facet&lt;/code&gt; . 경우 &lt;code&gt;facet&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 이 , 구축 된 로케일의 전체 복사본입니다 &lt;code&gt;other&lt;/code&gt; . 이러한 방식으로 구성된 로캘에는 이름이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4d7b7181d1e20e5b1ff7c14b02e5b25a354c817" translate="yes" xml:space="preserve">
          <source>7) Constructs a variant with the alternative T_i specified by the index &lt;code&gt;I&lt;/code&gt; and initializes the contained value with the arguments &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. If T_i's selected constructor is a constexpr constructor, this constructor is also a constexpr constructor. This overload only participates in overload resolution if &lt;code&gt;I &amp;lt; sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T_i, Args...&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">7) 인덱스 &lt;code&gt;I&lt;/code&gt; 로 지정된 대체 T_i로 변형을 구성하고 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 인수로 포함 된 값을 초기화합니다 . T_i의 선택된 생성자가 constexpr 생성자 인 경우이 생성자는 constexpr 생성자이기도합니다. 이 &lt;code&gt;I &amp;lt; sizeof...(Types)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T_i, Args...&amp;gt;&lt;/code&gt; ... (Types) 및 std :: is_constructible_v &amp;lt;T_i, Args ...&amp;gt; 가 true 인 경우에만이 과부하가 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="4ccfbda94891f91f32fdbc7923092e23042f2cb5" translate="yes" xml:space="preserve">
          <source>7) Constructs an optional object that</source>
          <target state="translated">7) 다음과 같은 선택적 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="da171e9b6aa1fc7e77b6e459ae24c68b18df6cbb" translate="yes" xml:space="preserve">
          <source>7) Constructs the underlying container using &lt;code&gt;alloc&lt;/code&gt; as allocator. Effectively calls &lt;code&gt;c(alloc)&lt;/code&gt;. &lt;code&gt;comp&lt;/code&gt; is value-initialized.</source>
          <target state="translated">7) &lt;code&gt;alloc&lt;/code&gt; 을 할당 자로 사용하여 기본 컨테이너를 구성합니다 . 효과적으로 &lt;code&gt;c(alloc)&lt;/code&gt; 호출합니다 . &lt;code&gt;comp&lt;/code&gt; 는 값이 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="3b750f709b9fe26c1a386ef6c8456cc8d62d23ff" translate="yes" xml:space="preserve">
          <source>7) Constructs the underlying container with the contents of &lt;code&gt;cont&lt;/code&gt; and using &lt;code&gt;alloc&lt;/code&gt; as allocator, as if by &lt;code&gt;c(cont, alloc)&lt;/code&gt;.</source>
          <target state="translated">7) &lt;code&gt;c(cont, alloc)&lt;/code&gt; 처럼 마치 &lt;code&gt;cont&lt;/code&gt; 의 내용을 가지고 &lt;code&gt;alloc&lt;/code&gt; 을 할당 자로 사용 하는 기본 컨테이너를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="c187c0ebe92a6cb0f89444ac3756bf813d956bb6" translate="yes" xml:space="preserve">
          <source>7) Converts the duration &lt;code&gt;d&lt;/code&gt; to one whose &lt;code&gt;rep&lt;/code&gt; is the common type between &lt;code&gt;Rep1&lt;/code&gt; and &lt;code&gt;Rep2&lt;/code&gt;, and creates a duration whose tick count is the remainder of the division of the tick count, after conversion, by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">7) 변환 기간 &lt;code&gt;d&lt;/code&gt; 하나 &lt;code&gt;rep&lt;/code&gt; 의 일반적인 유형 &lt;code&gt;Rep1&lt;/code&gt; 및 &lt;code&gt;Rep2&lt;/code&gt; 을 하고, 그 카운트 틱 틱 카운트 변환 후의 처리함으로써 나눗셈의 나머지 기간 인 생성 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e24ea18582f27e244de0137ef91f95a0e84a8db6" translate="yes" xml:space="preserve">
          <source>7) Copy constructor is defaulted, and is &lt;code&gt;constexpr&lt;/code&gt; if copying of both elements satisfies the requirements on constexpr functions.</source>
          <target state="translated">7) 복사 생성자는 디폴트로 설정하고, &lt;code&gt;constexpr&lt;/code&gt; 요소 모두 만족 constexpr의 기능에 대한 요구를 복사하는 경우.</target>
        </trans-unit>
        <trans-unit id="2d16e7e9a965f6f357fd09912e10d86b763c8fd6" translate="yes" xml:space="preserve">
          <source>7) Copy constructor is deleted.</source>
          <target state="translated">7) 복사 생성자가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ed4eff44e6d7c3de17664f18e5e7435ee785ce85" translate="yes" xml:space="preserve">
          <source>7) Copy constructor. Constructs the string with the copy of the contents of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">7) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 의 내용을 복사하여 문자열을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="69a2da12183da386e2accd7f3051d0030622c392" translate="yes" xml:space="preserve">
          <source>7) Error status indicator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd85d6336f8a13c2e55ad50a19dbd16990504a06" translate="yes" xml:space="preserve">
          <source>7) For arguments of type pointer to member function F of class X, the function parameter types, the function return type, and the class X are examined and their associated set of classes and namespaces are added to the set.</source>
          <target state="translated">7) 클래스 X의 멤버 함수 F에 대한 포인터 유형의 인수에 대해 함수 매개 변수 유형, 함수 리턴 유형 및 클래스 X가 검사되고 연관된 클래스 및 네임 스페이스 세트가 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e24dbc5b7edff14ef42a3b33711a5455054d601d" translate="yes" xml:space="preserve">
          <source>7) If &lt;code&gt;nh&lt;/code&gt; is an empty &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;, does nothing. Otherwise, inserts the element owned by &lt;code&gt;nh&lt;/code&gt; into the container , if the container doesn't already contain an element with a key equivalent to &lt;code&gt;nh.key()&lt;/code&gt;. The behavior is undefined if &lt;code&gt;nh&lt;/code&gt; is not empty and &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">7) &lt;code&gt;nh&lt;/code&gt; 가 빈 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 이면 아무 것도 수행하지 않습니다. 그렇지 않으면, 컨테이너에 &lt;code&gt;nh.key()&lt;/code&gt; 와 동일한 키를 가진 요소가 컨테이너에 포함되어 있지 않으면 &lt;code&gt;nh&lt;/code&gt; 소유의 요소를 container 에 삽입합니다 . &lt;code&gt;nh&lt;/code&gt; 이 비어 있지 않고 &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9fb35eafba94666fd148985a23f1e946eb4fbf35" translate="yes" xml:space="preserve">
          <source>7) If &lt;code&gt;nh&lt;/code&gt; is an empty &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;, does nothing. Otherwise, inserts the element owned by &lt;code&gt;nh&lt;/code&gt; into the container and returns an iterator pointing at the inserted element. If a range containing elements with keys equivalent to &lt;code&gt;nh.key()&lt;/code&gt; exists in the container, the element is inserted at the end of that range. The behavior is undefined if &lt;code&gt;nh&lt;/code&gt; is not empty and &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">7) &lt;code&gt;nh&lt;/code&gt; 가 빈 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 이면 아무 것도 수행하지 않습니다. 그렇지 않으면 &lt;code&gt;nh&lt;/code&gt; 가 소유 한 요소를 컨테이너에 삽입하고 삽입 된 요소를 가리키는 반복자를 리턴합니다. 컨테이너에 &lt;code&gt;nh.key()&lt;/code&gt; 와 동일한 키를 가진 요소가 포함 된 범위가 컨테이너에 있으면 해당 범위의 끝에 요소가 삽입됩니다. &lt;code&gt;nh&lt;/code&gt; 이 비어 있지 않고 &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5912e27d1e678829a48565e6977190e8e1bf249e" translate="yes" xml:space="preserve">
          <source>7) If &lt;code&gt;nh&lt;/code&gt; is an empty &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;, does nothing. Otherwise, inserts the element owned by &lt;code&gt;nh&lt;/code&gt; into the container and returns an iterator pointing at the inserted element.. The behavior is undefined if &lt;code&gt;nh&lt;/code&gt; is not empty and &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">7) &lt;code&gt;nh&lt;/code&gt; 가 빈 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 이면 아무 것도 수행하지 않습니다. 그렇지 않으면, &lt;code&gt;nh&lt;/code&gt; 가 소유 한 요소를 컨테이너에 삽입하고 삽입 된 요소를 가리키는 반복자를 리턴합니다. &lt;code&gt;nh&lt;/code&gt; 가 비어 있지 않고 &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt; 경우 동작은 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bb314f2778a4addd808572fd6fc27141a9ee9a3d" translate="yes" xml:space="preserve">
          <source>7) If the last filename is dot-dot, remove any trailing directory-separator.</source>
          <target state="translated">7) 마지막 파일 이름이 점이면 후행 디렉토리 구분자를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="930050bff71f7db8482766b37c9fd064ae63233e" translate="yes" xml:space="preserve">
          <source>7) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then compares this string to &lt;code&gt;sv&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">7) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음이 문자열을 &lt;code&gt;sv&lt;/code&gt; 와 비교합니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="ec2a500afb603354e968524b1c93c978e05c7f9f" translate="yes" xml:space="preserve">
          <source>7) Inserts &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt; before the element (if any) pointed by &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">7) 삽입물 &lt;code&gt;count&lt;/code&gt; 캐릭터의 복사본 &lt;code&gt;ch&lt;/code&gt; 가리키는 요소 (만약 있다면) 이전 &lt;code&gt;pos&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24205abf1c8eaf4543aa40984f7ba8840a9bfeff" translate="yes" xml:space="preserve">
          <source>7) Inserts elements from range &lt;code&gt;[first, last)&lt;/code&gt;. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;LWG2844&lt;/a&gt;).</source>
          <target state="translated">7) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소를 삽입합니다 . 범위의 여러 요소에 동등한 키가있는 경우 삽입 할 요소가 지정되지 &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;않습니다&lt;/a&gt; ( LWG2844 보류 중 ).</target>
        </trans-unit>
        <trans-unit id="ab4d28bf722a40ac047d7d432e20a3ac61224be8" translate="yes" xml:space="preserve">
          <source>7) Linear if &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt;, otherwise constant.</source>
          <target state="translated">7) &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt; 이면 선형 , 그렇지 않으면 상수.</target>
        </trans-unit>
        <trans-unit id="091f356f1a62d1b85675326707804d8301a629ba" translate="yes" xml:space="preserve">
          <source>7) Logarithmic in the size of the container, &lt;code&gt;O(log(size()))&lt;/code&gt;.</source>
          <target state="translated">7) 컨테이너 크기의 &lt;code&gt;O(log(size()))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c029cf1874081dd86e61770a00572857eef173d4" translate="yes" xml:space="preserve">
          <source>7) Pair move constructor. Constructs a 2-element tuple with the first element constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U1&amp;gt;(p.first)&lt;/code&gt; and the second element from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U2&amp;gt;(p.second)&lt;/code&gt;</source>
          <target state="translated">7) 페어 이동 생성자. &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U1&amp;gt;(p.first)&lt;/code&gt; 구성된 첫 번째 요소와 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U2&amp;gt;(p.second)&lt;/code&gt; &amp;lt;U2&amp;gt; (p.second) 의 두 번째 요소로 2 요소 튜플을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="f5eb5f14ce0bdc17537034ca0f6f6a7032f9c17f" translate="yes" xml:space="preserve">
          <source>7) Range constructor. Constructs the string with the contents of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">7) 범위 생성자. &lt;code&gt;[first, last)&lt;/code&gt; 범위의 내용으로 문자열을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="840a9e8f802e910474b5e4552055d69fbd511b5d" translate="yes" xml:space="preserve">
          <source>7) Replaces the contents with copies of the characters in the range &lt;code&gt;[first, last)&lt;/code&gt;. This overload does not participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.(since C++11)</source>
          <target state="translated">7) 내용을 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 문자 사본으로 대체합니다 . &lt;code&gt;InputIt&lt;/code&gt; 이 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator를&lt;/a&gt; 만족시키지 않는 경우,이 과부하는 과부하 해결에 관여 하지 않습니다 . (C ++ 11 이후)</target>
        </trans-unit>
        <trans-unit id="a1c3502bc20a0772937b9a46dcfe0f32b57691ec" translate="yes" xml:space="preserve">
          <source>7) Returns &lt;code&gt;Clock::to_sys(t)&lt;/code&gt;. This overload only participates in overload resolution if the expression &lt;code&gt;Clock::to_sys(t)&lt;/code&gt; is well-formed. The program is ill-formed if &lt;code&gt;Clock::to_sys(t)&lt;/code&gt; does not return &lt;code&gt;&lt;a href=&quot;system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;Duration&amp;gt;&lt;/code&gt; where &lt;code&gt;Duration&lt;/code&gt; is some valid specialization of &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">7) &lt;code&gt;Clock::to_sys(t)&lt;/code&gt; )를 반환 합니다. &lt;code&gt;Clock::to_sys(t)&lt;/code&gt; 식의 형식이 올바른 경우이 과부하는 과부하 해결에만 참여 합니다. &lt;code&gt;Clock::to_sys(t)&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;Duration&amp;gt;&lt;/code&gt; 반환하지 않으면 프로그램은 잘못된 형식입니다. 여기서 &lt;code&gt;Duration&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 의 일부 유효한 특수화입니다 .</target>
        </trans-unit>
        <trans-unit id="8d069f37a276cbfb9f1963e5c4969c4a0714e184" translate="yes" xml:space="preserve">
          <source>7) Returns an &lt;code&gt;insert_return_type&lt;/code&gt; with the members initialized as follows: if &lt;code&gt;nh&lt;/code&gt; is empty, &lt;code&gt;inserted&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;end()&lt;/code&gt;, and &lt;code&gt;node&lt;/code&gt; is empty. Otherwise if the insertion took place, &lt;code&gt;inserted&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt; points to the inserted element, and &lt;code&gt;node&lt;/code&gt; is empty. If the insertion failed, &lt;code&gt;inserted&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt; has the previous value of &lt;code&gt;nh&lt;/code&gt;, and &lt;code&gt;position&lt;/code&gt; points to an element with a key equivalent to &lt;code&gt;nh.key()&lt;/code&gt;.</source>
          <target state="translated">7) 다음과 같이 초기화 된 멤버와 함께 &lt;code&gt;insert_return_type&lt;/code&gt; 을 리턴 합니다. &lt;code&gt;nh&lt;/code&gt; 이 비어 있고 &lt;code&gt;inserted&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 이면 &lt;code&gt;position&lt;/code&gt; 이 &lt;code&gt;end()&lt;/code&gt; 이고 &lt;code&gt;node&lt;/code&gt; 가 비어 있습니다. 그렇지 않으면 삽입이 발생하면 &lt;code&gt;inserted&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;position&lt;/code&gt; 가 삽입 된 요소를 가리키고 &lt;code&gt;node&lt;/code&gt; 가 비어 있습니다. 삽입 실패, &lt;code&gt;inserted&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;node&lt;/code&gt; 의 이전 값은 &lt;code&gt;nh&lt;/code&gt; 이며 &lt;code&gt;position&lt;/code&gt; 은 &lt;code&gt;nh.key()&lt;/code&gt; 와 동일한 키를 가진 요소를 가리 킵니다..</target>
        </trans-unit>
        <trans-unit id="898263f1d7167569d8cbd17e06b3d2153f39612e" translate="yes" xml:space="preserve">
          <source>7) Returns the difference in months between the two time points represented by &lt;code&gt;ym1&lt;/code&gt; and &lt;code&gt;ym2&lt;/code&gt;.</source>
          <target state="translated">7) &lt;code&gt;ym1&lt;/code&gt; 과 &lt;code&gt;ym2&lt;/code&gt; 로 표시된 두 시점 사이의 월 차이를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="28fb154360e20c089ab095a84705b1b52b17311d" translate="yes" xml:space="preserve">
          <source>7) Same as (2), except that the individual array elements are &lt;a href=&quot;../../language/default_initialization&quot;&gt;default-initialized&lt;/a&gt;.</source>
          <target state="translated">7) 개별 배열 요소가 &lt;a href=&quot;../../language/default_initialization&quot;&gt;기본값으로 초기화&lt;/a&gt; 된다는 점을 제외하고 (2)와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="b057f82f1d982eacd7d7fa17f3f2d8a925a5a3ee" translate="yes" xml:space="preserve">
          <source>7) Stores the shared pointer &lt;code&gt;r&lt;/code&gt; in the shared pointer pointed to by &lt;code&gt;p&lt;/code&gt; and returns the value formerly pointed-to by &lt;code&gt;p&lt;/code&gt;, atomically. Effectively executes &lt;code&gt;p-&amp;gt;swap(r)&lt;/code&gt; and returns a copy of &lt;code&gt;r&lt;/code&gt; after the swap.</source>
          <target state="translated">7) 공유 포인터 &lt;code&gt;r&lt;/code&gt; 을 &lt;code&gt;p&lt;/code&gt; 가 가리키는 공유 포인터에 저장하고 이전에 &lt;code&gt;p&lt;/code&gt; 가 가리키는 값을 원자 적으로 반환합니다 . 효과적으로 &lt;code&gt;p-&amp;gt;swap(r)&lt;/code&gt; 실행 하고 스왑 후에 &lt;code&gt;r&lt;/code&gt; 의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8bada61d85722f29ce10ed329e74beccb023f7b1" translate="yes" xml:space="preserve">
          <source>7) The copy-constructor is deleted: this class is not copyable.</source>
          <target state="translated">7) 복사 생성자가 삭제되었습니다.이 클래스는 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ddafddca81ef1930c27689a805a3a9bc5b6d04a8" translate="yes" xml:space="preserve">
          <source>7) The overload 3 is prohibited from accepting temporary strings, otherwise this function populates match_results m with string iterators that become invalid immediately.</source>
          <target state="translated">7) 과부하 3은 임시 문자열을 허용하지 않습니다. 그렇지 않으면이 함수는 match_results m을 즉시 무효화되는 문자열 반복자로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="596bca819e072d18a96a69398cad3f7c2e8aafb4" translate="yes" xml:space="preserve">
          <source>7) The overload 4 is prohibited from accepting temporary strings, otherwise this function populates match_results m with string iterators that become invalid immediately.</source>
          <target state="translated">7) 과부하 4는 임시 문자열을 허용하지 않습니다. 그렇지 않으면이 함수는 match_results m을 즉시 무효화되는 문자열 반복자로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="637ae7e932eaeb370872734a7ede665277a4aa31" translate="yes" xml:space="preserve">
          <source>7) The parameter &lt;code&gt;P&lt;/code&gt; which is a parameter pack and does not occur at the end of the parameter list:</source>
          <target state="translated">7) 파라미터 팩이며 파라미터 목록의 끝에서 발생하지 않는 파라미터 &lt;code&gt;P&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="11d4c7d7a8740a1c24a2bf64af65f9417957f1e5" translate="yes" xml:space="preserve">
          <source>7) Tries to lock the associated mutex by calling &lt;code&gt;m.try_lock_for(timeout_duration)&lt;/code&gt;. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. May block for longer than &lt;code&gt;timeout_duration&lt;/code&gt;.</source>
          <target state="translated">7) &lt;code&gt;m.try_lock_for(timeout_duration)&lt;/code&gt; 을 호출하여 연관된 뮤텍스를 잠그려고 시도합니다 . 지정된 &lt;code&gt;timeout_duration&lt;/code&gt; 이 경과하거나 잠금이 획득 될 때까지 차단합니다 . &lt;code&gt;timeout_duration&lt;/code&gt; 보다 길게 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41cae9c504653d812e4ad8d3615114218b167cc1" translate="yes" xml:space="preserve">
          <source>7) Tries to lock the associated mutex in shared mode by calling &lt;code&gt;m.try_lock_shared_until(timeout_duration)&lt;/code&gt;, which blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. May block for longer than &lt;code&gt;timeout_duration&lt;/code&gt;. The behavior is undefined if this thread already owns the mutex in any mode.</source>
          <target state="translated">7) &lt;code&gt;m.try_lock_shared_until(timeout_duration)&lt;/code&gt; 을 호출하여 연결된 뮤텍스를 공유하려고 시도합니다. m.try_lock_shared_until (timeout_duration) 은 지정된 &lt;code&gt;timeout_duration&lt;/code&gt; 이 경과하거나 잠금이 획득 될 때까지 차단 됩니다. &lt;code&gt;timeout_duration&lt;/code&gt; 보다 길게 차단 될 수 있습니다. 이 스레드가 이미 모든 모드에서 뮤텍스를 소유 한 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d87f1cc87386d3d702b7ce5498e0b98f94c472e5" translate="yes" xml:space="preserve">
          <source>7) characters in the initializer list &lt;code&gt;ilist&lt;/code&gt;;</source>
          <target state="translated">7) 초기화리스트 &lt;code&gt;ilist&lt;/code&gt; 의 문자 ;</target>
        </trans-unit>
        <trans-unit id="8c19344e988c608cea5250497fc12afa65733cba" translate="yes" xml:space="preserve">
          <source>7) if &lt;code&gt;E1&lt;/code&gt; has a &lt;a href=&quot;type-id&quot;&gt;scalar type&lt;/a&gt; and &lt;code&gt;E2&lt;/code&gt; is a &lt;code&gt;~&lt;/code&gt; followed by the &lt;a href=&quot;type-id#Type_naming&quot;&gt;type name&lt;/a&gt; or &lt;a href=&quot;decltype&quot;&gt;decltype specifier&lt;/a&gt; designating the same type (minus cv-qualifications), optionally &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified&lt;/a&gt;, the result is a special kind of prvalue that can only be used as the left-hand operand of a function call operator, and for no other purpose. The resulting function call expression is called</source>
          <target state="translated">7) &lt;code&gt;E1&lt;/code&gt; 에 &lt;a href=&quot;type-id&quot;&gt;스칼라 유형이&lt;/a&gt; 있고 &lt;code&gt;E2&lt;/code&gt; 가 &lt;code&gt;~&lt;/code&gt; 와 그 뒤에 동일한 유형을 지정 하는 &lt;a href=&quot;type-id#Type_naming&quot;&gt;유형 이름&lt;/a&gt; 또는 &lt;a href=&quot;decltype&quot;&gt;decltype 지정자&lt;/a&gt; (빼기 cv 규정) (선택적으로 &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;한정된&lt;/a&gt; 경우) 인 경우 결과는 함수 호출 연산자의 왼쪽 피연산자이며 다른 용도로는 사용되지 않습니다. 결과 함수 호출 표현식이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a90e40dcfe3c435a0fee8fe0ef7793e6000637f7" translate="yes" xml:space="preserve">
          <source>7) if &lt;code&gt;E1&lt;/code&gt; is an lvalue and &lt;code&gt;E2&lt;/code&gt; points to a member function with ref-qualifier &amp;amp;&amp;amp;, the program is ill-formed.</source>
          <target state="translated">7) &lt;code&gt;E1&lt;/code&gt; 이 lvalue이고 &lt;code&gt;E2&lt;/code&gt; 가 참조 규정 자 &amp;amp;&amp;amp;를 갖는 멤버 함수를 가리키는 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="52820c3ddea05fb6b453cf22de27a1ff4ac6ed57" translate="yes" xml:space="preserve">
          <source>7) in a function call expression, with</source>
          <target state="translated">7) 함수 호출 표현식에서</target>
        </trans-unit>
        <trans-unit id="32ae06af54bb41bce05f01d1a6917932ab94a4ac" translate="yes" xml:space="preserve">
          <source>7) initialization of closure object members from the variables caught by copy in a lambda-expression</source>
          <target state="translated">7) 람다 식에서 복사에 의해 잡힌 변수에서 클로저 객체 멤버의 초기화</target>
        </trans-unit>
        <trans-unit id="73e84a39cc848461deceb5cbb2ca07d2001ddd9e" translate="yes" xml:space="preserve">
          <source>7) linear in distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;</source>
          <target state="translated">7) &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 사이의 거리에 선형</target>
        </trans-unit>
        <trans-unit id="558069c98e233b4661fc12fd49bfe7ce786ffbf8" translate="yes" xml:space="preserve">
          <source>7) linear in size of &lt;code&gt;other&lt;/code&gt;</source>
          <target state="translated">7) &lt;code&gt;other&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="a0fd895c7685d4149fe2f768cfefbe81893e7e80" translate="yes" xml:space="preserve">
          <source>7) non-type &lt;a href=&quot;template_parameters&quot;&gt;template argument&lt;/a&gt;</source>
          <target state="translated">7) 비 유형 &lt;a href=&quot;template_parameters&quot;&gt;템플릿 인수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="952e51997055078305219ab671e8e63f6e4a039a" translate="yes" xml:space="preserve">
          <source>7) or, if not that, F1 is a constructor for a class D, F2 is a constructor for a base class B of D, and for all arguments the corresponding parameters of F1 and F2 have the same type</source>
          <target state="translated">7) 또는 그렇지 않은 경우 F1은 클래스 D의 생성자이고 F2는 D의 기본 클래스 B의 생성자이며 모든 인수에 대해 F1과 F2의 해당 매개 변수는 동일한 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fef5abedd683dcb7dbe579c41463e0d8d5b64db7" translate="yes" xml:space="preserve">
          <source>7) simple by-reference capture of the current object</source>
          <target state="translated">7) 현재 객체의 간단한 참조로 캡처</target>
        </trans-unit>
        <trans-unit id="fca45f1e04359daa76ae91ee851cf41cf76e4cb8" translate="yes" xml:space="preserve">
          <source>7) try blocks;</source>
          <target state="translated">7) 블록을 시도;</target>
        </trans-unit>
        <trans-unit id="93f4617235d010db601b285f946aca7823fa2efb" translate="yes" xml:space="preserve">
          <source>7) user-defined character literal, such as &lt;code&gt;'c'_X&lt;/code&gt;</source>
          <target state="translated">7) 사용자 정의 문자 리터럴 (예 : &lt;code&gt;'c'_X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d2f6a718ee8f6875d0bf0de9225f7a59433f05e" translate="yes" xml:space="preserve">
          <source>7)&lt;a href=&quot;enum&quot;&gt;Scoped enumeration&lt;/a&gt;(C++11) type can be converted to an integer or floating-point type.</source>
          <target state="translated">7) &lt;a href=&quot;enum&quot;&gt;범위가 지정된 열거 형&lt;/a&gt; (C ++ 11) 형식은 정수 또는 부동 소수점 형식으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdd0ec586ccd29232baefe6caae6a2af43904fa3" translate="yes" xml:space="preserve">
          <source>7)&lt;a href=&quot;reference&quot;&gt;Rvalue reference declarator&lt;/a&gt;: the declaration &lt;code&gt;S &amp;amp;&amp;amp; D;&lt;/code&gt; declares &lt;code&gt;D&lt;/code&gt; as an rvalue reference to the type determined by decl-specifier-seq&lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">7) &lt;a href=&quot;reference&quot;&gt;Rvalue 참조 선언자&lt;/a&gt; : 선언 &lt;code&gt;S &amp;amp;&amp;amp; D;&lt;/code&gt; decl-specifier-seq &lt;code&gt;S&lt;/code&gt; 에 의해 결정된 유형에 대한 rvalue 참조로 &lt;code&gt;D&lt;/code&gt; 를 선언 합니다 .</target>
        </trans-unit>
        <trans-unit id="9ff9ad880145dbe9fe3eae21285257469885bd60" translate="yes" xml:space="preserve">
          <source>7)&lt;a href=&quot;type_alias&quot;&gt;alias declarations&lt;/a&gt;</source>
          <target state="translated">7) &lt;a href=&quot;type_alias&quot;&gt;별칭 선언&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcedc88352a1cf34c4e282b2dcb6b5cab03ccf28" translate="yes" xml:space="preserve">
          <source>7)&lt;code&gt;!lhs&lt;/code&gt;</source>
          <target state="translated">7)&lt;code&gt;!lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c54abca5a0cd4447be0d13d64bc8241d0558363e" translate="yes" xml:space="preserve">
          <source>7)&lt;code&gt;CD(CD(d).count() % s)&lt;/code&gt;</source>
          <target state="translated">7) &lt;code&gt;CD(CD(d).count() % s)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ab97042a8c9d91d71c60daaf86444b56cce6c99" translate="yes" xml:space="preserve">
          <source>7)&lt;code&gt;Clock::to_sys(t)&lt;/code&gt;.</source>
          <target state="translated">7)&lt;code&gt;Clock::to_sys(t)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="c816f7ae43cf349c39c3c7b729bf38c5d26bb0b6" translate="yes" xml:space="preserve">
          <source>7)&lt;code&gt;x.date() == y&lt;/code&gt;</source>
          <target state="translated">7) &lt;code&gt;x.date() == y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8b58567fb5e0d9bdef718fd7c300a3616df5f06" translate="yes" xml:space="preserve">
          <source>7)&lt;code&gt;ym1.year() - ym2.year() + &lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(int(unsigned(ym1.month())) - int(unsigned(ym2.month())))&lt;/code&gt;</source>
          <target state="translated">7) &lt;code&gt;ym1.year() - ym2.year() + &lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(int(unsigned(ym1.month())) - int(unsigned(ym2.month())))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21bebf90ec1c8c68af1e6f4f5e01b19797879a84" translate="yes" xml:space="preserve">
          <source>7)namespace-alias-definition: makes name a synonym for another namespace: see &lt;a href=&quot;namespace_alias&quot;&gt;namespace alias&lt;/a&gt;</source>
          <target state="translated">7) 네임 스페이스 별칭 정의 : 다른 네임 스페이스와 동의어를 만듭니다 : &lt;a href=&quot;namespace_alias&quot;&gt;네임 스페이스 별칭&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="1eabae2b076a3847c89997109bfe1aab462adbaf" translate="yes" xml:space="preserve">
          <source>7,8) (none)</source>
          <target state="translated">7,8) (없음)</target>
        </trans-unit>
        <trans-unit id="841d04da638d65713243932c6174eef12fed67e5" translate="yes" xml:space="preserve">
          <source>7,8) Converts a floating point value to a string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%f&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">7,8) 부동 소수점 값을 &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%f&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에서 생성 할 내용과 동일한 내용의 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="82b6f77e1e78eee3fc412f6db2e0a240f77589d8" translate="yes" xml:space="preserve">
          <source>7,8) Converts a floating point value to a wide string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%f&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">7,8) 부동 소수점 값을 &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%f&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에 대해 생성 할 내용과 동일한 내용을 가진 넓은 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2127540b006c01938e3f51702ffd0dd72af9cdc6" translate="yes" xml:space="preserve">
          <source>7,8) End iterator if &lt;code&gt;nh&lt;/code&gt; was empty, iterator pointing to the inserted element otherwise.</source>
          <target state="translated">7,8) &lt;code&gt;nh&lt;/code&gt; 가 비어 있으면 반복자를 종료 하고 그렇지 않으면 삽입 된 요소를 가리키는 반복자가 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="f56b08237f9ea63bbf08cb6efc622ec86e89ecbf" translate="yes" xml:space="preserve">
          <source>7-10) The overloads 2-5 are prohibited from being called with a temporary regex since otherwise the returned iterator would be immediately invalidated</source>
          <target state="translated">7-10) 오버로드 2-5는 임시 정규 표현식으로 호출 할 수 없습니다. 그렇지 않으면 반환 된 반복기가 즉시 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="1f5356021f2d2aedaa7aa4a206a13e925db72d69" translate="yes" xml:space="preserve">
          <source>7-10)&lt;a href=&quot;../../language/converting_constructor&quot;&gt;Converting constructor&lt;/a&gt;. Convert the corresponding data structure to a &lt;code&gt;valarray&lt;/code&gt;.</source>
          <target state="translated">7-10) &lt;a href=&quot;../../language/converting_constructor&quot;&gt;생성자 변환&lt;/a&gt; . 해당 데이터 구조를 &lt;code&gt;valarray&lt;/code&gt; 로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="f457c91b62ec3c332d17b816c82b3e55264a01bc" translate="yes" xml:space="preserve">
          <source>7-11) (none)</source>
          <target state="translated">7-11) (없음)</target>
        </trans-unit>
        <trans-unit id="87bfdcc398653199a450bd20ce415501b455585c" translate="yes" xml:space="preserve">
          <source>7-12) (none)</source>
          <target state="translated">7-12) (없음)</target>
        </trans-unit>
        <trans-unit id="03b9ee067a16d00f7548511478a450ee095523ab" translate="yes" xml:space="preserve">
          <source>7-12) Compares a &lt;code&gt;basic_string&lt;/code&gt; object and a null-terminated array of &lt;code&gt;CharT&lt;/code&gt;.</source>
          <target state="translated">7-12) &lt;code&gt;basic_string&lt;/code&gt; 객체와 null로 끝나는 &lt;code&gt;CharT&lt;/code&gt; 배열을 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="29541351b95736062f0d4ad6dfce03719848c057" translate="yes" xml:space="preserve">
          <source>7-12) The following constructors are only defined if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;container_type, Alloc&amp;gt;::value == true&lt;/code&gt;, that is, if the underlying container is an allocator-aware container (true for all standard library containers).</source>
          <target state="translated">7-12) 다음 생성자는 &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;container_type, Alloc&amp;gt;::value == true&lt;/code&gt; 인 경우 , 즉 기본 컨테이너가 할당 자 인식 컨테이너 인 경우에만 정의됩니다 (모든 표준 라이브러리 컨테이너에 대해 true).</target>
        </trans-unit>
        <trans-unit id="9b13a467efd9a92290fb2471fb1bd37590bc7a62" translate="yes" xml:space="preserve">
          <source>7-18) Compares &lt;code&gt;opt&lt;/code&gt; with a &lt;code&gt;nullopt&lt;/code&gt;. Equivalent to (1-6) when comparing to an &lt;code&gt;optional&lt;/code&gt; that does not contain a value.</source>
          <target state="translated">7-18) &lt;code&gt;opt&lt;/code&gt; 와 &lt;code&gt;nullopt&lt;/code&gt; 를 비교 합니다. 값을 포함하지 않는 &lt;code&gt;optional&lt;/code&gt; 과 비교할 때 (1-6)과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fa30481343c785f8b5bf21cb827c00a57a45cc94" translate="yes" xml:space="preserve">
          <source>7-18) Compares a &lt;code&gt;sub_match&lt;/code&gt; with a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;. Implemented as if by &lt;code&gt;sm.compare(typename sub_match&amp;lt;BidirIt&amp;gt;::string_type(st.data(), st.size())&lt;/code&gt;, where &lt;code&gt;sm&lt;/code&gt; is the &lt;code&gt;sub_match&lt;/code&gt; argument and &lt;code&gt;st&lt;/code&gt; is the &lt;code&gt;basic_string&lt;/code&gt; argument.</source>
          <target state="translated">7-18) &lt;code&gt;sub_match&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 과 비교합니다 . &lt;code&gt;sm.compare(typename sub_match&amp;lt;BidirIt&amp;gt;::string_type(st.data(), st.size())&lt;/code&gt; 의해 구현되며 , 여기서 &lt;code&gt;sm&lt;/code&gt; 은 &lt;code&gt;sub_match&lt;/code&gt; 인수이고 &lt;code&gt;st&lt;/code&gt; 는 &lt;code&gt;basic_string&lt;/code&gt; 인수입니다.</target>
        </trans-unit>
        <trans-unit id="bc7891308b7150aed85fa305e91ea9ce738001a6" translate="yes" xml:space="preserve">
          <source>7-18) Compares a &lt;code&gt;unique_ptr&lt;/code&gt; and &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">7-18) &lt;code&gt;unique_ptr&lt;/code&gt; 과 &lt;code&gt;nullptr&lt;/code&gt; 을 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="9bbc148d75b8f9846389a9fa018d5f471bf7c501" translate="yes" xml:space="preserve">
          <source>7-8) (none)</source>
          <target state="translated">7-8) (없음)</target>
        </trans-unit>
        <trans-unit id="c377051fecf2877f2193bba6f6025541f06fcd6e" translate="yes" xml:space="preserve">
          <source>7-8) &lt;code&gt;!x&lt;/code&gt;.</source>
          <target state="translated">7-8) &lt;code&gt;!x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39a620999d140f56f6a41b0112665ff65597c4f1" translate="yes" xml:space="preserve">
          <source>7-8) Advances the iterator by &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;-n&lt;/code&gt; positions respectively.</source>
          <target state="translated">7-8) 반복자를 &lt;code&gt;n&lt;/code&gt; 또는 &lt;code&gt;-n&lt;/code&gt; 위치 씩 각각 전진시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f29b00a46c67942e3789e473e47bcf7607e88b2b" translate="yes" xml:space="preserve">
          <source>7-8) Average case: &lt;code&gt;O(1)&lt;/code&gt;, worst case &lt;code&gt;O(size())&lt;/code&gt;</source>
          <target state="translated">7-8) 평균 사례 : &lt;code&gt;O(1)&lt;/code&gt; , 최악의 경우 &lt;code&gt;O(size())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33ac270bf696ccd1bacc01d04a0df8ffcddbe182" translate="yes" xml:space="preserve">
          <source>7-8) Constructs a span that is a view over the range &lt;code&gt;[&lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(cont), &lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(cont) + &lt;a href=&quot;../../iterator/size&quot;&gt;std::size&lt;/a&gt;(cont))&lt;/code&gt;; the resulting span has &lt;code&gt;size() == &lt;a href=&quot;../../iterator/size&quot;&gt;std::size&lt;/a&gt;(cont)&lt;/code&gt; and &lt;code&gt;data() == &lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(cont)&lt;/code&gt;. The behavior is undefined if that is not a valid range or if &lt;code&gt;extent != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../iterator/size&quot;&gt;std::size&lt;/a&gt;(cont) != extent&lt;/code&gt;.</source>
          <target state="translated">7-8) &lt;code&gt;[&lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(cont), &lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(cont) + &lt;a href=&quot;../../iterator/size&quot;&gt;std::size&lt;/a&gt;(cont))&lt;/code&gt; 범위에 대한 뷰인 범위를 구성합니다 . 결과 범위는 &lt;code&gt;size() == &lt;a href=&quot;../../iterator/size&quot;&gt;std::size&lt;/a&gt;(cont)&lt;/code&gt; 및 &lt;code&gt;data() == &lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(cont)&lt;/code&gt; 입니다. 유효한 범위가 아니거나 &lt;code&gt;extent != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../iterator/size&quot;&gt;std::size&lt;/a&gt;(cont) != extent&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e417aa16af15fbed98882cb25443e914015bc162" translate="yes" xml:space="preserve">
          <source>7-8) Constructs the path from a character sequence (format interpreted as specified by &lt;code&gt;fmt&lt;/code&gt;) provided by &lt;code&gt;source&lt;/code&gt;(6), which is a pointer or an input iterator to a null-terminated character sequence, an &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, an &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;, or represented as a pair of input iterators [&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;) ((7)). The only character type allowed is &lt;code&gt;char&lt;/code&gt;. Uses &lt;code&gt;loc&lt;/code&gt; to perform the character encoding conversion. If &lt;code&gt;value_type&lt;/code&gt; is &lt;code&gt;wchar_t&lt;/code&gt;, converts from to wide using the &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;wchar_t, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; facet of &lt;code&gt;loc&lt;/code&gt;. Otherwise, first converts to wide using the &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;wchar_t, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; facet and then converts to filesystem native character type using &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;wchar_t,value_type&amp;gt;&lt;/code&gt; facet of &lt;code&gt;loc&lt;/code&gt;.</source>
          <target state="translated">7-8 ()에 의해 지정된 포맷 해석 문자 시퀀스로부터 경로를 구축 &lt;code&gt;fmt&lt;/code&gt; )에 의해 제공되는 &lt;code&gt;source&lt;/code&gt; 포인터 또는 널 종료 문자 시퀀스에 입력 반복자 (6), &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 또는 한 쌍의 입력 반복기 [ &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;last&lt;/code&gt; ) ((7))로 표시됩니다. 허용되는 유일한 문자 유형은 &lt;code&gt;char&lt;/code&gt; 입니다. 사용 &lt;code&gt;loc&lt;/code&gt; 문자 인코딩 변환을 수행 할 수 있습니다. &lt;code&gt;value_type&lt;/code&gt; 이 &lt;code&gt;wchar_t&lt;/code&gt; 인 경우 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;wchar_t, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 패싯을 사용하여에서로 변환합니다 &lt;code&gt;loc&lt;/code&gt; . 그렇지 않으면, 먼저 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;wchar_t, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; facet를 사용하여 wide로 변환 한 다음 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;wchar_t,value_type&amp;gt;&lt;/code&gt; facet &lt;code&gt;loc&lt;/code&gt; 을 사용하여 파일 시스템 기본 문자 유형으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e7952b06509d929096bb54b40db2b2c651568db" translate="yes" xml:space="preserve">
          <source>7-8) Returns &lt;code&gt;!opt&lt;/code&gt;.</source>
          <target state="translated">7-8) &lt;code&gt;!opt&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8b515c96f586c27bf32d07243df3c875fd051271" translate="yes" xml:space="preserve">
          <source>7-8) Same as (5-6), except called if the alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;</source>
          <target state="translated">7-8) 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 경우 호출되는 것을 제외하고 (5-6)과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="42f8a1bf60012f3ab204464151352601ccdd02d6" translate="yes" xml:space="preserve">
          <source>7-8) The behavior is undefined unless &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;((U*)nullptr)&lt;/code&gt; is well formed.</source>
          <target state="translated">7-8) &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;((U*)nullptr)&lt;/code&gt; 가 제대로 형성 되지 않으면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0672e19ae3f5d20d397c168670862fa17f5c28ef" translate="yes" xml:space="preserve">
          <source>7-8) Throws what and when &lt;code&gt;&lt;a href=&quot;../../iterator/size&quot;&gt;std::size&lt;/a&gt;(cont)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(cont)&lt;/code&gt; throw.</source>
          <target state="translated">7-8) &lt;code&gt;&lt;a href=&quot;../../iterator/size&quot;&gt;std::size&lt;/a&gt;(cont)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../iterator/data&quot;&gt;std::data&lt;/a&gt;(cont)&lt;/code&gt; 던지는 내용과시기를 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="37a3e168bb482d19e8afc97b2ec0dea2b94f8f93" translate="yes" xml:space="preserve">
          <source>7-8)&lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">7-8)&lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65d95d53e472d1b54a262817653339ca11e414e2" translate="yes" xml:space="preserve">
          <source>7-8)&lt;code&gt;O(N*log(size() + N))&lt;/code&gt;, where N is the number of elements to insert.</source>
          <target state="translated">7-8) &lt;code&gt;O(N*log(size() + N))&lt;/code&gt; , 여기서 N은 삽입 할 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="f4734d60756746b9e26aeb35a470772b7bf61a5d" translate="yes" xml:space="preserve">
          <source>7-8)&lt;code&gt;reinterpret_cast&amp;lt;Y*&amp;gt;(r.get())&lt;/code&gt;</source>
          <target state="translated">7-8)&lt;code&gt;reinterpret_cast&amp;lt;Y*&amp;gt;(r.get())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9112a115232db3e0971f2ffef63eca0bbb7acd80" translate="yes" xml:space="preserve">
          <source>7-9) Multiplies its arguments</source>
          <target state="translated">7-9) 인수를 곱한다</target>
        </trans-unit>
        <trans-unit id="60b78753384ba69c2c457b288b9d97782c32712e" translate="yes" xml:space="preserve">
          <source>7-9)&lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) *= rhs&lt;/code&gt;</source>
          <target state="translated">7-9) &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) *= rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c53113497d041b9dc93a903e086783a2580682df" translate="yes" xml:space="preserve">
          <source>7.1.5.3 Elaborated type specifiers [dcl.type.elab]</source>
          <target state="translated">7.1.5.3 정교한 타입 지정자 [dcl.type.elab]</target>
        </trans-unit>
        <trans-unit id="b9f384405ac6b418ae33cc30814ff0f54bdf2450" translate="yes" xml:space="preserve">
          <source>7.1.6.3 Elaborated type specifiers [dcl.type.elab]</source>
          <target state="translated">7.1.6.3 정교한 타입 지정자 [dcl.type.elab]</target>
        </trans-unit>
        <trans-unit id="aacc8135930fd0e264c8a58eb258b0bc4d4e4a69" translate="yes" xml:space="preserve">
          <source>7.5 Linkage specifications [dcl.link]</source>
          <target state="translated">7.5 연계 사양 [dcl.link]</target>
        </trans-unit>
        <trans-unit id="df561dba1a37a91979ec251d99408b63269eee9b" translate="yes" xml:space="preserve">
          <source>71&amp;ndash;90</source>
          <target state="translated">71&amp;ndash;90</target>
        </trans-unit>
        <trans-unit id="fe5dbbcea5ce7e2988b8c69bcfdfde8904aabc1f" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>
        </trans-unit>
        <trans-unit id="c8c96dda31ee93f2ff94f6794dd5ffe859d1a635" translate="yes" xml:space="preserve">
          <source>8) A set of overloads or a function template accepting the &lt;code&gt;from&lt;/code&gt; argument of any &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;. Equivalent to (6) (the argument is cast to &lt;code&gt;double&lt;/code&gt;).</source>
          <target state="translated">8) &lt;a href=&quot;../../types/is_integral&quot;&gt;일체형&lt;/a&gt; 의 &lt;code&gt;from&lt;/code&gt; 인수를 허용하는 과부하 세트 또는 함수 템플릿 . (6)과 같습니다 (인수가 &lt;code&gt;double&lt;/code&gt; 로 캐스트 됨 ).</target>
        </trans-unit>
        <trans-unit id="c7a07a02ea0caa405de408fe5341cc4bf82bab91" translate="yes" xml:space="preserve">
          <source>8) A set of overloads or a function template for all combinations of arguments of arithmetic type not covered by (5-7). If any argument has &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;. If any other argument is &lt;code&gt;long double&lt;/code&gt;, then the return type is &lt;code&gt;long double&lt;/code&gt;, otherwise it is &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">8) (5-7)에서 다루지 않는 산술 유형의 모든 인수 조합에 대한 과부하 세트 또는 함수 템플릿. 인수에 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 . 다른 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 반환 유형은 &lt;code&gt;long double&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d0889c6b29adb56e749628f0dc5748268577de6f" translate="yes" xml:space="preserve">
          <source>8) A value of integer or enumeration type can be converted to any complete &lt;a href=&quot;enum&quot;&gt;enumeration type&lt;/a&gt;.</source>
          <target state="translated">8) 정수 또는 열거 유형의 값은 완전한 &lt;a href=&quot;enum&quot;&gt;열거 유형&lt;/a&gt; 으로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87b974556259f964e9d3e103f725f54465003544" translate="yes" xml:space="preserve">
          <source>8) Amortized constant if the insertion happens in the position just</source>
          <target state="translated">8) 삽입이 바로 그 위치에서 발생하면 상각 상수</target>
        </trans-unit>
        <trans-unit id="a098a27d6873575fbc6ada805104684ed7a4c823" translate="yes" xml:space="preserve">
          <source>8) Assigns the contents of initializer list &lt;code&gt;il&lt;/code&gt;. Equivalent to &lt;code&gt;*this = valarray(il)&lt;/code&gt;.</source>
          <target state="translated">8) 초기화리스트 &lt;code&gt;il&lt;/code&gt; 의 내용을 할당합니다 . &lt;code&gt;*this = valarray(il)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4300befb5115bc5e1198c4a43932686c19b6a49d" translate="yes" xml:space="preserve">
          <source>8) Called by the non-throwing array form of &lt;a href=&quot;../../language/new&quot;&gt;new[]-expressions&lt;/a&gt; when the alignment requirement of array elements exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;. The standard library implementation calls the version (4) and returns a null pointer on failure instead of propagating the exception.</source>
          <target state="translated">8) 배열 요소의 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과 할 경우, 던지지 않는 배열 형식 &lt;a href=&quot;../../language/new&quot;&gt;new [] &lt;/a&gt;-expressions에 의해 호출 됩니다. 표준 라이브러리 구현은 버전 (4)를 호출하고 예외를 전파하는 대신 실패시 널 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="969361bc44f05260ad25d598dcb51d145b764e7d" translate="yes" xml:space="preserve">
          <source>8) Checks whether &lt;a href=&quot;extension&quot;&gt;&lt;code&gt;extension()&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">8) &lt;a href=&quot;extension&quot;&gt; &lt;code&gt;extension()&lt;/code&gt; &lt;/a&gt; 이 비어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="93c12e411d001686ed25c74ea50ec5d7ba7a35ab" translate="yes" xml:space="preserve">
          <source>8) Constructs a copy of &lt;code&gt;other&lt;/code&gt; except for all the facets identified by the &lt;code&gt;cat&lt;/code&gt; argument, which are copied from &lt;code&gt;one&lt;/code&gt;. If both &lt;code&gt;other&lt;/code&gt; and &lt;code&gt;one&lt;/code&gt; have names, then the resulting locale also has a name.</source>
          <target state="translated">8)의 사본 구축 &lt;code&gt;other&lt;/code&gt; 의해 식별 할 수있는 모든 측면을 제외하고 &lt;code&gt;cat&lt;/code&gt; 에서 복사 인수 &lt;code&gt;one&lt;/code&gt; . &lt;code&gt;other&lt;/code&gt; 과 &lt;code&gt;one&lt;/code&gt; 이름 이 모두 있으면 결과 로캘에도 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="056152f37a76b07846396726e92995e9579c1eda" translate="yes" xml:space="preserve">
          <source>8) Constructs a variant with the alternative T_i specified by the index &lt;code&gt;I&lt;/code&gt; and initializes the contained value with the arguments &lt;code&gt;il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. If T_i's selected constructor is a constexpr constructor, this constructor is also a constexpr constructor. This overload only participates in overload resolution if &lt;code&gt;I &amp;lt; sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T_i, &lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">8) 인덱스 &lt;code&gt;I&lt;/code&gt; 로 지정된 대체 T_i로 변형을 구성하고 인수 &lt;code&gt;il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 포함 된 값을 초기화합니다 . T_i의 선택된 생성자가 constexpr 생성자 인 경우이 생성자는 constexpr 생성자이기도합니다. 이 &lt;code&gt;I &amp;lt; sizeof...(Types)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T_i, &lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; ... (Types) 및 std :: is_constructible_v &amp;lt;T_i, std :: initializer_list &amp;lt;U&amp;gt; &amp;amp;, Args ...&amp;gt; 가 true 인 경우에만이 과부하가 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="a1c5a915be77c219e2c04dbd8cb8cae3be5d09f6" translate="yes" xml:space="preserve">
          <source>8) Constructs an optional object that</source>
          <target state="translated">8) 다음과 같은 선택적 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="371c898f2f6db02b7deee7c7e6979213f27c3a6c" translate="yes" xml:space="preserve">
          <source>8) Constructs the container with the contents of the initializer list &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">8) 이니셜 라이저리스트 &lt;code&gt;init&lt;/code&gt; 의 내용으로 컨테이너를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="1120bd18db4cb5b43578810ef3ad5bb09581a498" translate="yes" xml:space="preserve">
          <source>8) Constructs the underlying container using &lt;code&gt;alloc&lt;/code&gt; as allocator. Effectively calls &lt;code&gt;c(alloc)&lt;/code&gt;. Copy-constructs &lt;code&gt;comp&lt;/code&gt; from &lt;code&gt;compare&lt;/code&gt;.</source>
          <target state="translated">8) &lt;code&gt;alloc&lt;/code&gt; 을 할당 자로 사용하여 기본 컨테이너를 구성합니다 . 효과적으로 &lt;code&gt;c(alloc)&lt;/code&gt; 호출합니다 . &lt;code&gt;compare&lt;/code&gt; 에서 &lt;code&gt;comp&lt;/code&gt; 를 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="3efeca477681410d2a1de0b3f05028cc88283556" translate="yes" xml:space="preserve">
          <source>8) Constructs the underlying container with the contents of &lt;code&gt;cont&lt;/code&gt; using move semantics while utilizing &lt;code&gt;alloc&lt;/code&gt; as allocator, as if by &lt;code&gt;c(std::move(cont), alloc)&lt;/code&gt;.</source>
          <target state="translated">8) &lt;code&gt;c(std::move(cont), alloc)&lt;/code&gt; 처럼 &lt;code&gt;alloc&lt;/code&gt; 을 할당 자로 사용하면서 이동 의미론을 사용하여 &lt;code&gt;cont&lt;/code&gt; 의 내용으로 기본 컨테이너를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="41326f6b2601ba156be4220e268ecc3fc25b3372" translate="yes" xml:space="preserve">
          <source>8) Converts the two durations to their common type and creates a duration whose tick count is the remainder of the tick counts after conversion.</source>
          <target state="translated">8) 두 지속 시간을 공통 유형으로 변환하고, 틱 수가 변환 후 남은 틱 수인 지속 시간을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="855db7c7f05b0d7777d5718a2a4a0dd9649f448a" translate="yes" xml:space="preserve">
          <source>8) End iterator if &lt;code&gt;nh&lt;/code&gt; was empty, iterator pointing to the inserted element if insertion took place, and iterator pointing to an element with a key equivalent to &lt;code&gt;nh.key()&lt;/code&gt; if it failed.</source>
          <target state="translated">8) &lt;code&gt;nh&lt;/code&gt; 이 비어 있으면 반복자를 종료 하고, 삽입이 발생한 경우 삽입 된 요소를 가리키는 반복자, 실패한 경우 &lt;code&gt;nh.key()&lt;/code&gt; 와 동일한 키를 가진 요소를 가리키는 반복자 가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6a84fe059f6739fd186e8b41122c0e7b2e61b75c" translate="yes" xml:space="preserve">
          <source>8) Equivalent to &lt;code&gt;atomic_compare_exchange_weak_explicit(p, expected, desired, &lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;, &lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">8) &lt;code&gt;atomic_compare_exchange_weak_explicit(p, expected, desired, &lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;, &lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f6fd9692ffa12431f39d59070dec62a7e04096e" translate="yes" xml:space="preserve">
          <source>8) File position indicator (an object of type &lt;code&gt;std::fpos_t&lt;/code&gt;), which, for wide character streams, includes the parse state (an object of type &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">8) 와이드 문자 스트림의 경우 구문 분석 상태 ( &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트)를 포함하는 파일 위치 표시기 ( &lt;code&gt;std::fpos_t&lt;/code&gt; 유형의 오브젝트 )입니다.</target>
        </trans-unit>
        <trans-unit id="0aceff11426f02f729ba0584401f8df6a5c2a14c" translate="yes" xml:space="preserve">
          <source>8) For arguments of type pointer to data member T of class X, the member type and the type X are both examined and their associated set of classes and namespaces are added to the set.</source>
          <target state="translated">8) 클래스 X의 데이터 멤버 T에 대한 포인터 유형의 인수에 대해 멤버 유형과 X 유형을 모두 검사하고 연관된 클래스 및 네임 스페이스 세트를 세트에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0c4c9e2dee1b6bba1c9345e31e59c2d5337d2fa0" translate="yes" xml:space="preserve">
          <source>8) If &lt;code&gt;nh&lt;/code&gt; is an empty &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;, does nothing and returns the end iterator. Otherwise, inserts the element owned by &lt;code&gt;nh&lt;/code&gt; into the container, and returns the iterator pointing to the element with key equivalent to &lt;code&gt;nh.key()&lt;/code&gt; The element is inserted as close as possible to &lt;code&gt;hint&lt;/code&gt;. The behavior is undefined if &lt;code&gt;nh&lt;/code&gt; is not empty and &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">8) &lt;code&gt;nh&lt;/code&gt; 가 빈 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 이면 아무것도하지 않고 종료 반복자를 반환합니다. 그렇지 않으면, 소유 요소 삽입 &lt;code&gt;nh&lt;/code&gt; 용기 내로 되돌 키 동등한 요소에 반복기 가리키는 &lt;code&gt;nh.key()&lt;/code&gt; 요소가 최대한 가까이 삽입 &lt;code&gt;hint&lt;/code&gt; . &lt;code&gt;nh&lt;/code&gt; 이 비어 있지 않고 &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="962b1c5da329be700465cd2ae0abd2017e2d8701" translate="yes" xml:space="preserve">
          <source>8) If &lt;code&gt;nh&lt;/code&gt; is an empty &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;, does nothing and returns the end iterator. Otherwise, inserts the element owned by &lt;code&gt;nh&lt;/code&gt; into the container, and returns the iterator pointing to the element with key equivalent to &lt;code&gt;nh.key()&lt;/code&gt; The element is inserted as close as possible to the position just prior to &lt;code&gt;hint&lt;/code&gt;. The behavior is undefined if &lt;code&gt;nh&lt;/code&gt; is not empty and &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">8) &lt;code&gt;nh&lt;/code&gt; 가 빈 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 이면 아무것도하지 않고 종료 반복자를 반환합니다. 그렇지 않으면, &lt;code&gt;nh&lt;/code&gt; 가 소유 한 요소를 컨테이너 에 삽입하고 &lt;code&gt;nh.key()&lt;/code&gt; 와 동일한 키를 사용하여 요소를 가리키는 반복자를 리턴합니다 . 요소는 &lt;code&gt;hint&lt;/code&gt; 직전 위치에 가능한 한 가깝게 삽입됩니다 . &lt;code&gt;nh&lt;/code&gt; 이 비어 있지 않고 &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="19e0d87412de896b6ebc9750b6340da51326c63c" translate="yes" xml:space="preserve">
          <source>8) If &lt;code&gt;nh&lt;/code&gt; is an empty &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;, does nothing and returns the end iterator. Otherwise, inserts the element owned by &lt;code&gt;nh&lt;/code&gt; into the container, if the container doesn't already contain an element with a key equivalent to &lt;code&gt;nh.key()&lt;/code&gt;, and returns the iterator pointing to the element with key equivalent to &lt;code&gt;nh.key()&lt;/code&gt; (regardless of whether the insert succeeded or failed). If the insertion succeeds, &lt;code&gt;nh&lt;/code&gt; is moved from, otherwise it retains ownership of the element. The element is inserted as close as possible to &lt;code&gt;hint&lt;/code&gt;. The behavior is undefined if &lt;code&gt;nh&lt;/code&gt; is not empty and &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">8) &lt;code&gt;nh&lt;/code&gt; 가 빈 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 이면 아무것도하지 않고 종료 반복자를 반환합니다. 그렇지 않으면, 소유 요소 삽입 &lt;code&gt;nh&lt;/code&gt; 컨테이너가 이미에 해당하는 키를 가진 요소를 포함하지 않는 경우, 컨테이너로를 &lt;code&gt;nh.key()&lt;/code&gt; 에 해당하는 키를 가진 요소에 대한 반복자를 가리키는 반환 &lt;code&gt;nh.key()&lt;/code&gt; (삽입의 성공 여부에 관계없이). 삽입이 성공하면 &lt;code&gt;nh&lt;/code&gt; 가 이동되고, 그렇지 않으면 요소의 소유권이 유지됩니다. 요소는 &lt;code&gt;hint&lt;/code&gt; 최대한 가깝게 삽입됩니다 . &lt;code&gt;nh&lt;/code&gt; 이 비어 있지 않고 &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7b7a33d6efb5ab6c50493c93647293f3a3b245bf" translate="yes" xml:space="preserve">
          <source>8) If &lt;code&gt;nh&lt;/code&gt; is an empty &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;, does nothing and returns the end iterator. Otherwise, inserts the element owned by &lt;code&gt;nh&lt;/code&gt; into the container, if the container doesn't already contain an element with a key equivalent to &lt;code&gt;nh.key()&lt;/code&gt;, and returns the iterator pointing to the element with key equivalent to &lt;code&gt;nh.key()&lt;/code&gt; (regardless of whether the insert succeeded or failed). If the insertion succeeds, &lt;code&gt;nh&lt;/code&gt; is moved from, otherwise it retains ownership of the element. The element is inserted as close as possible to the position just prior to &lt;code&gt;hint&lt;/code&gt;. The behavior is undefined if &lt;code&gt;nh&lt;/code&gt; is not empty and &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">8) &lt;code&gt;nh&lt;/code&gt; 가 빈 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 이면 아무것도하지 않고 종료 반복자를 반환합니다. 그렇지 않으면, 소유 요소 삽입 &lt;code&gt;nh&lt;/code&gt; 컨테이너가 이미에 해당하는 키를 가진 요소를 포함하지 않는 경우, 컨테이너로를 &lt;code&gt;nh.key()&lt;/code&gt; 에 해당하는 키를 가진 요소에 대한 반복자를 가리키는 반환 &lt;code&gt;nh.key()&lt;/code&gt; (삽입의 성공 여부에 관계없이). 삽입이 성공하면 &lt;code&gt;nh&lt;/code&gt; 가 이동되고, 그렇지 않으면 요소의 소유권이 유지됩니다. 요소는 &lt;code&gt;hint&lt;/code&gt; 직전 위치에 가능한 한 가깝게 삽입됩니다 . &lt;code&gt;nh&lt;/code&gt; 이 비어 있지 않고 &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt; 경우 동작이 정의되지 않습니다 ..</target>
        </trans-unit>
        <trans-unit id="5141946e6c3e1ffdfbdb7c773f8d223b82d92fb6" translate="yes" xml:space="preserve">
          <source>8) If the path is empty, add a dot (normal form of &lt;code&gt;./&lt;/code&gt; is &lt;code&gt;.&lt;/code&gt;)</source>
          <target state="translated">8) 경로가 비어 있으면 점을 추가하십시오 (일반 형식 &lt;code&gt;./&lt;/code&gt; is &lt;code&gt;.&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bee4f85b8861740a7f73f8b6d71510dae245bfbf" translate="yes" xml:space="preserve">
          <source>8) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then appends all characters from &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;append(sv.data(), sv.size())&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">8) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t;에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환 그런 다음 &lt;code&gt;append(sv.data(), sv.size())&lt;/code&gt; 처럼 &lt;code&gt;sv&lt;/code&gt; 의 모든 문자를 추가합니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="c134bf240080dc8ca10063be2726bb92fae344ec" translate="yes" xml:space="preserve">
          <source>8) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then compares a &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; substring of this string to &lt;code&gt;sv&lt;/code&gt;, as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(*this).substr(pos1, count1).compare(sv)&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">8) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(*this).substr(pos1, count1).compare(sv)&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; (* this) .substr (pos1, count1) .compare (sv) 처럼 이 문자열 의 &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; 하위 문자열을 &lt;code&gt;sv&lt;/code&gt; 와 비교합니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="afca5abb45d517062eef2c7117876906476703cc" translate="yes" xml:space="preserve">
          <source>8) Implicitly-defined copy constructor. Initializes each element of the tuple with the corresponding element of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">8) 암시 적으로 정의 된 복사 생성자. 튜플의 각 요소를 &lt;code&gt;other&lt;/code&gt; 의 해당 요소로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="e963db3ba7a43236c00d5fbd1d39d520c2780587" translate="yes" xml:space="preserve">
          <source>8) Initializer list constructor. Constructs the string with the contents of the initializer list &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">8) 이니셜 라이저 목록 생성자. 이니셜 라이저리스트 &lt;code&gt;init&lt;/code&gt; 의 내용으로 캐릭터 라인을 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="19a32d897e78dc74efacc99810acbf28a35564be" translate="yes" xml:space="preserve">
          <source>8) Inserts characters from the range &lt;code&gt;[first, last)&lt;/code&gt; before the element (if any) pointed by &lt;code&gt;pos&lt;/code&gt;. This overload does not participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.(since C++11)</source>
          <target state="translated">8) &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 (있는 경우 &lt;code&gt;[first, last)&lt;/code&gt; 앞에 [first, last) 범위의 문자를 삽입합니다 . &lt;code&gt;InputIt&lt;/code&gt; 이 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator를&lt;/a&gt; 만족시키지 않는 경우,이 과부하는 과부하 해결에 관여 하지 않습니다 . (C ++ 11 이후)</target>
        </trans-unit>
        <trans-unit id="9a45f54fc83c6448cd61494059833a2d0296daa9" translate="yes" xml:space="preserve">
          <source>8) Inserts elements from initializer list &lt;code&gt;ilist&lt;/code&gt;. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;LWG2844&lt;/a&gt;).</source>
          <target state="translated">8) 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 요소를 삽입합니다 . 범위의 여러 요소에 동등한 키가있는 경우 삽입 할 요소가 지정되지 &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;않습니다&lt;/a&gt; ( LWG2844 보류 중 ).</target>
        </trans-unit>
        <trans-unit id="8d9cfa0a01e724ff835b5cfd737995262f484493" translate="yes" xml:space="preserve">
          <source>8) Linear in size of &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">8) &lt;code&gt;init&lt;/code&gt; 크기의 선형 .</target>
        </trans-unit>
        <trans-unit id="39a3da8f9eb133a837f16b10987ef6895e889985" translate="yes" xml:space="preserve">
          <source>8) Move constructor is defaulted, and is &lt;code&gt;constexpr&lt;/code&gt; if moving of both elements satisfies the requirements on constexpr functions.</source>
          <target state="translated">8) 이동 생성자는 디폴트로 설정하고, &lt;code&gt;constexpr&lt;/code&gt; 요소 모두 만족 constexpr의 기능에 대한 요구를 이동하는 경우.</target>
        </trans-unit>
        <trans-unit id="6aa9b9c72edae4eb6e3328a76bcfb23bebc59163" translate="yes" xml:space="preserve">
          <source>8) Move constructor. Constructs the string with the contents of &lt;code&gt;other&lt;/code&gt; using move semantics. &lt;code&gt;other&lt;/code&gt; is left in valid, but unspecified state.</source>
          <target state="translated">8) 생성자를 이동하십시오. 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 내용으로 문자열을 구성합니다 . &lt;code&gt;other&lt;/code&gt; 는 유효하지만 지정되지 않은 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d95dbe36232c58cdf31d0d004daab79b3d6ffaa" translate="yes" xml:space="preserve">
          <source>8) On some implementations (in particular, on any POSIX compatible system as required by &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html&quot;&gt;dlsym&lt;/a&gt;), a function pointer can be converted to &lt;code&gt;void*&lt;/code&gt; or any other object pointer, or vice versa. If the implementation supports conversion in both directions, conversion to the original type yields the original value, otherwise the resulting pointer cannot be dereferenced or called safely.</source>
          <target state="translated">8) 일부 구현에서 (특히, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html&quot;&gt;dlsym에&lt;/a&gt; 필요한 POSIX 호환 시스템에서 ) 함수 포인터는 &lt;code&gt;void*&lt;/code&gt; 또는 다른 객체 포인터로 또는 그 반대로 변환 될 수 있습니다 . 구현이 양방향으로 변환을 지원하는 경우 원래 형식으로 변환하면 원래 값이 생성되며, 그렇지 않으면 결과 포인터를 역 참조하거나 안전하게 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d7ed154598ff9af2c328c40971e45c05b9a9e3c4" translate="yes" xml:space="preserve">
          <source>8) Outputs an implementation-defined string as if by &lt;code&gt;*this &amp;lt;&amp;lt; s&lt;/code&gt;, where &lt;code&gt;s&lt;/code&gt; is a null-terminated character type string.</source>
          <target state="translated">8) &lt;code&gt;*this &amp;lt;&amp;lt; s&lt;/code&gt; 에서처럼 구현 정의 문자열을 출력합니다 . 여기서 &lt;code&gt;s&lt;/code&gt; 는 널 종료 문자 유형 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a80358e08765e00c8594d525d0d1de8e0eb077d8" translate="yes" xml:space="preserve">
          <source>8) Replaces the contents with those of the initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">8) 내용을 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 의 내용으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="45f1e37c608f34d0045548b5a993c5dd5ff372a1" translate="yes" xml:space="preserve">
          <source>8) Returns &lt;code&gt;Clock::from_utc(t)&lt;/code&gt;. This overload only participates in overload resolution if the expression &lt;code&gt;Clock::from_utc(t)&lt;/code&gt; is well-formed. The program is ill-formed if &lt;code&gt;Clock::from_utc(t)&lt;/code&gt; does not return &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Clock, Duration&amp;gt;&lt;/code&gt; where &lt;code&gt;Duration&lt;/code&gt; is some valid specialization of &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">8) &lt;code&gt;Clock::from_utc(t)&lt;/code&gt; )를 반환 합니다. &lt;code&gt;Clock::from_utc(t)&lt;/code&gt; 표현식의 형식이 올바른 경우이 과부하는 과부하 해결에만 참여 합니다. &lt;code&gt;Clock::from_utc(t)&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Clock, Duration&amp;gt;&lt;/code&gt; 반환하지 않으면 프로그램이 잘못 구성됩니다. 여기서 &lt;code&gt;Duration&lt;/code&gt; 은 유효한 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="f3bb46319dcb373a87d50d460d092bd3747a2787" translate="yes" xml:space="preserve">
          <source>8) Same as &lt;code&gt;return *this += path(first, last)&lt;/code&gt;</source>
          <target state="translated">8) &lt;code&gt;return *this += path(first, last)&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="fc450b9e21eb79e53183fa3e857dd0a71d1ee1f3" translate="yes" xml:space="preserve">
          <source>8) The</source>
          <target state="translated">8)</target>
        </trans-unit>
        <trans-unit id="00b4b2a6f96d77afa39b18dc77cfd57f922b7dc9" translate="yes" xml:space="preserve">
          <source>8) The template parameter list that appears within the parameter &lt;code&gt;P&lt;/code&gt;, and which includes a pack expansion that is not at the very end of the template parameter list:</source>
          <target state="translated">8) 매개 변수 &lt;code&gt;P&lt;/code&gt; 내에 표시 되고 템플리트 매개 변수 목록의 맨 끝에없는 팩 확장을 포함하는 템플리트 매개 변수 목록 :</target>
        </trans-unit>
        <trans-unit id="432a110a3b9ed1a6d058dbf5483eb33c6e19499a" translate="yes" xml:space="preserve">
          <source>8) Throws nothing if &lt;code&gt;alloc == str.get_allocator()&lt;/code&gt;</source>
          <target state="translated">8) &lt;code&gt;alloc == str.get_allocator()&lt;/code&gt; 이면 아무것도 던지지 않습니다</target>
        </trans-unit>
        <trans-unit id="8cace9b3f36797af579c2c1d5b12b1e58c2bd42f" translate="yes" xml:space="preserve">
          <source>8) Tries to lock the associated mutex by calling &lt;code&gt;m.try_lock_until(timeout_time)&lt;/code&gt;. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. May block for longer than until &lt;code&gt;timeout_time&lt;/code&gt; has been reached.</source>
          <target state="translated">8) &lt;code&gt;m.try_lock_until(timeout_time)&lt;/code&gt; 을 호출하여 연관된 뮤텍스를 잠그려고 시도합니다 . 지정된 &lt;code&gt;timeout_time&lt;/code&gt; 에 도달하거나 잠금이 획득 될 때까지 차단합니다 . &lt;code&gt;timeout_time&lt;/code&gt; 에 도달 할 때까지 더 오래 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc1edca51dc765fd0e3134f729c731506ea1887e" translate="yes" xml:space="preserve">
          <source>8) Tries to lock the associated mutex in shared mode by calling &lt;code&gt;m.try_lock_shared_for(timeout_time)&lt;/code&gt;, which blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. May block for longer than until &lt;code&gt;timeout_time&lt;/code&gt; has been reached. The behavior is undefined if this thread already owns the mutex in any mode.</source>
          <target state="translated">8) &lt;code&gt;m.try_lock_shared_for(timeout_time)&lt;/code&gt; 을 호출하여 연결된 뮤텍스를 공유하려고 시도합니다. m.try_lock_shared_for (timeout_time) 은 지정된 &lt;code&gt;timeout_time&lt;/code&gt; 에 도달하거나 잠금을 획득 할 때까지 먼저 차단 됩니다. &lt;code&gt;timeout_time&lt;/code&gt; 에 도달 할 때까지 더 오래 차단 될 수 있습니다. 이 스레드가 이미 모든 모드에서 뮤텍스를 소유 한 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e0d0612ddd6092e368d675fd1f4517c0c789ea2" translate="yes" xml:space="preserve">
          <source>8) atomic and synchronized blocks (TM TS).</source>
          <target state="translated">8) 원자 및 동기 블록 (TM TS).</target>
        </trans-unit>
        <trans-unit id="ead3678a74f05a61e83fcffe4620b4d4a30dc051" translate="yes" xml:space="preserve">
          <source>8) characters of a string view &lt;code&gt;sv&lt;/code&gt;, converted from &lt;code&gt;t&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;. These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">8) 캐릭터의 볼 캐릭터의 &lt;code&gt;sv&lt;/code&gt; 로부터 변환 &lt;code&gt;t&lt;/code&gt; 에서처럼 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; . 이러한 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="f4e51332f493c3d39d2c5ef5ffff9208d29584c8" translate="yes" xml:space="preserve">
          <source>8) constant. If &lt;code&gt;alloc&lt;/code&gt; is given and &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt;, then linear</source>
          <target state="translated">8) 상수. 경우 &lt;code&gt;alloc&lt;/code&gt; 제공되고 &lt;code&gt;alloc != other.get_allocator()&lt;/code&gt; , 다음 선형</target>
        </trans-unit>
        <trans-unit id="ee7754b0e6d414c04f50c9ebef61a1cf78aefc7f" translate="yes" xml:space="preserve">
          <source>8) in a &lt;code&gt;return&lt;/code&gt; statement with braced-init-list used as the return expression and list-initialization initializes the returned object</source>
          <target state="translated">8) braced-init-list가 리턴 표현식으로 사용 된 &lt;code&gt;return&lt;/code&gt; 명령문에서 list-initialization은 리턴 된 오브젝트를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="97f7ccc3fd15790fbb67c8559b45416b89e426a1" translate="yes" xml:space="preserve">
          <source>8) linear in size of &lt;code&gt;ilist&lt;/code&gt;</source>
          <target state="translated">8) &lt;code&gt;ilist&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="c727d19012a3e5f458cb8c1183b247ec8530c426" translate="yes" xml:space="preserve">
          <source>8) nested namespace definition: &lt;code&gt;namespace A::B::C { ... }&lt;/code&gt; is equivalent to &lt;code&gt;namespace A { namespace B { namespace C { ... } } }&lt;/code&gt;.</source>
          <target state="translated">8) 중첩 네임 스페이스 정의 : &lt;code&gt;namespace A::B::C { ... }&lt;/code&gt; 는 &lt;code&gt;namespace A { namespace B { namespace C { ... } } }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4f0741433aa1cca82eab306a028fca835fe9f69" translate="yes" xml:space="preserve">
          <source>8) or, if not that, F2 is a rewritten candidate and F1 is not, 9) or, if not that, F1 and F2 are both rewritten candidates, and F2 is a synthesized rewritten candidate with reversed order of parameters and F1 is not,</source>
          <target state="translated">8) 또는 그렇지 않은 경우 F2는 다시 작성된 후보이고 F1이 아닌 경우 9) 또는 그렇지 않은 경우 F1과 F2는 모두 다시 작성된 후보이며, F2는 반대 순서의 매개 변수를 가진 합성 된 재 작성된 후보이며 F1은 그렇지 않습니다. ,</target>
        </trans-unit>
        <trans-unit id="5949ba2e14cf3448dcb92463512a6f2bda223b63" translate="yes" xml:space="preserve">
          <source>8) simple by-copy capture of the current object</source>
          <target state="translated">8) 현재 객체의 간단한 사본 별 캡처</target>
        </trans-unit>
        <trans-unit id="9acdd3d08992ab46faf39898bef27765720ab5ef" translate="yes" xml:space="preserve">
          <source>8) user-defined string literal, such as &lt;code&gt;&quot;abd&quot;_L&lt;/code&gt; or &lt;code&gt;u&quot;xyz&quot;_M&lt;/code&gt;</source>
          <target state="translated">8) &lt;code&gt;&quot;abd&quot;_L&lt;/code&gt; 또는 &lt;code&gt;u&quot;xyz&quot;_M&lt;/code&gt; 과 같은 사용자 정의 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="28ef5d8e27c3e35885f14392d41e8873756c06db" translate="yes" xml:space="preserve">
          <source>8)&lt;a href=&quot;array&quot;&gt;Array declarator&lt;/a&gt;. noptr-declarator any valid declarator, but if it begins with *, &amp;amp;, or &amp;amp;&amp;amp;, it has to be surrounded by parentheses.</source>
          <target state="translated">8) &lt;a href=&quot;array&quot;&gt;배열 선언자&lt;/a&gt; . noptr-declarator 유효한 선언자이지만 *, &amp;amp; 또는 &amp;amp;&amp;amp;로 시작하면 괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="575b7c119d376b5652aff3c7ecd7330d437c5d06" translate="yes" xml:space="preserve">
          <source>8)&lt;a href=&quot;deduction_guide&quot;&gt;deduction guides&lt;/a&gt; of member class templates:</source>
          <target state="translated">8) 멤버 클래스 템플릿의 &lt;a href=&quot;deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ec36352bd7f162c2d0f09c62d38fa4b4468d3807" translate="yes" xml:space="preserve">
          <source>8)&lt;code&gt;!rhs&lt;/code&gt;</source>
          <target state="translated">8)&lt;code&gt;!rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7204b48a6f364e3a894c5c45ff1ef6814ffa17d4" translate="yes" xml:space="preserve">
          <source>8)&lt;code&gt;CD(CD(lhs).count() % CD(rhs).count())&lt;/code&gt;</source>
          <target state="translated">8) &lt;code&gt;CD(CD(lhs).count() % CD(rhs).count())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e2b9a3b204364056c998ba79544fb51dbba26b4" translate="yes" xml:space="preserve">
          <source>8)&lt;code&gt;Clock::from_utc(t)&lt;/code&gt;.</source>
          <target state="translated">8)&lt;code&gt;Clock::from_utc(t)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="324145445c92e5f568eb20b7ac3c1b3e2025c2db" translate="yes" xml:space="preserve">
          <source>8)&lt;code&gt;std::nested_exception::rethrow_nested&lt;/code&gt; is called for an object that isn't holding a captured exception</source>
          <target state="translated">8) &lt;code&gt;std::nested_exception::rethrow_nested&lt;/code&gt; 는 캡처 된 예외를 보유하지 않은 객체에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ae40e418d98bb2c0c543145c84ca93a59187d448" translate="yes" xml:space="preserve">
          <source>8)&lt;code&gt;x == y.date()&lt;/code&gt;</source>
          <target state="translated">8) &lt;code&gt;x == y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff6be3c3b6c2240000b3772b89052e649ca06ff8" translate="yes" xml:space="preserve">
          <source>8,10)&lt;code&gt;&lt;a href=&quot;month_day_last&quot;&gt;std::chrono::month_day_last&lt;/a&gt;(m)&lt;/code&gt;</source>
          <target state="translated">8,10)&lt;code&gt;&lt;a href=&quot;month_day_last&quot;&gt;std::chrono::month_day_last&lt;/a&gt;(m)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07bc1363ade7ed3967bb77fe91a144f4c6d475b0" translate="yes" xml:space="preserve">
          <source>8,9,10,11)&lt;code&gt;true&lt;/code&gt; if the shared pointers were equivalent and the exchange was performed, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">8,9,10,11) &lt;code&gt;true&lt;/code&gt; 공유 포인터 등가이었고 교환이 수행 된 경우 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="83e7df956917d24719a43d47287521218371f5e7" translate="yes" xml:space="preserve">
          <source>8-10) Calls &lt;code&gt;func(*this)&lt;/code&gt;, where &lt;code&gt;func&lt;/code&gt; is an I/O manipulator.</source>
          <target state="translated">8-10) &lt;code&gt;func(*this)&lt;/code&gt; )를 호출합니다 . 여기서 &lt;code&gt;func&lt;/code&gt; 는 I / O 조작기입니다.</target>
        </trans-unit>
        <trans-unit id="11a38413c3288ca1921143378c010756e28874e0" translate="yes" xml:space="preserve">
          <source>8-9) Conversions to and from &lt;code&gt;std::chrono::utc_time&lt;/code&gt; when &lt;code&gt;Clock&lt;/code&gt; supports &lt;code&gt;from_utc&lt;/code&gt; and &lt;code&gt;to_utc&lt;/code&gt;: &lt;code&gt;operator()&lt;/code&gt; calls &lt;code&gt;Clock::to_utc&lt;/code&gt; and &lt;code&gt;Clock::from_utc&lt;/code&gt;, respectively.</source>
          <target state="translated">8-9) &lt;code&gt;Clock&lt;/code&gt; 에서 &lt;code&gt;from_utc&lt;/code&gt; 및 &lt;code&gt;to_utc&lt;/code&gt; 를 지원하는 경우 &lt;code&gt;std::chrono::utc_time&lt;/code&gt; 변환 및 변환 : &lt;code&gt;operator()&lt;/code&gt; 는 각각 &lt;code&gt;Clock::to_utc&lt;/code&gt; 및 &lt;code&gt;Clock::from_utc&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1b4f20dfdd1fb3ed1198e68f04cfb93e7c0d9975" translate="yes" xml:space="preserve">
          <source>8-9) Throws anything thrown by the conversion to &lt;code&gt;basic_string_view&lt;/code&gt;.</source>
          <target state="translated">8-9) &lt;code&gt;basic_string_view&lt;/code&gt; 로의 변환에 의해 던져진 것을 던진다 .</target>
        </trans-unit>
        <trans-unit id="0ade7c2cf97f75d009975f4d720d1fa6c19f4897" translate="yes" xml:space="preserve">
          <source>9</source>
          <target state="translated">9</target>
        </trans-unit>
        <trans-unit id="1c390b3a9deddfb1fa7dd8a84a655c0bc1ec2f85" translate="yes" xml:space="preserve">
          <source>9 Classes [class](p: 3)</source>
          <target state="translated">9 클래스 [클래스] (p : 3)</target>
        </trans-unit>
        <trans-unit id="7e4ab081313c777ee142137c34df08aa90eafb08" translate="yes" xml:space="preserve">
          <source>9 Classes [class](p: 4,7)</source>
          <target state="translated">9 클래스 [클래스] (p : 4,7)</target>
        </trans-unit>
        <trans-unit id="a3d27cc0b1bd6bf95d877fb4ebcb73847a921fc4" translate="yes" xml:space="preserve">
          <source>9) A pointer to member of some class &lt;code&gt;D&lt;/code&gt; can be upcast to a pointer to member of its unambiguous, accessible base class &lt;code&gt;B&lt;/code&gt;. This &lt;code&gt;static_cast&lt;/code&gt; makes no checks to ensure the member actually exists in the runtime type of the pointed-to object.</source>
          <target state="translated">9) 일부 클래스 &lt;code&gt;D&lt;/code&gt; 의 멤버에 대한 포인터는 명확하고 액세스 가능한 기본 클래스 &lt;code&gt;B&lt;/code&gt; 의 멤버에 대한 포인터로 캐스트 될 수 있습니다 . 이 &lt;code&gt;static_cast&lt;/code&gt; 는 멤버가 실제로 지정된 오브젝트의 런타임 유형에 존재하는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3fc5978c0167b44b3efc82bb251755b03de2666" translate="yes" xml:space="preserve">
          <source>9) Behaves as an &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, checks if &lt;code&gt;sb&lt;/code&gt; is a null pointer. If it is, executes &lt;code&gt;setstate(badbit)&lt;/code&gt; and exits. Otherwise, extracts characters from the input sequence controlled by &lt;code&gt;sb&lt;/code&gt; and inserts them into &lt;code&gt;*this&lt;/code&gt; until one of the following conditions are met:</source>
          <target state="translated">9) &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction으로&lt;/a&gt; 작동합니다 . 센트리 객체를 구성하고 확인한 후 &lt;code&gt;sb&lt;/code&gt; 가 널 포인터 인지 확인합니다 . 그렇다면, &lt;code&gt;setstate(badbit)&lt;/code&gt; 실행 하고 종료합니다. 그렇지 않으면, &lt;code&gt;sb&lt;/code&gt; 에 의해 제어되는 입력 순서에서 문자를 추출 하여 다음 조건 중 하나가 충족 될 때까지 &lt;code&gt;*this&lt;/code&gt; 에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="920008053dbc72b8c088307a113db8bb349cae65" translate="yes" xml:space="preserve">
          <source>9) Called by the non-throwing single-object &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; if a constructor of the object throws an exception. The standard library implementation behaves the same as (1)</source>
          <target state="translated">9) 객체 의 생성자가 예외를 던지면 던지지 않는 단일 객체 &lt;a href=&quot;../../language/new&quot;&gt;new-expression에&lt;/a&gt; 의해 호출됩니다 . 표준 라이브러리 구현은 (1)과 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="d5bb2cb78c05f59415d38e6a5bed102eb151c457" translate="yes" xml:space="preserve">
          <source>9) Called by the standard single-object &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression. The standard library implementation performs no action and returns &lt;code&gt;ptr&lt;/code&gt; unmodified.</source>
          <target state="translated">9) 표준 단일 객체 &lt;a href=&quot;../../language/new&quot;&gt;배치 새로운&lt;/a&gt; 표현에 의해 호출됩니다 . 표준 라이브러리 구현은 조치를 수행하지 않고 수정되지 않은 &lt;code&gt;ptr&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9cf052436b476e5b3fcca7335d7de45211577d41" translate="yes" xml:space="preserve">
          <source>9) Constructs a &lt;code&gt;shared_ptr&lt;/code&gt; which shares ownership of the object managed by &lt;code&gt;r&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; manages no object, &lt;code&gt;*this&lt;/code&gt; manages no object too. The template overload doesn't participate in overload resolution if &lt;code&gt;Y*&lt;/code&gt; is not implicitly convertible to(until C++17)</source>
          <target state="translated">9) &lt;code&gt;r&lt;/code&gt; 에 의해 관리되는 객체의 소유권을 공유 하는 &lt;code&gt;shared_ptr&lt;/code&gt; 을 구성합니다 . &lt;code&gt;r&lt;/code&gt; &lt;code&gt;*this&lt;/code&gt; 오브젝트를 관리하지 않으면 *이 오브젝트도 관리하지 않습니다. &lt;code&gt;Y*&lt;/code&gt; 를 암시 적으로 변환 할 수없는 경우 (C ++ 17까지) 템플릿 과부하가 과부하 해결에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="206c5d3c7e3d11857f710a59b554bdc8173708a5" translate="yes" xml:space="preserve">
          <source>9) Constructs the adaptor with the contents of &lt;code&gt;other.c&lt;/code&gt; and using &lt;code&gt;alloc&lt;/code&gt; as allocator, as if by &lt;code&gt;c(other.c, alloc)&lt;/code&gt;.</source>
          <target state="translated">9) &lt;code&gt;other.c&lt;/code&gt; 의 내용 으로 &lt;code&gt;c(other.c, alloc)&lt;/code&gt; 와 같이 &lt;code&gt;alloc&lt;/code&gt; 을 할당 자로 사용하여 어댑터를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="829d785a00f6379319829ebde48e6eed33dee966" translate="yes" xml:space="preserve">
          <source>9) Constructs the string with the contents of the initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">9) 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 의 내용으로 문자열을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="a71c54e6293e38df9c1979a609d3d4dce9869409" translate="yes" xml:space="preserve">
          <source>9) Constructs the underlying container with the contents of &lt;code&gt;cont&lt;/code&gt; and using &lt;code&gt;alloc&lt;/code&gt; as allocator, as if by &lt;code&gt;c(cont, alloc)&lt;/code&gt;. Copy-constructs &lt;code&gt;comp&lt;/code&gt; from &lt;code&gt;compare&lt;/code&gt;. Then calls &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp)&lt;/code&gt;.</source>
          <target state="translated">9) &lt;code&gt;c(cont, alloc)&lt;/code&gt; 와 같이 &lt;code&gt;cont&lt;/code&gt; 의 내용을 가지고 &lt;code&gt;alloc&lt;/code&gt; 을 할당 자로 사용 하는 기본 컨테이너를 구성합니다 . &lt;code&gt;compare&lt;/code&gt; 에서 &lt;code&gt;comp&lt;/code&gt; 를 복사합니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp)&lt;/code&gt; (c.begin (), c.end (), comp)를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="4da16dc163a91456db825cda567b9363146af54e" translate="yes" xml:space="preserve">
          <source>9) Converting constructor from another span &lt;code&gt;s&lt;/code&gt;; the resulting span has &lt;code&gt;size() == s.size()&lt;/code&gt; and &lt;code&gt;data() == s.data()&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt; || N == extent&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;U (*)[]&lt;/code&gt; is convertible to &lt;code&gt;element_type (*)[]&lt;/code&gt;.</source>
          <target state="translated">9) 다른 스팬에서 생성자 변환 &lt;code&gt;s&lt;/code&gt; ; 결과 범위는 &lt;code&gt;size() == s.size()&lt;/code&gt; 및 &lt;code&gt;data() == s.data()&lt;/code&gt; 입니다. &lt;code&gt;extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt; || N == extent&lt;/code&gt; 경우이 과부하는 과부하 해결에만 참여합니다. N == extent 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;U (*)[]&lt;/code&gt; 는 &lt;code&gt;element_type (*)[]&lt;/code&gt; 로 변환 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="3abd629a42a62584f0104ebbb2bb5cdb41e6c2ad" translate="yes" xml:space="preserve">
          <source>9) Converts a floating point value to a string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%Lf&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">9) 부동 소수점 값을 &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%Lf&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에 대해 생성 할 내용과 동일한 내용의 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="2c2f149e6f48d72f0b65a0a05054b26828f4ba8f" translate="yes" xml:space="preserve">
          <source>9) Converts a floating point value to a wide string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%Lf&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">9) 부동 소수점 값을 &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%Lf&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에 대해 생성 할 내용과 동일한 내용을 가진 넓은 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="b2f5750326d5cb373896faccd93f29bbff6692ff" translate="yes" xml:space="preserve">
          <source>9) Equivalent to &lt;code&gt;atomic_compare_exchange_strong_explicit(p, expected, desired, &lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;, &lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">9) &lt;code&gt;atomic_compare_exchange_strong_explicit(p, expected, desired, &lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;, &lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f149289cd67dbf3ef087b7d575089a1433bc9a2b" translate="yes" xml:space="preserve">
          <source>9) For &lt;code&gt;P&lt;/code&gt; of array type (but not reference to array or pointer to array), the major array bound:</source>
          <target state="translated">9) 배열 유형의 &lt;code&gt;P&lt;/code&gt; (배열에 대한 참조 또는 배열에 대한 포인터는 아님)의 경우 주 배열이 다음과 같이 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="293538dc1550ea370d1664d27c31f500c2d0a470" translate="yes" xml:space="preserve">
          <source>9) If &lt;code&gt;nh&lt;/code&gt; is an empty &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;, does nothing. Otherwise, inserts the element owned by &lt;code&gt;nh&lt;/code&gt; into the container , if the container doesn't already contain an element with a key equivalent to &lt;code&gt;nh.key()&lt;/code&gt;. The behavior is undefined if &lt;code&gt;nh&lt;/code&gt; is not empty and &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">9) &lt;code&gt;nh&lt;/code&gt; 가 빈 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 이면 아무 것도 수행하지 않습니다. 그렇지 않으면, 컨테이너에 &lt;code&gt;nh.key()&lt;/code&gt; 와 동일한 키를 가진 요소가 컨테이너에 포함되어 있지 않으면 &lt;code&gt;nh&lt;/code&gt; 소유의 요소를 container 에 삽입합니다 . &lt;code&gt;nh&lt;/code&gt; 이 비어 있지 않고 &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ddc727da15bd5436615b498225c01c32f0b40843" translate="yes" xml:space="preserve">
          <source>9) If the argument is the name or the &lt;a href=&quot;overloaded_address&quot;&gt;address-of expression for a set of overloaded functions&lt;/a&gt; (or function templates), every function in the overload set is examined and its associated set of classes and namespaces is added to the set.</source>
          <target state="translated">9) 인수가 &lt;a href=&quot;overloaded_address&quot;&gt;오버로드 된 함수 세트&lt;/a&gt; (또는 함수 템플릿) 의 이름 또는 표현식 주소 인 경우 오버로드 세트의 모든 함수가 검사되고 관련 클래스 및 네임 스페이스 세트가 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b74fcb65130aa582b7286608b9c9684d9085479a" translate="yes" xml:space="preserve">
          <source>9) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then appends the characters from the subview &lt;code&gt;[pos, pos+count)&lt;/code&gt; of &lt;code&gt;sv&lt;/code&gt;. If the requested subview extends past the end of &lt;code&gt;sv&lt;/code&gt;, or if &lt;code&gt;count == npos&lt;/code&gt;, the appended subview is &lt;code&gt;[pos, sv.size())&lt;/code&gt;. If &lt;code&gt;pos &amp;gt;= sv.size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">9) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 다음 하위 뷰에서 문자를 추가 &lt;code&gt;[pos, pos+count)&lt;/code&gt; 의 &lt;code&gt;sv&lt;/code&gt; . 요청 된 &lt;code&gt;[pos, sv.size())&lt;/code&gt; 뷰가 &lt;code&gt;sv&lt;/code&gt; 의 끝을지나 연장 되거나 &lt;code&gt;count == npos&lt;/code&gt; 인 경우 추가 된 서브 뷰는 [pos, sv.size ()) 입니다. 경우 &lt;code&gt;pos &amp;gt;= sv.size()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 발생합니다. 이 오버로드는 오버로드 확인에 참여하는 경우 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const를 T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;표준 : basic_string_view&lt;/a&gt; &amp;lt;그림, 형질 &amp;gt;&amp;gt; 이다 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9971c7e54c9529fb0092e735d35b40351eb7e382" translate="yes" xml:space="preserve">
          <source>9) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then compares a &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; substring of this string to a substring &lt;code&gt;[pos2, pos2+count2)&lt;/code&gt; of &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(*this).substr(pos1, count1).compare(sv.substr(pos2, count2))&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">9) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 다음 비교하는 &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; 문자열이 문자열의 부분 문자열 &lt;code&gt;[pos2, pos2+count2)&lt;/code&gt; 의 &lt;code&gt;sv&lt;/code&gt; 에서처럼 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(*this).substr(pos1, count1).compare(sv.substr(pos2, count2))&lt;/code&gt; 이) .substr &amp;lt;차트 형질&amp;gt; (* (POS1, COUNT1) 비교 (sv.substr (pos2, count2)) . 경우에 과부하는 오버로드 확인에 참여 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; CONST는 &amp;amp; T &amp;lt; &lt;a href=&quot;../basic_string_view&quot;&gt;표준 : basic_string_view&lt;/a&gt; &amp;lt;그림, 형질 &amp;gt;&amp;gt; 인 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const를 T &amp;amp;, const를 차트 *&amp;gt;가 있다 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea730624a8c822765def882663f7377e4d985eb" translate="yes" xml:space="preserve">
          <source>9) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then replaces the contents with those of &lt;code&gt;sv&lt;/code&gt;, as if by &lt;code&gt;assign(sv.data(), sv.size())&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">9) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t; 에서처럼 &lt;code&gt;t&lt;/code&gt; 를 문자열보기 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;assign(sv.data(), sv.size())&lt;/code&gt; 처럼 &lt;code&gt;sv&lt;/code&gt; 의 내용으로 내용을 바꿉니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="cf8371f197e8f8d87a4641de9c307f07826bfb61" translate="yes" xml:space="preserve">
          <source>9) Implicitly-defined move constructor. Initializes each ith element of the tuple with &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Ui&amp;gt;(std::get&amp;lt;i&amp;gt;(other))&lt;/code&gt;.</source>
          <target state="translated">9) 암시 적으로 정의 된 이동 생성자. &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Ui&amp;gt;(std::get&amp;lt;i&amp;gt;(other))&lt;/code&gt; 튜플의 각 i 번째 요소를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="f802e46e2f76db055101b23c139888696526ab51" translate="yes" xml:space="preserve">
          <source>9) Inserts elements from initializer list &lt;code&gt;ilist&lt;/code&gt; before the element (if any) pointed by &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">9) 이니셜 라이저 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 (있는 경우) 앞에 요소를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="99c213ebdd3ca7d327d59c98f56a71c8a09a1826" translate="yes" xml:space="preserve">
          <source>9) Logarithmic in the size of the container, &lt;code&gt;O(log(size()))&lt;/code&gt;.</source>
          <target state="translated">9) 컨테이너 크기의 &lt;code&gt;O(log(size()))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4ebabb5f6a940adff26077ecc50eb8eb531f37b" translate="yes" xml:space="preserve">
          <source>9) O(N) comparisons, where N is &lt;code&gt;cont.size()&lt;/code&gt;.</source>
          <target state="translated">9) O (N) 비교, 여기서 N은 &lt;code&gt;cont.size()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b644a7f5461d4dac87ed1e89e3052fc2ddd0177a" translate="yes" xml:space="preserve">
          <source>9) Returns &lt;code&gt;Clock::to_utc(t)&lt;/code&gt;. This overload only participates in overload resolution if the expression &lt;code&gt;Clock::to_utc(t)&lt;/code&gt; is well-formed. The program is ill-formed if &lt;code&gt;Clock::to_utc(t)&lt;/code&gt; does not return &lt;code&gt;&lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_time&lt;/a&gt;&amp;lt;Duration&amp;gt;&lt;/code&gt; where &lt;code&gt;Duration&lt;/code&gt; is some valid specialization of &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">9) &lt;code&gt;Clock::to_utc(t)&lt;/code&gt; )를 반환 합니다. &lt;code&gt;Clock::to_utc(t)&lt;/code&gt; 표현식의 형식이 올바른 경우이 과부하는 과부하 해결에만 참여 합니다. &lt;code&gt;Clock::to_utc(t)&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_time&lt;/a&gt;&amp;lt;Duration&amp;gt;&lt;/code&gt; 반환하지 않으면 프로그램이 잘못 구성됩니다. 여기서 &lt;code&gt;Duration&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 의 일부 유효한 특수화입니다 .</target>
        </trans-unit>
        <trans-unit id="ab387fd6c9d5312982af275674b3498b4aa87a39" translate="yes" xml:space="preserve">
          <source>9) Returns an &lt;code&gt;insert_return_type&lt;/code&gt; with the members initialized as follows: if &lt;code&gt;nh&lt;/code&gt; is empty, &lt;code&gt;inserted&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;end()&lt;/code&gt;, and &lt;code&gt;node&lt;/code&gt; is empty. Otherwise if the insertion took place, &lt;code&gt;inserted&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt; points to the inserted element, and &lt;code&gt;node&lt;/code&gt; is empty. If the insertion failed, &lt;code&gt;inserted&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt; has the previous value of &lt;code&gt;nh&lt;/code&gt;, and &lt;code&gt;position&lt;/code&gt; points to an element with a key equivalent to &lt;code&gt;nh.key()&lt;/code&gt;.</source>
          <target state="translated">9) 다음과 같이 초기화 된 멤버와 함께 &lt;code&gt;insert_return_type&lt;/code&gt; 을 리턴 합니다. &lt;code&gt;nh&lt;/code&gt; 이 비어 있고 &lt;code&gt;inserted&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 이면 &lt;code&gt;position&lt;/code&gt; 이 &lt;code&gt;end()&lt;/code&gt; 이고 &lt;code&gt;node&lt;/code&gt; 가 비어 있습니다. 그렇지 않으면 삽입이 발생하면 &lt;code&gt;inserted&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;position&lt;/code&gt; 가 삽입 된 요소를 가리키고 &lt;code&gt;node&lt;/code&gt; 가 비어 있습니다. 삽입 실패, &lt;code&gt;inserted&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;node&lt;/code&gt; 의 이전 값은 &lt;code&gt;nh&lt;/code&gt; 이며 &lt;code&gt;position&lt;/code&gt; 은 &lt;code&gt;nh.key()&lt;/code&gt; 와 동일한 키를 가진 요소를 가리 킵니다..</target>
        </trans-unit>
        <trans-unit id="65a219e907c05c0275921e404a6f450238e02387" translate="yes" xml:space="preserve">
          <source>9) The null pointer value of any pointer type can be converted to any other pointer type, resulting in the null pointer value of that type. Note that the null pointer constant &lt;code&gt;nullptr&lt;/code&gt; or any other value of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; cannot be converted to a pointer with &lt;code&gt;reinterpret_cast&lt;/code&gt;: implicit conversion or &lt;code&gt;static_cast&lt;/code&gt; should be used for this purpose.</source>
          <target state="translated">9) 모든 포인터 유형의 널 포인터 값을 다른 포인터 유형으로 변환하여 해당 유형의 널 포인터 값을 생성 할 수 있습니다. 널 포인터 상수 &lt;code&gt;nullptr&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 유형의 다른 값은 &lt;code&gt;reinterpret_cast&lt;/code&gt; 를 사용하여 포인터로 변환 할 수 없습니다 . 암시 적 변환 또는 &lt;code&gt;static_cast&lt;/code&gt; 를이 목적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5cf9755eed3d4b69b906bbe7371e3335b0da1ed7" translate="yes" xml:space="preserve">
          <source>9) an exception is thrown from the initial function of &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">9) &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 의 초기 함수에서 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="69d88537222dd42f47ea8040cc4dfee656ddaf6b" translate="yes" xml:space="preserve">
          <source>9) in a &lt;a href=&quot;operator_member_access#Built-in_subscript_operator&quot;&gt;subscript expression&lt;/a&gt; with a user-defined &lt;code&gt;operator[]&lt;/code&gt;, where list-initialization initializes the parameter of the overloaded operator</source>
          <target state="translated">9) 사용자 정의 &lt;code&gt;operator[]&lt;/code&gt; 가있는 &lt;a href=&quot;operator_member_access#Built-in_subscript_operator&quot;&gt;첨자 표현식&lt;/a&gt; 에서,리스트 초기화는 오버로드 된 연산자의 매개 변수를 초기화합니다</target>
        </trans-unit>
        <trans-unit id="6fd7c4d498c31e88952bf096d12121a1f7e1d85e" translate="yes" xml:space="preserve">
          <source>9) linear in size of &lt;code&gt;ilist&lt;/code&gt;</source>
          <target state="translated">9) &lt;code&gt;ilist&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="c1993a2b1996947e76b6679067a9e2cc2f498220" translate="yes" xml:space="preserve">
          <source>9) subview &lt;code&gt;[pos2, pos2 + count2)&lt;/code&gt; of a string view &lt;code&gt;sv&lt;/code&gt;, converted from &lt;code&gt;t&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, except if &lt;code&gt;count2==npos&lt;/code&gt; or if it would extend past &lt;code&gt;sv.size()&lt;/code&gt;, &lt;code&gt;[pos2, sv.size())&lt;/code&gt; is used. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">9) 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 의 subview &lt;code&gt;[pos2, pos2 + count2)&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 에서 변환 된 것처럼 t 에서 변환 됨 ; , 경우를 제외시켰다 &lt;code&gt;count2==npos&lt;/code&gt; 또는 과거 연장한다면 &lt;code&gt;sv.size()&lt;/code&gt; , &lt;code&gt;[pos2, sv.size())&lt;/code&gt; 에 사용된다. 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="a9fbbe18ff80dede94e9c9c5eaf18afc069f2113" translate="yes" xml:space="preserve">
          <source>9)(C++17) Reentrant lock used to prevent data races when multiple threads read, write, position, or query the position of a stream.</source>
          <target state="translated">9) (C ++ 17) 다중 스레드가 스트림의 위치를 ​​읽거나 쓰거나 위치를 지정하거나 쿼리 할 때 데이터 경쟁을 방지하는 데 사용되는 재진입 잠금입니다.</target>
        </trans-unit>
        <trans-unit id="2817d2c6f249dc385f4e5428668cab4851c08450" translate="yes" xml:space="preserve">
          <source>9)&lt;a href=&quot;function&quot;&gt;Function declarator&lt;/a&gt;. noptr-declarator any valid declarator, but if it begins with *, &amp;amp;, or &amp;amp;&amp;amp;, it has to be surrounded by parentheses. Note that the outermost function declarator may end with the optional trailing return type.</source>
          <target state="translated">9) &lt;a href=&quot;function&quot;&gt;기능 선언&lt;/a&gt; . noptr-declarator 유효한 선언자이지만 *, &amp;amp; 또는 &amp;amp;&amp;amp;로 시작하면 괄호로 묶어야합니다. 가장 바깥 쪽 함수 선언자는 선택적인 후행 리턴 유형으로 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6181958a14e35f65a5a5f0c6d87424b09aa5751a" translate="yes" xml:space="preserve">
          <source>9)&lt;code&gt;(bool)lhs&lt;/code&gt;</source>
          <target state="translated">9)&lt;code&gt;(bool)lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eecc2a41fea9b6dde06d88a00159e075e41e4b52" translate="yes" xml:space="preserve">
          <source>9)&lt;code&gt;Clock::to_utc(t)&lt;/code&gt;.</source>
          <target state="translated">9)&lt;code&gt;Clock::to_utc(t)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="6828e607eadda2daa80c72d698335804d0b55850" translate="yes" xml:space="preserve">
          <source>9)&lt;code&gt;x.date() != y&lt;/code&gt;</source>
          <target state="translated">9) &lt;code&gt;x.date() != y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1501fb5a5a62a036f7f7687abe15d7510af41ddf" translate="yes" xml:space="preserve">
          <source>9,11)&lt;code&gt;&lt;a href=&quot;month_day_last&quot;&gt;std::chrono::month_day_last&lt;/a&gt;(&lt;a href=&quot;month&quot;&gt;std::chrono::month&lt;/a&gt;(m))&lt;/code&gt;</source>
          <target state="translated">9,11)&lt;code&gt;&lt;a href=&quot;month_day_last&quot;&gt;std::chrono::month_day_last&lt;/a&gt;(&lt;a href=&quot;month&quot;&gt;std::chrono::month&lt;/a&gt;(m))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0eb5b686131d5ff3cce7f03cf83d881817c08df" translate="yes" xml:space="preserve">
          <source>9-10) &lt;code&gt;(bool)x&lt;/code&gt;.</source>
          <target state="translated">9-10) &lt;code&gt;(bool)x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b1173476213bf5f8e750b2b4a5e664361ecbba0" translate="yes" xml:space="preserve">
          <source>9-10) Returns &lt;code&gt;bool(opt)&lt;/code&gt;.</source>
          <target state="translated">9-10) &lt;code&gt;bool(opt)&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ccc87a0912d3c5516d0d9cbc522954d9ef33c643" translate="yes" xml:space="preserve">
          <source>9-10)&lt;code&gt;ptr&lt;/code&gt;</source>
          <target state="translated">9-10)&lt;code&gt;ptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a71448938f9776b816e95c032fcde47c1a162ae" translate="yes" xml:space="preserve">
          <source>9-12) Returns a reference to &lt;code&gt;p.second&lt;/code&gt;.</source>
          <target state="translated">9-12) &lt;code&gt;p.second&lt;/code&gt; 에 대한 참조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="72a7fe6b99cbeffe7c8237ef0330061479a10c09" translate="yes" xml:space="preserve">
          <source>9-13) Literal operators with these parameter lists are called by user-defined string literals</source>
          <target state="translated">9-13) 이러한 매개 변수 목록이있는 리터럴 연산자는 사용자 정의 문자열 리터럴에 의해 호출됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
