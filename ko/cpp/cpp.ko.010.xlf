<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="bd2bad531f6152b88c43bb2fbb72d8dcd8b7df39" translate="yes" xml:space="preserve">
          <source>A numeric value &lt;code&gt;n&lt;/code&gt; can be converted to a byte value using &lt;code&gt;std::byte{n}&lt;/code&gt;, due to C++17 relaxed enum class initialization rules.</source>
          <target state="translated">C ++ 17 완화 열거 형 클래스 초기화 규칙으로 인해 숫자 값 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;std::byte{n}&lt;/code&gt; 사용하여 바이트 값으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9a28ea00b0028d881fe812f3c217cb4fc954bd0" translate="yes" xml:space="preserve">
          <source>A pack expansion may appear inside the parentheses of a &lt;a href=&quot;direct_initialization&quot;&gt;direct initializer&lt;/a&gt;, a &lt;a href=&quot;explicit_cast&quot;&gt;function-style cast&lt;/a&gt;, and other contexts (&lt;a href=&quot;constructor&quot;&gt;member initializer&lt;/a&gt;, &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, etc) in which case the rules are identical to the rules for a function call expression above.</source>
          <target state="translated">팩 확장은 &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화 프로그램&lt;/a&gt; , &lt;a href=&quot;explicit_cast&quot;&gt;함수 스타일 캐스트&lt;/a&gt; 및 기타 컨텍스트 ( &lt;a href=&quot;constructor&quot;&gt;멤버 초기화 프로그램&lt;/a&gt; , &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; 등) 의 괄호 안에 표시 될 수 있으며 , 이 경우 규칙은 위의 함수 호출 표현식에 대한 규칙과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2677c415425384fd8d2e20b4d33138e46186a2e0" translate="yes" xml:space="preserve">
          <source>A pack expansion may appear inside the parentheses of a function call operator, in which case the largest expression or braced-init-list to the left of the ellipsis is the pattern that is expanded.</source>
          <target state="translated">팩 확장은 함수 호출 연산자의 괄호 안에 나타날 수 있으며,이 경우 줄임표 왼쪽의 가장 큰 표현식 또는 braced-init-list는 확장 된 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="e1ace690cd25f5f4ab9e5665bb9125a09841bb96" translate="yes" xml:space="preserve">
          <source>A pack expansion may designate the list of base classes in a &lt;a href=&quot;class&quot;&gt;class declaration&lt;/a&gt;. Typically, this also means that the constructor needs to use a pack expansion in the &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; to call the constructors of these bases:</source>
          <target state="translated">팩 확장은 &lt;a href=&quot;class&quot;&gt;클래스 선언&lt;/a&gt; 에서 기본 클래스 목록을 지정할 수 있습니다 . 일반적으로 이는 생성자가 &lt;a href=&quot;constructor&quot;&gt;멤버 초기화 목록&lt;/a&gt; 에서 팩 확장을 사용하여 이러한 기본의 생성자를 호출 해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d479119249c5408ac797bae6fd07fa8962b62780" translate="yes" xml:space="preserve">
          <source>A pair of iterators to the first and one past last positions in [first, last) where a subsequence that compares equal to [pat_first, pat_last) as defined by &lt;code&gt;pred&lt;/code&gt; is located, or a pair of copies of &lt;code&gt;last&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; 에 의해 정의 된 [pat_first, pat_last)와 동일한 서브 시퀀스가있는 마지막 순서의 마지막 위치와 마지막 마지막 위치에 대한 반복기 쌍 또는 &lt;code&gt;last&lt;/code&gt; 사본 사본 .</target>
        </trans-unit>
        <trans-unit id="92fbc534b58c32d1abb15ac3dd6e84d9ec347ad8" translate="yes" xml:space="preserve">
          <source>A pair whose first element is an iterator to the element past the last element moved in the source range, and whose second element is an iterator to the element past the last element moved in the destination range.</source>
          <target state="translated">첫 번째 요소가 마지막 요소를 지난 요소에 대한 반복자이고 소스 범위에서 이동 한 두 번째 요소와 마지막 요소를 지나친 요소에 대한 반복자 인 대상 범위에서 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="2e2beaabd453f4099778dc9501c74c786e364ee1" translate="yes" xml:space="preserve">
          <source>A parameter declaration in a function declaration that isn't a definition</source>
          <target state="translated">정의가 아닌 함수 선언의 매개 변수 선언</target>
        </trans-unit>
        <trans-unit id="0076d34b706ead6a1662fb14d4690ea4e30b8030" translate="yes" xml:space="preserve">
          <source>A parameter pack may appear in the capture clause of a &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; expression.</source>
          <target state="translated">&lt;a href=&quot;lambda&quot;&gt;람다&lt;/a&gt; 식 의 캡처 절에 매개 변수 팩이 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b45675f6742158d4e1ce1e4e41d58001eb61fb1" translate="yes" xml:space="preserve">
          <source>A path can be</source>
          <target state="translated">경로는</target>
        </trans-unit>
        <trans-unit id="8d3919f5b58d9be3b1d118858e1954d6017bb744" translate="yes" xml:space="preserve">
          <source>A path of execution is deemed to include a label if and only if it contains a jump to that label:</source>
          <target state="translated">실행 경로는 해당 레이블로의 점프가 포함 된 경우에만 레이블을 포함하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3d18d57e43e7c1a9f4ffb652c5171bd83b4d2f" translate="yes" xml:space="preserve">
          <source>A pattern consisting of a sign with no digits following it is treated as pattern that did not match anything.</source>
          <target state="translated">뒤에 숫자가없는 부호로 구성된 패턴은 일치하지 않는 패턴으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8746ca0afe0288d6db6ce87470f68b70a4fdf43e" translate="yes" xml:space="preserve">
          <source>A pattern followed by an ellipsis, in which the name of at least one parameter pack appears at least once, is</source>
          <target state="translated">하나 이상의 매개 변수 팩 이름이 한 번 이상 나타나는 패턴 뒤에 줄임표가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ca2d1d59088c7c3b22db69dff86c0c2b3191b10" translate="yes" xml:space="preserve">
          <source>A placeholder type specifier may appear in the following contexts:</source>
          <target state="translated">플레이스 홀더 유형 지정자는 다음 컨텍스트에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbee5c61daad736bbf4e77a8621940e9b34e3473" translate="yes" xml:space="preserve">
          <source>A plain integer is accepted if its meaning is unambiguous from the types of other operands: &lt;code&gt;2005y/4/5&lt;/code&gt; is allowed, but &lt;code&gt;5/April/2005&lt;/code&gt; is not.</source>
          <target state="translated">의미가 다른 피연산자 유형과 모호하지 않으면 일반 정수가 허용됩니다. &lt;code&gt;2005y/4/5&lt;/code&gt; 는 허용되지만 &lt;code&gt;5/April/2005&lt;/code&gt; 는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fec8de0bf924bd134d73493ee3f200fd0ba8a2d5" translate="yes" xml:space="preserve">
          <source>A pointer declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">포인터 선언은 &lt;a href=&quot;declarations&quot;&gt;선언자가&lt;/a&gt; 양식을 갖는 간단한 선언입니다 .</target>
        </trans-unit>
        <trans-unit id="e616d2d8a65fe8ffec77841c511375e1b8f9b0c3" translate="yes" xml:space="preserve">
          <source>A pointer or a reference to the current element.</source>
          <target state="translated">현재 요소에 대한 포인터 또는 참조</target>
        </trans-unit>
        <trans-unit id="76ac2aea4079c4a955b7660eae02edd433a9fd7c" translate="yes" xml:space="preserve">
          <source>A pointer or reference to the current match.</source>
          <target state="translated">현재 일치에 대한 포인터 또는 참조</target>
        </trans-unit>
        <trans-unit id="ab95db86866612e103ecab472411fe9d5d6b7a23" translate="yes" xml:space="preserve">
          <source>A pointer that points to an object</source>
          <target state="translated">객체를 가리키는 포인터</target>
        </trans-unit>
        <trans-unit id="4c96343afd2f0777da9cdc63088d337b0fc36123" translate="yes" xml:space="preserve">
          <source>A pointer to (possibly &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;-qualified) &lt;code&gt;void&lt;/code&gt; cannot be dereferenced. Pointers to other incomplete types can be dereferenced, but the resulting lvalue can only be used in contexts that allow an lvalue of incomplete type, e.g. when initializing a reference.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 에 대한 포인터는 아마도 &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt; -qualified 일 수 있습니다. 다른 불완전한 유형에 대한 포인터는 역 참조 될 수 있지만 결과 lvalue는 불완전한 유형의 lvalue를 허용하는 컨텍스트에서만 (예 : 참조를 초기화 할 때) 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d01181d4498df4cf0f8003b09ba8e09b3c553181" translate="yes" xml:space="preserve">
          <source>A pointer to &lt;code&gt;void&lt;/code&gt; cannot be deleted because it is not a pointer to a complete object type.</source>
          <target state="translated">포인터 &lt;code&gt;void&lt;/code&gt; 그것이 완전한 개체 형식에 대한 포인터가 없기 때문에 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f73f5e3d4de4e157b8dccf9da808fedaf2b59de" translate="yes" xml:space="preserve">
          <source>A pointer to a standard-layout class may be converted (with reinterpret_cast) to a pointer to its first non-static data member and vice versa.</source>
          <target state="translated">표준 레이아웃 클래스에 대한 포인터는 (reinterpret_cast와 함께) 첫 번째 비 정적 데이터 멤버에 대한 포인터로 변환 될 수 있으며 그 반대도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="705e66bb80cbfe8e2e8b61352ddc175ed95890e9" translate="yes" xml:space="preserve">
          <source>A pointer to allocated storage of at least &lt;code&gt;bytes&lt;/code&gt; bytes in size, aligned to the specified &lt;code&gt;alignment&lt;/code&gt; if such alignment is supported, and to &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; otherwise.</source>
          <target state="translated">크기가 최소 &lt;code&gt;bytes&lt;/code&gt; 바이트 인 할당 된 스토리지에 대한 포인터로 , 이러한 정렬이 지원되는 경우 지정된 &lt;code&gt;alignment&lt;/code&gt; 되고 그렇지 않으면 &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a9e5f21a34ce522aab5ca357e2281d794f6f56ab" translate="yes" xml:space="preserve">
          <source>A pointer to an element of an array satisfies all requirements of LegacyContiguousIterator.</source>
          <target state="translated">배열의 요소에 대한 포인터는 LegacyContiguousIterator의 모든 요구 사항을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="2dabfa7c1aee6ff19a8d014db29f4e03389ef1ab" translate="yes" xml:space="preserve">
          <source>A pointer to an element of an array satisfies all requirements of LegacyRandomAccessIterator.</source>
          <target state="translated">배열 요소에 대한 포인터는 LegacyRandomAccessIterator의 모든 요구 사항을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="bf53771350311775a7859918261dd7a4cabe6a6f" translate="yes" xml:space="preserve">
          <source>A pointer to an object of standard-layout class type can be &lt;a href=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; to pointer to its first non-static non-bitfield data member (if it has non-static data members) or otherwise any of its base class subobjects (if it has any), and vice versa. In other words, padding is not allowed before the first data member of a standard-layout type. Note that &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;strict aliasing&lt;/a&gt; rules still apply to the result of such cast.</source>
          <target state="translated">표준 레이아웃 클래스 유형의 객체에 대한 포인터는 비 정적 비 비트 필드 데이터 멤버 (비 정적 데이터 멤버가있는 경우) 또는 기본 클래스 서브 오브젝트 (있는 경우)를 가리키는 포인터로 &lt;a href=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; 될 수 있습니다. ), 그 반대. 즉, 표준 레이아웃 유형의 첫 번째 데이터 멤버 앞에는 패딩이 허용되지 않습니다. 참고 &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;엄격한 앨리어싱&lt;/a&gt; 규칙이 여전히 캐스트의 결과에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c433adb64c0845bb1339f1da97f3f437a44c4418" translate="yes" xml:space="preserve">
          <source>A pointer to function can be initialized with an address of a non-member function or a static member function. Because of the &lt;a href=&quot;implicit_cast&quot;&gt;function-to-pointer&lt;/a&gt; implicit conversion, the address-of operator is optional:</source>
          <target state="translated">비 멤버 함수 또는 정적 멤버 함수의 주소를 사용하여 함수에 대한 포인터를 초기화 할 수 있습니다. 왜냐하면의 &lt;a href=&quot;implicit_cast&quot;&gt;함수에 대한 포인터&lt;/a&gt; 암시 적 변환은 주소의 오퍼레이터는 선택적이다 :</target>
        </trans-unit>
        <trans-unit id="fee552ad23a470ee0488c57dc099836dec669c19" translate="yes" xml:space="preserve">
          <source>A pointer to function can be used as the left-hand operand of the &lt;a href=&quot;operator_other&quot;&gt;function call operator&lt;/a&gt;, this invokes the pointed-to function:</source>
          <target state="translated">함수에 대한 포인터는 &lt;a href=&quot;operator_other&quot;&gt;함수 호출 연산자&lt;/a&gt; 의 왼쪽 피연산자로 사용할 수 있으며 , 이는 지정된 함수를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="099c10c4969aca0ed60f063fd0510673f35f2754" translate="yes" xml:space="preserve">
          <source>A pointer to function may be initialized from an overload set which may include functions, function template specializations, and function templates, if only one overload matches the type of the pointer (see &lt;a href=&quot;overloaded_address&quot;&gt;address of an overloaded function&lt;/a&gt; for more detail):</source>
          <target state="translated">함수에 대한 포인터는 하나의 과부하 만 포인터 유형과 일치하는 경우 함수, 함수 템플릿 전문화 및 함수 템플릿을 포함 할 수있는 과부하 세트에서 초기화 될 수 있습니다 (자세한 내용 &lt;a href=&quot;overloaded_address&quot;&gt;은 오버로드 된 함수의 주소&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8f1bfae7aedabc69e7b7058df026de700a35db9f" translate="yes" xml:space="preserve">
          <source>A pointer to non-array object is treated as a pointer to the first element of an array with size 1.</source>
          <target state="translated">비 배열 객체에 대한 포인터는 크기가 1 인 배열의 첫 번째 요소에 대한 포인터로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="cb38a2b02a68bb7fc07ad522e4391fd787512883" translate="yes" xml:space="preserve">
          <source>A pointer to non-static member function &lt;code&gt;f&lt;/code&gt; which is a member of class &lt;code&gt;C&lt;/code&gt; can be initialized with the expression &lt;code&gt;&amp;amp;C::f&lt;/code&gt; exactly. Expressions such as &lt;code&gt;&amp;amp;(C::f)&lt;/code&gt; or &lt;code&gt;&amp;amp;f&lt;/code&gt; inside C's member function do not form pointers to member functions.</source>
          <target state="translated">클래스 &lt;code&gt;C&lt;/code&gt; 의 멤버 인 비 정적 멤버 함수 &lt;code&gt;f&lt;/code&gt; 에 대한 포인터 는 &lt;code&gt;&amp;amp;C::f&lt;/code&gt; 표현식으로 정확하게 초기화 될 수 있습니다 . C의 멤버 함수 내에서 &lt;code&gt;&amp;amp;(C::f)&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;f&lt;/code&gt; 와 같은 표현식 은 멤버 함수에 대한 포인터를 형성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53cf9e67e880a7f25905f2424504dd5b25bc02f1" translate="yes" xml:space="preserve">
          <source>A pointer to non-static member object &lt;code&gt;m&lt;/code&gt; which is a member of class &lt;code&gt;C&lt;/code&gt; can be initialized with the expression &lt;code&gt;&amp;amp;C::m&lt;/code&gt; exactly. Expressions such as &lt;code&gt;&amp;amp;(C::m)&lt;/code&gt; or &lt;code&gt;&amp;amp;m&lt;/code&gt; inside C's member function do not form pointers to members.</source>
          <target state="translated">클래스 &lt;code&gt;C&lt;/code&gt; 의 멤버 인 비 정적 멤버 오브젝트 &lt;code&gt;m&lt;/code&gt; 에 대한 포인터 는 &lt;code&gt;&amp;amp;C::m&lt;/code&gt; 표현식으로 정확하게 초기화 될 수 있습니다 . C의 멤버 함수 내에서 &lt;code&gt;&amp;amp;(C::m)&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;m&lt;/code&gt; 과 같은 표현식 은 멤버에 대한 포인터를 형성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4605388fefbc6745ad5fb4ab3501853f9b2e59ca" translate="yes" xml:space="preserve">
          <source>A pointer to object can be initialized with the return value of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; applied to any expression of object type, including another pointer type:</source>
          <target state="translated">객체에 대한 포인터 는 다른 포인터 유형을 포함하여 객체 유형의 모든 표현식에 적용된 &lt;a href=&quot;operator_member_access&quot;&gt;주소 연산자&lt;/a&gt; 의 반환 값으로 초기화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb0b45c2fb8692553e4131bcd61d0db96c449b86" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the local time zone of the computer.</source>
          <target state="translated">이 데이터베이스에서 컴퓨터의 로컬 시간대를 나타내는 &lt;code&gt;std::chrono::time_zone&lt;/code&gt; 에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="109ab033a06ddd191eedf4e6243ebdbfa781c50d" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the time zone designated by &lt;code&gt;tz_name&lt;/code&gt;.</source>
          <target state="translated">이 데이터베이스에서 &lt;code&gt;tz_name&lt;/code&gt; 으로 지정된 시간대를 나타내는 &lt;code&gt;std::chrono::time_zone&lt;/code&gt; 에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="7186294424331f7f2da77bb5b939c2393a738e08" translate="yes" xml:space="preserve">
          <source>A pointer to the allocated and constructed object.</source>
          <target state="translated">할당 및 생성 된 객체에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="90fab4aff09dede56fdb6d84059c3624b3b99e4c" translate="yes" xml:space="preserve">
          <source>A pointer to the allocated storage.</source>
          <target state="translated">할당 된 스토리지에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="84ca1216b138fa1171353f37562e84b5694e8e55" translate="yes" xml:space="preserve">
          <source>A pointer to the beginning of the sequence.</source>
          <target state="translated">시퀀스의 시작을 가리키는 포인터.</target>
        </trans-unit>
        <trans-unit id="34743a200c5640f215061cfae8958c69a6b3ced4" translate="yes" xml:space="preserve">
          <source>A pointer to the block of memory containing the elements of the container.</source>
          <target state="translated">컨테이너의 요소를 포함하는 메모리 블록에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="a8d3f2979c65ac771376f7686ffa1017464bd622" translate="yes" xml:space="preserve">
          <source>A pointer to the first character in the range specified by &lt;code&gt;[p, p + count)&lt;/code&gt; that compares equal to &lt;code&gt;ch&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if not found.</source>
          <target state="translated">&lt;code&gt;[p, p + count)&lt;/code&gt; 지정된 범위 에서 &lt;code&gt;ch&lt;/code&gt; 와 같거나 비교할 수없는 첫 번째 문자에 대한 포인터 이거나 찾지 못한 경우 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="85748d7d2f8b08c1130cce69c2693bdbf36686d5" translate="yes" xml:space="preserve">
          <source>A pointer to the first element in the classification table (which an array of size &lt;code&gt;std::ctype&amp;lt;char&amp;gt;::table_size&lt;/code&gt;).</source>
          <target state="translated">분류 테이블의 첫 번째 요소에 대한 포인터 (크기 배열 &lt;code&gt;std::ctype&amp;lt;char&amp;gt;::table_size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d6f48b5d05090c0288e98d43d8a863e8b2c04b8" translate="yes" xml:space="preserve">
          <source>A pointer to the owned deleter or &lt;code&gt;nullptr&lt;/code&gt;. The returned pointer is valid at least as long as there remains at least one &lt;code&gt;shared_ptr&lt;/code&gt; instance that owns it.</source>
          <target state="translated">소유 한 삭제 자 또는 &lt;code&gt;nullptr&lt;/code&gt; 의 포인터 . 반환 된 포인터는 적어도 하나의 &lt;code&gt;shared_ptr&lt;/code&gt; 인스턴스를 소유하고있는 한 최소한 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="b50fe0059480635f66a814d6c4000336f99ae375" translate="yes" xml:space="preserve">
          <source>A pointer to the stored function if &lt;code&gt;target_type() == typeid(T)&lt;/code&gt;, otherwise a null pointer.</source>
          <target state="translated">&lt;code&gt;target_type() == typeid(T)&lt;/code&gt; 인 경우 저장된 함수에 대한 포인터 이고, 그렇지 않으면 널 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="fe7ecdbac553ec91128d6f72f68f35f00624e049" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying character array.</source>
          <target state="translated">기본 문자 배열에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="890ea029c831a738d852daab1692736f467e7a47" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying character storage.</source>
          <target state="translated">기본 문자 저장소에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="7a202c804155efff22e9a4e471438c6dbf2d98d3" translate="yes" xml:space="preserve">
          <source>A possible implementation of this class is.</source>
          <target state="translated">이 클래스의 가능한 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc77f50c4833701227ea3422c38b612aa4fdfe9d" translate="yes" xml:space="preserve">
          <source>A possible use for &lt;code&gt;std::condition_variable_any&lt;/code&gt; with custom &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; types is to provide convenient interruptible waits: the custom lock operation would both lock the associated mutex as expected, and also perform the necessary setup to notify this condition variable when the interrupting signal is received.&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;condition_variable_any#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;../named_req/lockable&quot;&gt;잠금 가능&lt;/a&gt; 유형으로 &lt;code&gt;std::condition_variable_any&lt;/code&gt; 를 사용할 수있는 편리한 인터럽트 가능 대기를 제공하는 것입니다. 사용자 정의 잠금 조작은 예상대로 연관된 뮤텍스를 잠그고 인터럽트 신호가 수신 될 때이 조건 변수에 알리기 위해 필요한 설정을 수행합니다. &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;condition_variable_any#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0c4ca9f04ce9075912ba0b19bfb872f73c52baa7" translate="yes" xml:space="preserve">
          <source>A possibly const value of type &lt;code&gt;X::key_compare&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X::key_compare&lt;/code&gt; 유형의 가능한 const 값</target>
        </trans-unit>
        <trans-unit id="7916eb952414b9a1c31b5a2dafada3b876f5ad6e" translate="yes" xml:space="preserve">
          <source>A precondition of this function is that &lt;code&gt;[first, n_first)&lt;/code&gt; and &lt;code&gt;[n_first, last)&lt;/code&gt; are valid ranges.</source>
          <target state="translated">이 함수의 전제 조건은 &lt;code&gt;[first, n_first)&lt;/code&gt; 및 &lt;code&gt;[n_first, last)&lt;/code&gt; 가 유효한 범위 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="b6b696e16fd55d74c0cbd8840d4be4cbde76e009" translate="yes" xml:space="preserve">
          <source>A primitive static vector class, demonstrating creation, access, and destruction of objects in aligned storage.</source>
          <target state="translated">정렬 된 스토리지에서 객체의 생성, 액세스 및 파괴를 보여주는 기본 정적 벡터 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="9f03356025d9d886dc6751b026e010eaa4c75c65" translate="yes" xml:space="preserve">
          <source>A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.</source>
          <target state="translated">우선 순위 큐는 로그 삽입 및 추출을 희생하면서 가장 큰 (기본적으로) 요소의 지속적인 시간 조회를 제공하는 컨테이너 어댑터입니다.</target>
        </trans-unit>
        <trans-unit id="aa89f91f3d3f3e8b505f31100bf86fa2ca7b655c" translate="yes" xml:space="preserve">
          <source>A private member of a class can only be accessed by the members and friends of that class, regardless of whether the members are on the same or different instances:</source>
          <target state="translated">클래스의 비공개 멤버는 멤버가 동일한 인스턴스인지 또는 다른 인스턴스인지에 관계없이 해당 클래스의 멤버 및 친구 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da9d03016a24905e53207d2ba428a1b8e9a9aaf7" translate="yes" xml:space="preserve">
          <source>A program is not required to call the destructor of an object to end its lifetime if the object is &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;trivially-destructible&lt;/a&gt; or if the program does not rely on the side effects of the destructor. However, if a program ends the lifetime of an non-trivial object explicitly, it must ensure that a new object of the same type is constructed in-place (e.g. via placement new) before the destructor may be called implicitly, i.e. due to scope exit or exception for automatic objects, due to thread exit for thread-local objects, or due to program exit for static objects; otherwise the behavior is undefined.</source>
          <target state="translated">객체가 &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;사소하게 파괴 가능&lt;/a&gt; 하거나 프로그램이 소멸자의 부작용에 의존하지 않는 경우 프로그램은 객체의 소멸자를 호출하여 수명을 끝내지 않아도됩니다. 그러나 프로그램이 사소하지 않은 오브젝트의 수명을 명시 적으로 종료하는 경우 소멸자가 암시 적으로 호출되기 전에 (예 : 범위로 인해) 동일한 유형의 새 오브젝트가 적절한 위치에 (예 : 새 배치를 통해) 구성되어야합니다. 스레드 로컬 오브젝트의 스레드 종료 또는 정적 오브젝트의 프로그램 종료로 인해 자동 오브젝트의 종료 또는 예외; 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03089f15ead7ca5ed65d816afebaddda671b3974" translate="yes" xml:space="preserve">
          <source>A program may be translated with one of three</source>
          <target state="translated">프로그램은 다음 세 가지 중 하나로 번역 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="66c3ecf22ff81745bed14260f746ab81e7c0d0a2" translate="yes" xml:space="preserve">
          <source>A program may be translated with one of two</source>
          <target state="translated">프로그램은 두 가지 중 하나로 번역 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5a764d00cd6118dc37146370c6388538e41d1085" translate="yes" xml:space="preserve">
          <source>A program may not specialize &lt;code&gt;basic_common_reference&lt;/code&gt; on the third or fourth parameters, nor may it specialize &lt;code&gt;common_reference&lt;/code&gt; itself. A program that adds specializations in violation of these rules has undefined behavior.</source>
          <target state="translated">프로그램은 전문 않을 수 &lt;code&gt;basic_common_reference&lt;/code&gt; 을 3,4 파라미터 않으며 전문 수 &lt;code&gt;common_reference&lt;/code&gt; 자체. 이러한 규칙을 위반하여 전문화 영역을 추가하는 프로그램에는 정의되지 않은 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="17328f55bfa3f5f5c88fbe4c9f98cf4b5f272bc0" translate="yes" xml:space="preserve">
          <source>A program may specialize &lt;code&gt;basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;&lt;/code&gt; on the first two parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;U, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; are both true and at least one of them depends on a program-defined type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;T, &lt;a href=&quot;decay&quot;&gt;std :: decay_t&lt;/a&gt; &amp;lt;T &amp;gt;&amp;gt; 및 &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;U, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;U, &lt;a href=&quot;decay&quot;&gt;std :: decay_t 인&lt;/a&gt; 경우 프로그램은 처음 두 매개 변수 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;U&lt;/code&gt; 에 대해 &lt;code&gt;basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;&lt;/code&gt; 을 특수화 할 수 있습니다. &amp;lt;U &amp;gt;&amp;gt; 는 모두 true이며 둘 중 하나 이상은 프로그램 정의 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8e61a356e3234eed06fa2f0f5dee899601ee82c6" translate="yes" xml:space="preserve">
          <source>A program may specialize &lt;code&gt;clock_time_conversion&lt;/code&gt; if at least one of the template parameters is a user-defined clock type.</source>
          <target state="translated">템플릿 파라미터 중 적어도 하나가 사용자 정의 클록 유형 인 경우 프로그램은 &lt;code&gt;clock_time_conversion&lt;/code&gt; 을 특수화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97b63352c2d736a021395385f10f9bb467d6e3fd" translate="yes" xml:space="preserve">
          <source>A program shall contain a global function named &lt;code&gt;main&lt;/code&gt;, which is the designated start of the program. It shall have one of the following forms:</source>
          <target state="translated">프로그램 은 프로그램의 지정된 시작 인 &lt;code&gt;main&lt;/code&gt; 이라는 글로벌 함수를 포함해야합니다 . 다음 형식 중 하나를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="5437280a6191901c16079ac8f80aff7f070d8c2f" translate="yes" xml:space="preserve">
          <source>A program that adds &lt;code&gt;common_type&lt;/code&gt; specializations in violation of these rules has undefined behavior.</source>
          <target state="translated">이러한 규칙을 위반하여 &lt;code&gt;common_type&lt;/code&gt; 전문화 를 추가하는 프로그램 에는 정의되지 않은 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fee44e17e3a13581354a330d85e96728e00f4bd" translate="yes" xml:space="preserve">
          <source>A protected member of a class &lt;code&gt;Base&lt;/code&gt; can only be accessed.</source>
          <target state="translated">&lt;code&gt;Base&lt;/code&gt; 클래스의 보호 된 멤버 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87b080a926e158a236034e081054063e31488155" translate="yes" xml:space="preserve">
          <source>A prvalue cannot be &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;: the &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;dynamic type&lt;/a&gt; of the object it identifies is always the type of the expression.</source>
          <target state="translated">prvalue는 &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;다형성이&lt;/a&gt; 될 수 없습니다 . 식별하는 객체 의 &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;동적 유형&lt;/a&gt; 은 항상 표현식의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="948c7440ba50ed3eb424033ba764365ffa6afd0f" translate="yes" xml:space="preserve">
          <source>A prvalue cannot have &lt;a href=&quot;abstract_class&quot;&gt;abstract class type&lt;/a&gt; or an array thereof.</source>
          <target state="translated">prvalue는 &lt;a href=&quot;abstract_class&quot;&gt;추상 클래스 유형&lt;/a&gt; 이나 배열을 가질 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9922e8eeb154c6c0744ee9e4ba026d8fb5b557df" translate="yes" xml:space="preserve">
          <source>A prvalue cannot have &lt;a href=&quot;type-id#Incomplete_type&quot;&gt;incomplete type&lt;/a&gt; (except for type void, see below, or when used in &lt;a href=&quot;decltype&quot;&gt;decltype specifier&lt;/a&gt;)</source>
          <target state="translated">prvalue는 &lt;a href=&quot;type-id#Incomplete_type&quot;&gt;불완전한 유형을&lt;/a&gt; 가질 수 없습니다 (void 유형 제외, 아래 참조 또는 &lt;a href=&quot;decltype&quot;&gt;decltype 지정자&lt;/a&gt; 사용시 )</target>
        </trans-unit>
        <trans-unit id="89adcc7246c411786e22055f1d4bc6dc797ab523" translate="yes" xml:space="preserve">
          <source>A prvalue of integer or unscoped enumeration type can be converted to a prvalue of any floating-point type. If the value cannot be represented correctly, it is implementation defined whether the closest higher or the closest lower representable value will be selected, although if IEEE arithmetic is supported, rounding defaults &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;to nearest&lt;/a&gt;. If the value cannot fit into the destination type, the behavior is undefined. If the source type is &lt;code&gt;bool&lt;/code&gt;, the value &lt;code&gt;false&lt;/code&gt; is converted to zero, and the value &lt;code&gt;true&lt;/code&gt; is converted to one.</source>
          <target state="translated">정수 또는 범위가없는 열거 유형의 prvalue는 모든 부동 소수점 유형의 prvalue로 변환 될 수 있습니다. 값을 올바르게 표현할 수없는 경우 IEEE 산술이 지원되는 경우 반올림의 기본값 &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;은 가장 가까운로 표시&lt;/a&gt; 되지만 가장 높은 표현 값 또는 가장 가까운 가장 낮은 표현 가능 값을 선택할지 여부는 구현 정의 입니다. 값이 대상 유형에 맞지 않으면 동작이 정의되지 않은 것입니다. 소스 유형이 &lt;code&gt;bool&lt;/code&gt; 인 경우 &lt;code&gt;false&lt;/code&gt; 값 은 0 으로 변환되고 &lt;code&gt;true&lt;/code&gt; 값 은 1로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1cc331b941fd7c1d4179b58d5442419123db000e" translate="yes" xml:space="preserve">
          <source>A prvalue of type pointer to member of cv-qualified type &lt;code&gt;T&lt;/code&gt; in class &lt;code&gt;X&lt;/code&gt; can be converted to a prvalue pointer to member of more cv-qualified type &lt;code&gt;T&lt;/code&gt; in class &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">이력서 자격을 갖춘 형의 멤버로 유형 포인터의 prvalue &lt;code&gt;T&lt;/code&gt; 클래스에서 &lt;code&gt;X&lt;/code&gt; 는 더 이력서 자격 타입의 멤버에 prvalue 포인터로 변환 할 수있는 &lt;code&gt;T&lt;/code&gt; 클래스에 &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3def19238902e53ffc0e7c4199b58d0948a3fce" translate="yes" xml:space="preserve">
          <source>A prvalue of type pointer to non-throwing member function can be converted to a prvalue pointer to potentially-throwing member function.</source>
          <target state="translated">비 투척 멤버 함수에 대한 포인터 유형의 prvalue는 잠재적으로 투척하는 멤버 함수에 대한 prvalue 포인터로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4ca3c60807a21440fb680870f4faa7d3f0b6ab5" translate="yes" xml:space="preserve">
          <source>A prvalue pointer to a (optionally cv-qualified) derived class type can be converted to a prvalue pointer to its (identically cv-qualified) base class. If the base class is inaccessible or ambiguous, the conversion is ill-formed (won't compile). The result of the conversion is a pointer to the base class subobject within the pointed-to object. The null pointer value is converted to the null pointer value of the destination type.</source>
          <target state="translated">(선택적으로 cv-qualified) 파생 클래스 유형에 대한 prvalue 포인터는 (동일하게 cv-qualified) 기본 클래스에 대한 prvalue 포인터로 변환 될 수 있습니다. 기본 클래스에 액세스 할 수 없거나 모호한 경우 변환이 잘못 작성됩니다 (컴파일되지 않음). 변환 결과는 지정된 객체 내의 기본 클래스 하위 객체에 대한 포인터입니다. 널 포인터 값은 대상 유형의 널 포인터 값으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b68c522f33b2f282c51184b2111938ab2a45c6a2" translate="yes" xml:space="preserve">
          <source>A pseudo-random number in [&lt;code&gt;min()&lt;/code&gt;, &lt;code&gt;max()&lt;/code&gt;].</source>
          <target state="translated">[ &lt;code&gt;min()&lt;/code&gt; , &lt;code&gt;max()&lt;/code&gt; ] 의 의사 난수 입니다.</target>
        </trans-unit>
        <trans-unit id="518c2995944086d5bc64a89e68ef8ff2eda028d4" translate="yes" xml:space="preserve">
          <source>A public member of a class is accessible everywhere.</source>
          <target state="translated">클래스의 공개 멤버는 어디서나 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a237039e9334b0659fe3de5e7abb2fcf04116a22" translate="yes" xml:space="preserve">
          <source>A pure virtual function is a &lt;a href=&quot;virtual&quot;&gt;virtual function&lt;/a&gt; whose &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; has the following syntax:</source>
          <target state="translated">순수 가상 함수는 &lt;a href=&quot;function&quot;&gt;선언자가&lt;/a&gt; 다음 구문을 갖는 &lt;a href=&quot;virtual&quot;&gt;가상 함수&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d2a131b189a54243081396040bed210dca58fe18" translate="yes" xml:space="preserve">
          <source>A qualified name that appears in</source>
          <target state="translated">에 나오는 정규화 된 이름</target>
        </trans-unit>
        <trans-unit id="f00c1c26af032f164f98a00ceb65858c99c608e2" translate="yes" xml:space="preserve">
          <source>A qualified name that is used as a &lt;a href=&quot;declarations#Specifiers&quot;&gt;declaration specifier&lt;/a&gt; in the (top-level) decl-specifier-seq of:</source>
          <target state="translated">(최상위) decl-specifier-seq에서 &lt;a href=&quot;declarations#Specifiers&quot;&gt;선언 지정자&lt;/a&gt; 로 사용되는 정규화 된 이름 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="234e75018942daa7d9ddc6b7ab239081b75bbb61" translate="yes" xml:space="preserve">
          <source>A random number distribution post-processes the output of a URBG in such a way that resulting output is distributed according to a defined statistical probability density function.</source>
          <target state="translated">난수 분포는 결과 출력이 정의 된 통계적 확률 밀도 함수에 따라 분포되는 방식으로 URBG의 출력을 후 처리합니다.</target>
        </trans-unit>
        <trans-unit id="63c005a6e5fbfc7dc8af621e2d17685667135352" translate="yes" xml:space="preserve">
          <source>A random number engine is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.</source>
          <target state="translated">난수 엔진은 가능한 결과 범위의 각 값이 (이상적으로) 동일한 확률을 갖도록 부호없는 정수 값을 반환하는 함수 객체입니다.</target>
        </trans-unit>
        <trans-unit id="218114a7bf5a72fb79f4bcfba1ca863f66fc080d" translate="yes" xml:space="preserve">
          <source>A random number generator may satisfy &lt;code&gt;Invocable&lt;/code&gt; but cannot satisfy &lt;code&gt;RegularInvocable&lt;/code&gt; (&lt;a href=&quot;https://xkcd.com/221/&quot;&gt;comical&lt;/a&gt;&lt;a href=&quot;http://dilbert.com/strip/2001-10-25&quot;&gt;ones&lt;/a&gt; excluded).</source>
          <target state="translated">난수 생성기는 &lt;code&gt;Invocable&lt;/code&gt; 을 만족시킬 수 있지만 &lt;code&gt;RegularInvocable&lt;/code&gt; 을 만족시킬 수는 없습니다 ( &lt;a href=&quot;https://xkcd.com/221/&quot;&gt;만화 &lt;/a&gt;&lt;a href=&quot;http://dilbert.com/strip/2001-10-25&quot;&gt;는&lt;/a&gt; 제외).</target>
        </trans-unit>
        <trans-unit id="c8740cda35197e3b7986bfb9d3958a23da53121b" translate="yes" xml:space="preserve">
          <source>A random number uniformly distributed in [&lt;code&gt;min()&lt;/code&gt;, &lt;code&gt;max()&lt;/code&gt;].</source>
          <target state="translated">[ &lt;code&gt;min()&lt;/code&gt; , &lt;code&gt;max()&lt;/code&gt; ]에 균일하게 분포 된 난수 입니다.</target>
        </trans-unit>
        <trans-unit id="c6c8fb5e09b78d7ba8993d92c01b80b6ecf577e7" translate="yes" xml:space="preserve">
          <source>A range adaptor that returns a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of its &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 인수 의 모든 요소를 ​​포함 하는 &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 를 반환하는 범위 어댑터입니다 .</target>
        </trans-unit>
        <trans-unit id="4b161bf3c0670ce52a5c8049eec7a861c20295c5" translate="yes" xml:space="preserve">
          <source>A raw pointer of the type &lt;code&gt;element_type*&lt;/code&gt; that references the same memory location as the argument &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;p&lt;/code&gt; 와 동일한 메모리 위치를 참조하는 &lt;code&gt;element_type*&lt;/code&gt; 유형의 원시 포인터 .</target>
        </trans-unit>
        <trans-unit id="a987fe5116d16dac6c986d15e44866f1f2950023" translate="yes" xml:space="preserve">
          <source>A read-modify-write operation with this memory order is both an</source>
          <target state="translated">이 메모리 순서를 사용한 읽기-수정-쓰기 작업은</target>
        </trans-unit>
        <trans-unit id="e3862e525cd9728a75bb86198e817c0be834e74b" translate="yes" xml:space="preserve">
          <source>A reference is required to be initialized to refer to a valid object or function: see &lt;a href=&quot;reference_initialization&quot;&gt;reference initialization&lt;/a&gt;.</source>
          <target state="translated">유효한 객체 또는 함수를 참조하려면 &lt;a href=&quot;reference_initialization&quot;&gt;참조를 초기화해야&lt;/a&gt; 합니다 ( 참조 초기화 참조) .</target>
        </trans-unit>
        <trans-unit id="b8168313a358c53144732f59b7b55f79bc0d83aa" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;OuterAlloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OuterAlloc&lt;/code&gt; 에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="804797fdb54fd58e448bcbbb5edeb1965dd46ac6" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;T&lt;/code&gt; can be initialized with an object of type &lt;code&gt;T&lt;/code&gt;, a function of type &lt;code&gt;T&lt;/code&gt;, or an object implicitly convertible to &lt;code&gt;T&lt;/code&gt;. Once initialized, a reference cannot be changed to refer to another object.</source>
          <target state="translated">에 대한 참조 &lt;code&gt;T&lt;/code&gt; 는 타입의 객체로 초기화 될 수 &lt;code&gt;T&lt;/code&gt; 를 입력하는 기능 &lt;code&gt;T&lt;/code&gt; 또는 암시 적 변환 대상 &lt;code&gt;T&lt;/code&gt; . 일단 초기화되면 다른 객체를 참조하도록 참조를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96effaa229108956b87eaa0ef7506c4b68779cfb" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Ith&lt;/code&gt; element of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">받는 참조 &lt;code&gt;Ith&lt;/code&gt; 의 요소 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fed9a57692255e9193120495f8b304740d5643ee" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Ith&lt;/code&gt; element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 &lt;code&gt;Ith&lt;/code&gt; 요소에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="8587a8972573baad1abe654df486c02df1c78add" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;idx&lt;/code&gt;-th element of the array, i.e., &lt;code&gt;get()[idx]&lt;/code&gt;</source>
          <target state="translated">배열 의 &lt;code&gt;idx&lt;/code&gt; -th 요소에 대한 참조 , 즉 &lt;code&gt;get()[idx]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36d8ef7aa332a08ad1749e9a36b2ab00fe12b221" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;idx&lt;/code&gt;-th element of the sequence, i.e., &lt;code&gt;data()[idx]&lt;/code&gt;</source>
          <target state="translated">시퀀스 의 &lt;code&gt;idx&lt;/code&gt; -th 요소에 대한 참조 , 즉 &lt;code&gt;data()[idx]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af1efc2484e454ad9728eae87f942a799f403462" translate="yes" xml:space="preserve">
          <source>A reference to the back element.</source>
          <target state="translated">back 요소에 대한 참조</target>
        </trans-unit>
        <trans-unit id="932b2a1f1d48ceff1483626d393c48deb6ec133d" translate="yes" xml:space="preserve">
          <source>A reference to the contained value.</source>
          <target state="translated">포함 된 값에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="8de78a95776c196427cb50ef2308786df9feaa77" translate="yes" xml:space="preserve">
          <source>A reference to the element at relative location, that is, &lt;code&gt;base()[-n-1]&lt;/code&gt;.</source>
          <target state="translated">상대 위치의 요소, 즉 &lt;code&gt;base()[-n-1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed2f64858c4b136043374a81f773f2bb47825288" translate="yes" xml:space="preserve">
          <source>A reference to the element.</source>
          <target state="translated">요소에 대한 참조</target>
        </trans-unit>
        <trans-unit id="1b47ff083eea09f7ebfc57e29aa6a19dcffb7f4b" translate="yes" xml:space="preserve">
          <source>A reference to the first element.</source>
          <target state="translated">첫 번째 요소에 대한 참조</target>
        </trans-unit>
        <trans-unit id="a0df3de2b33596434eabf885b30512aa4bd9a7f7" translate="yes" xml:space="preserve">
          <source>A reference to the inner allocator, which is itself a &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt;.</source>
          <target state="translated">내부 할당 자에 대한 참조이며, 그 자체는 &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6d12739b00cf675a6ba691cc42cc3b54b7c86c25" translate="yes" xml:space="preserve">
          <source>A reference to the inserted element.</source>
          <target state="translated">삽입 된 요소에 대한 참조</target>
        </trans-unit>
        <trans-unit id="9b728bf8ae3f8f1afb3d2c134ee7f6175d648f5b" translate="yes" xml:space="preserve">
          <source>A reference to the new contained object.</source>
          <target state="translated">포함 된 새 객체에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="695dad725bff816bf70ec1a1e915658d83c47722" translate="yes" xml:space="preserve">
          <source>A reference to the new contained value.</source>
          <target state="translated">새 포함 값에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="1f840389ee6e69a00e4361ae4f5b87b0602e4e15" translate="yes" xml:space="preserve">
          <source>A reference to the selected element of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 의 선택된 요소에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="215a738f7f92427350a124e8545beaf159690b56" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;../../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 에서 파생 된 지정되지 않은 런타임 유형의 정적 객체에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="2dce474f5e611fdd344ca6f78607a960539b8d24" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 에서 파생 된 지정되지 않은 런타임 유형의 정적 객체에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="52beb0ba5b037a0cd1d9ec162abace30f7074fd0" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 에서 파생 된 지정되지 않은 런타임 유형의 정적 객체에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="b9ad010ef7d281736e175c6e04e6e45d80ea96e8" translate="yes" xml:space="preserve">
          <source>A reference to the stream, i.e., &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">스트림, 즉,에 대한 참조 &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b519975029bcddb7935a1938c71b85de5a9aa395" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;day&lt;/code&gt; after modification.</source>
          <target state="translated">수정 후이 &lt;code&gt;day&lt;/code&gt; 대한 참조 .</target>
        </trans-unit>
        <trans-unit id="fd1b8fb4c67bb93024d4c080ffbd107e8a00646c" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;month&lt;/code&gt; after modification.</source>
          <target state="translated">수정 후이 &lt;code&gt;month&lt;/code&gt; 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="77d42f71b8ba36af0d80129ce3320e59f448b88f" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;weekday&lt;/code&gt; after modification.</source>
          <target state="translated">수정 &lt;code&gt;weekday&lt;/code&gt; 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="30e2b7de4724355804f01b061a5218dcca673f33" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;year&lt;/code&gt; after modification.</source>
          <target state="translated">수정 후 &lt;code&gt;year&lt;/code&gt; 대한 참조 .</target>
        </trans-unit>
        <trans-unit id="c42d3cc108e10a5c0d961e89275a7b7e304370ef" translate="yes" xml:space="preserve">
          <source>A reference to this duration after modification.</source>
          <target state="translated">수정 후이 기간에 대한 참조.</target>
        </trans-unit>
        <trans-unit id="477f7a0da5713d89a4c5a2b12679f4b4532b6576" translate="yes" xml:space="preserve">
          <source>A reference variable declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">참조 변수 선언은 &lt;a href=&quot;declarations&quot;&gt;선언자가&lt;/a&gt; 양식을 갖는 간단한 선언입니다 .</target>
        </trans-unit>
        <trans-unit id="071394746753f76fda55bbb1f2d7273768e4c96d" translate="yes" xml:space="preserve">
          <source>A release fence F in thread A synchronizes-with atomic &lt;a href=&quot;memory_order&quot;&gt;acquire operation&lt;/a&gt; Y in thread B, if.</source>
          <target state="translated">스레드 A의 릴리스 펜스 F 는 스레드 B의 원자 &lt;a href=&quot;memory_order&quot;&gt;획득 작업&lt;/a&gt; Y 와 동기화 됩니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="6aafba41a946d2b0a19753067d04e0ec8318ec66" translate="yes" xml:space="preserve">
          <source>A release fence FA in thread A synchronizes-with an acquire fence FB in thread B, if.</source>
          <target state="translated">스레드 A의 릴리스 펜스 FA는 스레드 B의 획득 펜스 FB와 동기화됩니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="00a2a5eb93eeb9be0332c1c8673603beb7ab0223" translate="yes" xml:space="preserve">
          <source>A safely-derived copy of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">안전하게 파생 된 &lt;code&gt;p&lt;/code&gt; 의 사본 .</target>
        </trans-unit>
        <trans-unit id="34d713d3ce9641e15f0083875fa82da7295cd6d0" translate="yes" xml:space="preserve">
          <source>A searcher suitable for use with the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that implements the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&quot;&gt;Boyer-Moore-Horspool string searching algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&quot;&gt;Boyer-Moore-Horspool 문자열 검색 알고리즘&lt;/a&gt; 을 구현하는 &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; 의 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;검색기&lt;/a&gt; 과부하 와 함께 사용하기에 적합한 검색기 입니다.</target>
        </trans-unit>
        <trans-unit id="a4aca9528474448c3c240ea5a50dac0f70fee741" translate="yes" xml:space="preserve">
          <source>A searcher suitable for use with the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that implements the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Boyer-Moore string searching algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Boyer-Moore 문자열 검색 알고리즘&lt;/a&gt; 을 구현하는 &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; 의 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;검색기&lt;/a&gt; 과부하 와 함께 사용하기에 적합한 검색기 입니다.</target>
        </trans-unit>
        <trans-unit id="7c73f721b6023bb7d94aabb383e7afe39aad3eff" translate="yes" xml:space="preserve">
          <source>A separate stored pointer is necessary to ensure that converting a &lt;code&gt;shared_ptr&lt;/code&gt; to &lt;code&gt;weak_ptr&lt;/code&gt; and then back works correctly, even for aliased &lt;code&gt;shared_ptr&lt;/code&gt;s. It is not possible to access the stored pointer in a &lt;code&gt;weak_ptr&lt;/code&gt; without locking it into a &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">앨리어싱 된 &lt;code&gt;shared_ptr&lt;/code&gt; 에 대해서도 &lt;code&gt;shared_ptr&lt;/code&gt; 을 &lt;code&gt;weak_ptr&lt;/code&gt; 로 변환 한 다음 다시 올바르게 작동하도록 하려면 별도의 저장된 포인터가 필요합니다 . &lt;code&gt;shared_ptr&lt;/code&gt; 에 잠그지 않고 &lt;code&gt;weak_ptr&lt;/code&gt; 에 저장된 포인터에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="25e507c2060a3cafdcda35e0bc4aa2552b49e574" translate="yes" xml:space="preserve">
          <source>A sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range &lt;code&gt;[F1, F2)&lt;/code&gt; otherwise</source>
          <target state="translated">반복자 범위에 의해 지정된 문자 시퀀스로 이루어진 조합 요소를 나타내는 일련의 문자 &lt;code&gt;[F1, F2)&lt;/code&gt; 그렇지</target>
        </trans-unit>
        <trans-unit id="3a4ef167623ed9faf9a94eff09dae4f596aaaa70" translate="yes" xml:space="preserve">
          <source>A simple declaration is a statement that introduces, creates, and optionally initializes one or several identifiers, typically variables.</source>
          <target state="translated">간단한 선언은 하나 이상의 식별자 (일반적으로 변수)를 도입, 생성 및 선택적으로 초기화하는 명령문입니다.</target>
        </trans-unit>
        <trans-unit id="555b8933650b3bb84b4b7b35f14e9c321630ac4d" translate="yes" xml:space="preserve">
          <source>A simple requirement is an arbitrary expression statement. It asserts that the expression is valid. The expression is an unevaluated operand; only language correctness is checked.</source>
          <target state="translated">간단한 요구 사항은 임의의 표현 문입니다. 표현식이 유효하다고 주장합니다. 표현식은 평가되지 않은 피연산자입니다. 언어 정확성 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="3a6977f0304e9c21ebecd390f1670f86c4119c3c" translate="yes" xml:space="preserve">
          <source>A simple-template-id that names a class template specialization names a class.</source>
          <target state="translated">클래스 템플릿 전문화의 이름을 지정하는 간단한 템플릿 ID로 클래스 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8fa198408b5d0cb7b3044995aa1b61b2fdf97bfa" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;link&quot;&gt;std::chrono::link&lt;/a&gt;&amp;gt;&lt;/code&gt; containing description of alternative names of time zones (links)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;link&quot;&gt;std::chrono::link&lt;/a&gt;&amp;gt;&lt;/code&gt; 시간대 (링크)의 대체 이름에 대한 설명이 포함 된 정렬 된 std :: vector &amp;lt; std :: chrono :: link &amp;gt;</target>
        </trans-unit>
        <trans-unit id="457d45e0af075f01765307d373a69c2a8d94815f" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;&amp;gt;&lt;/code&gt; containing description of time zones</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;&amp;gt;&lt;/code&gt; 시간대에 대한 설명이 포함 된 정렬 된 std :: vector &amp;lt; std :: chrono :: time_zone &amp;gt;</target>
        </trans-unit>
        <trans-unit id="967914ef26dbd68948b66b13d60e30b85ed85a3c" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;std::chrono::leaps&amp;gt;&lt;/code&gt; containing description of leap seconds</source>
          <target state="translated">윤초에 대한 설명이 포함 된 정렬 된 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;std::chrono::leaps&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eee524fe2ac982c4dd9f9a32a0c582f50eef3782" translate="yes" xml:space="preserve">
          <source>A span &lt;code&gt;r&lt;/code&gt; that is a view over the first &lt;code&gt;Count&lt;/code&gt; elements of &lt;code&gt;*this&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">스팬 &lt;code&gt;r&lt;/code&gt; 제 위에 도면 &lt;code&gt;Count&lt;/code&gt; 요소 &lt;code&gt;*this&lt;/code&gt; 같은 것을 &lt;code&gt;r.data() == this-&amp;gt;data() &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65c54f136c4760893800380e5b0c393d21d23647" translate="yes" xml:space="preserve">
          <source>A span &lt;code&gt;r&lt;/code&gt; that is a view over the last &lt;code&gt;Count&lt;/code&gt; elements of &lt;code&gt;*this&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() + (this-&amp;gt;size() - Count) &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r.data() == this-&amp;gt;data() + (this-&amp;gt;size() - Count) &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt; 와 같이 &lt;code&gt;*this&lt;/code&gt; 의 마지막 &lt;code&gt;Count&lt;/code&gt; 요소에 대한보기 인 범위 &lt;code&gt;r&lt;/code&gt; 카운트 .</target>
        </trans-unit>
        <trans-unit id="5074592fbba4772cb532096c90f531b3f380c17b" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 전문화</target>
        </trans-unit>
        <trans-unit id="9ee495551d56b04a23dc52fb815bb43b2e18e8c4" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;conjunction&lt;/code&gt; does not necessarily inherit from either &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;: it simply inherits from the first &lt;code&gt;B&lt;/code&gt; whose &lt;code&gt;::value&lt;/code&gt;, explicitly converted to bool, is false, or from the very last &lt;code&gt;B&lt;/code&gt; when all of them convert to true. For example, &lt;code&gt;std::conjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;conjunction&lt;/code&gt; 의 특수화가 반드시 &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; 에서 상속받지는 않습니다 . 단순히 명시 적으로 bool로 변환 된 &lt;code&gt;::value&lt;/code&gt; 가 false 인 첫 번째 &lt;code&gt;B&lt;/code&gt; 또는 false 일 때 마지막 &lt;code&gt;B&lt;/code&gt; 에서 상속 합니다. true로 변환하십시오. 예를 들어, &lt;code&gt;std::conjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; &lt;a href=&quot;integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; &amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; &amp;lt;int, 4 &amp;gt;&amp;gt; :: value 는 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f9e9b49b2bead30b9efc6f23cbdc32fd0fd8ce60" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;disjunction&lt;/code&gt; does not necessarily inherit from of either &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;: it simply inherits from the first &lt;code&gt;B&lt;/code&gt; whose &lt;code&gt;::value&lt;/code&gt;, explicitly converted to &lt;code&gt;bool&lt;/code&gt;, is true, or from the very last B when all of them convert to false. For example, &lt;code&gt;std::disjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;disjunction&lt;/code&gt; 의 특수화가 반드시 &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; 중 하나에서 상속 할 필요는 없습니다 . 단순히 명시 적으로 &lt;code&gt;bool&lt;/code&gt; 로 변환 된 &lt;code&gt;::value&lt;/code&gt; 가 true 인 첫 번째 &lt;code&gt;B&lt;/code&gt; 또는 상속 된 마지막 B에서 상속 합니다. 그것들은 거짓으로 변환됩니다. 예를 들어, &lt;code&gt;std::disjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; &lt;a href=&quot;integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; &amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; &amp;lt;int, 4 &amp;gt;&amp;gt; :: value 는 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9f9e5d495b1b862008c29e72aac873442799f4b0" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::greater&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::greater&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">내장 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 가 아닌 경우에도 포인터 유형 에 &lt;code&gt;std::greater&lt;/code&gt; 를 지정하면 엄격한 총 차수가 생성 됩니다. 엄격한 총 순서는 &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::greater&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , std :: less_equal 및 해당 포인터 유형에 대한 &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; 전문화간에 일관성이 있으며 해당 내장 연산자가 부과하는 부분 순서와도 일치합니다. ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d8a4b2d55428dedbd5dbf627f7b5d8550161022" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::greater_equal&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">내장 &lt;code&gt;operator&amp;gt;=&lt;/code&gt; 가 아닌 경우에도 모든 포인터 유형에 대해 &lt;code&gt;std::greater_equal&lt;/code&gt; 의 전문화는 엄격한 전체 순서를 생성합니다 . 엄격한 총 순서는 &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , std :: less_equal 및 해당 포인터 유형에 대한 &lt;code&gt;std::greater_equal&lt;/code&gt; 전문화간에 일관성이 있으며 해당 내장 연산자가 부과하는 부분 순서와도 일치합니다. ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="475b3cfac8883fd0a588f09dae13ae24eea6b2df" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::less&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;std::less&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">내장형 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 가 아닌 경우에도 모든 포인터 유형에 대해 &lt;code&gt;std::less&lt;/code&gt; 의 전문화는 엄격한 전체 순서를 생성합니다 . 엄격한 총 순서는 &lt;code&gt;std::less&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , std :: less_equal 및 해당 포인터 유형에 대한 &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; 전문화간에 일관성이 있으며 해당 내장 연산자가 부과하는 부분 순서와도 일치합니다. ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5040d1c9db6502c777c18889e5250a72b8267c2f" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::less_equal&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">내장 &lt;code&gt;operator&amp;lt;=&lt;/code&gt; 가 아닌 경우에도 모든 포인터 유형에 대해 &lt;code&gt;std::less_equal&lt;/code&gt; 의 전문화는 엄격한 전체 순서를 생성합니다 . 엄격한 총 순서는 &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&lt;/code&gt; , std :: less_equal 및 해당 포인터 유형에 대한 &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; 전문화간에 일관성이 있으며 해당 내장 연산자가 부과하는 부분 순서와도 일치합니다. ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="92e25a120740f5ad5adbba2aabed8d933eb3d5e4" translate="yes" xml:space="preserve">
          <source>A spinlock mutex can be implemented in userspace using an atomic exchange operation, similar to &lt;code&gt;&lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;std::atomic_flag_test_and_set&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">스핀 락 뮤텍스는 &lt;code&gt;&lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;std::atomic_flag_test_and_set&lt;/a&gt;&lt;/code&gt; 과 비슷한 원자 교환 작업을 사용하여 사용자 공간에서 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9515057fe6328dc05919c4cf02d9006061787a0c" translate="yes" xml:space="preserve">
          <source>A spinlock mutex can be implemented in userspace using an atomic_flag.</source>
          <target state="translated">spinlock 뮤텍스는 atomic_flag를 사용하여 사용자 공간에서 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="901d05a2e6ec5ffbcf6b01e787bf262ebced94a5" translate="yes" xml:space="preserve">
          <source>A standard conversion sequence consists of the following, in this order:</source>
          <target state="translated">표준 변환 순서는 다음 순서로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d4c338c0450a24104d97679430b5532160d82771" translate="yes" xml:space="preserve">
          <source>A static assert declaration may appear at namespace and block scope (as a &lt;a href=&quot;declarations&quot;&gt;block declaration&lt;/a&gt;) and inside a class body (as a &lt;a href=&quot;class&quot;&gt;member declaration&lt;/a&gt;).</source>
          <target state="translated">정적 어설 션 선언은 네임 스페이스 및 블록 범위 ( &lt;a href=&quot;declarations&quot;&gt;블록 선언으로&lt;/a&gt; )와 클래스 본문 내부 ( &lt;a href=&quot;class&quot;&gt;구성원 선언으로&lt;/a&gt; )에 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f33f270773f2dc3de0fd0352e32cf33418d9b8c0" translate="yes" xml:space="preserve">
          <source>A static data member may be declared &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;. An inline static data member can be defined in the class definition and may specify an initializer. It does not need an out-of-class definition:</source>
          <target state="translated">정적 데이터 멤버는 &lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt; 으로 선언 될 수 있습니다 . 인라인 정적 데이터 멤버는 클래스 정의에서 정의 할 수 있으며 초기화 프로그램을 지정할 수 있습니다. 클래스 외부 정의가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5da97780b140e6a47935295d4e1ee4870bfe1e89" translate="yes" xml:space="preserve">
          <source>A static member variable (but not a namespace-scope variable) declared &lt;code&gt;constexpr&lt;/code&gt; is implicitly an inline variable.</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; 로 선언 된 정적 멤버 변수 (네임 스페이스 범위 변수는 아님) 는 암시 적으로 인라인 변수입니다.</target>
        </trans-unit>
        <trans-unit id="4b6d0fdd7d7607c01a896d9094690fc14c51a0b3" translate="yes" xml:space="preserve">
          <source>A steady clock is used to measure the duration. This function may block for longer than &lt;code&gt;timeout_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">지속 시간은 지속 시간을 측정하는 데 사용됩니다. 이 기능은 스케줄링 또는 리소스 경합 지연으로 인해 &lt;code&gt;timeout_duration&lt;/code&gt; 보다 오래 차단 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78127daba885f04d8c232a3a0e396aee55e69e02" translate="yes" xml:space="preserve">
          <source>A store operation with this memory order performs the</source>
          <target state="translated">이 메모리 순서로 저장 조작은</target>
        </trans-unit>
        <trans-unit id="c6bc48899775e9a6c5f0a1a15785f5ee33b9cf7b" translate="yes" xml:space="preserve">
          <source>A string describing the given error condition.</source>
          <target state="translated">주어진 오류 조건을 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="46b19b69118bd315cdfc683d15a6fa75436b64bc" translate="yes" xml:space="preserve">
          <source>A string literal is not necessarily a C string: if a string literal has embedded null characters, it represents an array which contains more than one string.</source>
          <target state="translated">문자열 리터럴은 반드시 C 문자열 일 필요는 없습니다. 문자열 리터럴에 널 문자가 포함 된 경우 둘 이상의 문자열을 포함하는 배열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1550cc2a5436eb99f071dfa4dcf0dd47ccf4c825" translate="yes" xml:space="preserve">
          <source>A string view representing the entire contents of the string.</source>
          <target state="translated">문자열의 전체 내용을 나타내는 문자열보기</target>
        </trans-unit>
        <trans-unit id="32570ac03b4c2c47cffb2bbc021cc0ca86dcc629" translate="yes" xml:space="preserve">
          <source>A structured binding declaration first introduces a uniquely-named variable (here denoted by &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt;) to hold the value of the initializer, as follows:</source>
          <target state="translated">구조적 바인딩 선언은 먼저 다음과 같이 이니셜 라이저 값을 보유하기 위해 고유 한 이름의 변수 (여기서는 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; 로 표시됨 )를 도입 합니다.</target>
        </trans-unit>
        <trans-unit id="144f71d00798ee052aabd4ddb5c24678262a6ae1" translate="yes" xml:space="preserve">
          <source>A structured binding declaration introduces all identifiers in the identifier-list as names in the surrounding scope and binds them to subobjects or elements of the object denoted by expression. The bindings so introduced are called</source>
          <target state="translated">구조적 바인딩 선언은 식별자 목록의 모든 식별자를 주변 범위의 이름으로 소개하고 식으로 표시된 개체의 하위 개체 또는 요소에 바인딩합니다. 이렇게 소개 된 바인딩을</target>
        </trans-unit>
        <trans-unit id="835974f7bef28e4dff1c1ff405518b0bb98087eb" translate="yes" xml:space="preserve">
          <source>A structured binding declaration then performs the binding in one of three possible ways, depending on &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;:</source>
          <target state="translated">그런 다음 구조적 바인딩 선언은 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 에 따라 가능한 세 가지 방법 중 하나로 바인딩을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="5ebdd31b80b554a53c87eaf8af1247d0cf95b1cf" translate="yes" xml:space="preserve">
          <source>A subobject is</source>
          <target state="translated">하위 객체는</target>
        </trans-unit>
        <trans-unit id="7a0f0cf82fd7a9695235dbab61201c1151c693d9" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;operator()&lt;/code&gt; synchronizes with a call to any member function of a &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; that share their shared state with &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator()&lt;/code&gt; 호출이 성공 하면 &lt;code&gt;*this&lt;/code&gt; 와 공유 상태를 공유 하는 &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; 의 멤버 함수에 대한 호출과 동기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e5e13088bac64880bbd1d92f74dea1c546eae32" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;std::feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ungetc&lt;/code&gt; 를 성공적으로 호출하면 파일 상태 플래그 &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;std::feof&lt;/a&gt;&lt;/code&gt; 의 끝이 지워 집니다.</target>
        </trans-unit>
        <trans-unit id="2f18b9828e8cbe5f820c7f00f14018c93e63c261" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).</source>
          <target state="translated">이진 스트림 에서 &lt;code&gt;ungetc&lt;/code&gt; 를 성공적으로 호출 하면 스트림 위치 표시기가 1 씩 감소합니다 (스트림 위치 표시기가 0이면 동작이 결정되지 않음).</target>
        </trans-unit>
        <trans-unit id="ca4337b8d12737a6a022afbf7eb03368caa77b5b" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">텍스트 스트림 에서 &lt;code&gt;ungetc&lt;/code&gt; 를 성공적으로 호출 하면 스트림 위치 표시기가 지정되지 않은 방식으로 수정되지만 모든 푸시 백 문자가 읽기 조작으로 검색된 후 스트림 위치 표시기는 &lt;code&gt;ungetc&lt;/code&gt; 이전의 값과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a28d7859e6f4fcb6db1df05cff06566fff5a4e72" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; clears the end of file status flag &lt;code&gt;feof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ungetwc&lt;/code&gt; 를 성공적으로 호출하면 파일 상태 플래그 &lt;code&gt;feof&lt;/code&gt; 의 끝이 지워 집니다.</target>
        </trans-unit>
        <trans-unit id="96bde972d314cd8969488c09d04edcb68d3e8cec" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">스트림 (텍스트 또는 2 진) 에서 &lt;code&gt;ungetwc&lt;/code&gt; 를 성공적으로 호출 하면 스트림 위치 표시기가 지정되지 않은 방식으로 수정되지만 모든 푸시 백 와이드 문자가 읽기 조작으로 검색된 후 스트림 위치 표시기는 &lt;code&gt;ungetwc&lt;/code&gt; 이전의 값과 동일합니다. .</target>
        </trans-unit>
        <trans-unit id="4438ef6f7a0682bb256998449673a26881f7a072" translate="yes" xml:space="preserve">
          <source>A template argument for a template template parameter must be an &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; which names a class template or a template alias.</source>
          <target state="translated">템플리트 템플리트 매개 변수의 템플리트 인수 는 클래스 템플리트 또는 템플리트 별명을 명명 하는 &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0cbe97ed8a5079b18bed67f0b987c6e75304c3a6" translate="yes" xml:space="preserve">
          <source>A template argument for a type template parameter must be a &lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt;, which may name an incomplete type:</source>
          <target state="translated">형식 템플릿 매개 변수의 템플릿 인수는 &lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt; 이어야하며 , 불완전한 형식의 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b77575f13c55d5afb76807a44c03b42f3be5cca3" translate="yes" xml:space="preserve">
          <source>A template defined in the &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; header may be instantiated with an incomplete type unless otherwise specified, notwithstanding the general prohibition against instantiating standard library templates with incomplete types.</source>
          <target state="translated">&lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; 헤더에 정의 된 템플릿은 불완전한 유형의 표준 라이브러리 템플릿을 인스턴스화하는 것에 대한 일반적인 금지에도 불구하고 달리 명시되지 않는 한 불완전한 유형으로 인스턴스화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3db9cfde6b359f0a7eac7446ebfcb7cabe3498b5" translate="yes" xml:space="preserve">
          <source>A template friend declaration can name a member of a class template A, which can be either a member function or a member type (the type must use &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated-type-specifier&lt;/a&gt;). Such declaration is only well-formed if the last component in its nested-name-specifier (the name to the left of the last &lt;code&gt;::&lt;/code&gt;) is a simple-template-id (template name followed by argument list in angle brackets) that names the class template. The template parameters of such template friend declaration must be deducible from the simple-template-id.</source>
          <target state="translated">템플릿 친구 선언은 클래스 템플릿 A의 멤버 이름을 지정할 수 있습니다. 클래스 멤버 A는 멤버 함수 또는 멤버 유형일 수 있습니다 (유형은 &lt;a href=&quot;elaborated_type_specifier&quot;&gt;정교한 유형 지정자를&lt;/a&gt; 사용해야 합니다 ). 이러한 선언은 nested-name-specifier (마지막 &lt;code&gt;::&lt;/code&gt; 왼쪽의 이름)의 마지막 구성 요소가 이름 이 간단한 템플릿 템플릿 ID (템플릿 이름 뒤에 꺾쇠 괄호로 묶인 인수 목록 ) 인 경우에만 잘 구성 됩니다. 클래스 템플릿 이러한 템플릿 친구 선언의 템플릿 매개 변수는 simple-template-id에서 추론 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8cbfd05ed876a96f58d914b20aab64f29b86a74" translate="yes" xml:space="preserve">
          <source>A template is a C++ entity that defines one of the following:</source>
          <target state="translated">템플릿은 다음 중 하나를 정의하는 C ++ 엔터티입니다.</target>
        </trans-unit>
        <trans-unit id="59d81713cfdc4799ddf46175f8d61401bcd90683" translate="yes" xml:space="preserve">
          <source>A template parameter of the form &lt;code&gt;class Foo&lt;/code&gt; is not an unnamed non-type template parameter of type &lt;code&gt;Foo&lt;/code&gt;, even if otherwise &lt;code&gt;class Foo&lt;/code&gt; is an &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; and &lt;code&gt;class Foo x;&lt;/code&gt; declares &lt;code&gt;x&lt;/code&gt; to be of type &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">폼의 템플릿 파라미터 &lt;code&gt;class Foo&lt;/code&gt; 유형의 이름 비 형 템플릿 파라미터가 아니다 &lt;code&gt;Foo&lt;/code&gt; 그렇지 않더라도 &lt;code&gt;class Foo&lt;/code&gt; 이다 &lt;a href=&quot;elaborated_type_specifier&quot;&gt;정교한 형태 지정자&lt;/a&gt; 및 &lt;code&gt;class Foo x;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;Foo&lt;/code&gt; 유형으로 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="d85241f2bc54602e57c2582a6ecab6b9f660f5f6" translate="yes" xml:space="preserve">
          <source>A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A function parameter pack is a function parameter that accepts zero or more function arguments.</source>
          <target state="translated">템플릿 매개 변수 팩은 0 개 이상의 템플릿 인수 (비 유형, 유형 또는 템플릿)를 허용하는 템플릿 매개 변수입니다. 함수 매개 변수 팩은 0 개 이상의 함수 인수를 허용하는 함수 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="eb2fa05aae2cb5737143f68053260c6a62f41e74" translate="yes" xml:space="preserve">
          <source>A template parameter pack that is explicitly specified may be extended by template argument deduction if there are additional arguments:</source>
          <target state="translated">추가 인수가있는 경우 명시 적으로 지정된 템플리트 매개 변수 팩은 템플리트 인수 공제에 의해 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f41dfabc2328a29181220b5113304c48aad61703" translate="yes" xml:space="preserve">
          <source>A template specialization that was declared but not defined can be used just like any other &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt; (e.g. pointers and references to it may be used).</source>
          <target state="translated">선언되었지만 정의되지 않은 템플릿 전문화는 다른 &lt;a href=&quot;incomplete_type&quot;&gt;불완전한 유형&lt;/a&gt; 과 마찬가지로 사용할 수 있습니다 (예 : 포인터 및 참조가 사용될 수 있음).</target>
        </trans-unit>
        <trans-unit id="344b2caa5e5fe345b5eddc1d5d915de3d6be2db2" translate="yes" xml:space="preserve">
          <source>A template with at least one parameter pack is called a</source>
          <target state="translated">하나 이상의 매개 변수 팩이있는 템플릿을</target>
        </trans-unit>
        <trans-unit id="673816c6497404faf247ef589f1b122b3a14f807" translate="yes" xml:space="preserve">
          <source>A template-id is only valid if.</source>
          <target state="translated">템플릿 ID는 다음과 같은 경우에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="10655830c19a77e3e63f7c59d226efb3c807b9e8" translate="yes" xml:space="preserve">
          <source>A template-id that names an alias template specialization names a type.</source>
          <target state="translated">별명 템플리트 전문화의 이름을 지정하는 템플리트 ID는 유형의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="df2b079308f3eca647407b9397b352dc670c7a81" translate="yes" xml:space="preserve">
          <source>A template-id that names an function template specialization names a function.</source>
          <target state="translated">함수 템플리트 전문화의 이름을 지정하는 템플리트 ID는 함수의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3c85feec0c63ebeca50f678f352ffcc3928d1b88" translate="yes" xml:space="preserve">
          <source>A templated entity (or, in some sources, &quot;temploid&quot;) is any entity that is defined (or, for a lambda-expression, created) within a template definition. All of the following are templated entities:</source>
          <target state="translated">템플릿 화 된 엔터티 (또는 일부 소스에서 &quot;템플릿&quot;)는 템플릿 정의 내에서 정의 된 (또는 람다 식의 경우) 엔터티입니다. 다음은 모두 템플릿 엔티티입니다.</target>
        </trans-unit>
        <trans-unit id="97a674e12e96df448607046bf1ea74819514e29d" translate="yes" xml:space="preserve">
          <source>A temporary object of type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; or &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 임시 오브젝트 는 &lt;a href=&quot;../language/value_initialization&quot;&gt;값 초기화&lt;/a&gt; 또는 &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;집계 초기화&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="33f18c53306de042e4c98fc4f2ec71d92fc7452f" translate="yes" xml:space="preserve">
          <source>A test for self-reset, i.e. whether &lt;code&gt;ptr&lt;/code&gt; points to an object already managed by &lt;code&gt;*this&lt;/code&gt;, is not performed, except where provided as a compiler extension or as a debugging assert. Note that code such as &lt;code&gt;p.reset(p.release())&lt;/code&gt; does not involve self-reset, only code like &lt;code&gt;p.reset(p.get())&lt;/code&gt; does.</source>
          <target state="translated">컴파일러 재설정 또는 디버깅 주장으로 제공된 경우를 제외하고 자체 재설정에 대한 테스트, 즉 &lt;code&gt;ptr&lt;/code&gt; &lt;code&gt;*this&lt;/code&gt; 이미 관리하는 객체를 가리키는 지 여부 는 수행되지 않습니다. &lt;code&gt;p.reset(p.release())&lt;/code&gt; 와 같은 코드 에는 자체 재설정이 포함되지 않으며 &lt;code&gt;p.reset(p.get())&lt;/code&gt; 과 같은 코드 만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="69a493f42c2d5d0a3d7b1e06a1285a10bdbe7061" translate="yes" xml:space="preserve">
          <source>A thread is said to</source>
          <target state="translated">실은</target>
        </trans-unit>
        <trans-unit id="ba9c13c0f9167e54bcbaf88e115f4167e83660c0" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;lock&lt;/code&gt; on a recursive mutex repeatedly. Ownership will only be released after the thread makes a matching number of calls to &lt;code&gt;unlock&lt;/code&gt;.</source>
          <target state="translated">스레드가 재귀 뮤텍스의 &lt;code&gt;lock&lt;/code&gt; 을 반복해서 호출 할 수 있습니다 . 스레드가 &lt;code&gt;unlock&lt;/code&gt; 을 해제 하기 위해 일치하는 횟수의 호출을 한 후에 만 ​​소유권이 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="7f432eae50bd789012a099dcf2a13f431564693f" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock&lt;/code&gt; increment the ownsership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스레드는 재귀 뮤텍스에서 &lt;code&gt;try_lock&lt;/code&gt; 을 반복적으로 호출 할 수 있습니다 . &lt;code&gt;try_lock&lt;/code&gt; 을 성공적으로 호출하면 소유권 수를 증가시킵니다. 스레드가 &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; 을 호출하기 위해 일치하는 횟수만큼 호출 한 후에 만 ​​뮤텍스가 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="37671f46b069e4bce5a6c704520d4965568d9f60" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock_for&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock_for&lt;/code&gt; increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스레드는 재귀 뮤텍스에서 &lt;code&gt;try_lock_for&lt;/code&gt; 를 반복적으로 호출 할 수 있습니다 . &lt;code&gt;try_lock_for&lt;/code&gt; 성공적으로 호출 하면 소유권 수가 증가합니다. 스레드가 &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; 을 호출하기 위해 일치하는 횟수만큼 호출 한 후에 만 ​​뮤텍스가 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="892016f3791df53a75393a4054de36f6670ede74" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock_until&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock_until&lt;/code&gt; increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스레드는 재귀 뮤텍스에서 &lt;code&gt;try_lock_until&lt;/code&gt; 을 반복해서 호출 할 수 있습니다 . &lt;code&gt;try_lock_until&lt;/code&gt; 을 성공적으로 호출 하면 소유권 수가 증가합니다. 스레드가 &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; 위해 일치하는 횟수의 호출을 수행 한 후에 만 ​​뮤텍스가 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="6b4560e93294ed5a9703378d1e170be75de3f418" translate="yes" xml:space="preserve">
          <source>A thread object does not have an associated thread (and is safe to destroy) after.</source>
          <target state="translated">스레드 객체는 이후에 연관된 스레드를 갖지 않으며 파괴하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="bac126fd4b2160e8de884ee506093cb6e1453d7a" translate="yes" xml:space="preserve">
          <source>A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by &lt;code&gt;&lt;a href=&quot;../thread/thread/thread&quot;&gt;std::thread::thread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt;, or other means.</source>
          <target state="translated">실행 스레드는 &lt;code&gt;&lt;a href=&quot;../thread/thread/thread&quot;&gt;std::thread::thread&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../thread/async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; 또는 다른 방법 으로 최상위 함수를 호출하는 것으로 시작하는 프로그램 내의 제어 흐름입니다 .</target>
        </trans-unit>
        <trans-unit id="13fb085a74dd9fd867bcbeeeed6c63aa5ff60cd7" translate="yes" xml:space="preserve">
          <source>A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable.</source>
          <target state="translated">코드 실행을 완료했지만 아직 결합되지 않은 스레드는 여전히 활성 실행 스레드로 간주되므로 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d83b1a24d6c356fdf4f8f81bf30022c94f556e0c" translate="yes" xml:space="preserve">
          <source>A time point is a duration of time that has passed since the epoch of a specific clock.</source>
          <target state="translated">시점은 특정 시계의 시대 이후로 지속 된 지속 시간입니다.</target>
        </trans-unit>
        <trans-unit id="842ecf6d69cdbeaddd28ab48c6e44b247497210b" translate="yes" xml:space="preserve">
          <source>A time point representing the current time.</source>
          <target state="translated">현재 시간을 나타내는 시점입니다.</target>
        </trans-unit>
        <trans-unit id="482e88b6e7ea3206c3e62b40431b9801a98e659f" translate="yes" xml:space="preserve">
          <source>A trailing template-argument can be left unspecified in an explicit instantiation of a function template specialization or of a member function template specialization if it can be &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced&lt;/a&gt; from the function parameter.</source>
          <target state="translated">함수 템플릿 전문 &lt;a href=&quot;template_argument_deduction&quot;&gt;화나&lt;/a&gt; 함수 매개 변수에서 추론 할 수있는 멤버 함수 템플릿 전문화의 명시 적 인스턴스화에서 후행 템플릿 인수를 지정하지 않은 채로 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1744e51348fac7204c6560fe5f680fd02436a4e6" translate="yes" xml:space="preserve">
          <source>A translation unit that includes a standard library header may not &lt;code&gt;#define&lt;/code&gt; or &lt;code&gt;#undef&lt;/code&gt; names declared in any standard library header.</source>
          <target state="translated">표준 라이브러리 헤더를 포함하는 번역 단위는 표준 라이브러리 헤더에 선언 된 &lt;code&gt;#define&lt;/code&gt; 또는 &lt;code&gt;#undef&lt;/code&gt; 이름을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e8a16a40cb320ca82f7aab312a29ceda1b14f739" translate="yes" xml:space="preserve">
          <source>A translation unit that uses any part of the standard library may not &lt;code&gt;#define&lt;/code&gt; or &lt;code&gt;#undef&lt;/code&gt; names lexically identical to:</source>
          <target state="translated">표준 라이브러리의 일부를 사용하는 번역 단위는 다음 과 어휘 적으로 &lt;code&gt;#define&lt;/code&gt; 또는 &lt;code&gt;#undef&lt;/code&gt; 이름을 동일하게 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d317f7a0ab3e788267489e0fc1532ddec6c12c38" translate="yes" xml:space="preserve">
          <source>A trivial copy assignment operator makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially copy-assignable.</source>
          <target state="translated">간단한 복사 할당 연산자는 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; 의한 것처럼 객체 표현의 복사본을 만듭니다 . C 언어 (POD 유형)와 호환되는 모든 데이터 유형은 간단하게 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd6abf8a66d91871c0f211e838354255f118cc43" translate="yes" xml:space="preserve">
          <source>A trivial copy constructor for a non-union class effectively copies every scalar subobject (including, recursively, subobject of subobjects and so forth) of the argument and performs no other action. However, padding bytes need not be copied, and even the object representations of the copied subobjects need not be the same as long as their values are identical.</source>
          <target state="translated">비 유니언 클래스의 간단한 복사 생성자는 인수의 모든 스칼라 하위 오브젝트 (하위 오브젝트의 하위 오브젝트 등을 포함하여)를 효과적으로 복사하고 다른 조치를 수행하지 않습니다. 그러나 패딩 바이트는 복사 할 필요가 없으며 복사 된 하위 객체의 객체 표현도 값이 동일한 한 동일 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="53f265b51a6ad6bc29b0d13aa314fdd06dcfce6a" translate="yes" xml:space="preserve">
          <source>A trivial default constructor is a constructor that performs no action. All data types compatible with the C language (POD types) are trivially default-constructible. Unlike &lt;a href=&quot;http://en.cppreference.com/w/c/language/object.html#Effective_type&quot;&gt;in C&lt;/a&gt;, however, objects with trivial default constructors cannot be created by simply reinterpreting suitably aligned storage, such as memory allocated with &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;: placement-new is required to formally &lt;a href=&quot;objects&quot;&gt;introduce a new object&lt;/a&gt; and avoid potential undefined behavior.</source>
          <target state="translated">간단한 기본 생성자는 동작을 수행하지 않는 생성자입니다. C 언어 (POD 유형)와 호환되는 모든 데이터 유형은 기본적으로 구성 가능합니다. 그러나 &lt;a href=&quot;http://en.cppreference.com/w/c/language/object.html#Effective_type&quot;&gt;C&lt;/a&gt; 와 달리 간단한 기본 생성자를 가진 객체는 &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; : location-new로 할당 된 메모리와 같이 적절히 정렬 된 스토리지를 단순히 재 해석하여 만들 수는 없습니다 &lt;a href=&quot;objects&quot;&gt;. 새로운 객체&lt;/a&gt; 를 공식적으로 도입하고 잠재적 인 정의되지 않은 동작을 피하려면 배치-새가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="033337ca5c4ad7c5b77be1ecaa5de6acda3c11c8" translate="yes" xml:space="preserve">
          <source>A trivial destructor is a destructor that performs no action. Objects with trivial destructors don't require a delete-expression and may be disposed of by simply deallocating their storage. All data types compatible with the C language (POD types) are trivially destructible.</source>
          <target state="translated">사소한 소멸자는 행동을 수행하지 않는 소멸자입니다. 사소한 소멸자를 가진 객체는 삭제 표현이 필요하지 않으며 단순히 스토리지 할당을 해제하여 폐기 할 수 있습니다. C 언어 (POD 유형)와 호환되는 모든 데이터 유형은 쉽게 파괴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d79042321968ff405b9eb41b02f03841f248eb8b" translate="yes" xml:space="preserve">
          <source>A trivial move assignment operator performs the same action as the trivial copy assignment operator, that is, makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially move-assignable.</source>
          <target state="translated">사소한 이동 할당 연산자는 사소한 복사 할당 연산자와 동일한 동작을 수행합니다. 즉, &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; 의한 것처럼 객체 표현의 복사본을 만듭니다 . C 언어 (POD 유형)와 호환되는 모든 데이터 유형은 쉽게 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ceb73134e634232cb9fed5b06967cd8af551fd6" translate="yes" xml:space="preserve">
          <source>A trivial move constructor is a constructor that performs the same action as the trivial copy constructor, that is, makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially movable.</source>
          <target state="translated">사소한 이동 생성자는 사소한 복사 생성자와 동일한 동작을 수행하는 생성자입니다. 즉, &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; 의한 것처럼 객체 표현의 복사본을 만듭니다 . C 언어 (POD 유형)와 호환되는 모든 데이터 유형은 쉽게 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4362f0ff877083bd05b03790df742e70f948b72d" translate="yes" xml:space="preserve">
          <source>A try-block is a &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;, and as such, can appear anywhere a statement can appear (that is, as one of the statements in a compound statement, including the function body compound statement). See &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; for the try blocks around function bodies. The following description applies to both try-blocks and &lt;a href=&quot;function-try-block&quot;&gt;function-try-blocks&lt;/a&gt;.</source>
          <target state="translated">try-block은 &lt;a href=&quot;statements&quot;&gt;명령문&lt;/a&gt; 이므로 명령문 이 나타날 수있는 모든 위치 (즉, 함수 본문 복합 명령문을 포함한 복합 명령문의 명령문 중 하나)로 나타날 수 있습니다. 함수 본문 주위의 try 블록에 대해서는 &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; 을 참조하십시오 . 다음 설명은 try-blocks 및 &lt;a href=&quot;function-try-block&quot;&gt;function-try-blocks&lt;/a&gt; 모두에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="19834a31076ba08c517eaff630de5e748d366c53" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;E&lt;/code&gt; satisfying &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; will additionally satisfy RandomNumberEngine if, given.</source>
          <target state="translated">&lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; 를 만족 하는 유형 &lt;code&gt;E&lt;/code&gt; 는 주어진 경우 RandomNumberEngine 을 추가로 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="ca6cf0688a958e8a7bf6dc59cfc4cfb1df147a82" translate="yes" xml:space="preserve">
          <source>A type T is ValueSwappable if.</source>
          <target state="translated">유형 T는 ValueSwappable if입니다.</target>
        </trans-unit>
        <trans-unit id="a7bc09bb961fc3d44a04b48c1111a1a318bd62fe" translate="yes" xml:space="preserve">
          <source>A type has</source>
          <target state="translated">유형은</target>
        </trans-unit>
        <trans-unit id="1816dc600e8b7d025987ab256efe8b9a53ee4eb9" translate="yes" xml:space="preserve">
          <source>A type requirement is the keyword &lt;code&gt;typename&lt;/code&gt; followed by a type name, optionally qualified. The requirement is that the named type is valid: this can be used to verify that a certain named nested type exists, or that a class template specialization names a type, or that an alias template specialization names a type. A type requirement naming a class template specialization does not require the type to be complete.</source>
          <target state="translated">유형 요구 사항은 키워드 &lt;code&gt;typename&lt;/code&gt; 다음에 선택적으로 규정 된 유형 이름 이옵니다 . 명명 된 유형이 유효해야합니다. 이는 명명 된 특정 중첩 유형이 존재하는지 또는 클래스 템플리트 전문화가 유형의 이름을 지정하거나 별명 템플리트 전문화가 유형의 이름을 지정하는 데 사용될 수 있습니다. 클래스 템플릿 전문화를 명명하는 유형 요구 사항은 유형을 완료 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="15ef01c2ad4973128037ff3072f4151a78c62933" translate="yes" xml:space="preserve">
          <source>A type that can hold all valid values of &lt;code&gt;X::char_type&lt;/code&gt; plus &lt;code&gt;X::eof()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X::char_type&lt;/code&gt; 과 &lt;code&gt;X::eof()&lt;/code&gt; 의 모든 유효한 값을 보유 할 수있는 유형</target>
        </trans-unit>
        <trans-unit id="03ac68cf57c6c426934400170b4271e37c362fbe" translate="yes" xml:space="preserve">
          <source>A typical cause of failure for &lt;code&gt;std::puts&lt;/code&gt; is running out of space on the file system, when &lt;code&gt;stdout&lt;/code&gt; is redirected to a file.</source>
          <target state="translated">&lt;code&gt;std::puts&lt;/code&gt; 의 일반적인 실패 원인은 &lt;code&gt;stdout&lt;/code&gt; 이 파일로 경로 재 지정 될 때 파일 시스템의 공간이 부족한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ae95c3cb82eea0b19d5fa37c3903de19a5db5a6a" translate="yes" xml:space="preserve">
          <source>A typical example of such situation is the naive implementation of &lt;code&gt;&lt;a href=&quot;../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; (derived from the empty base &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt;), which holds the underlying iterator (also derived from &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt;) as its first non-static data member.</source>
          <target state="translated">이러한 상황의 전형적인 예는 &lt;code&gt;&lt;a href=&quot;../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; (빈 기본 &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt; 에서 파생 됨 )의 순진한 구현입니다 . 이는 기본 이터레이터 ( &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt; 에서 파생 됨 )를 첫 번째 비 정적 데이터 멤버로 보유합니다.</target>
        </trans-unit>
        <trans-unit id="0734374c55a399a52d1410a4e6f7c1c0d057f16d" translate="yes" xml:space="preserve">
          <source>A typical generator's yield_value would store (copy/move or just store the address of, since the argument's lifetime crosses the suspension point inside the co_await) its argument into the generator object and return &lt;code&gt;std::suspend_always&lt;/code&gt;, transferring control to the caller/resumer.</source>
          <target state="translated">일반적인 생성자의 yield_value는 인수의 수명이 co_await 내부의 중단 점을 넘어 가기 때문에 인수를 저장 (복사 / 이동 또는 주소 만 저장)합니다. 인수를 생성자 객체에 반환하고 &lt;code&gt;std::suspend_always&lt;/code&gt; 반환 하여 제어를 호출자 / 재개 자에게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="51f160ce423fd83704df3a5cb0174dbe3220c314" translate="yes" xml:space="preserve">
          <source>A typical implementation holds one integer data member (the value) and a pointer to an &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적인 구현에는 하나의 정수 데이터 멤버 (값)와 &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 대한 포인터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aa218a5c2f20a77c0b0ce98af0029f85ebd7ae1" translate="yes" xml:space="preserve">
          <source>A typical implementation holds only two members: a pointer to &lt;code&gt;T&lt;/code&gt; and a size.</source>
          <target state="translated">일반적인 구현에는 &lt;code&gt;T&lt;/code&gt; 에 대한 포인터 와 크기의 두 멤버 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1049a0bd6d2b817dcdf4dbacf6924d39c59809b" translate="yes" xml:space="preserve">
          <source>A typical implementation holds only two members: a pointer to constant &lt;code&gt;CharT&lt;/code&gt; and a size.</source>
          <target state="translated">일반적인 구현에는 상수 &lt;code&gt;CharT&lt;/code&gt; 에 대한 포인터 와 크기의 두 멤버 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c4f9d8e2fe4e7c12c1285e532e5570e4bb48e5d" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_fstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_fstream&lt;/code&gt; 의 일반적인 구현에는 파생되지 않은 데이터 멤버가 하나만 있습니다. &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="b8130838cccfdb668dc1da70d0ff806b7225abc0" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_ifstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_ifstream&lt;/code&gt; 의 일반적인 구현에는 파생되지 않은 데이터 멤버가 하나만 있습니다. &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="7183d62923a8e947e2f0e103df21cd2904d87891" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_ofstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_ofstream&lt;/code&gt; 의 일반적인 구현에는 파생되지 않은 데이터 멤버가 하나만 있습니다. &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="217f99906b2120be1fba7713f69e991a00815576" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::istream_iterator&lt;/code&gt; holds two data members: a pointer to the associated &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; object and the most recently read value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::istream_iterator&lt;/code&gt; 의 일반적인 구현 에는 두 개의 데이터 멤버가 있습니다. 연관된 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 객체에 대한 포인터 와 가장 최근에 읽은 &lt;code&gt;T&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="ad3a71fd17c76f0ee62dee1d66ae5633a375fd68" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::regex_iterator&lt;/code&gt; holds the begin and the end iterators for the underlying sequence (two instances of BidirIt), a pointer to the regular expression (&lt;code&gt;const regex_type*&lt;/code&gt;), the match flags (&lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::match_flag_type&lt;/a&gt;&lt;/code&gt;), and the current match (&lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&amp;lt;BidirIt&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::regex_iterator&lt;/code&gt; 의 일반적인 구현 에는 기본 시퀀스 (BidirIt의 두 인스턴스), 정규 표현식에 대한 포인터 ( &lt;code&gt;const regex_type*&lt;/code&gt; ), 일치 플래그 ( &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::match_flag_type&lt;/a&gt;&lt;/code&gt; ) 의 시작 및 종료 반복자가 있습니다. , 현재 일치 ( &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&amp;lt;BidirIt&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5594f6466e9c627a309f191d1d21416131d6dcaa" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::regex_token_iterator&lt;/code&gt; holds the underlying &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt;, a container (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;) of the requested submatch indexes, the internal counter equal to the index of the submatch, a pointer to &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;, pointing at the current submatch of the current match, and a &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; object containing the last non-matched character sequence (used in tokenizer mode).</source>
          <target state="translated">의 전형적인 구현 &lt;code&gt;std::regex_token_iterator&lt;/code&gt; 기본 보유 &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; 컨테이너 (예 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; ) 요청 submatch 색인의 내부 카운터가 submatch, 포인터 인덱스와 동일 &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; , 현재 일치하는 현재 하위 일치 및 마지막 일치하지 않는 문자 시퀀스를 포함 하는 &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; 객체 (토큰 라이저 모드에서 사용).</target>
        </trans-unit>
        <trans-unit id="ec993624f290f31f38642161da480cca7738a5b4" translate="yes" xml:space="preserve">
          <source>A uniform random bit generator is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.</source>
          <target state="translated">균일 한 랜덤 비트 생성기는 가능한 결과 범위의 각 값이 (이상적으로) 동일한 확률을 갖도록 부호없는 정수 값을 반환하는 함수 객체입니다.</target>
        </trans-unit>
        <trans-unit id="5b1045e71b04fce292271774a5a72bec6686a37d" translate="yes" xml:space="preserve">
          <source>A union can have member functions (including constructors and destructors), but not virtual functions.</source>
          <target state="translated">공용체는 멤버 함수 (생성자 및 소멸자를 포함)를 가질 수 있지만 가상 함수는 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2abfe76729a7513736cb7faa5d5ce5576166784" translate="yes" xml:space="preserve">
          <source>A union cannot have base classes and cannot be used as a base class.</source>
          <target state="translated">공용체는 기본 클래스를 가질 수 없으며 기본 클래스로 사용될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d044e7ff18d6370026b7cb48f5515536c724fbdc" translate="yes" xml:space="preserve">
          <source>A union cannot have non-static data members of reference types.</source>
          <target state="translated">공용체는 비 정적 데이터 유형의 참조 유형을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c914c20794cb64933a85898ab023cc57498cff6" translate="yes" xml:space="preserve">
          <source>A union is a special class type that can hold only one of its non-static &lt;a href=&quot;data_members&quot;&gt;data members&lt;/a&gt; at a time.</source>
          <target state="translated">공용체는 한 번에 비 정적 &lt;a href=&quot;data_members&quot;&gt;데이터 멤버&lt;/a&gt; 중 하나만 보유 할 수있는 특수 클래스 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="b72fa34edde9b7a760e2ca9a63cea91e1b555145" translate="yes" xml:space="preserve">
          <source>A universal character name in a narrow string literal or a 16-bit string literal may map to more than one character, e.g. &lt;code&gt;\U0001f34c&lt;/code&gt; is 4 &lt;code&gt;char&lt;/code&gt; code units in UTF-8 (&lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt;) and 2 &lt;code&gt;char16_t&lt;/code&gt; code units in UTF-16 (&lt;code&gt;\uD83C\uDF4C&lt;/code&gt;).</source>
          <target state="translated">좁은 문자열 리터럴 또는 16 비트 문자열 리터럴의 범용 문자 이름은 둘 이상의 문자에 맵핑 될 수 있습니다. 예를 들어 &lt;code&gt;\U0001f34c&lt;/code&gt; 는 UTF-8 ( &lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt; ) 및 2 개의 &lt;code&gt;char16_t&lt;/code&gt; 코드 에서 4 개의 &lt;code&gt;char&lt;/code&gt; 코드 단위입니다. UTF-16 단위 ( &lt;code&gt;\uD83C\uDF4C&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="416c36a6fa82a246cd095bd156c7aaf5425291a8" translate="yes" xml:space="preserve">
          <source>A useful guideline is that the destructor of any base class must be &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual&quot;&gt;public and virtual or protected and non-virtual&lt;/a&gt;.</source>
          <target state="translated">유용한 지침은 모든 기본 클래스의 소멸자가 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual&quot;&gt;공개 및 가상이거나 보호되고 비 가상적&lt;/a&gt; 이어야한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="83e4b1da3b5d3236546ebba09aeb934da81e6f4f" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt; can be a template.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;cast_operator&quot;&gt;변환 함수&lt;/a&gt; 는 템플릿 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d638bfd657359641307f2e7271f6931cb2015b9" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;code&gt;std::unexpected_handler&lt;/code&gt; is expected to either terminate the program or throw an exception. If it throws an exception, one of the following three situations may be encountered:</source>
          <target state="translated">사용자 정의 &lt;code&gt;std::unexpected_handler&lt;/code&gt; 는 프로그램을 종료하거나 예외를 발생시킬 것으로 예상됩니다. 예외가 발생하면 다음 세 가지 상황 중 하나가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73f25ff036d8280e869a001e21e48bbeb542c334" translate="yes" xml:space="preserve">
          <source>A user-defined conversion consists of zero or one non-explicit single-argument constructor or non-explicit &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt; call.</source>
          <target state="translated">사용자 정의 변환은 0 개 또는 1 개의 비명 시적 단일 인수 생성자 또는 비명 시적 &lt;a href=&quot;cast_operator&quot;&gt;변환 함수&lt;/a&gt; 호출로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d0e1aabd13d35e1072413a4e56940753290b1935" translate="yes" xml:space="preserve">
          <source>A user-defined conversion function template cannot have a deduced return type.</source>
          <target state="translated">사용자 정의 변환 함수 템플릿은 추론 된 반환 유형을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e6c06935ba93da6b0506db32bcdb2cfcdba4051" translate="yes" xml:space="preserve">
          <source>A user-defined literal is an expression of any of the following forms.</source>
          <target state="translated">사용자 정의 리터럴은 다음 형식 중 하나의 표현입니다.</target>
        </trans-unit>
        <trans-unit id="3054b1de584f16f3593abd57817b8a39cfd5c191" translate="yes" xml:space="preserve">
          <source>A user-provided &lt;code&gt;Compare&lt;/code&gt; can be supplied to change the ordering, e.g. using &lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt; would cause the smallest element to appear as the &lt;code&gt;&lt;a href=&quot;priority_queue/top&quot;&gt;top()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하면 가장 작은 요소가 &lt;code&gt;&lt;a href=&quot;priority_queue/top&quot;&gt;top()&lt;/a&gt;&lt;/code&gt; 으로 표시되는 순서를 변경하기 위해 사용자 제공 &lt;code&gt;Compare&lt;/code&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="640dc08af4538f2be62eb03eb3dd195df49a90d2" translate="yes" xml:space="preserve">
          <source>A using-declaration also can't be used to introduce the name of a dependent member template as a</source>
          <target state="translated">또한 사용 선언은 종속 멤버 템플릿의 이름을 다음과 같이 소개하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4bae902040c5ab2ebd693033e3fed94dda49e2af" translate="yes" xml:space="preserve">
          <source>A using-declaration cannot name a member template specialization (&lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; is not permitted by the grammar):</source>
          <target state="translated">사용 선언은 멤버 템플리트 전문화의 이름을 지정할 수 없습니다 ( 문법에서는 &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; 를 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="ef90b2e3eff9b374774e4a806f69699ec8e2d794" translate="yes" xml:space="preserve">
          <source>A using-declaration cannot refer to a namespace, to a scoped enumerator, to a destructor of a base class or to a specialization of a member template for a user-defined conversion function.</source>
          <target state="translated">using-declaration은 네임 스페이스, 범위 지정된 열거 자, 기본 클래스의 소멸자 또는 사용자 정의 변환 함수를위한 멤버 템플릿의 전문화를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b03fbcaa0bf1071b311fbaae0c5ce6b26d0a8ede" translate="yes" xml:space="preserve">
          <source>A using-declaration with more than one using-declarator is equivalent to a corresponding sequence of using-declarations with one using-declarator.</source>
          <target state="translated">둘 이상의 사용 선언자가있는 사용 선언은 하나의 사용 선언이있는 해당 사용 선언 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="20d0f9a0bea74c92ad5ff18da1b24cd553bbba2b" translate="yes" xml:space="preserve">
          <source>A valarray with the same size as the parameter.</source>
          <target state="translated">매개 변수와 동일한 크기의 valarray</target>
        </trans-unit>
        <trans-unit id="9b0aa598587fc3cc855c9c9ccc2c85d04dd3b0d5" translate="yes" xml:space="preserve">
          <source>A valid const iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">에 유효한 CONST 반복자 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14a30aab0776a047f20feb27371310d867438a4f" translate="yes" xml:space="preserve">
          <source>A valid dereferenceable const iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">에 유효한 dereferenceable CONST 반복자 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c5ba5e3ccd5588e225779b9a36ab64c069c240a" translate="yes" xml:space="preserve">
          <source>A valid dereferenceable iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">에 유효한 dereferenceable 반복자 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28223fe6cd5ada49f5862218ac60de143b2567db" translate="yes" xml:space="preserve">
          <source>A value equal to 0 if the path is lexicographically equal to the given path.</source>
          <target state="translated">경로가 사 전적으로 지정된 경로와 동일한 경우 0과 같은 값입니다.</target>
        </trans-unit>
        <trans-unit id="a50061555eec54932403da5e038843403742ee9c" translate="yes" xml:space="preserve">
          <source>A value equivalent to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 와 동등한 값 .</target>
        </trans-unit>
        <trans-unit id="de1ab572a1a705bc1af0966dac1fe26f7ab37241" translate="yes" xml:space="preserve">
          <source>A value greater than 0 if the path is lexicographically greater than the given path.</source>
          <target state="translated">경로가 사전 순으로 지정된 경로보다 큰 경우 0보다 큰 값입니다.</target>
        </trans-unit>
        <trans-unit id="59605f92ecf81d222cf73bc53f88e408d0be42bc" translate="yes" xml:space="preserve">
          <source>A value less than 0 if the path is lexicographically less than the given path.</source>
          <target state="translated">경로가 사전 순으로 지정된 경로보다 작은 경우 0보다 작은 값입니다.</target>
        </trans-unit>
        <trans-unit id="772e15e1bdd5eccbbc37f434f301068fa5b598a7" translate="yes" xml:space="preserve">
          <source>A value less than zero if this sub_match is</source>
          <target state="translated">이 sub_match가 0이면 0보다 작은 값</target>
        </trans-unit>
        <trans-unit id="32241575a78d789ffd0a6260e7ef09d51214c2a4" translate="yes" xml:space="preserve">
          <source>A value not equivalent to any valid value of type &lt;code&gt;char_type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char_type&lt;/code&gt; 유형의 유효한 값과 같지 않은 값입니다 .</target>
        </trans-unit>
        <trans-unit id="6b19e1b2f4ff9e9aafad05b04d18d7cec329645b" translate="yes" xml:space="preserve">
          <source>A value of a floating-point type can also be converted to any complete enumeration type.</source>
          <target state="translated">부동 소수점 유형의 값은 완전한 열거 유형으로 변환 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a22bbd341be0d94948a8da39b757c96e4a822a" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;future&quot;&lt;/code&gt;.</source>
          <target state="translated">오류 카테고리 &lt;code&gt;&quot;future&quot;&lt;/code&gt; 와 연관된 &lt;code&gt;e&lt;/code&gt; 의 오류 코드 번호를 보유하는 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="8d689f1f7f9107c84de7e9e6a91164c4d8d448b7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;iostream&quot;&lt;/code&gt;.</source>
          <target state="translated">오류 범주 &lt;code&gt;&quot;iostream&quot;&lt;/code&gt; 과 연관된 &lt;code&gt;e&lt;/code&gt; 의 오류 코드 번호를 보유하는 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="d85edc98c1d148807f1167309444da367dce2885" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;future&quot;&lt;/code&gt;.</source>
          <target state="translated">오류 범주 &lt;code&gt;&quot;future&quot;&lt;/code&gt; 와 연관된 &lt;code&gt;e&lt;/code&gt; 의 오류 코드 번호를 보유하는 &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="db29599a3ec1300b12f7cddbf4961efd2a438f2c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;iostream&quot;&lt;/code&gt;.</source>
          <target state="translated">오류 범주 &lt;code&gt;&quot;iostream&quot;&lt;/code&gt; 과 연관된 &lt;code&gt;e&lt;/code&gt; 의 오류 코드 번호를 보유하는 &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="d4716864d7aecb12710c82c5051f8f56cfc5d9f6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::result&lt;/a&gt;&lt;/code&gt;, indicating the success status as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::result&lt;/a&gt;&lt;/code&gt; 유형의 값 으로 다음과 같이 성공 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="32fad6cd0042895426d631ee6330654d50fdd26f" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; identifying the thread associated with &lt;code&gt;*this&lt;/code&gt;. If there is no thread associated, default constructed &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 와 연관된 스레드를 식별하는 &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; 유형의 값입니다 . 연결된 스레드가 없으면 기본 생성 된 &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4007ab79efb7d58184f823559bcab8f2c0fe4508" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;X::key_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X::key_type&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="072712158f85df6191a61fbd61f9b1af57edb2a6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X::value_type&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="c9fa2a7989928288a59b9d1061cab281384dc7d7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;dateorder&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dateorder&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="e52779b1e6c9706944a08739b4d2e94ab73e1ebe" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::chrono::system_clock::time_point&lt;/code&gt; representing &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 를 나타내는 &lt;code&gt;std::chrono::system_clock::time_point&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="372178480f2f29b6cd4a1502b1b12fa8b61b4a68" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::partial_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">위에서 설명한 &lt;code&gt;std::partial_ordering&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="f50da534940de9fa538b0344ec2f07e991732fc7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::strong_equality&lt;/code&gt;, as described above.</source>
          <target state="translated">위에서 설명한 &lt;code&gt;std::strong_equality&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="1240d3098b2313d3e38b4e6524a3981c2caf173b" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::strong_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">위에서 설명한 &lt;code&gt;std::strong_ordering&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="d920da1ed499cf59fb8f2ff084478f87888ebedf" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::weak_equality&lt;/code&gt;, as described above.</source>
          <target state="translated">위에서 설명한 &lt;code&gt;std::weak_equality&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="84362b6647406e2ba1f03eb0961d6929e28947bb" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::weak_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">위에서 설명한 &lt;code&gt;std::weak_ordering&lt;/code&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="d92cb041f91a75157fbd95d555f69774c1ab1976" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;void (*)(int)&lt;/code&gt;. When returned by &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt;, indicates that an error has occurred.</source>
          <target state="translated">&lt;code&gt;void (*)(int)&lt;/code&gt; 유형의 값입니다 . &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; 이 리턴 하면 오류가 발생했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="03d7158f8947427f81b002e1dd1993eed28a9ff7" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;!c(ku, r)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;!c(ku, r)&lt;/code&gt; 대해 &lt;code&gt;a&lt;/code&gt; 가 분할 되는 값</target>
        </trans-unit>
        <trans-unit id="450945ae5d73489824ccfb0cd773638c26cd3654" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;c(r, ke)&lt;/code&gt; and &lt;code&gt;!c(ke, r)&lt;/code&gt;, with &lt;code&gt;c(r, ke)&lt;/code&gt; implying &lt;code&gt;!c(ke, r)&lt;/code&gt;</source>
          <target state="translated">되도록 값 &lt;code&gt;a&lt;/code&gt; 에 대하여 분할 &lt;code&gt;c(r, ke)&lt;/code&gt; 와 &lt;code&gt;!c(ke, r)&lt;/code&gt; 와 &lt;code&gt;c(r, ke)&lt;/code&gt; 의미 &lt;code&gt;!c(ke, r)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66162c2a5d40aef1c22e1f7994ce56c76783a955" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;c(r,kl)&lt;/code&gt;, with &lt;code&gt;r&lt;/code&gt; the key value of &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">되도록 값 &lt;code&gt;a&lt;/code&gt; 에 대하여 분할 &lt;code&gt;c(r,kl)&lt;/code&gt; 과, &lt;code&gt;r&lt;/code&gt; 의 키 값 &lt;code&gt;e&lt;/code&gt; 및 &lt;code&gt;e&lt;/code&gt; 에 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0a71e388e98e2de2ca1e6729afcd2caf02f4c95" translate="yes" xml:space="preserve">
          <source>A value that is identical for all &lt;code&gt;type_info&lt;/code&gt; objects referring to the same type.</source>
          <target state="translated">동일한 유형을 참조하는 모든 &lt;code&gt;type_info&lt;/code&gt; 객체에 대해 동일한 값입니다 .</target>
        </trans-unit>
        <trans-unit id="79bfc8c0189d75c8cec44ecc8d6396e58c45af93" translate="yes" xml:space="preserve">
          <source>A variable template declaration may appear at class scope, in which case it declares a static data member template. See &lt;a href=&quot;variable_template&quot;&gt;variable templates&lt;/a&gt; for details.</source>
          <target state="translated">변수 템플릿 선언은 클래스 범위에 나타날 수 있으며이 경우 정적 데이터 멤버 템플릿을 선언합니다. 자세한 내용은 &lt;a href=&quot;variable_template&quot;&gt;변수 템플릿&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a00357cf9d6e102b6c1e5ad12063c42c54ad2ce7" translate="yes" xml:space="preserve">
          <source>A variable template defines a family of variables or static data members.</source>
          <target state="translated">변수 템플릿은 변수 계열 또는 정적 데이터 멤버를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="aff896d1642161992d5991ac4ba8de8003708a52" translate="yes" xml:space="preserve">
          <source>A variable template may be introduced by a template declaration at namespace scope, where declaration declares a variable.</source>
          <target state="translated">네임 스페이스 범위에서 템플릿 선언으로 변수 템플릿을 도입 할 수 있습니다. 여기서 선언은 변수를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="09fc623a5cbacf9a90a9e712a74ec555cda701fd" translate="yes" xml:space="preserve">
          <source>A variadic class template can be instantiated with any number of template arguments:</source>
          <target state="translated">variadic 클래스 템플릿은 여러 템플릿 인수로 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb3820743def9d88fa6123aad6fc9bce3f38a75" translate="yes" xml:space="preserve">
          <source>A variadic function template can be called with any number of function arguments (the template arguments are deduced through &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;):</source>
          <target state="translated">다양한 함수 인수를 사용하여 가변 함수 템플릿을 호출 할 수 있습니다 (템플릿 인수는 &lt;a href=&quot;template_argument_deduction&quot;&gt;템플릿 인수 deduction을&lt;/a&gt; 통해 추론 됨 ).</target>
        </trans-unit>
        <trans-unit id="bb6e304c2616213d182d17fab4792e56d3349945" translate="yes" xml:space="preserve">
          <source>A variant is not permitted to hold references, arrays, or the type &lt;code&gt;void&lt;/code&gt;. Empty variants are also ill-formed (&lt;code&gt;std::variant&amp;lt;&lt;a href=&quot;variant/monostate&quot;&gt;std::monostate&lt;/a&gt;&amp;gt;&lt;/code&gt; can be used instead).</source>
          <target state="translated">변형은 참조, 배열 또는 유형 &lt;code&gt;void&lt;/code&gt; 를 보유 할 수 없습니다 . 빈 변형도 잘못 구성되어 있습니다 ( &lt;code&gt;std::variant&amp;lt;&lt;a href=&quot;variant/monostate&quot;&gt;std::monostate&lt;/a&gt;&amp;gt;&lt;/code&gt; 대신 사용 가능).</target>
        </trans-unit>
        <trans-unit id="ce4af0ae9360b0d87edd912329cc74243aa60def" translate="yes" xml:space="preserve">
          <source>A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type.</source>
          <target state="translated">변형은 동일한 유형을 두 번 이상 보유하고 동일한 유형의 cv-qualified 버전을 다르게 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea9112a4205a8e149b6d870c2538c2387fcc45a2" translate="yes" xml:space="preserve">
          <source>A variant may become valueless in the following situations:</source>
          <target state="translated">다음 상황에서는 변형이 무의미해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="360ab0f56da776d903fad4cd3c7802b6cff86bff" translate="yes" xml:space="preserve">
          <source>A variant that is valueless by exception is treated as being in an invalid state: &lt;a href=&quot;index&quot;&gt;index&lt;/a&gt; returns &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;, &lt;a href=&quot;get&quot;&gt;get&lt;/a&gt; and &lt;a href=&quot;visit&quot;&gt;visit&lt;/a&gt; throw &lt;a href=&quot;bad_variant_access&quot;&gt;bad_variant_access&lt;/a&gt;.</source>
          <target state="translated">: 예외로 가치없는 잘못된 상태에있는 것으로 취급 인 변형 &lt;a href=&quot;index&quot;&gt;인덱스&lt;/a&gt; 를 반환 &lt;a href=&quot;variant_npos&quot;&gt;variant_npos가&lt;/a&gt; , &lt;a href=&quot;get&quot;&gt;얻을&lt;/a&gt; 및 &lt;a href=&quot;visit&quot;&gt;방문&lt;/a&gt; 던져 &lt;a href=&quot;bad_variant_access&quot;&gt;bad_variant_access&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d13acd0a8aed6cefb7c9972fe8dbd4991eb6d5ec" translate="yes" xml:space="preserve">
          <source>A vector of strings can be sorted according to a non-default locale by using the locale object as comparator:</source>
          <target state="translated">로케일 객체를 비교 자로 사용하여 기본이 아닌 로케일에 따라 문자열 벡터를 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3e281fb8afe5cc3b522bbdd748cec3c0126f3da" translate="yes" xml:space="preserve">
          <source>A very common implementation-defined form of main() has a third argument (in addition to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;), of type &lt;code&gt;char*[]&lt;/code&gt;, pointing at &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the execution environment variables&lt;/a&gt;.</source>
          <target state="translated">main ()의 매우 일반적인 구현 정의 형식 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;에는 실행 환경 변수에 대한 포인터 배열을&lt;/a&gt; 가리키는 &lt;code&gt;char*[]&lt;/code&gt; 유형 의 세 번째 인수 ( &lt;code&gt;argc&lt;/code&gt; 및 &lt;code&gt;argv&lt;/code&gt; 외에 )가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cef77f8c0ffb4916f8bc0498dc7440820ca8d36" translate="yes" xml:space="preserve">
          <source>A zero-initialized pointer is the null pointer value of its type, even if the value of the null pointer is not integral zero.</source>
          <target state="translated">null로 초기화 된 포인터는 null 포인터의 값이 0이 아닌 경우에도 해당 유형의 null 포인터 값입니다.</target>
        </trans-unit>
        <trans-unit id="7be129f416228534857a690cd4c38374c5515373" translate="yes" xml:space="preserve">
          <source>A, and B</source>
          <target state="translated">A와 B</target>
        </trans-unit>
        <trans-unit id="a5e35ae614f82259bcebce61eb00073751f2e388" translate="yes" xml:space="preserve">
          <source>A, and B is a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation, then X precedes B in S d) if a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence X</source>
          <target state="translated">A이고, B는 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 연산이고, 다음에 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; )에서 X가 B보다 우선합니다 d) memory_order_seq_cst 펜스 X</target>
        </trans-unit>
        <trans-unit id="48a01a12d57f9009c8dea86e8610f3bdea642dd4" translate="yes" xml:space="preserve">
          <source>A. Williams (2012), &quot;C++ concurrency in action&quot; 9.2.4 Interrupting a wait on std::condition_variable_any</source>
          <target state="translated">A. Williams (2012), &quot;C ++ 동시성 작동&quot;9.2.4 std :: condition_variable_any에서 대기 중단</target>
        </trans-unit>
        <trans-unit id="6b4fe715ea89fb871c5a975d173f10a5adf57e7c" translate="yes" xml:space="preserve">
          <source>A1, A2, A3,... is a possibly empty list of arbitrary expressions, except the comma operator is not allowed at the top level to avoid ambiguity.</source>
          <target state="translated">A1, A2, A3, ...는 모호성을 피하기 위해 최상위 레벨에서 쉼표 연산자를 사용할 수 없다는 점을 제외하고 비어있는 임의의 표현식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="de2c49eaafb50b14e68d760cacef2f0ba0ba8f45" translate="yes" xml:space="preserve">
          <source>ADL</source>
          <target state="translated">ADL</target>
        </trans-unit>
        <trans-unit id="cd5086cb4e7d0efbc40ccb220af4c1d024f33775" translate="yes" xml:space="preserve">
          <source>ADL can find a &lt;a href=&quot;friend&quot;&gt;friend function&lt;/a&gt; (typically, an overloaded operator) that is defined entirely within a class or class template, even if it was never declared at namespace level.</source>
          <target state="translated">ADL은 네임 스페이스 수준에서 선언되지 않은 경우에도 클래스 또는 클래스 템플릿 내에 완전히 정의 된 &lt;a href=&quot;friend&quot;&gt;친구 함수&lt;/a&gt; (일반적으로 오버로드 된 연산자)를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="daf2a98f5077d337e35a18a770cad80d218e9ca5" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE NOON WITH JEEM WITH YEH FINAL FORM</source>
          <target state="translated">YEH FINAL FORM을 포함한 JEEM의 아랍어 합법적 정오</target>
        </trans-unit>
        <trans-unit id="5f8c72f94f6217e6dad861d24c88516ef9cd816b" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE SALLA USED AS KORANIC STOP SIGN ISOLATED FORM -</source>
          <target state="translated">아랍어 합자 SALLA KORANIC 정지 신호 ISOLATED 양식으로 사용-</target>
        </trans-unit>
        <trans-unit id="af1d8ae2aa108f95b9b57f28478231da2a606638" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE TEH WITH JEEM WITH MEEM INITIAL FORM -</source>
          <target state="translated">MEEM 초기 형식의 보석을 사용한 아랍어 합자-</target>
        </trans-unit>
        <trans-unit id="187459c12cbce645deb52d74f3d6152a7a9a17fc" translate="yes" xml:space="preserve">
          <source>ASCII Chart</source>
          <target state="translated">ASCII 차트</target>
        </trans-unit>
        <trans-unit id="6b85275355e86325dde0c35693852c2d7820c750" translate="yes" xml:space="preserve">
          <source>ASCII chart</source>
          <target state="translated">ASCII 차트</target>
        </trans-unit>
        <trans-unit id="6ff2c765d8c7f7f1624b70244d10913facb7ae0b" translate="yes" xml:space="preserve">
          <source>ASCII values</source>
          <target state="translated">ASCII 값</target>
        </trans-unit>
        <trans-unit id="63e21a0c9c10fbf518b0166eb437a67f1ed962cd" translate="yes" xml:space="preserve">
          <source>ATOMIC_FLAG_INIT</source>
          <target state="translated">ATOMIC_FLAG_INIT</target>
        </trans-unit>
        <trans-unit id="0b0620452fea1cd6ef04952a1260146f273e310f" translate="yes" xml:space="preserve">
          <source>ATOMIC_VAR_INIT</source>
          <target state="translated">ATOMIC_VAR_INIT</target>
        </trans-unit>
        <trans-unit id="435b6099910c97d9bc8e078e332560e92819291f" translate="yes" xml:space="preserve">
          <source>Abandons the shared state and destroys the stored task object.</source>
          <target state="translated">공유 상태를 포기하고 저장된 작업 개체를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="36e1c539cc780bc605cb01b3fddc5d8db9c3b6ab" translate="yes" xml:space="preserve">
          <source>Abandons the shared state:</source>
          <target state="translated">공유 상태를 포기합니다 :</target>
        </trans-unit>
        <trans-unit id="e7becc73c7eaff031859fb120395433f96283795" translate="yes" xml:space="preserve">
          <source>Abbreviated function template</source>
          <target state="translated">약식 함수 템플릿</target>
        </trans-unit>
        <trans-unit id="019202b59ca73881cfaab35533cb5a7033c39a80" translate="yes" xml:space="preserve">
          <source>Abbreviated function templates can be specialized like all function templates.</source>
          <target state="translated">축약 된 기능 템플릿은 모든 기능 템플릿처럼 전문화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd2f1ad3f3e244485410235abcc0dcd9d528402f" translate="yes" xml:space="preserve">
          <source>Absolute value of &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 의 절대 값 .</target>
        </trans-unit>
        <trans-unit id="1b11f0b716439740a7eef7b0954e8e03f2442de7" translate="yes" xml:space="preserve">
          <source>Abstract classes are used to represent general concepts (for example, Shape, Animal), which can be used as base classes for concrete classes (for example, Circle, Dog).</source>
          <target state="translated">추상 클래스는 일반 개념 (예 : 모양, 동물)을 나타내는 데 사용되며 콘크리트 클래스 (예 : Circle, Dog)의 기본 클래스로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="496f013275ea0cccdde9e4ce5e27272837e636f5" translate="yes" xml:space="preserve">
          <source>Abstract types cannot be used as parameter types, as function return types, or as the type of an explicit conversion (note this is checked at the point of definition and function call, since at the point of function declaration parameter and return type may be incomplete).</source>
          <target state="translated">추상 유형은 매개 변수 유형, 함수 리턴 유형 또는 명시 적 변환 유형으로 사용할 수 없습니다 (이는 함수 선언 시점에서 매개 변수 및 리턴 유형이 불완전 할 수 있으므로 정의 및 함수 호출시 점검 됨) ).</target>
        </trans-unit>
        <trans-unit id="8fda6cf2aae5ca82e8dc635a5cfbd7ff01d1ac31" translate="yes" xml:space="preserve">
          <source>Abstraction</source>
          <target state="translated">Abstraction</target>
        </trans-unit>
        <trans-unit id="fe89f3fca6949588976c79493bd13c9b36f00658" translate="yes" xml:space="preserve">
          <source>Access checking for the names used in &lt;a href=&quot;default_arguments&quot;&gt;default function arguments&lt;/a&gt; as well as in the default &lt;a href=&quot;template_parameters#Default_template_arguments&quot;&gt;template parameters&lt;/a&gt; is performed at the point of declaration, not at the point of use.</source>
          <target state="translated">&lt;a href=&quot;default_arguments&quot;&gt;기본 함수 인수&lt;/a&gt; 와 기본 &lt;a href=&quot;template_parameters#Default_template_arguments&quot;&gt;템플릿 매개 변수&lt;/a&gt; 에 사용 된 이름에 대한 액세스 검사는 사용 시점이 아니라 선언 시점에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="9de67dfb6d06413cdc219824a0f3f88445b9f32c" translate="yes" xml:space="preserve">
          <source>Access out of bounds</source>
          <target state="translated">범위를 벗어난 액세스</target>
        </trans-unit>
        <trans-unit id="64d102e911590ffe48aba24684384d363cf0b36b" translate="yes" xml:space="preserve">
          <source>Access outside of lifetime</source>
          <target state="translated">평생 외출</target>
        </trans-unit>
        <trans-unit id="ff2202db9230ee307101c952851e1360ff1ce903" translate="yes" xml:space="preserve">
          <source>Access overhead: In pImpl, each call to a private member function indirects through a pointer. Each access to a public member made by a private member indirects through another pointer. Both indirections cross translation unit boundaries and so can only be optimized out by link-time optimization. Note that OO factory requires indirection across translation units to access both public data and implementation detail, and offers even fewer opportunities for the link time optimizer due to virtual dispatch.</source>
          <target state="translated">액세스 오버 헤드 : pImpl에서 개인 멤버 함수에 대한 각 호출은 포인터를 통해 간접적으로 수행됩니다. 개인 구성원이 수행 한 공용 구성원에 대한 각 액세스는 다른 포인터를 통해 간접적으로 수행됩니다. 두 간접 지시는 변환 단위 경계를 교차하므로 링크 시간 최적화를 통해서만 최적화 할 수 있습니다. OO 팩토리는 퍼블릭 데이터와 구현 세부 사항에 모두 액세스하기 위해 번역 단위간에 간접적 인 액세스가 필요하며 가상 디스패치로 인해 링크 시간 최적화 프로그램에 대한 기회가 훨씬 적습니다.</target>
        </trans-unit>
        <trans-unit id="41dcddad26f26d0b23476e3af19f8e0cff1f9f7e" translate="yes" xml:space="preserve">
          <source>Access permissions model &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX permission bits&lt;/a&gt;, and any individual file permissions (as reported by &lt;a href=&quot;status&quot;&gt;status&lt;/a&gt;) are a combination of some of the following bits:</source>
          <target state="translated">액세스 권한 모델 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX 권한 비트&lt;/a&gt; 및 개별 파일 권한 ( &lt;a href=&quot;status&quot;&gt;status&lt;/a&gt; 로보고 됨 )은 다음 비트 중 일부의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="b29695d27ada4464e68e5f7e3d3cd693fa6cadcf" translate="yes" xml:space="preserve">
          <source>Access rules for the names of &lt;a href=&quot;virtual&quot;&gt;virtual functions&lt;/a&gt; are checked at the call point using the type of the expression used to denote the object for which the member function is called. The access of the final overrider is ignored.</source>
          <target state="translated">&lt;a href=&quot;virtual&quot;&gt;가상 함수&lt;/a&gt; 이름에 대한 액세스 규칙 은 멤버 함수가 호출되는 오브젝트를 나타내는 데 사용되는 표현식 유형을 사용하여 호출 지점에서 점검됩니다. 최종 재정 의자의 액세스는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="172f15fcb1759434b4e5cac298998c9f90e5367d" translate="yes" xml:space="preserve">
          <source>Access specifiers</source>
          <target state="translated">액세스 지정자</target>
        </trans-unit>
        <trans-unit id="fd9b61139d61fe4a3ad562d5c3fb1467d5f0fb25" translate="yes" xml:space="preserve">
          <source>Access specifiers give the author of the class the ability to decide which class members are accessible to the users of the class (that is, the</source>
          <target state="translated">액세스 지정자는 클래스 작성자에게 클래스의 사용자가 액세스 할 수있는 클래스 멤버 (즉,</target>
        </trans-unit>
        <trans-unit id="b5f1627a2f9ef35b0cad78d685d46c26ac79a8ba" translate="yes" xml:space="preserve">
          <source>Access to a non-static data member or a call to a non-static member function.</source>
          <target state="translated">비 정적 데이터 멤버에 액세스하거나 비 정적 멤버 함수에 대한 호출</target>
        </trans-unit>
        <trans-unit id="1632238dd01e0d2949d4e0ad89257742628b773a" translate="yes" xml:space="preserve">
          <source>Access to pointer passed to realloc</source>
          <target state="translated">realloc에 ​​전달 된 포인터에 대한 액세스</target>
        </trans-unit>
        <trans-unit id="27559787dd122b923d06b7298557d1cd2c568a23" translate="yes" xml:space="preserve">
          <source>Access to the &lt;code&gt;p&lt;/code&gt;'s deleter. If the shared pointer &lt;code&gt;p&lt;/code&gt; owns a deleter of type cv-unqualified &lt;code&gt;Deleter&lt;/code&gt; (e.g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter. Otherwise, returns a null pointer.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 의 삭제 도구에 액세스합니다 . 공유 포인터 &lt;code&gt;p&lt;/code&gt; 가 cv-unqualified &lt;code&gt;Deleter&lt;/code&gt; 유형의 삭제자를 소유 한 경우 (예 : 삭제자를 매개 변수로 사용하는 생성자 중 하나를 사용하여 작성된 경우) 삭제기에 대한 포인터를 리턴합니다. 그렇지 않으면 널 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5c1d13d1c544b3feecb6e442b5b9a73c51c6b267" translate="yes" xml:space="preserve">
          <source>Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a &lt;code&gt;shared_future&lt;/code&gt; object.</source>
          <target state="translated">각 스레드가 &lt;code&gt;shared_future&lt;/code&gt; 객체 의 자체 복사본을 통해 수행하는 경우 여러 스레드에서 동일한 공유 상태에 액세스하는 것이 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="f563d2f693e12ab63ee51309db6c0dd439835d3c" translate="yes" xml:space="preserve">
          <source>Accesses a member of its operand.</source>
          <target state="translated">피연산자의 멤버에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="a42b2fe3c4d5fcc9a9d311beb7c3efb130c09b8a" translate="yes" xml:space="preserve">
          <source>Accesses the bit at position &lt;code&gt;pos&lt;/code&gt;. The first version returns the value of the bit, the second version returns an object of type &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt; that allows modification of the value.</source>
          <target state="translated">위치 &lt;code&gt;pos&lt;/code&gt; 의 비트에 액세스합니다 . 첫 번째 버전은 비트 값을 반환하고 두 번째 버전은 값을 수정할 수있는 &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt; 유형의 개체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d60917183a0203e125a2a367082f7e505a1b54cc" translate="yes" xml:space="preserve">
          <source>Accesses the contained value.</source>
          <target state="translated">포함 된 값에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="5ffc054a82694395488926c5d88d20377f2fee4f" translate="yes" xml:space="preserve">
          <source>Accesses the file permissions information.</source>
          <target state="translated">파일 권한 정보에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="0faa3d14d648895a9103231a47e67306cf3658f8" translate="yes" xml:space="preserve">
          <source>Accesses the file type information.</source>
          <target state="translated">파일 유형 정보에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="9ab9ff8b7be4b7d40eb92e8afba99b14b56097f9" translate="yes" xml:space="preserve">
          <source>Accesses the imaginary part of the complex number.</source>
          <target state="translated">복소수의 허수 부분에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="6c9900004652bab063edd448abb4e13e10ff694e" translate="yes" xml:space="preserve">
          <source>Accesses the index stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 저장된 색인에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c82d4ce7723e142d0946770db58f80f216a936" translate="yes" xml:space="preserve">
          <source>Accesses the name and target of this &lt;code&gt;link&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;link&lt;/code&gt; 객체 의 이름과 대상에 액세스 합니다.</target>
        </trans-unit>
        <trans-unit id="ad5cf92f478d0439f59cdb4880f47ebacaf46e23" translate="yes" xml:space="preserve">
          <source>Accesses the native handle of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 의 기본 핸들에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="9d7d833d3713305bce90c91948acf875f0c20ba4" translate="yes" xml:space="preserve">
          <source>Accesses the native path name as a character string.</source>
          <target state="translated">기본 경로 이름을 문자열로 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="3ae496a866ebcdc4db51cd8794d1e50d8d500069" translate="yes" xml:space="preserve">
          <source>Accesses the pointed-to &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; 에&lt;/a&gt; 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="9823697b16ef01bf1ebfdd504cd02cc048fbff41" translate="yes" xml:space="preserve">
          <source>Accesses the real part of the complex number.</source>
          <target state="translated">복소수의 실수 부분에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="bbd2d3ce5c26cd90201155a08a10040ce8faa66b" translate="yes" xml:space="preserve">
          <source>Accessibility applies to all names with no regard to their origin, so a name introduced by a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; or &lt;a href=&quot;using_declaration&quot;&gt;using declarations&lt;/a&gt; is checked, not the name it refers to.</source>
          <target state="translated">접근성은 그 기원에 관계없이 모든 이름에 적용되므로, &lt;a href=&quot;typedef&quot;&gt;typedef에&lt;/a&gt; 의해 도입 되거나 &lt;a href=&quot;using_declaration&quot;&gt;선언을 사용&lt;/a&gt; 하여 이름이 참조되는 이름이 아닌 이름이 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="db5f1eeeca9d3c68907d330e642c8ec9d5a0116f" translate="yes" xml:space="preserve">
          <source>Accessing an object using an expression of a type other than the type with which it was created is undefined behavior in many cases, see &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;reinterpret_cast&lt;/a&gt; for the list of exceptions and examples.</source>
          <target state="translated">많은 경우에 작성된 유형이 아닌 유형의 표현식을 사용하여 오브젝트에 액세스하는 것은 정의되지 않은 동작입니다 . 예외 및 예제 목록 은 &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;reinterpret_cast&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43edbdec6f4616d56db2ed67623f9b6b877668ea" translate="yes" xml:space="preserve">
          <source>Accessing the variable during initialization from another thread, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; operation).</source>
          <target state="translated">원자 연산을 통해 다른 스레드에서 초기화하는 동안 변수에 액세스하는 것은 데이터 경쟁입니다 (주소가 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; 연산 으로 다른 스레드로 즉시 전달되는 경우 발생할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="bd21f9aade4e041d6127535e2103b7265328e814" translate="yes" xml:space="preserve">
          <source>Acquire operation</source>
          <target state="translated">작업 획득</target>
        </trans-unit>
        <trans-unit id="336eaf1465ee3c86483dca958f5b3f81e8c35309" translate="yes" xml:space="preserve">
          <source>Acquires ownership of the given mutex &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">주어진 뮤텍스 &lt;code&gt;m&lt;/code&gt; 의 소유권을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="a0bfcec1da334e9014a69ecff78b70a46245c533" translate="yes" xml:space="preserve">
          <source>Acquires ownership of the given mutexes &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">주어진 뮤텍스 &lt;code&gt;m&lt;/code&gt; 의 소유권을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="c865fe856f24b54f5a468d814de44d24b3ad8da2" translate="yes" xml:space="preserve">
          <source>Acquires shared ownership of the mutex. If another thread is holding the mutex in exclusive ownership, a call to &lt;code&gt;lock_shared&lt;/code&gt; will block execution until shared ownership can be acquired.</source>
          <target state="translated">뮤텍스의 공유 소유권을 얻습니다. 다른 스레드가 독점 소유권으로 뮤텍스를 보유하고 있으면 &lt;code&gt;lock_shared&lt;/code&gt; 를 호출하면 공유 소유권을 얻을 수있을 때까지 실행이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="116672ae6ceb211b89b5cc24d53045f44bb76b12" translate="yes" xml:space="preserve">
          <source>Acronyms</source>
          <target state="translated">Acronyms</target>
        </trans-unit>
        <trans-unit id="894e0d0ca601136dd7488a48cc4e246850d2e574" translate="yes" xml:space="preserve">
          <source>Action if file</source>
          <target state="translated">파일 인 경우 조치</target>
        </trans-unit>
        <trans-unit id="5405a9d57e6b63ab5821d9588dde26920a308e00" translate="yes" xml:space="preserve">
          <source>Action if file already exists</source>
          <target state="translated">파일이 이미 존재하는 경우의 조치</target>
        </trans-unit>
        <trans-unit id="c3c1db410576ecf3d85988b0535501a3dc1d020f" translate="yes" xml:space="preserve">
          <source>Action if file does not exist</source>
          <target state="translated">파일이 존재하지 않는 경우의 조치</target>
        </trans-unit>
        <trans-unit id="a7817b78f6b68e579f4e4537bfed1875e7ae184f" translate="yes" xml:space="preserve">
          <source>Actual implementations vary:</source>
          <target state="translated">실제 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ca7e3d2e4ac34bc514652447560887a72b3f649" translate="yes" xml:space="preserve">
          <source>Adaptors</source>
          <target state="translated">Adaptors</target>
        </trans-unit>
        <trans-unit id="fb414d455da6b9468629ebcfdfce20d9ea740f72" translate="yes" xml:space="preserve">
          <source>Adding constexpr modifiers to &lt;code&gt;&lt;a href=&quot;iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;iterator/move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;iterator#Container_access&quot;&gt;range access&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;iterator/move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; 및 &lt;a href=&quot;iterator#Container_access&quot;&gt;range 액세스에&lt;/a&gt; constexpr 수정 자 추가</target>
        </trans-unit>
        <trans-unit id="f9c64c7ebe5a611a1f12ffc12fb7a8366d9e1fdc" translate="yes" xml:space="preserve">
          <source>Adding heterogeneous comparison lookup to associative containers</source>
          <target state="translated">연관 컨테이너에 이기종 비교 조회 추가</target>
        </trans-unit>
        <trans-unit id="ad005a38d417aa5d21ad05bcc3397517559e1e10" translate="yes" xml:space="preserve">
          <source>Adding heterogeneous comparison lookup to unordered associative containers</source>
          <target state="translated">정렬되지 않은 연관 컨테이너에 이기종 비교 검색 추가</target>
        </trans-unit>
        <trans-unit id="a6dea03cb51c5650f791a12987ca0df26adb5602" translate="yes" xml:space="preserve">
          <source>Adding pre-calculated hash value lookup to unordered associative containers</source>
          <target state="translated">정렬되지 않은 연관 컨테이너에 사전 계산 된 해시 값 조회 추가</target>
        </trans-unit>
        <trans-unit id="87ed11c26edf58b14803d392bf82cd48a91e96b8" translate="yes" xml:space="preserve">
          <source>Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted.</source>
          <target state="translated">목록 내 또는 여러 목록에서 요소를 추가, 제거 및 이동해도 반복기 또는 참조가 무효화되지 않습니다. 반복자는 해당 요소가 삭제 된 경우에만 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="98f2660c67411bcd6814bc7ce1f2e850dfc897be" translate="yes" xml:space="preserve">
          <source>Adding, removing and moving the elements within the list, or across several lists, does not invalidate the iterators currently referring to other elements in the list. However, an iterator or reference referring to an element is invalidated when the corresponding element is removed (via &lt;code&gt;&lt;a href=&quot;forward_list/erase_after&quot;&gt;erase_after&lt;/a&gt;&lt;/code&gt;) from the list.</source>
          <target state="translated">목록 내에서 또는 여러 목록에서 요소를 추가, 제거 및 이동해도 현재 목록의 다른 요소를 참조하는 반복기가 무효화되지 않습니다. 그러나 해당 요소가 목록에서 ( &lt;code&gt;&lt;a href=&quot;forward_list/erase_after&quot;&gt;erase_after&lt;/a&gt;&lt;/code&gt; 통해 ) 제거되면 요소를 참조하는 반복자 또는 참조가 무효화됩니다 .</target>
        </trans-unit>
        <trans-unit id="48911a7386b2baa20a76ef9e342562ca04e9c341" translate="yes" xml:space="preserve">
          <source>Addition and subtraction</source>
          <target state="translated">더하기와 빼기</target>
        </trans-unit>
        <trans-unit id="5c20b1f1d3dccc5fc33df625c9821015eb0d18af" translate="yes" xml:space="preserve">
          <source>Additional basic types and macros</source>
          <target state="translated">추가 기본 유형 및 매크로</target>
        </trans-unit>
        <trans-unit id="dc459b3781fd1c39294a64216e4b94c9615d87b0" translate="yes" xml:space="preserve">
          <source>Additional behavior may be defined by the implementations for file systems which append additional elements (such as alternate data streams or partitioned dataset names) to extensions.</source>
          <target state="translated">추가 동작은 추가 요소 (예 : 대체 데이터 스트림 또는 파티션 된 데이터 세트 이름)를 확장자에 추가하는 파일 시스템의 구현에 의해 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9a945aa19333f0b54ff5676b6d9de2643f1b76b" translate="yes" xml:space="preserve">
          <source>Additional classifications such as &lt;code&gt;&quot;jdigit&quot;&lt;/code&gt; or &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; may be provided by system-supplied locales (in which case they are also accessible through &lt;code&gt;&lt;a href=&quot;../../string/wide/wctype&quot;&gt;std::wctype&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&quot;jdigit&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; 와 같은 추가 분류 는 시스템 제공 로케일에 의해 제공 될 수 있습니다 (이 경우 &lt;code&gt;&lt;a href=&quot;../../string/wide/wctype&quot;&gt;std::wctype&lt;/a&gt;&lt;/code&gt; 통해 액세스 할 수도 있음 ).</target>
        </trans-unit>
        <trans-unit id="ed64694f365b81d351dbd520c43964630a71e79f" translate="yes" xml:space="preserve">
          <source>Additional concepts can be found in &lt;a href=&quot;algorithm/ranges#Algorithm_concepts_and_utilities&quot;&gt;the algorithms library&lt;/a&gt; and &lt;a href=&quot;ranges#Range_concepts&quot;&gt;the ranges library&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;algorithm/ranges#Algorithm_concepts_and_utilities&quot;&gt;알고리즘 라이브러리&lt;/a&gt; 와 &lt;a href=&quot;ranges#Range_concepts&quot;&gt;범위 라이브러리&lt;/a&gt; 에서 추가 개념을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="655988b4d376c12072cf6c9cdb9826fe22ae3e28" translate="yes" xml:space="preserve">
          <source>Additional execution policies may be provided by a standard library implementation (possible future additions may include &lt;code&gt;std::parallel::cuda&lt;/code&gt; and &lt;code&gt;std::parallel::opencl&lt;/code&gt;).</source>
          <target state="translated">추가 실행 정책은 표준 라이브러리 구현에 의해 제공 될 수 있습니다 (향후 가능한 추가에는 &lt;code&gt;std::parallel::cuda&lt;/code&gt; 및 &lt;code&gt;std::parallel::opencl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b037de42fdfdd2746ba0eff4076bb78f7f07fda" translate="yes" xml:space="preserve">
          <source>Additional implementation-defined preparation may take place, which may call &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;setstate(failbit)&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 던질 수 있음)를 호출 할 수있는 추가 구현 정의 준비가 수행 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96549f1325a6bd11423df1587b53f51b1bda1aee" translate="yes" xml:space="preserve">
          <source>Additional macro constants, with names that begin with &lt;code&gt;LC_&lt;/code&gt; followed by at least one uppercase letter, may be defined in &lt;code&gt;&amp;lt;clocale&amp;gt;&lt;/code&gt;. For example, the POSIX specification requires LC_MESSAGES (which controls &lt;code&gt;&lt;a href=&quot;../io/c/perror&quot;&gt;std::perror&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt;), ISO/IEC 30112:2014 (&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 draft&lt;/a&gt;) additionally defines LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT, and LC_KEYBOARD, which are supported by the GNU C library (except for LC_XLITERATE).</source>
          <target state="translated">&lt;code&gt;LC_&lt;/code&gt; 로 시작하고 그 뒤에 대문자가 하나 이상인 추가 매크로 상수 는 &lt;code&gt;&amp;lt;clocale&amp;gt;&lt;/code&gt; 에 정의 될 수 있습니다 . 예를 들어, POSIX 사양에는 LC_MESSAGES ( &lt;code&gt;&lt;a href=&quot;../io/c/perror&quot;&gt;std::perror&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt; ), ISO / IEC 30112 : 2014 ( &lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 draft&lt;/a&gt; )가 LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT 및 LC_KEYASBOMENTARD를 추가로 정의해야합니다. GNU C 라이브러리에서 지원합니다 (LC_XLITERATE 제외).</target>
        </trans-unit>
        <trans-unit id="99f91b99c0d1f5963361dc127f6dbe9e38bb8903" translate="yes" xml:space="preserve">
          <source>Additional macros that begin with &lt;code&gt;FE_&lt;/code&gt; followed by uppercase letters, and have the type &lt;code&gt;const std::fenv_t*&lt;/code&gt;, may be supported by an implementation.</source>
          <target state="translated">&lt;code&gt;FE_&lt;/code&gt; 로 시작하고 대문자로 시작하고 &lt;code&gt;const std::fenv_t*&lt;/code&gt; 유형의 추가 매크로가 구현에 의해 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef3d826dd03b81e684d86b842e89e92269929ee7" translate="yes" xml:space="preserve">
          <source>Additional numeric formats may be accepted by the currently installed C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 설치된 C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt; 에서 추가 숫자 형식을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a5c5be417cfb6cd7d9118d383daf9f4ffd160e0" translate="yes" xml:space="preserve">
          <source>Additional overloads are provided for &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, and all integer types, which are treated as complex numbers with zero imaginary component.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; 및 모든 정수 유형 에 대해 추가 과부하가 제공되며 이는 가상의 성분이 0 인 복소수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e8146529cfa6fa203e23e61b37cbdf2d37d4634b" translate="yes" xml:space="preserve">
          <source>Additional rounding modes may be supported by an implementation.</source>
          <target state="translated">추가적인 반올림 모드는 구현에 의해 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c51476def7086889d71b363945c5ad2e8649c02e" translate="yes" xml:space="preserve">
          <source>Additional signal names &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;are specified by POSIX&lt;/a&gt;.</source>
          <target state="translated">추가 신호 이름 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;은 POSIX로 지정됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e1faa5440a863d95ba8c415f20385dfa4af6d4b" translate="yes" xml:space="preserve">
          <source>Additional support</source>
          <target state="translated">추가 지원</target>
        </trans-unit>
        <trans-unit id="04f95216581ee9c47e04240f25828352cba16ddc" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_&amp;shy;concept&lt;/code&gt; may be used to indicate conformance to the iterator concepts.</source>
          <target state="translated">또한, &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_&amp;shy;concept&lt;/code&gt; 반복자 개념에 대한 적합성을 표시하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="f2e0dd9b924004af0072e53510ae5406eb8b489b" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator!=&lt;/code&gt; are provided, either as members or as non-members, as required by &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;code&gt;operator==&lt;/code&gt; 및 &lt;code&gt;operator!=&lt;/code&gt; 는 &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator에&lt;/a&gt; 필요한대로 멤버 또는 비 멤버로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce53b9c5df0fcfe1d1195f17fc25165a98c09650" translate="yes" xml:space="preserve">
          <source>Additionally, O(N) calls to the constructor of &lt;code&gt;value_type&lt;/code&gt;, where N is &lt;code&gt;cont.size()&lt;/code&gt;.</source>
          <target state="translated">또한 O (N)은 &lt;code&gt;value_type&lt;/code&gt; 의 생성자를 호출합니다. 여기서 N은 &lt;code&gt;cont.size()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7bee97038914dbaf49097462be0b6fa3a27587e0" translate="yes" xml:space="preserve">
          <source>Additionally, a specialization exists for every cv-qualified version of each arithmetic type, identical to the unqualified specialization, e.g. &lt;code&gt;std::numeric_limits&amp;lt;const int&amp;gt;&lt;/code&gt;, &lt;code&gt;std::numeric_limits&amp;lt;volatile int&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::numeric_limits&amp;lt;const volatile int&amp;gt;&lt;/code&gt; are provided and are equivalent to &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">또한 정규화되지 않은 특수화와 동일하게 각 산술 유형의 모든 cv 규정 버전에 대해 특수화가 존재합니다 (예 : &lt;code&gt;std::numeric_limits&amp;lt;const int&amp;gt;&lt;/code&gt; , &lt;code&gt;std::numeric_limits&amp;lt;volatile int&amp;gt;&lt;/code&gt; 및 &lt;code&gt;std::numeric_limits&amp;lt;const volatile int&amp;gt;&lt;/code&gt; 가 제공되며 &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="234e939fc46f7fc9566afc50a39f23e96624b23f" translate="yes" xml:space="preserve">
          <source>Additionally, an object &lt;code&gt;m&lt;/code&gt; of SharedMutex type supports another mode of ownership: shared. Multiple threads (or, more generally, execution agents) can simultaneously own this mutex in shared mode, but no thread may obtain shared ownership if there is a thread that owns it in exclusive mode and no thread may obtain exclusive ownership if there is a thread that owns it in shared mode. If more than implementation-defined number of threads (no less than 10000) hold a shared lock, another attempt to acquire the mutex in shared mode blocks until the number of shared owners drops down below that threshold.</source>
          <target state="translated">또한 SharedMutex 유형 의 객체 &lt;code&gt;m&lt;/code&gt; 은 또 다른 소유권 모드 인 공유를 지원합니다. 다중 스레드 (또는보다 일반적으로 실행 에이전트)는 공유 모드에서이 뮤텍스를 동시에 소유 할 수 있지만 독점 모드에서 스레드를 소유 한 스레드가 있고 스레드가있는 경우 독점 소유권을 얻을 수없는 스레드는 공유 소유권을 얻을 수 없습니다 공유 모드에서 소유합니다. 구현 정의 된 스레드 수보다 많은 스레드 (10000 이상)가 공유 잠금을 보유하는 경우 공유 소유자 수가 해당 임계 값 아래로 떨어질 때까지 공유 모드에서 뮤텍스를 획득하려는 다른 시도가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="4c21e2edf0f81a97ef8a624494e0c5a7e8d14423" translate="yes" xml:space="preserve">
          <source>Additionally, an object &lt;code&gt;m&lt;/code&gt; of SharedTimedMutex type supports timed shared operations:</source>
          <target state="translated">또한 SharedTimedMutex 유형 의 객체 &lt;code&gt;m&lt;/code&gt; 은 시간이 지정된 공유 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6981bc51ea468df1e5cb432a395ddfc2e5d78804" translate="yes" xml:space="preserve">
          <source>Additionally, for an object &lt;code&gt;m&lt;/code&gt; of TimedMutex type:</source>
          <target state="translated">또한 TimedMutex 유형 의 객체 &lt;code&gt;m&lt;/code&gt; 의 경우 :</target>
        </trans-unit>
        <trans-unit id="ceefa22c95a1f23f16745529c429d1edf71f2d45" translate="yes" xml:space="preserve">
          <source>Additionally, for every sequence container, the constructor template that takes two input iterators and the member function template overloads of &lt;code&gt;insert()&lt;/code&gt;, &lt;code&gt;append()&lt;/code&gt;, &lt;code&gt;assign()&lt;/code&gt;, &lt;code&gt;replace()&lt;/code&gt; that take two input iterators do not participate in overload resolution if the corresponding template argument does not satisfy &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">또한 모든 시퀀스 컨테이너에 대해 두 개의 입력 반복자를 사용하는 생성자 템플릿과 두 개의 입력 반복자를 사용하는 &lt;code&gt;insert()&lt;/code&gt; , &lt;code&gt;append()&lt;/code&gt; , &lt;code&gt;assign()&lt;/code&gt; , &lt;code&gt;replace()&lt;/code&gt; 의 멤버 함수 템플릿 오버로드는 오버로드 확인에 참여하지 않습니다. 해당 템플릿 인수가 &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator를&lt;/a&gt; 충족하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="80407204b5613c93f4ff9eeeca0d87435272db5c" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;floatfield != (ios_base::fixed | ios_base::scientific)&lt;/code&gt;, then(since C++11) precision modifier is added, set to &lt;code&gt;str.precision()&lt;/code&gt;</source>
          <target state="translated">또한 &lt;code&gt;floatfield != (ios_base::fixed | ios_base::scientific)&lt;/code&gt; 이면 (C ++ 11부터) 정밀도 수정자가 추가되고 &lt;code&gt;str.precision()&lt;/code&gt; 설정됩니다</target>
        </trans-unit>
        <trans-unit id="92ec030910d3cd27bfd60a9308eb60d240987aa3" translate="yes" xml:space="preserve">
          <source>Additionally, in order for the type &lt;code&gt;A&lt;/code&gt; to satisfy Allocator.</source>
          <target state="translated">또한 유형 &lt;code&gt;A&lt;/code&gt; 가 할당자를 만족시키기 위해.</target>
        </trans-unit>
        <trans-unit id="e4c633a25d8deae1fd83be48e6f21fc0579f3bfe" translate="yes" xml:space="preserve">
          <source>Additionally, the following constants of this type are defined, which do not represent permissions:</source>
          <target state="translated">또한이 유형의 다음 상수가 정의되며 권한을 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3b85cc6377c854375953c6897c361f957b07ce5" translate="yes" xml:space="preserve">
          <source>Additionally, the resulting &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Floating&lt;/i&gt;&amp;gt;&lt;/code&gt; specialization has standard layout, a trivial default constructor, and a trivial destructor.</source>
          <target state="translated">또한 결과 &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Floating&lt;/i&gt;&amp;gt;&lt;/code&gt; 전문화에는 표준 레이아웃, 사소한 기본 생성자 및 사소한 소멸자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8aaea245aabbd553929a2dc8693fcb475a09d9c" translate="yes" xml:space="preserve">
          <source>Additionally, the resulting &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Integral&lt;/i&gt;&amp;gt;&lt;/code&gt; specialization has standard layout, a trivial default constructor, and a trivial destructor. Signed integer arithmetic is defined to use two's complement; there are no undefined results.</source>
          <target state="translated">또한 결과 &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Integral&lt;/i&gt;&amp;gt;&lt;/code&gt; 전문화에는 표준 레이아웃, 사소한 기본 생성자 및 사소한 소멸자가 있습니다. 부호있는 정수 산술은 2의 보수를 사용하도록 정의됩니다. 정의되지 않은 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac1d2a76e849b1b5833ee66f2036219c73ed4239" translate="yes" xml:space="preserve">
          <source>Additionally:</source>
          <target state="translated">Additionally:</target>
        </trans-unit>
        <trans-unit id="76be74594d0a3f6f1c23004ef8fbefa453574daa" translate="yes" xml:space="preserve">
          <source>Additive operators</source>
          <target state="translated">첨가제 연산자</target>
        </trans-unit>
        <trans-unit id="ce6e9db4782a94f83450a756f42238c060b97d77" translate="yes" xml:space="preserve">
          <source>Address constant expression</source>
          <target state="translated">주소 상수 표현</target>
        </trans-unit>
        <trans-unit id="38ee922cd750ff4631c23d9b88d00633994c2466" translate="yes" xml:space="preserve">
          <source>Address family not supported</source>
          <target state="translated">지원되지 않는 주소 패밀리</target>
        </trans-unit>
        <trans-unit id="9e53f7cf7661710ec98f0a6e7a65398f5e81f0be" translate="yes" xml:space="preserve">
          <source>Address in use</source>
          <target state="translated">사용중인 주소</target>
        </trans-unit>
        <trans-unit id="a645d07371a2ce45ebb0b375f8787a4fc425584d" translate="yes" xml:space="preserve">
          <source>Address not available</source>
          <target state="translated">사용할 수없는 주소</target>
        </trans-unit>
        <trans-unit id="f282d429f8e10c6e8f6cc685119b79f7b98f8d4a" translate="yes" xml:space="preserve">
          <source>Address of an lvalue may be taken: &lt;code&gt;&amp;amp;++i&lt;/code&gt;&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; and &lt;code&gt;&amp;amp;&lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; are valid expressions.</source>
          <target state="translated">lvalue의 주소를 사용할 수 있습니다. &lt;code&gt;&amp;amp;++i&lt;/code&gt; &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 및 &lt;code&gt;&amp;amp;&lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; 은 유효한 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="1a289481f4bde8e8211ad9ffe17faa98c7f5cb4e" translate="yes" xml:space="preserve">
          <source>Address of an overload set</source>
          <target state="translated">과부하 세트의 주소</target>
        </trans-unit>
        <trans-unit id="b68e9b443504394c722ff5e4129a8d602ab42051" translate="yes" xml:space="preserve">
          <source>Address of an overloaded function</source>
          <target state="translated">과부하 된 기능의 주소</target>
        </trans-unit>
        <trans-unit id="50d8d3dd04846c597735fdea066d1202471e00ac" translate="yes" xml:space="preserve">
          <source>Address of an rvalue may not be taken: &lt;code&gt;&amp;amp;int()&lt;/code&gt;, &lt;code&gt;&amp;amp;i++&lt;/code&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;, &lt;code&gt;&amp;amp;42&lt;/code&gt;, and &lt;code&gt;&amp;amp;std::move(x)&lt;/code&gt; are invalid.</source>
          <target state="translated">rvalue의 주소를 가져올 수 없습니다 : &lt;code&gt;&amp;amp;int()&lt;/code&gt; , &lt;code&gt;&amp;amp;i++&lt;/code&gt; &lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt; , &lt;code&gt;&amp;amp;42&lt;/code&gt; 및 &lt;code&gt;&amp;amp;std::move(x)&lt;/code&gt; 는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9377e4719dc070a5dfa0119a44583c6b5ae07578" translate="yes" xml:space="preserve">
          <source>Address-of</source>
          <target state="translated">Address-of</target>
        </trans-unit>
        <trans-unit id="d8e9fb4e567ee2aa8c62d2ac99954b60bc22db70" translate="yes" xml:space="preserve">
          <source>Addressing tuples by type</source>
          <target state="translated">유형별로 튜플 주소 지정</target>
        </trans-unit>
        <trans-unit id="b0ef7d67a5935e3fe8af11cd7847c8809d95a854" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the day value.</source>
          <target state="translated">일 값에서 1을 더하거나 뺍니다.</target>
        </trans-unit>
        <trans-unit id="e43efbbed96f261cc9549f2681044676631d009f" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the month value, reducing the result modulo 12 to an integer in the range [1, 12].</source>
          <target state="translated">월 값에서 1을 더하거나 빼서 결과 모듈로 12를 [1, 12] 범위의 정수로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="fa3ef2c3e28e35bbf2cbd5aafea835fc3ea7a3ef" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6].</source>
          <target state="translated">요일 값에서 1을 더하거나 빼서 결과 모듈로 7을 [0, 6] 범위의 정수로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="640e675cb46fdd695967fccbbef63e0607e284a0" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the year value.</source>
          <target state="translated">연도 값에서 1을 더하거나 뺍니다.</target>
        </trans-unit>
        <trans-unit id="4153c4972fd500059ef400485fdf85b87aceaa00" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;d.count()&lt;/code&gt; days from the day value.</source>
          <target state="translated">일 값에서 &lt;code&gt;d.count()&lt;/code&gt; 일을 더하거나 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="678a7c04a10343a84658ffb12634bd9ee9456301" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;d.count()&lt;/code&gt; from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6].</source>
          <target state="translated">요일 값에서 &lt;code&gt;d.count()&lt;/code&gt; 를 더하거나 빼서 결과 모듈로 7을 [0, 6] 범위의 정수로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="3230fc75b04ac3e6ea29e55230fe30dd1c203bfe" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;m.count()&lt;/code&gt; from the month value, reducing the result modulo 12 to an integer in the range [1, 12].</source>
          <target state="translated">월 값에서 &lt;code&gt;m.count()&lt;/code&gt; 를 더하거나 빼서 결과 모듈로 12를 [1, 12] 범위의 정수로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="25e4a09fe7696cac408ac8a894a8ff1b27aa44b2" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;y.count()&lt;/code&gt; years from the year value.</source>
          <target state="translated">연도 값에서 &lt;code&gt;y.count()&lt;/code&gt; 더하거나 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="458e4498a6e12a40a95f335b3f81898cfd748b12" translate="yes" xml:space="preserve">
          <source>Adjacent &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are concatenated.</source>
          <target state="translated">인접한 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 이 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="9932bec15aa8c818ed7b8796dbd6ed7ef02aab26" translate="yes" xml:space="preserve">
          <source>Adopt the Parallelism TS for C++17</source>
          <target state="translated">C ++ 17 용 Parallelism TS 채택</target>
        </trans-unit>
        <trans-unit id="03e5621c572270086c95471651dc888f07bc2da9" translate="yes" xml:space="preserve">
          <source>Advances &lt;code&gt;e&lt;/code&gt;'s state as if by &lt;code&gt;z&lt;/code&gt; consecutive calls to &lt;code&gt;e()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 가 &lt;code&gt;e()&lt;/code&gt; 를 연속해서 호출하는 것처럼 &lt;code&gt;e&lt;/code&gt; 의 상태를 향상 시킵니다.</target>
        </trans-unit>
        <trans-unit id="135dd9fae6bf561e041334e7723bb57b90c62cf2" translate="yes" xml:space="preserve">
          <source>Advances the input sequence by one character and reads one character.</source>
          <target state="translated">입력 순서를 한 문자 씩 앞당기 고 한 문자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="50499158101997cf6bc049268a358d31d71424e8" translate="yes" xml:space="preserve">
          <source>Advances the internal state by &lt;code&gt;z&lt;/code&gt; times. Equivalent to calling &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;z&lt;/code&gt; times and discarding the result.</source>
          <target state="translated">내부 상태를 &lt;code&gt;z&lt;/code&gt; 배 만큼 높 입니다. &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; 를 호출 하고 결과를 버리는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="efa9b27cb8a086b18bbe299b9e1c46a036172d58" translate="yes" xml:space="preserve">
          <source>Advances the internal state by &lt;code&gt;z&lt;/code&gt; times. Equivalent to calling &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;z&lt;/code&gt; times and discarding the result. The state of the underlying engine may be advanced by more than &lt;code&gt;z&lt;/code&gt; times.</source>
          <target state="translated">내부 상태를 &lt;code&gt;z&lt;/code&gt; 배 만큼 높 입니다. &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; 를 호출 하고 결과를 버리는 것과 같습니다. 기본 엔진의 상태는 &lt;code&gt;z&lt;/code&gt; 배 이상 향상 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9ef5cc9bbd2286407c3e7b628e2c0232b990d29" translate="yes" xml:space="preserve">
          <source>Advances the iterator by calling &lt;code&gt;sbuf_-&amp;gt;sbumpc()&lt;/code&gt; where &lt;code&gt;sbuf_&lt;/code&gt; is the stored pointer to the stream buffer.</source>
          <target state="translated">&lt;code&gt;sbuf_-&amp;gt;sbumpc()&lt;/code&gt; 를 호출하여 반복자를 향상시킵니다. 여기서 &lt;code&gt;sbuf_&lt;/code&gt; 는 스트림 버퍼에 대한 저장된 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="141cb43c20eeabe7572fd03d0044e60b4fa23f86" translate="yes" xml:space="preserve">
          <source>Advances the iterator on the next match.</source>
          <target state="translated">다음 경기에서 이터레이터를 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="041d757eb7a9bbdbe12db3d41c780db95f87a90c" translate="yes" xml:space="preserve">
          <source>Advances the iterator on the next sub match.</source>
          <target state="translated">다음 서브 매치에서 이터레이터를 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="6539ad1eea9dd55e8e95ccfb1b1a314e60e23185" translate="yes" xml:space="preserve">
          <source>Advances the iterator to the next entry. Invalidates all copies of the previous value of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">반복자를 다음 항목으로 전진시킵니다. 이전 값 &lt;code&gt;*this&lt;/code&gt; 의 모든 사본을 무효화합니다 .</target>
        </trans-unit>
        <trans-unit id="78b5c8f29ae07de10df28f52834a61b1bdbbd82b" translate="yes" xml:space="preserve">
          <source>Advances the iterator.</source>
          <target state="translated">반복자를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="207287a093e89e5bc03f0303474f506b39d8c2b3" translate="yes" xml:space="preserve">
          <source>After &lt;b&gt;erasure&lt;/b&gt;, are...</source>
          <target state="translated">&lt;b&gt;삭제&lt;/b&gt; 후 ...</target>
        </trans-unit>
        <trans-unit id="4f0adbf879d7bad6224d512c2918e8643c30107f" translate="yes" xml:space="preserve">
          <source>After &lt;b&gt;insertion&lt;/b&gt;, are...</source>
          <target state="translated">&lt;b&gt;삽입&lt;/b&gt; 후 ...</target>
        </trans-unit>
        <trans-unit id="88341f67098f03a0da3cea31a839663a0bc13b2c" translate="yes" xml:space="preserve">
          <source>After a</source>
          <target state="translated">후</target>
        </trans-unit>
        <trans-unit id="a061077fb09465352c22016448276d1996de8a86" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt;, dynamic streams become frozen automatically. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;ostrstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 호출하면 동적 스트림이 자동으로 고정됩니다. 이 &lt;code&gt;ostrstream&lt;/code&gt; 오브젝트가 작성된 범위를 종료하기 전에 &lt;code&gt;freeze(false)&lt;/code&gt; 호출 해야합니다 . 그렇지 않으면 소멸자가 메모리를 누출시킵니다. 또한 할당 된 버퍼의 끝에 도달하면 고정 된 스트림으로의 추가 출력이 잘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a539ff8b097686cd8f474897e86e0367fc84dba2" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt;, dynamic streams become frozen automatically. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;strstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 호출하면 동적 스트림이 자동으로 고정됩니다. 이 &lt;code&gt;strstream&lt;/code&gt; 오브젝트가 작성된 범위를 종료하기 전에 &lt;code&gt;freeze(false)&lt;/code&gt; 호출 해야합니다 . 그렇지 않으면 소멸자가 메모리를 누출시킵니다. 또한 할당 된 버퍼의 끝에 도달하면 고정 된 스트림으로의 추가 출력이 잘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eb647e196d16c21c41ab1c8527d9b7e8b2a6ba0" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;str()&lt;/code&gt;, dynamic streams become frozen. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;ostrstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer, which may leave the buffer not null-terminated.</source>
          <target state="translated">&lt;code&gt;str()&lt;/code&gt; 호출하면 동적 스트림이 고정됩니다. 이 &lt;code&gt;ostrstream&lt;/code&gt; 오브젝트가 작성된 범위를 종료하기 전에 &lt;code&gt;freeze(false)&lt;/code&gt; 호출 해야합니다 . 그렇지 않으면 소멸자가 메모리를 누출시킵니다. 또한, 할당 된 버퍼의 끝에 도달하면 고정 된 스트림으로의 추가 출력이 잘릴 수 있으며, 이로 인해 버퍼가 널 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44cdb0260695b6e760f2d33d6208f4bfff7fe216" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;str()&lt;/code&gt;, dynamic streams become frozen. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;strstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer, which may leave the buffer not null-terminated.</source>
          <target state="translated">&lt;code&gt;str()&lt;/code&gt; 호출하면 동적 스트림이 고정됩니다. 이 &lt;code&gt;strstream&lt;/code&gt; 오브젝트가 작성된 범위를 종료하기 전에 &lt;code&gt;freeze(false)&lt;/code&gt; 호출 해야합니다 . 그렇지 않으면 소멸자가 메모리를 누출시킵니다. 또한, 할당 된 버퍼의 끝에 도달하면 고정 된 스트림으로의 추가 출력이 잘릴 수 있으며, 이로 인해 버퍼가 널 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9daa7be1c203f1734014387e6ddd71754a92603" translate="yes" xml:space="preserve">
          <source>After a call to one of these functions, &lt;code&gt;ok()&lt;/code&gt; is always true if no overflow occurred during the operation.</source>
          <target state="translated">이러한 함수 중 하나를 호출 한 후 작업 중에 오버플로가 발생하지 않으면 &lt;code&gt;ok()&lt;/code&gt; 는 항상 true입니다.</target>
        </trans-unit>
        <trans-unit id="85753ca571347a3ec5bab8ac7f1155da1ea5f3fa" translate="yes" xml:space="preserve">
          <source>After a call to one of these functions, &lt;code&gt;ok()&lt;/code&gt; is always true.</source>
          <target state="translated">이러한 함수 중 하나를 호출 한 후 &lt;code&gt;ok()&lt;/code&gt; 는 항상 true입니다.</target>
        </trans-unit>
        <trans-unit id="b0d14c1273920c43e0727fafe465d22e6d51d0cb" translate="yes" xml:space="preserve">
          <source>After all macro expansion and evaluation of &lt;code&gt;defined&lt;/code&gt;and &lt;code&gt;__has_include&lt;/code&gt;(since C++17) expressions, any identifier which is not a &lt;a href=&quot;../language/bool_literal&quot;&gt;boolean literal&lt;/a&gt; is replaced with the number &lt;code&gt;​0​&lt;/code&gt; (this includes identifiers that are lexically keywords, but not alternative tokens like &lt;code&gt;and&lt;/code&gt;).</source>
          <target state="translated">모든 매크로 팽창 및 평가 후 &lt;code&gt;defined&lt;/code&gt; 및 &lt;code&gt;__has_include&lt;/code&gt; 식 (C ++ 17 보낸)하지 않은 임의의 식별자 &lt;a href=&quot;../language/bool_literal&quot;&gt;부울 리터럴&lt;/a&gt; 번호로 대체 &lt;code&gt;​0​&lt;/code&gt; (이 어휘 키워드이다 식별자하지만 좋아하지 대체 토큰 포함 &lt;code&gt;and&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b09013ce3cd67396c7277e3bcafa2ffe1562348b" translate="yes" xml:space="preserve">
          <source>After all static initialization is completed, dynamic initialization of non-local variables occurs in the following situations:</source>
          <target state="translated">모든 정적 초기화가 완료된 후 다음 상황에서 로컬이 아닌 변수의 동적 초기화가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="35dd559617a4f18a5460a7d2ed6280a6a78170b4" translate="yes" xml:space="preserve">
          <source>After any call to &lt;code&gt;str()&lt;/code&gt; on a stream with a dynamic buffer, a call to &lt;code&gt;freeze(false)&lt;/code&gt; is required to allow the &lt;code&gt;strstreambuf&lt;/code&gt; destructor to deallocate the buffer when necessary.</source>
          <target state="translated">동적 버퍼가있는 스트림 에서 &lt;code&gt;str()&lt;/code&gt; 을 호출 한 후 , 필요한 경우 &lt;code&gt;strstreambuf&lt;/code&gt; 소멸자가 버퍼를 할당 해제 할 수 있도록 &lt;code&gt;freeze(false)&lt;/code&gt; 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="1bff9fbc15a1512d56427c0bac69b8131756695d" translate="yes" xml:space="preserve">
          <source>After any call to &lt;code&gt;str()&lt;/code&gt;, a call to &lt;code&gt;freeze(false)&lt;/code&gt; is required to allow the destructor to deallocate the buffer as necessary.</source>
          <target state="translated">&lt;code&gt;str()&lt;/code&gt; 호출 한 후 소멸자가 필요에 따라 버퍼를 할당 해제 할 수 있도록 &lt;code&gt;freeze(false)&lt;/code&gt; 호출 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a783411c667be5aeca25a2e7d260e7d91749c14d" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;detach&lt;/code&gt;&lt;code&gt;*this&lt;/code&gt; no longer owns any thread.</source>
          <target state="translated">&lt;code&gt;detach&lt;/code&gt; 를 호출 &lt;code&gt;*this&lt;/code&gt; 더 이상 스레드를 소유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d81c3a85f42719a311033e306e37b8e8b9fb3c51" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;share&lt;/code&gt; on a &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;valid()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;== false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;share&lt;/code&gt; 를 호출 한 후 &lt;a href=&quot;valid&quot;&gt; &lt;code&gt;valid()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;== false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d8a56377919a429bed8801b85b079d1d09d9b97f" translate="yes" xml:space="preserve">
          <source>After calling the rvalue overloads (2,4,6,8), &lt;code&gt;r&lt;/code&gt; is empty and &lt;code&gt;r.get() == nullptr&lt;/code&gt;, except that &lt;code&gt;r&lt;/code&gt; is not modified for &lt;code&gt;dynamic_pointer_cast&lt;/code&gt;(4) if the &lt;code&gt;dynamic_cast&lt;/code&gt; fails.</source>
          <target state="translated">rvalue 오버로드 (2,4,6,8)를 호출 한 후 &lt;code&gt;dynamic_cast&lt;/code&gt; 가 실패하는 경우 &lt;code&gt;r&lt;/code&gt; 이 &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; (4)에 대해 수정되지 않는 것을 제외하고 &lt;code&gt;r&lt;/code&gt; 은 비어 있고 &lt;code&gt;r.get() == nullptr&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a43ab890db9a9d7fd099d5804cec46453734ffa7" translate="yes" xml:space="preserve">
          <source>After considering every P and A in both directions, if, for each type that was considered,</source>
          <target state="translated">고려 된 각 유형에 대해 모든 P와 A를 양방향으로 고려한 후,</target>
        </trans-unit>
        <trans-unit id="cde16484b3a6dce1a5a73f1d71d4d5f94eda1f7f" translate="yes" xml:space="preserve">
          <source>After container move assignment (overload (2)), unless elementwise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">컨테이너 이동 할당 후 (과부하 (2)), elementwise 이동 할당이 호환되지 않는 할당 자, 참조, 포인터, 그리고에 반복자 (끝 반복자 제외)에 의해 강제되지 않는 한 &lt;code&gt;other&lt;/code&gt; 유효하지만, 지금있는 요소를 참조 &lt;code&gt;*this&lt;/code&gt; . 현재 표준은 &amp;sect;23.2.1 [container.requirements.general] / 12의 총괄 성명을 통해 이러한 보증을 수행하며 &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321을&lt;/a&gt; 통해보다 직접적인 보증이 고려되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1efd3ba5fab7d922cddedab135cbf68623f0fbb3" translate="yes" xml:space="preserve">
          <source>After container move construction (overload (4)), references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">컨테이너 이동 구성 (과부하 (4)) 후에도 참조, 포인터 및 반복자 (끝 반복자 &lt;code&gt;other&lt;/code&gt; 는 계속 유효하지만 &lt;code&gt;*this&lt;/code&gt; 에 있는 요소를 참조하십시오 . 현재 표준은 &amp;sect;23.2.1 [container.requirements.general] / 12의 총괄 성명을 통해 이러한 보증을 수행하며 &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321을&lt;/a&gt; 통해보다 직접적인 보증이 고려되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaca101a515420f6158015d9049a7c61e1020372" translate="yes" xml:space="preserve">
          <source>After container move construction (overload (6)), references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">컨테이너 이동 구성 (과부하 (6)) 후에도 참조, 포인터 및 반복자 (끝 반복자 &lt;code&gt;other&lt;/code&gt; 는 계속 유효하지만 &lt;code&gt;*this&lt;/code&gt; 에 있는 요소를 참조하십시오 . 현재 표준은 &amp;sect;23.2.1 [container.requirements.general] / 12의 총괄 성명을 통해 이러한 보증을 수행하며 &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321을&lt;/a&gt; 통해보다 직접적인 보증이 고려되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb3e0e585b7b35a447a3da6d3ae0da5248da92b" translate="yes" xml:space="preserve">
          <source>After encountering the &lt;code&gt;#error&lt;/code&gt; directive, an implementation displays the diagnostic message error_message and renders the program ill-formed (the compilation stops).</source>
          <target state="translated">&lt;code&gt;#error&lt;/code&gt; 지시문을 만나면 구현시 진단 메시지 error_message가 표시되고 프로그램이 잘못된 형식으로 표시됩니다 (컴파일이 중지됨).</target>
        </trans-unit>
        <trans-unit id="1d2d75b0b4cf172aa9246ff178f69aced36a5e9c" translate="yes" xml:space="preserve">
          <source>After evaluating &lt;code&gt;lhs = rhs&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;lhs = rhs&lt;/code&gt; 평가 한 후 :</target>
        </trans-unit>
        <trans-unit id="45a5bba2318081758d338e6bc0ad55114ce64350" translate="yes" xml:space="preserve">
          <source>After one of the two templates was transformed as described above, &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; is executed using the transformed template as the argument template and the original template type of the other template as the parameter template. The process is then repeated using the second template (after transformations) as the argument and the first template in its original form as the parameter.</source>
          <target state="translated">위에서 설명한대로 두 템플릿 중 하나를 변환 한 후 변환 된 템플릿을 인수 템플릿으로 사용하고 다른 템플릿의 원래 템플릿 유형을 매개 변수 템플릿으로 사용하여 &lt;a href=&quot;template_argument_deduction&quot;&gt;템플릿 인수 공제&lt;/a&gt; 를 실행합니다. 그런 다음 두 번째 템플리트 (변환 후)를 인수로 사용하고 첫 번째 템플리트를 원래 양식의 매개 변수로 사용하여 프로세스를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="37697aac1a5eff809b30503e048e426d91ee09c0" translate="yes" xml:space="preserve">
          <source>After seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.</source>
          <target state="translated">넓은 스트림에서 비 종료 위치를 찾은 후, 임의의 출력 함수에 대한 다음 호출은 예를 들어, 다른 길이의 멀티 바이트 시퀀스를 출력함으로써 파일의 나머지를 정의되지 않을 수있다.</target>
        </trans-unit>
        <trans-unit id="6723da668a7284d1e0d9c856af9a4e60e17d6599" translate="yes" xml:space="preserve">
          <source>After substitution, all function parameters of array and function type are adjusted to pointers and all top-level cv-qualifiers are dropped from function parameters (as in a regular &lt;a href=&quot;function#Function_declaration&quot;&gt;function declaration&lt;/a&gt;).</source>
          <target state="translated">대체 후에는 배열 및 함수 유형의 모든 함수 매개 변수가 포인터로 조정되고 모든 최상위 cv 한정자가 함수 매개 변수에서 삭제됩니다 (일반 &lt;a href=&quot;function#Function_declaration&quot;&gt;함수 선언&lt;/a&gt; 에서처럼 ).</target>
        </trans-unit>
        <trans-unit id="799039415462a10354f545fe871b500eacc988ea" translate="yes" xml:space="preserve">
          <source>After that, whether or not an exception was thrown by any destructor, the delete expression invokes the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt; deallocation function&lt;/a&gt;: either &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; (for the first version of the expression) or &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; (for the second version of the expression), unless the matching new-expression was combined with another new-expression(since C++14).</source>
          <target state="translated">그 후, 소멸자에 의해 예외가 발생했는지 여부에 관계없이 delete 표현식은 &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;할당 취소 기능을&lt;/a&gt; 호출합니다 . &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; (표현식의 경우) 또는 &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; (표현식의 두 번째 버전) 일치하는 새로운 표현은 다른 새로운 표현과 결합되었습니다 (C ++ 14 이후).</target>
        </trans-unit>
        <trans-unit id="e0b82e4b58314156b84c6c073fedd13df3c06173" translate="yes" xml:space="preserve">
          <source>After the associated set of classes and namespaces is determined, all declarations found in classes of this set are discarded for the purpose of further ADL processing, except namespace-scoped friend functions and function templates, as stated in point 2 below .</source>
          <target state="translated">연관된 클래스 및 네임 스페이스 세트가 결정된 후이 포인트의 클래스에서 발견 된 모든 선언은 네임 스페이스 범위의 친구 함수 및 함수 템플리트를 제외한 추가 ADL 처리를 위해 폐기됩니다 (아래 2 항 참조).</target>
        </trans-unit>
        <trans-unit id="a30be8c196cfecdbad0fc0881a76a52f9af12d23" translate="yes" xml:space="preserve">
          <source>After the call &lt;code&gt;getloc() == loc&lt;/code&gt;.</source>
          <target state="translated">통화 후 &lt;code&gt;getloc() == loc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b157835cfa6ec4fc0f1fce8dc684fe4a88600d3" translate="yes" xml:space="preserve">
          <source>After the call, the value of &lt;code&gt;t&lt;/code&gt; is the value held by &lt;code&gt;u&lt;/code&gt; before the call, and the value of &lt;code&gt;u&lt;/code&gt; is the value held by &lt;code&gt;t&lt;/code&gt; before the call.</source>
          <target state="translated">호출되면, 값 &lt;code&gt;t&lt;/code&gt; 는 에 의해 유지되는 값 &lt;code&gt;u&lt;/code&gt; 를 호출하기 전에, 그리고 값 &lt;code&gt;u&lt;/code&gt; 는 에 의해 유지되는 값 &lt;code&gt;t&lt;/code&gt; 호출 전에.</target>
        </trans-unit>
        <trans-unit id="4cd3511e0d8d14569c23c73c7b91dc33ab8e711e" translate="yes" xml:space="preserve">
          <source>After the definition &lt;code&gt;T u = rv;&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt; is equal to &lt;code&gt;u2&lt;/code&gt;;</source>
          <target state="translated">정의 후 &lt;code&gt;T u = rv;&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; 동일하다 &lt;code&gt;u2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3d30d64981287500c819b1f90ccbf12490e9f92c" translate="yes" xml:space="preserve">
          <source>After the definition &lt;code&gt;T u = v;&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt; is equal to &lt;code&gt;v&lt;/code&gt;;</source>
          <target state="translated">정의 후 &lt;code&gt;T u = v;&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; 동일하다 &lt;code&gt;v&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0c6c90fd32023a18a6a7da6b1f777294338454a9" translate="yes" xml:space="preserve">
          <source>After the destruction, the smart pointers that shared ownership with &lt;code&gt;*this&lt;/code&gt;, if any, will report a &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count()&lt;/a&gt;&lt;/code&gt; that is one less than its previous value.</source>
          <target state="translated">삭제 후 &lt;code&gt;*this&lt;/code&gt; 와 소유권을 공유 한 스마트 포인터 는 이전 값보다 1이 작은 &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count()&lt;/a&gt;&lt;/code&gt; 를 보고 합니다.</target>
        </trans-unit>
        <trans-unit id="d2d0310f3096791666afb21ddf68713192d5f5d5" translate="yes" xml:space="preserve">
          <source>After the error condition is reported by a function, additional guarantees may be provided with regards to the state of the program. The following four levels of exception guarantee are generally recognized&lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;exceptions#cite_note-4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;exceptions#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-6&quot;&gt;&lt;a href=&quot;exceptions#cite_note-6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt;, which are strict supersets of each other:</source>
          <target state="translated">기능에 의해 오류 상태가보고 된 후 프로그램 상태와 관련하여 추가 보증이 제공 될 수 있습니다. 다음과 같은 4 가지 수준의 예외 보증은 일반적으로 인정되며 &lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;exceptions#cite_note-4&quot;&gt;[4] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;exceptions#cite_note-5&quot;&gt;[5] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-6&quot;&gt;&lt;a href=&quot;exceptions#cite_note-6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt; 은 서로의 상위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="5b29961c177bd98d620f93782ce1efd7215c74a8" translate="yes" xml:space="preserve">
          <source>After the standard library deallocation function returns, all pointers referring to any part of the deallocated storage become invalid.</source>
          <target state="translated">표준 라이브러리 할당 해제 함수가 반환되면 할당 해제 된 저장소의 일부를 참조하는 모든 포인터가 유효하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="d0f96cdce258dfc61390cebc0e99878ba570d5a1" translate="yes" xml:space="preserve">
          <source>After these adjustments, deduction of &lt;code&gt;P&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; is done following &lt;a href=&quot;template_argument_deduction#Deduction_from_a_type&quot;&gt;template argument deduction from a type&lt;/a&gt;.</source>
          <target state="translated">이러한 조정 후에 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;P&lt;/code&gt; 의&lt;a href=&quot;template_argument_deduction#Deduction_from_a_type&quot;&gt;공제는 유형에서 템플릿 인수 공제에&lt;/a&gt; 따라 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d3d82b04f2207d9d6bcf7a9bbc105dd774ee13b" translate="yes" xml:space="preserve">
          <source>After these transformations, the deduction processes as described below (cf. section &quot;Deduction from type&quot;) and attempts to find such template arguments that would make the deduced &lt;code&gt;A&lt;/code&gt; (that is, &lt;code&gt;P&lt;/code&gt; after adjustments listed above and the substitution of the deduced template parameters) identical to the</source>
          <target state="translated">이러한 변환 후, 추론은 아래 설명 된대로 ( &quot;섹션에서 추론&quot;섹션 참조) 처리되고 추론 된 &lt;code&gt;A&lt;/code&gt; (즉, 위에 나열된 조정 후 &lt;code&gt;P&lt;/code&gt; 및 추론 된 템플리트 매개 변수의 대체 후 P) 를 작성하는 템플리트 인수를 찾으려고 시도합니다. )와 동일</target>
        </trans-unit>
        <trans-unit id="cbfa05ba4a64164c2c06108c94e66a0d15618966" translate="yes" xml:space="preserve">
          <source>After this call, &lt;code&gt;other&lt;/code&gt; has no associated mutex.</source>
          <target state="translated">이 호출 후 &lt;code&gt;other&lt;/code&gt; 뮤텍스는 없습니다.</target>
        </trans-unit>
        <trans-unit id="09e6d08a70617f303ffde1bea6a795b13dc7771a" translate="yes" xml:space="preserve">
          <source>After this call, &lt;code&gt;this-&amp;gt;get_id()&lt;/code&gt; is equal to the value of &lt;code&gt;other.get_id()&lt;/code&gt; prior to the call, and &lt;code&gt;other&lt;/code&gt; no longer represents a thread of execution.</source>
          <target state="translated">통화를 종료 한 후 &lt;code&gt;this-&amp;gt;get_id()&lt;/code&gt; 의 값과 동일 &lt;code&gt;other.get_id()&lt;/code&gt; 호출 이전에, 그리고 &lt;code&gt;other&lt;/code&gt; 더 이상 실행 스레드를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="8c87604fd723b0f75058b0139b052da68fd8a53e" translate="yes" xml:space="preserve">
          <source>After this function completes, &lt;a href=&quot;has_path&quot;&gt;&lt;code&gt;has_filename&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 함수가 완료되면 &lt;a href=&quot;has_path&quot;&gt; &lt;code&gt;has_filename&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="af11ceb4dfc69bc2e19a600385c6a2e921b44982" translate="yes" xml:space="preserve">
          <source>After this operation &lt;code&gt;r&lt;/code&gt; is not required to be dereferenceable and any copies of the previous value of &lt;code&gt;r&lt;/code&gt; are no longer required to be dereferenceable or incrementable.</source>
          <target state="translated">이 작업 후에 &lt;code&gt;r&lt;/code&gt; 은 역 참조 가 필요하지 않으며 &lt;code&gt;r&lt;/code&gt; 의 이전 값의 사본 은 더 이상 역 참조 또는 증분이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6b3e4110c978c6c966e175d0fb21c24d0cb55b2" translate="yes" xml:space="preserve">
          <source>After this operation &lt;code&gt;r&lt;/code&gt; is not required to be incrementable and any copies of the previous value of &lt;code&gt;r&lt;/code&gt; are no longer required to be dereferenceable or incrementable.</source>
          <target state="translated">이 작업 후에 &lt;code&gt;r&lt;/code&gt; 을 증분 할 필요가없고 이전 &lt;code&gt;r&lt;/code&gt; 값의 사본을 더 이상 역 참조 또는 증분 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5cb3c3ab15a7948ac9776fc01389be53890f7bf1" translate="yes" xml:space="preserve">
          <source>After this statement the control is transferred to the statement immediately following the enclosing loop or switch. As with any block exit, all automatic storage objects declared in enclosing compound statement or in the condition of a loop/switch are destroyed, in reverse order of construction, before the execution of the first line following the enclosing loop.</source>
          <target state="translated">이 명령문 이후 제어는 엔 클로징 루프 또는 스위치 바로 다음에 명령문으로 전송됩니다. 모든 블록 종료와 마찬가지로, 엔 클로징 복합 명령문 또는 루프 / 스위치 조건에서 선언 된 모든 자동 스토리지 오브젝트는 엔 클로징 루프 다음의 첫 번째 행을 실행하기 전에 구성 순서와 반대로 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="fd175daec3ba5a5ff832d7613dfb6df9054a3994" translate="yes" xml:space="preserve">
          <source>After this, digit grouping is checked. if the position of any of the thousands separators discarded in Stage 2 does not match the grouping provided by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">그런 다음 숫자 그룹화가 확인됩니다. 2 단계에서 삭제 된 천 단위 구분 기호의 위치가 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt; 에서 제공 한 그룹화와 일치하지 않는 경우 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;err&lt;/code&gt; 에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d93b73971332d0c3efd8634484908552ab34c9a" translate="yes" xml:space="preserve">
          <source>Afterwards, &lt;code&gt;p&lt;/code&gt; is equivalent to &lt;code&gt;nullptr&lt;/code&gt;</source>
          <target state="translated">이후 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;nullptr&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="795da143b5dbe81dcf8c6232ccf436d09b14c393" translate="yes" xml:space="preserve">
          <source>Aggregate initialization</source>
          <target state="translated">집계 초기화</target>
        </trans-unit>
        <trans-unit id="32f6926454c3165c26d9dc05c16b8b6e9f95c8bb" translate="yes" xml:space="preserve">
          <source>Aggregate initialization initializes</source>
          <target state="translated">집계 초기화 초기화</target>
        </trans-unit>
        <trans-unit id="ce0cf7c09d177b646d6d216478f49a68396c308c" translate="yes" xml:space="preserve">
          <source>Aggregates copy/move initialize directly from single-element braced-init-lists of the same type, but non-aggregates consider initializer_list constructors first:</source>
          <target state="translated">집계는 동일한 유형의 단일 요소 braced-init-list에서 직접 복사 / 이동 초기화하지만 집계되지 않은 사용자는 initializer_list 생성자를 먼저 고려합니다.</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="e8a0f2b8083d5e86992465667615250c3f737a35" translate="yes" xml:space="preserve">
          <source>Algorithm concepts and utilities</source>
          <target state="translated">알고리즘 개념 및 유틸리티</target>
        </trans-unit>
        <trans-unit id="b03f71c0b2a6d1e175830b00066b005660a7079a" translate="yes" xml:space="preserve">
          <source>Algorithm utilities</source>
          <target state="translated">알고리즘 유틸리티</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="6886e87f506cf00f362a34227ad744fd6fcd6652" translate="yes" xml:space="preserve">
          <source>Algorithms library</source>
          <target state="translated">알고리즘 라이브러리</target>
        </trans-unit>
        <trans-unit id="b1d4c8b0854335cb6dc181f5d361a3a9a6c77f1d" translate="yes" xml:space="preserve">
          <source>Algorithms that operate on ranges</source>
          <target state="translated">범위에서 작동하는 알고리즘</target>
        </trans-unit>
        <trans-unit id="8d55ef673ad6d9815c8fe83971681410e8111110" translate="yes" xml:space="preserve">
          <source>Alias declarations are &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt; with the following syntax:</source>
          <target state="translated">별명 선언은 다음 구문을 사용한 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac7adb6d456a732926b16ac92fea1efb425fa68c" translate="yes" xml:space="preserve">
          <source>Alias template is a name that refers to a family of types.</source>
          <target state="translated">별명 템플리트는 유형 계열을 나타내는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="536ee4b3a1593a51e4e7a02e531109ebfa1e7aa5" translate="yes" xml:space="preserve">
          <source>Alias templates</source>
          <target state="translated">별칭 템플릿</target>
        </trans-unit>
        <trans-unit id="81fdfe39ee9314fa8adbdd24c8cefa9e67062042" translate="yes" xml:space="preserve">
          <source>Alias templates are never deduced by &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; when deducing a template template parameter.  It is not possible to &lt;a href=&quot;partial_specialization&quot;&gt;partially&lt;/a&gt; or &lt;a href=&quot;template_specialization&quot;&gt;explicitly specialize&lt;/a&gt; an alias template.</source>
          <target state="translated">템플릿 템플릿 매개 변수를 추론 할 때 별칭 템플릿은 &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;템플릿 인수&lt;/a&gt; 추론에 의해 추론되지 않습니다 . 별명 템플리트 를 &lt;a href=&quot;partial_specialization&quot;&gt;부분적으로&lt;/a&gt; 또는 &lt;a href=&quot;template_specialization&quot;&gt;명시 적으로 특수화&lt;/a&gt; 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="a2aba61989bb9dc7a1e9fe034611bf7295de52c9" translate="yes" xml:space="preserve">
          <source>Alignment (as obtained by &lt;code&gt;alignof&lt;/code&gt;) has the type &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, but placement forms of allocation and deallocation functions that take &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; as an additional parameter are already in use, so this type is used instead.</source>
          <target state="translated">Alignment ( &lt;code&gt;alignof&lt;/code&gt; 에 의해 얻은 )는 &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 유형을 갖지만 &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 를 추가 매개 변수로 사용하는 할당 및 할당 해제 함수의 배치 양식 이 이미 사용 중이므로이 유형이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1284e78e088763e07d38bdc498c7ac19fcd9faaa" translate="yes" xml:space="preserve">
          <source>Alignment specifier</source>
          <target state="translated">정렬 지정자</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="c533be78046b2b7438a7f5af4856db7635ad0dde" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../container&quot;&gt;standard library containers&lt;/a&gt; require that their element type satisfies Erasable.</source>
          <target state="translated">모든 &lt;a href=&quot;../container&quot;&gt;표준 라이브러리 컨테이너&lt;/a&gt; 는 해당 요소 유형이 지울 수 있음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad583fce81393d0c4c343ed80041c1cf855fb389" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../language/pointer#Pointers_to_functions&quot;&gt;pointers to functions&lt;/a&gt; satisfy this requirement.</source>
          <target state="translated">&lt;a href=&quot;../language/pointer#Pointers_to_functions&quot;&gt;함수에 대한&lt;/a&gt; 모든 포인터 는이 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="85e52ab157feeaab3392116ff6342f562d88a7b4" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;objects&quot;&gt;objects&lt;/a&gt; in a program have one of the following storage durations:</source>
          <target state="translated">프로그램의 모든 &lt;a href=&quot;objects&quot;&gt;오브젝트&lt;/a&gt; 는 다음 저장 기간 중 하나를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2be019deb6ca8794e180ab1025f12fa6403846db" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;randomnumberengine&quot;&gt;RandomNumberEngines&lt;/a&gt; satisfy this requirement.</source>
          <target state="translated">모든 &lt;a href=&quot;randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt; 은이 요구 사항을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="5586b0fcd654b42e2d7df9c2c898d38125873577" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;const&lt;/code&gt; member functions can be called concurrently by different threads on the same container. In addition, the member functions &lt;code&gt;begin()&lt;/code&gt;, &lt;code&gt;end()&lt;/code&gt;, &lt;code&gt;rbegin()&lt;/code&gt;, &lt;code&gt;rend()&lt;/code&gt;, &lt;code&gt;front()&lt;/code&gt;, &lt;code&gt;back()&lt;/code&gt;, &lt;code&gt;data()&lt;/code&gt;, &lt;code&gt;find()&lt;/code&gt;, &lt;code&gt;lower_bound()&lt;/code&gt;, &lt;code&gt;upper_bound()&lt;/code&gt;, &lt;code&gt;equal_range()&lt;/code&gt;, &lt;code&gt;at()&lt;/code&gt;, and, except in associative containers, &lt;code&gt;operator[]&lt;/code&gt;, behave as &lt;code&gt;const&lt;/code&gt; for the purposes of thread safety (that is, they can also be called concurrently by different threads on the same container). More generally, the C++ standard library functions do not modify objects unless those objects are accessible, directly or indirectly, via the function's non-const arguments, including the this pointer.</source>
          <target state="translated">모든 &lt;code&gt;const&lt;/code&gt; 멤버 함수는 같은 용기에 다른 스레드가 동시에 호출 할 수 있습니다. 또한 멤버 함수 &lt;code&gt;begin()&lt;/code&gt; , &lt;code&gt;end()&lt;/code&gt; , &lt;code&gt;rbegin()&lt;/code&gt; , &lt;code&gt;rend()&lt;/code&gt; , &lt;code&gt;front()&lt;/code&gt; , &lt;code&gt;back()&lt;/code&gt; , &lt;code&gt;data()&lt;/code&gt; , &lt;code&gt;find()&lt;/code&gt; , &lt;code&gt;lower_bound()&lt;/code&gt; , &lt;code&gt;upper_bound()&lt;/code&gt; , &lt;code&gt;equal_range()&lt;/code&gt; , &lt;code&gt;at()&lt;/code&gt; , 그리고 연관 컨테이너를 제외하고 &lt;code&gt;operator[]&lt;/code&gt; 는 &lt;code&gt;const&lt;/code&gt; 로 동작합니다스레드 안전성을 위해 (즉, 동일한 컨테이너의 다른 스레드에 의해 동시에 호출 될 수도 있음). 보다 일반적으로, C ++ 표준 라이브러리 함수는 this 포인터를 포함하여 함수의 비 const 인수를 통해 직접 또는 간접적으로 액세스 할 수있는 경우가 아니면 오브젝트를 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ce574fe03a26ad67fb18ae15f6d204f756c8e28" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;const&lt;/code&gt; member functions of &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; are provided.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 의 모든 &lt;code&gt;const&lt;/code&gt; 멤버 함수 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e4c5afaf4fff1d58306c2cfe530397e8446742a3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;emit()&lt;/code&gt; calls transferring characters to the same wrapped stream buffer object appear to execute in a total order, where each &lt;code&gt;emit()&lt;/code&gt; call &lt;a href=&quot;../../atomic/memory_order&quot;&gt;synchronizes-with&lt;/a&gt; subsequent &lt;code&gt;emit()&lt;/code&gt; calls in that total order, even if these calls are made through difference instances of &lt;code&gt;std::basic_syncbuf&lt;/code&gt;/&lt;code&gt;std::basic_osyncstream&lt;/code&gt;. In practice, this means that emit() takes a lock uniquely associated with the wrapped stream object: for example, it could be held in a static hash map where the address of the wrapped stream is used as the key.</source>
          <target state="translated">모든 &lt;code&gt;emit()&lt;/code&gt; 각각의 전체 순서에서 실행 나타나는 동일한 래핑 스트림 버퍼 개체자를 전송 호출 &lt;code&gt;emit()&lt;/code&gt; 호 &lt;a href=&quot;../../atomic/memory_order&quot;&gt;를 동기화-와&lt;/a&gt; 후속 &lt;code&gt;emit()&lt;/code&gt; 이들 통화가 차분 인스턴스 통한 경우에도, 그 합계 위해 호출 의 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; / &lt;code&gt;std::basic_osyncstream&lt;/code&gt; . 실제로 이것은 emit ()가 랩핑 된 스트림 객체와 고유하게 연관된 잠금을 취함을 의미합니다. 예를 들어 랩핑 된 스트림의 주소가 키로 사용되는 정적 해시 맵에 보유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e7989631f4fa0b7b123c5eceab25241a651d43" translate="yes" xml:space="preserve">
          <source>All Function objects defined in &lt;a href=&quot;../header/functional&quot;&gt;&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../header/functional&quot;&gt; &lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 Function 객체</target>
        </trans-unit>
        <trans-unit id="267678e718109eec99ac63d1e0c78b1e78e6bc72" translate="yes" xml:space="preserve">
          <source>All arithmetic operators compute the result of specific arithmetic operation and returns its result. The arguments are not modified.</source>
          <target state="translated">모든 산술 연산자는 특정 산술 연산의 결과를 계산하고 결과를 반환합니다. 인수는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2196ca16119493aee11e0e86a9a7193062fd552b" translate="yes" xml:space="preserve">
          <source>All atomic types except for &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 제외한 모든 원자 유형 은 잠금없는 원자 CPU 명령을 사용하는 대신 뮤텍스 또는 기타 잠금 작업을 사용하여 구현할 수 있습니다. 원자 유형도 가능합니다</target>
        </trans-unit>
        <trans-unit id="acf874c1ced8a0f3cff5567518c467d553d7b81d" translate="yes" xml:space="preserve">
          <source>All atomic types except for &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 제외한 모든 원자 유형 은 잠금없는 원자 CPU 명령을 사용하는 대신 뮤텍스 또는 기타 잠금 작업을 사용하여 구현할 수 있습니다. 원자 유형도 가능합니다</target>
        </trans-unit>
        <trans-unit id="1c6a82095fc35876e8565ece289c3317d10e940b" translate="yes" xml:space="preserve">
          <source>All built-in assignment operators return &lt;code&gt;*this&lt;/code&gt;, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;*this&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">모든 내장 할당 연산자는 &lt;code&gt;*this&lt;/code&gt; 를 반환 하고 대부분의 &lt;a href=&quot;operators&quot;&gt;사용자 정의 오버로드&lt;/a&gt; 도 &lt;code&gt;*this&lt;/code&gt; 를 반환 하므로 사용자 정의 연산자는 내장과 동일한 방식으로 사용될 수 있습니다. 그러나 사용자 정의 연산자 과부하에서는 모든 유형을 리턴 유형 ( &lt;code&gt;void&lt;/code&gt; 포함 ) 으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e3f7702614f1e201b0d2d7ca9cab6129fd842e0" translate="yes" xml:space="preserve">
          <source>All built-in operators return &lt;code&gt;bool&lt;/code&gt;, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;bool&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">모든 내장 연산자는 &lt;code&gt;bool&lt;/code&gt; 을 반환 하고 대부분의 &lt;a href=&quot;operators&quot;&gt;사용자 정의 오버로드&lt;/a&gt; 는 &lt;code&gt;bool&lt;/code&gt; 을 반환 하므로 사용자 정의 연산자를 내장과 동일한 방식으로 사용할 수 있습니다. 그러나 사용자 정의 연산자 과부하에서는 모든 유형을 리턴 유형 ( &lt;code&gt;void&lt;/code&gt; 포함 ) 으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad44cda1026b661b30b82e23a1cc8e4adc8dad82" translate="yes" xml:space="preserve">
          <source>All built-in operators return values, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return values so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;). In particular, stream insertion and stream extraction overloads of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; return &lt;code&gt;T&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">모든 내장 연산자는 값을 반환하고 대부분의 &lt;a href=&quot;operators&quot;&gt;사용자 정의 오버로드&lt;/a&gt; 도 값을 반환하므로 사용자 정의 연산자를 내장과 동일한 방식으로 사용할 수 있습니다. 그러나 사용자 정의 연산자 과부하에서는 모든 유형을 리턴 유형 ( &lt;code&gt;void&lt;/code&gt; 포함 ) 으로 사용할 수 있습니다 . 특히 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 의 스트림 삽입 및 스트림 추출 과부하는 &lt;code&gt;T&amp;amp;&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4c15cf3f5d785f05b074208b892da42654f696fb" translate="yes" xml:space="preserve">
          <source>All comments are removed from the program at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 3&lt;/a&gt; by replacing each comment with a single whitespace character.</source>
          <target state="translated">각 주석을 단일 공백 ​​문자로 바꾸면 &lt;a href=&quot;language/translation_phases&quot;&gt;번역 단계 3&lt;/a&gt; 에서 모든 주석이 프로그램에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf78ad8fede01661fec9052125328b1508f2f4d8" translate="yes" xml:space="preserve">
          <source>All comparison operators are short-circuited; they do not access tuple elements beyond what is necessary to determine the result of the comparison.</source>
          <target state="translated">모든 비교 연산자가 단락되었습니다. 비교 결과를 결정하는 데 필요한 것 이상으로 튜플 요소에 액세스하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d086b64161b8d9aca02f8348f6309d2102ee1278" translate="yes" xml:space="preserve">
          <source>All comparisons are done via the &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; member function (which itself is defined in terms of &lt;code&gt;Traits::compare()&lt;/code&gt;):</source>
          <target state="translated">모든 비교는 &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; 멤버 함수 (자체 자체가 &lt;code&gt;Traits::compare()&lt;/code&gt; 에 의해 정의 됨 ) 를 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8289f337cbc9bd64fef53be2978b84bf37ef44f" translate="yes" xml:space="preserve">
          <source>All constants, except for &lt;code&gt;match_default&lt;/code&gt; and &lt;code&gt;format_default&lt;/code&gt;, are bitmask elements. The &lt;code&gt;match_default&lt;/code&gt; and &lt;code&gt;format_default&lt;/code&gt; constants are empty bitmasks.</source>
          <target state="translated">&lt;code&gt;match_default&lt;/code&gt; 및 &lt;code&gt;format_default&lt;/code&gt; 를 제외한 모든 상수 는 비트 마스크 요소입니다. &lt;code&gt;match_default&lt;/code&gt; 및 &lt;code&gt;format_default&lt;/code&gt; 상수는 비어있는 비트 마스크입니다.</target>
        </trans-unit>
        <trans-unit id="dc168f2bceb154961bb7ed9909031e74d78d43a5" translate="yes" xml:space="preserve">
          <source>All constructors that take &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; as the only argument, or as the first argument if the remaining arguments have default values, are examined, and matched by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; against a single argument of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 를 유일한 인수로 사용하거나 나머지 인수에 기본값이있는 경우 첫 번째 인수로 사용하는 모든 생성자 는 검사되고 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 유형의 단일 인수에 대한 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결&lt;/a&gt; 과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2bcfde28187d671e9cbf776fb85caf9d73bb4df9" translate="yes" xml:space="preserve">
          <source>All container functions can be called concurrently by different threads on different containers. More generally, the C++ standard library functions do not read objects accessible by other threads unless those objects are directly or indirectly accessible via the function arguments, including the this pointer.</source>
          <target state="translated">모든 컨테이너 기능은 다른 컨테이너의 다른 스레드에서 동시에 호출 할 수 있습니다. 보다 일반적으로, C ++ 표준 라이브러리 함수는 this 포인터를 포함하여 함수 인수를 통해 직접 또는 간접적으로 액세스 할 수없는 경우 다른 스레드에서 액세스 할 수있는 객체를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36bd3ae32477cc666c63b1b73c2d5eb0bca71c31" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../../string/byte/isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 이외의 모든 변환 지정 자는 입력을 구문 분석하기 전에 모든 선행 공백 문자 ( &lt;a href=&quot;../../string/byte/isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; 를 호출하는 것처럼 결정됨)를 소비하고 버립니다 . 소비 된 문자는 지정된 최대 필드 너비에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2b014357acb5001a9291cf56269f10b96493516" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../../string/wide/iswspace&quot;&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 이외의 모든 변환 지정 자는 입력 구문 분석을 시도하기 전에 모든 선행 공백 문자 ( &lt;a href=&quot;../../string/wide/iswspace&quot;&gt; &lt;code&gt;iswspace&lt;/code&gt; &lt;/a&gt; 를 호출하는 것처럼 판별 됨)를 소비하고 삭제합니다 . 소비 된 문자는 지정된 최대 필드 너비에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbea028682ce84815358b5aa6eda3b614cfe993e" translate="yes" xml:space="preserve">
          <source>All custom allocators also must be stateless.</source>
          <target state="translated">모든 사용자 지정 할당자는 상태 비 저장이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e99bcc0ededa138f077034c407c38f0bfa9cb54b" translate="yes" xml:space="preserve">
          <source>All deallocation functions are &lt;code&gt;noexcept(true)&lt;/code&gt; unless specified otherwise in the declaration.</source>
          <target state="translated">선언에서 달리 지정하지 않는 한 모든 할당 해제 함수는 &lt;code&gt;noexcept(true)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7590e38178794abe168d1f61e5e605ebedab40ca" translate="yes" xml:space="preserve">
          <source>All direct base classes have trivial destructors</source>
          <target state="translated">모든 직접적인 기본 클래스에는 사소한 소멸자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1644548c66e07081be823b1a24493d9cfc6d493" translate="yes" xml:space="preserve">
          <source>All error codes are distinct and non-zero.</source>
          <target state="translated">모든 오류 코드는 고유하고 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4eb9393603f7bb0528b986591eb39bc9de40a1c4" translate="yes" xml:space="preserve">
          <source>All evaluations of &lt;code&gt;h(k)&lt;/code&gt;executed within a given execution of a program(since C++14) yield the same result for the same value of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">주어진 프로그램 실행 (C ++ 14 이후 &lt;code&gt;h(k)&lt;/code&gt; 내에서 실행 된 h (k) 의 모든 평가 는 동일한 &lt;code&gt;k&lt;/code&gt; 값에 대해 동일한 결과를 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="615556c95cd2277e3f2551bbe6ac5d7b7503c6b8" translate="yes" xml:space="preserve">
          <source>All exceptions generated by the standard library inherit from &lt;code&gt;std::exception&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리에 의해 생성 된 모든 예외는 &lt;code&gt;std::exception&lt;/code&gt; 상속 합니다.</target>
        </trans-unit>
        <trans-unit id="47496370c3026a6d2335b4c07d2899c2bfd0a9f8" translate="yes" xml:space="preserve">
          <source>All existing elements of &lt;code&gt;a&lt;/code&gt; are either move assigned to or destroyed; &lt;code&gt;a&lt;/code&gt; is equal to the value that &lt;code&gt;rv&lt;/code&gt; had before the assignment</source>
          <target state="translated">기존의 모든 요소 &lt;code&gt;a&lt;/code&gt; 하나에 할당되거나 파괴으로 이동된다 &lt;code&gt;a&lt;/code&gt; 는 할당 전에 &lt;code&gt;rv&lt;/code&gt; 가 가진 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b1c1c57702fcbfb1474e82ce403b1688060d643" translate="yes" xml:space="preserve">
          <source>All explicit and partial specializations of &lt;code&gt;hash&lt;/code&gt; provided by the standard library are &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; and &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;. User-provided specializations of &lt;code&gt;hash&lt;/code&gt; also must meet those requirements.</source>
          <target state="translated">표준 라이브러리가 제공하는 모든 명시 적 및 부분 &lt;code&gt;hash&lt;/code&gt; 전문화 는 &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; 및 &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; 입니다. 사용자가 제공 한 &lt;code&gt;hash&lt;/code&gt; 전문화 도 이러한 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3caef46757d5c781ce31db0ab1b1d011a7c9448" translate="yes" xml:space="preserve">
          <source>All functions accepting an argument of type &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; except &lt;a href=&quot;begin2&quot;&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;end2&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt;(since C++11) should also accept the replacement type.</source>
          <target state="translated">C ++ 11부터 &lt;a href=&quot;begin2&quot;&gt; &lt;code&gt;begin()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;end2&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt; 제외한 &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; 형식의 인수를 허용하는 모든 함수 도 대체 유형을 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0179673daad25aa9537982f33e1688378d0b8b34" translate="yes" xml:space="preserve">
          <source>All functions accepting two arguments of type &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; should accept every combination of &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; and the replacement type.</source>
          <target state="translated">&lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; 유형의 두 인수를 허용하는 모든 함수 는 &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; 및 대체 유형 의 모든 조합을 허용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c84866185eebd1e3d3c0bd203de655735b81b728" translate="yes" xml:space="preserve">
          <source>All functions from &lt;a href=&quot;../../types#Type_traits&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../types#Type_traits&quot;&gt;&amp;lt;type_traits&amp;gt;의&lt;/a&gt; 모든 함수</target>
        </trans-unit>
        <trans-unit id="eacdccc0ff89286560bd5447dd6d3e5754738868" translate="yes" xml:space="preserve">
          <source>All implicitly-captured variables must be declared within the</source>
          <target state="translated">내재적으로 캡처 된 모든 변수는</target>
        </trans-unit>
        <trans-unit id="ee4038fb61cddc0d5aee00559af689e67143f4cb" translate="yes" xml:space="preserve">
          <source>All implicitly-declared member functions (and inheriting constructors) have exception specifications, selected as follows:</source>
          <target state="translated">암시 적으로 선언 된 모든 멤버 함수 (및 상속 생성자)에는 다음과 같이 선택된 예외 사양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="73a8920376f49ed06b9320f4b183b14d1b56c59a" translate="yes" xml:space="preserve">
          <source>All instances of &lt;code&gt;std::monostate&lt;/code&gt; compare equal.</source>
          <target state="translated">&lt;code&gt;std::monostate&lt;/code&gt; 의 모든 인스턴스는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6f36973910215a95c48be1c361c474c6abda5dfd" translate="yes" xml:space="preserve">
          <source>All iterators and references are invalidated, unless the erased elements are at the end or the beginning of the container, in which case only the iterators and references to the erased elements are invalidated.</source>
          <target state="translated">지워진 요소가 컨테이너의 끝이나 시작 부분에 있지 않으면 모든 반복기와 참조가 무효화됩니다.이 경우 지워진 요소에 대한 반복자와 참조 만 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="3ff58822fed4cebf575b53176b537d16617bfe40" translate="yes" xml:space="preserve">
          <source>All iterators and references are invalidated. Past-the-end iterator is also invalidated.</source>
          <target state="translated">모든 반복자와 참조가 무효화됩니다. 과거의 반복자도 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="b6bfeb63a7689b81c8714600b9a0261d56188882" translate="yes" xml:space="preserve">
          <source>All iterators and references remain valid. It is unspecified whether an iterator holding the past-the-end value in this container will refer to this or the other container after the operation.</source>
          <target state="translated">모든 반복자와 참조는 유효합니다. 이 컨테이너에서 과거 값을 보유한 반복자가 조작 후이 컨테이너 또는 다른 컨테이너를 참조하는지 여부는 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c94adb4871f7b21a7fe1f80a6cb316845a106fd2" translate="yes" xml:space="preserve">
          <source>All iterators and references remain valid. The past-the-end iterator is invalidated.</source>
          <target state="translated">모든 반복자와 참조는 유효합니다. 과거의 반복자가 무효화되었습니다.</target>
        </trans-unit>
        <trans-unit id="ca555a6b3c340c88a2973a4408368f43f4dc4831" translate="yes" xml:space="preserve">
          <source>All iterators, including the past-the-end iterator, are invalidated. No references are invalidated.</source>
          <target state="translated">과거 반복기를 포함한 모든 반복기는 무효화됩니다. 무효화 된 참조는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf1ebdb0694902a0ff8fae76c426f9dc6a20dead" translate="yes" xml:space="preserve">
          <source>All iterators, including the past-the-end iterator, are invalidated. References are invalidated too, unless &lt;code&gt;pos == begin()&lt;/code&gt; or &lt;code&gt;pos == end()&lt;/code&gt;, in which case they are not invalidated.</source>
          <target state="translated">과거 반복기를 포함한 모든 반복기는 무효화됩니다. 하지 않는 한 언급도 무효화됩니다 &lt;code&gt;pos == begin()&lt;/code&gt; 또는 &lt;code&gt;pos == end()&lt;/code&gt; 그들이 무효화되지 않는 경우를.</target>
        </trans-unit>
        <trans-unit id="40ad628bf4f34bdc58de5f589d209eea4731620e" translate="yes" xml:space="preserve">
          <source>All iterators, pointers and references to the elements of the container are invalidated.</source>
          <target state="translated">컨테이너의 요소에 대한 모든 반복자, 포인터 및 참조가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="94cae0bd78bc02d0cb18bf7254756a408b83ca8f" translate="yes" xml:space="preserve">
          <source>All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated.</source>
          <target state="translated">컨테이너의 요소에 대한 모든 반복자, 포인터 및 참조가 무효화됩니다. 과거의 이터레이터도 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa2eedbbbd254c0a4f9a58cb63ee4b66a5cdbf4" translate="yes" xml:space="preserve">
          <source>All lock and unlock operations on a single mutex occur in a single total order</source>
          <target state="translated">단일 뮤텍스에 대한 모든 잠금 및 잠금 해제 작업은 단일 총 순서로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="178cdfec76dc5f4d6166a9e91517e1f3fec12bff" translate="yes" xml:space="preserve">
          <source>All lock and unlock operations on a single mutex occur in a single total order that can be viewed as &lt;a href=&quot;../atomic/memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of an atomic variable: the order is specific to this individual mutex.</source>
          <target state="translated">단일 뮤텍스에 대한 모든 잠금 및 잠금 해제 조작 은 원자 변수의 &lt;a href=&quot;../atomic/memory_order#Modification_order&quot;&gt;수정 순서&lt;/a&gt; 로 볼 수있는 단일의 전체 순서로 발생 합니다. 순서는이 개별 뮤텍스에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="34930fdb8cc73ddd310f600e059433705d8a684e" translate="yes" xml:space="preserve">
          <source>All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of &lt;code&gt;shared_ptr&lt;/code&gt; without additional synchronization even if these instances are copies and share ownership of the same object. If multiple threads of execution access the same &lt;code&gt;shared_ptr&lt;/code&gt; without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur; the &lt;a href=&quot;shared_ptr/atomic&quot;&gt;shared_ptr overloads of atomic functions&lt;/a&gt; can be used to prevent the data race.</source>
          <target state="translated">모든 인스턴스 함수 (복사 생성자 및 사본 할당 포함)는 동일한 인스턴스의 사본이고 공유 소유권이 있더라도 추가 동기화없이 여러 가지 &lt;code&gt;shared_ptr&lt;/code&gt; 인스턴스의 여러 스레드에서 호출 할 수 있습니다 . 여러 실행 스레드가 동기화없이 동일한 &lt;code&gt;shared_ptr&lt;/code&gt; 에 액세스하고 해당 액세스 중 하나가 비 const 멤버 함수 &lt;code&gt;shared_ptr&lt;/code&gt; 을 사용하는 경우 데이터 경쟁이 발생합니다. &lt;a href=&quot;shared_ptr/atomic&quot;&gt;원자 함수&lt;/a&gt; 의 shared_ptr 과부하 는 데이터 경쟁을 방지하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35b76e83898bb18b9a2f37898e8607d37cde7935" translate="yes" xml:space="preserve">
          <source>All member functions of all standard library specializations of this template are &lt;code&gt;noexcept&lt;/code&gt; except for the member functions of &lt;a href=&quot;optional/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;variant/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::variant&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../memory/unique_ptr/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 템플릿의 모든 표준 라이브러리 전문의 모든 멤버 함수는 &lt;code&gt;noexcept&lt;/code&gt; 를 의 멤버 함수를 제외하고 &lt;a href=&quot;optional/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;variant/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::variant&amp;gt;&lt;/code&gt; &lt;/a&gt; , 그리고 &lt;a href=&quot;../memory/unique_ptr/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8504e2abc83d5c2fab9fb5538bf231a69f226b05" translate="yes" xml:space="preserve">
          <source>All members are defined at once in the class definition, they cannot be added to an already-defined class (unlike the members of namespaces).</source>
          <target state="translated">모든 멤버는 클래스 정의에서 한 번에 정의되며 네임 스페이스 멤버와 달리 이미 정의 된 클래스에 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5302fa5db09bb78acbca4f2b6c8fda7d03161a35" translate="yes" xml:space="preserve">
          <source>All members of a class (bodies of &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;, initializers of member objects, and the entire &lt;a href=&quot;nested_classes&quot;&gt;nested class definitions&lt;/a&gt;) have access to all names the class can access. A local class within a member function has access to all names the member function can access.</source>
          <target state="translated">클래스의 모든 멤버 ( &lt;a href=&quot;member_functions&quot;&gt;멤버 함수의&lt;/a&gt; 바디 , 멤버 객체의 이니셜 라이저 및 전체 &lt;a href=&quot;nested_classes&quot;&gt;중첩 클래스 정의&lt;/a&gt; )는 클래스 가 액세스 할 수있는 모든 이름에 액세스 할 수 있습니다. 멤버 함수 내의 로컬 클래스는 멤버 함수가 액세스 할 수있는 모든 이름에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59ab18ea391c2d9b328f2f7d982b4ad982485409" translate="yes" xml:space="preserve">
          <source>All modifications to any particular atomic variable occur in a total order that is specific to this one atomic variable.</source>
          <target state="translated">특정 원자 변수에 대한 모든 수정은이 하나의 원자 변수에 특정한 전체 순서로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d28efff2a0fb864afdef01249aa565cd9c9d0c3a" translate="yes" xml:space="preserve">
          <source>All names introduced by the declarations that appear within namespace-body (including nested namespace definitions) become members of the namespace identifier, whether this namespace definition is the original namespace definition (which introduced identifier), or an extension namespace definition (which &quot;reopened&quot; the already defined namespace).</source>
          <target state="translated">네임 스페이스 본문 (네스트 된 네임 스페이스 정의 포함) 내에 나타나는 선언에 의해 도입 된 모든 이름은이 네임 스페이스 정의가 원래 네임 스페이스 정의 (ID를 도입 한)인지 또는 확장 네임 스페이스 정의 ( &quot;열린&quot;)이든 네임 스페이스 식별자의 멤버가됩니다. 이미 정의 된 네임 스페이스).</target>
        </trans-unit>
        <trans-unit id="b08c863ba714f38d0d860de01117473b44bbbe86" translate="yes" xml:space="preserve">
          <source>All non-local variables with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; are initialized as part of program startup, before the execution of the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt; begins (unless deferred, see below). All variables with thread-local storage duration are initialized as part of thread launch, sequenced-before the execution of the thread function begins. For both of these classes of variables, initialization occurs in two distinct stages:</source>
          <target state="translated">정적 &lt;a href=&quot;storage_duration&quot;&gt;저장 시간을&lt;/a&gt; 갖는 모든 비 로컬 변수 는 &lt;a href=&quot;main_function&quot;&gt;기본 기능&lt;/a&gt; 의 실행이 시작되기 전에 프로그램 시작의 일부로 초기화 됩니다 (지연되지 않는 한 아래 참조). 스레드 로컬 저장 기간을 갖는 모든 변수는 스레드 기능의 실행이 시작되기 전에 순서대로 스레드 실행의 일부로 초기화됩니다. 이 두 변수 클래스 모두 초기화는 두 가지 단계로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="55481c71bd011e1fe7bc3e43733da57362a61783" translate="yes" xml:space="preserve">
          <source>All non-specialized &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; functions are also provided by this specialization, and no additional member functions.</source>
          <target state="translated">특수화되지 않은 모든 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 함수도이 특수화에 의해 제공되며 추가 멤버 함수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0557b920b1069437438d197127c5136f3ee6adf1" translate="yes" xml:space="preserve">
          <source>All non-static data members and base classes are themselves standard layout types</source>
          <target state="translated">모든 비 정적 데이터 멤버 및 기본 클래스는 표준 레이아웃 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e4dcf520b0bb3c172727a71b79681a5d16c241c8" translate="yes" xml:space="preserve">
          <source>All non-static data members have the same &lt;a href=&quot;../language/access&quot;&gt;access control&lt;/a&gt;</source>
          <target state="translated">모든 비 정적 데이터 멤버는 동일한 &lt;a href=&quot;../language/access&quot;&gt;액세스 제어를&lt;/a&gt; 갖습니다.</target>
        </trans-unit>
        <trans-unit id="624a5b6de90948456f868c89c51c9329989f3cb3" translate="yes" xml:space="preserve">
          <source>All non-static data members of class type (or array of class type) have trivial destructors</source>
          <target state="translated">클래스 유형 (또는 클래스 유형 배열)의 모든 비 정적 데이터 멤버에는 간단한 소멸자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f485616a097e8c940e99a2d2edb5c6f19158253d" translate="yes" xml:space="preserve">
          <source>All of the elements before this new &lt;code&gt;nth&lt;/code&gt; element are less than or equal to the elements after the new &lt;code&gt;nth&lt;/code&gt; element.</source>
          <target state="translated">이 새로운 요소 전에 모든 &lt;code&gt;nth&lt;/code&gt; 요소 미만이거나 새로운 후의 요소와 동일한 &lt;code&gt;nth&lt;/code&gt; 요소.</target>
        </trans-unit>
        <trans-unit id="d5ea57823ac6ced06c326c70fd59fde6fcce0fad" translate="yes" xml:space="preserve">
          <source>All of the iterator categories (except &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; and &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;) can be organized into a hierarchy, where more powerful iterator categories (e.g. &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;) support the operations of less powerful categories (e.g. &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;). If an iterator falls into one of these categories and also satisfies the requirements of &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, then it is called a</source>
          <target state="translated">모든 반복자 범주 ( &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 및 &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; 제외 )는보다 강력한 반복자 범주 (예 : &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; )가 덜 강력한 범주 (예 : &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; ) 의 조작을 지원 하는 계층 구조로 구성 될 수 있습니다 . 반복자가 이러한 범주 중 하나에 속하고 &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 의 요구 사항을 충족하는 경우이를 반복 자라고 합니다.</target>
        </trans-unit>
        <trans-unit id="f4c48696f28287567f830764d3d2f6d6181a4365" translate="yes" xml:space="preserve">
          <source>All other constructors take an allocator parameter.</source>
          <target state="translated">다른 모든 생성자는 할당 자 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9051dde370d80e8aba9af3637e2fe2a4c637ddb2" translate="yes" xml:space="preserve">
          <source>All pointers are considered valid and may be dereferenced or deallocated</source>
          <target state="translated">모든 포인터는 유효한 것으로 간주되며 역 참조 또는 할당 해제 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="06db46d40762e7a049233b69f344ddc40172814b" translate="yes" xml:space="preserve">
          <source>All pointers are considered valid and may be dereferenced or deallocated. A reachability-based leak detector may be active</source>
          <target state="translated">모든 포인터는 유효한 것으로 간주되며 역 참조 또는 할당 해제 될 수 있습니다. 접근성 기반 누출 감지기가 작동 중일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="bdcfa55217ac64f8db8a5cf75b2b3e2a7b2b589f" translate="yes" xml:space="preserve">
          <source>All pointers, references, and iterators are invalidated.</source>
          <target state="translated">모든 포인터, 참조 및 반복자가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="cae4dbc2c6705f38175037741cbe2272cd9f0a9e" translate="yes" xml:space="preserve">
          <source>All private data members and all private non-virtual member functions are placed in the implementation class. All public, protected, and virtual members remain in the interface class (see &lt;a href=&quot;http://herbsutter.com/gotw/_100/&quot;&gt;GOTW #100&lt;/a&gt; for the discussion of the alternatives).</source>
          <target state="translated">모든 개인 데이터 멤버 및 모든 개인 비가 상 멤버 함수는 구현 클래스에 배치됩니다. 모든 공용, 보호 및 가상 구성원은 인터페이스 클래스에 남아 있습니다 ( 대안에 대한 설명 은 &lt;a href=&quot;http://herbsutter.com/gotw/_100/&quot;&gt;GOTW # 100&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6ad08b1a1866207c625f156796d23145d807041c" translate="yes" xml:space="preserve">
          <source>All read only operations</source>
          <target state="translated">모든 읽기 전용 작업</target>
        </trans-unit>
        <trans-unit id="51f454bbf261c865ca3eafaca5186949d522a16c" translate="yes" xml:space="preserve">
          <source>All read only operations, &lt;code&gt;&lt;a href=&quot;unordered_map/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">모든 읽기 전용 작업, &lt;code&gt;&lt;a href=&quot;unordered_map/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d0ff23cc747ee3f2c2cacda30dad2daf43fc67d" translate="yes" xml:space="preserve">
          <source>All read only operations, &lt;code&gt;&lt;a href=&quot;vector/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">모든 읽기 전용 작업, &lt;code&gt;&lt;a href=&quot;vector/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41a67df5b26d67f230c41a225f6f4807b01737d6" translate="yes" xml:space="preserve">
          <source>All references, pointers, and iterators are invalidated, including the end iterator. &lt;code&gt;a.empty() == true&lt;/code&gt;.</source>
          <target state="translated">종료 반복자를 포함하여 모든 참조, 포인터 및 반복자가 무효화됩니다. &lt;code&gt;a.empty() == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efe67501a1ba3ff0b54181ac0c20ec517abdc3e4" translate="yes" xml:space="preserve">
          <source>All requirements on the iterator types of a &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; applies to the &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; types of &lt;code&gt;basic_string_view&lt;/code&gt; as well.</source>
          <target state="translated">&lt;a href=&quot;../named_req/container&quot;&gt;컨테이너&lt;/a&gt; 의 반복자 유형에 대한 모든 요구 사항 은 &lt;code&gt;basic_string_view&lt;/code&gt; 의 &lt;code&gt;iterator&lt;/code&gt; 및 &lt;code&gt;const_iterator&lt;/code&gt; 유형 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f7b5a1e5c99b2a9bb4697e1dc9787334111a47c" translate="yes" xml:space="preserve">
          <source>All requirements on the iterator types of a &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; applies to the &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; types of &lt;code&gt;span&lt;/code&gt; as well.</source>
          <target state="translated">&lt;a href=&quot;../named_req/container&quot;&gt;컨테이너&lt;/a&gt; 의 반복자 유형에 대한 모든 요구 사항 은 &lt;code&gt;iterator&lt;/code&gt; 및 &lt;code&gt;const_iterator&lt;/code&gt; 유형의 &lt;code&gt;span&lt;/code&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="38eb211404e95dd1fe2352aec53428f8cadc5999" translate="yes" xml:space="preserve">
          <source>All resources owned by &lt;code&gt;u&lt;/code&gt; are reclaimed, no exceptions are thrown.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 가 소유 한 모든 리소스 는 회수되며 예외는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67f929817d9ab7c1515c103b3dec94699f49b916" translate="yes" xml:space="preserve">
          <source>All restrictions on regular declarations of the same names, hiding, and overloading rules apply to using-declarations:</source>
          <target state="translated">동일한 이름, 숨기기 및 오버로드 규칙의 일반 선언에 대한 모든 제한은 선언 사용에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="be8b6e7136fa8d596cfda90d7fa7d28938ef27cd" translate="yes" xml:space="preserve">
          <source>All six relational operators are automatically generated by the compiler if the three-way comparison operator &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; is defined, and that operator, in turn, is generated by the compiler if it is defined as defaulted:</source>
          <target state="translated">3 방향 비교 연산자 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 가 정의되면 6 개의 관계 연산자가 모두 컴파일러에 의해 자동으로 생성되고, 해당 연산자가 컴파일러가 기본값으로 정의 된 경우 컴파일러에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0d9fb7dc61944bda88f1835dd4562a6f28a100a2" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;fpos&lt;/code&gt; meet the &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;, and &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; requirements.</source>
          <target state="translated">모든 전문 &lt;code&gt;fpos&lt;/code&gt; 은 미트 &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;../named_req/destructible&quot;&gt;파괴 가능한&lt;/a&gt; 및 &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable로&lt;/a&gt; 요구 사항을.</target>
        </trans-unit>
        <trans-unit id="672a39cb4d9a7dc48c3d594e3812033e46d14edc" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;polymorphic_allocator&lt;/code&gt; meet the &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;Allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;polymorphic_allocator&lt;/code&gt; 의 모든 전문화 영역은 &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;Allocator 완전성 요구 사항을&lt;/a&gt; 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="211f03dbec01e5b6570f235c7176b37d2a2a79b5" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;shared_ptr&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, and &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; and are &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually convertible&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">모든 전문 &lt;code&gt;shared_ptr&lt;/code&gt; 의의 충족이 요구 사항 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 및 &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; 와는 &lt;a href=&quot;../language/implicit_cast&quot;&gt;문맥 전환&lt;/a&gt; 할 &lt;code&gt;bool&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="1031f9406b312c985a6ae796719a2a8d26efc31e" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;std::tuple_size&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">모든 전문 &lt;code&gt;std::tuple_size&lt;/code&gt; 충족 &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; 와</target>
        </trans-unit>
        <trans-unit id="743934d87daadcc6d9d31370a3db4d5504aa0fb9" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;std::variant_size&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">모든 전문 &lt;code&gt;std::variant_size&lt;/code&gt; 충족 &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; 와</target>
        </trans-unit>
        <trans-unit id="63c53895a6870cc913e144b2578bac2d714b260c" translate="yes" xml:space="preserve">
          <source>All standard containers (&lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;, etc.) value-initialize their elements when constructed with a single &lt;code&gt;size_type&lt;/code&gt; argument or when grown by a call to &lt;code&gt;resize()&lt;/code&gt;.</source>
          <target state="translated">모든 표준 컨테이너 ( &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 등)는 단일 &lt;code&gt;size_type&lt;/code&gt; 인수로 구성되거나 &lt;code&gt;resize()&lt;/code&gt; 호출에 의해 확장 될 때 해당 요소의 값을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="358e40d1bfabb9461fdcb4d0a347855e7c412649" translate="yes" xml:space="preserve">
          <source>All standard library containers except &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; are AllocatorAwareContainers:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; 제외한 모든 표준 라이브러리 컨테이너 는 AllocatorAwareContainers입니다.</target>
        </trans-unit>
        <trans-unit id="ffcd9ca742b4542ddb772e7d60b22b2039e3de22" translate="yes" xml:space="preserve">
          <source>All temporary objects are destroyed as the last step in evaluating the full-expression that (lexically) contains the point where they were created, and if multiple temporary objects were created, they are destroyed in the order opposite to the order of creation. This is true even if that evaluation ends in throwing an exception.</source>
          <target state="translated">생성 된 지점을 포함하는 전체 표현을 평가하는 마지막 단계로 모든 임시 오브젝트가 삭제되고 여러 임시 오브젝트가 작성된 경우 작성 순서와 반대 순서로 파괴됩니다. 평가가 예외를 던지더라도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="32f475507fbff7c599c3fd139abea98403ae6343" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions do not invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">이 모든 함수는 &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; 를 한 번 이상 호출 하며 &lt;code&gt;arg&lt;/code&gt; 의 값은 리턴 후 결정되지 않습니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; 를 호출하지 않으며 호출자가 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="176f5f0946a06ebe297b8c8ddf38982989abc5aa" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">이 모든 함수는 &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; 를 한 번 이상 호출 하며 &lt;code&gt;arg&lt;/code&gt; 의 값은 리턴 후 결정되지 않습니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; 를 호출하지 않으며 호출자가 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe267d2b83e7299286bdf1b9c5aac0a7f499c7ed" translate="yes" xml:space="preserve">
          <source>All these functions invoke undefined behavior if &lt;code&gt;p&lt;/code&gt; is a null pointer.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 널 포인터 인 경우 이러한 모든 함수는 정의되지 않은 동작을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="b0490d0cb63a327b1645f25c31bcc6482c7608ed" translate="yes" xml:space="preserve">
          <source>All these macro constants (except &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.</source>
          <target state="translated">이러한 모든 매크로 상수 ( &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; 제외 )는 2의 고유 한 제곱 인 정수 상수 표현식으로 확장되어 지원되는 모든 부동 소수점 예외를 고유하게 식별합니다. 각 매크로는 지원되는 경우에만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="18f14072e9d32bbf324c49cf31c0caf2c548ae29" translate="yes" xml:space="preserve">
          <source>All three overloads effectively return &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).ends_with(x);&lt;/code&gt;</source>
          <target state="translated">세 가지 과부하 모두 효과적으로 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).ends_with(x);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ae0f95f4fd5fb1e59f705f02f6b13547bc8d638" translate="yes" xml:space="preserve">
          <source>All three overloads effectively return &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).starts_with(x);&lt;/code&gt;</source>
          <target state="translated">세 가지 과부하 모두 효과적으로 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).starts_with(x);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41dbcf1025fbada0bb806a90ae80be55d2ccdbc3" translate="yes" xml:space="preserve">
          <source>All uniform random bit generators meet the &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; requirements. C++20 also defines a &lt;a href=&quot;random/uniformrandombitgenerator&quot;&gt;&lt;code&gt;UniformRandomBitGenerator&lt;/code&gt;&lt;/a&gt; concept.</source>
          <target state="translated">모든 균일 랜덤 비트 생성기는 &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; 요구 사항을 충족합니다 . C ++ 20은 또한 &lt;a href=&quot;random/uniformrandombitgenerator&quot;&gt; &lt;code&gt;UniformRandomBitGenerator&lt;/code&gt; &lt;/a&gt; 개념을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="8d23b28c0c5980cc7718a01e280ed03d0685c95f" translate="yes" xml:space="preserve">
          <source>All users have read, write, and execute/search permissions</source>
          <target state="translated">모든 사용자에게는 읽기, 쓰기 및 실행 / 검색 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="a57778f1822ccdd378e7db95391c602549921f33" translate="yes" xml:space="preserve">
          <source>All valid permission bits.</source>
          <target state="translated">모든 유효한 권한 비트.</target>
        </trans-unit>
        <trans-unit id="49247714c9e6a1264921f2f7061610f5ebfc233f" translate="yes" xml:space="preserve">
          <source>All values are required to be unique except that the values of &lt;code&gt;EOPNOTSUPP&lt;/code&gt; and &lt;code&gt;ENOTSUP&lt;/code&gt; may be identical and the values of &lt;code&gt;EAGAIN&lt;/code&gt; and &lt;code&gt;EWOULDBLOCK&lt;/code&gt; may be identical.</source>
          <target state="translated">&lt;code&gt;EOPNOTSUPP&lt;/code&gt; 및 &lt;code&gt;ENOTSUP&lt;/code&gt; 의 값이 동일하고 &lt;code&gt;EAGAIN&lt;/code&gt; 및 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; 의 값이 동일 할 수 있다는 점을 제외하고 모든 값은 고유 해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c56cddca11b01528f10a9f07f26dc5bec9d8e2f" translate="yes" xml:space="preserve">
          <source>All versions behave as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunctions&lt;/a&gt;. After constructing and checking the sentry object, these functions perform the following:</source>
          <target state="translated">모든 버전은 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunctions로&lt;/a&gt; 작동합니다 . 센트리 객체를 구성하고 확인한 후이 함수는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fe817f9833c1ccda48652b1e96a5f243b7b8c465" translate="yes" xml:space="preserve">
          <source>All versions set the value of &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; to the number of characters extracted.</source>
          <target state="translated">모든 버전은 &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; 의 값을 추출 된 문자 수로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="7c49bcb1867689918b55a1779cbc5e6907f7117d" translate="yes" xml:space="preserve">
          <source>All virtual base subobjects are initialized before any non-virtual base subobject, so only the most derived class calls the constructors of the virtual bases in its &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt;:</source>
          <target state="translated">모든 가상 기본 하위 개체는 가상이 아닌 기본 하위 개체보다 먼저 초기화되므로 가장 파생 된 클래스 만 &lt;a href=&quot;constructor&quot;&gt;멤버 이니셜 라이저 목록&lt;/a&gt; 에서 가상 기본 생성자를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="7b8e5641e2d8cbf1a2bdfdaf4f5a52ae7c538b20" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage whose alignment is specified by &lt;code&gt;alignment&lt;/code&gt;. The &lt;code&gt;size&lt;/code&gt; parameter must be an integral multiple of &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">할당 &lt;code&gt;size&lt;/code&gt; 정렬에 의해 지정된 초기화 저장 바이트 &lt;code&gt;alignment&lt;/code&gt; . &lt;code&gt;size&lt;/code&gt; 매개 변수의 정수 배가되어야합니다 &lt;code&gt;alignment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3713458c26ce42a8beb1ed61bfb66555a6fd00bb" translate="yes" xml:space="preserve">
          <source>Allocate memory</source>
          <target state="translated">메모리 할당</target>
        </trans-unit>
        <trans-unit id="c69536036834933fadf93bcfad2311dd91d4b772" translate="yes" xml:space="preserve">
          <source>Allocate raw aligned memory from the underlying resource</source>
          <target state="translated">기본 리소스에서 원시 정렬 메모리 할당</target>
        </trans-unit>
        <trans-unit id="8c90ccd007d394557e735c7fe5d3753ec43eedf6" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n * sizeof(T)&lt;/code&gt; bytes of uninitialized storage by calling &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;)&lt;/code&gt;or &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt;(since C++17), but it is unspecified when and how this function is called. The pointer &lt;code&gt;hint&lt;/code&gt; may be used to provide locality of reference: the allocator, if supported by the implementation, will attempt to allocate the new memory block as close as possible to &lt;code&gt;hint&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt; ( &lt;a href=&quot;../../types/size_t&quot;&gt;std :: size_t&lt;/a&gt; ) 또는 &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt; ( &lt;a href=&quot;../../types/size_t&quot;&gt;std :: size_t&lt;/a&gt; , &lt;a href=&quot;../new/align_val_t&quot;&gt;std :: align_val_t&lt;/a&gt; ) (C ++ 17부터 ) 를 호출하여 초기화되지 않은 스토리지의 &lt;code&gt;n * sizeof(T)&lt;/code&gt; 바이트를 할당합니다. 이 함수가 언제 어떻게 호출되는지 지정되지 않았습니다. 포인터 &lt;code&gt;hint&lt;/code&gt; 는 참조의 지역성을 제공하는데 사용될 수있다 : 할당자가 구현에 의해 지원된다면, 가능한 한 새로운 메모리 블록을 &lt;code&gt;hint&lt;/code&gt; 가깝게 할당하려고 시도 할 것이다 .</target>
        </trans-unit>
        <trans-unit id="e4fd50aabe78c29ec16f5fd9d57b662c1d7d801a" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;nbytes&lt;/code&gt; bytes of storage at specified alignment &lt;code&gt;alignment&lt;/code&gt; using the underlying memory resource. Equivalent to &lt;code&gt;return resource()-&amp;gt;allocate(nbytes, alignment);&lt;/code&gt;</source>
          <target state="translated">기본 메모리 리소스를 사용하여 지정된 정렬 &lt;code&gt;alignment&lt;/code&gt; &lt;code&gt;nbytes&lt;/code&gt; 바이트의 스토리지를 할당 합니다. 등가 &lt;code&gt;return resource()-&amp;gt;allocate(nbytes, alignment);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="575bf26e9df794dbd1383b334ef663788e920b7e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">초기화되지 않은 스토리지의 &lt;code&gt;size&lt;/code&gt; 바이트를 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="deda37c663ffd540f8cba4cf2e2cde12e85c7e4b" translate="yes" xml:space="preserve">
          <source>Allocates and constructs an object</source>
          <target state="translated">객체 할당 및 구성</target>
        </trans-unit>
        <trans-unit id="37d6f4ac7e329233b5c6cfd53ae16c6539bab6fd" translate="yes" xml:space="preserve">
          <source>Allocates and constructs an object of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; 유형의 객체를 할당하고 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="eec2cf410629d96a9a943a9c58f28ac54a41b535" translate="yes" xml:space="preserve">
          <source>Allocates memory for an array of &lt;code&gt;num&lt;/code&gt; objects of size &lt;code&gt;size&lt;/code&gt; and initializes it to all bits zero.</source>
          <target state="translated">크기가 &lt;code&gt;size&lt;/code&gt; 인 &lt;code&gt;num&lt;/code&gt; 개의 객체 배열에 메모리를 할당 하고 모든 비트를 0으로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="9d033c92aaed0cd6d702cbb7cedf1b4eeff6647d" translate="yes" xml:space="preserve">
          <source>Allocates raw memory suitable for an object or an array</source>
          <target state="translated">객체 또는 배열에 적합한 원시 메모리를 할당합니다</target>
        </trans-unit>
        <trans-unit id="cf91bb95384027fe5328e00c00aaeaa013321358" translate="yes" xml:space="preserve">
          <source>Allocates requested number of bytes. These allocation functions are called by &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate memory in which new object would then be initialized. They may also be called using regular function call syntax.</source>
          <target state="translated">요청 된 바이트 수를 할당합니다. 이러한 할당 함수는 &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt; 에 의해 호출되어 새 객체가 초기화 될 메모리를 할당합니다. 정규 함수 호출 구문을 사용하여 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2fc2b0dfd842a7e3a00d1f42dd3c72c9a40aeb4" translate="yes" xml:space="preserve">
          <source>Allocates storage for &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;T&lt;/code&gt; using the underlying memory resource. Equivalent to &lt;code&gt;return static_cast&amp;lt;T*&amp;gt;(resource()-&amp;gt;allocate(n * sizeof(T), alignof(T)));&lt;/code&gt;.</source>
          <target state="translated">기본 메모리 리소스를 사용하여 유형 &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;n&lt;/code&gt; 개 개체에 대한 저장소를 할당 합니다. 등가 &lt;code&gt;return static_cast&amp;lt;T*&amp;gt;(resource()-&amp;gt;allocate(n * sizeof(T), alignof(T)));&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef1e5d4c9fecdb8c77f2367b414e8a2ebe079e5f" translate="yes" xml:space="preserve">
          <source>Allocates storage for &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;U&lt;/code&gt; using the underlying memory resource.</source>
          <target state="translated">기본 메모리 리소스를 사용하여 &lt;code&gt;U&lt;/code&gt; 유형의 &lt;code&gt;n&lt;/code&gt; 개 개체에 대한 저장소를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="c8d51dfb7cc15d733b905081816cec434af6b924" translate="yes" xml:space="preserve">
          <source>Allocates storage with a size of at least &lt;code&gt;bytes&lt;/code&gt; bytes, aligned to the specified &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;alignment&lt;/code&gt; 에 맞춰 최소 &lt;code&gt;bytes&lt;/code&gt; 바이트 크기의 스토리지를 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="1719b83d89f242ab75b869949fb55eef6c5d0e25" translate="yes" xml:space="preserve">
          <source>Allocates storage with a size of at least &lt;code&gt;bytes&lt;/code&gt; bytes. The returned storage is aligned to the specified &lt;code&gt;alignment&lt;/code&gt; if such alignment is supported, and to &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; otherwise.</source>
          <target state="translated">최소 &lt;code&gt;bytes&lt;/code&gt; 바이트 크기의 스토리지를 할당 합니다. 반환 된 스토리지는 정렬 이 지원되는 경우 지정된 &lt;code&gt;alignment&lt;/code&gt; 되고 그렇지 않으면 &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="5fa0c7f2ed7e5ab17575514af95c1b4726f6491b" translate="yes" xml:space="preserve">
          <source>Allocates storage.</source>
          <target state="translated">스토리지를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="a4cd37a2b2f79389364650460bd02f87e623f6b0" translate="yes" xml:space="preserve">
          <source>Allocates uninitialized contiguous storage, which should be sufficient to store up to &lt;code&gt;count&lt;/code&gt; adjacent objects of type &lt;code&gt;T&lt;/code&gt;. The request is non-binding and the implementation may allocate less or more than necessary to store &lt;code&gt;count&lt;/code&gt; adjacent objects.</source>
          <target state="translated">초기화되지 않은 연속 스토리지를 할당합니다.이 스토리지는 &lt;code&gt;T&lt;/code&gt; 유형의 인접 오브젝트 를 &lt;code&gt;count&lt;/code&gt; 하기에 충분해야합니다 . 요청은 구속력이 없으며, 구현은 &lt;code&gt;count&lt;/code&gt; 인접한 객체 를 저장하는 데 필요한 것보다 적게 또는 더 많이 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="7e5a93aa2050aa67c4b2a8fa0227ec2d570a5f78" translate="yes" xml:space="preserve">
          <source>Allocation functions</source>
          <target state="translated">할당 기능</target>
        </trans-unit>
        <trans-unit id="bcdc03b4788456846d38f2b2c7a10637d4ba865e" translate="yes" xml:space="preserve">
          <source>Allocations requests that exceed the largest block size are served from the</source>
          <target state="translated">가장 큰 블록 크기를 초과하는 할당 요청은</target>
        </trans-unit>
        <trans-unit id="cbf9e75065cafb419b19fb5a13dddefb2735eaa6" translate="yes" xml:space="preserve">
          <source>Allocator</source>
          <target state="translated">Allocator</target>
        </trans-unit>
        <trans-unit id="c26087d42681b7f6e496369e9c820f3e757778ab" translate="yes" xml:space="preserve">
          <source>Allocator completeness requirements</source>
          <target state="translated">할당 자 완전성 요구 사항</target>
        </trans-unit>
        <trans-unit id="006db541d4a947093a399166c59d14c227c66a14" translate="yes" xml:space="preserve">
          <source>Allocator for &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 할당 자</target>
        </trans-unit>
        <trans-unit id="a14116cd7defc5cfe1008ae088831e83125981b1" translate="yes" xml:space="preserve">
          <source>Allocator of a type convertible to &lt;code&gt;A&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 로 변환 가능한 타입의 할당 자</target>
        </trans-unit>
        <trans-unit id="71d3d89dd86b8060b5c2c3dff2ad831f3f7d33f4" translate="yes" xml:space="preserve">
          <source>Allocator type</source>
          <target state="translated">할당 자 유형</target>
        </trans-unit>
        <trans-unit id="c5e06a85490c85e6350aa5bd28390e1ead65f231" translate="yes" xml:space="preserve">
          <source>Allocator-aware containers always call &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::construct(m, p, args)&lt;/code&gt; to construct an object of type &lt;code&gt;A&lt;/code&gt; at &lt;code&gt;p&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt;, with &lt;code&gt;m == get_allocator()&lt;/code&gt;. The default &lt;code&gt;construct&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;::new((void*)p) T(args)&lt;/code&gt;, but specialized allocators may choose a different definition.</source>
          <target state="translated">로케이터 인식 용기 항상 전화 &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::construct(m, p, args)&lt;/code&gt; 유형의 객체 구축 &lt;code&gt;A&lt;/code&gt; 에 &lt;code&gt;p&lt;/code&gt; 사용 &lt;code&gt;args&lt;/code&gt; 가진 &lt;code&gt;m == get_allocator()&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 의 기본 &lt;code&gt;construct&lt;/code&gt; 은 &lt;code&gt;::new((void*)p) T(args)&lt;/code&gt; 호출 하지만 특수 할당자는 다른 정의를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34acd9339509e4e1e31704ab4c073ecbdafd1f25" translate="yes" xml:space="preserve">
          <source>AllocatorAwareContainer</source>
          <target state="translated">AllocatorAwareContainer</target>
        </trans-unit>
        <trans-unit id="5ceb7c7c9f3657e9513254564292abfe012cfefb" translate="yes" xml:space="preserve">
          <source>Allocators</source>
          <target state="translated">Allocators</target>
        </trans-unit>
        <trans-unit id="629f37bb798c36a67317aa9ec0378bd852ec9f11" translate="yes" xml:space="preserve">
          <source>Allocators are class templates encapsulating memory allocation strategy. This allows generic containers to decouple memory management from the data itself.</source>
          <target state="translated">할당자는 메모리 할당 전략을 캡슐화하는 클래스 템플릿입니다. 이를 통해 일반 컨테이너는 메모리 관리와 데이터 자체를 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="095c1a8ff16049f04c3471ba9a37d8292cb9648d" translate="yes" xml:space="preserve">
          <source>Allow constant evaluation for all &lt;a href=&quot;language/template_parameters#Template_non-type_arguments&quot;&gt;non-type template arguments&lt;/a&gt;</source>
          <target state="translated">모든 &lt;a href=&quot;language/template_parameters#Template_non-type_arguments&quot;&gt;유형이 아닌 템플릿 인수에&lt;/a&gt; 대한 지속적인 평가 허용</target>
        </trans-unit>
        <trans-unit id="8672315bab526e017a0da6b4db8394d5643bd21c" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize for the case where paths of execution including that statement are more or less likely than any alternative path of execution that does not include such a statement.</source>
          <target state="translated">해당 명령문을 포함하는 실행 경로가 해당 명령문을 포함하지 않는 대체 실행 경로보다 많거나 적은 경우에 대해 컴파일러가 최적화하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="03388373add47a2fa22bbeb6dede9123b781ba3f" translate="yes" xml:space="preserve">
          <source>Allows a function to accept any number of arguments.</source>
          <target state="translated">함수가 임의의 수의 인수를 허용하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="411787b050d38051721728f3a87d5174918b5c69" translate="yes" xml:space="preserve">
          <source>Allows a function to be called without providing one or more trailing arguments.</source>
          <target state="translated">하나 이상의 후미 인수를 제공하지 않고 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="459d9517d5603efba94121b4d2acec3f8491a657" translate="yes" xml:space="preserve">
          <source>Allows any and all code transformations that do not change the observable behavior of the program.</source>
          <target state="translated">프로그램의 관찰 가능한 동작을 변경하지 않는 모든 코드 변환을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f7fd47c92a72794dea3d8bd7149aab52470581d7" translate="yes" xml:space="preserve">
          <source>Allows customizing class and variable(since C++14) templates for a given category of template arguments.</source>
          <target state="translated">주어진 범주의 템플릿 인수에 대해 클래스 및 변수 (C ++ 14 이후) 템플릿을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36e28bc484be80710ded433fdd6ceb2b32b730fd" translate="yes" xml:space="preserve">
          <source>Allows customizing the template code for a given set of template arguments.</source>
          <target state="translated">주어진 템플릿 인수 집합에 대한 템플릿 코드를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8bf676764b0183a61de1aa7f44f4c55b945bd3c" translate="yes" xml:space="preserve">
          <source>Allows insertion and extraction of quoted strings, such as the ones found in CSV or XML.</source>
          <target state="translated">CSV 또는 XML에있는 것과 같이 따옴표로 묶인 문자열을 삽입하고 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1433f306e640197740511f48680f25d7413dc2e9" translate="yes" xml:space="preserve">
          <source>Allows integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix.</source>
          <target state="translated">정수, 부동 소수점, 문자 및 문자열 리터럴이 사용자 정의 접미사를 정의하여 사용자 정의 유형의 객체를 생성 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="714a3428d46162788e491e8dc3208e88274f1f2f" translate="yes" xml:space="preserve">
          <source>Allows the size of an empty base subobject to be zero.</source>
          <target state="translated">빈 기본 하위 객체의 크기를 0으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccb54e9be1a4c6bc9837fefd7cc02f1997a12f3c" translate="yes" xml:space="preserve">
          <source>Allows values of integer type to be used in expressions directly.</source>
          <target state="translated">정수 유형의 값을 표현식에서 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0c4d0005f924626f07462db95d58f6067b54a8" translate="yes" xml:space="preserve">
          <source>Also because braced-init-list has no type, &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;special rules for overload resolution&lt;/a&gt; apply when it is used as an argument to an overloaded function call.</source>
          <target state="translated">또한 braced-init-list에는 유형이 없으므로 &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;과부하 해결에 대한 특수 규칙&lt;/a&gt; 은 과부하 된 함수 호출에 대한 인수로 사용될 때 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b587e48dc1be81684dc5d496c6af85f6a461578" translate="yes" xml:space="preserve">
          <source>Also provided are the C-style date and time functions, such as &lt;code&gt;&lt;a href=&quot;chrono/c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/c/difftime&quot;&gt;std::difftime&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;chrono/c/clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;chrono/c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;chrono/c/difftime&quot;&gt;std::difftime&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;chrono/c/clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt; 와 같은 C 스타일 날짜 및 시간 함수도 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="729da59cb6e707c89f461faec986a483c428299a" translate="yes" xml:space="preserve">
          <source>Also, all &lt;a href=&quot;language/name&quot;&gt;identifiers&lt;/a&gt; that contain a double underscore __ in any position and each identifier that begins with an underscore followed by an uppercase letter is always reserved and all identifiers that begin with an underscore are reserved for use as names in the global namespace. See &lt;a href=&quot;language/name&quot;&gt;identifiers&lt;/a&gt; for more details.</source>
          <target state="translated">또한 모든 위치에 이중 밑줄 __이 포함 된 모든 &lt;a href=&quot;language/name&quot;&gt;식별자&lt;/a&gt; 와 밑줄로 시작하고 대문자로 시작하는 각 식별자는 항상 예약되어 있으며 밑줄로 시작하는 모든 식별자는 전역 네임 스페이스에서 이름으로 사용되도록 예약되어 있습니다. 자세한 내용은 &lt;a href=&quot;language/name&quot;&gt;식별자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8790a9cbd433decb4fdf7491221b8bbc56822f99" translate="yes" xml:space="preserve">
          <source>Also, on some platforms, bit fields are packed left-to-right, on others right-to-left</source>
          <target state="translated">또한 일부 플랫폼에서는 비트 필드가 왼쪽에서 오른쪽으로, 다른 필드에서 오른쪽에서 왼쪽으로 압축됩니다</target>
        </trans-unit>
        <trans-unit id="5b07b0bdeb35442e306edb6a6d7347901e47e660" translate="yes" xml:space="preserve">
          <source>Also, the standard library functions called with xvalue arguments may assume the argument is the only reference to the object; if it was constructed from an lvalue with &lt;code&gt;std::move&lt;/code&gt;, no aliasing checks are made. In particular, this means that standard library move assignment operators do not have to perform self-assignment checks:</source>
          <target state="translated">또한 xvalue 인수로 호출 된 표준 라이브러리 함수는 인수가 객체에 대한 유일한 참조라고 가정 할 수 있습니다. &lt;code&gt;std::move&lt;/code&gt; 를 사용하여 lvalue로 구성된 경우 앨리어싱 검사가 수행되지 않습니다. 특히 이는 표준 라이브러리 이동 할당 연산자가 자체 할당 검사를 수행 할 필요가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9465911da185e318d4f902c965db53e7bdd827fb" translate="yes" xml:space="preserve">
          <source>Also, unlike the formatted output functions, this function does not set the &lt;code&gt;failbit&lt;/code&gt; on failure.</source>
          <target state="translated">또한 형식화 된 출력 기능과 달리이 기능은 실패시 페일 &lt;code&gt;failbit&lt;/code&gt; 를 설정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="2e4d959d6a71905b14d43661b5387037b9b586bd" translate="yes" xml:space="preserve">
          <source>Alternative operator representations</source>
          <target state="translated">대체 연산자 표현</target>
        </trans-unit>
        <trans-unit id="c8b93e0cfffeb74171554b62200f1f073639dd68" translate="yes" xml:space="preserve">
          <source>Alternative operator syntax</source>
          <target state="translated">대체 연산자 구문</target>
        </trans-unit>
        <trans-unit id="e32467443dfa96c0777ac9526ba4d4884bea25fb" translate="yes" xml:space="preserve">
          <source>Alternative tokens</source>
          <target state="translated">대체 토큰</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="f33a42489881f94fe215353e72be54816924c644" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;&lt;/code&gt; may sometimes be used to detect stack unwinding in progress, it is generally considered bad practice to allow any destructor to terminate by throwing an exception. This functionality is nevertheless used by some libraries, such as &lt;a href=&quot;https://github.com/SOCI/soci&quot;&gt;SOCI&lt;/a&gt; and &lt;a href=&quot;http://galeracluster.com/downloads/&quot;&gt;Galera 3&lt;/a&gt;, which rely on the ability of the destructors of nameless temporaries to throw exceptions at the end of the full expression that constructs the temporary.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;&lt;/code&gt; 사용하여 진행중인 스택 해제를 감지 할 수도 있지만 일반적으로 소멸자가 예외를 발생시켜 종료하도록 허용하는 것은 나쁜 습관으로 간주됩니다. 그럼에도 불구하고이 기능은 &lt;a href=&quot;https://github.com/SOCI/soci&quot;&gt;SOCI&lt;/a&gt; 및 &lt;a href=&quot;http://galeracluster.com/downloads/&quot;&gt;Galera 3&lt;/a&gt; 과 같은 일부 라이브러리에서 사용되며, 임시 라이브러리 를 구성하는 전체 표현식이 끝날 때 이름없는 임시 소멸자가 예외를 처리 할 수있는 기능에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="ea2b684e4b095592200988c7ab99debb5b70a888" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::pow&lt;/code&gt; cannot be used to obtain a root of a negative number, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;std::cbrt&lt;/a&gt;&lt;/code&gt; is provided for the common case where &lt;code&gt;exp&lt;/code&gt; is 1/3.</source>
          <target state="translated">비록 &lt;code&gt;std::pow&lt;/code&gt; 음의 수의 루트를 취득 할 수없는, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;std::cbrt&lt;/a&gt;&lt;/code&gt; 일반적인 경우를 위해 제공된다 &lt;code&gt;exp&lt;/code&gt; 1/3이다.</target>
        </trans-unit>
        <trans-unit id="b0bbe9c54239a7325e443792536d8b4342054835" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::scalbn&lt;/code&gt; and &lt;code&gt;std::scalbln&lt;/code&gt; are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="translated">비록 &lt;code&gt;std::scalbn&lt;/code&gt; 및 &lt;code&gt;std::scalbln&lt;/code&gt; 효율적 동작을 수행하도록 지정되어, 많은 구현에 그들 연산기를 이용하여 2의 거듭 제곱에 의해 곱셈이나 나눗셈보다 덜 효율적이다.</target>
        </trans-unit>
        <trans-unit id="3d1825778acdae18596af041fff74b7b10c86289" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; with the default deleter may be constructed with &lt;a href=&quot;../../language/incomplete_type&quot;&gt;incomplete type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;, the type &lt;code&gt;T&lt;/code&gt; must be complete at the point of code where the destructor is called.</source>
          <target state="translated">하지만 &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 기본 Deleter가와가 함께 구성 될 수있다 &lt;a href=&quot;../../language/incomplete_type&quot;&gt;불완전 형 &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; , 타입 &lt;code&gt;T&lt;/code&gt; 는 소멸자가 호출 코드의 시점에서 완료해야합니다.</target>
        </trans-unit>
        <trans-unit id="439c84aa6d4f184555f03b26b3fb02df31f3c81c" translate="yes" xml:space="preserve">
          <source>Although a function call can be resolved through ADL even if ordinary lookup finds nothing, a function call to a &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt; with explicitly-specified template arguments requires that there is a declaration of the template found by ordinary lookup (otherwise, it is a syntax error to encounter an unknown name followed by a less-than character).</source>
          <target state="translated">일반 조회에서 아무것도 찾지 않아도 ADL을 통해 함수 호출을 해결할 수 있지만 명시 적으로 지정된 템플리트 인수가 있는 &lt;a href=&quot;function_template&quot;&gt;함수 템플리트에&lt;/a&gt; 대한 함수를 호출하려면 일반 조회에서 찾은 템플리트 선언이 있어야합니다 (그렇지 않으면 구문 오류 임) 알 수없는 이름 뒤에 문자보다 작음).</target>
        </trans-unit>
        <trans-unit id="f1ebb0e824901f4ec3f02ea57f64d9e4828306f2" translate="yes" xml:space="preserve">
          <source>Although a zero-initialized &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; always represents the initial conversion state, there may be other values of &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; that also represent the initial conversion state.</source>
          <target state="translated">제로 초기화 있지만 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 항상 나타내는 초기 변환 상태의 다른 값이있을 수 있습니다 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 은 또한 나타내는 초기 변환 상태.</target>
        </trans-unit>
        <trans-unit id="f708528328b72807fc0654354970ef41ee70cd4b" translate="yes" xml:space="preserve">
          <source>Although arrays cannot be returned from functions by value and cannot be targets of most cast expressions, array &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt; may be formed by using a type alias to construct an array temporary using &lt;a href=&quot;explicit_cast&quot;&gt;brace-initialized functional cast&lt;/a&gt;.</source>
          <target state="translated">배열 값에 함수로부터 복귀 할 수없는 대부분의 주조 표현 대상이 될 수는 없지만, 배열 &lt;a href=&quot;value_category&quot;&gt;prvalues가&lt;/a&gt; 사용 임시 배열 구성하는 형태 별칭을 사용하여 형성 될 수있다 &lt;a href=&quot;explicit_cast&quot;&gt;브레이스 초기화 기능 캐스트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fd9b3c6d07c5655b399e6be4424fee0edae9357" translate="yes" xml:space="preserve">
          <source>Although canonical form of pre-increment/pre-decrement returns a reference, as with any operator overload, the return type is user-defined; for example the overloads of these operators for &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; return by value.</source>
          <target state="translated">사전 증분 / 사전 감소의 정식 형태는 연산자 오버로드와 마찬가지로 참조를 반환하지만 반환 유형은 사용자 정의됩니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 대한 이러한 연산자의 과부하는 값으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2de2491baa0eb4945c698a40f7cf02c5b5ff7ca9" translate="yes" xml:space="preserve">
          <source>Although decl-specifier-seq implies there can exist &lt;a href=&quot;declarations#Specifiers&quot;&gt;specifiers&lt;/a&gt; other than type specifiers, the only other specifier allowed is &lt;code&gt;register&lt;/code&gt;as well as &lt;code&gt;auto&lt;/code&gt;(until C++11), and it has no effect.</source>
          <target state="translated">decl-specifier-seq 는 유형 지정자 이외의 &lt;a href=&quot;declarations#Specifiers&quot;&gt;지정&lt;/a&gt; 자가 존재할 수 있음을 암시하지만 허용되는 유일한 다른 지정자는 &lt;code&gt;auto&lt;/code&gt; 뿐만 아니라 &lt;code&gt;register&lt;/code&gt; (C ++ 11까지)이며 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14b7b14235553f3b91083c0b71081ba75f07e98f" translate="yes" xml:space="preserve">
          <source>Although no class is its own base, &lt;code&gt;std::is_base_of&amp;lt;T, T&amp;gt;::value&lt;/code&gt; is true because the intent of the trait is to model the &quot;is-a&quot; relationship, and T is a T. Despite that, &lt;code&gt;std::is_base_of&amp;lt;int, int&amp;gt;::value&lt;/code&gt; is false because only classes participate in the relationship that this trait models.</source>
          <target state="translated">클래스가 자신의 기본이 아니지만 &lt;code&gt;std::is_base_of&amp;lt;T, T&amp;gt;::value&lt;/code&gt; 는 특성의 의도가 &quot;is-a&quot;관계를 모델링하고 T가 T이기 때문에 true입니다. 그럼에도 불구하고 &lt;code&gt;std::is_base_of&amp;lt;int, int&amp;gt;::value&lt;/code&gt; 는이 특성이 모델링하는 관계에 클래스 만 참여하기 때문에 false입니다.</target>
        </trans-unit>
        <trans-unit id="119fa9e7db8c27df8ae932b0248b04e4bfefb226" translate="yes" xml:space="preserve">
          <source>Although not defined, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt; POSIX time&lt;/a&gt;.</source>
          <target state="translated">정의되지는 않았지만 1970 년 1 월 1 일 UTC 00:00 이후 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;POSIX 시간에&lt;/a&gt; 해당하는 초 수를 포함하는 정수 값 (거의 초를 세지 않음)은 거의 항상 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="ac8975eb41b5df62d74c9b6ae1a1689383a4d797" translate="yes" xml:space="preserve">
          <source>Although references, once initialized, always refer to valid objects or functions, it is possible to create a program where the &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; of the referred-to object ends, but the reference remains accessible (</source>
          <target state="translated">참조가 일단 초기화되면 항상 유효한 객체 또는 함수를 참조하지만 참조 된 객체의 &lt;a href=&quot;lifetime&quot;&gt;수명&lt;/a&gt; 이 끝나지만 참조에 액세스 할 수있는 프로그램을 만들 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="6c367e67cfae5a3c20e167ab56108c7704f6c4ad" translate="yes" xml:space="preserve">
          <source>Although synchronized blocks execute as-if under a global lock, the implementations are expected to examine the code within each block and use optimistic concurrency (backed up by hardware transactional memory where available) for transaction-safe code and minimal locking for non-transaction safe code. When a synchronized block makes a call to a non-inlined function, the compiler may have to drop out of speculative execution and hold a lock around the entire call unless the function is declared &lt;code&gt;transaction_safe&lt;/code&gt; (see below) or the attribute &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; (see below) is used.</source>
          <target state="translated">동기화 된 블록은 전역 잠금 상태에서 그대로 실행되지만 구현시 각 블록 내에서 코드를 검사하고 트랜잭션 안전 코드에 대해 낙관적 동시성 (사용 가능한 경우 하드웨어 트랜잭션 메모리에 의해 백업 됨)을 사용하고 트랜잭션이 아닌 안전에 대한 최소 잠금을 사용해야합니다 암호. 동기화 된 블록이 인라인되지 않은 함수를 호출 할 때, 함수가 &lt;code&gt;transaction_safe&lt;/code&gt; (아래 참조) 또는 속성 &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; 로 선언되지 않은 경우 컴파일러는 추론 적 실행을 중단하고 전체 호출을 잠그어야합니다 . (아래 참조)가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dad5173c2001f38e75509fd69dc64ba3e87866b3" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic cosine&quot; (used by POSIX) or &quot;area hyperbolic cosine&quot;.</source>
          <target state="translated">C 표준 (이 함수에 대해 C ++이 참조하는)은이 함수를 &quot;아크 쌍곡 코사인&quot;이라고 명명하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 주장은 호가 아닌 쌍곡선의 영역이다. 올바른 이름은 &quot;역 쌍곡 코사인&quot;(POSIX에서 사용) 또는 &quot;영역 쌍곡 코사인&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a1733c8cc2a0d050132b6b9364d6944323c32b74" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic sine&quot; (used by POSIX) or &quot;area hyperbolic sine&quot;.</source>
          <target state="translated">C 표준 (이 함수에 대해 C ++이 참조하는)은이 함수의 이름을 &quot;arc hyperbolic sine&quot;이지만 하이퍼 볼릭 함수의 역함수는 영역 함수입니다. 그들의 주장은 호가 아닌 쌍곡선 영역의 영역입니다. 올바른 이름은 &quot;역 쌍곡 사인&quot;(POSIX에서 사용) 또는 &quot;영역 쌍곡 사인&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4277fd8c5f429dde16accb19c538a3e9d0e882ce" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic tangent&quot; (used by POSIX) or &quot;area hyperbolic tangent&quot;.</source>
          <target state="translated">C 표준 (이 함수에 대해 C ++이 참조하는)은이 함수의 이름을 &quot;arc hyperbolic tangent&quot;로 지정하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 주장은 호가 아닌 쌍곡선의 영역이다. 올바른 이름은 &quot;역 쌍곡 탄젠트&quot;(POSIX에서 사용) 또는 &quot;영역 쌍곡 탄젠트&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="91479e7f0ee3ff1337daf6434e5f71cdfdc3c6a6" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic cosine&quot;, and, less common, &quot;complex area hyperbolic cosine&quot;.</source>
          <target state="translated">C ++ 표준에서는이 함수를 &quot;복합 아크 쌍곡 코사인&quot;이라고 명명하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 주장은 호가 아닌 쌍곡선의 영역이다. 올바른 이름은 &quot;복합 역 쌍곡 코사인&quot;이며 덜 일반적으로는 &quot;복합 영역 쌍곡 코사인&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6a7e68fe75439346aeaad1f6906c84e17daadb3b" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic sine&quot;, and, less common, &quot;complex area hyperbolic sine&quot;.</source>
          <target state="translated">C ++ 표준에서는이 기능을 &quot;복합 아크 쌍곡 사인&quot;이라고 명명하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 주장은 호가 아닌 쌍곡선의 영역이다. 올바른 이름은 &quot;복합 역 쌍곡 사인&quot;이며 덜 일반적으로는 &quot;복합 영역 쌍곡 사인&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="8d2c788effcf0da46c782a95d9a9fd3b66474139" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic tangent&quot;, and, less common, &quot;complex area hyperbolic tangent&quot;.</source>
          <target state="translated">C ++ 표준에서는이 기능을 &quot;복합 아크 쌍곡 탄젠트&quot;라고 명명하지만 쌍곡선 함수의 역함수는 영역 함수입니다. 그들의 주장은 호가 아닌 쌍곡선의 영역이다. 올바른 이름은 &quot;복합 역 쌍곡 탄젠트&quot;이고 덜 일반적으로 &quot;복합 영역 쌍곡 탄젠트&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="fd70e10e04c4727c7eb398861b7b422e51e53f42" translate="yes" xml:space="preserve">
          <source>Although the C++11 standard still says &quot;On most machines, this is true for signed integers.&quot;, it is a defect and has been corrected. The exact wording changed from C++03 to C++11 in such a way that the &lt;code&gt;true&lt;/code&gt; value is no longer compatible with &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;undefined behavior on signed integer overflow&lt;/a&gt;. Because of that, the implementations that rely on signed overflow being undefined (for optimization opportunities) now set &lt;code&gt;is_modulo&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for signed integers. See for example &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt;.</source>
          <target state="translated">C ++ 11 표준에는 여전히 &quot;대부분의 컴퓨터에서 부호있는 정수에 해당됩니다.&quot;라고 표시되어 있지만 결함이며 수정되었습니다. 정확한 값은 &lt;code&gt;true&lt;/code&gt; 값이 더 이상 &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;부호있는 정수 오버플로에서 정의되지 않은 동작&lt;/a&gt; 과 호환되지 않도록 C ++ 03에서 C ++ 11로 변경되었습니다 . 이로 인해 (최적화 기회를 위해) 정의되지 않은 부호있는 오버 플로우에 의존하는 구현은 이제 부호있는 정수에 대해 &lt;code&gt;is_modulo&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 합니다. 예를 들어 &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="661de5137e7e9dcc1cb0c7e5d23a45a40d059e70" translate="yes" xml:space="preserve">
          <source>Although the definition uses &lt;code&gt;-1&lt;/code&gt;, &lt;a href=&quot;../basic_string&quot;&gt;&lt;code&gt;size_type&lt;/code&gt;&lt;/a&gt; is an unsigned integer type, and the value of &lt;code&gt;npos&lt;/code&gt; is the largest positive value it can hold, due to &lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;signed-to-unsigned implicit conversion&lt;/a&gt;. This is a portable way to specify the largest value of any unsigned type.</source>
          <target state="translated">정의 사용하지만 &lt;code&gt;-1&lt;/code&gt; , &lt;a href=&quot;../basic_string&quot;&gt; &lt;code&gt;size_type&lt;/code&gt; &lt;/a&gt; 부호없는 정수의 형태이고, 값 &lt;code&gt;npos&lt;/code&gt; 그것으로 인해, 수납 할 수있는 가장 큰 양수 값 인 &lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;서명 투 부호 암시 적 변환&lt;/a&gt; . 이것은 부호없는 유형의 가장 큰 값을 지정하는 이식 가능한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1abd2f0bb23531226358684e90cc6818e8f8598e" translate="yes" xml:space="preserve">
          <source>Although the expression &lt;code&gt;++c.begin()&lt;/code&gt; often compiles, it is not guaranteed to do so: &lt;code&gt;c.begin()&lt;/code&gt; is an rvalue expression, and there is no &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; requirement that specifies that increment of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers, &lt;code&gt;++c.begin()&lt;/code&gt; does not compile, while &lt;code&gt;std::next(c.begin())&lt;/code&gt; does.</source>
          <target state="translated">&lt;code&gt;++c.begin()&lt;/code&gt; 표현식 은 종종 컴파일되지만 그렇게 보장하지는 않습니다. &lt;code&gt;c.begin()&lt;/code&gt; 은 rvalue 표현식이며 rvalue의 증분이 작동하도록 지정하는 &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; 요구 사항 은 없습니다 . 특히 반복자가 포인터로 구현되면 &lt;code&gt;++c.begin()&lt;/code&gt; 은 컴파일되지 않지만 &lt;code&gt;std::next(c.begin())&lt;/code&gt; 은 컴파일 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55ffdbc2010bd6fba5315668a01fc1d2cb4bf01d" translate="yes" xml:space="preserve">
          <source>Although the expression &lt;code&gt;--c.end()&lt;/code&gt; often compiles, it is not guaranteed to do so: &lt;code&gt;c.end()&lt;/code&gt; is an rvalue expression, and there is no iterator requirement that specifies that decrement of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers, &lt;code&gt;--c.end()&lt;/code&gt; does not compile, while &lt;code&gt;std::prev(c.end())&lt;/code&gt; does.</source>
          <target state="translated">&lt;code&gt;--c.end()&lt;/code&gt; 표현식 은 종종 컴파일되지만 그렇게 보장하지는 않습니다. &lt;code&gt;c.end()&lt;/code&gt; 는 rvalue 표현식이며 rvalue의 감소가 작동하도록 지정하는 반복자 요구 사항은 없습니다. 특히 반복자가 포인터로 구현되면 &lt;code&gt;--c.end()&lt;/code&gt; 는 컴파일되지 않지만 &lt;code&gt;std::prev(c.end())&lt;/code&gt; 는 컴파일 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="562d3af0d04be2de0b30b637809f27a622e04faf" translate="yes" xml:space="preserve">
          <source>Although the header &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; is based on the C standard library header &lt;code&gt;errno.h&lt;/code&gt;, the majority of the macros defined by &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; were adopted by C++ from the POSIX standard, rather than the C standard library.</source>
          <target state="translated">비록 헤더 &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; 은 C 표준 라이브러리 헤더를 기반으로 &lt;code&gt;errno.h&lt;/code&gt; 에 의해 정의 된 매크로의 대부분 &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; POSIX 표준보다는 C 표준 라이브러리에서 C ++에 의해 채택되었다.</target>
        </trans-unit>
        <trans-unit id="3db5014665fd46dd8e252214316aa47507ad7ef2" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;std::tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;std::tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::tmpnam&lt;/code&gt; 의해 생성 된 이름 을 추측하기는 어렵지만 &lt;code&gt;std::tmpnam&lt;/code&gt; 리턴하는 순간과이 프로그램이 리턴 된 이름을 사용하여 파일. 표준 함수 &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; 및 POSIX 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; 에는이 문제가 없습니다 (표준 C 라이브러리 만 사용하여 고유 한 디렉토리를 작성하려면 &lt;code&gt;tmpnam&lt;/code&gt; 을 사용해야합니다 ).</target>
        </trans-unit>
        <trans-unit id="c9f3db27755b0d585a653f2d5f3657aa1f21c81b" translate="yes" xml:space="preserve">
          <source>Although the results of comparing pointers of random origin (e.g. not all pointing to members of the same array) is unspecified, many implementations provide &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total ordering&lt;/a&gt; of pointers, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">랜덤 원점의 포인터를 비교 한 결과 (예를 들어, 동일한 어레이의 멤버를 모두 가리키는 것은 아님)가 지정되지 않았지만, 많은 구현 은 포인터가 연속적인 가상 주소 공간 내에서 주소로 구현되는 경우와 같이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;엄격한 총 정렬 순서&lt;/a&gt; 를 제공 합니다. (예를 들어, 포인터의 모든 비트가 메모리 주소의 일부가 아니며 비교를 위해 무시되거나, 추가 계산이 필요하거나 포인터와 정수가 1 : 1 관계가 아닌 경우) 구현은 다음을 제공합니다. &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; 전문화 는 그 보증이있는 포인터에 적합합니다. 이를 통해 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 과 같은 표준 연관 컨테이너에서 무작위 원점의 모든 포인터를 키로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8a747e33a10c6fa21c941b73f1438fc704b6283" translate="yes" xml:space="preserve">
          <source>Although the return type is &lt;code&gt;char*&lt;/code&gt;, modifying the pointed-to characters is undefined behavior.</source>
          <target state="translated">리턴 유형이 &lt;code&gt;char*&lt;/code&gt; 이지만, 지정된 문자를 수정하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="1a131648c16bdab1f4ad67b397e73af609dc5ab0" translate="yes" xml:space="preserve">
          <source>Although the return type is not allowed in the declaration of a user-defined conversion function, the decl-specifier-seq of &lt;a href=&quot;declarations#Specifiers&quot;&gt;the declaration grammar&lt;/a&gt; may be present and may include any specifier other than type-specifier or the keyword static, In particular, besides &lt;code&gt;explicit&lt;/code&gt;, the specifiers &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt;, &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;, and &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; are also allowed (note that &lt;code&gt;friend&lt;/code&gt; requires a qualified name: &lt;code&gt;friend A::operator B();&lt;/code&gt;).</source>
          <target state="translated">사용자 정의 변환 함수 선언에서 리턴 유형이 허용되지 않지만 &lt;a href=&quot;declarations#Specifiers&quot;&gt;선언 문법&lt;/a&gt; 의 decl-specifier-seq 가 존재할 수 있으며 type-specifier 또는 키워드 static 이외의 다른 지정자를 포함 할 수 있습니다. 특히 &lt;code&gt;explicit&lt;/code&gt; 인 경우 지정자 &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; , &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt; , &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; 및 &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; 도 허용됩니다 ( &lt;code&gt;friend&lt;/code&gt; 는 규정 된 이름이 필요합니다 ( &lt;code&gt;friend A::operator B();&lt;/code&gt; )).</target>
        </trans-unit>
        <trans-unit id="d77898594331af7d94d8805113c2ae7cc96df8a5" translate="yes" xml:space="preserve">
          <source>Although the standard requires that this facet works with UCS2 when the size of &lt;code&gt;Elem&lt;/code&gt; is 16 bits, some implementations use UTF-16 instead, making this a non-converting locale. The term &quot;UCS2&quot; was deprecated and removed from the Unicode standard.</source>
          <target state="translated">표준은 &lt;code&gt;Elem&lt;/code&gt; 의 크기 가 16 비트 일 때이 패싯이 UCS2와 작동하도록 요구하지만 일부 구현에서는 UTF-16을 대신 사용하므로 변환되지 않는 로케일이됩니다. &quot;UCS2&quot;라는 용어는 더 이상 사용되지 않으며 유니 코드 표준에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="3eafdced96881df5338499ac356a8e8f50b8bc53" translate="yes" xml:space="preserve">
          <source>Although the standard requires that this facet works with UCS2 when the size of &lt;code&gt;Elem&lt;/code&gt; is 16 bits, some implementations use UTF-16 instead. The term &quot;UCS2&quot; was deprecated and removed from the Unicode standard.</source>
          <target state="translated">표준은 &lt;code&gt;Elem&lt;/code&gt; 의 크기 가 16 비트 일 때이 패싯이 UCS2에서 작동하도록 요구하지만 일부 구현에서는 UTF-16을 대신 사용합니다. &quot;UCS2&quot;라는 용어는 더 이상 사용되지 않으며 유니 코드 표준에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="a91bcce893b5de905ecbd22a99a03889cdcc2544" translate="yes" xml:space="preserve">
          <source>Always</source>
          <target state="translated">Always</target>
        </trans-unit>
        <trans-unit id="fe09758345685e241df672635cfac946bfc561d8" translate="yes" xml:space="preserve">
          <source>Always-throwing functions</source>
          <target state="translated">항상 던지는 기능</target>
        </trans-unit>
        <trans-unit id="4df6b8083eb91bc6a923cb0c4bf5c1ae0e994985" translate="yes" xml:space="preserve">
          <source>Ambiguous and nonexistent local times can occur as a result of time zone transitions (such as daylight saving time). For example, &quot;2016-03-13 02:30:00&quot; does not exist in the &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; time zone, while &quot;2016-11-06 01:30:00&quot; in that time zone can correspond to two UTC time points: 2016-11-06 05:30:00 UTC and 2016-11-06 06:30:00 UTC.</source>
          <target state="translated">시간대 전환 (일광 절약 시간 등)으로 인해 모호하고 존재하지 않는 현지 시간이 발생할 수 있습니다. 예를 들어 &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; 시간대 에는 &quot;2016-03-13 02:30:00&quot;이없고 해당 시간대의 &quot;2016-11-06 01:30:00&quot;은 두 UTC에 해당 할 수 있습니다. 시점 : 2016-11-06 05:30:00 UTC 및 2016-11-06 06:30:00 UTC</target>
        </trans-unit>
        <trans-unit id="c067979f83933e6c4d89a2c1e0fb562a0f280310" translate="yes" xml:space="preserve">
          <source>Ambiguous conversion sequences are ranked as user-defined conversion sequences because multiple conversion sequences for an argument can exist only if they involve different user-defined conversions:</source>
          <target state="translated">모호한 변환 시퀀스는 사용자 정의 변환 시퀀스로 순위가 매겨집니다. 인수에 대해 여러 변환 시퀀스가 ​​다른 사용자 정의 변환과 관련된 경우에만 존재할 수 있으므로</target>
        </trans-unit>
        <trans-unit id="5aa47b263945205f7df82cf554dee097502b0d78" translate="yes" xml:space="preserve">
          <source>Amortized constant number of invocations of &lt;code&gt;g.operator()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;g.operator()&lt;/code&gt; 의 상실된 상수 호출 횟수 .</target>
        </trans-unit>
        <trans-unit id="128bb665ca4a35fff2ef43cce127f6f8f60033b5" translate="yes" xml:space="preserve">
          <source>Amortized constant number of invocations of &lt;code&gt;g&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 의 상각 상수 호출 횟수</target>
        </trans-unit>
        <trans-unit id="1cbb525f8d6525a8ab447903dfd14ddbdc0818e6" translate="yes" xml:space="preserve">
          <source>Amortized constant on average, worst case linear in the size of the container.</source>
          <target state="translated">컨테이너의 크기에서 평균적으로 최악의 경우 선형으로 상각됩니다.</target>
        </trans-unit>
        <trans-unit id="50471dc8ecc10f0a607efbdd965811e70e031a13" translate="yes" xml:space="preserve">
          <source>Amortized constant.</source>
          <target state="translated">상각 상수.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="45ea68905c72735578b243d8c992010c73dd2b71" translate="yes" xml:space="preserve">
          <source>An 8-bit binary type can represent any two-digit decimal number exactly, but 3-digit decimal numbers 256..999 cannot be represented. The value of &lt;code&gt;digits10&lt;/code&gt; for an 8-bit type is 2 (&lt;code&gt;8 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; is 2.41).</source>
          <target state="translated">8 비트 이진 유형은 두 자리 10 진수를 정확하게 나타낼 수 있지만 3 자리 10 진수 256..999는 표현할 수 없습니다. 8 비트 유형 의 &lt;code&gt;digits10&lt;/code&gt; 의 값 은 2입니다 ( &lt;code&gt;8 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; 는 2.41입니다).</target>
        </trans-unit>
        <trans-unit id="b70a29f58335fff2ae0f72bb6d64b3b5da9003ef" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../language/type-id&quot;&gt;arithmetic type&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../language/type-id&quot;&gt;산술 유형&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="807382b205cd61b4e07e059d92477e9e7b450d4d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation&lt;/a&gt; or deallocation function for a class is odr-used by a &lt;a href=&quot;new&quot;&gt;new expression&lt;/a&gt; appearing in a potentially-evaluated expression</source>
          <target state="translated">&lt;a href=&quot;../memory/new/operator_new&quot;&gt;할당&lt;/a&gt; 클래스 또는 해제 기능을하는 ODR 의해 사용되는 &lt;a href=&quot;new&quot;&gt;새로운 표현&lt;/a&gt; 잠재적-평가 식에 나타나는</target>
        </trans-unit>
        <trans-unit id="8d5b39fd5f28e44fd4cbe7c1a6e4527324fdb198" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;asm&quot;&gt;asm declaration&lt;/a&gt; does not define any entities, but it is classified as a definition.</source>
          <target state="translated">&lt;a href=&quot;asm&quot;&gt;ASM 선언은&lt;/a&gt; 어떤 엔티티를 정의하지 않지만, 그것은 정의로 분류된다.</target>
        </trans-unit>
        <trans-unit id="d3db36c93422d5b474b182b8149fdd0c74f76e94" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; sequence attr may appear just before the label (in which case it applies to the label), or just before any statement itself, in which case it applies to the entire statement. A statement may carry multiple labels. Labels (and only labels) have &lt;a href=&quot;scope#Function_scope&quot;&gt;function scope&lt;/a&gt;. Labels are ignored by &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified lookup&lt;/a&gt;: a label can have the same name as any other entity in the program.</source>
          <target state="translated">&lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 순서 ATTR가 나타날 수 있습니다 단지 라벨 (이 경우는 라벨에 적용)하기 전에, 또는 그냥 전체 문에 적용되는 경우에는 명령문 자체 전에. 명세서에는 여러 개의 레이블이있을 수 있습니다. 레이블 (및 레이블 만)에는 &lt;a href=&quot;scope#Function_scope&quot;&gt;기능 범위가&lt;/a&gt; 있습니다. &lt;a href=&quot;unqualified_lookup&quot;&gt;규정되지 않은 조회&lt;/a&gt; 에서는 레이블이 무시됩니다 . 레이블은 프로그램의 다른 엔티티와 동일한 이름을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67d8f4f0c409d53bf6fc239c4572103225de8737" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;class_template#Class_template_instantiation&quot;&gt;explicit instantiation declaration&lt;/a&gt; (an &quot;extern template&quot;)</source>
          <target state="translated">&lt;a href=&quot;class_template#Class_template_instantiation&quot;&gt;명시 적 인스턴스화 선언&lt;/a&gt; (에 &quot;통근 템플릿&quot;)</target>
        </trans-unit>
        <trans-unit id="e8d07ab60f03237d43aaac774ff0a48905536383" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;declarations&quot;&gt;attribute declaration&lt;/a&gt; (does not define any entities)</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;속성 선언&lt;/a&gt; (모든 엔티티를 정의하지 않습니다)</target>
        </trans-unit>
        <trans-unit id="8250bcb5d0e5dcdf0fb994dd06a03c09d7251e75" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;declarations&quot;&gt;empty declaration&lt;/a&gt; (does not define any entities)</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;빈 선언&lt;/a&gt; (모든 엔티티를 정의하지 않습니다)</target>
        </trans-unit>
        <trans-unit id="1cae5b3ce33128b19eacc0658479be44746e7c43" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;enum&quot;&gt;opaque declaration&lt;/a&gt; of an enumeration</source>
          <target state="translated">열거 의 &lt;a href=&quot;enum&quot;&gt;불투명 한 선언&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97e3c29d16d88a0e096a7e69f7173bded9fa122e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; whose category and types are the same as &lt;code&gt;X::const_iterator&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; 그 범주 및 유형과 동일 &lt;code&gt;X::const_iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf13631c6d364b349a268bbd81c204b7997b1947" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; whose category and types are the same as &lt;code&gt;X::iterator&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; 그 범주 및 유형과 동일 &lt;code&gt;X::iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c036f0c614197c69e50ff0747f60db77d1ca80a7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;name&quot;&gt;identifier&lt;/a&gt; that names a non-type template parameter of class type &lt;code&gt;T&lt;/code&gt; denotes a static storage duration object of type &lt;code&gt;const T&lt;/code&gt;, called a</source>
          <target state="translated">클래스 유형 &lt;code&gt;T&lt;/code&gt; 의 비 유형 템플릿 매개 변수 이름을 지정 하는 &lt;a href=&quot;name&quot;&gt;식별자&lt;/a&gt; 는 &lt;code&gt;const T&lt;/code&gt; 유형의 정적 저장 기간 개체를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c6fbfbd5514da52daf4588bb104a4a85d038970e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;name#In_expressions&quot;&gt;identifier expression&lt;/a&gt; that denotes an immediate function may only appear within a subexpression of an immediate invocation or within an immediate function context. A pointer or reference to an immediate function can be taken but cannot escape constant expression evaluation:</source>
          <target state="translated">&lt;a href=&quot;name#In_expressions&quot;&gt;식별자 식&lt;/a&gt; 즉시 함수를 나타내고 만 즉시 호출의 표현식 내에 또는 즉각적으로 기능 컨텍스트 내에 나타날 수있다. 즉각적인 함수에 대한 포인터 또는 참조는 취할 수 있지만 상수 표현식 평가를 피할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4835e23540157d178506c76dbed3585b131cd6c2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt; whose declaration is not a definition.</source>
          <target state="translated">&lt;a href=&quot;template_specialization&quot;&gt;명시 적 전문화&lt;/a&gt; 그 선언은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0476037f5a01ed84f4c68efe6578d34ee836c695" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;type_alias&quot;&gt;alias-declaration&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;type_alias&quot;&gt;별명 선언&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec273bcf1f66db0db9b6197343f94ba32b5eec31" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; of function type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to a &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt;&lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;pointer to that function&lt;/a&gt;. This does not apply to non-static member functions because lvalues that refer to non-static member functions do not exist.</source>
          <target state="translated">함수 유형 &lt;code&gt;T&lt;/code&gt; 의 &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; 는 해당 함수 에 대한 &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue &lt;/a&gt;&lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;포인터로&lt;/a&gt; 내재적으로 변환 될 수 있습니다 . 비 정적 멤버 함수를 참조하는 lvalue가 존재하지 않으므로 비 정적 멤버 함수에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ba6cc034ab70817b81a34ed74af74dd8855a970" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; or &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; of type &quot;array of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;T&lt;/code&gt;&quot; or &quot;array of unknown bound of &lt;code&gt;T&lt;/code&gt;&quot; can be implicitly converted to a &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt; of type &quot;pointer to &lt;code&gt;T&lt;/code&gt;&quot;. If the array is a prvalue, &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; occurs.(since C++17) The resulting pointer refers to the first element of the array (see &lt;a href=&quot;array#Array-to-pointer_decay&quot;&gt;array to pointer decay&lt;/a&gt; for details).</source>
          <target state="translated">&lt;a href=&quot;value_category#lvalue&quot;&gt;좌변&lt;/a&gt; 또는 &lt;a href=&quot;value_category#rvalue&quot;&gt;를 rvalue&lt;/a&gt; 유형 &quot;의 배열의 &lt;code&gt;N&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; &quot;또는 &quot;의 경계 알 수없는 배열 &lt;code&gt;T&lt;/code&gt; 는 &quot;암시 적으로 변환 할 수 있습니다 &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt; 유형 &quot;에 대한 포인터의 &lt;code&gt;T&lt;/code&gt; &quot;. 배열이 prvalue 인 경우 &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;임시 materialization이&lt;/a&gt; 발생합니다. (C ++ 17부터) 결과 포인터는 배열의 첫 번째 요소를 나타냅니다 (자세한 내용은 &lt;a href=&quot;array#Array-to-pointer_decay&quot;&gt;포인터가 붕괴&lt;/a&gt; 될 배열 참조).</target>
        </trans-unit>
        <trans-unit id="3b75a307aa52c5825d1730c4cdd4f9a558685208" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; object containing the given values.</source>
          <target state="translated">주어진 값을 포함 하는 &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="d6c35561be6c0db7de52088fd8b63305b7a7d8f9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; holding a pointer to the beginning of the allocated storage and the number of objects that fit in the storage that was actually allocated.</source>
          <target state="translated">할당 된 스토리지의 시작과 실제로 할당 된 스토리지에 적합한 오브젝트 수에 대한 포인터를 보유 하는 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="64c0acf093e82ca7c2d56259ef132c09f1d727d8" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;AllocatorAwareContainer&lt;/strong&gt; is a &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt; that holds an instance of an &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; and uses that instance in all its member functions to allocate and deallocate memory and to construct and destroy objects in that memory (such objects may be container elements, nodes, or, for unordered containers, bucket arrays).</source>
          <target state="translated">&lt;strong&gt;AllocatorAwareContainer는&lt;/strong&gt; A는 &lt;a href=&quot;container&quot;&gt;컨테이너&lt;/a&gt; 한는 인스턴스 보유 &lt;a href=&quot;allocator&quot;&gt;할당 자&lt;/a&gt; 와 모든 멤버 함수의 인스턴스를 할당하고 할당 해제 메모리 구성하는 등 오브젝트 순서화 용기 컨테이너 엘리먼트, 노드, 또는 일 수있다 (즉, 메모리 내에 오브젝트를 파괴하는 것을 용도 , 버킷 배열).</target>
        </trans-unit>
        <trans-unit id="eaa15e16e5ec0c95afc353328fbb4fb678121869" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;AssociativeContainer&lt;/strong&gt; is an ordered &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt; that provides fast lookup of objects based on keys.</source>
          <target state="translated">&lt;strong&gt;AssociativeContainer의는&lt;/strong&gt; 주문한이다 &lt;a href=&quot;container&quot;&gt;컨테이너&lt;/a&gt; 키를 기준으로 객체의 빠른 검색을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b5c5d4aca5ec3c0868d0e700b371604b1ec448c3" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;LegacyInputIterator&lt;/strong&gt; is an &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; that can read from the pointed-to element. LegacyInputIterators only guarantee validity for single pass algorithms: once an LegacyInputIterator &lt;code&gt;i&lt;/code&gt; has been incremented, all copies of its previous value may be invalidated.</source>
          <target state="translated">&lt;strong&gt;LegacyInputIterator은&lt;/strong&gt; 입니다 &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; 뾰족한-에 요소에서 읽을 수 있습니다. LegacyInputIterator는 단일 패스 알고리즘에 대해서만 유효성을 보장합니다. 일단 LegacyInputIterator &lt;code&gt;i&lt;/code&gt; 가 증가하면 이전 값의 모든 사본이 무효화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a021125aae1a0c5f6666fbd70ad3091d5eaf4be5" translate="yes" xml:space="preserve">
          <source>An UnformattedInputFunction is a stream input function that performs the following:</source>
          <target state="translated">UnformattedInputFunction은 다음을 수행하는 스트림 입력 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ce56470376a6a1e9f7a374ada94b689a0ac77bd6" translate="yes" xml:space="preserve">
          <source>An abstract class is a class that either defines or inherits at least one function for which &lt;a href=&quot;virtual&quot;&gt;the final overrider&lt;/a&gt; is pure virtual.</source>
          <target state="translated">추상 클래스는 &lt;a href=&quot;virtual&quot;&gt;최종 재정의&lt;/a&gt; 가 순수 가상 인 함수를 하나 이상 정의하거나 상속하는 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="908b2d8b11e075496d08f7d7d4b01d8354d7a3e1" translate="yes" xml:space="preserve">
          <source>An additional class template &lt;code&gt;auto_ptr_ref&lt;/code&gt; is referred to throughout the documentation. It is an implementation-defined type that holds a reference to &lt;code&gt;auto_ptr&lt;/code&gt;. The implementation is allowed to provide the template with a different name or implement the functions returning it or accepting it as parameter in other ways.</source>
          <target state="translated">추가 클래스 템플릿 &lt;code&gt;auto_ptr_ref&lt;/code&gt; 는 설명서 전체에서 참조됩니다. &lt;code&gt;auto_ptr&lt;/code&gt; 에 대한 참조를 보유하는 구현 정의 유형입니다 . 구현시 템플릿에 다른 이름을 제공하거나 템플릿을 반환하거나 다른 방식으로 매개 변수로 받아들이는 기능을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="492bf377c49f20efce1a6cebadb795c9f43e068d" translate="yes" xml:space="preserve">
          <source>An additional rule is applied to the deduction in this case: when comparing function parameters &lt;code&gt;P&lt;/code&gt;i and &lt;code&gt;A&lt;/code&gt;i, if any &lt;code&gt;P&lt;/code&gt;i is an rvalue reference to cv-unqualified template parameter (a &quot;forwarding reference&quot;) and the corresponding &lt;code&gt;A&lt;/code&gt;i is an lvalue reference, then &lt;code&gt;P&lt;/code&gt;i is adjusted to the template parameter type (T&amp;amp;&amp;amp; becomes T).</source>
          <target state="translated">추가적인 규칙이 경우 공제에 적용된다 : 함수 파라미터 비교시 &lt;code&gt;P&lt;/code&gt; 를 I 및 &lt;code&gt;A&lt;/code&gt; 가 있는 경우 나, &lt;code&gt;P&lt;/code&gt; 나 CV-비정규 템플릿 파라미터 (a &quot;착신 기준&quot;) 및 대응에 r- 수치 기준이고 &lt;code&gt;A&lt;/code&gt; 는 내가 인 lvalue reference를 입력하면 &lt;code&gt;P&lt;/code&gt; i가 템플릿 매개 변수 유형으로 조정됩니다 (T &amp;amp;&amp;amp;는 T가 됨).</target>
        </trans-unit>
        <trans-unit id="39f1e2f1f4a1f2712c275be633629814179e5046" translate="yes" xml:space="preserve">
          <source>An aggregate class or array may include non-aggregate public bases(since C++17), members, or elements, which are initialized as described above (e.g. copy-initialization from the corresponding initializer clause).</source>
          <target state="translated">집계 클래스 또는 배열에는 위에서 설명 된대로 초기화 된 비 집계 퍼블릭베이스 (C ++ 17부터), 멤버 또는 요소가 포함될 수 있습니다 (예 : 해당 초기화 섹션에서 복사 초기화).</target>
        </trans-unit>
        <trans-unit id="b197d6cc29c7895c847275964c7060dca3357d57" translate="yes" xml:space="preserve">
          <source>An aggregate is one of the following types:</source>
          <target state="translated">집계는 다음 유형 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="12db35057383aa0593fc91fb24bea2072f9fc5b7" translate="yes" xml:space="preserve">
          <source>An algorithm to &quot;clamp&quot; a value between a pair of boundary values (&lt;code&gt;&lt;a href=&quot;algorithm/clamp&quot;&gt;std::clamp&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">경계 값 쌍 사이의 값을 &quot;클램프&quot;하는 알고리즘 ( &lt;code&gt;&lt;a href=&quot;algorithm/clamp&quot;&gt;std::clamp&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6a4c8075a51ee48f2fc8e9678f381d4c2cc5cd9e" translate="yes" xml:space="preserve">
          <source>An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;. The behavior is undefined if &lt;code&gt;Allocator::value_type&lt;/code&gt; is not the same as &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">메모리를 획득 / 릴리즈하고 해당 메모리의 요소를 구성 / 파기하는 데 사용되는 할당 자. 유형은 &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; 의 요구 사항을 충족해야합니다 . &lt;code&gt;Allocator::value_type&lt;/code&gt; 이 &lt;code&gt;T&lt;/code&gt; 와 다르면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2b7e6c1744a360683380fca88796315c08727ff6" translate="yes" xml:space="preserve">
          <source>An allocator type &lt;code&gt;X&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt; additionally satisfies the</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 에 대한 할당 자 유형 &lt;code&gt;X&lt;/code&gt; 는 추가로</target>
        </trans-unit>
        <trans-unit id="8d97370574b17753b94ede73aa5e362da9eb3aac" translate="yes" xml:space="preserve">
          <source>An arithmetic type or a class emulating an arithmetic type</source>
          <target state="translated">산술 유형 또는 산술 유형을 에뮬레이트하는 클래스</target>
        </trans-unit>
        <trans-unit id="c52cf5a897774b32a3cc4643437d36a5b1792813" translate="yes" xml:space="preserve">
          <source>An array can also be used as a tuple of &lt;code&gt;N&lt;/code&gt; elements of the same type.</source>
          <target state="translated">배열은 같은 유형 의 &lt;code&gt;N&lt;/code&gt; 요소 튜플로도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ac3648865a50f77bee68245b1bc8d2b8af79b49" translate="yes" xml:space="preserve">
          <source>An array declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">배열 선언은 &lt;a href=&quot;declarations&quot;&gt;선언자가&lt;/a&gt; 양식을 갖는 간단한 선언입니다 .</target>
        </trans-unit>
        <trans-unit id="f97a7d14a3134d2ce52774abf33446e4a447d088" translate="yes" xml:space="preserve">
          <source>An assignment operator in a class &lt;code&gt;T&lt;/code&gt; that is a member or base of another class &lt;code&gt;U&lt;/code&gt; is odr-used by an implicitly-defined copy-assignment or move-assignment functions of &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">클래스 &lt;code&gt;T&lt;/code&gt; 에서 다른 클래스 &lt;code&gt;U&lt;/code&gt; 의 멤버 또는베이스 인 할당 연산자 는 암시 적으로 정의 된 복사 할당 또는 이동 할당 함수 &lt;code&gt;U&lt;/code&gt; 에 의해 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="2bc87d164b8e7f6ecde4c668667f3c0239908e17" translate="yes" xml:space="preserve">
          <source>An associative container &lt;code&gt;X&lt;/code&gt; that is either &lt;code&gt;std::map&lt;/code&gt; and &lt;code&gt;std::multimap&lt;/code&gt; additionally supports the expression X::mapped_type, which has a return type of T, with the requirement that &lt;code&gt;T&lt;/code&gt; be &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and compile time complexity.</source>
          <target state="translated">연관 컨테이너 &lt;code&gt;X&lt;/code&gt; 중 하나입니다 &lt;code&gt;std::map&lt;/code&gt; 및 &lt;code&gt;std::multimap&lt;/code&gt; 추가로한다는 요구 사항, 표현의 X :: mapped_type, T의 반환 유형이 지원 &lt;code&gt;T&lt;/code&gt; 가 될 &lt;a href=&quot;destructible&quot;&gt;파괴 가능&lt;/a&gt; 하고, 컴파일 시간 복잡도.</target>
        </trans-unit>
        <trans-unit id="864fa04b4ed98eae74afcfaa9ef56bb780bc69ce" translate="yes" xml:space="preserve">
          <source>An asynchronous operation (created via &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;) can provide a &lt;code&gt;std::future&lt;/code&gt; object to the creator of that asynchronous operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 를 통해 작성된 비동기 작업은 해당 비동기 작업의 작성자에게 &lt;code&gt;std::future&lt;/code&gt; 객체를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e8f8230bc284edbfa18713cf06662ed31c603fb" translate="yes" xml:space="preserve">
          <source>An atomic &lt;a href=&quot;memory_order&quot;&gt;release operation&lt;/a&gt; X in thread A synchronizes-with an acquire fence F in thread B, if.</source>
          <target state="translated">스레드 A 의 원자 &lt;a href=&quot;memory_order&quot;&gt;해제 작업&lt;/a&gt; X는 스레드 B의 획득 펜스 F와 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="928fdce82eda51be195710313098b2223ec96c39" translate="yes" xml:space="preserve">
          <source>An atomic constraint consists of an expression &lt;code&gt;E&lt;/code&gt; and a mapping from the template parameters that appear within &lt;code&gt;E&lt;/code&gt; to template arguments involving the template parameters of the constrained entity, called its</source>
          <target state="translated">원자 제약 식의 구성 &lt;code&gt;E&lt;/code&gt; 와 내에서 표시되는 템플릿 매개 변수에서 매핑 &lt;code&gt;E&lt;/code&gt; 제약 기업의 템플릿 매개 변수를 포함하는 템플릿 인자로 불리는 그</target>
        </trans-unit>
        <trans-unit id="5a79829f8c7b85fe4e4638dfbea954acbd0eda02" translate="yes" xml:space="preserve">
          <source>An atomic operation A on some atomic object M is</source>
          <target state="translated">일부 원자 객체 M의 원자 연산 A는</target>
        </trans-unit>
        <trans-unit id="5a5310902368573c36e555b627b994b235e68248" translate="yes" xml:space="preserve">
          <source>An attribute can be used almost everywhere in the C++ program, and can be applied to almost everything: to types, to variables, to functions, to names, to code blocks, to entire translation units, although each particular attribute is only valid where it is permitted by the implementation: &lt;code&gt;[[expect_true]]&lt;/code&gt; could be an attribute that can only be used with an &lt;code&gt;if&lt;/code&gt;, and not with a class declaration. &lt;code&gt;[[omp::parallel()]]&lt;/code&gt; could be an attribute that applies to a code block or to a &lt;code&gt;for&lt;/code&gt; loop, but not to the type &lt;code&gt;int&lt;/code&gt;, etc. (note these two attributes are fictional examples, see below for the standard and some non-standard attributes).</source>
          <target state="translated">속성은 C ++ 프로그램의 거의 모든 곳에서 사용할 수 있으며 유형, 변수, 함수, 이름, 코드 블록, 전체 변환 단위에 거의 모든 것에 적용될 수 있습니다. 각 특정 속성은 해당 위치에서만 유효합니다. 구현에 의해 허용된다 : &lt;code&gt;[[expect_true]]&lt;/code&gt; 만 함께 사용할 수있는 속성이 될 수 &lt;code&gt;if&lt;/code&gt; 클래스 선언, 그리고. &lt;code&gt;[[omp::parallel()]]&lt;/code&gt; 은 코드 블록 또는 &lt;code&gt;for&lt;/code&gt; 루프에 적용되지만 &lt;code&gt;int&lt;/code&gt; 유형에는 적용되지 않는 속성 일 수 있습니다.이 두 속성은 가상의 예입니다. 표준 및 일부 비표준 속성).</target>
        </trans-unit>
        <trans-unit id="3b30276e5eb22d8f2d82beaa0982183267864ede" translate="yes" xml:space="preserve">
          <source>An ellipsis &lt;code&gt;...&lt;/code&gt; may appear at the end of the parameter list; this declares a &lt;a href=&quot;variadic_arguments&quot;&gt;variadic function&lt;/a&gt;:</source>
          <target state="translated">매개 변수 목록 끝에 줄임표 ( &lt;code&gt;...&lt;/code&gt; ) 가 나타날 수 있습니다. 이것은 &lt;a href=&quot;variadic_arguments&quot;&gt;variadic 함수를&lt;/a&gt; 선언 합니다 :</target>
        </trans-unit>
        <trans-unit id="7b28c53044424dbd671a0a292fff9b11ed2f240c" translate="yes" xml:space="preserve">
          <source>An empty path can be obtained by calling &lt;a href=&quot;clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; and by default-constructing a &lt;code&gt;path&lt;/code&gt;. It can also be returned by a path decomposition function (such as &lt;a href=&quot;extension&quot;&gt;&lt;code&gt;extension&lt;/code&gt;&lt;/a&gt;) if the corresponding component is not present in the path.</source>
          <target state="translated">&lt;a href=&quot;clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 를 호출 하고 기본적으로 &lt;code&gt;path&lt;/code&gt; 를 구성하여 빈 경로를 얻을 수 있습니다 . 해당 구성 요소가 경로에없는 경우 경로 분해 기능 (예 : &lt;a href=&quot;extension&quot;&gt; &lt;code&gt;extension&lt;/code&gt; &lt;/a&gt; ) 으로 리턴 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ecc5a9f5ce0682a542e5d3a7d4ffa7f954c9836" translate="yes" xml:space="preserve">
          <source>An empty path is classified as a relative path.</source>
          <target state="translated">빈 경로는 상대 경로로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="96c80c138bff7aa336c0c80903e065616c06546c" translate="yes" xml:space="preserve">
          <source>An empty range is lexicographically</source>
          <target state="translated">빈 범위는 사전 식으로</target>
        </trans-unit>
        <trans-unit id="c5d73f72c6721b75502428576903171289a2fc14" translate="yes" xml:space="preserve">
          <source>An empty shared_ptr (where &lt;code&gt;use_count() == 0&lt;/code&gt;) may store a non-null pointer accessible by &lt;code&gt;get()&lt;/code&gt;, e.g. if it were created using the aliasing constructor.</source>
          <target state="translated">빈 shared_ptr (여기서 &lt;code&gt;use_count() == 0&lt;/code&gt; )은 &lt;code&gt;get()&lt;/code&gt; 액세스 할 수있는 null이 아닌 포인터를 저장할 수 있습니다 ( 예 : 별칭 생성자를 사용하여 만든 경우 ) .</target>
        </trans-unit>
        <trans-unit id="bf3e0e6688aa2181023a253a9e87db009478a78e" translate="yes" xml:space="preserve">
          <source>An empty string if the character sequence is not a valid collating element</source>
          <target state="translated">문자 순서가 유효한 조합 요소가 아닌 경우 빈 문자열</target>
        </trans-unit>
        <trans-unit id="3d82664471aad182109ca58741b1d45d1271d6cf" translate="yes" xml:space="preserve">
          <source>An enumeration is defined by</source>
          <target state="translated">열거는 다음에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="afe5baa45aa238529a9d9f5521326fb55bc4227f" translate="yes" xml:space="preserve">
          <source>An equivalent effect may be achieved with the facilities provided by &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; 제공하는 기능으로 동등한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26b27f109fdc73d104fb47c91bb0233ff5e7c5ad" translate="yes" xml:space="preserve">
          <source>An example of a custom operator&amp;lt;=&amp;gt; that returns &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt; is an operator that compares every member of a class, except in order that is different from the default (here: last name first).</source>
          <target state="translated">&lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt; &lt;code&gt;std::strong_ordering&lt;/code&gt; &lt;/a&gt; 을 리턴하는 사용자 정의 연산자 &amp;lt;=&amp;gt;의 예는 기본값과 다른 순서를 제외하고 클래스의 모든 멤버를 비교하는 연산자입니다 (여기서는 성).</target>
        </trans-unit>
        <trans-unit id="e794383d64707bd6aee1a7ffa3033ac34c3317b6" translate="yes" xml:space="preserve">
          <source>An example of a custom operator&amp;lt;=&amp;gt; that returns &lt;a href=&quot;../utility/compare/weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt; is an operator that compares string members of a class in case-insensitive manner: this is different from the default comparison (so a custom operator is required) and it's possible to distinguish two strings that compare equal under this comparison.</source>
          <target state="translated">&lt;a href=&quot;../utility/compare/weak_ordering&quot;&gt; &lt;code&gt;std::weak_ordering&lt;/code&gt; &lt;/a&gt; 을 리턴하는 사용자 정의 연산자 &amp;lt;=&amp;gt;의 예는 대소 문자를 구분하지 않는 방식으로 클래스의 문자열 멤버를 비교하는 연산자입니다. 이는 기본 비교와 다르며 (따라서 사용자 정의 연산자가 필요함) 가능합니다. 이 비교에서 동일하게 비교되는 두 개의 문자열을 구별하십시오.</target>
        </trans-unit>
        <trans-unit id="bc3fdebc617a723576859b7b78597b5a6e61e62e" translate="yes" xml:space="preserve">
          <source>An example of a type that implements LegacyOutputIterator is &lt;a href=&quot;../iterator/ostream_iterator&quot;&gt;std::ostream_iterator&lt;/a&gt;.</source>
          <target state="translated">LegacyOutputIterator를 구현하는 유형의 예는 &lt;a href=&quot;../iterator/ostream_iterator&quot;&gt;std :: ostream_iterator&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="831c258222c425472a6e48db4facf3170a3cef28" translate="yes" xml:space="preserve">
          <source>An example of an inheritance hierarchy with virtual base classes is the iostreams hierarchy of the standard library: &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; using virtual inheritance. &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; is derived from both &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt;, so every instance of &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; contains a &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; subobject, a &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; subobject, and just one &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; subobject (and, consequently, one &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">가상 기본 클래스가있는 상속 계층의 예는 표준 라이브러리의 iostreams 계층입니다. &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; 은 가상 상속을 사용하여 &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; 에서 파생됩니다 . &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; 에서 파생 되므로 &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; 의 모든 인스턴스 에는 &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; 하위 오브젝트, &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; 하위 오브젝트 및 단 하나의 &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; 하위 오브젝트 ( 결과적으로 하나의 &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="41464d61485a2aac603dadcdf39c0ce3781751e5" translate="yes" xml:space="preserve">
          <source>An example of when such declaration is used is the implementation of &lt;code&gt;&lt;a href=&quot;../types/is_function&quot;&gt;std::is_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 선언이 사용되는 예는 &lt;code&gt;&lt;a href=&quot;../types/is_function&quot;&gt;std::is_function&lt;/a&gt;&lt;/code&gt; 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="bdba113faa387d1ab71c87afef4ec469f4cc925c" translate="yes" xml:space="preserve">
          <source>An example where int-returning &lt;code&gt;uncaught_exceptions&lt;/code&gt; is used is the &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; library: the expression &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; first creates a guard object and records the number of uncaught exceptions in its constructor. The output is performed by the guard object's destructor unless foo() throws (in which case the number of uncaught exceptions in the destructor is greater than what the constructor observed).</source>
          <target state="translated">int-returning &lt;code&gt;uncaught_exceptions&lt;/code&gt; 가 사용되는 예는 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; 라이브러리입니다. 표현식 &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; 먼저 가드 객체를 만들고 생성자에서 포착되지 않은 예외 수를 기록합니다. 출력은 foo ()가 발생하지 않는 한 가드 객체의 소멸자에 의해 수행됩니다 (이 경우 소멸자에서 포착되지 않은 예외의 수가 생성자가 관찰 한 것보다 큼).</target>
        </trans-unit>
        <trans-unit id="2b085b3ecbb54c70910e25f3896da20b2a187a73" translate="yes" xml:space="preserve">
          <source>An exception can be thrown by a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;, &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;, &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, &lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation function&lt;/a&gt;, and any of the standard library functions that are specified to throw exceptions to signal certain error conditions (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string/substr&quot;&gt;std::string::substr&lt;/a&gt;&lt;/code&gt;, etc).</source>
          <target state="translated">예외는에 의해 발생 될 수 &lt;a href=&quot;throw&quot;&gt;스로인 식&lt;/a&gt; , &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast는&lt;/a&gt; , &lt;a href=&quot;typeid&quot;&gt;유형 ID&lt;/a&gt; , &lt;a href=&quot;new&quot;&gt;새로운 표현&lt;/a&gt; , &lt;a href=&quot;../memory/new/operator_new&quot;&gt;할당 함수&lt;/a&gt; 예 (및 지정된 표준 라이브러리 함수의 임의 특정 에러 조건을 신호하는 예외를 발생하도록 &lt;code&gt;&lt;a href=&quot;../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/basic_string/substr&quot;&gt;std::string::substr&lt;/a&gt;&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="734db5e27654b7a1a090879aa79155ed3b4b2a8b" translate="yes" xml:space="preserve">
          <source>An exception is thrown if &lt;code&gt;*this&lt;/code&gt; has no shared state or &lt;code&gt;get_future&lt;/code&gt; has already been called. To get multiple &quot;pop&quot; ends of the promise-future communication channel, use &lt;code&gt;&lt;a href=&quot;../future/share&quot;&gt;std::future::share&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 공유 상태가 없거나 &lt;code&gt;get_future&lt;/code&gt; 가 이미 호출 된 경우 예외가 발생합니다 . promise-future 통신 채널의 여러 &quot;팝&quot;끝을 얻으려면 &lt;code&gt;&lt;a href=&quot;../future/share&quot;&gt;std::future::share&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44db7b4c1aff9b2986166f1068a5b7109c799860" translate="yes" xml:space="preserve">
          <source>An exception is thrown if there is no shared state or the shared state already stores a value or exception.</source>
          <target state="translated">공유 상태가 없거나 공유 상태에 이미 값이나 예외가 저장되어 있으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="400934141b26ebdcfa01b232809e28da4e1614d3" translate="yes" xml:space="preserve">
          <source>An exception of this type is thrown when a &lt;a href=&quot;../language/dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt; to a reference type fails the run-time check (e.g. because the types are not related by inheritance), and also from &lt;code&gt;&lt;a href=&quot;../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&lt;/code&gt; if the requested facet does not exist in the locale.</source>
          <target state="translated">이 유형의 예외는 참조 유형에 대한 &lt;a href=&quot;../language/dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt; 가 런타임 검사에 실패한 경우 (예 : 유형이 상속과 관련이 없기 때문에) 요청 된 패싯이 로케일에없는 경우 &lt;code&gt;&lt;a href=&quot;../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&lt;/code&gt; 에서도 예외가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="3e10eeb3d50b8941ecde1bf2d5b08ad5eba672d1" translate="yes" xml:space="preserve">
          <source>An exception of this type is thrown when a &lt;a href=&quot;../language/typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt; operator is applied to a dereferenced null pointer value of a polymorphic type.</source>
          <target state="translated">이 유형의 예외는 &lt;a href=&quot;../language/typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt; 연산자가 다형성 유형의 역 참조 된 널 포인터 값에 적용될 때 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="392a7913172c4bf28f4342b2ce3e240403f2f75f" translate="yes" xml:space="preserve">
          <source>An explanatory message for the stored error code and error category.</source>
          <target state="translated">저장된 오류 코드 및 오류 범주에 대한 설명 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="d5eabc2515cac7175770538d9fd2aca675f84744" translate="yes" xml:space="preserve">
          <source>An explicit instantiation declaration (an extern template) prevents implicit instantiations: the code that would otherwise cause an implicit instantiation has to use the explicit instantiation definition provided somewhere else in the program.</source>
          <target state="translated">명시 적 인스턴스화 선언 (외부 템플릿)은 암시 적 인스턴스화를 방지합니다. 암시 적 인스턴스화를 발생시키는 코드는 프로그램의 다른 곳에 제공된 명시 적 인스턴스화 정의를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="33cd7a0177e9f7ec5c231dde735e35e1a0d3fb00" translate="yes" xml:space="preserve">
          <source>An explicit instantiation declaration (an extern template) skips implicit instantiation step: the code that would otherwise cause an implicit instantiation instead uses the explicit instantiation definition provided elsewhere (resulting in link errors if no such instantiation exists). This can be used to reduce compilation times by explicitly declaring a template instantiation in all but one of the source files using it, and explicitly defining it in the remaining file.</source>
          <target state="translated">명시 적 인스턴스화 선언 (외부 템플릿)은 암시 적 인스턴스화 단계를 건너 뜁니다. 그렇지 않으면 암시 적 인스턴스화를 발생시키는 코드가 다른 곳에 제공된 명시 적 인스턴스화 정의를 대신 사용합니다 (그러한 인스턴스화가 없으면 링크 오류가 발생 함). 이를 사용하여 소스 파일 중 하나를 제외한 모든 파일에서 템플릿 인스턴스화를 명시 적으로 선언하고 나머지 파일에서이를 명시 적으로 정의하여 컴파일 시간을 단축하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="133c2fb50577da662edeff998e62d6b70b901935" translate="yes" xml:space="preserve">
          <source>An explicit instantiation definition forces instantiation of the class, struct, or union they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the entire program.</source>
          <target state="translated">명시 적 인스턴스화 정의는 그들이 참조하는 클래스, 구조체 또는 공용체의 인스턴스화를 강제합니다. 템플릿 정의 다음에 프로그램에 나타날 수 있으며 주어진 인수 목록에 대해 전체 프로그램에서 한 번만 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3fb00f7b63425b442d1cc0c31f1edb4322117c1" translate="yes" xml:space="preserve">
          <source>An explicit instantiation definition forces instantiation of the function or member function they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the program.</source>
          <target state="translated">명시 적 인스턴스화 정의는 참조하는 함수 또는 멤버 함수의 인스턴스화를 강제합니다. 템플릿 정의 다음에 프로그램에 표시 될 수 있으며 주어진 인수 목록에 대해 프로그램에서 한 번만 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9c128e72c9b832e8384315ba572027dc359efd3" translate="yes" xml:space="preserve">
          <source>An explicit specialization cannot be a &lt;a href=&quot;friend&quot;&gt;friend declaration&lt;/a&gt;.</source>
          <target state="translated">명시적인 전문화는 &lt;a href=&quot;friend&quot;&gt;친구 선언이&lt;/a&gt; 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5a4ebeb793310cf18619b24eeafbc2e6fd5d0c1f" translate="yes" xml:space="preserve">
          <source>An explicit specialization of a function template is inline only if it is declared with the &lt;a href=&quot;inline&quot;&gt;inline specifier&lt;/a&gt; (or defined as deleted), it doesn't matter if the primary template is inline.</source>
          <target state="translated">함수 템플릿의 명시적인 특수화는 &lt;a href=&quot;inline&quot;&gt;인라인 지정자로&lt;/a&gt; 선언 된 (또는 삭제 된 것으로 정의 된) 경우에만 인라인이며 기본 템플릿이 인라인인지는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad7859780f7fda205f962953901c88030d43e65f" translate="yes" xml:space="preserve">
          <source>An explicit specialization of a static data member of a template is a definition if the declaration includes an initializer; otherwise, it is a declaration. These definitions must use braces for default initialization:</source>
          <target state="translated">선언에 이니셜 라이저가 포함 된 경우 템플릿의 정적 데이터 멤버를 명시 적으로 특수화하는 것은 정의입니다. 그렇지 않으면 선언입니다. 이 정의는 기본 초기화에 중괄호를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5646484a04d1f69f62bdf5309c5a9d249438cc5" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;e&lt;/code&gt; is</source>
          <target state="translated">식 &lt;code&gt;e&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="11f8c98f192821781cccabf62455469b73d17864" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">식 &lt;code&gt;e&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="34f74cee143d788f51fcc25acc797aea92c197b8" translate="yes" xml:space="preserve">
          <source>An expression followed by a semicolon is a statement.</source>
          <target state="translated">세미콜론 뒤에 오는 표현식은 명령문입니다.</target>
        </trans-unit>
        <trans-unit id="f703e5af31c537ec73c27f6089a222ac20a91c8b" translate="yes" xml:space="preserve">
          <source>An expression is</source>
          <target state="translated">표현은</target>
        </trans-unit>
        <trans-unit id="c5756e59953f27f7802c2879dfb5bf8b2ef537aa" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of</source>
          <target state="translated">식은 일련의</target>
        </trans-unit>
        <trans-unit id="8582e3c88de4617441467faab5ff600afdf1bfb6" translate="yes" xml:space="preserve">
          <source>An expression statement without an expression is called a</source>
          <target state="translated">표현식이없는 표현식 문을</target>
        </trans-unit>
        <trans-unit id="ba931ef941c10e68e24584826bf3e7b5e908486f" translate="yes" xml:space="preserve">
          <source>An expression that designates a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; (e.g. &lt;code&gt;a.m&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is an lvalue of type &lt;code&gt;struct A { int m: 3; }&lt;/code&gt;) is an lvalue expression: it may be used as the left-hand operand of the assignment operator, but its address cannot be taken and a non-const lvalue reference cannot be bound to it. A const lvalue reference can be initialized from a bit-field lvalue, but a temporary copy of the bit-field will be made: it won't bind to the bit field directly.</source>
          <target state="translated">지정하는 식 &lt;a href=&quot;bit_field&quot;&gt;비트 필드&lt;/a&gt; (예 : &lt;code&gt;a.m&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; 유형의 좌변 인 &lt;code&gt;struct A { int m: 3; }&lt;/code&gt; ) 좌변 식이다 :이 왼쪽으로 피연산자 할당 연산자로 사용할 수 있지만, 그 주소를 가져올 수 없으며 상수가 아닌 lvalue 참조를 바인딩 할 수 없습니다. const lvalue 참조는 비트 필드 lvalue에서 초기화 될 수 있지만 비트 필드의 임시 복사본이 만들어집니다. 비트 필드에 직접 바인딩되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="95fcc97496d0a23551b56ed465f2ec32a136ce51" translate="yes" xml:space="preserve">
          <source>An identifier can be used &lt;a href=&quot;declarations&quot;&gt;to name&lt;/a&gt; objects, references, functions, enumerators, types, class members, namespaces, templates, template specializations, parameter packs, goto labels, and other entities, with the following exceptions:</source>
          <target state="translated">식별자는 다음 예외를 제외하고 객체, 참조, 함수, 열거 자, 유형, 클래스 멤버, 네임 스페이스, 템플릿, 템플릿 전문화, 매개 변수 팩, 이동 레이블 및 기타 엔티티의 &lt;a href=&quot;declarations&quot;&gt;이름을 지정&lt;/a&gt; 하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6eb1c54d1e440abd120bdddffed4feee0d07b20" translate="yes" xml:space="preserve">
          <source>An identifier that names a variable, a function, specialization of a &lt;a href=&quot;constraints&quot;&gt;concept&lt;/a&gt;,(since C++20) or an enumerator can be used as an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt;. The result of an expression consisting of just the identifier is the entity named by the identifier. The &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the expression is</source>
          <target state="translated">변수, 함수, &lt;a href=&quot;constraints&quot;&gt;개념의&lt;/a&gt; 전문화 (C ++ 20부터) 또는 열거자를 명명하는 식별자를 &lt;a href=&quot;expressions&quot;&gt;표현식&lt;/a&gt; 으로 사용할 수 있습니다 . 식별자로만 구성된 표현식의 결과는 식별자로 명명 된 엔티티입니다. 표현식 의 &lt;a href=&quot;value_category&quot;&gt;값 범주&lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="2bea22f245aad6a1bbd96dbe721e6bfbb9cba55e" translate="yes" xml:space="preserve">
          <source>An immediate function is a constexpr function, and must satisfy the requirements applicable to &lt;a href=&quot;constexpr&quot;&gt;constexpr functions or constexpr constructors&lt;/a&gt;, as the case may be.</source>
          <target state="translated">즉각적인 함수는 constexpr 함수이며, &lt;a href=&quot;constexpr&quot;&gt;constexpr 함수 또는 constexpr 생성자에&lt;/a&gt; 적용 가능한 요구 사항을 충족시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="252a155693a85c4513362e41870c607628599139" translate="yes" xml:space="preserve">
          <source>An implementation cannot declare additional non-static data members that would occupy storage disjoint from the real and imaginary components, and must ensure that the class template specialization does not contain any padding. The implementation must also ensure that optimizations to array access account for the possibility that a pointer to &lt;code&gt;value_type&lt;/code&gt; may be aliasing a &lt;code&gt;std::complex&lt;/code&gt; specialization or array thereof.</source>
          <target state="translated">구현은 스토리지를 점유하는 추가 비 정적 데이터 멤버를 실제 및 가상 컴포넌트와 분리 할 수 ​​없으며 클래스 템플리트 특수화에 패딩이 포함되지 않아야합니다. 또한 구현시 &lt;code&gt;value_type&lt;/code&gt; 에 대한 포인터가 &lt;code&gt;std::complex&lt;/code&gt; 특수화 또는 해당 배열의 별칭 일 수 있다는 가능성을 배열 액세스에 대한 최적화가 설명해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b36215737bc9acc94a1181b9b9fc0edbe7c6e8eb" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; for a user-defined type.</source>
          <target state="translated">사용자 정의 유형에 대한 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 구현 .</target>
        </trans-unit>
        <trans-unit id="5f56c2af44fa6aea68d66ab4f981e253c1870786" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for a user-defined type.</source>
          <target state="translated">사용자 정의 유형에 대한 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 구현 .</target>
        </trans-unit>
        <trans-unit id="8e1b5b99aec49dc279b82a189df1e4e71765f759" translate="yes" xml:space="preserve">
          <source>An implementation of the spherical harmonic function is &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;available in boost.math&lt;/a&gt;, and it reduces to this function when called with the parameter phi set to zero.</source>
          <target state="translated">구형 고조파 함수의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;boost.math&lt;/a&gt; 에서 사용할 수 있으며 매개 변수 phi를 0으로 설정하여 호출하면이 함수로 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="05f3d51d05cc3d2c938b7773b2a75528f0f533a8" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="e8a80dd8b49b57fd0af28cb5b6f9eab92b003670" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="463a45be898237901d9e95795630e24b7725815f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="a328d339a02fcd8f09757618757e341adcf6caf4" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="05afb78eee87d60d6affed2bb5d378e94152fda4" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="14e04477fae2c219d4ca4910e671ec277e96650f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="23aab2406e44d22254e76892b9bb67f949035f8f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="6d6d6fb65c08ea8df15db6341e3a63d4c3b1cb08" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="a8f1f0a1677f6760e20f47ca31a1260d73446bbf" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="172a3359b3bc94067fe1ce4e3994c6fccab63962" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="c3f9ea786832c07ac6ee8f2a1cf1bab37d07067f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="023d43dc101a8f0e0055a1bbe7ca05f32647f8f2" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="1416c6c581d2a16bec76ecd9c479fdd72d0c8646" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="b7a97e935596f5c5ad772a94c524a08ecf79d480" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt; as &lt;code&gt;boost::math::legendre_p&lt;/code&gt;, except that the boost.math definition includes the Condon-Shortley phase term.</source>
          <target state="translated">이 기능의 구현은 또한 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;boost.math에서 사용할 수있는&lt;/a&gt; 등의 &lt;code&gt;boost::math::legendre_p&lt;/code&gt; boost.math 정의가 콘돈 - Shortley 위상 용어를 포함하는 것을 제외하고.</target>
        </trans-unit>
        <trans-unit id="1b94dc33e3c2677817a24c87c5ae3eefdf3888b7" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">이 기능의 구현은 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;boost.math&lt;/a&gt; 에서도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="6484905546dbda0376c3234e4af32b4774ac948c" translate="yes" xml:space="preserve">
          <source>An incompletely-defined object type can be completed:</source>
          <target state="translated">불완전하게 정의 된 객체 유형을 완성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="034496cba173d751719f86a31427ebfaf5a3c429" translate="yes" xml:space="preserve">
          <source>An inline namespace is a namespace that uses the optional keyword &lt;code&gt;inline&lt;/code&gt; in its</source>
          <target state="translated">인라인 네임 스페이스는 선택적 키워드를 사용하는 네임 스페이스 &lt;code&gt;inline&lt;/code&gt; 년</target>
        </trans-unit>
        <trans-unit id="14113ff7972f0e79ae2bcb3f11df635a03888186" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; holding a reference to the copy of &lt;code&gt;e&lt;/code&gt;, or to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">인스턴스 &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 복사본 참조 들고 &lt;code&gt;e&lt;/code&gt; 또는 인스턴스에 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 또는 인스턴스에 &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; (참조 &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ba236b1f1a8d82abf0083dac8c36782f2303388c" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; holding a reference to the exception object, or a copy of the exception object, or to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인스턴스 &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 예외 객체 또는 예외 객체의 복사본에 대한 참조를 유지하거나, 인스턴스에 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 또는 인스턴스에 대한 &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fbb0b241c865dd210a0103cf5d2af8c3a3e8a71" translate="yes" xml:space="preserve">
          <source>An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.</source>
          <target state="translated">이 호출 이후에 스트림의 방향이 넓은 경우는 0보다 큰 정수,이 호출의 뒤에 스트림이 바이트 방향 인 경우는 0 미만, 스트림에 방향이없는 경우는 0</target>
        </trans-unit>
        <trans-unit id="27a4b795995133a65c00f00e3a5c86747c696bf8" translate="yes" xml:space="preserve">
          <source>An integer literal is a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt; of the form.</source>
          <target state="translated">정수 리터럴은 양식 의 &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;기본 표현식&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="22296b3029f90df1ec990b3a781242c55d5beaa6" translate="yes" xml:space="preserve">
          <source>An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.</source>
          <target state="translated">신호에 의한 비동기 인터럽트가있는 경우에도 원자 엔티티로 액세스 할 수있는 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5018516b14deb056aa79dc2efd7d50ff7637de58" translate="yes" xml:space="preserve">
          <source>An invalid (in the current C locale) multibyte character was encountered.</source>
          <target state="translated">유효하지 않은 (현재 C 로케일에서) 멀티 바이트 문자가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="6a1cb2e740b1d006f9942d3f948b281b6ec84075" translate="yes" xml:space="preserve">
          <source>An invalid multibyte character (according to the current C locale) was encountered. &lt;code&gt;src&lt;/code&gt; is set to point at the beginning of the first unconverted multibyte character.</source>
          <target state="translated">현재 C 로케일에 따라 유효하지 않은 멀티 바이트 문자가 발견되었습니다. &lt;code&gt;src&lt;/code&gt; 는 변환되지 않은 첫 번째 멀티 바이트 문자의 시작 부분을 가리 키도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e0fbbc7a96cda105d7e43e6ea9e384c88eb8bd01" translate="yes" xml:space="preserve">
          <source>An invalid simple-template-id is a compile-time error, unless it names a function template specialization (in which case &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; may apply).</source>
          <target state="translated">유효하지 않은 simple-template-id는 함수 템플릿 전문화의 이름을 지정하지 않는 한 컴파일 타임 오류입니다 (이 경우 &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; 가 적용될 수 있음).</target>
        </trans-unit>
        <trans-unit id="738a0c3fdce4b2a8db1475951201c5a23036b195" translate="yes" xml:space="preserve">
          <source>An invariant of &lt;code&gt;zoned_time&lt;/code&gt; is that it always refers to a valid time zone and represents an existing and unambiguous time point in that time zone. Consistent with this invariant, &lt;code&gt;zoned_time&lt;/code&gt; has no move constructor or move assignment operator; attempts to move a &lt;code&gt;zoned_time&lt;/code&gt; will perform a copy.</source>
          <target state="translated">&lt;code&gt;zoned_time&lt;/code&gt; 의 변하지 않는 것은 항상 유효한 시간대를 나타내며 해당 시간대의 기존 및 명확한 시간대를 나타냅니다. 이 불변에 따라 &lt;code&gt;zoned_time&lt;/code&gt; 에는 이동 생성자 또는 이동 할당 연산자가 없습니다. &lt;code&gt;zoned_time&lt;/code&gt; 이동 시도 는 복사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ff8ec771a3e408dd089882b2303398b60f16d16a" translate="yes" xml:space="preserve">
          <source>An invocation of an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; is always evaluated, even in an unevaluated operand.</source>
          <target state="translated">&lt;a href=&quot;consteval&quot;&gt;즉시 함수&lt;/a&gt; 의 호출은 평가되지 않은 피연산자에서도 항상 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="30e4b56dc9d38cfe9d66956b6e4aed328bf1c204" translate="yes" xml:space="preserve">
          <source>An invocation of an immediate function whose innermost non-block scope is not a &lt;a href=&quot;scope#Function_parameter_scope&quot;&gt;function parameter scope&lt;/a&gt; of an immediate function must produce a constant expression; such an invocation (known as an</source>
          <target state="translated">가장 안쪽의 비 블록 범위가 즉시 함수의 &lt;a href=&quot;scope#Function_parameter_scope&quot;&gt;함수 매개 변수 범위&lt;/a&gt; 가 아닌 즉시 함수의 호출은 상수 표현식을 생성해야합니다. 이러한 호출 (</target>
        </trans-unit>
        <trans-unit id="4706ad1f00d621a48d2e07b2a350e165dc71b6e6" translate="yes" xml:space="preserve">
          <source>An iterator pointing at the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 와 동일한 객체를 가리키는 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="7ef94e98b9aecdcf5a48dda0b6d175cdca4869ff" translate="yes" xml:space="preserve">
          <source>An iterator pointing immediately after the last character produced.</source>
          <target state="translated">마지막 문자가 생성 된 직후를 가리키는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="a6f7df894c8448a1c11979a004ebd6ace3d75b98" translate="yes" xml:space="preserve">
          <source>An iterator pointing immediately after the last character recognized as a valid part of the monetary string input.</source>
          <target state="translated">마지막 문자 바로 다음을 가리키는 반복기는 통화 문자열 입력의 유효한 부분으로 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="2ae3748a0356e1b6e535e66f5c4ffa0cfaff3539" translate="yes" xml:space="preserve">
          <source>An iterator pointing to the element following the erased element, or &lt;code&gt;end()&lt;/code&gt; if no such element exists.</source>
          <target state="translated">지워진 요소 다음에 나오는 요소를 가리키는 반복자 또는 해당 요소가없는 경우 &lt;code&gt;end()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e831682f27c4215fd3d51adc3ab282760afa70fa" translate="yes" xml:space="preserve">
          <source>An iterator referring to the first &lt;code&gt;std::chrono::tzdb&lt;/code&gt; in the container.</source>
          <target state="translated">컨테이너 의 첫 번째 &lt;code&gt;std::chrono::tzdb&lt;/code&gt; 를 참조하는 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="7a63b694e4a7d314c8d05c5417ebc4bb1f31eb30" translate="yes" xml:space="preserve">
          <source>An iterator to the beginning of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 또는 &lt;code&gt;array&lt;/code&gt; 의 시작 부분에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="02479c246c44225a9035a0d45997e83cce8420db" translate="yes" xml:space="preserve">
          <source>An iterator to the end of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;. Note that the end of a container or array is defined as the element following the last valid element.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 또는 &lt;code&gt;array&lt;/code&gt; 끝의 반복자 입니다. 컨테이너 또는 배열의 끝은 마지막 유효한 요소 다음의 요소로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a11a64a7066be12c5192b1c7d9f47275f39b47d8" translate="yes" xml:space="preserve">
          <source>An iterator to the reverse-beginning of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 또는 &lt;code&gt;array&lt;/code&gt; 의 역 시작에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="e7197d58fc54a43b495f2accaea0f6922ad829bd" translate="yes" xml:space="preserve">
          <source>An iterator to the reverse-end of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 또는 &lt;code&gt;array&lt;/code&gt; 의 역방향에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="625c5f2464c30593f74840f1bd907c2068776afc" translate="yes" xml:space="preserve">
          <source>An iterator type whose category, value, difference, pointer and</source>
          <target state="translated">범주, 값, 차이, 포인터 및</target>
        </trans-unit>
        <trans-unit id="19a75628cf6442d77f6648e9556c5bb263d28280" translate="yes" xml:space="preserve">
          <source>An lvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize an lvalue reference&lt;/a&gt;; this associates a new name with the object identified by the expression.</source>
          <target state="translated">lvalue는 &lt;a href=&quot;reference_initialization&quot;&gt;lvalue 참조&lt;/a&gt; 를 초기화하는 데 사용될 수 있습니다 . 그러면 새 이름이 표현식으로 식별 된 오브젝트와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="ca62ca28732e81cc9d1b6aa1ed666a055a48eb41" translate="yes" xml:space="preserve">
          <source>An object can contain other objects, which are called</source>
          <target state="translated">객체는 다른 객체를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83df7119bca64cfa6a0dedb8658d0ab00a4eaf95" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;basic_istream::sentry&lt;/code&gt; is constructed in local scope at the beginning of each member function of &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; that performs input (both formatted and unformatted). Its constructor prepares the input stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, skips leading whitespace unless &lt;code&gt;noskipws&lt;/code&gt; flag is set, and performs other implementation-defined tasks if necessary. All cleanup, if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during input.</source>
          <target state="translated">&lt;code&gt;basic_istream::sentry&lt;/code&gt; 클래스의 객체는 입력을 수행하는 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 의 각 멤버 함수 시작시 로컬 범위로 구성됩니다 (형식화 및 형식화되지 않음). 생성자는 입력 스트림을 준비합니다. 스트림이 이미 실패한 상태인지 확인하고 tie ()의 출력 스트림을 플러시하고 &lt;code&gt;noskipws&lt;/code&gt; 플래그가 설정되어 있지 않으면 선행 공백을 건너 뛰고 필요한 경우 다른 구현 정의 작업을 수행합니다. 필요한 경우 모든 정리가 소멸자에서 수행되므로 입력 중에 예외가 발생하는 경우 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="823634b581a9cede4fd0ccc574bd7fa0bc24d634" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;basic_ostream::sentry&lt;/code&gt; is constructed in local scope at the beginning of each member function of &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; that performs output (both formatted and unformatted). Its constructor prepares the output stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, and performs other implementation-defined tasks if necessary. Implementation-defined cleanup, as well as flushing of the output stream if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during output.</source>
          <target state="translated">&lt;code&gt;basic_ostream::sentry&lt;/code&gt; 클래스의 오브젝트는 출력을 수행하는 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 의 각 멤버 함수 시작시 로컬 범위로 구성됩니다 (형식화 및 형식화되지 않음). 생성자는 출력 스트림을 준비합니다. 스트림이 이미 실패한 상태인지 확인하고 tie ()의 출력 스트림을 플러시하고 필요한 경우 다른 구현 정의 작업을 수행합니다. 필요한 경우 출력 스트림의 플러시뿐만 아니라 구현 정의 정리가 소멸자에서 수행되므로 출력 중에 예외가 발생하는 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0455f9161322806dadb1a5a0172793f044ae30ea" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;std::locale&lt;/code&gt; is an immutable indexed set of immutable facets. Each stream object of the C++ input/output library is associated with an &lt;code&gt;std::locale&lt;/code&gt; object and uses its facets for parsing and formatting of all data. In addition, a locale object is associated with each &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; object. Locale objects can also be used as predicates that perform string collation with the standard containers and algorithms and can be accessed directly to obtain or modify the facets they hold.</source>
          <target state="translated">&lt;code&gt;std::locale&lt;/code&gt; 클래스의 객체 는 변경 불가능한 인덱스 된 변경 불가능한 패싯 세트입니다. C ++ 입 / 출력 라이브러리의 각 스트림 오브젝트는 &lt;code&gt;std::locale&lt;/code&gt; 오브젝트와 연관되며 모든 데이터의 구문 분석 및 형식화에 해당 패싯을 사용합니다. 또한 로케일 오브젝트는 각 &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 오브젝트 와 연관됩니다 . 로케일 오브젝트는 표준 컨테이너 및 알고리즘으로 문자열 조합을 수행하는 술어로 사용될 수 있으며 보유한 패싯을 얻거나 수정하기 위해 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d66af98d41f06cecefd4af58c7d9c0ca924bcff6" translate="yes" xml:space="preserve">
          <source>An object of the type must be contextually convertible to bool. The effect of this conversion returns false if the value is equivalent to its null value and true otherwise.</source>
          <target state="translated">유형의 객체는 상황에 맞게 bool로 변환 할 수 있어야합니다. 이 변환의 효과는 값이 null 값과 같으면 false를, 그렇지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7bacce28d1059e82c9739033111e220b4d8671d7" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;&lt;a href=&quot;../../../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; &amp;lt;double&amp;gt; 유형의 객체</target>
        </trans-unit>
        <trans-unit id="f0e2760523dc7073d44af20a277e7f5a90698df4" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;&amp;lt;value_type&amp;gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; &amp;lt;value_type&amp;gt; 유형의 객체</target>
        </trans-unit>
        <trans-unit id="7bd18a30dbdab573b7c39639752708407fb37b52" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;To&lt;/code&gt; whose value representation is as described above.</source>
          <target state="translated">값 표현이 위에서 설명한 &lt;code&gt;To&lt;/code&gt; 유형의 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="e81f259c6d82e8e50d80fae74008b6a20cb6f607" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;X::value_compare&lt;/code&gt; constructed out of the comparison object is returned.</source>
          <target state="translated">비교 객체로 구성된 &lt;code&gt;X::value_compare&lt;/code&gt; 유형의 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7cce6a193570a048de83246c7b511f63641f001b" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; is a lightweight proxy object that provides access to an array of objects of type &lt;code&gt;const T&lt;/code&gt;.</source>
          <target state="translated">유형의 개체 &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; IS 유형의 오브젝트의 어레이에 대한 액세스를 제공하는 경량 프록시 객체 &lt;code&gt;const T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9033aa603f097747fd262291447f23ece9703946" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;std::once_flag&lt;/code&gt; that is passed to multiple calls to &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; allows those calls to coordinate with each other such that only one of the calls will actually run to completion.</source>
          <target state="translated">유형의 객체 &lt;code&gt;std::once_flag&lt;/code&gt; 에 여러 개의 호출에 전달 된 &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; 그 전화가 통화 중 하나만 실제로 완료 될 때까지 실행됩니다 서로 등으로 조정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bdae20fade93232b05ba74a9d73283a7dcdf8dd" translate="yes" xml:space="preserve">
          <source>An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt; when unpacking a &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, as a placeholder for the arguments that are not used.</source>
          <target state="translated">효과가없는 값을 지정할 수 있도록 지정되지 않은 유형의 객체입니다. &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 압축을 풀 때 사용되지 않는 인수의 자리 표시 자로 &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt; 와 함께 사용합니다.</target>
        </trans-unit>
        <trans-unit id="26b9967510dc89a341fa42ca83cfa44ef6ebf576" translate="yes" xml:space="preserve">
          <source>An object that is not a subobject of another object is called</source>
          <target state="translated">다른 객체의 하위 객체가 아닌 객체를</target>
        </trans-unit>
        <trans-unit id="858015fdff20dfb1bcca98de775349cd0072b086" translate="yes" xml:space="preserve">
          <source>An object, in C++, is a</source>
          <target state="translated">C ++에서 객체는</target>
        </trans-unit>
        <trans-unit id="2f63388a843dce76eb6b22f8810249f3b38a691e" translate="yes" xml:space="preserve">
          <source>An optional object &lt;code&gt;op&lt;/code&gt; may be turned into an empty optional with both &lt;code&gt;op = {};&lt;/code&gt; and &lt;code&gt;op = nullopt;&lt;/code&gt;. The first expression constructs an empty &lt;code&gt;optional&lt;/code&gt; object with &lt;code&gt;{}&lt;/code&gt; and assigns it to &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">선택적 객체 &lt;code&gt;op&lt;/code&gt; 는 &lt;code&gt;op = {};&lt;/code&gt; 그리고 &lt;code&gt;op = nullopt;&lt;/code&gt; . 첫 번째 표현식 은 &lt;code&gt;{}&lt;/code&gt; 를 사용 하여 빈 &lt;code&gt;optional&lt;/code&gt; 오브젝트를 구성하고 &lt;code&gt;op&lt;/code&gt; 에 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="eb6a5327aa18d2bb8b350958dde2d290354f8030" translate="yes" xml:space="preserve">
          <source>An out-of-class definition of a member function template must be</source>
          <target state="translated">멤버 함수 템플릿의 클래스 외부 정의는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="7a79aaf703db97b5a7b0d58031c37912c2d8149a" translate="yes" xml:space="preserve">
          <source>An output iterator that writes successive elements into an output stream, separating adjacent elements with a delimiter</source>
          <target state="translated">연속 요소를 출력 스트림에 기록하고 인접한 요소를 구분 기호로 분리하는 출력 반복기</target>
        </trans-unit>
        <trans-unit id="7c1bcb6f6b9e1950eeb340e7b5a97c8ee444cb42" translate="yes" xml:space="preserve">
          <source>An output iterator to element past the last element copied.</source>
          <target state="translated">마지막으로 복사 한 요소 이후의 요소에 대한 출력 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="dc7304d0df5442d14acbaafb1a4c43fd8d0d9ec3" translate="yes" xml:space="preserve">
          <source>An overload &lt;code&gt;F(T_i)&lt;/code&gt; is only considered if the declaration &lt;code&gt;T_i x[] = { &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t) };&lt;/code&gt; is valid for some invented variable &lt;code&gt;x&lt;/code&gt;;</source>
          <target state="translated">과부하 &lt;code&gt;F(T_i)&lt;/code&gt; 는 선언 &lt;code&gt;T_i x[] = { &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t) };&lt;/code&gt; 발명 된 일부 변수 &lt;code&gt;x&lt;/code&gt; 에 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="31a89ff54bf0a65e07ec5e6290a30f27bf9c83bf" translate="yes" xml:space="preserve">
          <source>An rvalue can't be used as the left-hand operand of the built-in assignment or compound assignment operators.</source>
          <target state="translated">내장 된 대입 또는 복합 대입 연산자의 왼쪽 피연산자로 rvalue를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="df8a77695e43a01d35ff3833e595deae1c70885b" translate="yes" xml:space="preserve">
          <source>An rvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize a const lvalue reference&lt;/a&gt;, in which case the lifetime of the object identified by the rvalue is &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extended&lt;/a&gt; until the scope of the reference ends.</source>
          <target state="translated">rvalue는 &lt;a href=&quot;reference_initialization&quot;&gt;const lvalue reference&lt;/a&gt; 를 초기화하는 데 사용될 수 있으며 ,이 경우 rvalue로 식별되는 객체의 수명은 참조의 범위가 끝날 때까지 &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;연장&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="0e072674017d2ac839c66e65b949d44d2466050e" translate="yes" xml:space="preserve">
          <source>An rvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize an rvalue reference&lt;/a&gt;, in which case the lifetime of the object identified by the rvalue is &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extended&lt;/a&gt; until the scope of the reference ends.</source>
          <target state="translated">rvalue를 사용 &lt;a href=&quot;reference_initialization&quot;&gt;하여 rvalue 참조&lt;/a&gt; 를 초기화 할 수 있습니다 .이 경우 rvalue로 식별 된 객체의 수명 이 참조 범위가 끝날 때까지 &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;연장&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="9223b2493a48ecf49ed1c32238f5defa3e17a1e2" translate="yes" xml:space="preserve">
          <source>An rvalue reference to a cv-unqualified template parameter is not a &lt;a href=&quot;template_argument_deduction&quot;&gt;forwarding reference&lt;/a&gt; if that parameter is a class template parameter:</source>
          <target state="translated">cv-unqualified 템플릿 매개 변수에 대한 rvalue 참조는 해당 매개 변수가 클래스 템플릿 매개 변수 인 경우 &lt;a href=&quot;template_argument_deduction&quot;&gt;전달 참조&lt;/a&gt; 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="06c47888799c4beade0a1c880e7969d048a047e7" translate="yes" xml:space="preserve">
          <source>An rvalue reference to the element at relative location, that is, &lt;code&gt;std::move(base()[n])&lt;/code&gt;.</source>
          <target state="translated">상대 위치의 요소에 대한 rvalue 참조, 즉 &lt;code&gt;std::move(base()[n])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4431ce6b5c54a2464689bcd2649d6be6a6d6edb5" translate="yes" xml:space="preserve">
          <source>Analyzes the character sequence &lt;code&gt;[first,last)&lt;/code&gt; for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">아래 설명 된 패턴에 대한 문자 순서 &lt;code&gt;[first,last)&lt;/code&gt; 를 분석합니다 . 패턴과 일치하는 문자가 없거나 일치하는 문자를 구문 분석하여 얻은 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;value&lt;/code&gt; 유형으로 표시 할 수없는 경우 value 를 수정할 수 없습니다. 그렇지 않으면 패턴과 일치하는 문자가 산술 값의 텍스트 표현으로 해석되어 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ffd735c77a58f5bee4802f3701c7f6fda3f232e" translate="yes" xml:space="preserve">
          <source>And after evaluation, the value of &lt;code&gt;*p&lt;/code&gt; is equivalent to the value formerly held by &lt;code&gt;rv&lt;/code&gt; (&lt;code&gt;rv&lt;/code&gt; remains valid, but is in an unspecified state.).</source>
          <target state="translated">그리고 평가 후 &lt;code&gt;*p&lt;/code&gt; 의 값은 이전에 &lt;code&gt;rv&lt;/code&gt; 가 보유한 값과 같습니다 ( &lt;code&gt;rv&lt;/code&gt; 는 유효하지만 지정되지 않은 상태입니다).</target>
        </trans-unit>
        <trans-unit id="a5b3b63e68ab039e5e9a76fb79b51bc5995bb988" translate="yes" xml:space="preserve">
          <source>And after evaluation, the value of &lt;code&gt;*p&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;. The value of &lt;code&gt;v&lt;/code&gt; is unchanged.</source>
          <target state="translated">그리고 평가 후 &lt;code&gt;*p&lt;/code&gt; 값은 &lt;code&gt;v&lt;/code&gt; 값과 같습니다 . &lt;code&gt;v&lt;/code&gt; 의 값 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56b1a77f4fe21b0570e2813c8d454db94a7cb374" translate="yes" xml:space="preserve">
          <source>And if any &lt;a href=&quot;reference_initialization&quot;&gt;reference binding&lt;/a&gt; takes place, it is direct binding (not one that constructs a temporary object)</source>
          <target state="translated">어떤 경우 &lt;a href=&quot;reference_initialization&quot;&gt;바인딩 참조&lt;/a&gt; 일어난다는 결합 다이렉트 (하지 임시 객체를 생성 한)</target>
        </trans-unit>
        <trans-unit id="c4c1b28f8418245c8009d38e2fd06aa2b822e70b" translate="yes" xml:space="preserve">
          <source>And, for every.</source>
          <target state="translated">그리고 모든 사람들에게.</target>
        </trans-unit>
        <trans-unit id="c8cb4cc17edf8c49a6c05da36754f248647a5429" translate="yes" xml:space="preserve">
          <source>And, given.</source>
          <target state="translated">그리고 주어진.</target>
        </trans-unit>
        <trans-unit id="78f82f2df8d5e45692f017f6cf128f97529f9a02" translate="yes" xml:space="preserve">
          <source>Anonymous unions</source>
          <target state="translated">익명의 노동 조합</target>
        </trans-unit>
        <trans-unit id="f39f69aff078c2dee33a0b3c3af4837d3936bb7c" translate="yes" xml:space="preserve">
          <source>Anonymous unions have further restrictions: they cannot have member functions, cannot have static data members, and all their data members must be public. The only declarations allowed are non-static data members  and &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; declarations(since C++14).</source>
          <target state="translated">익명 공용체에는 추가 제한이 있습니다. 멤버 함수를 사용할 수없고 정적 데이터 멤버를 가질 수 없으며 모든 데이터 멤버가 공개되어야합니다. 정적이 아닌 데이터 멤버와 &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; 선언 만 허용됩니다 (C ++ 14 이후).</target>
        </trans-unit>
        <trans-unit id="79c7bbc8f686393ed4d5a563735506c51a1b8513" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;std::weak_ptr&lt;/code&gt; is to break reference cycles formed by objects managed by &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. If such cycle is orphaned (i,e. there are no outside shared pointers into the cycle), the shared_ptr reference counts cannot reach zero and the memory is leaked. To prevent this, one of the pointers in the cycle can be made weak.</source>
          <target state="translated">&lt;code&gt;std::weak_ptr&lt;/code&gt; 또 다른 용도는 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 관리되는 객체에 의해 형성된 참조주기를 중단하는 것 입니다. 이러한 사이클이 분리되면 (즉, 사이클에 외부 공유 포인터가없는 경우) shared_ptr 참조 카운트가 0에 도달 할 수없고 메모리가 누출됩니다. 이를 방지하기 위해 사이클의 포인터 중 하나를 약하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="899d67ebfae429b08b8eebcf8e8c9e086747304a" translate="yes" xml:space="preserve">
          <source>Another way to test if a floating-point value is NaN is to compare it with itself: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</source>
          <target state="translated">부동 소수점 값이 NaN인지 테스트하는 또 다른 방법은 값을 자체와 비교하는 것입니다. &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f898bf7d5a8e88530be0282c53c70a4902e14d0" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;declarations&quot;&gt;simple declarations&lt;/a&gt; are allowed, except.</source>
          <target state="translated">를 제외한 모든 &lt;a href=&quot;declarations&quot;&gt;간단한 선언&lt;/a&gt; 이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b7e1bdbe6a7f8ce733280e2254188bf3b1de8cb1" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;function&quot;&gt;function declarations&lt;/a&gt; are allowed, with additional syntax elements that are only available for non-static member functions: &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; and &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; specifiers, &lt;a href=&quot;abstract_class&quot;&gt;pure-specifiers&lt;/a&gt;, cv-qualifiers, ref-qualifiers, and &lt;a href=&quot;constructor&quot;&gt;member initialization lists&lt;/a&gt;.</source>
          <target state="translated">비 정적 멤버 함수에만 사용할 수있는 추가 구문 요소 인 &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; 및 &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; 지정자, &lt;a href=&quot;abstract_class&quot;&gt;pure-specifiers&lt;/a&gt; , cv-qualifiers, ref-qualifiers 및 &lt;a href=&quot;constructor&quot;&gt;멤버 초기화 목록&lt;/a&gt; 과 같은 모든 &lt;a href=&quot;function&quot;&gt;함수 선언&lt;/a&gt; 이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b49f8c4e0a542030094cffe671da5baa163695a" translate="yes" xml:space="preserve">
          <source>Any additional integral types needed by the typedefs in the header &lt;a href=&quot;../header/cstdint&quot;&gt;&lt;code&gt;&amp;lt;cstdint&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">헤더의 형식 정의에 필요한 모든 추가 정수형 &lt;a href=&quot;../header/cstdint&quot;&gt; &lt;code&gt;&amp;lt;cstdint&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f08aea9a890f019823885a1075301ba39bc58d28" translate="yes" xml:space="preserve">
          <source>Any capture may appear only once:</source>
          <target state="translated">캡처는 한 번만 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6942cddecd7def2bc3a413a01b71ac46c41eb7d" translate="yes" xml:space="preserve">
          <source>Any character in the buffer which has been initialized, regardless of whether it originated from the string passed in the constructor or was appended by &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, is considered to be part of the input sequence.</source>
          <target state="translated">생성자에서 전달 된 문자열에서 시작했거나 &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 가 추가 된 문자열에 관계없이 초기화 된 버퍼의 모든 문자 는 입력 시퀀스의 일부로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6e77be05deb9b5ecac58519844a0e640e7f8ea02" translate="yes" xml:space="preserve">
          <source>Any character sequence, except that it must not contain the closing sequence &lt;code&gt;)&lt;/code&gt;delimiter&lt;code&gt;&quot;&lt;/code&gt;</source>
          <target state="translated">닫는 순서를 포함하지 않아야한다는 점을 제외하고 모든 문자 순서 &lt;code&gt;)&lt;/code&gt; 구분 기호 &lt;code&gt;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8037bc5cabc21aa1e4b299af2223a57b399d0e7" translate="yes" xml:space="preserve">
          <source>Any class type (whether declared with class-key&lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt;) may be declared as</source>
          <target state="translated">모든 클래스 유형 (class-key &lt;code&gt;class&lt;/code&gt; 또는 &lt;code&gt;struct&lt;/code&gt; 로 선언 되든 )은 다음과 같이 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8220613774bb0009e4140293deea0ebc75659a" translate="yes" xml:space="preserve">
          <source>Any declaration with an &lt;code&gt;extern&lt;/code&gt;&lt;a href=&quot;storage_duration&quot;&gt;storage class specifier&lt;/a&gt; or with a &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; specifier (such as &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;) without an initializer</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; &lt;a href=&quot;storage_duration&quot;&gt;스토리지 클래스 지정자&lt;/a&gt; 또는 초기화자가없는 &lt;a href=&quot;language_linkage&quot;&gt;언어 링크&lt;/a&gt; 지정자 (예 : &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; )가있는 선언</target>
        </trans-unit>
        <trans-unit id="7246de96efdd56306a5b292694e0b51ddecb8395" translate="yes" xml:space="preserve">
          <source>Any entity captured by a lambda (implicitly or explicitly) is odr-used by the lambda-expression (therefore, implicit capture by a nested lambda triggers implicit capture in the enclosing lambda).</source>
          <target state="translated">람다 (내재적으로 또는 명시 적으로)에 의해 캡처 된 모든 엔티티는 람다 표현에 의해 사용됩니다 (따라서 중첩 된 람다에 의한 내재적 캡처는 둘러싸는 람다에서 내재 된 캡처를 트리거합니다).</target>
        </trans-unit>
        <trans-unit id="2989809a7b8d0c13f3bc5dcda54fae5845e8e939" translate="yes" xml:space="preserve">
          <source>Any exception thrown by &lt;code&gt;Clock&lt;/code&gt; or &lt;code&gt;Duration&lt;/code&gt; (clocks and durations provided by the standard library never throw).</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; 또는 &lt;code&gt;Duration&lt;/code&gt; 에서 발생한 예외 (표준 라이브러리에서 제공 한 클록 및 지속 시간은 절대 발생하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="0155546b454eb352e396af9a9583e45239059529" translate="yes" xml:space="preserve">
          <source>Any exception thrown by clock, time point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).</source>
          <target state="translated">실행 중 시계, 시점 또는 지속 시간에 의해 발생 된 예외 (표준 라이브러리에서 제공 한 시계, 시점 및 지속 시간은 절대 발생하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="c2829040c4ec83947a1f6cbfdec13c1bbc1b434c" translate="yes" xml:space="preserve">
          <source>Any exception thrown by clock, time_point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).</source>
          <target state="translated">실행 중 클럭, time_point 또는 지속 시간 (표준 라이브러리에서 제공 한 클럭, 시점 및 지속 시간)에 의해 발생 된 예외.</target>
        </trans-unit>
        <trans-unit id="c01d2aae1c56f6c1e27461994e6f980f695234ee" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the selected constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, &lt;code&gt;*this&lt;/code&gt; does not contain a value after this call (the previously contained value, if any, had been destroyed).</source>
          <target state="translated">선택된 &lt;code&gt;T&lt;/code&gt; 생성자에 의해 예외가 발생합니다 . 예외가 발생하면 &lt;code&gt;*this&lt;/code&gt; 호출 후 값이 포함되지 않습니다 (이전에 포함 된 값이있는 경우).</target>
        </trans-unit>
        <trans-unit id="9f5d991a2059cb95872e45c2fc73f5d2c5d644d5" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the selected constructor of the return value &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">반환 값 &lt;code&gt;T&lt;/code&gt; 의 선택된 생성자에 의해 발생되는 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="8272c2eb0b4b3a47c1fd6266b118d8e0b7dc16c2" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the swap of the &lt;code&gt;Compare&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;Compare&lt;/code&gt; 객체 의 스왑으로 인해 예외가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="067dbafb29590e30db3698223b8289c3ba3a81cd" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the swap of the &lt;code&gt;Hash&lt;/code&gt; or &lt;code&gt;KeyEqual&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; 또는 &lt;code&gt;KeyEqual&lt;/code&gt; 객체 의 스왑으로 인해 예외가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="3ee3642fda89a9c4f4d022a23e66f5f0e3c59796" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt; 의해 발생 된 예외</target>
        </trans-unit>
        <trans-unit id="b6634d37c80775a0920996e88d7df6e338b295bf" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt; 의해 발생 된 예외</target>
        </trans-unit>
        <trans-unit id="a87dda0d2400f372bf7fe2820ca303981427bec3" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; (&lt;a href=&quot;../../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; types do not throw in &lt;code&gt;try_lock&lt;/code&gt;, but a custom &lt;a href=&quot;../../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; might)</source>
          <target state="translated">에 의해 throw되는 예외 &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; ( &lt;a href=&quot;../../named_req/mutex&quot;&gt;뮤텍스&lt;/a&gt; 유형에 포기하지 &lt;code&gt;try_lock&lt;/code&gt; 하지만, 사용자 정의 &lt;a href=&quot;../../named_req/lockable&quot;&gt;잠금&lt;/a&gt; 힘)</target>
        </trans-unit>
        <trans-unit id="655f412d1dcbf9a4b5e59996ea72d45e509cebc3" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt; 예외</target>
        </trans-unit>
        <trans-unit id="7e00b1d47fa13181989c95392d4568f3ce99f9b2" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt; 의해 발생 된 예외</target>
        </trans-unit>
        <trans-unit id="fbacb0aafa934213b8105430ca644b8c44fceb18" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt; 예외</target>
        </trans-unit>
        <trans-unit id="29577e958473f7848749dbde1c0fe41d4d28de86" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_time)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_time)&lt;/code&gt; 예외</target>
        </trans-unit>
        <trans-unit id="3c13a79f4c3e26012d9358714b624c43671f4909" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_until(timeout_time)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_until(timeout_time)&lt;/code&gt; 의해 발생 된 예외</target>
        </trans-unit>
        <trans-unit id="50c476323ba0569c33a9d73cfd698b2849a0d7de" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;unlock()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;unlock()&lt;/code&gt; 의해 발생 된 예외</target>
        </trans-unit>
        <trans-unit id="dde4d98fe163593f45905da9796164d4135b2aa5" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt; 의해 발생 된 예외</target>
        </trans-unit>
        <trans-unit id="46aca186f0d5118e57ea1ec2d858f1e279a474ac" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by the copy constructors of &lt;code&gt;BinaryPredicate&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryPredicate&lt;/code&gt; 또는 &lt;code&gt;ForwardIt&lt;/code&gt; 의 복사 생성자에 의해 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="4d35da87105417bd2f8dd9b5f22cbdf22b00eefe" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by.</source>
          <target state="translated">예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="ae8214fbedcd7b7b2c7806d56b17165dfe143da7" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown from iterator operations or the element swap.</source>
          <target state="translated">반복자 조작 또는 요소 스왑에서 발생한 예외.</target>
        </trans-unit>
        <trans-unit id="39254fcd3fdb015be0ee13d463da04333fcb57d3" translate="yes" xml:space="preserve">
          <source>Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator. Parentheses preserve value, type, and value category.</source>
          <target state="translated">괄호 안의 모든 표현은 기본 표현으로 분류됩니다. 이렇게하면 괄호가 어떤 연산자보다 우선 순위가 높습니다. 괄호는 값, 유형 및 값 범주를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="60455d87fc053fc9392b56ddecf2d39bad868244" translate="yes" xml:space="preserve">
          <source>Any instance of &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; at any given point in time either</source>
          <target state="translated">특정 시점 의 &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스</target>
        </trans-unit>
        <trans-unit id="d6460fec33d2d5219b69f7a6eebb68fbfc2a92cb" translate="yes" xml:space="preserve">
          <source>Any lvalue or rvalue of this type can be swapped with any lvalue or rvalue of some other type, using unqualified function call &lt;code&gt;swap()&lt;/code&gt; in the context where both &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; and the user-defined &lt;code&gt;swap()&lt;/code&gt;s are visible.</source>
          <target state="translated">이 유형의 lvalue 또는 rvalue는 &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 및 사용자 정의 &lt;code&gt;swap()&lt;/code&gt; 이 모두 표시 되는 컨텍스트에서 규정되지 않은 함수 호출 &lt;code&gt;swap()&lt;/code&gt; 을 사용하여 다른 유형의 lvalue 또는 rvalue와 교체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6091484d7bf355dd0cb949cd776657171718f832" translate="yes" xml:space="preserve">
          <source>Any member that could not be determined is set to &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt;</source>
          <target state="translated">확인할 수없는 멤버는 &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74a03ddfcb26a95ca3f318466c08e7e95a815c27" translate="yes" xml:space="preserve">
          <source>Any number of access specifiers may appear within a class, in any order. Member access specifiers may affect class layout: the addresses of non-static &lt;a href=&quot;data_members#Layout&quot;&gt;data members&lt;/a&gt; are only guaranteed to increase in order of declaration for the members with the same access. For &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;, all non-static data members must have the same access.</source>
          <target state="translated">클래스 내에 임의의 수의 액세스 지정자가 순서대로 나타날 수 있습니다. 멤버 액세스 지정자는 클래스 레이아웃에 영향을 줄 수 있습니다. 정적이 아닌 &lt;a href=&quot;data_members#Layout&quot;&gt;데이터 멤버&lt;/a&gt; 의 주소 는 동일한 액세스 권한을 가진 멤버의 선언 순서 대로만 증가합니다. 들어 &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; , 모든 비 정적 데이터 멤버는 동일한 액세스 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a64cd75ae326e1b045aa2b1398be8083184efecf" translate="yes" xml:space="preserve">
          <source>Any of the following can be fully specialized:</source>
          <target state="translated">다음 중 하나를 완전히 전문화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="437e7790370da61d174fe4d318acf7c074ede85b" translate="yes" xml:space="preserve">
          <source>Any of the following contexts requires class &lt;code&gt;T&lt;/code&gt; to be complete:</source>
          <target state="translated">다음 컨텍스트는 클래스 &lt;code&gt;T&lt;/code&gt; 가 완료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="104d110bb41e8701d9fe7c539eb86ce87b612d21" translate="yes" xml:space="preserve">
          <source>Any of the following names declared at namespace scope have external linkage unless the namespace is unnamed or is contained within an unnamed namespace(since C++11):</source>
          <target state="translated">네임 스페이스 범위에서 선언 된 다음 이름 중 하나는 네임 스페이스의 이름이 지정되지 않았거나 이름이 지정되지 않은 네임 스페이스 (C ++ 11부터)에 포함되지 않는 한 외부 연결을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="5407990c5239cdd7bd6ef99bf9f9a20fd8e6527f" translate="yes" xml:space="preserve">
          <source>Any of the following names first declared at block scope have external linkage:</source>
          <target state="translated">블록 범위에서 처음 선언 된 다음 이름은 외부 연결을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3238703010dee73fdace47f181589c27f2e4d0de" translate="yes" xml:space="preserve">
          <source>Any of the six two-way relational operators can be explicitly defaulted. A defaulted relational operator must have the return type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">6 가지 양방향 관계 연산자 중 하나를 명시 적으로 기본값으로 지정할 수 있습니다. 기본 관계 연산자에는 리턴 유형 &lt;code&gt;bool&lt;/code&gt; 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="904ac65505544c6e1c0c9dffcf96e6454f73cb6f" translate="yes" xml:space="preserve">
          <source>Any other combination of encoding prefixes may or may not be supported by the implementation. The result of such a concatenation is implementation-defined.</source>
          <target state="translated">인코딩 프리픽스의 다른 조합은 구현에 의해 지원되거나 지원되지 않을 수있다. 이러한 연결의 결과는 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0401aa15a157b543ba80abd41cb54281ed03d456" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#include&lt;/code&gt;and &lt;code&gt;__has_include&lt;/code&gt;(since C++17) as long as they expand to a sequence of characters surrounded by &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&quot;&lt;/code&gt;&lt;code&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">전처리 토큰 (매크로 상수 또는 표현식)은 &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&quot;&lt;/code&gt; &lt;code&gt;&quot;&lt;/code&gt; 로 둘러싸인 일련의 문자로 확장되는 한 &lt;code&gt;#include&lt;/code&gt; 및 &lt;code&gt;__has_include&lt;/code&gt; (C ++ 17부터 )에 대한 인수로 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="52919eaf1eb62c0854fdd694ccfd8a6c2a0705b3" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#line&lt;/code&gt; as long as they expand to a valid decimal integer optionally following a valid character string.</source>
          <target state="translated">전처리 토큰 (매크로 상수 또는 표현식)은 선택적으로 유효한 문자열 뒤에 오는 유효한 십진 정수로 확장되는 한 &lt;code&gt;#line&lt;/code&gt; 에 대한 인수로 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a80f56d370810d05ed5b7f500aef83276b2b56b" translate="yes" xml:space="preserve">
          <source>Any random number engine is also a &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;, and therefore may be plugged into any &lt;a href=&quot;../numeric/random&quot;&gt;random number distribution&lt;/a&gt; in order to obtain a random number (formally, a random variate).</source>
          <target state="translated">임의의 난수 엔진도 &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; 이므로 난수 (공식적으로 난수)를 얻기 위해 임의의 난수 &lt;a href=&quot;../numeric/random&quot;&gt;분포&lt;/a&gt; 에 연결될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25328abef95d7bd06cd8ccb115014d680f4af1fb" translate="yes" xml:space="preserve">
          <source>Any reads or writes to a bitset that happen via a &lt;code&gt;std::bitset::reference&lt;/code&gt; potentially read or write to the entire underlying bitset.</source>
          <target state="translated">&lt;code&gt;std::bitset::reference&lt;/code&gt; 를 통해 발생하는 비트 세트를 읽거나 쓰면 잠재적으로 전체 기본 비트 세트를 읽거나 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce62d6fd6228c7ed0a629a27ad487d906ba0cf6e" translate="yes" xml:space="preserve">
          <source>Any reads or writes to a vector that happen via a &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; potentially read or write to the entire underlying vector.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; 를 통해 발생하는 벡터를 읽거나 쓰면 잠재적으로 전체 기본 벡터를 읽거나 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79d69f3522c40f28b11ac3de0d09461ee1623eb9" translate="yes" xml:space="preserve">
          <source>Any return value from the function is ignored. If the function throws an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. In order to pass return values or exceptions back to the calling thread, &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">함수의 모든 반환 값은 무시됩니다. 함수에서 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. 리턴 값 또는 예외를 호출 스레드로 다시 전달하기 위해 &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65591f30b00907d381312a521d81c7b5924c3ee3" translate="yes" xml:space="preserve">
          <source>Any shared state is released. &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; after a call to this method.</source>
          <target state="translated">모든 공유 상태가 해제됩니다. 이 메소드를 호출 한 후 &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="594a9e7004e035507b2faafb30d5238be37f382a" translate="yes" xml:space="preserve">
          <source>Any statement can be</source>
          <target state="translated">모든 진술은</target>
        </trans-unit>
        <trans-unit id="569389483a39353b7174754570a587d2d30d7a93" translate="yes" xml:space="preserve">
          <source>Any thread can potentially access any object in the program (objects with automatic and thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; may still be accessed by another thread through a pointer or by reference).</source>
          <target state="translated">모든 스레드는 프로그램의 모든 개체에 잠재적으로 액세스 할 수 있습니다 (자동 및 스레드 로컬 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간을&lt;/a&gt; 가진 개체 는 포인터 또는 참조를 통해 다른 스레드에 의해 여전히 액세스 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="c56361a71bf85ab91f9c4ec67339965aa7d1d832" translate="yes" xml:space="preserve">
          <source>Any thread that intends to wait on &lt;code&gt;std::condition_variable&lt;/code&gt; has to.</source>
          <target state="translated">&lt;code&gt;std::condition_variable&lt;/code&gt; 에서 대기하려는 모든 스레드 는해야합니다.</target>
        </trans-unit>
        <trans-unit id="a27b17e4a874eb86d62efa02b876f52b84cb2492" translate="yes" xml:space="preserve">
          <source>Any two objects with overlapping &lt;a href=&quot;lifetime&quot;&gt;lifetimes&lt;/a&gt; (that are not &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;) are guaranteed to have different addresses unless one of them is a subobject of another or provides storage for another, or if they are subobjects of different type within the same complete object, and one of them is a subobject of zero size.</source>
          <target state="translated">&lt;a href=&quot;lifetime&quot;&gt;수명&lt;/a&gt; 이 겹치는 두 &lt;a href=&quot;bit_field&quot;&gt;비트&lt;/a&gt; 객체 ( 비트 필드 아님)는 다른 객체의 하위 객체이거나 다른 객체의 스토리지를 제공하지 않거나 동일한 전체 객체 내에서 다른 유형의 하위 객체 인 경우를 제외하고 서로 다른 주소를 갖습니다. 그들 중 제로 크기의 하위 객체입니다.</target>
        </trans-unit>
        <trans-unit id="747805bfa6e2b47c753f371046684998f5739c7b" translate="yes" xml:space="preserve">
          <source>Any use of a pointer that became invalid in this manner, even copying the pointer value into another variable, is undefined behavior.</source>
          <target state="translated">포인터 값을 다른 변수에 복사하더라도 이러한 방식으로 유효하지 않은 포인터를 사용하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="edb0075febb6c810a733225d843cfc260a841379" translate="yes" xml:space="preserve">
          <source>Any valid character except the double-quote &lt;code&gt;&quot;&lt;/code&gt;, backslash &lt;code&gt;\&lt;/code&gt;, or new-line character</source>
          <target state="translated">큰 따옴표 &lt;code&gt;&quot;&lt;/code&gt; , 백 슬래시 &lt;code&gt;\&lt;/code&gt; 또는 개행 문자를 제외한 모든 유효한 문자</target>
        </trans-unit>
        <trans-unit id="1b24babb1df893acf8a8a6efb01913ddf0bd9397" translate="yes" xml:space="preserve">
          <source>Appear in any type specifier, including decl-specifier-seq of &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt;, to specify constness or volatility of the object being declared or of the type being named.</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;선언 문법&lt;/a&gt; 의 decl-specifier-seq를 포함하여 선언 된 객체 또는 이름이 지정된 유형의 constness 또는 휘발성을 지정 하는 모든 유형 지정자에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="b3cea74b8699d0d5592fcdb76824dfd00b7a1900" translate="yes" xml:space="preserve">
          <source>Appears in a function declaration, enumeration declaration, or class declaration.</source>
          <target state="translated">함수 선언, 열거 선언 또는 클래스 선언에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1f41b36bd2867522723d540cbaf10ea09210fdf2" translate="yes" xml:space="preserve">
          <source>Append to a file</source>
          <target state="translated">파일에 추가</target>
        </trans-unit>
        <trans-unit id="185b3e5c1287dbe88e91911ebf09f0289a09ed1c" translate="yes" xml:space="preserve">
          <source>Append to file</source>
          <target state="translated">파일에 추가</target>
        </trans-unit>
        <trans-unit id="7727ad0dfc1361a3b9a9f16594166faee13a49d3" translate="yes" xml:space="preserve">
          <source>Appends a &lt;code&gt;T&lt;/code&gt; constructed with &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; &amp;lt;Args&amp;gt; (args)로 구성된 &lt;code&gt;T&lt;/code&gt; 를 추가합니다 ...</target>
        </trans-unit>
        <trans-unit id="ffa8f7a6232502ff61b9f355b8192a149bda0bdd" translate="yes" xml:space="preserve">
          <source>Appends a byte string pointed to by &lt;code&gt;src&lt;/code&gt; to a byte string pointed to by &lt;code&gt;dest&lt;/code&gt;. At most &lt;code&gt;count&lt;/code&gt; characters are copied. The resulting byte string is null-terminated.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 바이트 문자열을 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 바이트 문자열에 추가합니다 . 최대 &lt;code&gt;count&lt;/code&gt; 문자가 복사됩니다. 결과 바이트 문자열은 null로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c89f8ba239ec205d14a709567d6066df8a0d1451" translate="yes" xml:space="preserve">
          <source>Appends a copy of &lt;code&gt;rv&lt;/code&gt;, possibly using move semantics</source>
          <target state="translated">이동 의미론을 사용하여 &lt;code&gt;rv&lt;/code&gt; 사본을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="93a15a35c8298c01ed0b17fc08d04c4607bfeb7b" translate="yes" xml:space="preserve">
          <source>Appends a copy of &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 의 사본을 추가합니다</target>
        </trans-unit>
        <trans-unit id="0749406f25dc8bfe01326e6508ea40f8ccdfe8f5" translate="yes" xml:space="preserve">
          <source>Appends a copy of the character string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the character string pointed to by &lt;code&gt;dest&lt;/code&gt;. The character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting byte string is null-terminated.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 문자열의 사본을 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 문자열의 끝에 추가합니다 . &lt;code&gt;src[0]&lt;/code&gt; 문자 는 &lt;code&gt;dest&lt;/code&gt; 끝에서 널 종료 자를 대체합니다 . 결과 바이트 문자열은 null로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0f3b244f19389096a59b50d552c3a3947e4ec319" translate="yes" xml:space="preserve">
          <source>Appends a copy of the wide string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting wide string is null-terminated.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 넓은 문자열의 사본을 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 넓은 문자열의 끝에 추가합니다 . 넓은 문자 &lt;code&gt;src[0]&lt;/code&gt; 은 &lt;code&gt;dest&lt;/code&gt; 끝에서 널 종료 자를 대체합니다 . 넓은 문자열 결과는 null로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ee76f2e6383e182374a1ac158b3fb988871f2017" translate="yes" xml:space="preserve">
          <source>Appends a new element to the end of the container. The element is constructed through &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt;, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments &lt;code&gt;args...&lt;/code&gt; are forwarded to the constructor as &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">컨테이너 끝에 새 요소를 추가합니다. 요소는 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt; construct를 통해 구성 되며, 일반적으로 배치 새 항목을 사용하여 컨테이너가 제공하는 위치에 요소를 제 위치에 구성합니다. 인수 &lt;code&gt;args...&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 로 생성자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="3769354c56bdf441401d30ffbfd485d11afed226" translate="yes" xml:space="preserve">
          <source>Appends additional characters to the string.</source>
          <target state="translated">문자열에 추가 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9435c7778f8168db6ddee793e51647858e33337b" translate="yes" xml:space="preserve">
          <source>Appends at most &lt;code&gt;count&lt;/code&gt; wide characters from the wide string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the character string pointed to by &lt;code&gt;dest&lt;/code&gt;, stopping if the null terminator is copied. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is &lt;code&gt;count+1&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 넓은 문자열에서 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 문자열의 끝까지 최대 &lt;code&gt;count&lt;/code&gt; 넓은 문자를 추가 하고 널 종료자가 복사되면 중지합니다. 넓은 문자 &lt;code&gt;src[0]&lt;/code&gt; 은 &lt;code&gt;dest&lt;/code&gt; 끝에서 널 종료 자를 대체합니다 . 널 종료자는 항상 끝에 추가됩니다 (따라서 함수가 작성할 수있는 최대 와이드 문자 수는 &lt;code&gt;count+1&lt;/code&gt; 입니다 ).</target>
        </trans-unit>
        <trans-unit id="616d6d1b2db8c5cbc5b78e6729f280f6ef9cde21" translate="yes" xml:space="preserve">
          <source>Appends the character &lt;code&gt;c&lt;/code&gt; to the output character sequence.</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 를 출력 문자 순서에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="97e86c02631fb97ad63c305dc2c6744a765ce0c5" translate="yes" xml:space="preserve">
          <source>Appends the character &lt;code&gt;c&lt;/code&gt; to the put area of the buffer, reallocating if possible.</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 를 버퍼의 넣기 영역에 추가하고 가능한 경우 재 할당합니다.</target>
        </trans-unit>
        <trans-unit id="532328072ae734b050324e7bd55974ecc3a7470f" translate="yes" xml:space="preserve">
          <source>Appends the given character &lt;code&gt;ch&lt;/code&gt; to the end of the string.</source>
          <target state="translated">주어진 문자 &lt;code&gt;ch&lt;/code&gt; 를 문자열의 끝에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="cfc483d3db69eff6dcd82b004d3786722b9a1849" translate="yes" xml:space="preserve">
          <source>Appends the given element &lt;code&gt;value&lt;/code&gt; to the end of the container.</source>
          <target state="translated">지정된 요소 &lt;code&gt;value&lt;/code&gt; 을 컨테이너 끝에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="d2c0fb94e5cddaf445eca7c3640f9ada9fb6e2a7" translate="yes" xml:space="preserve">
          <source>Applied to</source>
          <target state="translated">에 적용</target>
        </trans-unit>
        <trans-unit id="cbd47fe22d148dd069a031976318ab7fb6d631c4" translate="yes" xml:space="preserve">
          <source>Applies compound assignment operators to each element in the numeric array.</source>
          <target state="translated">숫자 형 배열의 각 요소에 복합 할당 연산자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="bc6e0092dfd47ac0f36260b8d91a3704f6cc8726" translate="yes" xml:space="preserve">
          <source>Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type &lt;code&gt;T&lt;/code&gt;, removes cv-qualifiers, and defines the resulting type as the member typedef &lt;code&gt;type&lt;/code&gt;. Formally:</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 에 대한 lvalue-to-rvalue, array-to-pointer 및 function-to-pointer 암시 적 변환을 적용하고 cv 규정 자를 제거하고 결과 유형을 멤버 typedef &lt;code&gt;type&lt;/code&gt; 으로 정의 합니다 . 공식적으로 :</target>
        </trans-unit>
        <trans-unit id="71f4ff319120444a2809431ede654e171b067641" translate="yes" xml:space="preserve">
          <source>Applies the corresponding operation to the referred elements and the elements of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">해당 요소를 참조 된 요소 및 &lt;code&gt;other&lt;/code&gt; 요소에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="27d8e4e4d1d2e00786c12ccc2c42604642524bdd" translate="yes" xml:space="preserve">
          <source>Applies the unary operators to the year value.</source>
          <target state="translated">단항 연산자를 연도 값에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="a0cc3e98fe133b6a125be7a1095a1e4722d59951" translate="yes" xml:space="preserve">
          <source>Applies the visitor &lt;code&gt;vis&lt;/code&gt; to the variants &lt;code&gt;vars&lt;/code&gt;.</source>
          <target state="translated">방문자 &lt;code&gt;vis&lt;/code&gt; 를 변형 &lt;code&gt;vars&lt;/code&gt; 에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="767013b70c83389088a9d12acdf6717a821be569" translate="yes" xml:space="preserve">
          <source>Applies to the name being declared in a function declaration, which must be the first declaration of the function.</source>
          <target state="translated">함수 선언에서 선언되는 이름에 적용되며, 함수의 첫 번째 선언이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0463466b4fbb2abaeda54896e7f772d38769d910" translate="yes" xml:space="preserve">
          <source>Applies to the name being declared in the declaration of a non-static data member that's not a bit field.</source>
          <target state="translated">비트 필드가 아닌 비 정적 데이터 멤버의 선언에서 선언되는 이름에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c80f073f7430ca362ef718e10efb9033f924c369" translate="yes" xml:space="preserve">
          <source>Applies unary operators to each element in the numeric array.</source>
          <target state="translated">숫자 배열의 각 요소에 단항 연산자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="4b03880d31fcc803c8ff4f90e7d09f01a683bd9e" translate="yes" xml:space="preserve">
          <source>Apply binary operators to each element of two valarrays, or a valarray and a value.</source>
          <target state="translated">이진 연산자를 두 개의 valarray 또는 valarray와 값의 각 요소에 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="68fcd04d7e11c3d0bcd63b86035531ef6f69e2ba" translate="yes" xml:space="preserve">
          <source>Applying &lt;a href=&quot;cv&quot;&gt;cv-qualifiers&lt;/a&gt; to an array type (through typedef or template type manipulation) applies the qualifiers to the element type, but any array type whose elements are of cv-qualified type is considered to have the same cv-qualification.</source>
          <target state="translated">&lt;a href=&quot;cv&quot;&gt;cv 규정&lt;/a&gt; 자를 배열 유형에 적용하면 (typedef 또는 템플릿 유형 조작을 통해) 한정자를 요소 유형에 적용하지만 요소가 cv 규정 유형 인 배열 유형은 동일한 cv 규정을 갖는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4da3e84107ea6402ad05595526acce55c364845f" translate="yes" xml:space="preserve">
          <source>Approximate</source>
          <target state="translated">Approximate</target>
        </trans-unit>
        <trans-unit id="09d845a999b4fbc8adffb5aaf317f7912e88b018" translate="yes" xml:space="preserve">
          <source>Approximately (last-first)log(middle-first) applications of &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cmp&lt;/code&gt; 의 대략 (마지막 우선) log (가운데 첫 번째) 응용 프로그램 .</target>
        </trans-unit>
        <trans-unit id="784f9dcf68eaea0702498dee303485e97ffb2719" translate="yes" xml:space="preserve">
          <source>Approximately &lt;code&gt;N log N&lt;/code&gt; comparisons, where N is the number of elements in the list.</source>
          <target state="translated">대략 &lt;code&gt;N log N&lt;/code&gt; 비교. 여기서 N은 목록의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="263ef14d73529c347640508e4c1ee9f8d38a5463" translate="yes" xml:space="preserve">
          <source>Arbitrary variable name</source>
          <target state="translated">임의 변수 이름</target>
        </trans-unit>
        <trans-unit id="e35b07545cf742633f94fa34acab673ea47df2c2" translate="yes" xml:space="preserve">
          <source>Args&lt;code&gt;...&lt;/code&gt;args(optional)</source>
          <target state="translated">Args&lt;code&gt;...&lt;/code&gt;args(optional)</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="b8bc95515466bfd1d5820bfea495f62a49211b2b" translate="yes" xml:space="preserve">
          <source>Argument list too long</source>
          <target state="translated">인수 목록이 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="def2bf62b424e602e225d5df7086bbc94649ceb1" translate="yes" xml:space="preserve">
          <source>Argument type</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="2b55cecef5202fd86c073a0e44fac351439665bc" translate="yes" xml:space="preserve">
          <source>Argument-Dependent Lookup</source>
          <target state="translated">인수 의존적 조회</target>
        </trans-unit>
        <trans-unit id="81b2c9c824baa8fa05c1678ad66e87db4cff58c7" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup</source>
          <target state="translated">인수 의존적 조회</target>
        </trans-unit>
        <trans-unit id="ae0999c00edb7da81dc23e3610fb98d912a734a5" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup makes it possible to use operators defined in a different namespace. Example:</source>
          <target state="translated">인수 종속 조회를 통해 다른 네임 스페이스에 정의 된 연산자를 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="48fb1df93f3daa01db173d8e4c1d5be0610f1c51" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup, also known as ADL, or Koenig lookup, is the set of rules for looking up the unqualified function names in &lt;a href=&quot;operator_other&quot;&gt;function-call expressions&lt;/a&gt;, including implicit function calls to &lt;a href=&quot;operators&quot;&gt;overloaded operators&lt;/a&gt;. These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces considered by the usual &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt;.</source>
          <target state="translated">ADL 또는 Koenig 조회라고도하는 인수 종속 조회는 &lt;a href=&quot;operators&quot;&gt;오버로드 된 연산자에 대한&lt;/a&gt; 내재적 함수 호출을 포함하여 함수 호출 &lt;a href=&quot;operator_other&quot;&gt;표현식&lt;/a&gt; 에서 규정되지 않은 함수 이름을 조회하기위한 규칙 세트입니다 . 이러한 함수 이름은 일반적인 &lt;a href=&quot;lookup&quot;&gt;정규화되지 않은 이름 조회&lt;/a&gt; 에서 고려되는 범위와 네임 스페이스 외에 인수의 네임 스페이스에서 조회 됩니다.</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="6e926e8a15212af2e7d9e38d85b6ff5994219acc" translate="yes" xml:space="preserve">
          <source>Arithmetic comparison operators</source>
          <target state="translated">산술 비교 연산자</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">산술 연산</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="ebc8c7691d9a7980369acc634bd9267bcb2e5a9e" translate="yes" xml:space="preserve">
          <source>Arithmetic operators are overloaded for many standard library types.</source>
          <target state="translated">산술 연산자는 많은 표준 라이브러리 유형에 과부하가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="aa83af8c4fc56c37be9ed278bb37886d698b573b" translate="yes" xml:space="preserve">
          <source>Arithmetic type capable of representing the process running time of implementation-defined range and precision.</source>
          <target state="translated">구현 정의 범위 및 정밀도의 프로세스 실행 시간을 나타낼 수있는 산술 유형.</target>
        </trans-unit>
        <trans-unit id="8067dbf084d6b81e05c895b3fb91dd4530c4b57b" translate="yes" xml:space="preserve">
          <source>Arithmetic type capable of representing times.</source>
          <target state="translated">시간을 표현할 수있는 산술 유형.</target>
        </trans-unit>
        <trans-unit id="3a96c27ea8acc41f84ccf2e2e957611cc9d4cd07" translate="yes" xml:space="preserve">
          <source>Arithmetic types</source>
          <target state="translated">산술 유형</target>
        </trans-unit>
        <trans-unit id="d06d9a0dfd0ee03ff5118df0f82845bdc8d2b4bc" translate="yes" xml:space="preserve">
          <source>Arithmetic types are the built-in types for which the &lt;a href=&quot;../language/operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; (+, -, *, /) are defined (possibly in combination with the usual arithmetic conversions).</source>
          <target state="translated">산술 유형은 &lt;a href=&quot;../language/operator_arithmetic&quot;&gt;산술 연산자&lt;/a&gt; (+,-, *, /)가 정의 된 내장 유형입니다 (일반적인 산술 변환과 함께 사용 가능).</target>
        </trans-unit>
        <trans-unit id="7a080955122add0c1c12baf72d49c4257bf60020" translate="yes" xml:space="preserve">
          <source>Array &lt;a href=&quot;value_category&quot;&gt;xvalues&lt;/a&gt; may be formed directly by accessing an array member of a class rvalue or by using &lt;code&gt;std::move&lt;/code&gt; or another cast or function call that returns an rvalue reference.</source>
          <target state="translated">배열 &lt;a href=&quot;value_category&quot;&gt;x 값&lt;/a&gt; 은 rvalue 클래스의 배열 멤버에 액세스하거나 &lt;code&gt;std::move&lt;/code&gt; 또는 rvalue 참조를 반환하는 다른 캐스트 또는 함수 호출을 사용하여 직접 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee291b10c5dda44d0a9e99115603b2cd5af533b7" translate="yes" xml:space="preserve">
          <source>Array I/O implementations</source>
          <target state="translated">어레이 I / O 구현</target>
        </trans-unit>
        <trans-unit id="1fac704c74c4d1cd597a85741e932ee6a1399565" translate="yes" xml:space="preserve">
          <source>Array allocation may supply unspecified overhead, which may vary from one call to new to the next. The pointer returned by the new-expression will be offset by that value from the pointer returned by the allocation function. Many implementations use the array overhead to store the number of objects in the array which is used by the &lt;a href=&quot;delete&quot;&gt;&lt;code&gt;delete[]&lt;/code&gt;&lt;/a&gt; expression to call the correct number of destructors. In addition, if the new-expression is used to allocate an array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, or &lt;a href=&quot;../types/byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt;, it may request additional memory from the allocation function if necessary to guarantee correct alignment of objects of all types no larger than the requested array size, if one is later placed into the allocated array.</source>
          <target state="translated">배열 할당은 지정되지 않은 오버 헤드를 제공 할 수 있으며, 이는 호출마다 다를 수 있습니다. new-expression이 리턴 한 포인터는 할당 함수가 리턴 한 포인터에서 해당 값으로 오프셋됩니다. 많은 구현에서는 배열 오버 헤드를 사용하여 &lt;a href=&quot;delete&quot;&gt; &lt;code&gt;delete[]&lt;/code&gt; &lt;/a&gt; 식에서 올바른 수의 소멸자를 호출하는 데 사용되는 개체 수를 배열에 저장합니다 . 또한 new 표현식이 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;a href=&quot;../types/byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt; 배열을 할당하는 데 사용되는 경우, 모든 유형의 객체를 올바르게 정렬하기 위해 필요한 경우 할당 함수에서 추가 메모리를 요청할 수 있습니다. 나중에 할당 된 배열에 배치 된 경우 요청 된 배열 크기입니다.</target>
        </trans-unit>
        <trans-unit id="19dbfbf61f5e11cabe0b3e7c939480487b44e48e" translate="yes" xml:space="preserve">
          <source>Array and function types may be written in a template declaration, but they are automatically replaced by pointer to object and pointer to function as appropriate.</source>
          <target state="translated">배열 및 함수 유형은 템플릿 선언으로 작성 될 수 있지만 객체에 대한 포인터와 함수에 대한 포인터로 자동 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3fb125cc9e54d7ed417b90f1b586cad673b24cc3" translate="yes" xml:space="preserve">
          <source>Array declaration</source>
          <target state="translated">배열 선언</target>
        </trans-unit>
        <trans-unit id="fa11a0bed9bf8be4aa754cdcc96dcd83617299af" translate="yes" xml:space="preserve">
          <source>Array rvalues</source>
          <target state="translated">배열 r 값</target>
        </trans-unit>
        <trans-unit id="2e4177a778e8e0d4d36e9396b01d0e6f4341b30c" translate="yes" xml:space="preserve">
          <source>Array subscript operator</source>
          <target state="translated">배열 첨자 연산자</target>
        </trans-unit>
        <trans-unit id="66b8cc3bf902fd9199bad14788d8e22184391a03" translate="yes" xml:space="preserve">
          <source>Array to pointer conversion</source>
          <target state="translated">배열에서 포인터로의 변환</target>
        </trans-unit>
        <trans-unit id="c0025fd7b0d4a983ce2fa2e1c1b60d86f77fcd32" translate="yes" xml:space="preserve">
          <source>Array version, &lt;code&gt;unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt;</source>
          <target state="translated">배열 버전, &lt;code&gt;unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d338acd11db4278249951233a983d4b787dc89b" translate="yes" xml:space="preserve">
          <source>Array-oriented access</source>
          <target state="translated">배열 지향 액세스</target>
        </trans-unit>
        <trans-unit id="78c423e7d10bf3348df8d43bf148cb5827744e5a" translate="yes" xml:space="preserve">
          <source>Array-to-pointer and function-to-pointer conversions are never applied to the value calculated by a discarded-value expression. The lvalue-to-rvalue conversion is applied if and only if the expression is a &lt;a href=&quot;cv&quot;&gt;volatile-qualified&lt;/a&gt; glvalue and has one of the following forms (built-in meaning required, possibly parenthesized).</source>
          <target state="translated">배열-포인터 및 함수-포인터 변환은 폐기 된 값 표현식으로 계산 된 값에 적용되지 않습니다. lvalue에서 rvalue 로의 변환은 표현식이 &lt;a href=&quot;cv&quot;&gt;휘발성으로 한정된&lt;/a&gt; glvalue이고 다음 형식 중 하나 (내장 된 의미 필요, 괄호로 묶음) 중 하나 인 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8874168e3c1df960a01e93b0e01fe86fb6ae2dc" translate="yes" xml:space="preserve">
          <source>Array-to-pointer decay</source>
          <target state="translated">배열에서 포인터로의 붕괴</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="1376db7bd12df19420984d74ce62a991f95e82b5" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed from any &lt;a href=&quot;types&quot;&gt;fundamental type&lt;/a&gt; (except &lt;code&gt;void&lt;/code&gt;), &lt;a href=&quot;pointer&quot;&gt;pointers&lt;/a&gt;, &lt;a href=&quot;pointer&quot;&gt;pointers to members&lt;/a&gt;, &lt;a href=&quot;classes&quot;&gt;classes&lt;/a&gt;, &lt;a href=&quot;enum&quot;&gt;enumerations&lt;/a&gt;, or from other arrays (in which case the array is said to be multi-dimensional).</source>
          <target state="translated">배열은 모든 &lt;a href=&quot;types&quot;&gt;기본 유형&lt;/a&gt; ( &lt;code&gt;void&lt;/code&gt; 제외 ), &lt;a href=&quot;pointer&quot;&gt;포인터&lt;/a&gt; , &lt;a href=&quot;pointer&quot;&gt;멤버에 대한 포인터&lt;/a&gt; , &lt;a href=&quot;classes&quot;&gt;클래스&lt;/a&gt; , &lt;a href=&quot;enum&quot;&gt;열거&lt;/a&gt; 또는 다른 배열 (이 경우 배열은 다차원이라고 함)로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb1e79ec0101099cc8a59bf9fd30eb4aa15f99db" translate="yes" xml:space="preserve">
          <source>Arrays of character types (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;) can be initialized from an appropriate &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;, optionally enclosed in braces. Successive characters of the string literal (which includes the implicit terminating null character) initialize the elements of the array. If the size of the array is specified and it is larger than the number of characters in the string literal, the remaining characters are zero-initialized.</source>
          <target state="translated">문자 유형의 배열 ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; )은 선택적으로 중괄호로 묶인 적절한 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 에서 초기화 될 수 있습니다 . 문자열 리터럴의 연속 문자 (암시 적 종료 널 문자 포함)는 배열의 요소를 초기화합니다. 배열의 크기가 지정되고 문자열 리터럴의 문자 수보다 큰 경우 나머지 문자는 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="1dad2511cb3cf432d9a23097f1bff2b6f8637192" translate="yes" xml:space="preserve">
          <source>Arrays of unknown bound</source>
          <target state="translated">알려지지 않은 배열</target>
        </trans-unit>
        <trans-unit id="5cf5ca03aab0034cdf7ff385d06729a538f15f36" translate="yes" xml:space="preserve">
          <source>As a rule, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during &lt;a href=&quot;array/swap&quot;&gt;swap&lt;/a&gt;, the iterator will continue to point to the same array element, and will thus change its value.</source>
          <target state="translated">일반적으로 배열의 반복자는 배열 수명 동안 무효화되지 않습니다. 그러나 &lt;a href=&quot;array/swap&quot;&gt;swap&lt;/a&gt; 동안 반복자는 동일한 배열 요소를 계속 가리 키므로 값이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="614cc5be51bd0fccb31d1106fa599930fafe0ca5" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; is treated as a uses-allocator type even though &lt;code&gt;std::uses_allocator&lt;/code&gt; is false for pairs (unlike e.g. &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;): see pair-specific overloads of &lt;code&gt;std::polymoprhic_allocator::construct&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;std::scoped_allocator_adaptor::construct&lt;/a&gt;&lt;/code&gt;(until C++20)&lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt;(since C++20)</source>
          <target state="translated">특별한 경우 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;std::uses_allocator&lt;/code&gt; 가 쌍에 대해 false 인 경우에도 사용 할당 자 유형으로 처리됩니다 (예 : &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; ) : &lt;code&gt;std::polymoprhic_allocator::construct&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;std::scoped_allocator_adaptor::construct&lt;/a&gt;&lt;/code&gt; (C ++ 20까지) &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="363835804f732ae2a7518afa5d70079b8f827fb9" translate="yes" xml:space="preserve">
          <source>As a special case, objects can be created in arrays of &lt;code&gt;unsigned char&lt;/code&gt; or &lt;a href=&quot;../types/byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt; (in which case it is said that the array</source>
          <target state="translated">특별한 경우로, &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;a href=&quot;../types/byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt; 배열로 객체를 만들 수 있습니다 (이 경우 배열은</target>
        </trans-unit>
        <trans-unit id="f52724b9ca0301f1d8b93282821a00b036f2d526" translate="yes" xml:space="preserve">
          <source>As above, with &lt;code&gt;eq=key_equal()&lt;/code&gt;</source>
          <target state="translated">위와 같이 &lt;code&gt;eq=key_equal()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8531b085109b3b3d1377cabf79180d8d388c7ee8" translate="yes" xml:space="preserve">
          <source>As above, with &lt;code&gt;hf=hasher()&lt;/code&gt;</source>
          <target state="translated">위와 같이 &lt;code&gt;hf=hasher()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bda77b28e4ca321fc30d59f16b97fba79dbe7581" translate="yes" xml:space="preserve">
          <source>As above, with an unspecified number of buckets</source>
          <target state="translated">위와 같이 지정되지 않은 버킷 수</target>
        </trans-unit>
        <trans-unit id="cb4232ed7041310ecc9217dc4e9b0dad693d0afb" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void*)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="translated">&quot;구현에 의해 지원됨&quot;요구 사항의 예로 POSIX 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; 은 &lt;code&gt;sizeof(void*)&lt;/code&gt; 의 2와 배수의 거듭 제곱 인 모든 &lt;code&gt;alignment&lt;/code&gt; 을 허용 하며 POSIX 기반의 &lt;code&gt;aligned_alloc&lt;/code&gt; 구현은 이 요구 사항을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="6dabb20bee356347a72de2e02dded113dd51368a" translate="yes" xml:space="preserve">
          <source>As any other function, a destructor may terminate by throwing an &lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;(this usually requires it to be explicitly declared &lt;code&gt;noexcept(false)&lt;/code&gt;)(since C++11), however if this destructor happens to be called during &lt;a href=&quot;throw&quot;&gt;stack unwinding&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">다른 함수와 마찬가지로 소멸자는 &lt;a href=&quot;exceptions&quot;&gt;예외&lt;/a&gt; 를 throw하여 종료 할 수 있습니다 (일반적으로 C ++ 11부터 &lt;code&gt;noexcept(false)&lt;/code&gt; 으로 명시 적으로 선언 해야 함 ). 그러나이 소멸자가 &lt;a href=&quot;throw&quot;&gt;스택 해제&lt;/a&gt; 동안 호출 되면 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 대신 종료 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7a66bb24008dddd2f1f26becdeebf04e56826247" translate="yes" xml:space="preserve">
          <source>As defined above.</source>
          <target state="translated">위에서 정의한대로.</target>
        </trans-unit>
        <trans-unit id="a534c811c2d3571f2ae27f157ef19b52a844ad05" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;, when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;) to an object whose member will be accessed.</source>
          <target state="translated">&lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; 에서 설명한 것처럼 비 정적 멤버 함수에 대한 포인터 또는 비 정적 데이터 멤버에 대한 포인터를 호출 할 때 첫 번째 인수는 참조 또는 포인터 여야합니다 (가능한 경우 &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 와 같은 스마트 포인터 포함) . : unique_ptr )을 멤버에 액세스 할 오브젝트에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9ee2578ea146050c5227b8b046d49c6f68518e95" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../memory/new/operator_new&quot;&gt; allocation function&lt;/a&gt;, the C++ program may provide global and class-specific replacements for these functions. If the new-expression begins with the optional &lt;code&gt;::&lt;/code&gt; operator, as in &lt;code&gt;::new T&lt;/code&gt; or &lt;code&gt;::new T[n]&lt;/code&gt;, class-specific replacements will be ignored (the function is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; in global &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;). Otherwise, if &lt;code&gt;T&lt;/code&gt; is a class type, lookup begins in the class scope of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../memory/new/operator_new&quot;&gt;할당 함수에&lt;/a&gt; 설명 된대로 C ++ 프로그램은 이러한 함수에 대한 전역 및 클래스 별 대체를 제공 할 수 있습니다. &lt;code&gt;::new T&lt;/code&gt; 또는 &lt;code&gt;::new T[n]&lt;/code&gt; 에서처럼 new-expression이 선택적 &lt;code&gt;::&lt;/code&gt; 연산자로 시작 하면 클래스 별 대체는 무시됩니다 (함수는 전역 &lt;a href=&quot;scope&quot;&gt;범위&lt;/a&gt; 에서 &lt;a href=&quot;lookup&quot;&gt;조회&lt;/a&gt; 됨 ). 그렇지 않으면 &lt;code&gt;T&lt;/code&gt; 가 클래스 유형이면 클래스 범위 &lt;code&gt;T&lt;/code&gt; 에서 조회가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="03fe97a528d16f7fe7e71f5717247af8db4822bd" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;explicit_cast&quot;&gt;functional cast&lt;/a&gt;, the syntax &lt;code&gt;T()&lt;/code&gt;(1) is prohibited for arrays, while &lt;code&gt;T{}&lt;/code&gt;(5) is allowed.</source>
          <target state="translated">&lt;a href=&quot;explicit_cast&quot;&gt;Functional cast에&lt;/a&gt; 설명 된대로 구문 &lt;code&gt;T()&lt;/code&gt; (1)은 배열에 대해 금지되고 &lt;code&gt;T{}&lt;/code&gt; (5)는 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f2a24edd45dbf727b01f52b1b2fe43e48097af38" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;non-local initialization&lt;/a&gt;, static and thread-local variables that aren't constant-initialized(since C++14) are zero-initialized before any other initialization takes place. If the definition of a non-class non-local variable has no initializer, then default initialization does nothing, leaving the result of the earlier zero-initialization unmodified.</source>
          <target state="translated">&lt;a href=&quot;initialization#Non-local_variables&quot;&gt;로컬&lt;/a&gt; 이 아닌 초기화에 설명 된 것처럼 , C ++ 14 이후로 상수 초기화되지 않은 정적 및 스레드 로컬 변수는 다른 초기화가 발생하기 전에 0으로 초기화됩니다. 비 클래스 비 로컬 변수의 정의에 이니셜 라이저가없는 경우 기본 초기화는 아무 것도 수행하지 않고 이전의 0으로 초기화 한 결과는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08d19aea73540a5ba0404cba80c23af9e3c2ceba" translate="yes" xml:space="preserve">
          <source>As described in &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt;, when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;) to an object whose member will be accessed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; 설명 된대로 비 정적 멤버 함수에 대한 포인터 또는 비 정적 데이터 멤버에 대한 포인터를 호출 할 때 첫 번째 인수는 참조 또는 포인터 여야합니다 ( &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 과 같은 스마트 포인터 포함) 및 &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; )을 멤버에 액세스 할 오브젝트에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2b2d6cdbd1b2496e6a2f40aed0a78a511c900aab" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt;, the lookup of a dependent name used in a template is postponed until the template arguments are known, at which time.</source>
          <target state="translated">&lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt; 에서 논의한 것처럼 , 템플리트에서 사용되는 종속 이름의 조회는 템플리트 인수가 알려질 때까지 연기됩니다.</target>
        </trans-unit>
        <trans-unit id="58e3f3f862eff79aa619bdf804e54d8152b28137" translate="yes" xml:space="preserve">
          <source>As formulated in C++11, the behavior of &lt;code&gt;std::result_of&lt;/code&gt; is undefined when &lt;code&gt;INVOKE(std::declval&amp;lt;F&amp;gt;(), std::declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; is ill-formed (e.g. when F is not a callable type at all). C++14 changes that to a &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; (when F is not callable, &lt;code&gt;std::result_of&amp;lt;F(ArgTypes...)&amp;gt;&lt;/code&gt; simply doesn't have the &lt;code&gt;type&lt;/code&gt; member).</source>
          <target state="translated">C ++ 11에서 공식화 한 것처럼, &lt;code&gt;INVOKE(std::declval&amp;lt;F&amp;gt;(), std::declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; 가 잘못 형성 될 때 &lt;code&gt;std::result_of&lt;/code&gt; 의 동작 은 정의되지 않습니다 (예 : F는 호출 가능한 유형이 아닙니다). C ++ 14는 &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE로&lt;/a&gt; 변경합니다 (F를 호출 할 수없는 경우 &lt;code&gt;std::result_of&amp;lt;F(ArgTypes...)&amp;gt;&lt;/code&gt; 에는 &lt;code&gt;type&lt;/code&gt; 멤버 가 없습니다 ).</target>
        </trans-unit>
        <trans-unit id="937a4526e972e8900a66eaf74bf3283dd336852b" translate="yes" xml:space="preserve">
          <source>As free (namespace) function</source>
          <target state="translated">자유 (네임 스페이스) 기능으로</target>
        </trans-unit>
        <trans-unit id="ebe6ab533cbf3972cb8d127e93ba520450789106" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, if statement is a single statement (not a compound statement), the scope of variables declared in it is limited to the loop body as if it was a compound statement.</source>
          <target state="translated">&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; 루프 의 경우와 마찬가지로 명령문이 복합 명령문이 아닌 단일 명령문 인 경우 선언 된 변수의 범위는 마치 복합 명령문 인 것처럼 루프 본문으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c00d6a8291143d3954d0476db09f338bbdf6a6a6" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;code&gt;typename&lt;/code&gt;, the &lt;code&gt;template&lt;/code&gt; prefix is allowed even if the name is not dependent or the use does not appear in the scope of a template(since C++11).</source>
          <target state="translated">의 경우와 마찬가지로 &lt;code&gt;typename&lt;/code&gt; 의 &lt;code&gt;template&lt;/code&gt; 접두사 이름 의존하지 않는 경우에도 허용 또는 사용 (11 ++ C 때문에) 템플릿의 범위에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f30e97ae154b85ba90b59b0fc7f3cc9421ecbfce" translate="yes" xml:space="preserve">
          <source>As long as the computation doesn't overflow, (1-3) always return a valid &lt;code&gt;weekday&lt;/code&gt; even if &lt;code&gt;wd.ok()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">계산이 오버플로되지 않는 한 (1-3)은 &lt;code&gt;wd.ok()&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에도 항상 유효한 &lt;code&gt;weekday&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b2ffc3f13ddf954cdee7f939204ad75111f3eb7d" translate="yes" xml:space="preserve">
          <source>As long as the computation doesn't overflow, (1-3) always return a valid month even if &lt;code&gt;m.ok()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">계산이 오버플로되지 않는 한 (1-3)은 &lt;code&gt;m.ok()&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에도 항상 유효한 월을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="974f4de3b83d59e1f68e4272f20e899a5d37454c" translate="yes" xml:space="preserve">
          <source>As member function</source>
          <target state="translated">멤버 함수로</target>
        </trans-unit>
        <trans-unit id="713b3ed5226e8894aaa4433505d652a47c900087" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;declarations#Declarators&quot;&gt;Declarations&lt;/a&gt;, the declarator can be followed by a</source>
          <target state="translated">&lt;a href=&quot;declarations#Declarators&quot;&gt;선언&lt;/a&gt; 에서 언급했듯이 선언자 뒤에는</target>
        </trans-unit>
        <trans-unit id="49e91975e9ca17802a309ea7799083868c1165b1" translate="yes" xml:space="preserve">
          <source>As non-member function</source>
          <target state="translated">비 멤버 기능으로</target>
        </trans-unit>
        <trans-unit id="3b425af2c74038d3cea50dc46fcd13bffe0eccf8" translate="yes" xml:space="preserve">
          <source>As of C++17, the types of the</source>
          <target state="translated">C ++ 17부터는</target>
        </trans-unit>
        <trans-unit id="459c28d90aaec6c98bb359ff8946c3af0fb14c25" translate="yes" xml:space="preserve">
          <source>As of C++20, &lt;code&gt;std::rel_ops&lt;/code&gt; are deprecated in favor of &lt;a href=&quot;../../language/default_comparisons&quot;&gt;&lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C ++ 20부터 &lt;code&gt;std::rel_ops&lt;/code&gt; 는 &lt;a href=&quot;../../language/default_comparisons&quot;&gt; &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; &lt;/a&gt; 대신 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="393ac68dbef87cdc436bb91eca938eb72a14d0ab" translate="yes" xml:space="preserve">
          <source>As of the ISO C11 standard, the C language has the &lt;code&gt;_Alignas&lt;/code&gt; keyword and defines &lt;code&gt;alignas&lt;/code&gt; as a preprocessor macro expanding to the keyword in the header &lt;a href=&quot;http://en.cppreference.com/w/c/types.html&quot;&gt;&lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;&lt;/a&gt;, but in C++ this is a keyword, and the headers &lt;a href=&quot;../header#Meaningless_C_headers&quot;&gt;&lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../header/cstdalign&quot;&gt;&lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;&lt;/a&gt; do not define such macro. They do, however, define the macro constant &lt;code&gt;__alignas_is_defined&lt;/code&gt;.</source>
          <target state="translated">ISO C11 표준에서 C 언어에는 &lt;code&gt;_Alignas&lt;/code&gt; 키워드가 있으며 &lt;a href=&quot;http://en.cppreference.com/w/c/types.html&quot;&gt; &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 헤더에서 키워드로 확장되는 전 처리기 매크로로 &lt;code&gt;alignas&lt;/code&gt; 를 정의 하지만 C ++에서는 키워드이며 헤더는 &lt;a href=&quot;../header#Meaningless_C_headers&quot;&gt; &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../header/cstdalign&quot;&gt; &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt; &lt;/a&gt; 같은 매크로를 정의하지 않습니다. 그러나 매크로 상수 &lt;code&gt;__alignas_is_defined&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="1a3bf7d8519e9e7ad03735c819bddeb04ebd58f9" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, the elements of a deque are not stored contiguously: typical implementations use a sequence of individually allocated fixed-size arrays, with additional bookkeeping, which means indexed access to deque must perform two pointer dereferences, compared to vector's indexed access which performs only one.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 와 반대로 deque의 요소는 연속적으로 저장되지 않습니다. 일반적인 구현에서는 추가 예약 기능이있는 개별적으로 할당 된 고정 크기 배열 시퀀스를 사용합니다. 즉, deque에 대한 인덱스 액세스는 벡터에 비해 두 개의 포인터 역 참조를 수행해야합니다. 하나만 수행하는 인덱스 액세스.</target>
        </trans-unit>
        <trans-unit id="fda56045f92b7462f128e13910bd06f8f30c0434" translate="yes" xml:space="preserve">
          <source>As other &lt;a href=&quot;declarations&quot;&gt;block declarations&lt;/a&gt;, this declaration can appear inside a block (a function body or another compound statement), and, as all other declarations, this declaration can also appear outside a block.</source>
          <target state="translated">다른 &lt;a href=&quot;declarations&quot;&gt;블록 선언&lt;/a&gt; 과 마찬가지로이 선언은 블록 (함수 본문 또는 다른 복합 명령문) 내에 나타날 수 있으며 다른 모든 선언과 마찬가지로이 선언은 블록 외부에 나타날 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b28e6bf13601652216db82706de6c91cb78b5eb" translate="yes" xml:space="preserve">
          <source>As part of the C++ &lt;a href=&quot;memory_model#Forward_progress&quot;&gt;forward progress guarantee&lt;/a&gt;, the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt; if a loop that has no &lt;a href=&quot;as_if&quot;&gt;observable behavior&lt;/a&gt; (does not make calls to I/O functions, access volatile objects, or perform atomic or synchronization operations) does not terminate. Compilers are permitted to remove such loops.</source>
          <target state="translated">는 C ++의 일환으로 &lt;a href=&quot;memory_model#Forward_progress&quot;&gt;앞으로 진행 보증&lt;/a&gt; 의 동작은 &lt;a href=&quot;ub&quot;&gt;정의되지 않은&lt;/a&gt; 어떤이없는 루프 경우 &lt;a href=&quot;as_if&quot;&gt;관찰 행동&lt;/a&gt; (I / O 기능에 액세스 휘발성 객체에 전화를하지 않습니다, 또는 원자 또는 동기화 작업을 수행) 종료되지 않습니다. 컴파일러는 이러한 루프를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a58c582d2511f72c3f58935ef1fcd1a0625d23a3" translate="yes" xml:space="preserve">
          <source>As specifed in &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::put&lt;/a&gt;&lt;/code&gt;, the showbase flag in integer output acts like the # format specifier in &lt;code&gt;&lt;a href=&quot;../c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;, which means the numeric base prefix is</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::put&lt;/a&gt;&lt;/code&gt; 지정된 것처럼 정수 출력의 showbase 플래그는 &lt;code&gt;&lt;a href=&quot;../c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; 의 # 형식 지정자와 같은 역할을합니다. 이는 숫자 기본 접두어가</target>
        </trans-unit>
        <trans-unit id="758f5930578d19fd61834cd8aab203c32e2b6172" translate="yes" xml:space="preserve">
          <source>As specified in &lt;code&gt;&lt;a href=&quot;../../locale/time_get/get&quot;&gt;std::time_get::do_get&lt;/a&gt;&lt;/code&gt;, which this function calls, it's unspecified if this function zero out the fields in &lt;code&gt;*tmb&lt;/code&gt; that are not set directly by the conversion specifiers that appear in &lt;code&gt;fmt&lt;/code&gt;: portable programs should initialize every field of &lt;code&gt;*tmb&lt;/code&gt; to zero before calling &lt;code&gt;std::get_time&lt;/code&gt;.</source>
          <target state="translated">이 함수가 호출하는 &lt;code&gt;&lt;a href=&quot;../../locale/time_get/get&quot;&gt;std::time_get::do_get&lt;/a&gt;&lt;/code&gt; 지정된 대로이 함수가 &lt;code&gt;fmt&lt;/code&gt; 에 나타나는 변환 지정자에 의해 직접 설정되지 않은 &lt;code&gt;*tmb&lt;/code&gt; 의 필드를 제로화하면 지정되지 않습니다 . 이식 가능한 프로그램은 &lt;code&gt;*tmb&lt;/code&gt; 모든 필드를 초기화해야합니다. &lt;code&gt;std::get_time&lt;/code&gt; 호출하기 전에 tmb 를 0으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="12353475b6995e09c45d7991314f3740302cb8b2" translate="yes" xml:space="preserve">
          <source>As specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; may be (but isn't required to be on non-IEEE floating-point platforms) raised by &lt;code&gt;std::rint&lt;/code&gt; when rounding a non-integer finite value.</source>
          <target state="translated">에 지정된대로 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 이 될 수있다 (그러나 비 IEEE 부동 소수점 플랫폼에있을 필요는 없습니다)에 의해 제기 &lt;code&gt;std::rint&lt;/code&gt; 정수가 아닌 유한 한 값을 반올림 때.</target>
        </trans-unit>
        <trans-unit id="7725511f2ba730c6af150bdf08e783c9982b3239" translate="yes" xml:space="preserve">
          <source>As the control flow moves up the call stack, destructors are invoked for all objects with &lt;a href=&quot;storage_duration&quot;&gt;automatic storage duration&lt;/a&gt; constructed, but not yet destroyed, since the corresponding try-block was entered, in reverse order of completion of their constructors.  If an exception is thrown from a destructor of a local variable or of a temporary used in a &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; statement, the destructor for the object returned from the function is also invoked.(since C++14).</source>
          <target state="translated">제어 흐름이 호출 스택 위로 이동함에 따라 생성자 완료 순서와 반대로 해당 try-block이 입력 &lt;a href=&quot;storage_duration&quot;&gt;되었으므로 자동 저장 시간이&lt;/a&gt; 구성된 모든 객체에 대해 소멸자가 호출됩니다 . 로컬 변수의 소멸자 또는 &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; 문에 사용 된 임시 소멸자에서 예외가 발생 하면 함수에서 리턴 된 오브젝트의 소멸자도 호출됩니다 (C ++ 14부터).</target>
        </trans-unit>
        <trans-unit id="59a6248c1a38202e83ccc7b37adc45f17d3ca8bb" translate="yes" xml:space="preserve">
          <source>As the object of the interface type controls the lifetime of the object of the implementation type, the pointer to implementation is usually &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인터페이스 유형의 객체가 구현 유형의 객체 수명을 제어하므로 구현에 대한 포인터는 일반적으로 &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="95b6d730748d0282aeb230ca4bb19bcc16aee1d0" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../promise/~promise&quot;&gt;std::promise::~promise&lt;/a&gt;&lt;/code&gt;, if the shared state is abandoned before it was made ready, an &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; exception is stored with the error code &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::broken_promise&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;&lt;a href=&quot;../promise/~promise&quot;&gt;std::promise::~promise&lt;/a&gt;&lt;/code&gt; 가 준비되었다 전에 공유 상태가 중단되는 경우, &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; 예외가 오류 코드와 함께 저장되어 &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::broken_promise&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="db81005fb30215522b4ae6ed80e37c5851341286" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;readsome&quot;&gt;readsome()&lt;/a&gt;&lt;/code&gt;, it is implementation-defined whether this function does anything with library-supplied streams. The intent is typically for the next read operation to pick up any changes that may have been made to the associated input sequence after the stream buffer last filled its get area. To achieve that, &lt;code&gt;sync()&lt;/code&gt; may empty the get area, or it may refill it, or it may do nothing. A notable exception is Visual Studio, where this operation discards the unprocessed input when called with a standard input stream.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;readsome&quot;&gt;readsome()&lt;/a&gt;&lt;/code&gt; 과 마찬가지로이 함수가 라이브러리 제공 스트림을 사용하여 수행하는지 여부는 구현 정의입니다. 의도는 다음 번 읽기 작업이 스트림 버퍼가 마지막으로 get 영역을 채운 후 관련 입력 시퀀스에 대한 변경 사항을 모두 가져 오는 것입니다. 이를 달성하기 위해 &lt;code&gt;sync()&lt;/code&gt; 가 get 영역을 비우거나 다시 채우거나 아무 것도 수행하지 않을 수 있습니다. 주목할만한 예외는 Visual Studio이며,이 작업은 표준 입력 스트림으로 호출 될 때 처리되지 않은 입력을 버립니다.</target>
        </trans-unit>
        <trans-unit id="e02b3da6a9ef315d015858b0685c757647c3727e" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;, this function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex was not locked by any other thread at some point before &lt;code&gt;timeout_time&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; 과 마찬가지로이 함수는 &lt;code&gt;timeout_time&lt;/code&gt; 이전의 어느 시점에서 뮤텍스가 다른 스레드에 의해 잠겨 있지 않은 경우에도 가짜로 실패하고 &lt;code&gt;false&lt;/code&gt; 를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2344babfb98b4f53fd07a875b3c619171ca14ba3" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;, this function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex was not locked by any other thread at some point during &lt;code&gt;timeout_duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; 과 마찬가지로이 함수는 &lt;code&gt;timeout_duration&lt;/code&gt; 동안 어떤 시점에서 뮤텍스가 다른 스레드에 의해 잠겨 있지 않은 경우에도 가짜로 실패하고 &lt;code&gt;false&lt;/code&gt; 를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cc991e561b91afca581c36d0451f165db913528" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;, this function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex was not locked by any other thread at some point before &lt;code&gt;timeout_time&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; 와 마찬가지로이 함수는 뮤텍스가 &lt;code&gt;timeout_time&lt;/code&gt; 이전의 어느 시점에서 다른 스레드에 의해 잠겨 있지 않은 경우에도 가짜로 실패하고 &lt;code&gt;false&lt;/code&gt; 를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ca3ed64cc51c1cb0dc92ea591b8dc31fb89228" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;, this function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex was not locked by any other thread at some point during &lt;code&gt;timeout_duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; 와 마찬가지로이 함수는 &lt;code&gt;timeout_duration&lt;/code&gt; 동안 어느 시점에서 뮤텍스가 다른 스레드에 의해 잠기지 않은 경우에도 가짜로 실패하고 &lt;code&gt;false&lt;/code&gt; 를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6c725944b1fe65a2ebfcadda7a99c820c0b5684" translate="yes" xml:space="preserve">
          <source>As with all cast expressions, the result is:</source>
          <target state="translated">모든 캐스트 표현식과 마찬가지로 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4531a0fac3bef177007b25ab065170cd62b185b" translate="yes" xml:space="preserve">
          <source>As with all floating-point expressions, the expression &lt;code&gt;(x*y) + z&lt;/code&gt; may be compiled as a fused multiply-add unless the &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma&lt;/a&gt;&lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; is off.</source>
          <target state="translated">모든 부동 소수점 식과 마찬가지로 &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma &lt;/a&gt; &lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; 가 해제되어 있지 않으면 식 &lt;code&gt;(x*y) + z&lt;/code&gt; 가 융합 곱셈으로 컴파일 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3219f037624b3a59d32f19972411fe565f772da" translate="yes" xml:space="preserve">
          <source>As with any &lt;a href=&quot;../fenv&quot;&gt;floating-point environment&lt;/a&gt; functionality, rounding is only guaranteed if &lt;code&gt;#pragma STDC FENV_ACCESS ON&lt;/code&gt; is set.</source>
          <target state="translated">모든 &lt;a href=&quot;../fenv&quot;&gt;부동 소수점 환경&lt;/a&gt; 기능 과 마찬가지로 반올림은 &lt;code&gt;#pragma STDC FENV_ACCESS ON&lt;/code&gt; 이 설정된 경우에만 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="c944fdb24684333ebc3c89bf06ee5cb49e730938" translate="yes" xml:space="preserve">
          <source>As with any &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;, evaluation of that expression is not allowed to call non-const functions through the dereferenced iterators.</source>
          <target state="translated">&lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; 와 마찬가지로 해당 표현식의 평가는 역 참조 된 반복자를 통해 비 const 함수를 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c8150aa08651170bc9a40a763dd7808b45e5c3c" translate="yes" xml:space="preserve">
          <source>As with any declaration, attributes that appear before the declaration and the attributes that appear immediately after the identifier within the declarator both apply to the entity being declared or defined (in this case, to the function).</source>
          <target state="translated">다른 선언과 마찬가지로 선언 앞에 나타나는 특성과 선언자 내 식별자 바로 뒤에 나타나는 특성은 선언되거나 정의 된 엔터티 (이 경우 함수)에 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="56571e50d5f66c5a4fcd35d377801f5d88c364d4" translate="yes" xml:space="preserve">
          <source>As with any declaration, the type of the function &lt;code&gt;func&lt;/code&gt; declared as &lt;code&gt;ret func(params)&lt;/code&gt; is &lt;code&gt;ret(params)&lt;/code&gt; (except for parameter type rewriting described below): see &lt;a href=&quot;type-id#Type_naming&quot;&gt;type naming&lt;/a&gt;.</source>
          <target state="translated">선언과 마찬가지로, &lt;code&gt;ret func(params)&lt;/code&gt; 로 선언 된 &lt;code&gt;func&lt;/code&gt; 함수의 유형 은 &lt;code&gt;ret(params)&lt;/code&gt; (아래 설명 된 매개 변수 유형 다시 쓰기 제외) : &lt;a href=&quot;type-id#Type_naming&quot;&gt;type naming을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="696ebcfb49b007939dac3def74f8d0bf869c372d" translate="yes" xml:space="preserve">
          <source>As with any floating-point computations, accuracy loss may raise &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 계산과 마찬가지로 정확도 손실로 인해 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 가 증가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e78a90c2d8247309ba7cb75c5ea72e82d43d4fa8" translate="yes" xml:space="preserve">
          <source>As with any implicitly-declared special member function, the exception specification of the implicitly-declared destructor is non-throwing unless the destructor of any potentially-constructed base or member is &lt;a href=&quot;noexcept_spec&quot;&gt;potentially-throwing&lt;/a&gt;(since C++17)implicit definition would directly invoke a function with a different exception specification(until C++17). In practice, implicit destructors are &lt;code&gt;noexcept&lt;/code&gt; unless the class is &quot;poisoned&quot; by a base or member whose destructor is &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="translated">어떠한 암시 선언 특별한 멤버 함수와 같이, 암시 적 선언 소멸자 제외 사양은 잠재적으로 구성된 염기 또는 부재 소멸자가 아닌 비 던지고 &lt;a href=&quot;noexcept_spec&quot;&gt;잠재적 던지기&lt;/a&gt; (17 ++ C 보낸) 암시 적 정의를 호출 직접 것을 다른 예외 사양을 가진 함수 (C ++ 17까지). 실제로, 소멸자가 &lt;code&gt;noexcept(false)&lt;/code&gt; 인 기본 또는 멤버가 클래스를 &quot;중독&quot;하지 않는 한 암시 적 소멸자는 &lt;code&gt;noexcept&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="50e87fdf512eb04cfd3749351769cc640478c4f4" translate="yes" xml:space="preserve">
          <source>As with any other uninitialized storage, the objects are created using &lt;a href=&quot;../language/new&quot;&gt;placement new&lt;/a&gt; and destroyed with explicit destructor calls.</source>
          <target state="translated">초기화되지 않은 다른 저장소와 마찬가지로 개체는 &lt;a href=&quot;../language/new&quot;&gt;새로운 배치를&lt;/a&gt; 사용하여 만들어지고 명시 적 소멸자 호출로 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="17eb59c250e2c883a971b71b88fc81b6282b7ab5" translate="yes" xml:space="preserve">
          <source>As with copy assignment, it is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined move assignment operator:</source>
          <target state="translated">복사 할당과 마찬가지로 상속 격자에서 둘 이상의 경로를 통해 액세스 할 수있는 가상 기본 클래스 하위 객체에 암시 적으로 정의 된 이동 할당 연산자가 두 번 이상 할당되는지 여부는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="845dc726234df1066d102eb3d7d5edcb75d4ae23" translate="yes" xml:space="preserve">
          <source>As with most user-defined overloads, return types should match return types provided by the built-in operators so that &lt;a href=&quot;operators&quot;&gt;the user-defined operators&lt;/a&gt; can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;). One exception is &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, which must return a pointer or another class with overloaded &lt;code&gt;operator-&amp;gt;&lt;/code&gt; to be realistically usable.</source>
          <target state="translated">대부분의 사용자 정의 오버로드와 마찬가지로 반환 유형은 기본 제공 &lt;a href=&quot;operators&quot;&gt;연산자&lt;/a&gt; 와 동일한 방식으로 사용자 정의 연산자를 사용할 수 있도록 내장 연산자에서 제공 한 반환 유형과 일치해야합니다 . 그러나 사용자 정의 연산자 과부하에서는 모든 유형을 리턴 유형 ( &lt;code&gt;void&lt;/code&gt; 포함 ) 으로 사용할 수 있습니다 . 한 가지 예외는 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 이며, 실제로 사용할 수 있도록 오버로드 된 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 가 있는 포인터 또는 다른 클래스를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a00bb778184f2e410cf6c8021b7589c57c820f61" translate="yes" xml:space="preserve">
          <source>As with other &lt;a href=&quot;static&quot;&gt;static members&lt;/a&gt;, a definition of a static data member template may be required. Such definition is provided outside the class definition. A template declaration of a static data member at namespace scope may also be a definition of a non-template &lt;a href=&quot;member_template&quot;&gt;data member of a class template&lt;/a&gt;:</source>
          <target state="translated">다른 &lt;a href=&quot;static&quot;&gt;정적 멤버&lt;/a&gt; 와 마찬가지로 정적 데이터 멤버 템플릿의 정의가 필요할 수 있습니다. 이러한 정의는 클래스 정의 외부에 제공됩니다. 네임 스페이스 범위에서 정적 데이터 멤버의 템플릿 선언은 &lt;a href=&quot;member_template&quot;&gt;클래스 템플릿의&lt;/a&gt; 템플릿이 아닌 데이터 멤버의 정의 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0caedc0a848a88fa7660a1d1d491a243138571ee" translate="yes" xml:space="preserve">
          <source>As with unions, if a variant holds a value of some object type &lt;code&gt;T&lt;/code&gt;, the object representation of &lt;code&gt;T&lt;/code&gt; is allocated directly within the object representation of the variant itself. Variant is not allowed to allocate additional (dynamic) memory.</source>
          <target state="translated">변형 일부 오브젝트 유형의 값을 보유하는 경우 조합과 같이, &lt;code&gt;T&lt;/code&gt; 가 의 객체 표현 &lt;code&gt;T&lt;/code&gt; 는 변형 자체의 객체 표현에서 직접 할당된다. 변형은 추가 (동적) 메모리를 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a16aea9de44066876745f8be1e3815d74bf01236" translate="yes" xml:space="preserve">
          <source>As with using-declarations for any other non-static member functions, if an inherited constructor matches the signature of one of the constructors of &lt;code&gt;Derived&lt;/code&gt;, it is hidden from lookup by the version found in &lt;code&gt;Derived&lt;/code&gt;. If one of the inherited constructors of &lt;code&gt;Base&lt;/code&gt; happens to have the signature that matches a copy/move constructor of the &lt;code&gt;Derived&lt;/code&gt;, it does not prevent implicit generation of &lt;code&gt;Derived&lt;/code&gt; copy/move constructor (which then hides the inherited version, similar to &lt;code&gt;using operator=&lt;/code&gt;).</source>
          <target state="translated">상속 생성자의 생성자 중 하나의 서명이 일치하는 경우는 임의의 다른 비 - 정적 멤버 함수의 사용 선언-와 같이 &lt;code&gt;Derived&lt;/code&gt; , 그것이 검색된 버전 룩업 숨겨져 &lt;code&gt;Derived&lt;/code&gt; . &lt;code&gt;Base&lt;/code&gt; 의 상속 된 생성자 중 하나가 &lt;code&gt;Derived&lt;/code&gt; 의 복사 / 이동 생성자와 일치하는 서명을 갖는 경우 &lt;code&gt;Derived&lt;/code&gt; 복사 / 이동 생성자 의 암시 적 생성을 막지 않습니다 (그런 다음 &lt;code&gt;using operator=&lt;/code&gt; 를 사용하는 것과 같이 상속 된 버전을 숨 깁니다 ) .</target>
        </trans-unit>
        <trans-unit id="79bc029ba48a0820eb9af6de0ebd1ea7e6ea9789" translate="yes" xml:space="preserve">
          <source>As-if rule</source>
          <target state="translated">그대로 규칙</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="b2f457245914fc23605f0f7914ce430db153c7e2" translate="yes" xml:space="preserve">
          <source>Assertions help to implement checking of preconditions in programs.</source>
          <target state="translated">어설 션은 프로그램에서 사전 조건 확인을 구현하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="fdd23dc2be237bc20201ebacd22daaf8d91fcba6" translate="yes" xml:space="preserve">
          <source>Assign the range &lt;code&gt;[il.begin(), il.end())&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt;. Elements of &lt;code&gt;a&lt;/code&gt; that were not assigned to are destroyed</source>
          <target state="translated">범위 지정 &lt;code&gt;[il.begin(), il.end())&lt;/code&gt; 로 &lt;code&gt;a&lt;/code&gt; . 의 요소 할당되지 않은 파괴하는 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f202c66f553fb440879be6b02e68b6d5eec62e62" translate="yes" xml:space="preserve">
          <source>Assign the value of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 의 값 을 &lt;code&gt;*this&lt;/code&gt; 에 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a88debc55c7f994c398ec8c342bc18a51643d37f" translate="yes" xml:space="preserve">
          <source>Assignable</source>
          <target state="translated">Assignable</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="57808f73b7c2a86fa45f02e4061d5d9b69c60881" translate="yes" xml:space="preserve">
          <source>Assignment need not be a total function. In particular, if assigning to some object &lt;code&gt;x&lt;/code&gt; can cause some other object &lt;code&gt;y&lt;/code&gt; to be modified, then &lt;code&gt;x = y&lt;/code&gt; is likely not in the domain of &lt;code&gt;=&lt;/code&gt;. This typically happens if the right operand is owned directly or indirectly by the left operand (e.g., with smart pointers to nodes in an node-based data structure, or with something like &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;../utility/any&quot;&gt;std::any&lt;/a&gt;&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">과제는 전체 기능 일 필요는 없습니다. 어떤 오브젝트에 할당하는 경우, 특히, &lt;code&gt;x&lt;/code&gt; 발생할 수있는 다른 오브젝트 &lt;code&gt;y&lt;/code&gt; 다음, 수정 될 &lt;code&gt;x = y&lt;/code&gt; 의 도메인 같지는 않다 &lt;code&gt;=&lt;/code&gt; . 이는 일반적으로 오른쪽 피연산자가 왼쪽 피연산자에 의해 직접 또는 간접적으로 소유되는 경우에 발생합니다 (예 : 노드 기반 데이터 구조의 노드에 대한 스마트 포인터 또는 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;../utility/any&quot;&gt;std::any&lt;/a&gt;&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="39671023c69da7c852abacd292e68eeae860a3fe" translate="yes" xml:space="preserve">
          <source>Assignment operator</source>
          <target state="translated">할당 연산자</target>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="translated">할당 연산자</target>
        </trans-unit>
        <trans-unit id="a8dbab8cdfdf68fc2916694485f688c6d01225f3" translate="yes" xml:space="preserve">
          <source>Assignment operators modify the value of the object.</source>
          <target state="translated">할당 연산자는 객체의 값을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="fcab7b97b0f1e15ee8896c3acff0e0448829e741" translate="yes" xml:space="preserve">
          <source>Assignment through a mutable &lt;code&gt;ForwardIterator&lt;/code&gt; iterator cannot invalidate the iterator (implicit due to &lt;code&gt;reference&lt;/code&gt; defined as a true reference)</source>
          <target state="translated">변경 가능한 &lt;code&gt;ForwardIterator&lt;/code&gt; 반복자 를 통한 지정 은 반복자를 무효화 할 수 없습니다 ( 실제 참조로 정의 된 &lt;code&gt;reference&lt;/code&gt; 로 인해 암시 적 )</target>
        </trans-unit>
        <trans-unit id="fe44cd73fab188856ba0f6384ea8fafe903edc50" translate="yes" xml:space="preserve">
          <source>Assignment through an output iterator is expected to alternate with incrementing. Double-increment is undefined behavior (C++ standard currently claims that double increment is supported, contrary to the STL documentation; this is &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2035&quot;&gt;LWG #2035&lt;/a&gt;).</source>
          <target state="translated">출력 반복자를 통한 할당은 증분과 교대로 예상됩니다. 이중 증가는 정의되지 않은 동작입니다 (C ++ 표준에서는 현재 STL 문서와 달리 이중 증가가 지원된다고 주장합니다. &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2035&quot;&gt;LWG # 2035입니다&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="553860964fd6a1007a18f254d5618448ceac0701" translate="yes" xml:space="preserve">
          <source>Assignment through the same value of an output iterator happens only once: algorithms on output iterators must be single-pass algorithms.</source>
          <target state="translated">출력 반복기의 동일한 값을 통한 할당은 한 번만 발생합니다. 출력 반복기의 알고리즘은 단일 패스 알고리즘이어야합니다.</target>
        </trans-unit>
        <trans-unit id="524653a24d773948c1d7496e501b9fa8b1adbd56" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. This defaulted assignment operator performs a shallow copy of the data pointer and the size, i.e., after a call to this function, &lt;code&gt;data() == other.data()&lt;/code&gt; and &lt;code&gt;size() == other.size()&lt;/code&gt;.</source>
          <target state="translated">를 할당 &lt;code&gt;other&lt;/code&gt; 에 &lt;code&gt;*this&lt;/code&gt; . 이 기본 할당 연산자는 데이터 포인터와 크기의 얕은 사본을 수행합니다. 즉,이 함수를 호출 한 후 &lt;code&gt;data() == other.data()&lt;/code&gt; 및 &lt;code&gt;size() == other.size()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4f7c009b9e05455f5ee322973dbe74b2cf883cb0" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;r = d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r = d&lt;/code&gt; 할당합니다</target>
        </trans-unit>
        <trans-unit id="4aafd41880c29ea871a64084e56a24b9a1dd1f31" translate="yes" xml:space="preserve">
          <source>Assigns a character.</source>
          <target state="translated">문자를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="c380382dc946c6b38c72f9000c2fa642f83370ed" translate="yes" xml:space="preserve">
          <source>Assigns a new</source>
          <target state="translated">새로운 할당</target>
        </trans-unit>
        <trans-unit id="148d8d90edaa74304a70db798f7ca1605e9d4d0a" translate="yes" xml:space="preserve">
          <source>Assigns a recursive directory iterator.</source>
          <target state="translated">재귀 디렉토리 반복자를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="6bcc16d175c62b0f7d0ca59170841be8738b1f42" translate="yes" xml:space="preserve">
          <source>Assigns a value to the referenced bit.</source>
          <target state="translated">참조 된 비트에 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="70c1ad8e16a29319ca5255591ac175bae3d1f77a" translate="yes" xml:space="preserve">
          <source>Assigns another &lt;code&gt;basic_filebuf&lt;/code&gt; object.</source>
          <target state="translated">다른 &lt;code&gt;basic_filebuf&lt;/code&gt; 객체를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="ac1f7eb83c6013e04d8d08ba10d298a42ccc7668" translate="yes" xml:space="preserve">
          <source>Assigns another stream object.</source>
          <target state="translated">다른 스트림 객체를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b30f137ee566f8e589d71ba4820344e1b4d0d089" translate="yes" xml:space="preserve">
          <source>Assigns contents to an error condition.</source>
          <target state="translated">내용을 오류 조건에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="ad0b945b4ffa28d85095693a880450266a0ca151" translate="yes" xml:space="preserve">
          <source>Assigns contents to an error condition. Sets the error code to &lt;code&gt;val&lt;/code&gt; and error category to &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="translated">내용을 오류 조건에 할당합니다. 오류 코드를 &lt;code&gt;val&lt;/code&gt; 로 설정 하고 오류 범주를 &lt;code&gt;cat&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="ea89ac146cf04142bd2be43a6e0a9c6e6569d6ee" translate="yes" xml:space="preserve">
          <source>Assigns contents to the contained value.</source>
          <target state="translated">포함 된 값에 내용을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="2093eed70685137da5105e2eb98d22672f7415b0" translate="yes" xml:space="preserve">
          <source>Assigns new content to the directory entry object. Sets the path to &lt;code&gt;p&lt;/code&gt; and calls &lt;a href=&quot;refresh&quot;&gt;&lt;code&gt;refresh&lt;/code&gt;&lt;/a&gt; to update the cached attributes. If an error occurs, the values of the cached attributes are unspecified.</source>
          <target state="translated">디렉토리 엔트리 객체에 새로운 내용을 할당합니다. 캐시 된 속성을 업데이트 하기 위해 경로를 &lt;code&gt;p&lt;/code&gt; 로 설정하고 &lt;a href=&quot;refresh&quot;&gt; &lt;code&gt;refresh&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 오류가 발생하면 캐시 된 속성 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="985e7cc92c5da0b124ac42b6b293ea6ab860d46d" translate="yes" xml:space="preserve">
          <source>Assigns new values to the contents.</source>
          <target state="translated">내용에 새로운 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="01f85854d8567649bd63cc3cf8e502d10e76c2fa" translate="yes" xml:space="preserve">
          <source>Assigns the contents of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 의 내용을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="334748da8228ad08ebb5167fc8305cc7025bf9e9" translate="yes" xml:space="preserve">
          <source>Assigns the contents of another &lt;code&gt;shared_future&lt;/code&gt;.</source>
          <target state="translated">다른 &lt;code&gt;shared_future&lt;/code&gt; 의 내용을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="b207364b5a449e23901fdab43b361ab06c868233" translate="yes" xml:space="preserve">
          <source>Assigns the contents of another future object.</source>
          <target state="translated">다른 미래 객체의 내용을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="4f05b82c9cda5c4c83b76872686239121d98d3fc" translate="yes" xml:space="preserve">
          <source>Assigns the contents of one &lt;code&gt;duration&lt;/code&gt; to another.</source>
          <target state="translated">한 &lt;code&gt;duration&lt;/code&gt; 의 내용을 다른 기간 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="e767b59b7ccb0fbb234828fcb4b12aaf2f52a32b" translate="yes" xml:space="preserve">
          <source>Assigns the contents to the regular expression.</source>
          <target state="translated">컨텐츠를 정규식에 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2dfd90f5b61c413ae9ace2f839434909fb2f18d8" translate="yes" xml:space="preserve">
          <source>Assigns the contents.</source>
          <target state="translated">내용을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="19908a094e988df6a7adcb0e6c5d93f456d9ed88" translate="yes" xml:space="preserve">
          <source>Assigns the data members of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 의 데이터 멤버 를 &lt;code&gt;*this&lt;/code&gt; 에 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="82e1cf9bdead926f51d186513fb276548517188c" translate="yes" xml:space="preserve">
          <source>Assigns the given value &lt;code&gt;value&lt;/code&gt; to all elements in the container.</source>
          <target state="translated">주어진 값의 할당 &lt;code&gt;value&lt;/code&gt; 컨테이너의 모든 요소를.</target>
        </trans-unit>
        <trans-unit id="86e7899b4fde9882ed3e1a38d15420d9298faf2e" translate="yes" xml:space="preserve">
          <source>Assigns the range represented by &lt;code&gt;il&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt;&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;sequencecontainer#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">로 표시되는 범위를 할당 &lt;code&gt;il&lt;/code&gt; 로 &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;sequencecontainer#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; &lt;code&gt;a&lt;/code&gt; &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="191520175c260ae79e0f47e5426987b311a602d8" translate="yes" xml:space="preserve">
          <source>Assigns values to all referred elements.</source>
          <target state="translated">참조 된 모든 요소에 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="902cee84cc49e2a403fa00fdfc2ec44cf1457c20" translate="yes" xml:space="preserve">
          <source>Associated types</source>
          <target state="translated">관련 유형</target>
        </trans-unit>
        <trans-unit id="9ed2fd1fcf10b45d142954b85138750fe63d022c" translate="yes" xml:space="preserve">
          <source>Associated use_count increments are guaranteed to be part of the atomic operation. Associated use_count decrements are sequenced after the atomic operation, but are not required to be part of it, except for the use_count change when overriding &lt;code&gt;expected&lt;/code&gt; in a failed CAS. Any associated deletion and deallocation are sequenced after the atomic update step and are not part of the atomic operation.</source>
          <target state="translated">연관된 use_count 증가는 원 자성 조작의 일부로 보장됩니다. 연관된 use_count 감소는 원 자성 조작 후에 순서화되지만 실패한 CAS에서 &lt;code&gt;expected&lt;/code&gt; 되는 재정의시 use_count 변경을 제외하고는 그 일부가 될 필요는 없습니다 . 연관된 삭제 및 할당 해제는 원자 업데이트 단계 이후에 순서가 지정되며 원자 작업의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bad1cb6f24e9b441150943730abacf00652d78d1" translate="yes" xml:space="preserve">
          <source>Associates one or more exception handlers (catch-clauses) with a compound statement.</source>
          <target state="translated">하나 이상의 예외 핸들러 (catch-clauses)를 복합 명령문과 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="e1b7038d16ea26b3ef95375a5ebae12043ab309d" translate="yes" xml:space="preserve">
          <source>Associative containers</source>
          <target state="translated">연관 컨테이너</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
