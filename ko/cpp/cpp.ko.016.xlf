<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="a3d00b46e93a04f762ceacf129a7d8e708f9cdae" translate="yes" xml:space="preserve">
          <source>If object is an lvalue expression, and its type is &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, and is equally or less cv-qualified, then the reference is bound to the object identified by the lvalue or to its base class subobject.</source>
          <target state="translated">object가 lvalue 표현식이고 유형이 &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;T&lt;/code&gt; 에서 파생되고 cv 규정이 같거나 적은 경우 참조는 lvalue로 식별 된 오브젝트 또는 기본 클래스 서브 오브젝트에 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="aa22f5451003f7660daffd02d5df19ccf7abfc20" translate="yes" xml:space="preserve">
          <source>If one evaluation modifies a memory location, and the other reads or modifies the same memory location, and if at least one of the evaluations is not an atomic operation, the behavior of the program is undefined (the program has a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) unless there exists a</source>
          <target state="translated">하나의 평가가 메모리 위치를 수정하고 다른 평가가 동일한 메모리 위치를 읽거나 수정하는 경우, 평가 중 하나 이상이 원자 연산이 아닌 경우 프로그램의 동작은 정의되지 않은 경우 (프로그램에는 &lt;a href=&quot;../language/memory_model&quot;&gt;데이터 경쟁이 있음&lt;/a&gt; ) 존재한다</target>
        </trans-unit>
        <trans-unit id="e3ee4df0d28305af8190dfed503a69842ecdea1b" translate="yes" xml:space="preserve">
          <source>If one of the operands is of type &lt;code&gt;bool&lt;/code&gt; and the other is not, the program is ill-formed.</source>
          <target state="translated">피연산자 중 하나가 &lt;code&gt;bool&lt;/code&gt; 유형 이고 다른 피연산자가 아닌 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2677ad2fee54206928d1289296944052d7155f2a" translate="yes" xml:space="preserve">
          <source>If one of the strings has an encoding prefix and the other doesn't, the one that doesn't will be considered to have the same encoding prefix as the other.</source>
          <target state="translated">문자열 중 하나에 인코딩 접두사가 있고 다른 문자열에 그렇지 않으면 다른 문자열과 동일한 인코딩 접두사를 갖는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5394cec101ec494404d07198530eec4ab37c59ad" translate="yes" xml:space="preserve">
          <source>If one of the two arguments is NaN, the value of the other argument is returned</source>
          <target state="translated">두 인수 중 하나가 NaN이면 다른 인수의 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="41700bbfc9368c2b5358e57134ccfd94d1f553f5" translate="yes" xml:space="preserve">
          <source>If one range is a prefix of another, the shorter range is lexicographically</source>
          <target state="translated">한 범위가 다른 범위의 접두사 인 경우 짧은 범위는 사전 식으로</target>
        </trans-unit>
        <trans-unit id="dcc36215317b874404f96885cfc95439d29a3922" translate="yes" xml:space="preserve">
          <source>If only one function is left, that function is selected.</source>
          <target state="translated">하나의 기능 만 남으면 해당 기능이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="58314a8e7e0dda6a0f7693f28a3be7368beb7517" translate="yes" xml:space="preserve">
          <source>If only one of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; contains a value (let's call this object &lt;code&gt;in&lt;/code&gt; and the other &lt;code&gt;un&lt;/code&gt;), the contained value of &lt;code&gt;un&lt;/code&gt; is &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; from &lt;code&gt;std::move(*in)&lt;/code&gt;, followed by destruction of the contained value of &lt;code&gt;in&lt;/code&gt; as if by &lt;code&gt;in-&amp;gt;T::~T()&lt;/code&gt;. After this call, &lt;code&gt;in&lt;/code&gt; does not contain a value; &lt;code&gt;un&lt;/code&gt; contains a value.</source>
          <target state="translated">단 하나의 경우 &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 값이 포함이 (의이 객체를 호출 할 수 &lt;code&gt;in&lt;/code&gt; 다른 &lt;code&gt;un&lt;/code&gt; )의 포함 된 값 &lt;code&gt;un&lt;/code&gt; 입니다 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 에서 &lt;code&gt;std::move(*in)&lt;/code&gt; 의 포함 된 값의 파괴 다음에, &lt;code&gt;in&lt;/code&gt; 경우와 같게 &lt;code&gt;in-&amp;gt;T::~T()&lt;/code&gt; . 이 호출 후, &lt;code&gt;in&lt;/code&gt; 에는 값이 없습니다. &lt;code&gt;un&lt;/code&gt; 은 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="38fac4f8f19905bafe2c9ea62d2092290cb1aaea" translate="yes" xml:space="preserve">
          <source>If only one of the two function templates being compared is a member function , and that function template is a non-static member of some class &lt;code&gt;A&lt;/code&gt;, a new first parameter is inserted into its parameter list, whose type is &lt;code&gt;cv A&amp;amp;&amp;amp;&lt;/code&gt; if the member function template is &amp;amp;&amp;amp;-qualified and &lt;code&gt;cv A&amp;amp;&lt;/code&gt; otherwise (cv is the cv-qualification of the member function template) -- this helps the ordering of operators, which are looked up both as member and as non-member functions:</source>
          <target state="translated">비교중인 두 함수 템플리트 중 하나만 멤버 함수이고 해당 함수 템플리트가 일부 클래스 &lt;code&gt;A&lt;/code&gt; 의 비 정적 멤버 인 경우 멤버 함수 인 경우 유형이 &lt;code&gt;cv A&amp;amp;&amp;amp;&lt;/code&gt; 인 새 첫 번째 매개 변수가 매개 변수 목록에 삽입됩니다. 템플릿은 &amp;amp;&amp;amp;-qualified이고 &lt;code&gt;cv A&amp;amp;&lt;/code&gt; 그렇지 않습니다 (cv는 멤버 함수 템플릿의 cv-qualification입니다). 이는 멤버 및 비 멤버 함수로 조회되는 연산자의 순서를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ec7712843cd5f938f1aba16750b9a0671c8585bc" translate="yes" xml:space="preserve">
          <source>If other is an rvalue expression, &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt; will be selected by overload resolution and called during copy-initialization. There is no such term as move-initialization.</source>
          <target state="translated">other가 rvalue 표현식 인 경우, 과부하 &lt;a href=&quot;move_constructor&quot;&gt;생성에&lt;/a&gt; 의해 이동 생성자 가 선택되고 복사 초기화 중에 호출됩니다. 이동 초기화와 같은 용어는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ddc5ecaabd07bdd4041442caa75864db6c6d691" translate="yes" xml:space="preserve">
          <source>If overflow occurs, the behavior is undefined.</source>
          <target state="translated">오버플로가 발생하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="750847988fad756b2797b04ab539da8a7a039e9f" translate="yes" xml:space="preserve">
          <source>If overload resolution selects an inherited constructor, it is accessible if it would be accessible when used to construct an object of the corresponding base class: the accessibility of the using-declaration that introduced it is ignored.</source>
          <target state="translated">오버로드 해결이 상속 된 생성자를 선택하는 경우 해당 기본 클래스의 오브젝트를 구성하는 데 사용될 때 액세스 할 수있는 경우 액세스 할 수 있습니다.이를 도입 한 사용 선언의 액세스 가능성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="210ca7809f61451a624d2c6beec2bcb2c768f5c6" translate="yes" xml:space="preserve">
          <source>If overload resolution selects one of the inherited constructors when initializing an object of such derived class, then the &lt;code&gt;Base&lt;/code&gt; subobject from which the constructor was inherited is initialized using the inherited constructor, and all other bases and members of &lt;code&gt;Derived&lt;/code&gt; are initialized as if by the defaulted default constructor (default member initializers are used if provided, otherwise default initialization takes place). The entire initialization is treated as a single function call: initialization of the parameters of the inherited constructor is sequenced-before initialization of any base or member of the derived object.</source>
          <target state="translated">이러한 파생 클래스의 개체를 초기화 할 때 오버로드 확인에서 상속 된 생성자 중 하나를 선택하면 상속 된 생성자 를 사용하여 생성자가 상속 된 &lt;code&gt;Base&lt;/code&gt; 하위 개체 가 초기화되고 &lt;code&gt;Derived&lt;/code&gt; 의 다른 모든 기본 및 멤버 는 기본값이 지정된 것처럼 초기화됩니다. 기본 생성자 (제공된 경우 기본 멤버 이니셜 라이저가 사용되며 그렇지 않으면 기본 초기화가 수행됨) 전체 초기화는 단일 함수 호출로 처리됩니다. 상속 된 생성자의 매개 변수 초기화는 파생 된 객체의 기본 또는 멤버 초기화 전에 순서화됩니다.</target>
        </trans-unit>
        <trans-unit id="569b041ed62609471e4536cb80335e9cadb562bd" translate="yes" xml:space="preserve">
          <source>If possible, constructs an object of type &lt;code&gt;T&lt;/code&gt; in allocated uninitialized storage pointed to by &lt;code&gt;p&lt;/code&gt;, by calling.</source>
          <target state="translated">가능하면 &lt;code&gt;p&lt;/code&gt; 가 가리키는 초기화되지 않은 할당 된 스토리지에 &lt;code&gt;T&lt;/code&gt; 유형의 객체를 호출하여 구성합니다.</target>
        </trans-unit>
        <trans-unit id="7bd19a7c8b0277a43bb96d2aa204eaa9e1df26a8" translate="yes" xml:space="preserve">
          <source>If possible, obtains the copy-constructed version of the allocator &lt;code&gt;a&lt;/code&gt;, by calling &lt;code&gt;a.select_on_container_copy_construction()&lt;/code&gt;. If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;select_on_container_copy_construction()&lt;/code&gt;, then returns &lt;code&gt;a&lt;/code&gt;, unmodified.</source>
          <target state="translated">가능하면 &lt;code&gt;a.select_on_container_copy_construction()&lt;/code&gt; 을 호출 하여 할당 &lt;code&gt;a&lt;/code&gt; 복사기 버전의 할당 자 a 를 가져옵니다 . 위의 방법을 사용할 수없는 경우 (예 : &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;select_on_container_copy_construction()&lt;/code&gt; 멤버 함수가없는 경우 ) 수정되지 않은 을 반환 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2bb51f991f1f844a514dcdb161773a64461aa00" translate="yes" xml:space="preserve">
          <source>If possible, obtains the maximum theoretically possible allocation size from the allocator &lt;code&gt;a&lt;/code&gt;, by calling.</source>
          <target state="translated">가능하면 할당 자 &lt;code&gt;a&lt;/code&gt; 에서 이론적으로 가능한 최대 할당 크기를 호출 하여 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="e98d09928ca05eb652c54751fcdfc483c6a1ba29" translate="yes" xml:space="preserve">
          <source>If present, the &lt;code&gt;hash&lt;/code&gt; parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking &lt;code&gt;&lt;a href=&quot;hash_function&quot;&gt;hash_function()&lt;/a&gt;&lt;/code&gt; on the key passed do not produce the same value as &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">존재하는 경우, &lt;code&gt;hash&lt;/code&gt; 파라미터는 최적화로서 미리 계산 된 해시 값을 전달하는데 사용될 수있다. 전달 된 키에서 &lt;code&gt;&lt;a href=&quot;hash_function&quot;&gt;hash_function()&lt;/a&gt;&lt;/code&gt; 을 호출 해도 &lt;code&gt;hash&lt;/code&gt; 와 동일한 값을 생성하지 않으면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b615c53ecc545ad86db4eb50538fd76266abf064" translate="yes" xml:space="preserve">
          <source>If present, the &lt;code&gt;hash&lt;/code&gt; parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking &lt;code&gt;hash_function()&lt;/code&gt; on the key passed do not produce the same value as &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">존재하는 경우, &lt;code&gt;hash&lt;/code&gt; 파라미터는 최적화로서 미리 계산 된 해시 값을 전달하는데 사용될 수있다. 전달 된 키에서 &lt;code&gt;hash_function()&lt;/code&gt; 을 호출 해도 &lt;code&gt;hash&lt;/code&gt; 와 동일한 값을 생성하지 않으면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d0ad3998a5ac30264cf943a5c000f09e6f5af44e" translate="yes" xml:space="preserve">
          <source>If prior to the call &lt;code&gt;*this&lt;/code&gt; has an associated mutex and has acquired ownership of it, the mutex is unlocked.</source>
          <target state="translated">호출 전에 &lt;code&gt;*this&lt;/code&gt; 관련된 뮤텍스를 가지고 있고 그 소유권을 획득 한 경우, 뮤텍스의 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="5bdd482f92ba03cbf032a677ef80f876bd9e89d4" translate="yes" xml:space="preserve">
          <source>If putback position was available, returns the character that the next pointer is now pointing at, converted to &lt;code&gt;int_type&lt;/code&gt; with &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;. The next single-character input from this streambuf will return this character.</source>
          <target state="translated">putback position이 사용 가능하면, 다음 포인터가 가리키는 문자를 &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; 으로 &lt;code&gt;int_type&lt;/code&gt; 으로 변환 한 문자를 리턴합니다 . 이 streambuf에서 다음 단일 문자 입력은이 문자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3eb692c025338041e4eed4f9319cfb04b675d552" translate="yes" xml:space="preserve">
          <source>If putback position was not available, returns what &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; returns, which is &lt;code&gt;Traits::eof()&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; position을 사용할 수없는 경우 pbackfail ()이 반환하는 것을 반환합니다 &lt;code&gt;Traits::eof()&lt;/code&gt; 실패시 Traits :: eof ()) .</target>
        </trans-unit>
        <trans-unit id="fd77c426f218dbc4996392b11cbf4a9df041bd55" translate="yes" xml:space="preserve">
          <source>If range_expression is an expression of a class type &lt;code&gt;C&lt;/code&gt; that has both a member named &lt;code&gt;begin&lt;/code&gt; and a member named &lt;code&gt;end&lt;/code&gt; (regardless of the type or accessibility of such member), then</source>
          <target state="translated">range_expression이 &lt;code&gt;begin&lt;/code&gt; 이라는 멤버 와 &lt;code&gt;end&lt;/code&gt; 라는 멤버를 가진 클래스 유형 &lt;code&gt;C&lt;/code&gt; 의 표현식 인 경우 ( 해당 멤버 의 유형 또는 액세스 가능성에 관계없이)</target>
        </trans-unit>
        <trans-unit id="a31a47abbcbe52c11cb5aabb738ee006961c36bf" translate="yes" xml:space="preserve">
          <source>If range_expression is an expression of array type, then</source>
          <target state="translated">range_expression이 배열 유형의 표현식 인 경우</target>
        </trans-unit>
        <trans-unit id="8998880636aec0b41e1f3aa9bb5068fe2d087a45" translate="yes" xml:space="preserve">
          <source>If range_expression returns a temporary, its lifetime is extended until the end of the loop, as indicated by binding to the forwarding reference &lt;b&gt;&lt;code&gt;__range&lt;/code&gt;&lt;/b&gt;, but beware that the lifetime of any temporary within range_expression</source>
          <target state="translated">range_expression이 임시를 리턴하는 경우, 전달 참조 &lt;b&gt; &lt;code&gt;__range&lt;/code&gt; &lt;/b&gt; 에 바인딩하여 표시된대로 루프의 끝까지 수명이 연장 되지만 range_expression 내의 임시 수명은주의하십시오.</target>
        </trans-unit>
        <trans-unit id="831b1dfec868a21157a075677fd82a9bf6d69aa8" translate="yes" xml:space="preserve">
          <source>If rdbuf() is a null pointer, does nothing.</source>
          <target state="translated">rdbuf ()가 널 포인터이면 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b1e7d795c25e0720f46207c35f854b7bc6a7349" translate="yes" xml:space="preserve">
          <source>If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.</source>
          <target state="translated">재 할당이 발생하면 과거 종료 반복자를 포함한 모든 반복자와 요소에 대한 모든 참조가 무효화됩니다. 재 할당이 발생하지 않으면 반복자 또는 참조가 무효화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5722a09effa0795d91444af4d2753abca8a7e18" translate="yes" xml:space="preserve">
          <source>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;.</source>
          <target state="translated">삽입으로 인해 다시 해싱이 발생하면 모든 반복자가 무효화됩니다. 그렇지 않으면 반복자는 영향을받지 않습니다. 참조가 무효화되지 않았습니다. 재해시는 새로운 요소 수가 &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; 보다 큰 경우에만 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="b48960c4455b015acecf76682b1d33d5044e8f1b" translate="yes" xml:space="preserve">
          <source>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.(since C++17).</source>
          <target state="translated">삽입으로 인해 다시 해싱이 발생하면 모든 반복자가 무효화됩니다. 그렇지 않으면 반복자는 영향을받지 않습니다. 참조가 무효화되지 않았습니다. 재해시는 새로운 요소 수가 &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; 보다 큰 경우에만 발생합니다 . 삽입에 성공하면, 노드 핸들에있는 동안 획득 한 요소에 대한 포인터 및 참조가 무효화되고, 추출되기 전에 해당 요소에 대해 얻은 포인터 및 참조가 유효 해집니다 (C ++ 17 이후).</target>
        </trans-unit>
        <trans-unit id="e5803322a669884d371a27e94b8e3347c4a1e0b8" translate="yes" xml:space="preserve">
          <source>If removing references and cv-qualifiers from &lt;code&gt;P&lt;/code&gt; gives &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;P'&amp;gt;&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is a &lt;a href=&quot;list_initialization&quot;&gt;braced-init-list&lt;/a&gt;, then deduction is performed for every element of the initializer list, taking &lt;code&gt;P'&lt;/code&gt; as the parameter and the list element &lt;code&gt;A'&lt;/code&gt; as the argument:</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 에서 참조 및 cv 한정자를 제거 하면 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;P'&amp;gt;&lt;/code&gt; 되고 &lt;code&gt;A&lt;/code&gt; 가 &lt;a href=&quot;list_initialization&quot;&gt;braced-init-list&lt;/a&gt; 이면 &lt;code&gt;P'&lt;/code&gt; 를 매개 변수로 사용하고 목록 요소로 사용하여 이니셜 라이저 목록의 모든 요소에 대해 추론이 수행 됩니다. 인수로 &lt;code&gt;A'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4023bf4d1f43d575e2d6327b1416c5ed7d9cb751" translate="yes" xml:space="preserve">
          <source>If removing references and cv-qualifiers from &lt;code&gt;P&lt;/code&gt; gives &lt;code&gt;P'&lt;/code&gt;[&lt;code&gt;N&lt;/code&gt;], and &lt;code&gt;A&lt;/code&gt; is a non-empty braced-init-list, then deduction is performed as above, except if &lt;code&gt;N&lt;/code&gt; is a non-type template parameter, it is deduced from the length of the initializer list:</source>
          <target state="translated">참조한 및 CV-한정자 제거하면 &lt;code&gt;P&lt;/code&gt; 하는 범 &lt;code&gt;P'&lt;/code&gt; [ &lt;code&gt;N&lt;/code&gt; 을 , 그리고 &lt;code&gt;A&lt;/code&gt; 는 이고 비어 보강-INIT-목록 다음 공제 상기와 같은 경우를 제외하고 행해진 다 &lt;code&gt;N&lt;/code&gt; 은 비 형 템플릿 파라미터이고,이 도출된다 초기화 목록의 길이에서 :</target>
        </trans-unit>
        <trans-unit id="3e746f9c695cdf56415555b25b2b13ebeeb30b4c" translate="yes" xml:space="preserve">
          <source>If searching for an empty string (&lt;code&gt;str.size()&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, or &lt;code&gt;Traits::length(s)&lt;/code&gt; is zero) returns &lt;code&gt;pos&lt;/code&gt; (the empty string is found immediately) unless &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; (including the case where &lt;code&gt;pos == npos&lt;/code&gt;), in which case returns &lt;code&gt;size()&lt;/code&gt;.</source>
          <target state="translated">빈 문자열 ( &lt;code&gt;str.size()&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; 또는 &lt;code&gt;Traits::length(s)&lt;/code&gt; 이 0 임 )을 검색하면 &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; 가 아닌 한 &lt;code&gt;pos&lt;/code&gt; (빈 문자열이 즉시 발견됨 )를 반환합니다 ( &lt;code&gt;pos == npos&lt;/code&gt; 경우 포함 ) npos ),이 경우 &lt;code&gt;size()&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="8032ef45e981f5ae9ab731c15293224cc1be4894" translate="yes" xml:space="preserve">
          <source>If side-effect A is visible with respect to the value computation B, then the longest contiguous subset of the side-effects to M, in</source>
          <target state="translated">값 계산 B와 관련하여 부작용 A가 보이는 경우, 부작용의 가장 긴 연속 서브 세트는 M에서</target>
        </trans-unit>
        <trans-unit id="a813fcc7c976b042560912c3cfabd51324dc8cdf" translate="yes" xml:space="preserve">
          <source>If some &lt;a href=&quot;value_category&quot;&gt;glvalue expression&lt;/a&gt; refers to a &lt;a href=&quot;objects&quot;&gt;polymorphic object&lt;/a&gt;, the type of its most derived object is known as the dynamic type.</source>
          <target state="translated">일부 &lt;a href=&quot;value_category&quot;&gt;glvalue 표현식&lt;/a&gt; 이 &lt;a href=&quot;objects&quot;&gt;다형성 객체를&lt;/a&gt; 참조하는 경우 가장 파생 된 객체의 유형을 동적 유형이라고합니다.</target>
        </trans-unit>
        <trans-unit id="eee5be8ef339e31668583c5122cb3ea37abcf9da" translate="yes" xml:space="preserve">
          <source>If some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, it will be copied to &lt;code&gt;d_first&lt;/code&gt; exactly &lt;code&gt;std::abs(m-n)&lt;/code&gt; times. If &lt;code&gt;m&amp;gt;n&lt;/code&gt;, then the last &lt;code&gt;m-n&lt;/code&gt; of those elements are copied from &lt;code&gt;[first1,last1)&lt;/code&gt;, otherwise the last &lt;code&gt;n-m&lt;/code&gt; elements are copied from &lt;code&gt;[first2,last2)&lt;/code&gt;. The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">어떤 요소가 발견되면 &lt;code&gt;m&lt;/code&gt; 의 시간 &lt;code&gt;[first1, last1)&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 의 시간 &lt;code&gt;[first2, last2)&lt;/code&gt; 이를 위해 복사 될 &lt;code&gt;d_first&lt;/code&gt; 정확하게 &lt;code&gt;std::abs(m-n)&lt;/code&gt; 번. &lt;code&gt;m&amp;gt;n&lt;/code&gt; 인 경우 , 해당 요소 의 마지막 &lt;code&gt;m-n&lt;/code&gt; 은 &lt;code&gt;[first1,last1)&lt;/code&gt; 에서 복사되고 , 그렇지 않으면 마지막 &lt;code&gt;n-m&lt;/code&gt; 요소는 &lt;code&gt;[first2,last2)&lt;/code&gt; 에서 복사됩니다 . 결과 범위는 입력 범위 중 하나와 겹칠 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="caf2cbf83a05e60a4bb97a0592549e75d93ad63b" translate="yes" xml:space="preserve">
          <source>If some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, then all &lt;code&gt;m&lt;/code&gt; elements will be copied from &lt;code&gt;[first1, last1)&lt;/code&gt; to &lt;code&gt;d_first&lt;/code&gt;, preserving order, and then exactly &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n-m, 0)&lt;/code&gt; elements will be copied from &lt;code&gt;[first2, last2)&lt;/code&gt; to &lt;code&gt;d_first&lt;/code&gt;, also preserving order.</source>
          <target state="translated">어떤 요소가 발견되면 &lt;code&gt;m&lt;/code&gt; 의 시간 &lt;code&gt;[first1, last1)&lt;/code&gt; 와 &lt;code&gt;n&lt;/code&gt; 의 시간 &lt;code&gt;[first2, last2)&lt;/code&gt; , 모든 &lt;code&gt;m&lt;/code&gt; 요소로 복사한다 &lt;code&gt;[first1, last1)&lt;/code&gt; 하기 &lt;code&gt;d_first&lt;/code&gt; 순서를 보존하고 정확하게 &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n-m, 0)&lt;/code&gt; 요소는 &lt;code&gt;[first2, last2)&lt;/code&gt; 에서 &lt;code&gt;d_first&lt;/code&gt; 로 복사되며 순서도 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="67873cc8d634e461cb815d4a8417a686c3237eb4" translate="yes" xml:space="preserve">
          <source>If some member function &lt;code&gt;vf&lt;/code&gt; is declared as &lt;code&gt;virtual&lt;/code&gt; in a class &lt;code&gt;Base&lt;/code&gt;, and some class &lt;code&gt;Derived&lt;/code&gt;, which is derived, directly or indirectly, from &lt;code&gt;Base&lt;/code&gt;, has a declaration for member function with the same.</source>
          <target state="translated">몇몇 멤버 함수 경우 &lt;code&gt;vf&lt;/code&gt; 선언되는 &lt;code&gt;virtual&lt;/code&gt; 클래스의 &lt;code&gt;Base&lt;/code&gt; , 일부 클래스 &lt;code&gt;Derived&lt;/code&gt; 로부터 직접 또는 간접적으로 유도되는, &lt;code&gt;Base&lt;/code&gt; 의 부재와 동일한 기능을위한 선언을 갖는다.</target>
        </trans-unit>
        <trans-unit id="e561cbd21051ae04ee69688d91773e4d66564214" translate="yes" xml:space="preserve">
          <source>If some of the arguments that are supplied in the call to &lt;code&gt;g()&lt;/code&gt; are not matched by any placeholders stored in &lt;code&gt;g&lt;/code&gt;, the unused arguments are evaluated and discarded.</source>
          <target state="translated">호출에 제공되는 일부 인수하면 &lt;code&gt;g()&lt;/code&gt; 저장된 모든 자리가 일치하지 &lt;code&gt;g&lt;/code&gt; , 미사용 인수 평가 폐기된다.</target>
        </trans-unit>
        <trans-unit id="c16f0b9646e0495cf7360c2d57ef97bff686bc4e" translate="yes" xml:space="preserve">
          <source>If some user-declared constructors are present, the user may still force the automatic generation of a default constructor by the compiler that would be implicitly-declared otherwise with the keyword &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">일부 사용자 선언 생성자가 존재하는 경우, 사용자는 키워드 &lt;code&gt;default&lt;/code&gt; 와 함께 암시 적으로 선언되는 컴파일러에 의해 기본 생성자의 자동 생성을 여전히 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81f7a3f627cd87e8bf750cf042cc3a980725dec5" translate="yes" xml:space="preserve">
          <source>If some user-defined constructors are present, the user may still force the automatic generation of a default constructor by the compiler that would be implicitly-declared otherwise with the keyword &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">일부 사용자 정의 생성자가있는 경우 사용자는 키워드 &lt;code&gt;default&lt;/code&gt; 를 사용하여 암시 적으로 선언 된 컴파일러에서 기본 생성자를 자동으로 강제 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f89b2e39dc991aa70988548f099b5134242e0c1" translate="yes" xml:space="preserve">
          <source>If statement is a single statement (not a compound statement), the scope of variables declared in it is limited to the while loop as if it was a compound statement, in other words,</source>
          <target state="translated">statement가 복합 명령문이 아닌 단일 명령문 인 경우 선언 된 변수의 범위는 복합 명령문 인 것처럼 while 루프로 제한됩니다. 즉,</target>
        </trans-unit>
        <trans-unit id="de8e6184779d6e772f3df1e2bc68eaa83374bf85" translate="yes" xml:space="preserve">
          <source>If statement-true is entered by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; or &lt;code&gt;longjmp&lt;/code&gt;, statement_false is not executed.</source>
          <target state="translated">&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; 또는 &lt;code&gt;longjmp&lt;/code&gt; 로 statement-true를 입력 하면 statement_false가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e2cbc4d6a00d3a75286c31bf804d8bad59194eb" translate="yes" xml:space="preserve">
          <source>If statement_true or statement_false is not a compound statement, it is treated as if it were:</source>
          <target state="translated">statement_true 또는 statement_false가 복합 명령문이 아닌 경우 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="834b8d6940f6e20e10043e602b81088e525449aa" translate="yes" xml:space="preserve">
          <source>If successful, an integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; is returned.</source>
          <target state="translated">성공하면 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 정수 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="25bfeb839d8f5173b50bb285122b4cc54720321c" translate="yes" xml:space="preserve">
          <source>If successful, returns a pointer to the object that controls the opened file stream, with both eof and error bits cleared. The stream is fully buffered unless filename refers to an interactive device.</source>
          <target state="translated">성공하면 eof 및 error 비트가 모두 지워진 상태에서 열린 파일 스트림을 제어하는 ​​객체에 대한 포인터를 반환합니다. filename은 대화식 장치를 참조하지 않는 한 스트림이 완전히 버퍼링됩니다.</target>
        </trans-unit>
        <trans-unit id="5632ad995e8027aefc150ef8436b23c84c4578ae" translate="yes" xml:space="preserve">
          <source>If successful, returns the IEEE floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">성공하면 위에서 정의한대로 &lt;code&gt;x/y&lt;/code&gt; 나누기의 IEEE 부동 소수점 나머지를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7ba7ac810951fe3d89eb854fd7520e591880a573" translate="yes" xml:space="preserve">
          <source>If successful, returns the absolute value of &lt;code&gt;arg&lt;/code&gt; (&lt;code&gt;|arg|&lt;/code&gt;). The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">성공하면 &lt;code&gt;arg&lt;/code&gt; ( &lt;code&gt;|arg|&lt;/code&gt; ) 의 절대 값을 반환합니다 . 반환 된 값은 정확하며 반올림 모드에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a595b23fd21a8f04c669747846486d0e27d71af0" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">성공하면 위에서 정의한 바와 같이 나누기 &lt;code&gt;x/y&lt;/code&gt; 의 부동 소수점 나머지를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="03e429269f7181e14b033dacb9e7bf8c7396151a" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt;, and stores, in &lt;code&gt;*quo&lt;/code&gt;, the sign and at least three of the least significant bits of &lt;code&gt;x/y&lt;/code&gt; (formally, stores a value whose sign is the sign of &lt;code&gt;x/y&lt;/code&gt; and whose magnitude is congruent modulo 2n</source>
          <target state="translated">성공하면, 분할의 부동 소수점 나머지를 반환 &lt;code&gt;x/y&lt;/code&gt; 에 정의 된 &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt; , 저장에, &lt;code&gt;*quo&lt;/code&gt; , 부호와의 최하위 비트의 적어도 세 &lt;code&gt;x/y&lt;/code&gt; (공식적으로, 상점 A를 부호가 &lt;code&gt;x/y&lt;/code&gt; 의 부호 이고 크기가 합동 인 modulo 2n 인 값</target>
        </trans-unit>
        <trans-unit id="ea98bbdcb76a97fab4ef9d6ca9c32eecbe479081" translate="yes" xml:space="preserve">
          <source>If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">성공하면 두 개의 부동 소수점 값 중 더 큰 값을 반환합니다. 반환 된 값은 정확하며 반올림 모드에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9423b4432f6a645ec2473ed82b459b6686deb60f" translate="yes" xml:space="preserve">
          <source>If successful, returns the positive difference between x and y.</source>
          <target state="translated">성공하면 x와 y의 양의 차이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46138f9b406992b59d0f9492f2e64a28cf85480b" translate="yes" xml:space="preserve">
          <source>If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">성공하면 두 개의 부동 소수점 값 중 작은 값을 반환합니다. 반환 된 값은 정확하며 반올림 모드에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ca1e3a726f6c442c2b326f76a16b023bb9441ee" translate="yes" xml:space="preserve">
          <source>If successful, returns the value of &lt;code&gt;(x*y) + z&lt;/code&gt; as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).</source>
          <target state="translated">성공하면 &lt;code&gt;(x*y) + z&lt;/code&gt; 값을 무한 정밀도로 계산하고 결과 유형에 맞게 한 번 반올림 (또는 단일 삼항 부동 소수점 연산으로 계산) 한 것처럼 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="44139e51119b7719b4d6c2c45a98ecd6bcfaac63" translate="yes" xml:space="preserve">
          <source>If such a specialization has a member named &lt;code&gt;type&lt;/code&gt;, it must be a public and unambiguous member type that names a cv-unqualified non-reference type to which both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are explicitly convertible. Additionally, &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; and &lt;code&gt;std::common_type&amp;lt;T2, T1&amp;gt;::type&lt;/code&gt; must denote the same type.</source>
          <target state="translated">이러한 전문화에 &lt;code&gt;type&lt;/code&gt; 이라는 멤버가있는 경우 , &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 를 명시 적으로 변환 할 수있는 cv-unqualified 비 참조 유형의 이름을 지정하는 공용 및 모호하지 않은 멤버 유형이어야합니다 . 또한 &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; 및 &lt;code&gt;std::common_type&amp;lt;T2, T1&amp;gt;::type&lt;/code&gt; 은 동일한 유형을 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="3a37148d1443f4a7f83a98b72097fe4c825195aa" translate="yes" xml:space="preserve">
          <source>If such a specialization has a member named &lt;code&gt;type&lt;/code&gt;, it must be a public and unambiguous member type that names a type to which both &lt;code&gt;TQual&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;UQual&amp;lt;U&amp;gt;&lt;/code&gt; are convertible. Additionally, &lt;code&gt;std::basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;::type&lt;/code&gt; and &lt;code&gt;std::basic_common_reference&amp;lt;U, T, UQual, TQual&amp;gt;::type&lt;/code&gt; must denote the same type.</source>
          <target state="translated">이러한 전문화에 &lt;code&gt;type&lt;/code&gt; 이라는 멤버가있는 경우 &lt;code&gt;TQual&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;UQual&amp;lt;U&amp;gt;&lt;/code&gt; 가 모두 변환 가능한 유형의 이름을 지정하는 공용 및 모호하지 않은 멤버 유형이어야합니다 . 또한 &lt;code&gt;std::basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;::type&lt;/code&gt; 및 &lt;code&gt;std::basic_common_reference&amp;lt;U, T, UQual, TQual&amp;gt;::type&lt;/code&gt; 은 동일한 유형을 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="a948028c1758b5531024e3fe8732225a9c5cc129" translate="yes" xml:space="preserve">
          <source>If such character was found, is it the</source>
          <target state="translated">그러한 캐릭터가 발견되면</target>
        </trans-unit>
        <trans-unit id="18c5e1768b43942789912ab8899675cb0c8b4274" translate="yes" xml:space="preserve">
          <source>If such character was found, it is</source>
          <target state="translated">그러한 캐릭터가 발견되면</target>
        </trans-unit>
        <trans-unit id="1e5aef218cb47cb6d5be701f51f4abca139d0794" translate="yes" xml:space="preserve">
          <source>If such function has multiple return statements, the deduction is performed for each return statement. All the resulting types must be the same and become the actual return type.</source>
          <target state="translated">이러한 함수에 여러 개의 return 문이 있으면 각 return 문에 대해 추론이 수행됩니다. 모든 결과 유형은 동일해야하며 실제 리턴 유형이되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0ef2cb48d46014bbb2de04ceea1ca8d25cb98355" translate="yes" xml:space="preserve">
          <source>If such function has no return statement, &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;void()&lt;/code&gt; when deducing.</source>
          <target state="translated">이러한 함수에 return 문이 없으면 추론 할 때 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;void()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="781a8af57a4e00c05cd18f270856d6e17bfee700" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is</source>
          <target state="translated">그러한 넓은 성격이 발견되면</target>
        </trans-unit>
        <trans-unit id="cc7116ca6f31d674f4a72c2589a0d09f652f8823" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is the</source>
          <target state="translated">그러한 넓은 성격이 발견되면</target>
        </trans-unit>
        <trans-unit id="6016d8ecaf1d3d66d2fab0578528efd9598d22d7" translate="yes" xml:space="preserve">
          <source>If that invocation returns normally (such call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">해당 호출이 복귀 일반적으로 (콜 경우 &lt;code&gt;call_once&lt;/code&gt; 가 로 알려져있다</target>
        </trans-unit>
        <trans-unit id="d62acf7636b44fe974a0dd1f118413c4d750777d" translate="yes" xml:space="preserve">
          <source>If that invocation throws an exception, it is propagated to the caller of &lt;code&gt;call_once&lt;/code&gt;, and the flag is not flipped so that another call will be attempted (such call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">그 호출이 예외를 던지면, 그것은 &lt;code&gt;call_once&lt;/code&gt; 의 호출자에게 전파되고, 다른 호출이 시도되도록 플래그가 뒤집 히지 않습니다 (이러한 &lt;code&gt;call_once&lt;/code&gt; 호출 은</target>
        </trans-unit>
        <trans-unit id="80a16c9b65c48e0464ea5d60a9c92f28adf5f633" translate="yes" xml:space="preserve">
          <source>If that portion of the array previously provided storage for another object, the lifetime of that object ends because its storage was reused, however the lifetime of the array itself does not end (its storage is not considered to have been reused).</source>
          <target state="translated">이전에 어레이의 해당 부분에서 다른 객체에 대한 스토리지를 제공 한 경우 해당 스토리지의 재사용으로 인해 해당 객체의 수명이 종료되지만 어레이 자체의 수명은 종료되지 않습니다 (스토리지는 재사용 된 것으로 간주되지 않음).</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="345e55abff70a548ca370acdb8ec63c08545a970" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt; component of the generic-format path contains a period (&lt;code&gt;.&lt;/code&gt;), and is not one of the special filesystem elements dot or dot-dot, then the</source>
          <target state="translated">일반 형식 경로 의 &lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt; 구성 요소에 마침표 ( &lt;code&gt;.&lt;/code&gt; ) 가 포함되어 있고 특수 파일 시스템 요소 도트 또는 도트 중 하나가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="ba0ee99ef431871bed3ba20ad26dd7f7656ca3aa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object was obtained from &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; or the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt;, the value of &lt;code&gt;tm_isdst&lt;/code&gt; is indeterminate, and needs to be set explicitly before calling &lt;code&gt;mktime&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 객체로부터 얻은 &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; 또는 POSIX의 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt; 의 값 &lt;code&gt;tm_isdst&lt;/code&gt; 은 부정하고, 요구는 호출하기 전에 명시 적으로 설정해야 &lt;code&gt;mktime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78ffd5bdb618a15dacdd93c1f4888f75a24f4a33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; type defines a class-level replacement, it will be used, otherwise global &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 유형이 클래스 수준 대체를 정의 하면이 유형이 사용되고 그렇지 않으면 전역 &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73ae41564f6a1c376265c280e35f0cabc8e5e1b5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; type defines a placement form of &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; that takes additional parameters, and they match an argument list where the first argument is the size requested (of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) and the rest are the coroutine function arguments, those arguments will be passed to &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; (this makes it possible to use &lt;a href=&quot;../memory/uses_allocator#Uses-allocator_construction&quot;&gt;leading-allocator-convention&lt;/a&gt; for coroutines).</source>
          <target state="translated">는 IF &lt;code&gt;Promise&lt;/code&gt; 유형의 배치 형태를 정의 &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; 추가 매개 변수를, 그들이 첫 번째 인수가 크기 (유형의 요청 인수 목록과 일치 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 코 루틴 함수 인수하고 나머지), 그 인수는 것이다 &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; 에게 전달됩니다 (이것은 코 루틴에 대해 &lt;a href=&quot;../memory/uses_allocator#Uses-allocator_construction&quot;&gt;선행 할당 자-협약&lt;/a&gt; 을 사용할 수있게합니다 ).</target>
        </trans-unit>
        <trans-unit id="478337dee1f38e04706d749bfe79388ccef331de" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;directory_iterator&lt;/code&gt; reports an error or is advanced past the last directory entry, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.</source>
          <target state="translated">는 IF &lt;code&gt;directory_iterator&lt;/code&gt; 가 오류를보고 또는 마지막 디렉토리 엔트리를지나 전진, 그것은 동일하게 기본-구성도, 반복자를 끝 반복자으로 알려져 있습니다. 두 개의 엔드 이터레이터는 항상 동일하므로 엔드 이터레이터를 역 참조하거나 증가시키는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="b8e4d93257a92c723d2b683f90d9e06102fd5b29" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;local_time&lt;/code&gt; is ambiguous, then &lt;code&gt;result == local_info::ambiguous&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that ends just after the &lt;code&gt;local_time&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is filled with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that starts just before the &lt;code&gt;local_time&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;local_time&lt;/code&gt; 모호하고 &lt;code&gt;result == local_info::ambiguous&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; 함께 충전 &lt;code&gt;std::chrono::sys_info&lt;/code&gt; 단부 바로 뒤에 있음 &lt;code&gt;local_time&lt;/code&gt; 및 &lt;code&gt;second&lt;/code&gt; 충전되는 &lt;code&gt;std::chrono::sys_info&lt;/code&gt; 시작 그 바로 전에 &lt;code&gt;local_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be3a36bf5edab54949d33d3601ee2498da9859cd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;local_time&lt;/code&gt; is nonexistent, then &lt;code&gt;result == local_info::nonexistent&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that ends just prior to the &lt;code&gt;local_time&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that begins just after the &lt;code&gt;local_time&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;local_time&lt;/code&gt; 존재하지 않는 다음 &lt;code&gt;result == local_info::nonexistent&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; 로 작성되는 &lt;code&gt;std::chrono::sys_info&lt;/code&gt; 바로 전에 끝나는 &lt;code&gt;local_time&lt;/code&gt; 및 &lt;code&gt;second&lt;/code&gt; 로 기입되어있는 &lt;code&gt;std::chrono::sys_info&lt;/code&gt; &lt;code&gt;local_time&lt;/code&gt; 직후에 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="aba2a61809646633728f0c300cb4a04fd0fdd0e8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nptr&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;enptr&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;nptr&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;endptr&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;nptr&lt;/code&gt; 가 비어 있거나 예상되는 형태가없는 (경우에는 변환이 수행되지되고 &lt;code&gt;enptr&lt;/code&gt; 이 아닌 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 가 )의 값 &lt;code&gt;nptr&lt;/code&gt; 가 가리키는 객체에 저장됩니다 &lt;code&gt;endptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdf7be468a8d6d0434b13fed187af1e31121791" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;recursive_directory_iterator&lt;/code&gt; reports an error or is advanced past the last directory entry of the top-level directory, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.</source>
          <target state="translated">는 IF &lt;code&gt;recursive_directory_iterator&lt;/code&gt; 가 오류를보고 또는 최상위 디렉토리의 마지막 디렉토리 엔트리를지나 전진, 그것은 동일하게 디폴트-구성도, 반복자를 끝 반복자으로 알려져 있습니다. 두 개의 엔드 이터레이터는 항상 동일하므로 엔드 이터레이터를 역 참조하거나 증가시키는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="5651c6461cabc5494e66b0b82def60eb3e607dc1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;std::future&lt;/code&gt; obtained from &lt;code&gt;std::async&lt;/code&gt; is not moved from or bound to a reference, the destructor of the &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; will block at the end of the full expression until the asynchronous operation completes, essentially making code such as the following synchronous:</source>
          <target state="translated">경우] &lt;code&gt;std::future&lt;/code&gt; 로부터 얻어진 &lt;code&gt;std::async&lt;/code&gt; 옮겨 또는 기준에 결합되지 않은 상기 소멸자 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 본질적으로 같은 코드를 만드는 비동기 동작이 완료 될 때까지 전체 식 끝에 차단 다음 동기 :</target>
        </trans-unit>
        <trans-unit id="f1881ec1b9072afac208ff470251f98ed10178f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;str&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;str_end&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;str&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;str_end&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;str&lt;/code&gt; 비어 있거나 예상되는 형태가없는 (경우에는 변환이 수행되지되고 &lt;code&gt;str_end&lt;/code&gt; 이 아닌 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 가 )의 값 &lt;code&gt;str&lt;/code&gt; 가리키는 객체에 저장됩니다 &lt;code&gt;str_end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e50fd41c5ef8a59127cf972f021ae16ba8532f47" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in binary mode, the new position is exactly &lt;code&gt;offset&lt;/code&gt; bytes measured from the beginning of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;, from the current file position if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt;, and from the end of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;. Binary streams are not required to support &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;, in particular if additional null bytes are output.</source>
          <target state="translated">는 IF &lt;code&gt;stream&lt;/code&gt; 바이너리 모드에서 열려, 새로운 위치는 정확히 &lt;code&gt;offset&lt;/code&gt; 경우 파일의 시작 부분에서 측정 바이트 &lt;code&gt;origin&lt;/code&gt; 이다 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; 이 경우 현재 파일 위치에서 &lt;code&gt;origin&lt;/code&gt; 이다 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt; , 파일의 끝에서 경우 &lt;code&gt;origin&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; 를 . 이진 스트림은 특히 추가 널 바이트가 출력되는 경우 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; 를 지원할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="37a2ed3c9a259690f19d7262a85bdeef29cb181d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in text mode, the only supported values for &lt;code&gt;offset&lt;/code&gt; are zero (which works with any &lt;code&gt;origin&lt;/code&gt;) and a value returned by an earlier call to &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; on a stream associated with the same file (which only works with &lt;code&gt;origin&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; 이 텍스트 모드에서 열려있는 경우 &lt;code&gt;offset&lt;/code&gt; 에 대해 지원되는 유일한 값 은 0 ( &lt;code&gt;origin&lt;/code&gt; 작동 함 )과 동일한 파일과 연관된 스트림 에서 &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; 에 대한 이전 호출에서 반환 된 값 ( &lt;code&gt;origin&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="892724969fe6221e78fcbe5fd94b682363cb5949" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is wide-oriented, the restrictions of both text and binary streams apply (result of &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; 이 넓은 경우 텍스트 스트림과 이진 스트림 모두의 제한이 적용됩니다 ( SEEK_SET 에서는 &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; 결과 가 허용되고 SEEK_END에서는 SEEK_SET 및 SEEK_CUR에서는 0 오프셋이 허용되지 않음).</target>
        </trans-unit>
        <trans-unit id="d0b614dfebe10969c88ebb875d7426f7d8ef68bd" translate="yes" xml:space="preserve">
          <source>If the OS uses a</source>
          <target state="translated">OS가</target>
        </trans-unit>
        <trans-unit id="78c8e20ea6a30edcc63fb9e62dc035eb0fe67dd3" translate="yes" xml:space="preserve">
          <source>If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;construct()&lt;/code&gt;,), then calls placement-new as.</source>
          <target state="translated">위의 방법을 사용할 수없는 경우 (예 : &lt;code&gt;a&lt;/code&gt; 멤버 함수 &lt;code&gt;construct()&lt;/code&gt; 경우) place-new as를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="08776426179650f866b4d0470c65442caf416cce" translate="yes" xml:space="preserve">
          <source>If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;max_size()&lt;/code&gt;), then returns &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max()&lt;/code&gt;(until C++17)&lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt;(since C++17).</source>
          <target state="translated">위의 방법을 사용할 수없는 경우 (예 : &lt;code&gt;a&lt;/code&gt; 에 멤버 함수 &lt;code&gt;max_size()&lt;/code&gt; 가없는 경우 ) &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max()&lt;/code&gt; (C ++ 17까지) &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt; (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="aac3be73f3bb8e2fda1848ee16dfee9b40b5d6a7" translate="yes" xml:space="preserve">
          <source>If the aggregate initialization uses copy-(until C++14)list-initialization syntax (&lt;code&gt;T a = {args..}&lt;/code&gt;or &lt;code&gt;T a {args..}&lt;/code&gt;(since C++14)), the braces around the nested initializer lists may be elided (omitted), in which case as many initializer clauses as necessary are used to initialize every member or element of the corresponding subaggregate, and the subsequent initializer clauses are used to initialize the following members of the object. However, if the object has a sub-aggregate without any members (an empty struct, or a struct holding only static members), brace elision is not allowed, and an empty nested list &lt;code&gt;{} &lt;/code&gt; must be used.</source>
          <target state="translated">집계 초기화에서 copy- (C ++ 14까지) 목록 초기화 구문 ( &lt;code&gt;T a = {args..}&lt;/code&gt; 또는 &lt;code&gt;T a {args..}&lt;/code&gt; (C ++ 14 이후))을 사용하는 경우 중첩 된 이니셜 라이저 주위에 중괄호 리스트는 생략 (생략) 될 수 있으며,이 경우 필요한 수의 이니셜 라이저 절이 해당 하위 집계의 모든 멤버 또는 요소를 초기화하는 데 사용되고 후속 이니셜 라이저 절이 오브젝트의 다음 멤버를 초기화하는 데 사용됩니다. 그러나 오브젝트에 멤버가없는 하위 집계가있는 경우 (빈 구조체 또는 정적 멤버 만 보유하는 구조체) 중괄호 제거는 허용되지 않으며 빈 중첩 목록 &lt;code&gt;{} &lt;/code&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0399c949000296ee9ae66ca9aac394f1a2f1f9c" translate="yes" xml:space="preserve">
          <source>If the aggregate that is initialized with a designated initializer clause has an anonymous union member, the corresponding designated initializer must name one of the members of that anonymous union.</source>
          <target state="translated">지정된 이니셜 라이저 절로 초기화 된 집계에 익명 공용 멤버가있는 경우 해당 지정된 이니셜 라이저가 해당 익명 공용 멤버의 이름 중 하나를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="594b9ef516bc13e866ad5205b086e5efba4a2ca2" translate="yes" xml:space="preserve">
          <source>If the algorithm fails to allocate memory, &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">알고리즘이 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1bbf4fee39cb9b1e1b2e31f5aa92d3790c46ca1d" translate="yes" xml:space="preserve">
          <source>If the algorithm fails to allocate memory, &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">알고리즘이 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c2e9382364758d1ba08276bed3a0538d258c6220" translate="yes" xml:space="preserve">
          <source>If the allocation function returns a null pointer, which is possible if the non-throwing overload was selected, e.g. with &lt;code&gt;new(&lt;a href=&quot;../memory/new/nothrow&quot;&gt;std::nothrow&lt;/a&gt;) T;&lt;/code&gt;, then the new-expression returns immediately, it does not attempt to initialize an object or to call a deallocation function. If the standard placement allocation function returns a null pointer, which is possible if the user passes a null pointer as the argument, the behavior is undefined.(since C++17).</source>
          <target state="translated">할당 함수가 널 포인터를 리턴하는 경우, 비 투척 과부하가 선택된 경우에 가능합니다 &lt;code&gt;new(&lt;a href=&quot;../memory/new/nothrow&quot;&gt;std::nothrow&lt;/a&gt;) T;&lt;/code&gt; 예 : new ( std :: nothrow ) T; 그런 다음 new-expression이 즉시 리턴되며 오브젝트를 초기화하거나 할당 해제 함수를 호출하지 않습니다. 표준 배치 할당 함수가 널 포인터를 리턴하는 경우, 사용자가 널 포인터를 인수로 전달하면 작동이 정의되지 않습니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="a90b4223ec8c5c3e6da2dcd84075a2e4a1b01cc8" translate="yes" xml:space="preserve">
          <source>If the allocator will</source>
          <target state="translated">할당자가</target>
        </trans-unit>
        <trans-unit id="61e2b91fec3faec7fc75d4eceab84254e8c8a972" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;A&lt;/code&gt; of the transformed template-1 can be used to deduce the corresponding parameter &lt;code&gt;P&lt;/code&gt; of template-2, but not vice versa, then this &lt;code&gt;A&lt;/code&gt; is more specialized than &lt;code&gt;P&lt;/code&gt; with regards to the type(s) that are deduced by this P/A pair.</source>
          <target state="translated">변환 된 template-1 의 인수 &lt;code&gt;A&lt;/code&gt; 를 사용하여 template-2 의 해당 매개 변수 &lt;code&gt;P&lt;/code&gt; 를 추론 할 수 있지만 그 반대의 경우는 그렇지 않습니다.이 경우 &lt;code&gt;A&lt;/code&gt; 에 의해 추론 된 유형과 관련하여 &lt;code&gt;P&lt;/code&gt; 보다 더 전문화 됩니다 P / A 쌍.</target>
        </trans-unit>
        <trans-unit id="2619199639dd0dfe77e10f7ea0d17382af754c82" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, &amp;plusmn;1 is returned</source>
          <target state="translated">인수가 &amp;plusmn; &amp;infin;이면 &amp;plusmn; 1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a9eeedbf12ee3261a62193ec2f7bf409d740fd6e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">인수가 &amp;plusmn; &amp;infin;이면 + &amp;infin;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bc0e32230b86eab8904c3236eac37ff6f8e3e5b9" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">인수가 &amp;plusmn; &amp;infin;이면 + &amp;infin;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="70915638207ef43ec09152008a5ac4da1c3e101e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 &amp;plusmn; &amp;infin;이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bcd3cf56514ebcbadf81a91fe745d514dda05b5" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;0 is returned</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 &amp;plusmn; 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="79c9397babcc1b0c97ddd36d4f6dacccb4dbab7b" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 + &amp;infin;이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="97d561db29f01535350a0e816707f41c9ebbceeb" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +0 is returned</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 +0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6f44ff73ce4a7042130e83bc24af8060e5fe2b98" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 -&amp;infin;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="310b79d192c0fa5a1ce6ca3877e2deb499d9d5f3" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 -&amp;infin;이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e20d184a4efd311faacd5da72518930f348cac5a" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, 1 is returned</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d3f53d74b0dca3908c99b1e364989b3591808e1e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned unmodified</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 수정되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ccd73690fa7a557641f2fe90d1fb0da76c7573ad" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 수정되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="666ec3240c22502f1099c8da74484f25ff980d70" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;1, a pole error occurs.</source>
          <target state="translated">인수가 &amp;plusmn; 1이면 폴 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16671d13b546303a8dbbbb41028ae78cbf067eb9" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin; or &amp;plusmn;0, it is returned, unmodified.</source>
          <target state="translated">인수가 + &amp;infin; 또는 &amp;plusmn; 0이면 수정되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="54b0607c64e592ab2e8d7944a7583de099ef78bc" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">인수가 + &amp;infin;이면 + &amp;infin;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="aa21d5b0bb57bf219f506cda16da2521284b89b4" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">인수가 + &amp;infin;이면 + &amp;infin;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="540557a8bd62a5b0f36f5bd102aec659ebb950db" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;pi;/2 is returned</source>
          <target state="translated">인수가 + &amp;infin;이면 + &amp;pi; / 2가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7199243658fb47291089c2b185fa5cf8110be042" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +0 is returned</source>
          <target state="translated">인수가 + &amp;infin;이면 +0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f4be25ee19a8f2e9c79ffae1bfa98e41cff590c7" translate="yes" xml:space="preserve">
          <source>If the argument is +1, the value &lt;code&gt;+0&lt;/code&gt; is returned.</source>
          <target state="translated">인수가 +1이면 &lt;code&gt;+0&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="09765a27421db439d2ceef1decf36c6c5400ca31" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, +0 is returned</source>
          <target state="translated">인수가 -&amp;infin;이면 +0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ab67da2ac08a598b0aeee9a84a5ea4203889b128" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -&amp;pi;/2 is returned</source>
          <target state="translated">인수가 -&amp;infin;이면 -&amp;pi; / 2가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c52a07d7a9cd046aa4f61618e846c887cf3ca1d0" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -1 is returned</source>
          <target state="translated">인수가 -&amp;infin;이면 -1이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3cb7272c20346f5eded435e9a2ce5990a13f544b" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, 2 is returned</source>
          <target state="translated">인수가 -&amp;infin;이면 2가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7b59bb47bb4f9b237288770872fa9592f179ad22" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">인수가 -&amp;infin;이면 NaN이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2728e75a63954aabe83e882896db0bf09fd9c3f9" translate="yes" xml:space="preserve">
          <source>If the argument is -1, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">인수가 -1이면 -&amp;infin;이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dad9f0dbcbb32af831ea87c9b1abd3643a5b7b20" translate="yes" xml:space="preserve">
          <source>If the argument is 1, +0 is returned</source>
          <target state="translated">인수가 1이면 +0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="290ee1b584ad39adb2720da091bea3742f568b9f" translate="yes" xml:space="preserve">
          <source>If the argument is 2, +0 is returned</source>
          <target state="translated">인수가 2이면 +0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9f6074320a813a4e58ce3f8235a3e40354fe9d12" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned</source>
          <target state="translated">인수가 NaN이면 NaN이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ccc4c1fc3fbbb948e5c992719dc5c43cdd7d9790" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned and domain error is not reported</source>
          <target state="translated">인수가 NaN이면 NaN이 반환되고 도메인 오류가보고되지 않습니다</target>
        </trans-unit>
        <trans-unit id="663f54eba211611128011b5b2bd091f463b1a1cc" translate="yes" xml:space="preserve">
          <source>If the argument is a designated initializer list, a conversion is only possible if the parameter has an aggregate type that can be initialized from that initializer list according to the rules for &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, in which case the implicit conversion sequence is a user-defined conversion sequence whose second standard conversion sequence is an identity conversion.</source>
          <target state="translated">인수가 지정된 이니셜 라이저 목록 인 경우 매개 변수에 &lt;a href=&quot;aggregate_initialization&quot;&gt;집계 초기화&lt;/a&gt; 규칙에 따라 해당 이니셜 라이저 목록에서 초기화 할 수있는 집계 유형이있는 경우에만 변환이 가능합니다. 이 경우 내재적 변환 순서는 사용자 정의 변환입니다. 두 번째 표준 변환 시퀀스가 ​​ID 변환 인 시퀀스.</target>
        </trans-unit>
        <trans-unit id="f630be49c2abd923603f430a83802a576f8d8a5b" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">인수가 음의 정수이면 + &amp;infin;이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d3cb5a23f7100fda931d00bdcf1949dd71d061ad" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">인수가 음의 정수이면 NaN이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="20646ae3669e13c85917f45de5026134f970fd91" translate="yes" xml:space="preserve">
          <source>If the argument is less than -0, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and NaN is returned.</source>
          <target state="translated">인수가 -0보다 작은 경우 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생하고 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d60f1479d7ad633bb20dc263baae8366ce50fe47" translate="yes" xml:space="preserve">
          <source>If the argument is less than -1, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">인수가 -1보다 작은 경우 NaN이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="82e61b5e3d8efb3126389ca46e457ed7c53253b6" translate="yes" xml:space="preserve">
          <source>If the argument is less than 1, a domain error occurs.</source>
          <target state="translated">인수가 1보다 작은 경우 도메인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8ca2273cafe3374e2295b541c384fca2773d84f3" translate="yes" xml:space="preserve">
          <source>If the argument is negative, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">인수가 음수이면 NaN이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0ce877c1c558f9ec930d2aac72c101f35a2f7812" translate="yes" xml:space="preserve">
          <source>If the argument is not on the interval [-1, +1], a range error occurs.</source>
          <target state="translated">인수가 구간 [-1, +1]에 없으면 범위 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a3c3924a950cbead03e34404522a3031242c5c81" translate="yes" xml:space="preserve">
          <source>If the arguments are temporaries, &lt;code&gt;forward_as_tuple&lt;/code&gt; does not extend their lifetime; they have to be used before the end of the full expression.</source>
          <target state="translated">인수가 임시 인 경우 &lt;code&gt;forward_as_tuple&lt;/code&gt; 은 수명을 연장하지 않습니다. 그것들은 완전한 표현이 끝나기 전에 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2199aba2bc9bf0df1d73b9c3777d78213c53216a" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that &lt;code&gt;comp&lt;/code&gt; would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.</source>
          <target state="translated">어레이는 여러 요소가 포함되어 있으면 &lt;code&gt;comp&lt;/code&gt; 소자 같음 검색으로 나타내는 것을, 다음 함수가 결과로서 반환하는 요소 지정한다.</target>
        </trans-unit>
        <trans-unit id="f51494a87d2300af12e0330eba96c74b86cb7986" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open() == false&lt;/code&gt;), returns &lt;code&gt;Traits::eof()&lt;/code&gt; before doing anything.</source>
          <target state="translated">연결된 파일이 열려 있지 않으면 ( &lt;code&gt;is_open() == false&lt;/code&gt; ), 작업을 수행하기 전에 &lt;code&gt;Traits::eof()&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b7bafed16d966c0cf1207175d019010ae108d6c1" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;), fails immediately.</source>
          <target state="translated">연관된 파일이 열려 있지 않으면 ( &lt;code&gt;is_open()==false&lt;/code&gt; ) 즉시 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ae52be96052bf801f3b8098ab2013b04fe3a4a04" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;, fails immediately.</source>
          <target state="translated">연관된 파일이 열려 있지 않으면 ( &lt;code&gt;is_open()==false&lt;/code&gt; 즉시 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7cac4bee56cffefb9d5f96aafb66ad2424beb17d" translate="yes" xml:space="preserve">
          <source>If the associated file was already open, returns a null pointer right away.</source>
          <target state="translated">연결된 파일이 이미 열려 있으면 즉시 널 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="707b71cd5415cf8d8476c290727e5a9c8c18e35f" translate="yes" xml:space="preserve">
          <source>If the associated mutex is already locked by this &lt;code&gt;shared_lock&lt;/code&gt; (that is, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">연관된 뮤텍스가이 &lt;code&gt;shared_lock&lt;/code&gt; 에 의해 이미 잠긴 경우 (즉, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 리턴 함 ), 오류 코드 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8b1ad230edb75da7998e440c34314fa12ebb13f" translate="yes" xml:space="preserve">
          <source>If the body of a lambda &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-uses&lt;/a&gt; an entity captured by copy, the member of the closure type is accessed. If it is not odr-using the entity, the access is to the original object:</source>
          <target state="translated">람다 본문이 사본으로 캡처 된 엔티티를 &lt;a href=&quot;definition#ODR-use&quot;&gt;사용&lt;/a&gt; 하는 경우 클로저 유형의 멤버에 액세스합니다. 엔티티를 odr 사용하지 않는 경우 원래 오브젝트에 대한 액세스 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="efb071bf7d785901c94b7543fe7ce5432fcfa86c" translate="yes" xml:space="preserve">
          <source>If the braced-init-list is empty and &lt;code&gt;T&lt;/code&gt; is a class type with a default constructor, &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt; is performed.</source>
          <target state="translated">braced-init-list가 비어 있고 &lt;code&gt;T&lt;/code&gt; 가 기본 생성자를 가진 클래스 유형 인 경우 &lt;a href=&quot;value_initialization&quot;&gt;값 초기화&lt;/a&gt; 가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1719a9715867ad8b0bc520fba8f212e17cc25ebe" translate="yes" xml:space="preserve">
          <source>If the buffer uses dynamic allocation, sets the frozen status of the stream to &lt;code&gt;freezefl&lt;/code&gt;.</source>
          <target state="translated">버퍼가 동적 할당을 사용하는 경우 스트림의 고정 상태를 &lt;code&gt;freezefl&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1b15e0ac114ac6cf1d11c46237069b5057df384" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;(pos_type)-1&lt;/code&gt;, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="translated">호출이 &lt;code&gt;(pos_type)-1&lt;/code&gt; 을 반환 하면 &lt;code&gt;setstate(failbit)&lt;/code&gt; 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="d455f5da56a971dee921cba17f2bcf47c19cb43f" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;false&lt;/code&gt;, the iterator sets &lt;code&gt;*this&lt;/code&gt; to the end-of-sequence iterator, the function returns.</source>
          <target state="translated">호출이 &lt;code&gt;false&lt;/code&gt; 를 돌려주는 경우, 이터레이터는 &lt;code&gt;*this&lt;/code&gt; 를 시퀀스 끝 의 이터레이터로 설정 하면 함수가 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="e503214a190894ba07737d97130f4f4e57a0952d" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;true&lt;/code&gt;, the function returns.</source>
          <target state="translated">호출이 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 함수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5756be4be986d9060f28be2990144a451f23bebb" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; returns &lt;code&gt;Traits::eof&lt;/code&gt;, sets the failed() flag to true.</source>
          <target state="translated">&lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; 호출이 &lt;code&gt;Traits::eof&lt;/code&gt; 리턴 하면 failed () 플래그를 true로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4aae1dcba7a08d934d0a653ad0c0ff27019c75f7" translate="yes" xml:space="preserve">
          <source>If the capture-default is &lt;code&gt;&amp;amp;&lt;/code&gt;, subsequent simple captures must not begin with &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">캡처 기본값이 &lt;code&gt;&amp;amp;&lt;/code&gt; 인 경우 후속 단순 캡처는 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 시작해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="0277bab17cc429663b1ace6d465fb1f995414d4e" translate="yes" xml:space="preserve">
          <source>If the capture-default is &lt;code&gt;=&lt;/code&gt;, subsequent simple captures must begin with &lt;code&gt;&amp;amp;&lt;/code&gt; or be &lt;code&gt;*this&lt;/code&gt;(since C++17)or &lt;code&gt;this&lt;/code&gt;(since C++20).</source>
          <target state="translated">capture-default가 &lt;code&gt;=&lt;/code&gt; 인 경우 후속 단순 캡처는 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 시작 하거나 &lt;code&gt;*this&lt;/code&gt; (C ++ 17부터) 또는 &lt;code&gt;this&lt;/code&gt; (C ++ 20부터 ) 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="de84be00a72fc5e9e1aaa148e3a8f5aade0e83e5" translate="yes" xml:space="preserve">
          <source>If the cast is successful, &lt;code&gt;dynamic_cast&lt;/code&gt; returns a value of type &lt;code&gt;new_type&lt;/code&gt;. If the cast fails and &lt;code&gt;new_type&lt;/code&gt; is a pointer type, it returns a null pointer of that type. If the cast fails and &lt;code&gt;new_type&lt;/code&gt; is a reference type, it throws an exception that matches a handler of type &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">캐스트가 성공하면 &lt;code&gt;dynamic_cast&lt;/code&gt; 는 &lt;code&gt;new_type&lt;/code&gt; 유형의 값을 리턴합니다 . 캐스트가 실패하고 &lt;code&gt;new_type&lt;/code&gt; 이 포인터 유형 인 경우 해당 유형의 널 포인터를 리턴합니다. 캐스트가 실패하고 &lt;code&gt;new_type&lt;/code&gt; 이 참조 유형 인 경우 &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt; 유형의 핸들러와 일치하는 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="8d0ba473a6711055af0221180f781e98850fbb86" translate="yes" xml:space="preserve">
          <source>If the character matches one of &lt;code&gt;&quot;0123456789abcdefxABCDEFX+-&quot;&lt;/code&gt;, widened to the locale's char_type as if by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).widen()&lt;/code&gt;, it is converted to the corresponding &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">문자가 &lt;code&gt;&quot;0123456789abcdefxABCDEFX+-&quot;&lt;/code&gt; 중 하나와 일치 하면 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).widen()&lt;/code&gt; 처럼 로케일의 char_type으로 확장 된 경우 해당하는로 변환됩니다. &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1c4cec9fd9552b11fc88dfc3cdd3888d0078a93" translate="yes" xml:space="preserve">
          <source>If the character matches the decimal point separator (&lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).decimal_point())&lt;/code&gt;), it is replaced by &lt;code&gt;'.'&lt;/code&gt;.</source>
          <target state="translated">문자가 소수점 구분 기호 ( &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).decimal_point())&lt;/code&gt; ) 와 일치하면 &lt;code&gt;'.'&lt;/code&gt; 로 바뀝니다 . .</target>
        </trans-unit>
        <trans-unit id="4175453721d5f90ed16f3adae9fd0acf7beb27c3" translate="yes" xml:space="preserve">
          <source>If the character matches the thousands separator (&lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt;) and the thousands separation is in use at all &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping().length() != 0&lt;/code&gt;, then if the decimal point &lt;code&gt;'.'&lt;/code&gt; has not yet been accumulated, the position of the character is remembered, but the character is otherwise ignored. If the decimal point has already been accumulated, the character is discarded and Stage 2 terminates.</source>
          <target state="translated">문자가 천 단위 구분 기호 ( &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt; )와 일치하고 천 단위 구분이 모든 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping().length() != 0&lt;/code&gt; 에서 사용중인 경우 numpunct &amp;lt; charT &amp;gt;&amp;gt; (str.getloc ()). grouping (). length ()! = 0 , 소수점이 &lt;code&gt;'.'&lt;/code&gt; 인 경우 아직 누적되지 않은 경우 캐릭터의 위치는 기억되지만 캐릭터는 무시됩니다. 소수점이 이미 누적 된 경우 문자가 삭제되고 2 단계가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e6c7076c1a1240513d559610a53ddb63ba3eb6f5" translate="yes" xml:space="preserve">
          <source>If the character sequence &lt;code&gt;[first, last)&lt;/code&gt; represents the name of a valid character class in the currently imbued locale (that is, the string between &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; in regular expressions), returns the implementation-defined value representing this character class. Otherwise, returns zero.</source>
          <target state="translated">문자 순서 &lt;code&gt;[first, last)&lt;/code&gt; 가 현재 삽입 된 로케일의 유효한 문자 클래스 이름 (즉, 정규식에서 &lt;code&gt;[:&lt;/code&gt; 와 &lt;code&gt;:]&lt;/code&gt; 사이의 문자열 )을 나타내는 경우이 문자 클래스를 나타내는 구현 정의 값을 리턴합니다. 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a2ef46a67a9512caa78f86cb2680b53275117ae5" translate="yes" xml:space="preserve">
          <source>If the character sequence &lt;code&gt;[first, last)&lt;/code&gt; represents the name of a valid collating element in the currently imbued locale, returns the name of that collating element. Otherwise, returns an empty string.</source>
          <target state="translated">문자 순서 &lt;code&gt;[first, last)&lt;/code&gt; 가 현재 삽입 된 로케일에서 유효한 조합 요소의 이름을 나타내는 경우 해당 조합 요소의 이름을 리턴합니다. 그렇지 않으면 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fe55081ac62dc0b587a9cbf52fa55cd3bee4000" translate="yes" xml:space="preserve">
          <source>If the closure object's &lt;code&gt;operator()&lt;/code&gt; has a non-throwing exception specification, then the pointer returned by this function has the type pointer to noexcept function.</source>
          <target state="translated">클로저 객체의 &lt;code&gt;operator()&lt;/code&gt; 예외가 아닌 예외 사양이있는 경우이 함수가 반환하는 포인터에는 noexcept 함수에 대한 포인터 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="745715b691af433f45a6d1bda05f6b64c4819109" translate="yes" xml:space="preserve">
          <source>If the compiler issues warnings on unused entities, that warning is suppressed for any entity declared maybe_unused.</source>
          <target state="translated">컴파일러가 사용하지 않는 엔터티에 대해 경고를 발행하면 maybe_unused로 선언 된 엔터티에 대해서는 해당 경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8a49a5236b04e3615bd1cc238ec4430854742fb" translate="yes" xml:space="preserve">
          <source>If the condition yields &lt;code&gt;true&lt;/code&gt; after conversion to &lt;code&gt;bool&lt;/code&gt;, statement-true is executed.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 로 변환 한 후 조건이 &lt;code&gt;true&lt;/code&gt; 이면 statement-true가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="229091fed99fdddbb18485bc60172db01d5f6825" translate="yes" xml:space="preserve">
          <source>If the conditions listed above are not met, a valid pointer to the new object may still be obtained by applying the pointer optimization barrier &lt;a href=&quot;../utility/launder&quot;&gt;&lt;code&gt;std::launder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위에 나열된 조건이 충족되지 않으면 포인터 최적화 장벽 &lt;a href=&quot;../utility/launder&quot;&gt; &lt;code&gt;std::launder&lt;/code&gt; &lt;/a&gt; 를 적용하여 새 객체에 대한 유효한 포인터를 계속 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2221877dc5bedfe8cd4e7aed36ecca467cec7440" translate="yes" xml:space="preserve">
          <source>If the constructor was inherited from multiple base class subobjects of type B, the program is ill-formed, similar to multiply-inherited non-static member functions:</source>
          <target state="translated">생성자가 B 유형의 여러 기본 클래스 하위 오브젝트에서 상속 된 경우 다중 상속 된 비 정적 멤버 함수와 유사하게 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ec7e0506f8686074df12634f2b0dcdc66508f971" translate="yes" xml:space="preserve">
          <source>If the container is empty, the returned iterator will be equal to &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">컨테이너가 비어 있으면 반환 된 반복자는 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4be0a9674e89e888ef7897d1c0bff106b4bd693d" translate="yes" xml:space="preserve">
          <source>If the conversion fails with &lt;code&gt;&lt;a href=&quot;../../locale/codecvt_base&quot;&gt;std::codecvt_base::error&lt;/a&gt;&lt;/code&gt;, returns &lt;code&gt;Traits::eof()&lt;/code&gt; without attempting any output.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../locale/codecvt_base&quot;&gt;std::codecvt_base::error&lt;/a&gt;&lt;/code&gt; 변환에 실패하면 출력을 시도하지 않고 &lt;code&gt;Traits::eof()&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="60a697aa95e320d7d6b93da3ee60c2df0a966a8e" translate="yes" xml:space="preserve">
          <source>If the conversion function fails to convert the entire field, the value &lt;code&gt;​0​&lt;/code&gt; is stored in &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">변환 함수는 전체 필드를 변환하는 데 실패하면, 값 &lt;code&gt;​0​&lt;/code&gt; 에 저장되어있는 &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4027272e7c52f77712bdb3b653471483e93cc10" translate="yes" xml:space="preserve">
          <source>If the conversion function results in a negative value too large to fit in the type of &lt;code&gt;v&lt;/code&gt;, the most negative representable value is stored in &lt;code&gt;v&lt;/code&gt;, or zero for unsigned integer types.(until C++17)</source>
          <target state="translated">변환 함수의 결과로 &lt;code&gt;v&lt;/code&gt; 유형에 맞지 않는 음수 값이 너무 큰 경우, 가장 음의 표현 가능 값은 &lt;code&gt;v&lt;/code&gt; 에 저장 되거나 부호없는 정수 유형의 경우 0이됩니다 (C ++ 17까지).</target>
        </trans-unit>
        <trans-unit id="fb166b2ef44fa2af14cb9e58cf13d66806179e94" translate="yes" xml:space="preserve">
          <source>If the conversion function results in a positive value too large to fit in the type of &lt;code&gt;v&lt;/code&gt;, the most positive representable value is stored in &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">너무 많은 양의 값으로 변환 함수 결과의 종류에 맞는 경우 &lt;code&gt;v&lt;/code&gt; , 가장 긍정적 표현할 값에 저장된 &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2eaadc84330d90ea23a53f900d957f39efcabf8" translate="yes" xml:space="preserve">
          <source>If the conversion is successful, the &lt;code&gt;time&lt;/code&gt; object is modified. All fields of &lt;code&gt;time&lt;/code&gt; are updated to fit their proper ranges. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; and &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; are recalculated using information available in other fields.</source>
          <target state="translated">변환에 성공하면 &lt;code&gt;time&lt;/code&gt; 개체가 수정됩니다. 모든 &lt;code&gt;time&lt;/code&gt; 필드가 적절한 범위에 맞게 업데이트됩니다. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; 및 &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; 는 다른 필드에서 사용 가능한 정보를 사용하여 다시 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="c8c7ea2a20a700c8ab515cd57db8ff2477c02ff7" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">변환 된 값이 해당 리턴 유형의 범위를 벗어나면 범위 오류가 발생하고 ( &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; 로 설정 ) &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6192b4cbcd6b133ff7698ce09fce768219ba252e" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate.</source>
          <target state="translated">변환 된 값이 반환 유형의 대응 범위를 벗어나게되면, 레인지 에러가 발생 (설정 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; ) 및 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;​0​&lt;/code&gt; 적절하게 복귀된다.</target>
        </trans-unit>
        <trans-unit id="fa940cdd0f1bc4912d7a80a9acf3e3f2a1974390" translate="yes" xml:space="preserve">
          <source>If the coroutine ends with an uncaught exception, it performs the following:</source>
          <target state="translated">코 루틴이 포착되지 않은 예외로 끝나면 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="12ad0f51863289a6c7c5da2f479d5e058f364975" translate="yes" xml:space="preserve">
          <source>If the coroutine is a non-static member function, such as &lt;code&gt;task&amp;lt;void&amp;gt; my_class::method1(int x) const;&lt;/code&gt;, its &lt;code&gt;Promise&lt;/code&gt; type is &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;void&amp;gt;, const my_class&amp;amp;, int&amp;gt;::promise_type&lt;/code&gt;.</source>
          <target state="translated">코 루틴이 비 정적 멤버 함수 인 경우 (예 : &lt;code&gt;task&amp;lt;void&amp;gt; my_class::method1(int x) const;&lt;/code&gt; 그 &lt;code&gt;Promise&lt;/code&gt; 유형입니다 &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;void&amp;gt;, const my_class&amp;amp;, int&amp;gt;::promise_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dc7e439c27949bc04c73f28d03c64e858d4848d" translate="yes" xml:space="preserve">
          <source>If the coroutine is defined as &lt;code&gt;task&amp;lt;float&amp;gt; foo(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt; x, bool flag);&lt;/code&gt;, then its &lt;code&gt;Promise&lt;/code&gt; type is &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;float&amp;gt;, std::string, bool&amp;gt;::promise_type&lt;/code&gt;.</source>
          <target state="translated">코 루틴이 &lt;code&gt;task&amp;lt;float&amp;gt; foo(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt; x, bool flag);&lt;/code&gt; 그런 다음 &lt;code&gt;Promise&lt;/code&gt; 유형은 &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;float&amp;gt;, std::string, bool&amp;gt;::promise_type&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8ed628c0c3ef9224600ee8ab10e072d7456f4358" translate="yes" xml:space="preserve">
          <source>If the coroutine was suspended in the co_await expression, and is later resumed, the resume point is immediately before the call to &lt;code&gt;awaiter.await_resume()&lt;/code&gt;.</source>
          <target state="translated">코 루틴이 co_await 표현식에서 일시 중단되고 나중에 재개되는 경우 재개 지점은 &lt;code&gt;awaiter.await_resume()&lt;/code&gt; 대한 호출 직전에 있습니다.</target>
        </trans-unit>
        <trans-unit id="779db0a2dceed4ce10fd8dad1f3fd5a2aa365ff9" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">정확한 결과가보다 크면 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 또는보다 작은 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="6c1e25624b3fd048578a45e9a3c4ec61bc91d80f" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, a domain error or a range error may occur.</source>
          <target state="translated">올바른 결과가 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 보다 크 거나 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; 보다 작은 경우 도메인 오류 또는 범위 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df721ce87be91a1d2a0670fee727bda1f6488296" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, the return value is unspecified.</source>
          <target state="translated">올바른 결과가 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 보다 크 거나 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; 보다 작 으면 리턴 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e57a705dd469f19d6863e23a81d83613f10c1c86" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt;, this function rounds to even in halfway cases (like &lt;code&gt;rint&lt;/code&gt;, but unlike &lt;code&gt;round&lt;/code&gt;).</source>
          <target state="translated">현재 반올림 모드가 &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt; 이면이 함수 는 반음의 경우에도 반올림합니다 ( &lt;code&gt;rint&lt;/code&gt; 와 같지만 &lt;code&gt;round&lt;/code&gt; 와 달리 ).</target>
        </trans-unit>
        <trans-unit id="e2333eb5beb6ae4621087ed67aea4b57771b1571" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is...</source>
          <target state="translated">현재 반올림 모드가 ...</target>
        </trans-unit>
        <trans-unit id="896aca99d0b416d865962f92c6c37d2f798c20b2" translate="yes" xml:space="preserve">
          <source>If the current size is greater than &lt;code&gt;count&lt;/code&gt;, the container is reduced to its first &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">현재 크기가 &lt;code&gt;count&lt;/code&gt; 보다 큰 경우 컨테이너는 첫 번째 &lt;code&gt;count&lt;/code&gt; 요소로 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="1c6fbeaf9e8910c2d4ff6f11b1e18360cddb4c17" translate="yes" xml:space="preserve">
          <source>If the current size is greater than &lt;code&gt;count&lt;/code&gt;, the string is reduced to its first &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">현재 크기가 &lt;code&gt;count&lt;/code&gt; 보다 큰 경우 문자열은 첫 번째 &lt;code&gt;count&lt;/code&gt; 요소로 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="8f352e4005a3a9b34a2f768d15d84aa23ea90cd3" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;,</source>
          <target state="translated">현재의 사이즈보다 작은 경우 &lt;code&gt;count&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6f72d059786307ab4c08950a1fc590bdfbacc9a7" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;, additional characters are appended.</source>
          <target state="translated">현재 크기가 &lt;code&gt;count&lt;/code&gt; 보다 작 으면 추가 문자가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c289d28a9c0b1ae0f12bb49e019b21510591df99" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;, additional elements are appended and initialized with copies of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">현재 크기가 &lt;code&gt;count&lt;/code&gt; 보다 작 으면 추가 요소가 추가되고 &lt;code&gt;value&lt;/code&gt; 사본으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="442e11214c1977140f19902972be104365029434" translate="yes" xml:space="preserve">
          <source>If the deallocation functions that were found are class-specific, size-unaware class-specific deallocation function (without a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) is preferred over size-aware class-specific deallocation function (with a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">발견 된 할당 해제 함수가 클래스 별, 크기를 인식하지 않는 클래스 별 할당 해제 기능 ( &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 유형의 매개 변수 없음 )이 크기 인식 클래스 별 할당 해제 기능 ( &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 유형의 매개 변수 사용)보다 선호됩니다 . : 크기 _t )</target>
        </trans-unit>
        <trans-unit id="81a5d52aae1f78fba956c41a28dfa8ef8191aab3" translate="yes" xml:space="preserve">
          <source>If the declared return type is &lt;code&gt;auto&lt;/code&gt;, then the actual return type is &lt;a href=&quot;../utility/compare/common_comparison_category&quot;&gt;&lt;code&gt;std::common_comparison_category_t&amp;lt;Ms&amp;gt;&lt;/code&gt;&lt;/a&gt; where Ms is the list (possibly empty) of the types of base and member subobject and member array elements to be compared. This makes it easier to write cases where the return type non-trivially depends on the members, such as:</source>
          <target state="translated">선언 된 리턴 유형이 &lt;code&gt;auto&lt;/code&gt; 인 경우 실제 리턴 유형은 &lt;a href=&quot;../utility/compare/common_comparison_category&quot;&gt; &lt;code&gt;std::common_comparison_category_t&amp;lt;Ms&amp;gt;&lt;/code&gt; &lt;/a&gt; 여기서 Ms는 비교할 기본 및 멤버 서브 오브젝트 및 멤버 배열 요소 유형의 목록 (비어있을 수 있음)입니다. 이렇게하면 반환 유형이 사소하게 멤버에 따라 달라지는 경우를보다 쉽게 ​​작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a11e45a27e5f79c83df818f9c033db03c1a75a8a" translate="yes" xml:space="preserve">
          <source>If the default is specified for a template parameter of a primary class template , primary variable template, (since C++14)or alias template, each subsequent template parameter must have a default argument, except the very last one may be a template parameter pack. In a function template, there are no restrictions on the parameters that follow a default, and a parameter pack may be followed by more type parameters only if they have defaults or can be deduced from the function arguments.</source>
          <target state="translated">기본 클래스 템플리트, 기본 변수 템플리트 (C ++ 14 이후) 또는 별명 템플리트의 템플리트 매개 변수에 기본값이 지정된 경우, 이후의 각 템플리트 매개 변수에는 기본 인수가 있어야합니다 (마지막 매개 변수는 템플리트 매개 변수 일 수 있음) 팩. 함수 템플릿에는 기본값을 따르는 매개 변수에 대한 제한이 없으며 매개 변수 팩에는 기본값이 있거나 함수 인수에서 추론 할 수있는 경우에만 더 많은 유형 매개 변수가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15dd06f6865462c19c491fa71c0e722074bd75af" translate="yes" xml:space="preserve">
          <source>If the definition of any object results in an object of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt; or &lt;a href=&quot;abstract_class&quot;&gt;abstract class type&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">객체 정의로 인해 &lt;a href=&quot;incomplete_type&quot;&gt;불완전한 유형&lt;/a&gt; 또는 &lt;a href=&quot;abstract_class&quot;&gt;추상 클래스 유형&lt;/a&gt; 의 객체가 생성 되면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6627083d86de96fac39a9639172b8e5cae7776e7" translate="yes" xml:space="preserve">
          <source>If the destination type is &lt;code&gt;bool&lt;/code&gt;, this is a boolean conversion (see below).</source>
          <target state="translated">대상 유형이 &lt;code&gt;bool&lt;/code&gt; 인 경우 부울 변환입니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="bcab72b198f459511f9abd66295e0e372205290d" translate="yes" xml:space="preserve">
          <source>If the destination type is signed, the value does not change if the source integer can be represented in the destination type. Otherwise the result is implementation-defined(until C++20)the unique value of the destination type equal to the source value modulo 2n</source>
          <target state="translated">대상 유형이 서명 된 경우, 소스 정수가 대상 유형으로 표시 될 수 있으면 값이 변경되지 않습니다. 그렇지 않으면 결과는 구현 정의 (C ++ 20까지) 대상 유형의 고유 값이 소스 값 모듈로 2n과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="926b449ff74682e6ecadc43082826a46200dfffc" translate="yes" xml:space="preserve">
          <source>If the destination type is unsigned, the resulting value is the smallest unsigned value equal to the source value &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt; modulo&lt;/a&gt; 2n</source>
          <target state="translated">대상 유형이 부호없는 경우 결과 값은 소스 값 &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;모듈로&lt;/a&gt; 2n 과 같은 가장 작은 부호없는 값입니다.</target>
        </trans-unit>
        <trans-unit id="4a5a2a7675f65b9135eddde36e34f905978fe4fb" translate="yes" xml:space="preserve">
          <source>If the directory structure contains cycles, the end iterator may be unreachable.</source>
          <target state="translated">디렉토리 구조에주기가 포함 된 경우 종료 반복기에 도달 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3337548ef4310df502c47a0607ce0d45303b5ba5" translate="yes" xml:space="preserve">
          <source>If the elements in the two ranges are equal, returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">두 범위의 요소가 같으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="1870c25fe91ccb4fdf9e04186e90172ccaa106e8" translate="yes" xml:space="preserve">
          <source>If the else part of the if statement is present and condition yields &lt;code&gt;false&lt;/code&gt; after conversion to &lt;code&gt;bool&lt;/code&gt;, statement-false is executed.</source>
          <target state="translated">if 문의 else 부분이 있고 &lt;code&gt;bool&lt;/code&gt; 로 변환 한 후 condition이 &lt;code&gt;false&lt;/code&gt; 를 생성하면 statement-false가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f2f9989909780caf1535a25076ad27e3ad5b20b0" translate="yes" xml:space="preserve">
          <source>If the enclosing class declaration is, in turn, a class template, when a member template is defined outside of the class body, it takes two sets of template parameters: one for the enclosing class, and another one for itself:</source>
          <target state="translated">엔 클로징 클래스 선언이 클래스 템플릿 인 경우 멤버 템플릿이 클래스 본문 외부에 정의 된 경우 두 개의 템플릿 매개 변수 집합이 있습니다. 하나는 엔 클로징 클래스 용이고 다른 하나는 자체입니다.</target>
        </trans-unit>
        <trans-unit id="fa860288a207ce4de20ba1818eb37f1d240c59f9" translate="yes" xml:space="preserve">
          <source>If the encoding is state-dependent (&lt;code&gt;encoding() == -1&lt;/code&gt;), then more than &lt;code&gt;max_length()&lt;/code&gt; external characters may be consumed to produce one internal character.</source>
          <target state="translated">인코딩이 상태에 의존하는 경우 ( &lt;code&gt;encoding() == -1&lt;/code&gt; ), &lt;code&gt;max_length()&lt;/code&gt; 보다 많은 외부 문자를 사용하여 하나의 내부 문자를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c81f2ab01c02567fbf73ffd81b990b4f235586" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid date is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">유효한 날짜를 읽기 전에 종료 반복기에 도달하면이 함수는 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;err&lt;/code&gt; 로 설정 합니다. 구문 분석 오류가 발생하면이 함수는 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;err&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="8aae18db76ff682a209b370fc6276ae620d78597" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid month name is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">유효한 월 이름을 읽기 전에 종료 반복기에 도달하면 함수는 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt; 를 설정 합니다. 구문 분석 오류가 발생하면이 함수는 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;err&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="eed2547c74a6a3a462c75d24c54d56132c1d3935" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid value is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">유효한 값을 읽기 전에 종료 반복기에 도달하면이 함수는 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;err&lt;/code&gt; 로 설정 합니다. 구문 분석 오류가 발생하면이 함수는 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;err&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="9920cfb6a997d965d21f9be654bb51f5b8757867" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid weekday name is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">유효한 요일 이름을 읽기 전에 종료 반복기에 도달하면이 함수는 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;err&lt;/code&gt; 로 설정 합니다. 구문 분석 오류가 발생하면이 함수는 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;err&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="56f8aef93d36921723ad214ce365f4585fbe9195" translate="yes" xml:space="preserve">
          <source>If the entity named by the (unqualified) identifier is a local entity, and would result in an intervening &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; capturing it by copy if it were named outside of an unevaluated operand in the declarative region in which the identifier appears, then the type of the expression is the type of a &lt;a href=&quot;operator_member_access&quot;&gt;class member access expression&lt;/a&gt; naming the non-static data member that would be declared for such a capture in the closure object of the innermost such intervening lambda expression.</source>
          <target state="translated">(제한되지 않은) 식별자로 명명 된 엔티티가 로컬 엔티티이고 식별자가 나타나는 선언적 영역에서 평가되지 않은 피연산자 외부에서 명명 된 경우 복사하여 &lt;a href=&quot;lambda&quot;&gt;람다 식&lt;/a&gt; 을 복사하여 결과를 캡처하는 경우 표현식은 가장 중간에있는 람다 표현식의 클로저 오브젝트에서 캡처에 대해 선언 될 비 정적 데이터 멤버를 명명 하는 &lt;a href=&quot;operator_member_access&quot;&gt;클래스 멤버 액세스 표현식&lt;/a&gt; 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="dfdabf4aff6dc82f3c877f50307cf3a860280ed1" translate="yes" xml:space="preserve">
          <source>If the entity named is a &lt;a href=&quot;template_parameters#Non-type_template_parameter&quot;&gt;template parameter object&lt;/a&gt; for a template parameter of type &lt;code&gt;T&lt;/code&gt;, the type of the expression is &lt;code&gt;const T&lt;/code&gt;.</source>
          <target state="translated">이름이 지정된 엔티티가 유형 &lt;code&gt;T&lt;/code&gt; 의 템플리트 매개 변수에 대한 &lt;a href=&quot;template_parameters#Non-type_template_parameter&quot;&gt;템플리트 매개 변수 오브젝트&lt;/a&gt; 인 경우 표현식의 유형은 &lt;code&gt;const T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d94c16d2093f565827acd0baa83270e850862eaa" translate="yes" xml:space="preserve">
          <source>If the exception is thrown from a constructor that is invoked by a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, the matching &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; is called, if available.</source>
          <target state="translated">&lt;a href=&quot;new&quot;&gt;new-expression에&lt;/a&gt; 의해 호출 된 생성자에서 예외가 발생 하면 사용 가능한 경우 일치하는 &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;할당 해제 기능&lt;/a&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7c77baa68d29932853f92768b1f24a64502a012b" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as shortcut.</source>
          <target state="translated">루프 본문 끝에서 루프 실행을 계속해야하는 경우 &lt;a href=&quot;continue&quot;&gt;continue 문&lt;/a&gt; 을 바로 가기로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8c4f280148d62bcff94e6cfcf459f791d957459" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, a &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as shortcut.</source>
          <target state="translated">루프 본문 끝에서 루프 실행을 계속해야하는 경우 &lt;a href=&quot;continue&quot;&gt;continue 문&lt;/a&gt; 을 바로 가기로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94e3914e819b4e9c6f38a7c7d3a8f66bfec35d72" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="translated">루프 실행을 어느 시점에서 종료해야하는 경우 &lt;a href=&quot;break&quot;&gt;break 문&lt;/a&gt; 을 종료 문으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd72081fe396e16bec08079f951e2582fddd18b" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, a &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="translated">루프 실행을 어느 시점에서 종료해야하는 경우 &lt;a href=&quot;break&quot;&gt;중단 명령문&lt;/a&gt; 을 중단 명령문 으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a63e54974439d0c04ddba7efece25f14eb6ccc71" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, Source&amp;gt;{}(t)&lt;/code&gt; is well-formed, returns the result of that expression.</source>
          <target state="translated">만약 식 &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, Source&amp;gt;{}(t)&lt;/code&gt; 잘 형성되어, 그 식의 결과를 반환한다.</target>
        </trans-unit>
        <trans-unit id="5c56737809ca6e1f51c00db974474519c25494a7" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;E&lt;/code&gt; has the form &lt;code&gt;PA-&amp;gt;B&lt;/code&gt; or &lt;code&gt;A.B&lt;/code&gt; (where A has class type cv T), then &lt;code&gt;B&lt;/code&gt; is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; as a member function of &lt;code&gt;T&lt;/code&gt;. The function declarations found by that lookup are the candidate functions. The argument list for the purpose of overload resolution has the implied object argument of type cv T.</source>
          <target state="translated">표현하면 &lt;code&gt;E&lt;/code&gt; 가 형태를 갖는 &lt;code&gt;PA-&amp;gt;B&lt;/code&gt; 또는 &lt;code&gt;A.B&lt;/code&gt; (A가 갖는 클래스 타입 이력서 T)를 다음 &lt;code&gt;B&lt;/code&gt; 가 되는 &lt;a href=&quot;lookup&quot;&gt;고개&lt;/a&gt; 의 멤버 함수로서 &lt;code&gt;T&lt;/code&gt; . 해당 조회에서 찾은 함수 선언은 후보 함수입니다. 과부하 해결을위한 인수 목록에는 cv T 유형의 객체 인수가 내재되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a23e92522ea5793ad90d37f08a288000d14cacdf" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;E&lt;/code&gt; is a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt;, the name is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; following normal rules for function calls (which may involve &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt;). The function declarations found by this lookup are (due to the way lookup works) either:</source>
          <target state="translated">표현의 경우 &lt;code&gt;E&lt;/code&gt; 는 A는 &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;주 식&lt;/a&gt; 이름입니다 &lt;a href=&quot;lookup&quot;&gt;고개&lt;/a&gt; 함수 호출에 대한 일반 규칙 (포함 할 수있는 다음 &lt;a href=&quot;adl&quot;&gt;ADL을&lt;/a&gt; ). 이 조회에서 찾은 함수 선언은 (조회 작동 방식으로 인해) 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="69f0efd4d241778b0ab12aa15f7c0cba8b51c323" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::partial_ordering&lt;/code&gt;, returns that result.</source>
          <target state="translated">&lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; 표현식 의 형식 이 양호하고 결과가 &lt;code&gt;std::partial_ordering&lt;/code&gt; 변환 가능한 경우 해당 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a3ce312862a56044d6ce5fd6d18b3cc810505779" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::strong_equality&lt;/code&gt;, returns that result.</source>
          <target state="translated">&lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; 표현식 의 형식 이 양호하고 결과가 &lt;code&gt;std::strong_equality&lt;/code&gt; 로 변환 가능한 경우 해당 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2791850e6413d1fb089fa268221ec13c44284426" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::weak_equality&lt;/code&gt;, returns that result.</source>
          <target state="translated">&lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; 표현식 의 형식 이 양호하고 결과가 &lt;code&gt;std::weak_equality&lt;/code&gt; 로 변환 가능한 경우 해당 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6562c1886aa8be17523dc870268a8b013d14d9d0" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::weak_ordering&lt;/code&gt;, returns that result.</source>
          <target state="translated">&lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; 표현식 의 형식 이 양호하고 결과가 &lt;code&gt;std::weak_ordering&lt;/code&gt; 변환 가능한 경우 해당 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="82d3a34faff20e40c4069465ee795568784e5d84" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed, returns its result</source>
          <target state="translated">표현식 &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; 이 올바른 경우 결과를 리턴합니다</target>
        </trans-unit>
        <trans-unit id="a8ccf3f902bab3475c2f0d81bd04eb2a781e9731" translate="yes" xml:space="preserve">
          <source>If the expression above is a prvalue, the awaiter object is a temporary &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from it. Otherwise, if the expression above is an glvalue, the awaiter object is the object to which it refers.</source>
          <target state="translated">표현은 위의 prvalue 경우, awaiter 객체는 임시가 &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;구체화&lt;/a&gt; 그것에서. 그렇지 않으면, 위의 표현식이 glvalue 인 경우 awaiter 오브젝트는 그것이 참조하는 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="84b2a486468566117d378873877349b38e54a1e0" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise.</source>
          <target state="translated">식이 0이 아닌 값으로 평가되면 제어 코드 블록이 포함되고 그렇지 않으면 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="f8f246002c66268584002c4ed48b13695ad83d46" translate="yes" xml:space="preserve">
          <source>If the expression is a non-void prvalue (after any lvalue-to-rvalue conversion that might have taken place), &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; occurs.</source>
          <target state="translated">표현식이 무효가 아닌 prvalue 인 경우 (임의의 lvalue에서 rvalue로 변환 후) &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;임시 materialization&lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7329a5c8ff286b9d0a4e59efe0069989f5cd5e91" translate="yes" xml:space="preserve">
          <source>If the expression used as init or as pack has an operator with precedence below cast at the top level, it can be parenthesized:</source>
          <target state="translated">init 또는 pack으로 사용 된 표현식에 최상위 레벨에서 캐스트보다 우선 순위가 낮은 연산자가 있으면 괄호로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2b1b61632e47d98b991cfabb43ddaa1fc1c9b3b" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end of file condition, additionally sets the</source>
          <target state="translated">파일 종료 조건으로 인해 실패한 경우 추가로</target>
        </trans-unit>
        <trans-unit id="90c9cca36bdb9f6f7d9748c18430b538e7979538" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end-of-file condition, additionally sets the</source>
          <target state="translated">파일 끝 조건으로 인해 오류가 발생한 경우 추가로</target>
        </trans-unit>
        <trans-unit id="994d9bf8337b9cacbb5385430d81add1cb5bd997" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by some other error, sets the</source>
          <target state="translated">다른 오류로 인해 오류가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="40e036169518dee5621368e67a2b9be1ab5fb193" translate="yes" xml:space="preserve">
          <source>If the file is currently open by the current or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name, although the file system space is not reclaimed even if this was the last hardlink to the file until the last running process closes the file, Windows does not allow the file to be deleted).</source>
          <target state="translated">현재 또는 다른 프로세스에 의해 파일이 현재 열려있는 경우,이 기능의 동작은 구현에 따라 정의됩니다 (특히 POSIX 시스템은 파일 이름을 링크 해제합니다. 파일은 마지막으로 실행중인 프로세스가 파일을 닫을 때까지 파일을 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8a3927438032bc9c246a1d6cab93f5a9e333a4a" translate="yes" xml:space="preserve">
          <source>If the file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;, this function returns &lt;code&gt;Traits::eof()&lt;/code&gt; immediately.</source>
          <target state="translated">파일이 열려 있지 않으면 ( &lt;code&gt;is_open()==false&lt;/code&gt; )이 함수는 &lt;code&gt;Traits::eof()&lt;/code&gt; 즉시 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a0aabb532f13e04a1724903ba0225e1eed159600" translate="yes" xml:space="preserve">
          <source>If the file is open for reading, updates the get area if necessary.</source>
          <target state="translated">파일이 읽기 위해 열려 있으면 필요한 경우 가져 오기 영역을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="b7298526d7f2b5594b5589a131851e279edeaa84" translate="yes" xml:space="preserve">
          <source>If the file is open for writing, first writes the put area and any unshift sequences required by the currently imbued locale, using &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일이 쓰기 위해 열려있는 경우 먼저 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 사용하여 현재 임베딩 된 로케일에 필요한 풋 영역과 언 시프트 시퀀스를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="e6046f5bcc7e057f2daa45b27fc1473dbcccb2e9" translate="yes" xml:space="preserve">
          <source>If the file size is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::file_size(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::file_size(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">파일 크기가이 &lt;code&gt;directory_entry&lt;/code&gt; 에 캐시되면 캐시 된 값을 반환합니다. 그렇지 않으면 &lt;code&gt;std::filesystem::file_size(path())&lt;/code&gt; 또는 &lt;code&gt;std::filesystem::file_size(path(), ec)&lt;/code&gt; 를 각각 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fc2139afc05136a3d64cc794796b08e516434f34" translate="yes" xml:space="preserve">
          <source>If the filename is one of the special filesystem components dot or dot-dot, or if it has no periods, the function returns the entire &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">filename이 특수 파일 시스템 구성 요소 도트 또는 도트 중 하나이거나 마침표가없는 경우 함수는 전체 &lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="06579240cba49b57e27dc71348315d2cf9aab0ac" translate="yes" xml:space="preserve">
          <source>If the final overrider of a &lt;code&gt;transaction_safe_dynamic&lt;/code&gt; function is not declared &lt;code&gt;transaction_safe&lt;/code&gt;, calling it in an atomic block is undefined behavior.</source>
          <target state="translated">(A)의 경우, 최종 overrider &lt;code&gt;transaction_safe_dynamic&lt;/code&gt; 함수가 선언되지 &lt;code&gt;transaction_safe&lt;/code&gt; 를 , 원자 블록을 호출하면 정의되지 않은 동작이다.</target>
        </trans-unit>
        <trans-unit id="7d41e6a07f9e559a56f8b06959d59178f0f1531d" translate="yes" xml:space="preserve">
          <source>If the first character in the filename is a period, that period is ignored (a filename like &quot;.profile&quot; is not treated as an extension).</source>
          <target state="translated">파일 이름의 첫 문자가 마침표 인 경우 해당 마침표는 무시됩니다 ( &quot;.profile&quot;과 같은 파일 이름은 확장명으로 처리되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="6020291574132d5834e014d6c7f58d404fb0a67b" translate="yes" xml:space="preserve">
          <source>If the first character of the set is &lt;code&gt;^&lt;/code&gt;, then all characters not in the set are matched. If the set begins with &lt;code&gt;]&lt;/code&gt; or &lt;code&gt;^]&lt;/code&gt; then the &lt;code&gt;]&lt;/code&gt; character is also included into the set. It is implementation-defined whether the character &lt;code&gt;-&lt;/code&gt; in the non-initial position in the scanset may be indicating a range, as in &lt;code&gt;[0-9]&lt;/code&gt;. If width specifier is used, matches only up to</source>
          <target state="translated">세트의 첫 번째 문자가 &lt;code&gt;^&lt;/code&gt; 인 경우 세트에없는 모든 문자가 일치합니다. 세트가 &lt;code&gt;]&lt;/code&gt; 또는 &lt;code&gt;^]&lt;/code&gt; 로 시작 하면 &lt;code&gt;]&lt;/code&gt; 문자도 세트에 포함됩니다. 이 구현 정의 문자 여부 &lt;code&gt;-&lt;/code&gt; scanset의 비는 초기 위치에서와 같이 범위가 표시 될 수있다 &lt;code&gt;[0-9]&lt;/code&gt; . 너비 지정자를 사용하는 경우 최대</target>
        </trans-unit>
        <trans-unit id="87a6fda77086306a8c7bdf456c9e29f296b5945d" translate="yes" xml:space="preserve">
          <source>If the first character of the string returned by &lt;code&gt;mp.positive_sign()&lt;/code&gt; or &lt;code&gt;mp.negative_sign()&lt;/code&gt; is found in the &lt;code&gt;money_base::sign&lt;/code&gt; position of the formatting pattern, it is consumed, and the rest of the characters in that string are expected and consumed after all other components of the monetary value. If both &lt;code&gt;mp.positive_sign()&lt;/code&gt; and &lt;code&gt;mp.negative_sign()&lt;/code&gt; are non-empty, the sign is required and must match the first character of one of these strings. If one of theses strings is empty, the sign is optional (and if it is absent, the sign of the result corresponds to the string that was empty). If both strings are empty, or have the same first character, the result is given the positive sign. If the output parameter is a string (&lt;code&gt;digits&lt;/code&gt;) and the result is negative, the value &lt;code&gt;ct.widen('-')&lt;/code&gt; is stored as the first character of the result.</source>
          <target state="translated">&lt;code&gt;mp.positive_sign()&lt;/code&gt; 또는 &lt;code&gt;mp.negative_sign()&lt;/code&gt; 의해 리턴 된 문자열의 첫 번째 문자가 형식화 패턴 의 &lt;code&gt;money_base::sign&lt;/code&gt; 위치 에서 발견되면 소비되고 해당 문자열의 나머지 문자는 예상되고 화폐 가치의 다른 모든 구성 요소 이후에 소비됩니다. 양쪽 모두 &lt;code&gt;mp.positive_sign()&lt;/code&gt; 및 &lt;code&gt;mp.negative_sign()&lt;/code&gt; 비어 있지 않은 경우 부호가 필요하며이 문자열 중 하나의 첫 문자와 일치해야합니다. 이 문자열 중 하나가 비어 있으면 부호는 선택 사항입니다 (없는 경우 결과 부호는 비어있는 문자열에 해당합니다). 두 문자열이 모두 비어 있거나 동일한 첫 문자가 있으면 결과에 양수 부호가 표시됩니다. 출력 매개 변수가 문자열 ( &lt;code&gt;digits&lt;/code&gt; )이고 결과가 음수이면 값 &lt;code&gt;ct.widen('-')&lt;/code&gt; 이 결과의 첫 문자로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="6d83faa70c2aba93e1941e43de6bbfe2385cd57c" translate="yes" xml:space="preserve">
          <source>If the flag has static &lt;a href=&quot;../language/storage_duration#Storage_duration&quot;&gt;storage duration&lt;/a&gt;, this &lt;a href=&quot;../language/initialization#Static_initialization&quot;&gt;initialization is static&lt;/a&gt;.</source>
          <target state="translated">플래그에 정적 &lt;a href=&quot;../language/storage_duration#Storage_duration&quot;&gt;저장 기간&lt;/a&gt; 이 있으면이 &lt;a href=&quot;../language/initialization#Static_initialization&quot;&gt;초기화는 정적&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0aca185ec9eaa4817332d6d1708fa168e08a203c" translate="yes" xml:space="preserve">
          <source>If the floating literal begins with the character sequence &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the floating literal is a</source>
          <target state="translated">부동 리터럴이 문자 시퀀스 &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; 로 시작하면 부동 리터럴은</target>
        </trans-unit>
        <trans-unit id="1fc39f622f213adb1f2c8d85a8aa6d829ea3b127" translate="yes" xml:space="preserve">
          <source>If the format specifier &lt;code&gt;%Z&lt;/code&gt; is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*abbrev&lt;/code&gt; if &lt;code&gt;abbrev&lt;/code&gt; is not null. If the format specifier &lt;code&gt;%z&lt;/code&gt; or a modified variant is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*offset&lt;/code&gt; if &lt;code&gt;offset&lt;/code&gt; is not null, and the parsed offset will be subtracted from the parsed timestamp before the difference is assigned to &lt;code&gt;tp&lt;/code&gt;.</source>
          <target state="translated">형식 지정자 &lt;code&gt;%Z&lt;/code&gt; 가 사용되고 성공적으로 구문 분석 된 경우, &lt;code&gt;abbrev&lt;/code&gt; 가 널이 아닌 경우 구문 분석 된 값이 &lt;code&gt;*abbrev&lt;/code&gt; 에 지정됩니다 . 형식 지정자 &lt;code&gt;%z&lt;/code&gt; 또는 수정 된 변형이 사용되고 성공적으로 구문 분석 된 경우, &lt;code&gt;offset&lt;/code&gt; 이 널이 아닌 경우 구문 분석 된 값이 &lt;code&gt;*offset&lt;/code&gt; 에 지정되고 , 차이가 &lt;code&gt;tp&lt;/code&gt; 에 지정되기 전에 구문 분석 된 시간 소인에서 구문 분석 된 오프셋이 빼집니다 .</target>
        </trans-unit>
        <trans-unit id="e503e2359ab45b0919fcc779613a87ba2c630429" translate="yes" xml:space="preserve">
          <source>If the format specifier &lt;code&gt;%Z&lt;/code&gt; is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*abbrev&lt;/code&gt; if &lt;code&gt;abbrev&lt;/code&gt; is not null. If the format specifier &lt;code&gt;%z&lt;/code&gt; or a modified variant is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*offset&lt;/code&gt; if &lt;code&gt;offset&lt;/code&gt; is not null.</source>
          <target state="translated">형식 지정자 &lt;code&gt;%Z&lt;/code&gt; 가 사용되고 성공적으로 구문 분석 된 경우, &lt;code&gt;abbrev&lt;/code&gt; 가 널이 아닌 경우 구문 분석 된 값이 &lt;code&gt;*abbrev&lt;/code&gt; 에 지정됩니다 . 형식 지정자 &lt;code&gt;%z&lt;/code&gt; 또는 수정 된 변형이 사용되고 성공적으로 구문 분석 된 경우, &lt;code&gt;offset&lt;/code&gt; 이 널이 아닌 경우 구문 분석 된 값이 &lt;code&gt;*offset&lt;/code&gt; 에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ce235bdf9bf338e07e75bb2fe881d619ae23200" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;Derived::f&lt;/code&gt; overrides a function &lt;code&gt;Base::f&lt;/code&gt;, their return types must either be the same or be</source>
          <target state="translated">함수 &lt;code&gt;Derived::f&lt;/code&gt; 가 함수 &lt;code&gt;Base::f&lt;/code&gt; :: f를 재정의하는 경우 반환 유형은 동일하거나 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="857c1e56c78b3e56396b067396f56e801e6dd2c3" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">특수화 &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; 의 함수 호출 연산자가 포인터를 비교하는 내장 연산자를 호출하는 경우 내장 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 가 아닌 경우에도 총계 순서가 엄격 합니다. 이 엄격한 총 순서는 &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; 및 &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; 전문화 와 일치하며 부분 순서와도 일치합니다. 해당 내장 연산자에 의해 부과됩니다.</target>
        </trans-unit>
        <trans-unit id="efb23e76ae6241c0d68a489477442012c4a6ba54" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">특수화 &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; 의 함수 호출 연산자가 포인터를 비교하는 내장 연산자를 호출하는 경우 내장 &lt;code&gt;operator&amp;gt;=&lt;/code&gt; 가 아닌 경우에도 총계가 엄격 합니다. 이 엄격한 총 순서는 &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; 및 &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; 전문화 와 일치하며 부분 순서와도 일치합니다. 해당 내장 연산자에 의해 부과됩니다.</target>
        </trans-unit>
        <trans-unit id="7d4d6d78f770aad39153c1ff4080cd8ea8e3ca96" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">특수화 &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; 의 함수 호출 연산자가 포인터를 비교하는 내장 연산자를 호출하면 내장 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 가 아닌 경우에도 엄격한 총 순서를 산출합니다 . 이 엄격한 총 순서는 &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; 및 &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; 전문화 와 일치하며 부분 순서와도 일치합니다. 해당 내장 연산자에 의해 부과됩니다.</target>
        </trans-unit>
        <trans-unit id="40559e5060a6bc4c31508f6386e2b42c2555e25e" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">특수화 &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; 의 함수 호출 연산자가 포인터를 비교하는 내장 연산자를 호출하는 경우 내장 &lt;code&gt;operator&amp;lt;=&lt;/code&gt; 가 아닌 경우에도 총계 순서가 엄격 합니다. 이 엄격한 총 순서는 &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; 및 &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; 전문화 와 일치하며 부분 순서와도 일치합니다. 해당 내장 연산자에 의해 부과됩니다.</target>
        </trans-unit>
        <trans-unit id="6d049b3d36607639d24052288370b34cd4ee531e" translate="yes" xml:space="preserve">
          <source>If the function extracts no characters (e.g. if &lt;code&gt;count &amp;lt; 1&lt;/code&gt;), &lt;code&gt;setstate(failbit)&lt;/code&gt; is executed.</source>
          <target state="translated">함수가 문자를 추출하지 않으면 (예 : &lt;code&gt;count &amp;lt; 1&lt;/code&gt; ) &lt;code&gt;setstate(failbit)&lt;/code&gt; 가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f3778a28625a42b16a2c98400bf20b26542a73dd" translate="yes" xml:space="preserve">
          <source>If the function is called when no exception is being handled, an empty &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">예외가 처리되지 않을 때 함수가 호출되면 빈 &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="251005437285fe4170728bd7ef6498ade0a544a1" translate="yes" xml:space="preserve">
          <source>If the function is overloaded, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; takes place first, and the program is only ill-formed if the deleted function was selected.</source>
          <target state="translated">기능에 과부하가 걸리면 먼저 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결&lt;/a&gt; 이 수행되고 삭제 된 기능을 선택한 경우에만 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0813887879f4315c7f626d21875c1875367fd78d" translate="yes" xml:space="preserve">
          <source>If the function name names a function template, then, first, &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; is done, and if it succeeds, it produces a single template specialization which is added to the set of overloads to consider. All functions whose associated &lt;a href=&quot;constraints&quot;&gt;constraints&lt;/a&gt; are not satisfied are dropped from the set.(since C++20) If more than one function from the set matches the target, and at least one function is non-template, the template specializations are eliminated from consideration. For any pair of non-template functions where one is &lt;a href=&quot;constraints&quot;&gt;more constrained&lt;/a&gt; than another, the less constrained function is dropped from the set(since C++20). If all remaining candidates are template specializations, &lt;a href=&quot;partial_specialization&quot;&gt;less specialized&lt;/a&gt; ones are removed if more specialized are available. If more than one candidate remains after the removals, the program is ill-formed.</source>
          <target state="translated">함수 이름이 함수 템플릿의 이름을 지정하면 먼저 &lt;a href=&quot;template_argument_deduction&quot;&gt;템플릿 인수 공제&lt;/a&gt; 가 수행되고 성공하면 단일 템플릿 전문화가 생성되어 고려해야 할 과부하 세트에 추가됩니다. 연관된 &lt;a href=&quot;constraints&quot;&gt;제한 조건&lt;/a&gt; 이 만족되지 않는 모든 함수 는 세트에서 제거됩니다. (C ++ 20부터) 세트에서 둘 이상의 함수가 대상과 일치하고 하나 이상의 함수가 템플릿이 아닌 경우 템플리트 전문화는 고려에서 제거됩니다. . 하나가 다른 것보다 &lt;a href=&quot;constraints&quot;&gt;더 제한&lt;/a&gt; 적인 비 템플릿 함수의 경우 , 덜 제한적인 함수는 세트에서 삭제됩니다 (C ++ 20 이후). 나머지 모든 응시자가 템플릿 전문화라면 &lt;a href=&quot;partial_specialization&quot;&gt;덜 전문화 된 경우&lt;/a&gt;보다 전문화 된 제품이 있으면 제거됩니다. 제거 후 둘 이상의 후보가 남아 있으면 프로그램이 잘못 형성됩니다.</target>
        </trans-unit>
        <trans-unit id="22b71c40978885e6386333f0b2f28d4de5c561ce" translate="yes" xml:space="preserve">
          <source>If the function selected by overload resolution does not exchange the values referenced by &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt;, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">과부하 해결로 선택한 기능이 &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;u&lt;/code&gt; 로 참조되는 값을 교환하지 않으면 프로그램이 잘못 형성됩니다. 진단이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93d41cd28845eed34b17adb4d10684f1b1c26d1d" translate="yes" xml:space="preserve">
          <source>If the function that called &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; has exited, the behavior is undefined (in other words, only long jumps up the call stack are allowed).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 를 호출 한 함수 가 종료 된 경우 동작이 정의되지 않습니다 (즉, 콜 스택 위로 길게 점프 만 허용됨).</target>
        </trans-unit>
        <trans-unit id="532af6d794823602f1906bb8fd26e75deeabc0c7" translate="yes" xml:space="preserve">
          <source>If the function throws an exception of the type not listed in its exception specification, the function &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; is called. The default function calls &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;, but it may be replaced by a user-provided function (via &lt;code&gt;&lt;a href=&quot;../error/exception/set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt;) which may call &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; or throw an exception. If the exception thrown from &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; is accepted by the exception specification, stack unwinding continues as usual. If it isn't, but &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; is allowed by the exception specification, &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; is thrown. Otherwise, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">함수가 예외 스펙에 나열되지 않은 유형의 예외를 처리하면 &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 함수 가 호출됩니다. 기본 함수는 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 호출 하지만 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 호출 하거나 예외를 발생 시킬 수 있는 사용자 제공 함수 ( &lt;code&gt;&lt;a href=&quot;../error/exception/set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt; 를 통해)로 대체 될 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 에서 발생한 예외가 예외 사양에서 승인되면 스택 해제가 평소처럼 계속됩니다. 그것은 아니지만, 경우 &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 예외 사양에 의해 허용되는, &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 발생합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b4bb1179760bc730c31b7e350c9e316f8b5d5256" translate="yes" xml:space="preserve">
          <source>If the function-try-block is on a delegating constructor, which called a non-delegating constructor that completed successfully, but then the body of the delegating constructor throws, the destructor of this object will be completed before any catch clauses of the function-try-block are entered.</source>
          <target state="translated">function-try-block이 성공적으로 완료된 비 위임 생성자를 호출 한 위임 생성자에 있지만 위임 생성자의 본문이 throw되면이 객체의 소멸자가 함수의 catch 절보다 먼저 완료됩니다. try-block이 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="7500ebfb29c88826fb63f492df6d76905a9569c0" translate="yes" xml:space="preserve">
          <source>If the get area is empty, calls &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; to determine the number of bytes available in the associated character sequence. In this case, the value returned is the number of bytes that can be extracted from the buffer while it's guaranteed that &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; would not return &lt;code&gt;Traits::eof&lt;/code&gt;.</source>
          <target state="translated">get 영역이 비어 있으면 &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; 를 호출 하여 연관된 문자 순서에서 사용 가능한 바이트 수를 판별하십시오. 이 경우 반환되는 값은 버퍼에서 추출 할 수있는 바이트 수이며 &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;Traits::eof&lt;/code&gt; 반환하지 않도록 합니다.</target>
        </trans-unit>
        <trans-unit id="3b3eec597fe44d789a14bb34434aa90dd5be188a" translate="yes" xml:space="preserve">
          <source>If the implementation cannot parallelize or vectorize (e.g. due to lack of resources), all standard execution policies can fall back to sequential execution.</source>
          <target state="translated">구현이 병렬화 또는 벡터화 할 수없는 경우 (예 : 자원 부족으로 인해) 모든 표준 실행 정책이 순차적 실행으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d83c11796c2c1e3f318ffcc89e81bbd5f8b11e8" translate="yes" xml:space="preserve">
          <source>If the implementation does not support floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to a positive value that is guaranteed to overflow a &lt;code&gt;float&lt;/code&gt; at compile time, and the use of this macro generates a compiler warning.</source>
          <target state="translated">구현이 부동 소수점 무한대를 지원하지 않는 경우 매크로 &lt;code&gt;INFINITY&lt;/code&gt; 는 양수 값으로 확장되어 컴파일시 &lt;code&gt;float&lt;/code&gt; 을 오버 플로우하도록 보장 하며이 매크로를 사용하면 컴파일러 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c2a825970a15face4ff4ecff0110e20adedc7e9c" translate="yes" xml:space="preserve">
          <source>If the implementation of this function requires a call to &lt;code&gt;new&lt;/code&gt; and the call fails, the returned pointer will hold a reference to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수의 구현에 &lt;code&gt;new&lt;/code&gt; 호출이 필요하고 호출이 실패하면 리턴 된 포인터는 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 인스턴스에 대한 참조를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="026f63aebd84e1c965f7e8366d68af982aae2ce8" translate="yes" xml:space="preserve">
          <source>If the implementation of this function requires copying the captured exception object and its copy constructor throws an exception, the returned pointer will hold a reference to the exception thrown. If the copy constructor of the thrown exception object also throws, the returned pointer may hold a reference to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; to break the endless loop.</source>
          <target state="translated">이 함수를 구현하려면 캡처 된 예외 객체를 복사해야하고 해당 복사 생성자가 예외를 throw하면 반환 된 포인터는 throw 된 예외에 대한 참조를 보유합니다. throw 된 예외 객체의 복사 생성자도 throw되면 반환 된 포인터는 &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 인스턴스에 대한 참조를 보유 하여 무한 루프를 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19ffe219703efe6527e00547f4a8cca5d22a9042" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),</source>
          <target state="translated">구현이 IEEE 부동 소수점 산술을 지원하는 경우 (IEC 60559)</target>
        </trans-unit>
        <trans-unit id="288c402c66673ce9a5009971c355fc8223b75acd" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;std::rint&lt;/code&gt; function:</source>
          <target state="translated">구현이 IEEE 부동 소수점 산술 (IEC 60559)을 지원하는 경우 &lt;code&gt;std::rint&lt;/code&gt; 함수의 경우 :</target>
        </trans-unit>
        <trans-unit id="0958ac9ba873e345e2bdc636b948c447e2e03547" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;std::round&lt;/code&gt; function:</source>
          <target state="translated">구현이 IEEE 부동 소수점 산술 (IEC 60559)을 지원하는 경우 &lt;code&gt;std::round&lt;/code&gt; 함수의 경우 :</target>
        </trans-unit>
        <trans-unit id="c7685e11635ec992c012cd0e03140bd9ce1479a3" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559), &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; is required to be non-zero.</source>
          <target state="translated">구현이 IEEE 부동 소수점 산술을 지원하는 경우 (IEC 60559) &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; 는 0이 아니 어야 합니다.</target>
        </trans-unit>
        <trans-unit id="452d571ea8f52d84cf9e46de2bbbf6be56c3970a" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic,</source>
          <target state="translated">구현이 IEEE 부동 소수점 산술을 지원하는 경우</target>
        </trans-unit>
        <trans-unit id="7392bc849012f8a7b52172fc01358b19f1c644b0" translate="yes" xml:space="preserve">
          <source>If the implementation supports floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to positive or unsigned infinity.</source>
          <target state="translated">구현이 부동 소수점 무한대를 지원하는 경우 매크로 &lt;code&gt;INFINITY&lt;/code&gt; 는 양수 또는 부호없는 무한대로 평가되는 &lt;code&gt;float&lt;/code&gt; 유형의 상수 표현식으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ccfe7e9c2a2ea14c1997c4a20a1b44aba2730f7" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared copy assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined copy assignment copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the operator performs member-wise copy assignment of the object's bases and non-static members, in their initialization order, using built-in assignment for the scalars and copy assignment operator for class types.</source>
          <target state="translated">내재적으로 선언 된 복사 지정 연산자가 삭제되거나 사소하지 않으면 &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used 인&lt;/a&gt; 경우 컴파일러에 의해 정의됩니다 (즉, 함수 본문이 생성 및 컴파일 됨) . 에 대한 &lt;code&gt;union&lt;/code&gt; 유형, 암시 적으로 정의 복사 할당 사본 (기준으로 객체 표현 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ). 비 유니언 클래스 유형 ( &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;struct&lt;/code&gt; )의 경우 연산자는 스칼라에 대한 기본 제공 지정 및 클래스 유형에 대한 복사 지정 연산자를 사용하여 초기화 순서에 따라 오브젝트의 기본 및 비 정적 멤버의 멤버 별 복사 지정을 수행합니다. .</target>
        </trans-unit>
        <trans-unit id="d8ae3f1b05db376bf2d23b1574a42628e3a6ef11" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared copy constructor is not deleted, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined copy constructor copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the constructor performs full member-wise copy of the object's bases and non-static members, in their initialization order, using direct initialization. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated copy constructor is &lt;code&gt;constexpr&lt;/code&gt;.(since C++11).</source>
          <target state="translated">내재적으로 선언 된 복사 생성자가 삭제되지 않은 경우 &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used 인&lt;/a&gt; 경우 컴파일러에 의해 정의됩니다 (즉, 함수 본문이 생성 및 컴파일 됨) . 에 대한 &lt;code&gt;union&lt;/code&gt; 유형, 암시 적으로 정의 된 복사 생성자 복사 (기준으로 객체 표현 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ). 비 유니언 클래스 유형 ( &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;struct&lt;/code&gt; )의 경우 생성자는 직접 초기화를 사용하여 초기화 순서에 따라 오브젝트의 기본 및 비 정적 멤버의 전체 멤버 별 사본을 수행합니다. 이것이 &lt;a href=&quot;constexpr&quot;&gt;constexpr 생성자&lt;/a&gt; 의 요구 사항을 충족시키는 경우 , 생성 된 사본 생성자는 &lt;code&gt;constexpr&lt;/code&gt; 입니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="30e62786983413b04a43c6ccf7b6769db6b9db27" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared default constructor is not defined as deleted, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;, and it has exactly the same effect as a user-defined constructor with empty body and empty initializer list. That is, it calls the default constructors of the bases and of the non-static members of this class. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated constructor is &lt;code&gt;constexpr&lt;/code&gt;.(since C++11).</source>
          <target state="translated">내재적으로 선언 된 기본 생성자가 삭제 된 것으로 정의되지 않은 경우 &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt; 인 경우 컴파일러에 의해 정의 (즉, 함수 본문이 생성 및 컴파일 됨)되며 사용자 정의 생성자와 빈 본문 및 빈 초기화 목록. 즉,이 클래스의 기본 및 비 정적 멤버의 기본 생성자를 호출합니다. 이것이 &lt;a href=&quot;constexpr&quot;&gt;constexpr 생성자&lt;/a&gt; 의 요구 사항을 충족시키는 경우 생성 된 생성자는 &lt;code&gt;constexpr&lt;/code&gt; 입니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="c350045eebab9392561937d25bdc83283a8bc2b6" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared move assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;.</source>
          <target state="translated">내재적으로 선언 된 이동 지정 연산자가 삭제되거나 사소하지 않으면 &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used 인&lt;/a&gt; 경우 컴파일러에 의해 정의됩니다 (즉, 함수 본문이 생성 및 컴파일 됨) .</target>
        </trans-unit>
        <trans-unit id="ceab06f5631ee2653c87921d9ff9e756382351b1" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared move constructor is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined move constructor copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the move constructor performs full member-wise move of the object's bases and non-static members, in their initialization order, using direct initialization with an &lt;a href=&quot;value_category#xvalue&quot;&gt;xvalue&lt;/a&gt; argument. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated move constructor is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">내재적으로 선언 된 이동 생성자가 삭제되거나 사소하지 않은 경우 &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used 인&lt;/a&gt; 경우 컴파일러에 의해 정의됩니다 (즉, 함수 본문이 생성 및 컴파일 됨) . 에 대한 &lt;code&gt;union&lt;/code&gt; 유형, 암시 적으로 정의 이동 생성자 사본 (기준으로 객체 표현 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ). 비 유니언 클래스 유형 ( &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;struct&lt;/code&gt; )의 경우 이동 생성자는 &lt;a href=&quot;value_category#xvalue&quot;&gt;xvalue&lt;/a&gt; 인수를 사용하여 직접 초기화를 사용하여 초기화 순서에 따라 객체의 기본 및 비 정적 멤버를 전체 멤버 단위로 이동합니다 . 이것이 &lt;a href=&quot;constexpr&quot;&gt;constexpr 생성자&lt;/a&gt; 요구 사항을 만족 시키면, 생성 된 이동 생성자는 &lt;code&gt;constexpr&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b006776f232a7b6fc30d9aed9df44514f27ef73" translate="yes" xml:space="preserve">
          <source>If the initialization &lt;a href=&quot;throw&quot;&gt;throws an exception&lt;/a&gt;, the variable is not considered to be initialized, and initialization will be attempted again the next time control passes through the declaration.</source>
          <target state="translated">초기화 &lt;a href=&quot;throw&quot;&gt;에서 예외가 발생&lt;/a&gt; 하면 변수가 초기화 된 것으로 간주되지 않으며 다음에 제어가 선언을 통과 할 때 초기화가 다시 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="70a7998feab60665e9807c4931559d1fd72d7fb4" translate="yes" xml:space="preserve">
          <source>If the initialization of a non-inline variable(since C++17) is deferred to happen after the first statement of main/thread function, it happens before the first &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-use&lt;/a&gt; of any variable with static/thread storage duration defined in the same translation unit as the variable to be initialized. If no variable or function is odr-used from a given translation unit, the non-local variables defined in that translation unit may never be initialized (this models the behavior of an on-demand dynamic library). However, as long as anything from a translation unit is odr-used, all non-local variables whose initialization or destruction has side effects will be initialized even if they are not used in the program.</source>
          <target state="translated">인라인이 아닌 변수 (C ++ 17부터)의 초기화가 주 / 스레드 함수의 첫 번째 명령문 이후에 발생하는 것으로 연기되면 정적 / 스레드 저장 기간이 정의 된 변수를 처음 &lt;a href=&quot;definition#ODR-use&quot;&gt;으로 사용&lt;/a&gt; 하기 전에 발생 합니다. 초기화 될 변수와 동일한 변환 단위. 지정된 변환 단위에서 변수 또는 함수를 사용하지 않으면 해당 변환 단위에 정의 된 로컬이 아닌 변수는 초기화 될 수 없습니다 (이는 주문형 동적 라이브러리의 동작을 모델링 함). 그러나 변환 단위의 항목을 사용하지 않는 한 초기화 또는 소멸에 부작용이있는 모든 비 로컬 변수는 프로그램에서 사용되지 않더라도 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="3f6bf015004432f99da972ebcadb65c84565ae76" translate="yes" xml:space="preserve">
          <source>If the initialization of a non-local variable with static or thread storage duration exits via an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">정적 또는 스레드 스토리지 기간으로 로컬이 아닌 변수의 초기화가 예외를 통해 종료되면 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1b11a1c3896d9b7ae4903a89c0351942d3a51b04" translate="yes" xml:space="preserve">
          <source>If the initialization of an inline variable is deferred, it happens before the first &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-use&lt;/a&gt; of that specific variable.</source>
          <target state="translated">인라인 변수의 초기화가 지연되면 해당 변수를 처음 &lt;a href=&quot;definition#ODR-use&quot;&gt;사용&lt;/a&gt; 하기 전에 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="126551b23f54c215a6bae6f1387512974293e25e" translate="yes" xml:space="preserve">
          <source>If the initialization recursively enters the block in which the variable is being initialized, the behavior is undefined.</source>
          <target state="translated">초기화가 변수가 초기화되는 블록에 반복적으로 들어가면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b698184c8fc9c6ca4e1b58ee7ce5abecef65b881" translate="yes" xml:space="preserve">
          <source>If the initializer (range_expression) is a braced-init-list, __range is deduced to be &lt;code&gt;std::initializer_list&amp;lt;&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">이니셜 라이저 (range_expression)가 braced-init-list 인 경우 __range는 &lt;code&gt;std::initializer_list&amp;lt;&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f9de00dbbb1064006866fc50c910f17dedcc3df" translate="yes" xml:space="preserve">
          <source>If the initializer clause is a nested braced-init-list (which is not an expression), the corresponding array element/class member/public base(since C++17) is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt; from that clause: aggregate initialization is recursive.</source>
          <target state="translated">initializer 절이 중첩 된 braced-init-list (식이 아님) 인 경우 해당 배열 요소 / 클래스 멤버 / 공개 기본 (C ++ 17부터)은 해당 절에서 &lt;a href=&quot;list_initialization&quot;&gt;목록 초기화&lt;/a&gt; 됩니다. 집계 초기화는 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="263c85b919faedf2707a9f0cb930d424e5361608" translate="yes" xml:space="preserve">
          <source>If the initializer clause is an expression, implicit conversions are allowed as per copy-initialization, except, for &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; form, narrowing conversions are prohibited(since C++11).</source>
          <target state="translated">initializer 절이 표현식 인 경우, &lt;a href=&quot;list_initialization&quot;&gt;목록 초기화&lt;/a&gt; 양식의 경우 축소 변환은 금지됩니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="9e522fac274022ad05f5205f4ec4d76c0dff7b8d" translate="yes" xml:space="preserve">
          <source>If the initializer is a braced-init-list &lt;code&gt;{&lt;/code&gt;arg1, arg2, ...&lt;code&gt;} &lt;/code&gt;, rules of &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt; are followed.</source>
          <target state="translated">이니셜 라이저가 braced-init-list &lt;code&gt;{&lt;/code&gt; arg1, arg2, ... &lt;code&gt;} &lt;/code&gt; 인 경우 &lt;a href=&quot;list_initialization&quot;&gt;목록 초기화&lt;/a&gt; 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="17a801942e1f9c93f9b22088a58723039bdb9b3e" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty and &lt;code&gt;T&lt;/code&gt; has a default constructor, phase 1 is skipped.</source>
          <target state="translated">초기화 목록이 비어 있고 &lt;code&gt;T&lt;/code&gt; 에 기본 생성자 가 있으면 1 단계를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="3e6d2d2dc08cc044669732b9dbb39c02db128762" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty, the values of &lt;a href=&quot;begin&quot;&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified, but will be identical.</source>
          <target state="translated">이니셜 라이저 목록이 비어 있으면 &lt;a href=&quot;begin&quot;&gt; &lt;code&gt;begin()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;end()&lt;/code&gt; 의 값 은 지정되지 않지만 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e4201a6a146ed0efc5a6cfe2c7d212a524559429" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty, the values of &lt;code&gt;begin()&lt;/code&gt; and &lt;a href=&quot;end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified, but will be identical.</source>
          <target state="translated">이니셜 라이저 목록이 비어 있으면 &lt;code&gt;begin()&lt;/code&gt; 및 &lt;a href=&quot;end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt; 의 값 은 지정되지 않지만 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d6346069140ef89aa4a40fbb67316690947509e3" translate="yes" xml:space="preserve">
          <source>If the input has been parsed into preprocessing tokens up to a given character, the next preprocessing token is generally taken to be the longest sequence of characters that could constitute a preprocessing token, even if that would cause subsequent analysis to fail. This is commonly known as</source>
          <target state="translated">입력이 주어진 문자까지 전처리 토큰으로 구문 분석 된 경우 다음 전처리 토큰은 일반적으로 후속 분석이 실패하더라도 전처리 토큰을 구성 할 수있는 가장 긴 문자 시퀀스로 간주됩니다. 이것은 일반적으로 알려진</target>
        </trans-unit>
        <trans-unit id="15db5ceb85ecf11c1bb40aa49fe97037e6943c70" translate="yes" xml:space="preserve">
          <source>If the input iterator &lt;code&gt;beg&lt;/code&gt; becomes equal to &lt;code&gt;end&lt;/code&gt; before the parsing was completed, sets both &lt;code&gt;failbit&lt;/code&gt; and &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If parsing fails for another reason, sets the &lt;code&gt;failbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. Either way, does not modify the output parameter ((&lt;code&gt;units&lt;/code&gt; or &lt;code&gt;digits&lt;/code&gt;) on error.</source>
          <target state="translated">구문 분석이 완료되기 전에 입력 반복기 &lt;code&gt;beg&lt;/code&gt; 가 &lt;code&gt;end&lt;/code&gt; 와 &lt;code&gt;failbit&lt;/code&gt; 및 &lt;code&gt;eofbit&lt;/code&gt; 를 &lt;code&gt;err&lt;/code&gt; 로 설정하십시오 . 다른 이유로 구문 분석이 실패하면, 실패 &lt;code&gt;failbit&lt;/code&gt; 를 &lt;code&gt;err&lt;/code&gt; 로 설정하십시오 . 어느 쪽이든, 오류시 출력 매개 변수 (( &lt;code&gt;units&lt;/code&gt; 또는 &lt;code&gt;digits&lt;/code&gt; )를 수정하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="32e7c4b65d1f3ec9ebd0ad90287093fbb310dbce" translate="yes" xml:space="preserve">
          <source>If the input sequence has a read position available (&lt;code&gt;gptr() &amp;lt; egptr()&lt;/code&gt;, returns &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt;.</source>
          <target state="translated">입력 시퀀스에 사용 가능한 읽기 위치가 있으면 ( &lt;code&gt;gptr() &amp;lt; egptr()&lt;/code&gt; , &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="45b2d15e0da710723c3cf60d16eb11250968276f" translate="yes" xml:space="preserve">
          <source>If the input sequence read position is not available, returns &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt;. Otherwise returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;.</source>
          <target state="translated">입력 시퀀스 읽기 위치를 사용할 수 &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; 반환합니다 . 그렇지 않으면 &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6f43632fd3506c566c7659b87242e4ba36c845b6" translate="yes" xml:space="preserve">
          <source>If the input sequence read position is not available, returns &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;. Otherwise returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;.</source>
          <target state="translated">입력 시퀀스 읽기 위치를 사용할 수 없으면 &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 반환합니다 . 그렇지 않으면 &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a9116078f703a37d13100bfaf8b9930ee23b4bdb" translate="yes" xml:space="preserve">
          <source>If the insertion failed because the element already exists, returns an iterator to the already existing element with the equivalent key.</source>
          <target state="translated">요소가 이미 존재하여 삽입에 실패한 경우 동등한 키를 사용하여 이미 존재하는 요소로 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a9fe612f9ce2e8b253c5cf483a66190457dfe15b" translate="yes" xml:space="preserve">
          <source>If the iterator holds a zero-length match and &lt;code&gt;start == end&lt;/code&gt;, &lt;code&gt;*this&lt;/code&gt; is set to end-of-sequence iterator and the function returns.</source>
          <target state="translated">반복자가 길이가 0 인 일치를 보유하고 &lt;code&gt;start == end&lt;/code&gt; 이면 &lt;code&gt;*this&lt;/code&gt; 시퀀스 끝 반복자로 설정되고 함수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="00ebb2aeeb1edae6ae85a26d3e1931e1626d24a9" translate="yes" xml:space="preserve">
          <source>If the lambda definition uses an explicit template parameter list, that template parameter list is used with &lt;code&gt;operator()&lt;/code&gt;. For every parameter in params whose type is specified as &lt;code&gt;auto&lt;/code&gt;, an additional invented template parameter is appended to the end of that template parameter list:</source>
          <target state="translated">람다 정의가 명시 적 템플릿 매개 변수 목록을 사용하는 경우 해당 템플릿 매개 변수 목록은 &lt;code&gt;operator()&lt;/code&gt; 와 함께 사용됩니다 . 유형이 &lt;code&gt;auto&lt;/code&gt; 로 지정된 매개 변수의 모든 매개 변수에 대해 추가로 발명 된 템플리트 매개 변수가 해당 템플리트 매개 변수 목록의 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c2e82d8a32eeab86a4c1f4f5bce0d91e5af9b994" translate="yes" xml:space="preserve">
          <source>If the lambda-expression captures anything by copy (either implicitly with capture clause &lt;code&gt;[=]&lt;/code&gt; or explicitly with a capture that does not include the character &amp;amp;, e.g. &lt;code&gt;[a, b, c]&lt;/code&gt;), the closure type includes unnamed non-static data members, declared in unspecified order, that hold copies of all entities that were so captured.</source>
          <target state="translated">lambda-expression이 복사로 항목을 캡처하는 경우 (암시 적으로 캡처 절 &lt;code&gt;[=]&lt;/code&gt; 또는 문자 &amp;amp;가 포함되지 않은 캡처 (예 : &lt;code&gt;[a, b, c]&lt;/code&gt; )로)을 지정하는 경우 클로저 유형에는 이름이 지정되지 않은 비 정적 데이터가 포함됩니다. 지정되지 않은 순서로 선언 된 멤버는 캡처 된 모든 엔티티의 사본을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="fd29e44a99211fd550448d9553f6ae1ad92b1445" translate="yes" xml:space="preserve">
          <source>If the last modification time is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::last_write_time(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::last_write_time(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">이 &lt;code&gt;directory_entry&lt;/code&gt; 에 마지막 수정 시간이 캐시 되면 캐시 된 값을 리턴합니다. 그렇지 않으면 &lt;code&gt;std::filesystem::last_write_time(path())&lt;/code&gt; 또는 &lt;code&gt;std::filesystem::last_write_time(path(), ec)&lt;/code&gt; 를 각각 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="7b9eab5ed5a441c8e5830c92fe0f6282d0707a87" translate="yes" xml:space="preserve">
          <source>If the left and the right operands identify overlapping objects, the behavior is undefined (unless the overlap is exact and the type is the same).</source>
          <target state="translated">왼쪽 피연산자와 오른쪽 피연산자가 겹치는 객체를 식별하는 경우 동작이 정의되지 않습니다 (오버랩이 정확하고 유형이 동일하지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="fa424ec54e9e85e6bf53212ac1a5db2c477f5b29" translate="yes" xml:space="preserve">
          <source>If the length specifier &lt;code&gt;l&lt;/code&gt; is not used, the conversion specifiers &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, and &lt;code&gt;[&lt;/code&gt; perform wide-to-multibyte character conversion as if by calling &lt;a href=&quot;../../string/multibyte/wcrtomb&quot;&gt;&lt;code&gt;wcrtomb()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="translated">길이 지정자 &lt;code&gt;l&lt;/code&gt; 을 사용하지 않으면 변환 지정자 &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;[&lt;/code&gt; 는 첫 번째 문자가 변환되기 전에 &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt; &lt;code&gt;mbstate_t&lt;/code&gt; &lt;/a&gt; 오브젝트를 0으로 초기화하여 &lt;a href=&quot;../../string/multibyte/wcrtomb&quot;&gt; &lt;code&gt;wcrtomb()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것처럼 와이드 바이트에서 멀티 바이트 문자로 변환을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="4854bc47bd09d34dbcbd17a9720f9b303f9e3fb1" translate="yes" xml:space="preserve">
          <source>If the literal operator is a template, it must have an empty parameter list and can have only one template parameter, which must be a non-type template parameter pack with element type &lt;code&gt;char&lt;/code&gt; (in which case it is known as a</source>
          <target state="translated">리터럴 연산자가 템플릿 인 경우 빈 매개 변수 목록이 있어야하며 템플릿 유형이 하나만있을 수 있으며 요소 유형이 &lt;code&gt;char&lt;/code&gt; 인 유형이 아닌 템플릿 매개 변수 팩이어야합니다 (이 경우</target>
        </trans-unit>
        <trans-unit id="fa1825d8cb36d3fdb7a1cdb0411663647de38a09" translate="yes" xml:space="preserve">
          <source>If the lock is &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; may provide better performance.</source>
          <target state="translated">잠금이 &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; 이 더 나은 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2072cff7e155c80603cea5b9b2279dd4d08fd38c" translate="yes" xml:space="preserve">
          <source>If the lookup of a member of current instantiation gives a different result between the point of instantiation and the point of definition, the lookup is ambiguous. Note however that when a member name is used, it is not automatically converted to a class member access expression, only explicit member access expressions indicate members of current instantiation:</source>
          <target state="translated">현재 인스턴스화 멤버를 조회하면 인스턴스화 지점과 정의 지점간에 다른 결과가 제공되는 경우, 검색이 모호합니다. 그러나 멤버 이름을 사용하는 경우 멤버 이름이 클래스 멤버 액세스 표현식으로 자동 변환되지 않으며 명시 적 멤버 액세스 표현식 만 현재 인스턴스화의 멤버를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01f377ce674649640d133ed5cc78ca704a3b02f5" translate="yes" xml:space="preserve">
          <source>If the lookup of the left hand side name comes up with a class/struct or union name, the name on the right hand side of &lt;code&gt;::&lt;/code&gt; is looked up in the scope of that class (and so may find a declaration of a member of that class or of its base), with the following exceptions.</source>
          <target state="translated">왼쪽 이름을 조회 할 때 클래스 / 구조체 또는 공용체 이름이 나오면 &lt;code&gt;::&lt;/code&gt; 오른쪽의 이름 이 해당 클래스의 범위에서 조회됩니다 (따라서 멤버의 선언을 찾을 수 있음). 다음 예외를 제외하고 해당 클래스 또는 해당 기본 클래스).</target>
        </trans-unit>
        <trans-unit id="d37b88b9ada3dd332af605d1fd3e5a8cf0eb71e3" translate="yes" xml:space="preserve">
          <source>If the lookup of the left-hand side name comes up with an &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; (either scoped or unscoped), the lookup of the right-hand side must result in an enumerator that belongs that enumeration, otherwise the program is ill-formed.</source>
          <target state="translated">왼쪽 이름의 조회에 &lt;a href=&quot;enum&quot;&gt; 열거&lt;/a&gt; (범위 또는 범위가 지정되지 않은)가 열거 되면 오른쪽을 조회하면 해당 열거에 속하는 열거자가 생성되어야합니다. 그렇지 않으면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1c84f7f76196e3d1858123032bdb6f7a708a9edc" translate="yes" xml:space="preserve">
          <source>If the main function is defined with a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;, the exceptions thrown by the destructors of static objects (which are destroyed by the implied &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;) are not caught by it.</source>
          <target state="translated">기본 함수가 &lt;a href=&quot;function-try-block&quot;&gt;function-try-block으로&lt;/a&gt; 정의 된 경우 정적 오브젝트의 소멸자에 의해 예외가 발생합니다 (암시 된 &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 의해 파괴됨) 포착되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e06f91c09b7d51a80ad502bd1ebea399586e472" translate="yes" xml:space="preserve">
          <source>If the match does not exist:</source>
          <target state="translated">일치하지 않는 경우 :</target>
        </trans-unit>
        <trans-unit id="7e82db05b3b86f89f14289a124a974cfc8812bd1" translate="yes" xml:space="preserve">
          <source>If the match exists:</source>
          <target state="translated">일치하는 경우 :</target>
        </trans-unit>
        <trans-unit id="4183569bf1256905bbaf650046e97c16dae9e0cc" translate="yes" xml:space="preserve">
          <source>If the meaning of a</source>
          <target state="translated">의 의미</target>
        </trans-unit>
        <trans-unit id="e85a366ebfca22ae74e5b65314e65c8d7039ce9f" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unary minus&lt;/a&gt; in the result type, which applies unsigned integer wraparound rules.</source>
          <target state="translated">빼기 부호가 입력 시퀀스의 일부인 경우, 자릿수 시퀀스에서 계산 된 숫자 값은 &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;단항 빼기&lt;/a&gt; 만큼 무시됩니다. 은 결과 유형의 되며 부호없는 정수 랩 어라운드 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ec415c505d275361f5e319da3ba14be0e8e4bd1" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unary minus&lt;/a&gt; in the result type.</source>
          <target state="translated">빼기 부호가 입력 시퀀스의 일부인 경우, 자릿수 시퀀스에서 계산 된 숫자 값은 &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;단항 빼기&lt;/a&gt; 만큼 무시됩니다. , 결과 .</target>
        </trans-unit>
        <trans-unit id="5755fdc9594791908fc98437469bea77cb6e1fd5" translate="yes" xml:space="preserve">
          <source>If the most recent match was not a zero-length match, the operator sets &lt;code&gt;flags&lt;/code&gt; to &lt;code&gt;flags | regex_constants::match_prev_avail&lt;/code&gt; and invokes the following:</source>
          <target state="translated">가장 최근의 일치가 길이가 0이 아닌 경우 연산자는 &lt;code&gt;flags&lt;/code&gt; 를 &lt;code&gt;flags | regex_constants::match_prev_avail&lt;/code&gt; 및 다음을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d96faf371e54d959541ad721b9a13b1a3685ad32" translate="yes" xml:space="preserve">
          <source>If the most recently called function, out of &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;seekpos()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt;, was &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, then calls &lt;code&gt;std::codecvt::unshift()&lt;/code&gt;, perhaps multiple times, to determine the unshift sequence according to the imbued locale, and writes that sequence to file with &lt;code&gt;overflow(Traits::eof())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;seekpos()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; 에서 가장 최근에 호출 된 함수 가 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 이면 &lt;code&gt;std::codecvt::unshift()&lt;/code&gt; 를 여러 번 호출 하여 imbeed 로케일에 따라 순서를 변경하지 않고 &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; 해당 순서를 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="90491130497fa2fc6497b24640b7ae73bc68aa73" translate="yes" xml:space="preserve">
          <source>If the multibyte character encoding is state-dependent (&lt;a href=&quot;../../locale/codecvt/encoding&quot;&gt;&lt;code&gt;codecvt::encoding()&lt;/code&gt;&lt;/a&gt; returned &lt;code&gt;-1&lt;/code&gt;) or variable-length (&lt;code&gt;codecvt::encoding()&lt;/code&gt; returned &lt;code&gt;​0​&lt;/code&gt;) and the offset &lt;code&gt;off&lt;/code&gt; is not &lt;code&gt;​0​&lt;/code&gt;, fails immediately: this function cannot determine the number of bytes that correspond to &lt;code&gt;off&lt;/code&gt; characters.</source>
          <target state="translated">다중 바이트 문자 인코딩 상태 의존성 (이면 &lt;a href=&quot;../../locale/codecvt/encoding&quot;&gt; &lt;code&gt;codecvt::encoding()&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;-1&lt;/code&gt; ) 또는 가변 길이 ( &lt;code&gt;codecvt::encoding()&lt;/code&gt; 반환 &lt;code&gt;​0​&lt;/code&gt; ) 및 오프셋 &lt;code&gt;off&lt;/code&gt; 아니다 &lt;code&gt;​0​&lt;/code&gt; 즉시 실패 이것은 함수는 &lt;code&gt;off&lt;/code&gt; 문자에 해당하는 바이트 수를 판별 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="312e4e4f74f5b82f6bd25b87461c9b4fbde989e6" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc16&lt;/code&gt; will write out the additional char16_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*s&lt;/code&gt; 의 멀티 바이트 문자 가 multi-char16_t 시퀀스 (예 : UTF-16의 서로 게이트 쌍)에 해당하는 경우이 함수에 대한 첫 번째 호출 후 &lt;code&gt;*ps&lt;/code&gt; 는 &lt;code&gt;mbrtoc16&lt;/code&gt; 에 대한 다음 호출 이 작성 되는 방식으로 업데이트됩니다. &lt;code&gt;*s&lt;/code&gt; 를 고려하지 않고 추가 char16_t를 출력하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcb6afe2a5acb943ad2fdd6f475921c6ce71ebf8" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next calls to &lt;code&gt;mbrtoc32&lt;/code&gt; will write out the additional char32_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*s&lt;/code&gt; 의 멀티 바이트 문자 가 multi-char32_t 시퀀스 (UTF-32에서는 불가능)에 해당하는 경우이 함수에 대한 첫 번째 호출 후 &lt;code&gt;*ps&lt;/code&gt; 는 다음 &lt;code&gt;mbrtoc32&lt;/code&gt; 호출 이 &lt;code&gt;*s&lt;/code&gt; 를 고려하지 않고 추가 char32_t .</target>
        </trans-unit>
        <trans-unit id="baf70aa7bd1cf40829d0398b1fa87e9dc92941f8" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked by this &lt;code&gt;std::unique_lock&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">뮤텍스가 이미 잠근 경우 &lt;code&gt;std::unique_lock&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 의 오류 코드와 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26a0b8cab69da9fd4564dd153dc7e72537daded3" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked by this &lt;code&gt;unique_lock&lt;/code&gt; (in other words, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; is true), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">뮤텍스가이 &lt;code&gt;unique_lock&lt;/code&gt; 에 의해 이미 잠겨있는 경우 (즉, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; 이 true 임) &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt; 오류 코드와 함께 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="554e21c6a83788b53dc332bdeec20b2bc45e361b" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">뮤텍스가 이미 잠겨 있으면 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt; 오류 코드와 함께 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5f5c7e5fb56183cbccedca22001e62c7b4f9e65" translate="yes" xml:space="preserve">
          <source>If the name appears immediately to the right of the scope resolution operator &lt;code&gt;::&lt;/code&gt; or possibly after &lt;code&gt;::&lt;/code&gt; followed by the disambiguating keyword &lt;code&gt;template&lt;/code&gt;, see.</source>
          <target state="translated">이름이 범위 해결 연산자의 오른쪽에 &lt;code&gt;::&lt;/code&gt; 또는 가능하면 &lt;code&gt;::&lt;/code&gt; 뒤에 키워드 &lt;code&gt;template&lt;/code&gt; 이 나오는 경우를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="12c49bf8d3ab86a8d2eba4533e6f3ce9e54beb97" translate="yes" xml:space="preserve">
          <source>If the name lookup does not find a previously declared type name, the elaborated-type-specifier is introduced by &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; (i.e. not by &lt;code&gt;enum&lt;/code&gt;), and class-name is an unqualified identifier, then the elaborated-type-specifier is a class declaration of the class-name.</source>
          <target state="translated">이름 조회에서 이전에 선언 된 유형 이름을 찾지 못하면 정교한 유형 지정자가 &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;union&lt;/code&gt; (즉 &lt;code&gt;enum&lt;/code&gt; 이 아닌)에 의해 도입되고 class-name이 규정되지 않은 식별자 인 경우 elaborated-type- 지정자는 class-name의 클래스 선언입니다.</target>
        </trans-unit>
        <trans-unit id="680aaf5d39f0524608d21769dd7093d5030e0ccf" translate="yes" xml:space="preserve">
          <source>If the name of the class itself appears as class-or-identifier in the member initializer list, then the list must consist of that one member initializer only; such constructor is known as the</source>
          <target state="translated">클래스 자체의 이름이 멤버 이니셜 라이저 목록에 클래스 또는 식별자로 나타나는 경우 목록은 해당 멤버 이니셜 라이저로만 구성되어야합니다. 이러한 생성자는</target>
        </trans-unit>
        <trans-unit id="b15648eb5df5f87645e8346a354b1f3da3971a94" translate="yes" xml:space="preserve">
          <source>If the name on the left of &lt;code&gt;::&lt;/code&gt; refers to a namespace or if there is nothing on the left of &lt;code&gt;::&lt;/code&gt; (in which case it refers to the global namespace), the name that appears on the right hand side of &lt;code&gt;::&lt;/code&gt; is looked up in the scope of that namespace, except that.</source>
          <target state="translated">왼쪽의에 이름이있는 경우 &lt;code&gt;::&lt;/code&gt; 네임 스페이스를 참조하거나의 왼쪽에 아무것도 존재하지 않는 경우 &lt;code&gt;::&lt;/code&gt; (이 경우는 글로벌 네임 스페이스를 참조), 이름이 오른쪽의에 표시가 있다는 &lt;code&gt;::&lt;/code&gt; 보았다된다 해당 네임 스페이스의 범위 내에서</target>
        </trans-unit>
        <trans-unit id="351414d67b6211a3be33d9c5a18059ec3fe49dc4" translate="yes" xml:space="preserve">
          <source>If the name refers to a &lt;a href=&quot;typedef&quot;&gt;typedef name&lt;/a&gt;, a &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt;, a &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;template type parameter&lt;/a&gt;, or an &lt;a href=&quot;type_alias&quot;&gt;alias template specialization&lt;/a&gt;, the program is ill-formed, otherwise the elaborated type specifier introduces the name into the declaration the same way a &lt;a href=&quot;declarations#Specifiers&quot;&gt;simple type specifier&lt;/a&gt; introduces its type-name.</source>
          <target state="translated">이름이 &lt;a href=&quot;typedef&quot;&gt;typedef name&lt;/a&gt; , &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt; , &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;template type parameter&lt;/a&gt; 또는 &lt;a href=&quot;type_alias&quot;&gt;alias template specialization&lt;/a&gt; 을 참조하면 프로그램이 잘못 작성됩니다. 그렇지 않으면 정교한 형식 지정자가 &lt;a href=&quot;declarations#Specifiers&quot;&gt;간단한 형식 지정자가&lt;/a&gt; 도입 하는 것과 같은 방식으로 선언에 이름을 소개합니다 유형 이름.</target>
        </trans-unit>
        <trans-unit id="7bf4ac13d848aeaa14204e7424d717fa7118c92d" translate="yes" xml:space="preserve">
          <source>If the names of two parameter packs appear in the same pattern, they are expanded simultaneously, and they must have the same length:</source>
          <target state="translated">두 매개 변수 팩의 이름이 동일한 패턴으로 표시되면 동시에 확장되며 길이가 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="a2b281f14bc994fec6ff8448c81b41b3e5d1e437" translate="yes" xml:space="preserve">
          <source>If the nearest enclosing function declarator is not the declarator of a function definition, its potential scope ends at the end of that function declarator.</source>
          <target state="translated">가장 가까운 둘러싸는 함수 선언자가 함수 정의의 선언자가 아닌 경우 잠재적 범위는 해당 함수 선언자의 끝에서 끝납니다.</target>
        </trans-unit>
        <trans-unit id="b5670784086b76d24bb1fae4d2445942134f26af" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated.</source>
          <target state="translated">새 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 보다 크면 모든 반복자와 참조 (과거의 반복자를 포함)가 무효화됩니다. 그렇지 않으면 과거의 이터레이터 만 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="cf94debed8cd7dc4895c7d2f2f99ed8c3d0eef6f" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</source>
          <target state="translated">새 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 보다 큰 경우 모든 반복자와 참조가 무효화됩니다. 그렇지 않으면 삽입 점 이전의 반복자와 참조 만 유효합니다. 과거의 이터레이터도 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="7ea2ea05865b3c53570d6c768a8336b0fce606d3" translate="yes" xml:space="preserve">
          <source>If the new size is bigger than the old one : all iterators are invalidated</source>
          <target state="translated">새 크기가 이전 크기보다 큰 경우 모든 반복자가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="92c6212e4fbc62d508c776cafe31778487d050cd" translate="yes" xml:space="preserve">
          <source>If the new size is smaller than the old one : only erased elements and the past-the-end iterator</source>
          <target state="translated">새로운 크기가 이전 크기보다 작은 경우 : 지워진 요소와 과거의 반복자 만</target>
        </trans-unit>
        <trans-unit id="b4edb10d6256f62d87a1b6332196a1e63e973276" translate="yes" xml:space="preserve">
          <source>If the next character begins a sequence of characters that could be the prefix and initial double quote of a &lt;a href=&quot;string_literal&quot;&gt;raw string literal&lt;/a&gt;, the next preprocessing token shall be a raw string literal. The literal consists of the shortest sequence of characters that matches the raw-string pattern.</source>
          <target state="translated">다음 문자가 &lt;a href=&quot;string_literal&quot;&gt;원시 문자열 리터럴&lt;/a&gt; 의 접두사 및 초기 큰 따옴표 일 수있는 일련의 문자를 시작하는 경우 다음 전처리 토큰은 원시 문자열 리터럴이어야합니다. 리터럴은 원시 문자열 패턴과 일치하는 가장 짧은 문자 시퀀스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d33bd7b55fb01fe98f2f3acadf5f6a08379b3852" translate="yes" xml:space="preserve">
          <source>If the next pointer for the put area (&lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::streambuf::pptr()&lt;/a&gt;&lt;/code&gt;) is a null pointer, returns zero.</source>
          <target state="translated">풋 영역에 대한 다음 포인터 ( &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::streambuf::pptr()&lt;/a&gt;&lt;/code&gt; )가 널 포인터이면 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f2a3a5f033565b87ab609d62fb110b1186e8e3e4" translate="yes" xml:space="preserve">
          <source>If the next pointer is greater than the beginning pointer in a get area, a</source>
          <target state="translated">다음 포인터가 get 영역의 시작 포인터보다 큰 경우</target>
        </trans-unit>
        <trans-unit id="c38cc8ddc7ddabb28e42f0dfb6f798c707698933" translate="yes" xml:space="preserve">
          <source>If the next pointer is less than the end pointer in the get area, a</source>
          <target state="translated">다음 포인터가 get 영역의 끝 포인터보다 작은 경우</target>
        </trans-unit>
        <trans-unit id="c4b8d1b94f24bba646631c4092b8de8ae27a04b9" translate="yes" xml:space="preserve">
          <source>If the next pointer is less than the end pointer in the put area, a</source>
          <target state="translated">다음 포인터가 풋 영역의 끝 포인터보다 작은 경우</target>
        </trans-unit>
        <trans-unit id="9a69438e54d280f6f9ab5d647f4340372fb34e64" translate="yes" xml:space="preserve">
          <source>If the next three characters are &lt;code&gt;&amp;lt;::&lt;/code&gt; and the subsequent character is neither &lt;code&gt;:&lt;/code&gt; nor &lt;code&gt;&amp;gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; is treated as a preprocessing token by itself (and not as the first character of the &lt;a href=&quot;operator_alternative&quot;&gt;alternative token&lt;/a&gt;&lt;code&gt;&amp;lt;:&lt;/code&gt;).</source>
          <target state="translated">다음 세 문자가 &lt;code&gt;&amp;lt;::&lt;/code&gt; 이고 후속 문자가 &lt;code&gt;:&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; 이 아닌 경우 &lt;code&gt;&amp;lt;&lt;/code&gt; 는 자체적으로 전처리 토큰으로 취급되며 &lt;a href=&quot;operator_alternative&quot;&gt;대체 토큰 &lt;/a&gt; &lt;code&gt;&amp;lt;:&lt;/code&gt; 의 첫 문자는 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="af14e08b4fe197ba9df3e02d9b9e83c72cf7dc83" translate="yes" xml:space="preserve">
          <source>If the number of characters generated for the specified format is less than the value returned by &lt;code&gt;str.width()&lt;/code&gt;, then copies of &lt;code&gt;fill&lt;/code&gt; are inserted to bring the total length of the output sequence to exactly &lt;code&gt;str.width()&lt;/code&gt;, as follows:</source>
          <target state="translated">지정된 형식에 대해 생성 된 문자 수가 &lt;code&gt;str.width()&lt;/code&gt; 에서 리턴 한 값보다 작은 경우 다음 과 같이 출력 사본의 전체 길이를 정확하게 &lt;code&gt;str.width()&lt;/code&gt; 로 가져 오기 &lt;code&gt;fill&lt;/code&gt; 사본 이 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0d99c831c2d187591fcd3895e3191880ca06c5c" translate="yes" xml:space="preserve">
          <source>If the number of hard links is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::hard_link_count(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::hard_link_count(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">이 &lt;code&gt;directory_entry&lt;/code&gt; 에 하드 링크 수가 캐시되어 있으면 캐시 된 값을 반환합니다. 그렇지 않으면 &lt;code&gt;std::filesystem::hard_link_count(path())&lt;/code&gt; 또는 &lt;code&gt;std::filesystem::hard_link_count(path(), ec)&lt;/code&gt; 를 각각 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b99a05a29894a68183df39a196889aa25aa975f9" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses exceeds the number of members and bases(since C++17) to initialize, the program is ill-formed.</source>
          <target state="translated">이니셜 라이저 절의 수가 초기화 할 멤버 및 기본 수 (C ++ 17부터)를 초과하면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b81ad8faee1ff23ba51f5fbba00473611ac8e7b6" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses is less than the number of members and bases(since C++17) or initializer list is completely empty, the remaining members and bases(since C++17) are initialized by their &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt;, if provided in the class definition, and otherwise(since C++14) by empty lists, in accordance with the usual &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; rules (which performs value-initialization for non-class types and non-aggregate classes with default constructors, and aggregate initialization for aggregates). If a member of a reference type is one of these remaining members, the program is ill-formed.</source>
          <target state="translated">이니셜 라이저 절의 수가 멤버 및베이스 수 (C ++ 17부터)보다 작거나 이니셜 라이저 목록이 완전히 비어있는 경우 나머지 멤버 및베이스 (C ++ 17부터)는 &lt;a href=&quot;data_members#Member_initialization&quot;&gt;기본 멤버 이니셜&lt;/a&gt; 라이저에 의해 초기화 됩니다. 클래스 정의에서 제공하고 그렇지 않으면 (C ++ 14 이후) 일반적인 &lt;a href=&quot;list_initialization&quot;&gt;목록 초기화&lt;/a&gt; 규칙 (기본 생성자가있는 비 클래스 유형 및 집계되지 않은 클래스에 대해 값 초기화를 수행하고 집계) 집계 초기화). 참조 유형의 구성원이 나머지 구성원 중 하나 인 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bb0f41458b43834e51177c5651bbd7795714a125" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses is less than the number of members or initializer list is completely empty, the remaining members are &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;. If a member of a reference type is one of these remaining members, the program is ill-formed.</source>
          <target state="translated">이니셜 라이저 절 수가 멤버 수보다 적거나 이니셜 라이저 목록이 완전히 비어 있으면 나머지 멤버는 &lt;a href=&quot;value_initialization&quot;&gt;값으로 초기화&lt;/a&gt; 됩니다. 참조 유형의 구성원이 나머지 구성원 중 하나 인 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b0ce7ffb5fd666d693981b8165606cef96184b92" translate="yes" xml:space="preserve">
          <source>If the number of variants is larger than 1, the invocation of the callable object has no complexity requirements.</source>
          <target state="translated">변형의 수가 1보다 크면 호출 가능한 객체의 호출에는 복잡성 요구 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="30a909a72a6ffc780941652c5f3605de8c85f27e" translate="yes" xml:space="preserve">
          <source>If the object being deleted has incomplete class type at the point of deletion, and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</source>
          <target state="translated">삭제되는 객체가 삭제 시점에 불완전한 클래스 유형을 가지고 있고 완전한 클래스에 사소한 소멸자 또는 할당 해제 기능이있는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94419747850ceda4ef56a69f80c16b2a13fb641e" translate="yes" xml:space="preserve">
          <source>If the object contains a value and the type &lt;code&gt;T&lt;/code&gt; is not trivially destructible (see &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible&lt;/a&gt;&lt;/code&gt;), destroys the contained value by calling its destructor, as if by &lt;code&gt;value().T::~T()&lt;/code&gt;.</source>
          <target state="translated">객체에 값이 포함되어 있고 유형 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible&lt;/a&gt;&lt;/code&gt; 파괴 가능하지 않은 경우 ( std :: is_trivially_destructible 참조 ), &lt;code&gt;value().T::~T()&lt;/code&gt; 처럼 소멸자를 호출하여 포함 된 값을 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="ec70e1f18459a8290a0f4bd35e232554ccfd607b" translate="yes" xml:space="preserve">
          <source>If the object is an array of unknown size, and the supplied brace-enclosed initializer list has &lt;code&gt;n&lt;/code&gt; clauses, the size of the array is &lt;code&gt;n&lt;/code&gt;. (Note that the object in this case cannot be a non-static data member: a member must have complete type.)</source>
          <target state="translated">객체가 알 수없는 크기의 배열이고 제공된 괄호로 묶인 초기화 목록에 &lt;code&gt;n&lt;/code&gt; 개의 절이있는 경우 배열의 크기는 &lt;code&gt;n&lt;/code&gt; 입니다. (이 경우 오브젝트는 정적이 아닌 데이터 멤버가 될 수 없습니다. 멤버는 완전한 유형이어야합니다.)</target>
        </trans-unit>
        <trans-unit id="dc925382d2c313f9d5510edd341c98dae666642c" translate="yes" xml:space="preserve">
          <source>If the object pointed to by &lt;code&gt;ptr&lt;/code&gt; is already owned, the function results in undefined behavior.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 가리키는 오브젝트 가 이미 소유 된 경우, 함수는 정의되지 않은 동작을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="6178c7826636249aa31114e15b28fd10b4ae9c38" translate="yes" xml:space="preserve">
          <source>If the object to which the glvalue refers contains an indeterminate value (such as obtained by &lt;a href=&quot;default_initialization&quot;&gt;default initializing&lt;/a&gt; a non-class automatic variable), the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;.</source>
          <target state="translated">glvalue가 참조하는 객체에 불확정 값 (예 : 비 클래스 자동 변수를 &lt;a href=&quot;default_initialization&quot;&gt;초기화&lt;/a&gt; 하여 얻은 값)이 포함 된 경우 동작은 &lt;a href=&quot;ub&quot;&gt;정의되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="854c163308d68bcd5f11e6e68fac53ee79ca0fa5" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memcpy&lt;/code&gt; is not specified and &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="translated">객체가 &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;겹칠 가능성이&lt;/a&gt; 있거나 &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 이 아닌 경우 &lt;code&gt;memcpy&lt;/code&gt; 의 동작이 지정되지 않아 &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;정의되지 않을 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43ec58c2abf0222a29b0c8fffc8a48f853af4796" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memmove&lt;/code&gt; is not specified and &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="translated">객체가 &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;겹칠 가능성이&lt;/a&gt; 있거나 &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 이 아닌 경우 &lt;code&gt;memmove&lt;/code&gt; 의 동작이 지정되지 않아 &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;정의되지 않을 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af231aef821c421dada8c16256fc78ace43c4fd5" translate="yes" xml:space="preserve">
          <source>If the objects are not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">객체가 &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 이 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7439cc88d3247f96faa2170d824e55add0c21fea" translate="yes" xml:space="preserve">
          <source>If the objects overlap, the behavior is undefined.</source>
          <target state="translated">객체가 겹치는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cfd990fe5c8c1f9320d43b19453f94b1906d5b8d" translate="yes" xml:space="preserve">
          <source>If the old locale's encoding is state-dependent and file is not positioned at the beginning, then the new locale must have the same &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet as the one previously imbued.</source>
          <target state="translated">이전 로케일의 인코딩이 상태에 따라 다르며 파일이 시작 위치에없는 경우 새 로케일은 이전에 삽입 된 것과 동일한 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 패싯을 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="7518873ec88dce6433b77a202724dd872b5facce" translate="yes" xml:space="preserve">
          <source>If the old pointer was non-empty, deletes the previously managed object &lt;code&gt;if(old_ptr) get_deleter()(old_ptr)&lt;/code&gt;.</source>
          <target state="translated">이전 포인터가 비어 있지 않은 &lt;code&gt;if(old_ptr) get_deleter()(old_ptr)&lt;/code&gt; 이전에 관리 된 객체 if (old_ptr) get_deleter () (old_ptr)를 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="4dd6552f73dd69bf5933722a03efee57f0b98bea" translate="yes" xml:space="preserve">
          <source>If the open operation succeeds and &lt;code&gt;openmode &amp;amp; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt; != 0&lt;/code&gt; (the &lt;code&gt;ate&lt;/code&gt; bit is set), repositions the file position to the end of file, as if by calling &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;)&lt;/code&gt;, where &lt;code&gt;file&lt;/code&gt; is the pointer returned by calling &lt;code&gt;fopen&lt;/code&gt;. If the repositioning fails, calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; and returns a null pointer to indicate failure.</source>
          <target state="translated">열기 조작이 성공하고 &lt;code&gt;openmode &amp;amp; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt; != 0&lt;/code&gt; ( &lt;code&gt;ate&lt;/code&gt; 비트가 설정 됨)이면 &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;)&lt;/code&gt; 를 호출하는 것처럼 파일 위치를 파일 끝으로 재배치합니다. ) 여기서 &lt;code&gt;file&lt;/code&gt; 호출하여 반환 된 포인터 &lt;code&gt;fopen&lt;/code&gt; . 재배치가 실패하면 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 호출 하고 실패를 나타내는 null 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1df990f7386ff3f2cc16de12a9e72eb727c483f2" translate="yes" xml:space="preserve">
          <source>If the operand is not &lt;code&gt;bool&lt;/code&gt;, it is converted to &lt;code&gt;bool&lt;/code&gt; using &lt;a href=&quot;implicit_cast&quot;&gt;contextual conversion to bool&lt;/a&gt;: it is only well-formed if the declaration &lt;code&gt;bool t(arg)&lt;/code&gt; is well-formed, for some invented temporary &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">피연산자가 아닌 경우 &lt;code&gt;bool&lt;/code&gt; , 변환됩니다 &lt;code&gt;bool&lt;/code&gt; 에 사용 &lt;a href=&quot;implicit_cast&quot;&gt;부울로 문맥 전환&lt;/a&gt; : 선언의 경우는 잘 형성된다 &lt;code&gt;bool t(arg)&lt;/code&gt; 일부 발명 일시적를 들어, 잘 형성된다 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="910435839383d33c5dc2d8d4ba19e0ed1ca648ae" translate="yes" xml:space="preserve">
          <source>If the operand is the name of an overloaded function, the address may be taken only if the overload can be resolved due to context. See &lt;a href=&quot;overloaded_address&quot;&gt;Address of an overloaded function&lt;/a&gt; for details.</source>
          <target state="translated">피연산자가 오버로드 된 함수의 이름 인 경우 컨텍스트로 인해 과부하를 해결할 수있는 경우에만 주소를 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;overloaded_address&quot;&gt;은 오버로드 된 기능의 주소를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="edcca376b9017a314c5ce3c74e8c8cd913ab1436" translate="yes" xml:space="preserve">
          <source>If the operand of the post-increment operator is of type &lt;code&gt;bool&lt;/code&gt;, it is set to &lt;code&gt;true&lt;/code&gt;(deprecated).(until C++17).</source>
          <target state="translated">후행 증가 연산자의 피연산자가 &lt;code&gt;bool&lt;/code&gt; 유형 인 경우 &lt;code&gt;true&lt;/code&gt; (더 이상 사용되지 않음)로 설정됩니다 (C ++ 17까지).</target>
        </trans-unit>
        <trans-unit id="6058f3bacdd6399a42fe9ae2e370059cb00c4139" translate="yes" xml:space="preserve">
          <source>If the operand of the pre-increment operator is of type &lt;code&gt;bool&lt;/code&gt;, it is set to &lt;code&gt;true&lt;/code&gt;(deprecated).(until C++17).</source>
          <target state="translated">사전 증분 연산자의 피연산자가 &lt;code&gt;bool&lt;/code&gt; 유형 인 경우 &lt;code&gt;true&lt;/code&gt; (더 이상 사용되지 않음)로 설정됩니다 (C ++ 17까지).</target>
        </trans-unit>
        <trans-unit id="6c5fbbf8cf6f23e69c16207aea6b5866059dd114" translate="yes" xml:space="preserve">
          <source>If the operand passed to an arithmetic operator is integral or unscoped enumeration type, then before any other action (but after lvalue-to-rvalue conversion, if applicable), the operand undergoes &lt;a href=&quot;implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;. If an operand has array or function type, array-to-pointer and function-to-pointer conversions are applied.</source>
          <target state="translated">산술 연산자에 전달 된 피연산자가 정수 또는 범위가 지정되지 않은 열거 유형 인 경우 다른 조치 전에 (그러나 해당되는 경우 lvalue에서 rvalue로 변환 후) 피연산자는 &lt;a href=&quot;implicit_cast#Integral_promotion&quot;&gt;정수 승격을&lt;/a&gt; 받습니다. 피연산자에 배열 또는 함수 유형이 있으면 배열 간 포인터 및 함수 간 포인터 변환이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b2856e7c84ee7bcd9c7d54aff911eeecd1a576e8" translate="yes" xml:space="preserve">
          <source>If the operand to &lt;code&gt;typeid&lt;/code&gt; is a class type or a reference to a class type, then that class type must not be an &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;typeid&lt;/code&gt; 에 대한 피연산자 가 클래스 유형이거나 클래스 유형에 대한 참조 인 경우 해당 클래스 유형은 &lt;a href=&quot;incomplete_type&quot;&gt;불완전한 유형이&lt;/a&gt; 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a6f60e09ec075130d1f28f4c735c3e62c6710a29" translate="yes" xml:space="preserve">
          <source>If the operands has arithmetic or enumeration type (scoped or unscoped),</source>
          <target state="translated">피연산자에 산술 또는 열거 유형 (범위 또는 범위 없음)이있는 경우</target>
        </trans-unit>
        <trans-unit id="0f10e3bc67559ed7f0001e6e7e37e3c27f4624c6" translate="yes" xml:space="preserve">
          <source>If the operation would result in &lt;code&gt;size() &amp;gt; max_size()&lt;/code&gt;, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">작업 결과 &lt;code&gt;size() &amp;gt; max_size()&lt;/code&gt; 가 발생하면 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b217f2aa9381c149a3dabe0b7cf0fe6551f65c06" translate="yes" xml:space="preserve">
          <source>If the options argument was not supplied, returns &lt;code&gt;options::none&lt;/code&gt;.</source>
          <target state="translated">options 인수가 제공되지 않은 경우 &lt;code&gt;options::none&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b113388f82173776cc247c5cef46e3268d0b48fb" translate="yes" xml:space="preserve">
          <source>If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.</source>
          <target state="translated">스트림의 방향이 이미 결정된 경우 (출력을 실행하거나 fwide에 대한 이전 호출을 통해)이 기능은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1de522a1c1fdc728580e466d8485c9d4aecac535" translate="yes" xml:space="preserve">
          <source>If the original pointer is pointing to a base class subobject within an object of some polymorphic type, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; may be used to obtain a &lt;code&gt;void*&lt;/code&gt; that is pointing at the complete object of the most derived type.</source>
          <target state="translated">원래 포인터가 다형성 유형의 객체 내에서 기본 클래스 하위 객체를 가리키는 경우, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast를&lt;/a&gt; 사용 하여 가장 파생 된 유형의 전체 객체를 가리키는 &lt;code&gt;void*&lt;/code&gt; 를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="990f3e3a0b5d27b439c43881744b60db8d8b4e06" translate="yes" xml:space="preserve">
          <source>If the output could not be generated, sets &lt;code&gt;failbit&lt;/code&gt;, If exceptions on failbit are enabled in this stream's exception mask, throws &lt;a href=&quot;../io/ios_base/failure&quot;&gt;&lt;code&gt;ios_base::failure&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">출력이 생성 될 수없는 경우, 세트 &lt;code&gt;failbit&lt;/code&gt; failbit에 예외가이 스트림의 예외 마스크를 사용할 경우, 발생 &lt;a href=&quot;../io/ios_base/failure&quot;&gt; &lt;code&gt;ios_base::failure&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36e1dfece2770bc2927fb6c9f13e3ae6d4aa3615" translate="yes" xml:space="preserve">
          <source>If the output fails for any reason, sets &lt;code&gt;badbit&lt;/code&gt;.</source>
          <target state="translated">어떤 이유로 든 출력이 실패하면 &lt;code&gt;badbit&lt;/code&gt; 를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="2b185a676601b8249554276be7b4af45b951241d" translate="yes" xml:space="preserve">
          <source>If the output sequence write position is not available (the buffer is full), then calls &lt;code&gt;overflow(ch)&lt;/code&gt;.</source>
          <target state="translated">출력 시퀀스 쓰기 위치를 사용할 수 없으면 (버퍼가 가득 참) &lt;code&gt;overflow(ch)&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="0ddd7375e8e8b7ed3f1d22a6f4f461c76fda6d26" translate="yes" xml:space="preserve">
          <source>If the overload resolution selects a built-in candidate, the &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequence&lt;/a&gt; from an operand of class type is not allowed to have a second standard conversion sequence: the user-defined conversion function must give the expected operand type directly:</source>
          <target state="translated">과부하 해결이 내장 후보를 선택하는 경우 클래스 유형의 피연산자에서 &lt;a href=&quot;implicit_cast&quot;&gt;사용자 정의 변환 시퀀스&lt;/a&gt; 는 두 번째 표준 변환 시퀀스를 가질 수 없습니다. 사용자 정의 변환 함수는 예상 피연산자 유형을 직접 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0339e3bc8e944d80de0d65db76ef29721018ee48" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;icase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the character class ignores character case, e.g. the regex &lt;code&gt;[:lower:]&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; generates a call to &lt;code&gt;regex_traits&amp;lt;&amp;gt;::lookup_classname()&lt;/code&gt; with &lt;code&gt;[first, last)&lt;/code&gt; indicating the string &lt;code&gt;&quot;lower&quot;&lt;/code&gt; and &lt;code&gt;icase == true&lt;/code&gt;. This call returns the same bitmask as the call generated by the regex &lt;code&gt;[:alpha:]&lt;/code&gt; with &lt;code&gt;icase == false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;icase&lt;/code&gt; 매개 변수 가 &lt;code&gt;true&lt;/code&gt; 이면 문자 클래스는 문자 대 / 소문자를 무시합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; 와 함께 regex &lt;code&gt;[:lower:]&lt;/code&gt; 는 &lt;code&gt;[first, last)&lt;/code&gt; &lt;code&gt;regex_traits&amp;lt;&amp;gt;::lookup_classname()&lt;/code&gt; , last) 와 함께 regex_traits &amp;lt;&amp;gt; :: lookup_classname ()에 대한 호출을 생성 합니다. 문자열 &lt;code&gt;&quot;lower&quot;&lt;/code&gt; 및 &lt;code&gt;icase == true&lt;/code&gt; 입니다. 이 호출은 정규식 &lt;code&gt;[:alpha:]&lt;/code&gt; 의해 생성 된 호출과 동일한 비트 마스크 를 &lt;code&gt;icase == false&lt;/code&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="71a8649df3ecbbada92cdc80a78f0174dc434084" translate="yes" xml:space="preserve">
          <source>If the parameter of the catch-clause is a reference type, any changes made to it are reflected in the exception object, and can be observed by another handler if the exception is rethrown with &lt;code&gt;throw;&lt;/code&gt;. If the parameter is not a reference, any changes made to it are are local and its lifetime ends when the handler exits.</source>
          <target state="translated">catch-clause의 매개 변수가 참조 유형 인 경우, 이에 대한 변경 사항은 예외 오브젝트에 반영되며 예외가 throw와 함께 다시 발생하면 다른 핸들러가이를 관찰 할 수 있습니다 &lt;code&gt;throw;&lt;/code&gt; . 매개 변수가 참조가 아닌 경우, 변경 사항은 로컬이며 처리기가 종료되면 수명이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6dad0498ed0cf6b6b98d4eaaf808c912c3d3152c" translate="yes" xml:space="preserve">
          <source>If the parameter type is &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt;, and there is an non-narrowing implicit conversion from every element of the initializer list to &lt;code&gt;X&lt;/code&gt;, the implicit conversion sequence for the purpose of overload resolution is the worst conversion necessary. If the braced-init-list is empty, the conversion sequence is the identity conversion.</source>
          <target state="translated">매개 변수 유형이 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; 이고 초기화 목록의 모든 요소에서 &lt;code&gt;X&lt;/code&gt; 로 좁히지 않는 암시 적 변환이있는 경우 과부하 해결을위한 암시 적 변환 순서는 필요한 최악의 변환입니다. braced-init-list가 비어 있으면 변환 순서는 ID 변환입니다.</target>
        </trans-unit>
        <trans-unit id="18426061d489bcb10c6138a5612f8728895a21a5" translate="yes" xml:space="preserve">
          <source>If the parameter type is some aggregate &lt;code&gt;X&lt;/code&gt; and the initializer list consists of exactly one element of same or derived class (possibly cv-qualified), the implicit conversion sequence is the one required to convert the element to the parameter type.</source>
          <target state="translated">매개 변수 유형이 일부 집계 &lt;code&gt;X&lt;/code&gt; 이고 이니셜 라이저 목록이 동일하거나 파생 된 클래스 (cv-qualified)의 정확히 하나의 요소로 구성된 경우 내재적 변환 시퀀스는 요소를 매개 변수 유형으로 변환하는 데 필요한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d845ac35c60a3d6398352b7893d2603e6b328c05" translate="yes" xml:space="preserve">
          <source>If the parent directory is outside directory hierarchy that is iterated on (i.e. &lt;code&gt;depth() == 0&lt;/code&gt;), sets &lt;code&gt;*this&lt;/code&gt; to an end directory iterator.</source>
          <target state="translated">상위 디렉토리가 반복되는 디렉토리 계층 외부에있는 경우 (즉, &lt;code&gt;depth() == 0&lt;/code&gt; ) &lt;code&gt;*this&lt;/code&gt; 를 종료 디렉토리 반복자로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8f12e10b26c51070735d7546640510f221a4a717" translate="yes" xml:space="preserve">
          <source>If the parsing succeeds, does not change &lt;code&gt;err&lt;/code&gt;, and stores the result in &lt;code&gt;units&lt;/code&gt; or &lt;code&gt;digits&lt;/code&gt;.</source>
          <target state="translated">구문 분석이 성공하면 &lt;code&gt;err&lt;/code&gt; 을 변경하지 않고 결과를 &lt;code&gt;units&lt;/code&gt; 또는 &lt;code&gt;digits&lt;/code&gt; 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="704ea65740c7ae23e0fe2ae321dd1d4cee11f634" translate="yes" xml:space="preserve">
          <source>If the part of the regular expression that matched is just an &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript#Assertions&quot;&gt;assertion&lt;/a&gt; (&lt;code&gt;^&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt;), the match stored in the iterator is a zero-length match, that is, &lt;code&gt;match[0].first == match[0].second&lt;/code&gt;.</source>
          <target state="translated">일치하는 정규 표현식의 일부가 &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript#Assertions&quot;&gt;어설 션&lt;/a&gt; ( &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\B&lt;/code&gt; ) 인 경우 반복자에 저장된 일치는 길이가 0 인 일치, 즉 &lt;code&gt;match[0].first == match[0].second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ebed057a709d5166451a5bb4fdfc9d04cff29d" translate="yes" xml:space="preserve">
          <source>If the path &lt;code&gt;p&lt;/code&gt; refers to a symbolic link, returns a new path object which refers to the target of that symbolic link.</source>
          <target state="translated">경로 &lt;code&gt;p&lt;/code&gt; 가 기호 링크를 참조하는 경우 해당 기호 링크의 대상을 참조하는 새 경로 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5a2ee3308db767e5626b5d282347713ca3b32db" translate="yes" xml:space="preserve">
          <source>If the pathname is either &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, or if &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt; does not contain the &lt;code&gt;.&lt;/code&gt; character, then empty path is returned.</source>
          <target state="translated">경우 경로 이름 중 하나입니다 &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; . 경우, 또는 &lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt; 포함되어 있지 않습니다 &lt;code&gt;.&lt;/code&gt; 문자, 빈 경로가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="422fd574496432a86171fe46fb0d9e0b579301d4" translate="yes" xml:space="preserve">
          <source>If the pattern ([pat_first, pat_last)) is empty, returns &lt;code&gt;make_pair(first, first)&lt;/code&gt;.</source>
          <target state="translated">패턴 ([pat_first, pat_last))이 비어 있으면 &lt;code&gt;make_pair(first, first)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="70f9539cc95e6db66dffafbd8aa72c5758b90e7b" translate="yes" xml:space="preserve">
          <source>If the pattern was matched, but the parsed value is not in the range representable by the type of &lt;code&gt;value&lt;/code&gt;, returns value of type &lt;code&gt;from_chars_result&lt;/code&gt; such that &lt;code&gt;ec&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ptr&lt;/code&gt; points at the first character not matching the pattern. &lt;code&gt;value&lt;/code&gt; is unmodified.</source>
          <target state="translated">패턴이 일치하지만, 파싱 된 값의 종류별 범위 표현할 아닌 경우 &lt;code&gt;value&lt;/code&gt; 을 입력의 반환 값 &lt;code&gt;from_chars_result&lt;/code&gt; 되도록 &lt;code&gt;ec&lt;/code&gt; 동일 &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;ptr&lt;/code&gt; 패턴과 일치하지 않는 첫 번째 문자의 포인트. &lt;code&gt;value&lt;/code&gt; 은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a87d6d2f05d467c7b59a0780f341a0df12fb06a" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is &lt;code&gt;auto&lt;/code&gt;or type-constraint&lt;code&gt;auto&lt;/code&gt;(since C++20), the variable type is deduced from the initializer using the rules for &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; from a function call (see &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;template argument deduction#Other contexts&lt;/a&gt; for details).</source>
          <target state="translated">자리 표시 자 형식 지정 &lt;code&gt;auto&lt;/code&gt; 또는 type-constraint &lt;code&gt;auto&lt;/code&gt; 인 경우 (C ++ 20부터) 함수 호출에서 &lt;a href=&quot;template_argument_deduction&quot;&gt;템플릿 인수 공제&lt;/a&gt; 규칙을 사용하여 이니셜 라이저에서 변수 유형이 추론됩니다 (자세한 내용은 &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;템플릿 인수 공제 # 기타 컨텍스트&lt;/a&gt; 참조). .</target>
        </trans-unit>
        <trans-unit id="2276b641f558192e6893ac9cc30b93561ac6a1e7" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is &lt;code&gt;decltype(auto)&lt;/code&gt;or type-constraint&lt;code&gt;decltype(auto)&lt;/code&gt;(since C++20), the deduced type is &lt;code&gt;decltype(e)&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is the initializer.</source>
          <target state="translated">플레이스 홀더 유형 지정자가 &lt;code&gt;decltype(auto)&lt;/code&gt; 또는 type-constraint &lt;code&gt;decltype(auto)&lt;/code&gt; (C ++ 20부터) 추론 된 유형은 &lt;code&gt;decltype(e)&lt;/code&gt; . 여기서 &lt;code&gt;e&lt;/code&gt; 는 초기화 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="ac0eb770b354dc56dd2f5ee40b48df9887d2f9d4" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is used to declare multiple variables, the deduced types must match. For example, the declaration &lt;code&gt;auto i = 0, d = 0.0;&lt;/code&gt; is ill-formed, while the declaration &lt;code&gt;auto i = 0, *p = &amp;amp;i;&lt;/code&gt; is well-formed and the &lt;code&gt;auto&lt;/code&gt; is deduced as &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">플레이스 홀더 유형 지정자가 여러 변수를 선언하는 데 사용되는 경우 추론 된 유형이 일치해야합니다. 예를 들어, 선언 &lt;code&gt;auto i = 0, d = 0.0;&lt;/code&gt; 선언 &lt;code&gt;auto i = 0, *p = &amp;amp;i;&lt;/code&gt; 잘 구성되어 있으며 &lt;code&gt;auto&lt;/code&gt; 는 &lt;code&gt;int&lt;/code&gt; 로 추론됩니다 .</target>
        </trans-unit>
        <trans-unit id="05226f11d77b34f54e805ec7153e749dfb3f47a5" translate="yes" xml:space="preserve">
          <source>If the platform uses mixed endian, &lt;code&gt;std::endian::native&lt;/code&gt; does not equal either &lt;code&gt;std::endian::big&lt;/code&gt; nor &lt;code&gt;std::endian::little&lt;/code&gt;</source>
          <target state="translated">플랫폼이 혼합 엔디안을 사용하는 경우 &lt;code&gt;std::endian::native&lt;/code&gt; 는 &lt;code&gt;std::endian::big&lt;/code&gt; 또는 &lt;code&gt;std::endian::little&lt;/code&gt; 와 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12d037e01ff534df66a9b8a862a8773089ded879" translate="yes" xml:space="preserve">
          <source>If the pointer (either &lt;code&gt;gptr&lt;/code&gt; or &lt;code&gt;pptr&lt;/code&gt; or both) is repositioned, it is done as follows:</source>
          <target state="translated">포인터 ( &lt;code&gt;gptr&lt;/code&gt; 또는 &lt;code&gt;pptr&lt;/code&gt; 또는 둘 다)가 재배치되면 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="28cec222b90e62fa53ecba18ed8db910c7df5ecd" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points to the &lt;code&gt;i&lt;/code&gt;th element of an array, and the pointer &lt;code&gt;Q&lt;/code&gt; points at the &lt;code&gt;j&lt;/code&gt;th element of the same array, the expression &lt;code&gt;P-Q&lt;/code&gt; has the value &lt;code&gt;i-j&lt;/code&gt;, if the value fits in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;. Both operands must point to the elements of the same array (or one past the end), otherwise the behavior is undefined. If the result does not fit in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">포인터 &lt;code&gt;P&lt;/code&gt; 가 배열 의 &lt;code&gt;i&lt;/code&gt; 번째 요소를 가리키고 포인터 &lt;code&gt;Q&lt;/code&gt; 가 같은 배열 의 &lt;code&gt;j&lt;/code&gt; 번째 요소를 가리키는 경우, 값 &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt; 가 std :: ptrdiff_t에 맞는 경우 &lt;code&gt;P-Q&lt;/code&gt; 표현식 의 값은 &lt;code&gt;i-j&lt;/code&gt; 입니다. 두 피연산자는 모두 같은 배열의 요소 (또는 끝을 지나는 요소)를 가리켜 야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 결과가 &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt; 맞지 않으면 동작이 정의되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c3af6cf6b2fece3bf06d95f3b15704d049a2a68" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points to the &lt;code&gt;i&lt;/code&gt;th element of an array, then the expressions &lt;code&gt;P+n&lt;/code&gt;, &lt;code&gt;n+P&lt;/code&gt;, and &lt;code&gt;P-n&lt;/code&gt; are pointers of the same type that point to the &lt;code&gt;i+n&lt;/code&gt;th, &lt;code&gt;i+n&lt;/code&gt;th, and &lt;code&gt;i-n&lt;/code&gt;th element of the same array, respectively. The result of pointer addition may also be a one-past-the-end pointer (that is, pointer &lt;code&gt;P&lt;/code&gt; such that the expression &lt;code&gt;P-1&lt;/code&gt; points to the last element of the array). Any other situations (that is, attempts to generate a pointer that isn't pointing at an element of the same array or one past the end) invoke undefined behavior.</source>
          <target state="translated">포인터 경우 &lt;code&gt;P&lt;/code&gt; 의 포인트에 &lt;code&gt;i&lt;/code&gt; 배열 th 요소 다음 식 &lt;code&gt;P+n&lt;/code&gt; , &lt;code&gt;n+P&lt;/code&gt; 및 &lt;code&gt;P-n&lt;/code&gt; 동일한 유형의 포인터는 것을 가리키고 &lt;code&gt;i+n&lt;/code&gt; 번째 &lt;code&gt;i+n&lt;/code&gt; 번째와 &lt;code&gt;i-n&lt;/code&gt; 번째 같은 배열의 요소. 포인터 추가의 결과는 또한 1- 지난-끝 포인터 ( 즉, 표현 &lt;code&gt;P-1&lt;/code&gt; 이 어레이의 마지막 요소를 가리 키도록 포인터 &lt;code&gt;P&lt;/code&gt; ) 일 수있다. 다른 상황 (즉, 같은 배열의 요소를 가리 키거나 끝을 지나지 않는 포인터를 생성하려는 시도)은 정의되지 않은 동작을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0ca8d499f0d01575fddc904d502c2ba50ea7a28f" translate="yes" xml:space="preserve">
          <source>If the pointer is advanced and then &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; is called to flush the put area to the associated character sequence, the effect is that extra &lt;code&gt;count&lt;/code&gt; characters with undefined values are output.</source>
          <target state="translated">포인터를 앞선 다음 put 영역을 연관된 문자 순서로 플러시하기 위해 &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 를 호출하면 정의되지 않은 값을 가진 추가 &lt;code&gt;count&lt;/code&gt; 문자가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="e450bd3f7a3a2237b2e10ff661bc465b1471234b" translate="yes" xml:space="preserve">
          <source>If the pointers stored in &lt;code&gt;pword&lt;/code&gt; require management, &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; may be used to install handlers that execute deep copy or deallocation as needed.</source>
          <target state="translated">&lt;code&gt;pword&lt;/code&gt; 에 저장된 포인터에 관리가 필요한 경우 &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; 사용하여 필요에 따라 딥 카피 또는 할당 해제를 실행하는 핸들러를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16ee378b87cd08352666411c9cd09d7998ae045a" translate="yes" xml:space="preserve">
          <source>If the pool selected for a block of size &lt;code&gt;bytes&lt;/code&gt; is unable to satisfy the request from its internal data structures, calls &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource to obtain memory.</source>
          <target state="translated">크기 &lt;code&gt;bytes&lt;/code&gt; 블록에 대해 선택된 풀이 내부 데이터 구조의 요청을 충족시킬 수없는 경우 업스트림 메모리 자원에서 assign &lt;code&gt;allocate()&lt;/code&gt; 을 호출 하여 메모리를 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="9eafb34d20e4bdd821ef599345cd0d19bc68a4ab" translate="yes" xml:space="preserve">
          <source>If the precision of the input cannot be exactly represented with seconds, then the format is a decimal floating point number with a fixed format and a precision matching that of the precision of the input (or to a microseconds precision if the conversion to floating point decimal seconds cannot be made within 18 fractional digits). The character for the decimal point is localized according to the locale.</source>
          <target state="translated">입력의 정밀도를 초로 정확하게 표현할 수없는 경우 형식은 고정 형식의 소수 부동 소수점 숫자이며 입력의 정밀도와 일치하는 정밀도입니다 (또는 부동 소수점 10 진수로 변환하는 경우 마이크로 초 정밀도 임) 초는 18 소수 내에서 만들 수 없습니다). 소수점 문자는 로케일에 따라 현지화됩니다.</target>
        </trans-unit>
        <trans-unit id="556a0df3f2ed8a7cac546a84886519ac3ebeac8f" translate="yes" xml:space="preserve">
          <source>If the previous stage does not produce a match, all constructors of &lt;code&gt;T&lt;/code&gt; participate in &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;overload resolution&lt;/a&gt; against the set of arguments that consists of the elements of the braced-init-list, with the restriction that only non-narrowing conversions are allowed. If this stage produces an explicit constructor as the best match for a copy-list-initialization, compilation fails (note, in simple copy-initialization, explicit constructors are not considered at all).</source>
          <target state="translated">이전 단계에서 일치 항목을 생성하지 않으면 &lt;code&gt;T&lt;/code&gt; 의 모든 생성자 는 괄호로 묶인 초기 목록의 요소로 구성된 인수 집합에 대한 &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;오버로드 확인&lt;/a&gt; 에 참여하며 비 좁게 변환 만 허용됩니다. 이 단계에서 명시 적 생성자를 복사 목록 초기화와 가장 일치하는 것으로 생성하는 경우 컴파일이 실패합니다 (단순한 복사 초기화에서는 명시 적 생성자가 전혀 고려되지 않음).</target>
        </trans-unit>
        <trans-unit id="7cc06dc92cb043df323fc3aa474cf3ba56bb3c97" translate="yes" xml:space="preserve">
          <source>If the primary member template is explicitly (fully) specialized for a given (implicit) specialization of the enclosing class template, the partial specializations of the member template are ignored for this specialization of the enclosing class template.</source>
          <target state="translated">기본 멤버 템플리트가 엔 클로징 클래스 템플리트의 주어진 (암시 적) 특수화에 대해 명시 적으로 (완전히) 특수화 된 경우, 멤버 클래스의 부분 특수화는이 클래스 화 클래스 템플리트의 특수화에 대해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="adfd306bbffa0b23164cbb3f7616b73a92779a42" translate="yes" xml:space="preserve">
          <source>If the primary template has a exception specification that isn't &lt;code&gt;noexcept(false)&lt;/code&gt;, the explicit specializations must have a compatible exception specification.</source>
          <target state="translated">기본 템플릿에 &lt;code&gt;noexcept(false)&lt;/code&gt; 가 아닌 예외 사양이있는 경우 명시 적 특수화에는 호환 가능한 예외 사양이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a27f2e5bb1066b5ba8ecb5c6e80fdaaed8988b08" translate="yes" xml:space="preserve">
          <source>If the program closes the file, e.g. by executing &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;std::fclose&lt;/a&gt;&lt;/code&gt;, the file is automatically deleted.</source>
          <target state="translated">프로그램이 파일을 닫으면 (예 : &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;std::fclose&lt;/a&gt;&lt;/code&gt; 실행) 파일이 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f054e6c94ddb2b1d1ab37e865dadbaa42672443f" translate="yes" xml:space="preserve">
          <source>If the program terminates abnormally, it is implementation-defined if these temporary files are deleted.</source>
          <target state="translated">프로그램이 비정상적으로 종료되면 이러한 임시 파일이 삭제되면 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2165d06ea6d2bb20531c9f3d3cebc5362167aa09" translate="yes" xml:space="preserve">
          <source>If the program terminates normally (by calling &lt;code&gt;&lt;a href=&quot;../../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;, returning from &lt;code&gt;main&lt;/code&gt;, etc), all files that were opened by calling &lt;code&gt;std::tmpfile&lt;/code&gt; are also automatically deleted.</source>
          <target state="translated">프로그램이 정상적으로 종료되면 ( &lt;code&gt;&lt;a href=&quot;../../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 호출 , &lt;code&gt;main&lt;/code&gt; 등으로 리턴 ) &lt;code&gt;std::tmpfile&lt;/code&gt; 호출로 열린 모든 파일 도 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="c4563d58386ce90b83da2edbf6c91576f3250457" translate="yes" xml:space="preserve">
          <source>If the put area becomes full (&lt;code&gt;pptr() == epptr()&lt;/code&gt;), this function may call &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, or achieve the effect of calling &lt;code&gt;overflow()&lt;/code&gt; by some other, unspecified, means.</source>
          <target state="translated">넣기 영역이 가득 차면 ( &lt;code&gt;pptr() == epptr()&lt;/code&gt; )이 함수는 &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 를 호출하거나 지정되지 않은 다른 방법으로 &lt;code&gt;overflow()&lt;/code&gt; 를 호출하는 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4470c9cf96cf0b0427223088eda48f753afa8e5d" translate="yes" xml:space="preserve">
          <source>If the range is empty, &lt;code&gt;init&lt;/code&gt; is returned, unmodified.</source>
          <target state="translated">범위가 비어 있으면 &lt;code&gt;init&lt;/code&gt; 되고 수정되지 않은 채로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0a1fccb7fec68247b6a1b2dd1f263989d79d91a2" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is greater than or equal to the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">비율이 경우 &lt;code&gt;R1&lt;/code&gt; 은 비율 이상인 &lt;code&gt;R2&lt;/code&gt; 멤버 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a7f289660496e50704c8e12b0a1a4ded1768f65" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is greater than than the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">비 경우 &lt;code&gt;R1&lt;/code&gt; 은 비보다보다 큰 &lt;code&gt;R2&lt;/code&gt; 멤버 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="486dc284a8aec5600eb2ce6107311df95fa15c27" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is less than or equal to the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">비 경우 &lt;code&gt;R1&lt;/code&gt; 은 비와 같거나 작 &lt;code&gt;R2&lt;/code&gt; 멤버 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2c44d3b0dc212e8ac325d4b33e901580daa7a83e" translate="yes" xml:space="preserve">
          <source>If the ratio R1 is less than the ratio R2, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">비율 R1이 비율 R2보다 작은 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 과 동일한 &lt;code&gt;true&lt;/code&gt; 를 제공하십시오 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="402f8a7cc133b62e154ebba1457929bfddbc3bf0" translate="yes" xml:space="preserve">
          <source>If the ratios R1 and R2 are equal, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">비율 R1 및 R2가 동일한 경우, 부재의 제공 상수 &lt;code&gt;value&lt;/code&gt; 과 동일 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="86470dd50c07d87d87cc6afc10ca67f451b58476" translate="yes" xml:space="preserve">
          <source>If the ratios R1 and R2 are not equal, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">비율 R1 및 R2가 동일하지 않은 경우, 부재 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e6ef67dfe973705134074e186274b6c8db214065" translate="yes" xml:space="preserve">
          <source>If the referred-to object was destroyed (e.g. by explicit destructor call), but the storage was not deallocated, a reference to the out-of-lifetime object may be used in limited ways, and may become valid if the object is recreated in the same storage (see &lt;a href=&quot;lifetime#Access_outside_of_lifetime&quot;&gt;Access outside of lifetime&lt;/a&gt; for details).</source>
          <target state="translated">참조 된 오브젝트가 (예 : 명시 적 소멸자 호출에 의해) 파괴되었지만 스토리지가 할당 해제되지 않은 경우, 수명이 만료 된 오브젝트에 대한 참조는 제한된 방식으로 사용될 수 있으며 오브젝트가 동일한 스토리지 ( 자세한 내용 &lt;a href=&quot;lifetime#Access_outside_of_lifetime&quot;&gt;은 수명 이외의 액세스&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="32e827308169dc81e7dc50577c7dd9c26262ce2a" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a maximum-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">기간 의 표현 &lt;code&gt;rep&lt;/code&gt; 가 다른 길이의 구현으로 최대 길이의 기간을 반환해야하는 경우 &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; 를 지정하여 원하는 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf898146c6c3c24b40b13c45caea3516ac8e0db7" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a minimum-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">기간 의 표현 &lt;code&gt;rep&lt;/code&gt; 가 최소 길이의 기간을 반환하기 위해 다른 구현이 필요한 경우 &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; 를 지정하여 원하는 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="216bb9502dac2c6f6a263c7893d238bdae801fdf" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a zero-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">기간 의 표현 &lt;code&gt;rep&lt;/code&gt; 가 길이가 0 인 기간을 반환하기 위해 다른 구현이 필요한 경우 &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; 를 지정하여 원하는 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79081ea2c3cd338bf77b76285c9d2307dabb3758" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;std::lrint&lt;/code&gt; or &lt;code&gt;std::llrint&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">&lt;code&gt;std::lrint&lt;/code&gt; 또는 &lt;code&gt;std::llrint&lt;/code&gt; 의 결과가 리턴 유형으로 표시 할 수있는 범위를 벗어나면 도메인 오류 또는 범위 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="587dd46cd3feba4cdcd09248f53d64715a053010" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;std::lround&lt;/code&gt; or &lt;code&gt;std::llround&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">&lt;code&gt;std::lround&lt;/code&gt; 또는 &lt;code&gt;std::llround&lt;/code&gt; 의 결과가 리턴 유형으로 표시 할 수있는 범위를 벗어나면 도메인 오류 또는 범위 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9143780183f7e4a1182584068e608842bda530b" translate="yes" xml:space="preserve">
          <source>If the result of the conversion is unique, then &lt;code&gt;result == local_info::unique&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the correct &lt;code&gt;std::chrono::sys_info&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is zero-initialized.</source>
          <target state="translated">변환 결과가 고유하면 &lt;code&gt;result == local_info::unique&lt;/code&gt; 이고, &lt;code&gt;first&lt;/code&gt; 올바른 &lt;code&gt;std::chrono::sys_info&lt;/code&gt; 지고 &lt;code&gt;second&lt;/code&gt; 는 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="8eeeae32aeed1e098fc91dd8bd921c86fb200e23" translate="yes" xml:space="preserve">
          <source>If the result of the rounding is outside the range of the return type, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">반올림 결과가 리턴 유형의 범위를 벗어나면 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생하고 구현 정의 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="40b9661e308f2792d26e6a4e9185df30cab4c8f8" translate="yes" xml:space="preserve">
          <source>If the result would be outside the range [-32767, 32767], the actual stored value is unspecified.</source>
          <target state="translated">결과가 [-32767, 32767] 범위를 벗어나면 실제 저장된 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12704794f475153a5a68233a95befd2418ed3109" translate="yes" xml:space="preserve">
          <source>If the result would be outside the range [0, 255], the actual stored value is unspecified.</source>
          <target state="translated">결과가 [0, 255] 범위를 벗어나면 실제 저장된 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b8913f174ebaea61408caa1ef433d1587bd6ffe" translate="yes" xml:space="preserve">
          <source>If the resulting pointer type is a function pointer, a pointer to member, or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; returns a prvalue of type &lt;a href=&quot;../utility/compare/strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">결과 포인터 유형이 함수 포인터, 멤버에 대한 포인터 또는 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; 는 &lt;a href=&quot;../utility/compare/strong_equality&quot;&gt; &lt;code&gt;std::strong_equality&lt;/code&gt; &lt;/a&gt; 유형의 prvalue를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2e78c0f7505a15522acda3776ce4ce10a21d82dd" translate="yes" xml:space="preserve">
          <source>If the resulting pointer type is an object pointer type, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; returns a prvalue of type &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;strong_ordering&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">결과 포인터 유형이 객체 포인터 유형 인 경우 &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; 는 strong_ordering 유형의 &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt; &lt;code&gt;strong_ordering&lt;/code&gt; &lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dbda3e4805d43967af0a89706ef34251ae9306d8" translate="yes" xml:space="preserve">
          <source>If the resulting year value for (1-3) is outside the range [-32767,32767], the actual value stored is unspecified.</source>
          <target state="translated">(1-3)의 결과 연도 값이 [-32767,32767] 범위를 벗어나면 저장된 실제 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d76cd29ea50833e8ec64892b7a35746e9aff8b17" translate="yes" xml:space="preserve">
          <source>If the return statement uses a brace-init-list, deduction is not allowed:</source>
          <target state="translated">return 문이 brace-init-list를 사용하는 경우 공제는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa7a732c5f6541d73e515269ccd1d1ceb3b46448" translate="yes" xml:space="preserve">
          <source>If the return type is &lt;code&gt;decltype(auto)&lt;/code&gt;, the return type is as what would be obtained if the expression used in the return statement were wrapped in &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt;.</source>
          <target state="translated">리턴 유형이 &lt;code&gt;decltype(auto)&lt;/code&gt; 인 경우 리턴 유형은 리턴 명령문에 사용 된 표현식이 &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; 에 랩핑 된 경우 얻을 수있는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d28a3f66a7fff0e2a4e0c4769a914c3fc6299edf" translate="yes" xml:space="preserve">
          <source>If the return type of the function template is a placeholder (&lt;code&gt;auto&lt;/code&gt; or &lt;code&gt;decltype(auto)&lt;/code&gt;), that return type is a non-deduced context and is determined from the instantiation.</source>
          <target state="translated">함수 템플리트의 리턴 유형이 플레이스 홀더 ( &lt;code&gt;auto&lt;/code&gt; 또는 &lt;code&gt;decltype(auto)&lt;/code&gt; ) 인 경우 해당 리턴 유형은 교육되지 않은 컨텍스트이며 인스턴스화에서 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="55096951d03276844009d4ac6ef2f86a40234649" translate="yes" xml:space="preserve">
          <source>If the returned value is &lt;code&gt;0&lt;/code&gt;, it will have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">반환 값이 &lt;code&gt;0&lt;/code&gt; 의 경우 , &lt;code&gt;x&lt;/code&gt; 와 같은 부호를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="6acd7cb12ab8e3d0ef11d24ea68011a7873b5dae" translate="yes" xml:space="preserve">
          <source>If the rewrite produces an invalid type, then &lt;code&gt;P&lt;/code&gt; is not at least as specialized as &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">다시 쓰기가 유효하지 않은 유형을 생성하면 &lt;code&gt;P&lt;/code&gt; 는 최소한 &lt;code&gt;A&lt;/code&gt; 만큼 전문화되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4014e2bbf13db27364d7162d5b480ce0991f7037" translate="yes" xml:space="preserve">
          <source>If the right hand side of &lt;code&gt;::&lt;/code&gt; names the same class as the left hand side, the name designates the &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; of that class. Such qualified name can only be used in a declaration of a constructor and in the &lt;a href=&quot;using_declaration&quot;&gt;using-declaration&lt;/a&gt; for an &lt;a href=&quot;using_declaration#Inheriting_constructors&quot;&gt;inheriting constructor&lt;/a&gt;. In those lookups where function names are ignored (that is, when looking up a name on the left of &lt;code&gt;::&lt;/code&gt;, when looking up a name in &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;, or &lt;a href=&quot;derived_class&quot;&gt;base specifier&lt;/a&gt;), the same syntax resolves to the injected-class-name:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 의 오른쪽 이 왼쪽과 동일한 클래스를 명명하는 경우 해당 이름 은 해당 클래스 의 &lt;a href=&quot;constructor&quot;&gt;생성자&lt;/a&gt; 를 지정합니다 . 이러한 자격을 갖춘 이름은 생성자의 선언과에서 사용할 수있는 &lt;a href=&quot;using_declaration&quot;&gt;사용하여 선언&lt;/a&gt; 에 대한 &lt;a href=&quot;using_declaration#Inheriting_constructors&quot;&gt;상속 생성자&lt;/a&gt; . 함수 이름이 무시되는 조회 (즉, &lt;code&gt;::&lt;/code&gt; 의 왼쪽에서 이름을 검색 할 때, &lt;a href=&quot;elaborated_type_specifier&quot;&gt;정교한 유형 지정자&lt;/a&gt; 또는 &lt;a href=&quot;derived_class&quot;&gt;기본 지정자&lt;/a&gt; 에서 이름을 찾을 때 )에서 동일한 구문이 injection-class-name으로 해석됩니다. :</target>
        </trans-unit>
        <trans-unit id="cf85d17881197f4ecbe7cccfb07809892b92473d" translate="yes" xml:space="preserve">
          <source>If the right operand is a</source>
          <target state="translated">오른쪽 피연산자가</target>
        </trans-unit>
        <trans-unit id="3c25a1f1f190f7079576b9f6ac4b83bbb5951e6a" translate="yes" xml:space="preserve">
          <source>If the same function is registered multiple times, it is called multiple times.</source>
          <target state="translated">동일한 기능이 여러 번 등록 된 경우 여러 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6456596730ba60e84aee4ac147873b048b5c59b5" translate="yes" xml:space="preserve">
          <source>If the second operand is zero, the behavior is undefined, except that if floating-point division is taking place and the type supports IEEE floating-point arithmetic (see &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt;), then:</source>
          <target state="translated">두 번째 피연산자가 0이면 부동 소수점 나누기가 발생하고 유형이 IEEE 부동 소수점 산술을 지원하는 경우 ( &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt; 참조)를 제외하고는 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="04f0455691936b497fbaebef44e9588dc509eb29" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception, no input takes place</source>
          <target state="translated">보초가 &lt;code&gt;false&lt;/code&gt; 를 반환 하거나 보초의 생성자가 예외를 던지면 입력이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39a91a877963ed9b5a894be3943380a70d626e6f" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception, no output takes place</source>
          <target state="translated">보초가 &lt;code&gt;false&lt;/code&gt; 를 반환 하거나 보초의 생성자가 예외를 던지면 출력이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb9f6b8db596d35efa0c018a14df69e7f6bbfaa1" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception:</source>
          <target state="translated">보초가 &lt;code&gt;false&lt;/code&gt; 반환 하거나 보초의 생성자가 예외를 던진 경우 :</target>
        </trans-unit>
        <trans-unit id="1a7affbf0e55ba9d44864cd1959e23685822e021" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;true&lt;/code&gt;, attempts to perform the desired output by inserting the characters into the output stream as if by calling &lt;code&gt;rdbuf()-&amp;gt;sputc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;xsputn()&lt;/code&gt;. Additionally, &lt;code&gt;rdbuf()-&amp;gt;overflow()&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;sync()&lt;/code&gt; may be called, but no other virtual member function of &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">센트리가 &lt;code&gt;true&lt;/code&gt; 를 리턴 한 경우 &lt;code&gt;rdbuf()-&amp;gt;sputc()&lt;/code&gt; 또는 &lt;code&gt;rdbuf()-&amp;gt;xsputn()&lt;/code&gt; 을 호출하는 것처럼 문자를 출력 스트림에 삽입하여 원하는 출력을 수행하려고 시도합니다 . 또한 &lt;code&gt;rdbuf()-&amp;gt;overflow()&lt;/code&gt; 및 &lt;code&gt;rdbuf()-&amp;gt;sync()&lt;/code&gt; 가 호출 될 수 있지만 &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 의 다른 가상 멤버 함수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d65656ed9a96ce6e5067eef9a37718da9bc64cf6" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;true&lt;/code&gt;, performs the input as if by calling &lt;code&gt;rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt;.</source>
          <target state="translated">센트리가 &lt;code&gt;true&lt;/code&gt; 를 리턴 한 경우 &lt;code&gt;rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; 또는 &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt; 를 호출하여 입력을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="70cc476a7cece12b6a2caeadf0dc66668c3d640a" translate="yes" xml:space="preserve">
          <source>If the set of potential exceptions is the set of all types, the implicit exception specification is &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="translated">잠재적 예외 세트가 모든 유형의 세트 인 경우 내재적 예외 스펙은 &lt;code&gt;noexcept(false)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2fd5f4d3d66499f24cbe8e9106c8eff484bfafb9" translate="yes" xml:space="preserve">
          <source>If the signal handler is called NOT as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (asynchronous signal), the behavior is undefined if.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (비동기 신호) 의 결과로 신호 핸들러가 NOT으로 호출 되면 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="671f3a813ef40ad3c5384400961c74b31b5b1d3a" translate="yes" xml:space="preserve">
          <source>If the signal handler is called as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (synchronous signal), the behavior is undefined if the signal handler calls &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">신호 핸들러가 &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (동기 신호) 의 결과로 호출되는 경우 신호 핸들러가 &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; 호출하면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6be8eefa6fa1b67c6f58f6b59c61b09644913654" translate="yes" xml:space="preserve">
          <source>If the single-argument overload (17,18) is not provided, but the size-aware overload taking &lt;code&gt;std::size_t&lt;/code&gt; as the second parameter (21,22) is provided, the size-aware form is called for normal deallocation, and the C++ runtime passes the size of the object to be deallocated as the second argument. If both forms are defined, the size-unaware version is called.</source>
          <target state="translated">단일 인수 과부하 (17,18)가 제공되지 않지만 두 번째 매개 변수 (21,22)가 제공 될 때 &lt;code&gt;std::size_t&lt;/code&gt; 를 사용하는 크기 인식 과부하 가 제공되는 경우 정상 할당 해제를 위해 크기 인식 양식이 호출됩니다. C ++ 런타임은 두 번째 인수로 할당 해제 될 객체의 크기를 전달합니다. 두 양식을 모두 정의하면 크기를 알 수없는 버전이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c2d39c7de53ad27f42a0268ca018c937a1d8ffae" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is known at compile time, &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; may be used, which offers a richer set of member functions. In addition, &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; exists as an alternative to &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">컴파일시 비트 세트의 크기를 알면 &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; 사용하여보다 다양한 멤버 함수 세트를 제공 할 수 있습니다. 또한 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost :: dynamic_bitset&lt;/a&gt; 은 &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt; 의 대안으로 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="d3ec4da197f7dc487044d683f9f3f0534aa5677b" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is not known at compile time, &lt;a href=&quot;../container/vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; may be used.</source>
          <target state="translated">컴파일시 비트 세트의 크기를 알 수 없으면 &lt;a href=&quot;../container/vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;&lt;/a&gt; 또는 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost :: dynamic_bitset을&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad1cf7f64b041e9b0a91851335d5ade685bd49da" translate="yes" xml:space="preserve">
          <source>If the size requested is larger than what the largest pool can handle, memory is allocated by calling &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource.</source>
          <target state="translated">요청 된 크기가 가장 큰 풀이 처리 할 수있는 크기보다 큰 경우 업스트림 메모리 리소스에서 assign &lt;code&gt;allocate()&lt;/code&gt; 을 호출하여 메모리가 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="b62ea5d0b3c38b6b4f7a4e5580107ff3cf6239e4" translate="yes" xml:space="preserve">
          <source>If the source and destination ranges (that is, &lt;code&gt;[first, last)&lt;/code&gt; and &lt;code&gt;[d_first, d_first+(last-first))&lt;/code&gt; respectively) overlap, the behavior is undefined.</source>
          <target state="translated">소스 및 대상 범위 (즉, &lt;code&gt;[first, last)&lt;/code&gt; 및 &lt;code&gt;[d_first, d_first+(last-first))&lt;/code&gt; )가 겹치는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81c139c2b88224c56ebf4f7944ce062c13ebe2bf" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char16_t&lt;/code&gt;, conversion from UTF-16 to native filesystem encoding is used.</source>
          <target state="translated">소스 문자 유형이 &lt;code&gt;char16_t&lt;/code&gt; 인 경우 UTF-16에서 기본 파일 시스템 인코딩으로의 변환이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="913c2f0506e7ab797a84a2f6e825328ef3b20217" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char32_t&lt;/code&gt;, conversion from UTF-32 to native filesystem encoding is used.</source>
          <target state="translated">소스 문자 유형이 &lt;code&gt;char32_t&lt;/code&gt; 인 경우 UTF-32에서 기본 파일 시스템 인코딩으로의 변환이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="694b72bdebad2e7991d3953383227294208921f6" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char8_t&lt;/code&gt;, conversion from UTF-8 to native filesystem encoding is used.</source>
          <target state="translated">소스 문자 유형이 &lt;code&gt;char8_t&lt;/code&gt; 인 경우 UTF-8에서 기본 파일 시스템 인코딩으로의 변환이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="96a70ab7daabf750d23aa93b01ed20ad4c4a1d50" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char&lt;/code&gt;, the encoding of the source is assumed to be the native narrow encoding (so no conversion takes place on POSIX systems)</source>
          <target state="translated">소스 문자 유형이 &lt;code&gt;char&lt;/code&gt; 인 경우 소스 인코딩은 기본 좁은 인코딩으로 간주됩니다 (따라서 POSIX 시스템에서는 변환이 수행되지 않음)</target>
        </trans-unit>
        <trans-unit id="4f00894176b3c2149f96504f78763e6045b2b289" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;wchar_t&lt;/code&gt;, the input is assumed to be the native wide encoding (so no conversion takes places on Windows)</source>
          <target state="translated">소스 문자 유형이 &lt;code&gt;wchar_t&lt;/code&gt; 인 경우 입력은 기본 와이드 인코딩으로 가정됩니다 (따라서 Windows에서는 변환이 수행되지 않음)</target>
        </trans-unit>
        <trans-unit id="c129bdb54be16ce791f2a9877c6536a222b2a628" translate="yes" xml:space="preserve">
          <source>If the source type is &lt;code&gt;bool&lt;/code&gt;, the value &lt;code&gt;false&lt;/code&gt; is converted to zero and the value &lt;code&gt;true&lt;/code&gt; is converted to the value one of the destination type (note that if the destination type is &lt;code&gt;int&lt;/code&gt;, this is an integer promotion, not an integer conversion).</source>
          <target state="translated">소스 유형이 &lt;code&gt;bool&lt;/code&gt; 인 경우 &lt;code&gt;false&lt;/code&gt; 값 은 0으로 변환되고 &lt;code&gt;true&lt;/code&gt; 값은 대상 유형 중 하나의 값으로 변환됩니다 (대상 유형이 &lt;code&gt;int&lt;/code&gt; 인 경우 정수 승격이 아니라 정수 승격 임).</target>
        </trans-unit>
        <trans-unit id="bab9d6ec8e3d2f1fd684bd9854d45b7e92934c4f" translate="yes" xml:space="preserve">
          <source>If the source value can be represented exactly in the destination type, it does not change.</source>
          <target state="translated">소스 값을 대상 유형으로 정확하게 나타낼 수 있으면 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efb29c4d220f173d5c3f3bd33b9dfc2ebc5dd7b6" translate="yes" xml:space="preserve">
          <source>If the source value is between two representable values of the destination type, the result is one of those two values (it is implementation-defined which one, although if IEEE arithmetic is supported, rounding defaults &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;to nearest&lt;/a&gt;).</source>
          <target state="translated">소스 값이 대상 유형의 표현 가능한 두 값 사이 인 경우 결과는이 두 값 중 하나입니다 (IEEE 산술이 지원되는 경우 기본값 &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;을 가장 가까운&lt;/a&gt; 반올림으로 구현 정의 됨 ).</target>
        </trans-unit>
        <trans-unit id="31b86def2b9a34fa38b7b256145666db6c5bf517" translate="yes" xml:space="preserve">
          <source>If the span is empty, the returned iterator will be equal to &lt;code&gt;end()&lt;/code&gt;.</source>
          <target state="translated">범위가 비어 있으면 반환 된 반복자는 &lt;code&gt;end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b682c7de7ba329b4fb255e71c3dba81aec002eb" translate="yes" xml:space="preserve">
          <source>If the specified size of the bit field is greater than the size of its type, the value is limited by the type: a &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint8_t&lt;/a&gt; b : 1000;&lt;/code&gt; would still hold values between 0 and 255. the extra bits become unused padding.</source>
          <target state="translated">비트 필드의 지정된 크기가 해당 유형의 크기보다 큰 경우 값은 유형에 따라 제한됩니다. a &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint8_t&lt;/a&gt; b : 1000;&lt;/code&gt; 여분의 비트는 사용되지 않은 패딩이됩니다.</target>
        </trans-unit>
        <trans-unit id="0cd8d8e47fd2f7d673121bf212de39492d391631" translate="yes" xml:space="preserve">
          <source>If the static type of the object that is being deleted differs from its dynamic type (such as when deleting a &lt;a href=&quot;../../language/objects&quot;&gt;polymorphic&lt;/a&gt; object through a pointer to base), and if the destructor in the static type is virtual, the single object form of delete begins lookup of the deallocation function's name starting from the point of definition of the final overrider of its virtual destructor. Regardless of which deallocation function would be executed at run time, the statically visible version of operator delete must be accessible in order to compile. In other cases, when deleting an array through a pointer to base, or when deleting through pointer to base with non-virtual destructor, the behavior is undefined.</source>
          <target state="translated">삭제중인 객체의 정적 유형이 동적 유형과 다른 경우 (예 : 기준에 대한 포인터를 통해 &lt;a href=&quot;../../language/objects&quot;&gt;다형성&lt;/a&gt; 객체를 삭제하는 경우) 정적 유형의 소멸자가 가상 ​​인 경우 단일 객체 삭제 유형의 조회가 시작됩니다. 가상 소멸자의 최종 재정 의자의 정의 지점에서 시작하여 할당 해제 기능의 이름. 런타임시 어떤 할당 해제 기능이 실행 되든 상관없이, 컴파일하려면 정적으로 보이는 버전의 운영자 삭제에 액세스 할 수 있어야합니다. 다른 경우, base에 대한 포인터를 통해 배열을 삭제하거나 비 가상적 소멸자가있는 base에 대한 포인터를 통해 삭제하는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a0ccecdae65148cf1c548284599ec7fc29e7a26" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; (for example, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; was used in the initial call to &lt;code&gt;bind&lt;/code&gt;), then the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;arg.get()&lt;/code&gt; and the type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;T&amp;amp;&lt;/code&gt;: the stored argument is passed by reference into the invoked function object.</source>
          <target state="translated">저장된 인수 &lt;code&gt;arg&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 유형 인 경우 (예 : &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; 가 초기 호출에서 &lt;code&gt;bind&lt;/code&gt; 를 사용하여 사용 된 경우 ) &lt;code&gt;std::invoke&lt;/code&gt; 호출 의 인수 &lt;code&gt;vn&lt;/code&gt; 은 위의 호출 인 &lt;code&gt;arg.get()&lt;/code&gt; 및 유형 &lt;code&gt;Vn&lt;/code&gt; 동일 호에 것은 &lt;code&gt;T&amp;amp;&lt;/code&gt; : 저장 인자는 호출 된 함수 객체 참조로 전달된다.</target>
        </trans-unit>
        <trans-unit id="acee41d0611ce916e2778b1cfd039971f9e77287" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;is_bind_expression&quot;&gt;std::is_bind_expression&lt;/a&gt;&amp;lt;T&amp;gt;::value == true&lt;/code&gt; (for example, another &lt;code&gt;bind&lt;/code&gt; expression was passed directly into the initial call to &lt;code&gt;bind&lt;/code&gt;), then &lt;code&gt;bind&lt;/code&gt; performs function composition: instead of passing the function object that the bind subexpression would return, the subexpression is invoked eagerly, and its return value is passed to the outer invokable object. If the bind subexpression has any placeholder arguments, they are shared with the outer bind (picked out of &lt;code&gt;u1, u2, ...&lt;/code&gt;). Specifically, the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;arg(std::forward&amp;lt;Uj&amp;gt;(uj)...)&lt;/code&gt; and the type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;&lt;a href=&quot;../../types/result_of&quot;&gt;std::result_of_t&lt;/a&gt;&amp;lt;T cv &amp;amp;(Uj&amp;amp;&amp;amp;...)&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt; (cv qualification is the same as that of &lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">저장된 인수 경우 &lt;code&gt;arg&lt;/code&gt; 유형이다 &lt;code&gt;T&lt;/code&gt; 되는 &lt;code&gt;&lt;a href=&quot;is_bind_expression&quot;&gt;std::is_bind_expression&lt;/a&gt;&amp;lt;T&amp;gt;::value == true&lt;/code&gt; (예를 들어, 다른 &lt;code&gt;bind&lt;/code&gt; 발현에 초기 호출에 직접 전달 된 &lt;code&gt;bind&lt;/code&gt; ) 다음 &lt;code&gt;bind&lt;/code&gt; 을 수행 조성물 기능 : 대신 바인드 부속 표현식이 리턴 할 함수 오브젝트를 전달하면 부속 표현식이 열심히 호출되며 리턴 값이 외부 호출 가능 오브젝트로 전달됩니다. 바인드 부속 표현식에 플레이스 홀더 인수가 있으면 외부 바인드와 공유됩니다 ( &lt;code&gt;u1, u2, ...&lt;/code&gt; ). 특히 위 의 &lt;code&gt;std::invoke&lt;/code&gt; 호출 에서 인수 &lt;code&gt;vn&lt;/code&gt; 은 &lt;code&gt;arg(std::forward&amp;lt;Uj&amp;gt;(uj)...)&lt;/code&gt; 이고 &lt;code&gt;Vn&lt;/code&gt; 유형 &lt;code&gt;g&lt;/code&gt; ).같은 호출에서 &lt;code&gt;&lt;a href=&quot;../../types/result_of&quot;&gt;std::result_of_t&lt;/a&gt;&amp;lt;T cv &amp;amp;(Uj&amp;amp;&amp;amp;...)&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt; (cv 자격은</target>
        </trans-unit>
        <trans-unit id="dc4a284d335b2d5c1ce7e8244468b32d33179179" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt;, for which &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;T&amp;gt;::value != 0&lt;/code&gt; (meaning, a placeholder such as &lt;code&gt;std::placeholders::_1, _2, _3, ...&lt;/code&gt; was used as the argument to the initial call to &lt;code&gt;bind&lt;/code&gt;), then the argument indicated by the placeholder (&lt;code&gt;u1&lt;/code&gt; for &lt;code&gt;_1&lt;/code&gt;, &lt;code&gt;u2&lt;/code&gt; for &lt;code&gt;_2&lt;/code&gt;, etc) is passed to the invokable object: the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Uj&amp;gt;(uj)&lt;/code&gt; and the corresponding type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;Uj&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">저장된 인수 경우 &lt;code&gt;arg&lt;/code&gt; 형이고 &lt;code&gt;T&lt;/code&gt; 들면 &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;T&amp;gt;::value != 0&lt;/code&gt; (예, 플레이스 홀더를 의미 &lt;code&gt;std::placeholders::_1, _2, _3, ...&lt;/code&gt; 로 하였다 은 초기 호출 인수 &lt;code&gt;bind&lt;/code&gt; ), 그 인자가 자리로 나타낸 ( &lt;code&gt;u1&lt;/code&gt; 용 &lt;code&gt;_1&lt;/code&gt; , &lt;code&gt;u2&lt;/code&gt; 위한 &lt;code&gt;_2&lt;/code&gt; 인자 : 등)는 호출 가능한 객체에 전달 &lt;code&gt;vn&lt;/code&gt; 에서 &lt;code&gt;std::invoke&lt;/code&gt; 되어 상기 호 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Uj&amp;gt;(uj)&lt;/code&gt; 동일한 호출에서 순방향 &amp;lt;Uj&amp;gt; (uj) 및 해당 유형 &lt;code&gt;Vn&lt;/code&gt; 은 &lt;code&gt;Uj&amp;amp;&amp;amp;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5073b898afe983835e7576b31a4b2a5ed1384e70" translate="yes" xml:space="preserve">
          <source>If the stored reference is &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;, &lt;code&gt;std::reference_wrapper&lt;/code&gt; is callable with the same arguments.</source>
          <target state="translated">저장된 참조가 &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable 인&lt;/a&gt; 경우 &lt;code&gt;std::reference_wrapper&lt;/code&gt; 는 동일한 인수로 호출 가능합니다.</target>
        </trans-unit>
        <trans-unit id="721f1a0ff5ac2a85a4aec48dc758c5efa06cf129" translate="yes" xml:space="preserve">
          <source>If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.</source>
          <target state="translated">스트림이 이진 모드로 열린 경우이 함수로 얻은 값은 파일 시작 부분의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="1be01e06d2b7863dcf18bfbfbb7a62e4aff8f3b7" translate="yes" xml:space="preserve">
          <source>If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스트림이 텍스트 모드에서 열려있는 경우이 함수가 리턴하는 값은 지정되지 않으며 &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt; 의 입력으로 만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcf9d7178da0219ad2eb8a851abb68eb2713f063" translate="yes" xml:space="preserve">
          <source>If the stream is using a dynamically-allocated array for output, disables (&lt;code&gt;flag == true&lt;/code&gt;) or enables (&lt;code&gt;flag == false&lt;/code&gt;) automatic allocation/deallocation of the buffer. Effectively calls &lt;code&gt;rdbuf()-&amp;gt;freeze(flag)&lt;/code&gt;.</source>
          <target state="translated">스트림이 출력에 동적으로 할당 된 배열을 사용하는 경우 버퍼의 자동 할당 / 할당을 비활성화 ( &lt;code&gt;flag == true&lt;/code&gt; ) 또는 활성화 ( &lt;code&gt;flag == false&lt;/code&gt; )합니다. 효과적으로 &lt;code&gt;rdbuf()-&amp;gt;freeze(flag)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e3a1404f13d35c564c59b09dcb07b726f75ab0a7" translate="yes" xml:space="preserve">
          <source>If the strictest (largest) &lt;code&gt;alignas&lt;/code&gt; on a declaration is weaker than the alignment it would have without any &lt;code&gt;alignas&lt;/code&gt; specifiers (that is, weaker than its natural alignment or weaker than &lt;code&gt;alignas&lt;/code&gt; on another declaration of the same object or type), the program is ill-formed:</source>
          <target state="translated">선언 에서 가장 엄격한 (가장 큰) &lt;code&gt;alignas&lt;/code&gt; 가 &lt;code&gt;alignas&lt;/code&gt; 지정 자가없는 것보다 (즉, 자연적 정렬보다 약하거나 &lt;code&gt;alignas&lt;/code&gt; 같은 객체 또는 유형의 다른 선언에)는, 프로그램은 병이다 형성 :</target>
        </trans-unit>
        <trans-unit id="b376b7c229a7bc07ebacea949f846a78b0d1782c" translate="yes" xml:space="preserve">
          <source>If the strings overlap, the behavior is undefined.</source>
          <target state="translated">문자열이 겹치면 동작이 정의되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="7d57980d6c4db7f5a88e476c28a7345cd0ee1e03" translate="yes" xml:space="preserve">
          <source>If the synchronization is turned off, the C++ standard streams are allowed to buffer their I/O independently, which may be considerably faster in some cases.</source>
          <target state="translated">동기화가 해제되면 C ++ 표준 스트림이 I / O를 독립적으로 버퍼링 할 수 있으며 경우에 따라 속도가 훨씬 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8cb52b7220965fcee67fc72cd6b2b899d9bdff" translate="yes" xml:space="preserve">
          <source>If the target sequence is uniquely matched, &lt;code&gt;v&lt;/code&gt; is set to the corresponding &lt;code&gt;bool&lt;/code&gt; value. Otherwise &lt;code&gt;false&lt;/code&gt; is stored in &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;. If unique match could not be found before the input ended (&lt;code&gt;in==end&lt;/code&gt;), &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; is executed.</source>
          <target state="translated">대상 시퀀스가 ​​고유하게 일치하면 &lt;code&gt;v&lt;/code&gt; 는 해당 &lt;code&gt;bool&lt;/code&gt; 값으로 설정됩니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 &lt;code&gt;v&lt;/code&gt; 에 저장 되고 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;err&lt;/code&gt; 에 지정됩니다 . 입력이 끝나기 전에 ( &lt;code&gt;in==end&lt;/code&gt; ) 고유 한 일치를 찾을 수 없으면 &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; 가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f1289b6bdc776c1418acfec4d954c523b4601b0f" translate="yes" xml:space="preserve">
          <source>If the type &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type referred to by &lt;code&gt;T&lt;/code&gt; with its topmost cv-qualifiers removed. Otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; with its topmost cv-qualifiers removed.</source>
          <target state="translated">유형 경우 &lt;code&gt;T&lt;/code&gt; 가 참조 형식이며, 멤버 타입 정의를 제공 &lt;code&gt;type&lt;/code&gt; 타입에 의해 참조 &lt;code&gt;T&lt;/code&gt; 제거 된 최상위 CV-한정자한다. 그렇지 않으면 &lt;code&gt;type&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 입니다 최상위 cv 한정자가 제거 된 입니다.</target>
        </trans-unit>
        <trans-unit id="bc4e534b1c21d223bb95673e8d15e125bb5d8892" translate="yes" xml:space="preserve">
          <source>If the type &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type referred to by &lt;code&gt;T&lt;/code&gt;. Otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">유형 경우 &lt;code&gt;T&lt;/code&gt; 가 참조 형식이며, 멤버 타입 정의를 제공 &lt;code&gt;type&lt;/code&gt; 타입에 의해 참조 &lt;code&gt;T&lt;/code&gt; 를 . 그렇지 않으면 &lt;code&gt;type&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="568c9a7735dfb6e7c3f7facf46f864c936b3998f" translate="yes" xml:space="preserve">
          <source>If the type is complete and if, for the delete[] only, the operand is a pointer to a class type with a non-trivial destructor or a (possibly multi-dimensional) array thereof, the global size-aware global function (with a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) is selected</source>
          <target state="translated">유형이 완전하고 delete []에 대해서만 피연산자가 사소한 소멸자 또는 그 (다차원) 배열을 가진 클래스 유형에 대한 포인터 인 경우 전역 크기 인식 전역 함수 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 유형의 매개 변수 가 선택됨</target>
        </trans-unit>
        <trans-unit id="d45b643bd174051aee94549a2f03f3ff00e0a987" translate="yes" xml:space="preserve">
          <source>If the type is reference type, the operator returns the alignment of</source>
          <target state="translated">유형이 참조 유형 인 경우 연산자는</target>
        </trans-unit>
        <trans-unit id="e61370f729d3fc61feda284c6f51bb8eac974871" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 유형 이 &lt;code&gt;bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb07f1de8954ef59a83dcf953df4f4e9416e15a0" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;boolalpha!=0&lt;/code&gt;, the following replaces stages 2 and 3:</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 유형 이 &lt;code&gt;bool&lt;/code&gt; 및 &lt;code&gt;boolalpha!=0&lt;/code&gt; 인 경우 다음은 2 단계와 3 단계를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="9a11f0db514f9cdeffd237282d9ed24955a00f05" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;boolalpha==0&lt;/code&gt;, proceeds as if the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long&lt;/code&gt;, except for the value to be stored in &lt;code&gt;v&lt;/code&gt; in stage 3.</source>
          <target state="translated">유형 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;bool&lt;/code&gt; 및 &lt;code&gt;boolalpha==0&lt;/code&gt; 유형 것처럼 진행 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;long&lt;/code&gt; 값으로 저장 될 제외한 &lt;code&gt;v&lt;/code&gt; 3 단계 에 .</target>
        </trans-unit>
        <trans-unit id="5c85042e7deeed4301f664d1dc468bbb3d06b939" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and boolalpha is not set, then if the value to be stored is &lt;code&gt;​0​&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; is stored, if the value to be stored is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is stored, for any other value &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; is stored.</source>
          <target state="translated">의 유형 경우 &lt;code&gt;v&lt;/code&gt; 것입니다 &lt;code&gt;bool&lt;/code&gt; 와 boolalpha가 설정되어 있지 않은 경우, 값이 저장 될 수있는 경우이다 &lt;code&gt;​0​&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 저장되는 값 인 경우, 저장 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 다른 값을 위해, 저장된 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;err&lt;/code&gt; 에 할당 되고 &lt;code&gt;true&lt;/code&gt; 가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7476d41e2a67317c3bb5251d97663d77eeb1e42c" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;double&lt;/code&gt;, will use conversion specifier &lt;code&gt;%lg&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 유형 이 &lt;code&gt;double&lt;/code&gt; 인 경우 변환 지정자 &lt;code&gt;%lg&lt;/code&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dfdf59b17079b062cc1b92411ee58243a516a33f" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;float&lt;/code&gt;, will use conversion specifier &lt;code&gt;%g&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 유형 이 &lt;code&gt;float&lt;/code&gt; 인 경우 변환 지정자 &lt;code&gt;%g&lt;/code&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4567caa0edddb2a88680b490c4e2737935cdcbd5" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long double&lt;/code&gt;, the length modifier &lt;code&gt;L&lt;/code&gt; is added to the conversion specifier.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 유형 이 &lt;code&gt;long double&lt;/code&gt; 인 경우 길이 한정자 &lt;code&gt;L&lt;/code&gt; 이 변환 지정자에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0474c288e1ccdf560a85090121492766095a9be3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long double&lt;/code&gt;, will use conversion specifier &lt;code&gt;%Lg&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 유형 이 &lt;code&gt;long double&lt;/code&gt; 인 경우 변환 지정자 &lt;code&gt;%Lg&lt;/code&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="00d6a72b02646eead810c617c23ae522ca753e6d" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;void*&lt;/code&gt;, will use conversion specifier &lt;code&gt;%p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 유형 이 &lt;code&gt;void*&lt;/code&gt; 인 경우 변환 지정자 &lt;code&gt;%p&lt;/code&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="29e503ca84cb15f39173a1562dbbbb2beffa737a" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is a floating-point type, the the first applicable choice of the following is selected:</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 유형이 부동 소수점 유형 인 경우, 다음 중 적용 가능한 첫 번째 선택 사항이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="af8313560c731302bab034bb408aa878436ea837" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is an integer type, the the first applicable choice of the following five is selected:</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 유형이 정수 유형 인 경우, 다음 다섯 가지 중 첫 번째 적용 가능한 선택이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a7ea4c84d1d685474ebd89637a92007ea3ea02" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is an integer type, the the first applicable choice of the following is selected:</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 유형이 정수 유형 인 경우 다음 중 적용 가능한 첫 번째 선택 사항이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="78f0474ec6b14c626c7efaff5801d926c1f92941" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is signed, will use conversion specifier &lt;code&gt;%d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 유형 이 서명 된 경우 변환 지정자 &lt;code&gt;%d&lt;/code&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4990261c39b3a34d0f827b213b2a6345d9b18783" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is unsigned, will use conversion specifier &lt;code&gt;%u&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 유형 이 부호가 없으면 변환 지정자 &lt;code&gt;%u&lt;/code&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="51577fdf94f044af450cebe5474487f90f5669ab" translate="yes" xml:space="preserve">
          <source>If the type of the next argument in &lt;code&gt;ap&lt;/code&gt; (after promotions) is not compatible with &lt;code&gt;T&lt;/code&gt;, the behavior is undefined, unless:</source>
          <target state="translated">&lt;code&gt;ap&lt;/code&gt; (프로모션 후) 의 다음 인수 유형이 &lt;code&gt;T&lt;/code&gt; 와 호환 되지 않으면 다음과 같은 경우를 제외하고 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37ea6657641f330790f7fa714b3234e4d4d737e5" translate="yes" xml:space="preserve">
          <source>If the type's alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, alignment-aware deallocation functions (with a parameter of type &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) are preferred. For other types, the alignment-unaware deallocation functions (without a parameter of type &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) are preferred.</source>
          <target state="translated">유형의 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하면 정렬 인식 해제 기능 ( &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; 유형의 매개 변수 사용 )이 선호됩니다. 다른 유형의 경우, 정렬 비 인식 해제 기능 ( &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; 유형의 매개 변수 없음 )이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="9e2d47f6d426a3f84b185a211656e8cd6bd7698e" translate="yes" xml:space="preserve">
          <source>If the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; is copied into such an array, and then the resulting content is copied back into &lt;code&gt;obj1&lt;/code&gt;, &lt;code&gt;obj1&lt;/code&gt; will hold its original value. If the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; are copied into &lt;code&gt;obj2&lt;/code&gt;, &lt;code&gt;obj2&lt;/code&gt; will hold &lt;code&gt;obj1&lt;/code&gt;'s value.</source>
          <target state="translated">&lt;code&gt;obj1&lt;/code&gt; 의 기본 바이트가 이러한 배열로 복사 된 후 결과 컨텐츠가 &lt;code&gt;obj1&lt;/code&gt; 로 다시 복사 되면 &lt;code&gt;obj1&lt;/code&gt; 은 원래 값을 보유합니다. &lt;code&gt;obj1&lt;/code&gt; 의 기본 바이트가 &lt;code&gt;obj2&lt;/code&gt; 에 복사 되면 &lt;code&gt;obj2&lt;/code&gt; 는 &lt;code&gt;obj1&lt;/code&gt; 의 값을 보유 합니다.</target>
        </trans-unit>
        <trans-unit id="1c532a0885cdbf73cb10a896503a4564c8a0bf0b" translate="yes" xml:space="preserve">
          <source>If the underlying type is fixed, the result is the same as the &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;converting&lt;/a&gt; the original value first to the underlying type of the enumeration and then to the enumeration type.</source>
          <target state="translated">기본 형식이 고정 된 경우 결과는 원래 값을 먼저 기본 형식의 열거 형으로 &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;변환&lt;/a&gt; 한 다음 열거 형식으로 변환 하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="53c5be902373ad8ba2b8c3eceeaae48131069091" translate="yes" xml:space="preserve">
          <source>If the underlying type is not fixed, the result is unspecified(until C++17)undefined behavior(since C++17) if the value of expression is out of range (the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration).</source>
          <target state="translated">기본 유형이 고정되지 않은 경우 표현식 값이 범위를 벗어난 경우 (C ++ 17 이후) 정의되지 않은 동작 (C ++ 17 이후) 결과가 지정되지 않습니다 (범위는 가장 작은 비트 필드에 대해 가능한 모든 값입니다). 대상 열거의 모든 열거자를 보유하기에 충분).</target>
        </trans-unit>
        <trans-unit id="9584e81563cc79a87482512943d106e7c6f35aeb" translate="yes" xml:space="preserve">
          <source>If the user defined function returns when handling &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt; or any other implementation-defined signal specifying a computational exception, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt; 또는 계산 예외를 지정하는 기타 구현 정의 신호를 처리 할 때 사용자 정의 함수가 반환되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="758bb6908f51c11c8477acd6f36292722e9b2a25" translate="yes" xml:space="preserve">
          <source>If the user-defined signal handling strategy is not set using &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked.</source>
          <target state="translated">사용자 정의 신호 처리 전략이 &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; 사용하여 아직 설정되지 않은 경우 신호가 무시되는지 또는 기본 핸들러가 호출되는지 여부는 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="ad569346ec44ef60f084b9ce61fd4164c7c32f63" translate="yes" xml:space="preserve">
          <source>If the usual deduction from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; (as described above) fails, the following alternatives are additionally considered:</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 의 일반적인 추론 (위에서 설명한)이 실패하면 다음 대안이 추가로 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="222dded9de677b2df12bcb544421882e3b919712" translate="yes" xml:space="preserve">
          <source>If the usual deduction from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; fails, the following alternatives are additionally considered:</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 의 일반적인 공제 가 실패하면 다음과 같은 대안이 추가로 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="2044c8cb072e19726cdc9c11e14101e5b7aa5788" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;​0​&lt;/code&gt; is added or subtracted from a pointer, the result is the pointer, unchanged. If two pointers point at the same object or are both one past the end of the same array, or both are null pointers, then the result of subtraction is equal to &lt;code&gt;(&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;)0&lt;/code&gt;.</source>
          <target state="translated">값이 있으면 &lt;code&gt;​0​&lt;/code&gt; 추가되거나 포인터로부터 감산되고, 그 결과는 포인터는 변하지 않는다. 두 포인터가 같은 객체를 가리 키거나 둘 다 같은 배열의 끝을지나거나 둘 다 널 포인터 인 경우 빼기 결과는 &lt;code&gt;(&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;)0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29e60c2f6520b56b9cab3b22f7509b4a9255b562" translate="yes" xml:space="preserve">
          <source>If the value in the first dimension is erroneous for any of these reasons,</source>
          <target state="translated">이러한 이유로 인해 첫 번째 측정 기준의 값이 잘못된 경우</target>
        </trans-unit>
        <trans-unit id="030063b706611cf1e8e06a4ae59ec7618b58db95" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;ch&lt;/code&gt; is neither representable as a &lt;code&gt;wchar_t&lt;/code&gt; nor equal to the value of the macro &lt;code&gt;WEOF&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 의 값을 &lt;code&gt;wchar_t&lt;/code&gt; 로 표현할 수 없고 매크로 &lt;code&gt;WEOF&lt;/code&gt; 의 값과 같지 않은 경우 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="248a5c7e458d6f5d84a843bb9bad9a695797de69" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;wc&lt;/code&gt; is neither representable as a &lt;code&gt;wchar_t&lt;/code&gt; nor equal to the value of the macro &lt;code&gt;WEOF&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;wc&lt;/code&gt; 값을 &lt;code&gt;wchar_t&lt;/code&gt; 로 표현할 수 없고 매크로 &lt;code&gt;WEOF&lt;/code&gt; 값과 같지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95ab164f16af6b727b63cdf344a7e218377e5641" translate="yes" xml:space="preserve">
          <source>If the value of base is &lt;code&gt;​0​&lt;/code&gt;, the numeric base is auto-detected: if the prefix is &lt;code&gt;0&lt;/code&gt;, the base is octal, if the prefix is &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the base is hexadecimal, otherwise the base is decimal.</source>
          <target state="translated">염기의 값인 경우 &lt;code&gt;​0​&lt;/code&gt; , 숫자베이스는 자동으로 탐지 : 접두어 인 경우 &lt;code&gt;0&lt;/code&gt; 접두어 인 경우, 기지국은 진수이다 &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; ,베이스 16 진수이고, 그렇지 않으면베이스 소수점이다.</target>
        </trans-unit>
        <trans-unit id="70a9c765b78740ba6c067e64a0ddbb7ae2ac6060" translate="yes" xml:space="preserve">
          <source>If the value of the integer literal is too big to fit in any of the types allowed by suffix/base combination and the compiler supports extended integer types (such as &lt;code&gt;__int128&lt;/code&gt;) the literal may be given the extended integer type -- otherwise the program is ill-formed.</source>
          <target state="translated">정수 리터럴의 값이 접미사 /베이스 조합에 의해 허용되는 유형에 맞지 않을 정도로 너무 크고 컴파일러가 확장 정수 유형 (예 : &lt;code&gt;__int128&lt;/code&gt; )을 지원하는 경우 리터럴에 확장 정수 유형이 제공 될 수 있습니다. 그렇지 않으면 프로그램은 다음과 같습니다. 잘못된 형태.</target>
        </trans-unit>
        <trans-unit id="e8c33ee241a255a63ad79ee3a3348d39830a7425" translate="yes" xml:space="preserve">
          <source>If the value to be stored in &lt;code&gt;*exp&lt;/code&gt; is outside the range of &lt;code&gt;int&lt;/code&gt;, the behavior is unspecified.</source>
          <target state="translated">&lt;code&gt;*exp&lt;/code&gt; 에 저장 될 값 이 &lt;code&gt;int&lt;/code&gt; 범위를 벗어나 면 동작이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2f54be830759cbe8fb68d644557c982f45181ea" translate="yes" xml:space="preserve">
          <source>If the value type is known to be a built-in type, the const variant should return by value.</source>
          <target state="translated">값 유형이 내장 유형으로 알려진 경우 const 변형은 값으로 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="90307671f8933d3e9e5abc11ed1d390a29f7fef2" translate="yes" xml:space="preserve">
          <source>If the variant is &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt;, returns &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;.</source>
          <target state="translated">변형이 &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; 인 경우 &lt;a href=&quot;variant_npos&quot;&gt;variant_npos를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fa561126aaa10ae89524de188dae5e165b1fdb67" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, none.</source>
          <target state="translated">벡터가 용량을 변경하면 모두 용량이 변경됩니다. 그렇지 않다면 없음.</target>
        </trans-unit>
        <trans-unit id="4d3428e86be4da734a232d16973b7cf3b93b4058" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, only end().</source>
          <target state="translated">벡터가 용량을 변경하면 모두 용량이 변경됩니다. 그렇지 않으면 end () 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="72ef803ef1a355b795f9869f64ff81133821942a" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, only those after the insertion point.</source>
          <target state="translated">벡터가 용량을 변경하면 모두 용량이 변경됩니다. 그렇지 않은 경우 삽입 점 이후의 항목 만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="eb75958a443f6e86954852258d39617127eed64b" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">생성 된 와이드 문자가 널 문자 인 경우 변환 상태 &lt;code&gt;*ps&lt;/code&gt; 는 초기 시프트 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="24382f133af9ec92a179262afb80b489903f3a55" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state stored in &lt;code&gt;*ps&lt;/code&gt; is the initial shift state.</source>
          <target state="translated">생성 된 와이드 문자가 널 문자 인 경우 &lt;code&gt;*ps&lt;/code&gt; 에 저장된 변환 상태 는 초기 시프트 상태입니다.</target>
        </trans-unit>
        <trans-unit id="0c78b539f6ef73fa78a596278e160b79dda2072b" translate="yes" xml:space="preserve">
          <source>If there are multiple declarations with different lexical orders (e.g. a function template declared with trailing return type, to be substituted after a parameter, and redeclared with ordinary return type that would be substituted before the parameter), then the program is ill-formed; no diagnostic required.</source>
          <target state="translated">어휘 순서가 다른 여러 선언이있는 경우 (예 : 후행 리턴 유형으로 선언되고 매개 변수 다음에 대체되고 매개 변수 이전에 대체되는 일반 리턴 유형으로 다시 선언되는 함수 템플리트) 프로그램이 잘못 구성됩니다. 진단이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2b18351965a2fe087972c4fc08282cc6ca24208" translate="yes" xml:space="preserve">
          <source>If there are multiple overloads of the function or operator being called, after the implicit conversion sequence is built from &lt;code&gt;T1&lt;/code&gt; to each available &lt;code&gt;T2&lt;/code&gt;, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; rules decide which overload is compiled.</source>
          <target state="translated">암시 적 변환 시퀀스에서 구축 한 후, 호출되는 함수 나 연산자의 다중 과부하가있는 경우 &lt;code&gt;T1&lt;/code&gt; 가능한 각에 &lt;code&gt;T2&lt;/code&gt; 는 , &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해상도&lt;/a&gt; 규칙은 컴파일되는 과부하를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="a5a33472c5c80216c585ac1f3e2bb1b8d2b913cd" translate="yes" xml:space="preserve">
          <source>If there are multiple parameters, each &lt;code&gt;P&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt; pair is deduced separately and the deduced template arguments are then combined. If deduction fails or is ambiguous for any &lt;code&gt;P&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt; pair or if different pairs yield different deduced template arguments, or if any template argument remains neither deduced nor explicitly specified, compilation fails.</source>
          <target state="translated">여러 개의 매개 변수가있는 경우 각 &lt;code&gt;P&lt;/code&gt; / &lt;code&gt;A&lt;/code&gt; 쌍이 개별적으로 추론되고 추론 된 템플리트 인수가 결합됩니다. &lt;code&gt;P&lt;/code&gt; / &lt;code&gt;A&lt;/code&gt; 쌍에 대해 추론이 실패하거나 모호 하거나 다른 쌍이 다른 추론 된 템플리트 인수를 생성하거나 템플리트 인수가 추론되거나 명시 적으로 지정되지 않은 경우 컴파일이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="08ff4d812abea495b9856132aa9d1453e7f49ba6" translate="yes" xml:space="preserve">
          <source>If there are multiple return statements, they must all deduce to the same type.</source>
          <target state="translated">리턴 문이 여러 개인 경우 모두 같은 유형으로 추론해야합니다.</target>
        </trans-unit>
        <trans-unit id="56e2a9dcbebace2c5e7ec9081f6a581a3eccd3f0" translate="yes" xml:space="preserve">
          <source>If there are no elements</source>
          <target state="translated">요소가없는 경우</target>
        </trans-unit>
        <trans-unit id="2be453c0735328c6008b2c9ff54809c970ae7dd0" translate="yes" xml:space="preserve">
          <source>If there are no elements, the behavior is undefined.</source>
          <target state="translated">요소가 없으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60124398219caa2545336ef3688db0d123bcef47" translate="yes" xml:space="preserve">
          <source>If there are no matches, copies the entire sequence into &lt;code&gt;out&lt;/code&gt; as-is, by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(first, last, out)&lt;/code&gt;</source>
          <target state="translated">일치되는 복사본으로 전체 시퀀스가 없으면 &lt;code&gt;out&lt;/code&gt; 하여, 그대로 &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(first, last, out)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="430a0a9ceb3976f6b074269c72597aae319e083f" translate="yes" xml:space="preserve">
          <source>If there are no more entries left in the currently iterated directory, the iteration is resumed over the parent directory. The process is repeated if the parent directory has no sibling entries that can to be iterated on. If the parent of the directory hierarchy that has been recursively iterated on is reached (there are no candidate entries at &lt;code&gt;depth() == 0)&lt;/code&gt;, &lt;code&gt;*this&lt;/code&gt; is set to an end iterator.</source>
          <target state="translated">현재 반복 된 디렉토리에 더 이상 항목이 남아 있지 않으면 반복이 상위 디렉토리에서 재개됩니다. 상위 디렉토리에 반복 할 수있는 형제 항목이없는 경우 프로세스가 반복됩니다. 재귀에 반복 된 디렉토리 계층의 상위에 도달하면 (에서 후보 항목이없는 &lt;code&gt;depth() == 0)&lt;/code&gt; , &lt;code&gt;*this&lt;/code&gt; 끝 반복자로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="786c19346a6501f7f519d77c25d16a5bd6120203" translate="yes" xml:space="preserve">
          <source>If there is no associated mutex or the mutex is not locked, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">연관된 뮤텍스가 없거나 뮤텍스가 잠기지 않은 경우 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt; 오류 코드와 함께 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd20e611e7f59595531f451ca3dfeabb2921c4e5" translate="yes" xml:space="preserve">
          <source>If there is no associated mutex, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">연관된 뮤텍스가없는 경우 오류 코드 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d214d3c80c859a6e49e6fef5913cd6a8474d164" translate="yes" xml:space="preserve">
          <source>If there is no corresponding call to &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt;, or if &lt;code&gt;va_end&lt;/code&gt; is not called before a function that calls &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; returns, the behavior is undefined.</source>
          <target state="translated">에 해당하는 전화가없는 경우 &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; 를 또는 &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; 가 있는 경우, 또는 &lt;code&gt;va_end&lt;/code&gt; 의이 통화가 기능하기 전에 호출되지 않습니다 &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; 를 또는 &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; 반환, 동작은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="82e2ba4ed8370caec8cb2a4375b819fec9dd1a0f" translate="yes" xml:space="preserve">
          <source>If there is no pattern match, returns a value of type &lt;code&gt;from_chars_result&lt;/code&gt; such that &lt;code&gt;ptr&lt;/code&gt; equals &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;ec&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;value&lt;/code&gt; is unmodified.</source>
          <target state="translated">어떠한 패턴 일치가 없으면, 형의 값 반환 &lt;code&gt;from_chars_result&lt;/code&gt; 하도록 &lt;code&gt;ptr&lt;/code&gt; 동일 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;ec&lt;/code&gt; 동일 &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;value&lt;/code&gt; 은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb2824bbf3f97be3e717eef3b6756fb7dd5b0ccf" translate="yes" xml:space="preserve">
          <source>If there is no return statement or if the argument of the return statement is a void expression, the declared return type must be either &lt;code&gt;decltype(auto)&lt;/code&gt;, in which case the deduced return type is &lt;code&gt;void&lt;/code&gt;, or (possibly cv-qualified) &lt;code&gt;auto&lt;/code&gt; , in which case the deduced return type is then (identically cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">리턴 명령문이 없거나 리턴 명령문의 인수가 void 표현식 인 경우 선언 된 리턴 유형은 &lt;code&gt;decltype(auto)&lt;/code&gt; 이어야합니다 .이 경우 추론 된 리턴 유형이 &lt;code&gt;void&lt;/code&gt; 또는 (아마도 cv-qualified) &lt;code&gt;auto&lt;/code&gt; 여야합니다 . 이 경우 추론 된 리턴 유형은 (동일하게 cv-qualified) &lt;code&gt;void&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9786fb90520614ec4de44d4ccd5a94337ce70dc0" translate="yes" xml:space="preserve">
          <source>If there is no value of type &lt;code&gt;To&lt;/code&gt; corresponding to the value representation produced, the behavior is undefined. If there are multiple such values, which value is produced is unspecified.</source>
          <target state="translated">생성 된 값 표현에 해당하는 &lt;code&gt;To&lt;/code&gt; 유형의 값이 없으면 동작이 정의되지 않습니다. 이러한 값이 여러 개인 경우 생성되는 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08e7e744ae0e0c5037802c6defe497d81baa4ef8" translate="yes" xml:space="preserve">
          <source>If there is not enough memory, the old memory block is not freed and null pointer is returned.</source>
          <target state="translated">메모리가 충분하지 않으면 이전 메모리 블록이 해제되지 않고 널 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="75b29d8574fca6602e9dfcd68f07686982e86cb2" translate="yes" xml:space="preserve">
          <source>If there is nothing on the left hand side of the &lt;code&gt;::&lt;/code&gt;, the lookup considers only declarations made in the global namespace scope (or introduced into the global namespace by a &lt;a href=&quot;namespace&quot;&gt;using declaration&lt;/a&gt;). This makes it possible to refer to such names even if they were hidden by a local declaration:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 의 왼쪽에 아무 것도 없으면 , 조회는 전역 네임 스페이스 범위에서 작성된 선언 만 &lt;a href=&quot;namespace&quot;&gt;사용&lt;/a&gt; 하거나 using 선언에 의해 전역 네임 스페이스에 도입 된 것으로 간주합니다 . 이를 통해 로컬 선언에 의해 숨겨진 경우에도 해당 이름을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a39354352c3a36abb4078e05bc0601edf6cd7f44" translate="yes" xml:space="preserve">
          <source>If there was a &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; operation X</source>
          <target state="translated">&lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; 작업 이있는 경우 X</target>
        </trans-unit>
        <trans-unit id="ad371531997ade6500f19cfb02b883b25ff79f63" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postcondition (&lt;code&gt;lock.owns_lock()==true&lt;/code&gt; and &lt;code&gt;lock.mutex()&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">이러한 함수가 사후 조건을 충족시키지 못하면 ( &lt;code&gt;lock.owns_lock()==true&lt;/code&gt; 및 &lt;code&gt;lock.mutex()&lt;/code&gt; 가 호출 스레드에 의해 잠김) &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. 예를 들어, 뮤텍스를 다시 잠그면 예외가 발생하면 이런 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b7c68c75d237fbfbeeafab70e579d60f492f831" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postcondition (&lt;code&gt;lock&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">이러한 함수가 사후 조건을 충족하지 못하면 ( 호출 스레드에 의해 &lt;code&gt;lock&lt;/code&gt; 이 잠김) &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. 예를 들어, 뮤텍스를 다시 잠그면 예외가 발생하면 이런 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e64ebeb583017ab34a1b336b3949d0e606ed7464" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postconditions (&lt;code&gt;lock.owns_lock()==true&lt;/code&gt; and &lt;code&gt;lock.mutex()&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">이러한 함수가 사후 조건을 충족시키지 못하면 ( &lt;code&gt;lock.owns_lock()==true&lt;/code&gt; 및 &lt;code&gt;lock.mutex()&lt;/code&gt; 가 호출 스레드에 의해 잠김) &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. 예를 들어, 뮤텍스를 다시 잠그면 예외가 발생하면 이런 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d1cce971ef81ebeb27b3f75282ca12f479c4a3" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postconditions (&lt;code&gt;lock&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">이러한 함수가 사후 조건을 충족시키지 못하면 ( 호출 스레드에 의해 &lt;code&gt;lock&lt;/code&gt; 이 잠김) &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. 예를 들어, 뮤텍스를 다시 잠그면 예외가 발생하면 이런 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d778c344c068708c3e9722504ddb91a10967713" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;codecvt&lt;/code&gt; facet does not define a conversion, no characters are converted. &lt;code&gt;to_next&lt;/code&gt; is set to be equal to &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; is unchanged, and &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">이 &lt;code&gt;codecvt&lt;/code&gt; 패싯이 변환을 정의하지 않으면 문자가 변환되지 않습니다. &lt;code&gt;to_next&lt;/code&gt; 가 동일하게 설정 &lt;code&gt;to&lt;/code&gt; , &lt;code&gt;state&lt;/code&gt; 변경하고, &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="aacf8a59ed2ae04fea1befba59a2f4989fe43a0b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;wstring_convert&lt;/code&gt; object was constructed without a user-supplied byte-error string, throws &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; on conversion failure.</source>
          <target state="translated">이 &lt;code&gt;wstring_convert&lt;/code&gt; 객체가 사용자 제공 바이트 오류 문자열없이 구성된 경우 변환 실패시 &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cbcd6f179051e3d4d790103a0692450f238f91b6" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;wstring_convert&lt;/code&gt; object was constructed without a user-supplied wide-error string, throws &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; on conversion failure.</source>
          <target state="translated">이 &lt;code&gt;wstring_convert&lt;/code&gt; 객체가 사용자 제공 와이드 오류 문자열없이 구성된 경우 변환 실패시 &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f6ba9b5bd88a92b215f9d46a302f511d4c0d3235" translate="yes" xml:space="preserve">
          <source>If this function is called after I/O has occurred on the standard stream, the behavior is implementation-defined: implementations range from no effect to destroying the read buffer.</source>
          <target state="translated">표준 스트림에서 I / O가 발생한 후이 함수가 호출되면 동작이 구현 정의됩니다. 구현은 영향을 미치지 않고 읽기 버퍼를 파괴하는 것까지 다양합니다.</target>
        </trans-unit>
        <trans-unit id="7ab8ebc954b0557ea6a9a5ccedd0ab0cb9a2ceb2" translate="yes" xml:space="preserve">
          <source>If this function is called twice on the same &lt;code&gt;obj&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">이 함수가 동일한 &lt;code&gt;obj&lt;/code&gt; 에서 두 번 호출 되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b1e8e769c369fe401942d10347ef2341bebc1e8" translate="yes" xml:space="preserve">
          <source>If transfer of control enters the scope of any automatic variables (e.g. by jumping forward over a declaration statement), the program is ill-formed (cannot be compiled), unless all variables whose scope is entered have.</source>
          <target state="translated">제어 전송이 자동 변수의 범위에 들어간 경우 (예 : 선언문 위로 건너 뛰어) 범위를 입력 한 모든 변수가 없으면 프로그램이 잘못 작성됩니다 (컴파일 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="9007006fca17d8a04caf552baacfbe914165d918" translate="yes" xml:space="preserve">
          <source>If transfer of control exits the scope of any automatic variables (e.g. by jumping backwards to a point before the declarations of such variables or by jumping forward out of a compound statement where the variables are scoped), the destructors are called for all variables whose scope was exited, in the order opposite to the order of their construction.</source>
          <target state="translated">제어 전송이 자동 변수의 범위를 벗어나는 경우 (예 : 그러한 변수를 선언하기 전의 지점으로 뒤로 이동하거나 변수가 범위가 지정된 복합 명령문에서 앞으로 점프하여) 범위를 갖는 모든 변수에 대해 소멸자가 호출됩니다. 건설 순서와 반대 순서로 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="96de619385ef72541fd42f53b710eb1ba726dc0a" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Key&lt;/code&gt;s are equal according to &lt;code&gt;Pred&lt;/code&gt;, &lt;code&gt;Hash&lt;/code&gt; must return the same value for both keys.</source>
          <target state="translated">이 경우 &lt;code&gt;Key&lt;/code&gt; 들에 따라 동일 &lt;code&gt;Pred&lt;/code&gt; 를 가산 , &lt;code&gt;Hash&lt;/code&gt; 두 키에 대해 동일한 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="21514f17271611919ab5d31d97737af032553cf0" translate="yes" xml:space="preserve">
          <source>If two conversion sequences are indistinguishable because they have the same rank, the following additional rules apply:</source>
          <target state="translated">순위가 같기 때문에 두 변환 시퀀스를 구분할 수없는 경우 다음과 같은 추가 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="236b56e175db6d0402c006ec6f6fe29bfcd434e0" translate="yes" xml:space="preserve">
          <source>If two or more overloads accept different pointer types, an overload for &lt;code&gt;std::nullptr_t&lt;/code&gt; is necessary to accept a null pointer argument.</source>
          <target state="translated">둘 이상의 과부하가 다른 포인터 유형 을 허용하는 경우 널 포인터 인수를 승인하려면 &lt;code&gt;std::nullptr_t&lt;/code&gt; 대한 과부하 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1df13f76013467c8d1808876f2f6ad361b81ec46" translate="yes" xml:space="preserve">
          <source>If two pointers are not specified to compare greater or compare equal, the result of the comparison is unspecified. The result may be nondeterministic, and need not be consistent even for multiple evaluations of the same expression with the same operands in the same execution of the program:</source>
          <target state="translated">더 크게 비교하거나 같게 비교하기 위해 두 개의 포인터를 지정하지 않으면 비교 결과가 지정되지 않습니다. 결과는 비 결정적 일 수 있으며 동일한 프로그램 실행에서 동일한 피연산자로 동일한 표현식을 여러 번 평가하더라도 일관성이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="54c474a432a885a9d80c638012c2da37dcdf5a0e" translate="yes" xml:space="preserve">
          <source>If two ranges have equivalent elements and are of the same length, then the ranges are lexicographically</source>
          <target state="translated">두 범위가 동일한 요소를 가지고 있고 길이가 같은 경우 범위는 사전 식으로</target>
        </trans-unit>
        <trans-unit id="dea9e99a4902829c785e86953d9771a67436d749" translate="yes" xml:space="preserve">
          <source>If two thread identifiers compare equal, they have identical textual representations; if they do not compare equal, their representations are distinct.</source>
          <target state="translated">두 개의 스레드 식별자가 동일하게 비교되면 동일한 텍스트 표현을 갖습니다. 그들이 동등하게 비교하지 않으면, 그들의 표현은 구별됩니다.</target>
        </trans-unit>
        <trans-unit id="44df2c42d0c8b0977cc12b1567332b861f35e2c9" translate="yes" xml:space="preserve">
          <source>If two union members are standard-layout types, it's well-defined to examine their common subsequence on any compiler.</source>
          <target state="translated">두 개의 Union 멤버가 표준 레이아웃 유형 인 경우 모든 컴파일러에서 공통 하위 시퀀스를 검사하는 것이 잘 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="905593757752d3cb5b8a000e5d6df93d8badb63b" translate="yes" xml:space="preserve">
          <source>If two using-declarations inherit the constructor with the same signature (from two direct base classes), the program is ill-formed.</source>
          <target state="translated">두 개의 사용 선언이 두 개의 직접 기본 클래스에서 동일한 서명을 가진 생성자를 상속하면 프로그램이 잘못 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="b3ee41429cd3e4ea61f8eae244494a1cc4dbc646" translate="yes" xml:space="preserve">
          <source>If type is an array type, an array of objects is initialized.</source>
          <target state="translated">type이 배열 유형 인 경우 객체 배열이 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="dfd366835c89e7a8dac1ada14ac3a1a2f256aa18" translate="yes" xml:space="preserve">
          <source>If type-constraint is &lt;code&gt;Concept&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt;, then the constraint expression &lt;code&gt;Concept&amp;lt;T, A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; must be valid and return &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">제약 형이면 &lt;code&gt;Concept&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; 다음 제약 식 &lt;code&gt;Concept&amp;lt;T, A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; 유효 반환해야 &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="37e1efeb1f04dd65befd738a35a8fbab85af47d5" translate="yes" xml:space="preserve">
          <source>If type-constraint is present, let &lt;code&gt;T&lt;/code&gt; be the type deduced for the placeholder, &lt;code&gt;T&lt;/code&gt; must satisfy the immediately-declared constraint of type-constraint. That is,</source>
          <target state="translated">타입 제약이있는 경우,하자 &lt;code&gt;T&lt;/code&gt; 는 , 자리 표시 자에 대한 추론 유형이 될 &lt;code&gt;T&lt;/code&gt; 는 타입 제약의 즉시 선언 제약 조건을 만족 있어야합니다. 그건,</target>
        </trans-unit>
        <trans-unit id="60c6cdefb849b977d1ac7bc22c41f84525eb69b1" translate="yes" xml:space="preserve">
          <source>If value-initialization in overload (1) is undesirable, for example, if the elements are of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="translated">오버로드 (1)의 값 초기화가 바람직하지 않은 경우, 예를 들어 요소가 비 클래스 유형이고 0이 필요하지 않은 경우 &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;사용자 지정 Allocator :: construct를&lt;/a&gt; 제공하면 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f66ab74451a3db452059ec3845f07a89e06bbf3" translate="yes" xml:space="preserve">
          <source>If wc is the null wide character &lt;code&gt;L'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">wc가 널 와이드 문자 &lt;code&gt;L'\0'&lt;/code&gt; 인 경우, 초기 시프트 상태를 복원하는 데 필요한 시프트 시퀀스가 ​​앞에 오는 널 바이트가 저장되고 변환 상태 매개 변수 &lt;code&gt;*ps&lt;/code&gt; 는 초기 시프트 상태를 나타내도록 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="32c015539aa6def36ac45f02ee69383d444c9a17" translate="yes" xml:space="preserve">
          <source>If width specifier is used, matches up to</source>
          <target state="translated">너비 지정자를 사용하는 경우 최대</target>
        </trans-unit>
        <trans-unit id="80643aeb5f10297c8773a32774b36761e19c9f6e" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">x가 0이고 y가 무한하거나 x가 무한하고 y가 0이고 z가 NaN이면 NaN이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="217b0f1a492e46dd9c7d22b89fac1d204972e19f" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">x가 0이고 y가 무한하거나 x가 무한하고 y가 0이고 z가 NaN이 아닌 경우 NaN이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="46f35d1f1e835536b48c1d1451cead305f826b6a" translate="yes" xml:space="preserve">
          <source>If x or y are NaN, NaN is returned</source>
          <target state="translated">x 또는 y가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="448389c4ec48e9adff6b8542b1d7d5e0005baf1b" translate="yes" xml:space="preserve">
          <source>If x*y is an exact infinity and z is an infinity with the opposite sign, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">x * y가 정확한 무한대이고 z가 반대 부호의 무한대이면 NaN이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3bdeffa5a91b0032e30c68e073ce8335607fac7a" translate="yes" xml:space="preserve">
          <source>If you do not have C++11, an equivalent to &lt;code&gt;std::find_if_not&lt;/code&gt; is to use &lt;code&gt;std::find_if&lt;/code&gt; with the negated predicate.</source>
          <target state="translated">당신이 C ++ (11)에 상응하지 않은 경우 &lt;code&gt;std::find_if_not&lt;/code&gt; 사용하는 &lt;code&gt;std::find_if&lt;/code&gt; 부정형 술어.</target>
        </trans-unit>
        <trans-unit id="dee1d062b9bd3ef2ac4463366425592d8bf6079d" translate="yes" xml:space="preserve">
          <source>If z is NaN, and x*y aren't 0*Inf or Inf*0, then NaN is returned (without FE_INVALID)</source>
          <target state="translated">z가 NaN이고 x * y가 0 * ​​Inf 또는 Inf * 0이 아닌 경우 NaN이 반환됩니다 (FE_INVALID없이).</target>
        </trans-unit>
        <trans-unit id="fede8b50b6882e5d3ce2a02e4778a6b33e6bfd1e" translate="yes" xml:space="preserve">
          <source>If |arg| &amp;gt; 1, a domain error occurs and NaN is returned.</source>
          <target state="translated">| arg | 인 경우 &amp;gt; 1이면 도메인 오류가 발생하고 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="19ae8a036da573c60fcd648999f547940ac705f3" translate="yes" xml:space="preserve">
          <source>If |k|&amp;gt;1, a domain error may occur</source>
          <target state="translated">| k |&amp;gt; 1이면 도메인 오류가 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f54d83c12cb912afe24330261b82ab51323c3c37" translate="yes" xml:space="preserve">
          <source>If |x| &amp;gt; 1, a domain error may occur</source>
          <target state="translated">| x | 인 경우 &amp;gt; 1, 도메인 오류가 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="124d00d6f3d9dc4a6bd589c99e1ea07d87b1c00a" translate="yes" xml:space="preserve">
          <source>If, after a using-directive was used to nominate some namespace, the namespace is extended and additional members and/or using-directives are added to it, those additional members and the additional namespaces are visible through the using-directive (in contrast with using-declaration).</source>
          <target state="translated">using-directive를 사용하여 일부 네임 스페이스를 지정한 후 네임 스페이스가 확장되고 추가 멤버 및 / 또는 using-directive가 추가되면 using-directive를 통해 추가 멤버 및 추가 네임 스페이스를 볼 수 있습니다. 사용 선언).</target>
        </trans-unit>
        <trans-unit id="f18ec98606b2fb57c51cf2d2b42ed110712ce687" translate="yes" xml:space="preserve">
          <source>If, after considering all pairs of overloaded templates, there is one that is unambiguously more specialized than all others, that template's specialization is selected, otherwise compilation fails.</source>
          <target state="translated">오버로드 된 모든 템플릿 쌍을 고려한 후 다른 템플릿보다 더 전문화 된 템플릿이 있으면 해당 템플릿의 전문화가 선택되고 그렇지 않으면 컴파일이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="18db54187de2ad0a31a7c5e4bdded4c034fc402d" translate="yes" xml:space="preserve">
          <source>If, after construction, the member &lt;code&gt;regex_iterator&lt;/code&gt; is not an end-of-sequence iterator, sets the member pointer to the address of the current &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">생성 후 멤버 &lt;code&gt;regex_iterator&lt;/code&gt; 가 시퀀스 끝 반복자가 아닌 경우 멤버 포인터를 현재 &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; 의 주소로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="24d2b4c0d32e555ffdf12e4f24627c557a463748" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">,에서 종료 널 문자를 복사 한 후 경우 &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; 에 도달하지 못한 추가 널 문자에 기록됩니다 &lt;code&gt;dest&lt;/code&gt; 의 총까지 &lt;code&gt;count&lt;/code&gt; 문자가 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="d6321b986a2eb461234e0b8b628d35dcf35b6aeb" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null wide character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null wide characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">,에서 종료 널 (null) 와이드 문자 복사 한 후 경우 &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; 에 도달하지 못한 추가 널 (null) 넓은 문자가 기록됩니다 &lt;code&gt;dest&lt;/code&gt; 의 총까지 &lt;code&gt;count&lt;/code&gt; 문자가 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="2b833da015ca09bbc003a6a35757746d54b28eaa" translate="yes" xml:space="preserve">
          <source>If, after overload resolution, the order of declaration of the aggregate's members does not match for the selected overload, the initialization of the parameter will be ill-formed.</source>
          <target state="translated">과부하 해결 후 집계 멤버 선언 순서가 선택한 과부하와 일치하지 않으면 매개 변수의 초기화가 잘못됩니다.</target>
        </trans-unit>
        <trans-unit id="4344e13bb6aa8857aeb8da90f2cfb52094846e93" translate="yes" xml:space="preserve">
          <source>If, after the using-declaration was used to take a member from a namespace, the namespace is extended and additional declarations for the same name are introduced, those additional declarations do not become visible through the using-declaration (in contrast with using-directive). One exception is when a using-declaration names a class template: partial specializations introduced later are effectively visible, because their &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt; proceeds through the primary template.</source>
          <target state="translated">using-declaration을 사용하여 네임 스페이스에서 멤버를 가져온 후 네임 스페이스가 확장되고 동일한 이름에 대한 추가 선언이 도입 된 경우 using-directive와는 달리 using-declaration을 통해 추가 선언이 표시되지 않습니다. ). 사용 선언이 클래스 템플리트의 이름을 지정할 때 한 가지 예외가 있습니다. 나중에 소개 된 부분 특수화는 &lt;a href=&quot;lookup&quot;&gt;조회&lt;/a&gt; 가 기본 템플리트를 통해 진행 되므로 효과적으로 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbce6be800bfbd414094242237e485ad6d751c14" translate="yes" xml:space="preserve">
          <source>If, by the time &lt;code&gt;call_once&lt;/code&gt; is called, &lt;code&gt;flag&lt;/code&gt; indicates that &lt;code&gt;f&lt;/code&gt; was already called, &lt;code&gt;call_once&lt;/code&gt; returns right away (such a call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">시간에 의해 경우 &lt;code&gt;call_once&lt;/code&gt; 이 라고하며, &lt;code&gt;flag&lt;/code&gt; 나타냅니다 &lt;code&gt;f&lt;/code&gt; 이미 불렀다, &lt;code&gt;call_once&lt;/code&gt; 의 반환은 즉시 (에 같은 전화 &lt;code&gt;call_once&lt;/code&gt; 이 로 알려져 있습니다</target>
        </trans-unit>
        <trans-unit id="515903e5cd9a30bdc013b27094038c879ea5e3ca" translate="yes" xml:space="preserve">
          <source>If, instead of a function body, the special syntax &lt;code&gt;= delete&amp;nbsp;;&lt;/code&gt; is used, the function is defined as</source>
          <target state="translated">함수 본문 대신 특수 구문 &lt;code&gt;= delete&amp;nbsp;;&lt;/code&gt; 이 함수는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1fcb027646c98dda89397bc3d304d3c40f2112ab" translate="yes" xml:space="preserve">
          <source>If, prior to this call, &lt;code&gt;*this&lt;/code&gt; has an associated mutex ((&lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; returns a non-null pointer) and has acquired ownership of it (&lt;code&gt;owns()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), the mutex is unlocked by calling &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 호출 전에 &lt;code&gt;*this&lt;/code&gt; 에 연관된 뮤텍스가 있고 (( &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; 는 널이 아닌 포인터를 리턴 함 &lt;code&gt;owns()&lt;/code&gt; 그 소유권을 획득 한 경우 ( owns () 는 &lt;code&gt;true&lt;/code&gt; 를 리턴 함 ), &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; 를 호출하여 뮤텍스가 잠금 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="cddfcce1d6482355377933166f2bf61ba8023df9" translate="yes" xml:space="preserve">
          <source>If, when this instance of &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; was constructed, a custom classification table was provided and the second argument to the constructor (the boolean &lt;code&gt;del&lt;/code&gt;) was &lt;code&gt;true&lt;/code&gt;, then this destructor executes &lt;code&gt;delete[] table()&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 인스턴스가 생성 될 때 사용자 정의 분류 테이블이 제공되고 생성자에 대한 두 번째 인수 (부울 &lt;code&gt;del&lt;/code&gt; )가 &lt;code&gt;true&lt;/code&gt; 이면 이 소멸자는 &lt;code&gt;delete[] table()&lt;/code&gt; 실행 합니다 .</target>
        </trans-unit>
        <trans-unit id="abf34976945e39546eb65c898c5e72a940d36da7" translate="yes" xml:space="preserve">
          <source>Ignore symlinks</source>
          <target state="translated">심볼릭 링크 무시</target>
        </trans-unit>
        <trans-unit id="3c9993c27a919660753159130e530c6cef6861a2" translate="yes" xml:space="preserve">
          <source>Ill-formed expression used in a template parameter type</source>
          <target state="translated">템플릿 매개 변수 유형에 사용되는 잘못된 형식의 식</target>
        </trans-unit>
        <trans-unit id="e25011561bbd556c89b469f62fed950e3e750d2a" translate="yes" xml:space="preserve">
          <source>Ill-formed expression used in the function type</source>
          <target state="translated">함수 유형에 사용 된 잘못된 형식의 표현식</target>
        </trans-unit>
        <trans-unit id="e769494ea641bd01735c8978b12dae80bc631fc2" translate="yes" xml:space="preserve">
          <source>Illegal byte sequence</source>
          <target state="translated">잘못된 바이트 시퀀스</target>
        </trans-unit>
        <trans-unit id="d87c7055340deb568caf4674b187c44939256ef2" translate="yes" xml:space="preserve">
          <source>Illustrates the difference in the matching algorithm between ECMAScript and POSIX regular expressions.</source>
          <target state="translated">ECMAScript와 POSIX 정규식 간의 일치 알고리즘의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="13da76356b1fa19b7292603df60cd8183deacc7b" translate="yes" xml:space="preserve">
          <source>Imbues &lt;code&gt;u&lt;/code&gt; with the locale &lt;code&gt;loc&lt;/code&gt;</source>
          <target state="translated">불어 넣는다 &lt;code&gt;u&lt;/code&gt; 로케일과 &lt;code&gt;loc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="1bec87acbedb55cac0fd8887b67c78afe18b54a1" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior control</source>
          <target state="translated">구현 정의 행동 제어</target>
        </trans-unit>
        <trans-unit id="dd1e3f977c02056ea472998c02c487e2316720f9" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior is controlled by &lt;code&gt;#pragma&lt;/code&gt; directive.</source>
          <target state="translated">구현 정의 동작은 &lt;code&gt;#pragma&lt;/code&gt; 지시문에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="baec7f3938747fde7fd91e8cd29d528dd3ee3a7c" translate="yes" xml:space="preserve">
          <source>Implementation defined class type. The name &lt;code&gt;proxy&lt;/code&gt; is for exposition only.</source>
          <target state="translated">구현 정의 클래스 유형. 이름 &lt;code&gt;proxy&lt;/code&gt; 는 박람회 전용입니다.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">구현 노트</target>
        </trans-unit>
        <trans-unit id="ac4df666d0cf4b162038d0ca49842cbe67665bba" translate="yes" xml:space="preserve">
          <source>Implementation properties</source>
          <target state="translated">구현 속성</target>
        </trans-unit>
        <trans-unit id="618e4b612934a7109a06661620d8dd64653307f6" translate="yes" xml:space="preserve">
          <source>Implementation test to check if setbuf() is supported on a dynamic strstream (output obtained with Sun Studio).</source>
          <target state="translated">동적 strstream (Sun Studio에서 얻은 출력)에서 setbuf ()가 지원되는지 확인하기위한 구현 테스트.</target>
        </trans-unit>
        <trans-unit id="4ba79c92bcb0daad8f101d0490ccc2e884002f26" translate="yes" xml:space="preserve">
          <source>Implementation-defined meaning, but POSIX XSI specifies that when set on a directory, only file owners may delete files even if the directory is writeable to others (used with &lt;code&gt;/tmp&lt;/code&gt;)</source>
          <target state="translated">구현 정의 의미이지만 POSIX XSI는 디렉토리에 설정된 경우 디렉토리를 다른 사람이 쓸 수있는 경우에도 파일 소유자 만 파일을 삭제할 수 있음을 지정합니다 ( &lt;code&gt;/tmp&lt;/code&gt; 와 함께 사용 )</target>
        </trans-unit>
        <trans-unit id="c4dfef564acdd2d91911e7e70e08d38d4e85e505" translate="yes" xml:space="preserve">
          <source>Implementation-defined native handle object.</source>
          <target state="translated">구현 정의 네이티브 핸들 객체.</target>
        </trans-unit>
        <trans-unit id="5df371b6c82001fdb73bd4a012e00b058a54aeba" translate="yes" xml:space="preserve">
          <source>Implementation-defined pathname format, auto-detected where possible</source>
          <target state="translated">가능한 경우 자동 감지되는 구현 정의 경로 이름 형식</target>
        </trans-unit>
        <trans-unit id="667c8eda998c1c080db13b731500db6f8a8c9f3c" translate="yes" xml:space="preserve">
          <source>Implementation-defined value. If &lt;code&gt;command&lt;/code&gt; is a null pointer, returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">구현 정의 값. 경우 &lt;code&gt;command&lt;/code&gt; 널 포인터이며, 명령 프로세서가 존재하는 경우에만 경우, 제로가 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2b90c22fbd261737448cc728280b9e1a0b2564f9" translate="yes" xml:space="preserve">
          <source>Implementation-defined.</source>
          <target state="translated">Implementation-defined.</target>
        </trans-unit>
        <trans-unit id="fc59b9097e566566bcbc34003e0d601ccd5cbd0c" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to avoid dynamic allocations for small objects, but such an optimization may only be applied to types for which &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_nothrow_move_constructible&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">작은 객체에 대한 동적 할당을 피하기 위해 구현이 권장되지만 이러한 최적화는 &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_nothrow_move_constructible&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 유형에만 적용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d4e582a58851ee6c4bb6dc2e172c7707251917f" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to declare the placeholders as if by &lt;code&gt;inline constexpr /*unspecified*/ _1;&lt;/code&gt;, although declaring them by &lt;code&gt;extern /*unspecified*/ _1;&lt;/code&gt; is still allowed by the standard.</source>
          <target state="translated">자리 표시자를 &lt;code&gt;inline constexpr /*unspecified*/ _1;&lt;/code&gt; &lt;code&gt;extern /*unspecified*/ _1;&lt;/code&gt; 선언했지만 ; 여전히 표준에 의해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc2283d4e61c94c8b4cf57a3cc3008b1c58fed08" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to not consider &lt;code&gt;p&lt;/code&gt; not existing to be an error.</source>
          <target state="translated">구현은 존재 하지 않는 &lt;code&gt;p&lt;/code&gt; 를 오류로 간주하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4cdbff21c557331fbffdc58f3ae0f283ef89f728" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to not provide any programmatic way to query, set, or modify the build level or to set or modify the violation handler.</source>
          <target state="translated">빌드 레벨을 쿼리, 설정 또는 수정하거나 위반 핸들러를 설정 또는 수정하는 프로그래밍 방식을 제공하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0fc00335f1f76568cf7bc5d27173b1a48e4839fb" translate="yes" xml:space="preserve">
          <source>Implementations are not permitted to declare library functions as &lt;code&gt;constexpr&lt;/code&gt; unless the standard says the function is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">표준에서 함수가 &lt;code&gt;constexpr&lt;/code&gt; 이라고 말하지 않는 한 구현에서는 라이브러리 함수를 &lt;code&gt;constexpr&lt;/code&gt; 로 선언 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cac6f663736c0881de57437359b44434cf63f3b6" translate="yes" xml:space="preserve">
          <source>Implementations may provide specializations of &lt;code&gt;std::numeric_limits&lt;/code&gt; for implementation-specific types: e.g. GCC provides &lt;code&gt;std::numeric_limits&amp;lt;__int128&amp;gt;&lt;/code&gt;. Non-standard libraries may &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;add specializations&lt;/a&gt; for library-provided types, e.g. &lt;a href=&quot;http://openexr.com/&quot;&gt;OpenEXR&lt;/a&gt; provides &lt;code&gt;std::numeric_limits&amp;lt;half&amp;gt;&lt;/code&gt; for a 16-bit floating-point type.</source>
          <target state="translated">구현은 구현 특정 유형에 대한 &lt;code&gt;std::numeric_limits&lt;/code&gt; 전문화를 제공 할 수 있습니다. 예를 들어 GCC는 &lt;code&gt;std::numeric_limits&amp;lt;__int128&amp;gt;&lt;/code&gt; 합니다. 비표준 라이브러리는 라이브러리 제공 유형에 대한 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;전문화&lt;/a&gt; 를 추가 할 수 있습니다 . 예를 들어 &lt;a href=&quot;http://openexr.com/&quot;&gt;OpenEXR&lt;/a&gt; 은 16 비트 부동 소수점 유형에 &lt;code&gt;std::numeric_limits&amp;lt;half&amp;gt;&lt;/code&gt; 를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="e11e78a73a7bdbeba97a62a3332a0fcaea58d4d7" translate="yes" xml:space="preserve">
          <source>Implementations that do not support C++17, but support &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;ISO 29124:2010&lt;/a&gt;, provide this function if &lt;code&gt;__STDCPP_MATH_SPEC_FUNCS__&lt;/code&gt; is defined by the implementation to a value at least 201003L and if the user defines &lt;code&gt;__STDCPP_WANT_MATH_SPEC_FUNCS__&lt;/code&gt; before including any standard library headers.</source>
          <target state="translated">C ++ 17을 지원하지만 지원하지 않는 구현 &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;2010 : ISO 29124&lt;/a&gt; , 경우이 기능을 제공 &lt;code&gt;__STDCPP_MATH_SPEC_FUNCS__&lt;/code&gt; 가 사용자 정의 값 적어도 201003L과 경우 구현에 의해 정의된다 &lt;code&gt;__STDCPP_WANT_MATH_SPEC_FUNCS__&lt;/code&gt; 표준 라이브러리의 헤더를 포함 전에.</target>
        </trans-unit>
        <trans-unit id="70e8f87cf29af9772a694ae2cede769b63d6dda0" translate="yes" xml:space="preserve">
          <source>Implementations that do not support ISO 29124:2010 but support TR 19768:2007 (TR1), provide this function in the header &lt;code&gt;tr1/cmath&lt;/code&gt; and namespace &lt;code&gt;std::tr1&lt;/code&gt;.</source>
          <target state="translated">ISO 29124 : 2010을 지원하지 않지만 TR 19768 : 2007 (TR1)을 지원하는 구현은 헤더 &lt;code&gt;tr1/cmath&lt;/code&gt; 및 네임 스페이스 &lt;code&gt;std::tr1&lt;/code&gt; 에이 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="773665687bef6caf01efcdb3d35a7cb85d3b76c9" translate="yes" xml:space="preserve">
          <source>Implementations usually guarantee precision of less than 1 ulp (units in the last place): &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt;, &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text/plain&quot;&gt;BSD&lt;/a&gt;, &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt;.</source>
          <target state="translated">구현은 일반적으로 &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt; , &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text/plain&quot;&gt;BSD&lt;/a&gt; , &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt; 와 같은 1ulp ( 마지막 위치의 단위) 미만의 정밀도를 보장 합니다.</target>
        </trans-unit>
        <trans-unit id="7c1270f12ce6696248d9babe2729d237c7e58364" translate="yes" xml:space="preserve">
          <source>Implements the analogs of the unary arithmetic operators for complex numbers.</source>
          <target state="translated">복소수에 대한 단항 산술 연산자의 아날로그를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ecc1f13a5483ad5061a47e46d970f730cb42f7e5" translate="yes" xml:space="preserve">
          <source>Implements the binary operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero.</source>
          <target state="translated">복소수 연산 및 혼합 복소수 / 스칼라 연산에 대한 이진 연산자를 구현합니다. 스칼라 인수는 실수 부분이 인수와 같고 허수 부분이 0으로 설정된 복소수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c4afda3b855163af9d0d3b6360d184e0bdc5cd94" translate="yes" xml:space="preserve">
          <source>Implements the compound assignment operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero.</source>
          <target state="translated">복소수 산술 및 혼합 복소수 / 스칼라 산술에 대한 복합 할당 연산자를 구현합니다. 스칼라 인수는 실수 부분이 인수와 같고 허수 부분이 0으로 설정된 복소수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="7b890ec344a13c8ecc3220d297694526da2518e7" translate="yes" xml:space="preserve">
          <source>Implements unary plus and unary minus for the durations.</source>
          <target state="translated">기간 동안 단항 더하기 및 단항 빼기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="978783100f08201e0e5529544f86d4a285682f97" translate="yes" xml:space="preserve">
          <source>Implicit conversion sequence consists of the following, in this order:</source>
          <target state="translated">암시 적 변환 순서는 다음 순서로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1429b69e907debf636007c5f2b2aa8f332893f57" translate="yes" xml:space="preserve">
          <source>Implicit conversion sequence in list-initialization</source>
          <target state="translated">목록 초기화의 암시 적 변환 순서</target>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">암시 적 변환</target>
        </trans-unit>
        <trans-unit id="46354cbf9b435d43405dcf0d28126a074735a10d" translate="yes" xml:space="preserve">
          <source>Implicit conversions are performed whenever an expression of some type &lt;code&gt;T1&lt;/code&gt; is used in context that does not accept that type, but accepts some other type &lt;code&gt;T2&lt;/code&gt;; in particular:</source>
          <target state="translated">일부 유형 &lt;code&gt;T1&lt;/code&gt; 의 표현식이 해당 유형을 허용하지 않지만 다른 유형 &lt;code&gt;T2&lt;/code&gt; 를 허용하는 컨텍스트에서 사용될 때마다 암시 적 변환이 수행 됩니다 . 특히:</target>
        </trans-unit>
        <trans-unit id="c7e1233543f67ff6021074ff2ae9773f138a2071" translate="yes" xml:space="preserve">
          <source>Implicit conversions between two durations normally depends on the tick period of the durations. However, implicit conversions can happen regardless of tick period if &lt;code&gt;std::chrono::treat_as_floating_point&amp;lt;Rep&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">두 기간 사이의 암시 적 변환은 일반적으로 기간의 틱 기간에 따라 다릅니다. 그러나 &lt;code&gt;std::chrono::treat_as_floating_point&amp;lt;Rep&amp;gt;::value == true&lt;/code&gt; 경우 틱 기간에 관계없이 암시 적 변환이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cff2a76253e4ae1d3384d748888091cc614f0787" translate="yes" xml:space="preserve">
          <source>Implicit expression variations</source>
          <target state="translated">암시 적 표현 변형</target>
        </trans-unit>
        <trans-unit id="6deeab06530145f211662ed2cb9cf74741af72c3" translate="yes" xml:space="preserve">
          <source>Implicit instantiation</source>
          <target state="translated">암시 적 인스턴스화</target>
        </trans-unit>
        <trans-unit id="46c4cf71d06da185f299f0f266b516eb714362c2" translate="yes" xml:space="preserve">
          <source>Implicitly declared copy assignment operator</source>
          <target state="translated">암시 적으로 선언 된 복사 할당 연산자</target>
        </trans-unit>
        <trans-unit id="f3b3376d1419db08d028d5d3e6c6df0f0035aa37" translate="yes" xml:space="preserve">
          <source>Implicitly declared destructor</source>
          <target state="translated">암시 적으로 선언 된 소멸자</target>
        </trans-unit>
        <trans-unit id="0562f19403fee4205b21d8bb018af2a9b080047c" translate="yes" xml:space="preserve">
          <source>Implicitly-declared and user-defined non-explicit &lt;a href=&quot;copy_constructor&quot;&gt;copy constructors&lt;/a&gt; and &lt;a href=&quot;move_constructor&quot;&gt;move constructors&lt;/a&gt; are converting constructors.</source>
          <target state="translated">암시 적으로 선언되고 사용자 정의 된 비명 시적 &lt;a href=&quot;copy_constructor&quot;&gt;복사 생성자&lt;/a&gt; 와 &lt;a href=&quot;move_constructor&quot;&gt;이동 생성자&lt;/a&gt; 가 생성자 를 변환하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="29a6f3e1205f66c508c2094943ddce2c63b0df90" translate="yes" xml:space="preserve">
          <source>Implicitly-declared copy assignment operator</source>
          <target state="translated">암시 적으로 선언 된 복사 할당 연산자</target>
        </trans-unit>
        <trans-unit id="a6d4013875adefe27157f85be3bba73a81597a9f" translate="yes" xml:space="preserve">
          <source>Implicitly-declared copy constructor</source>
          <target state="translated">암시 적으로 선언 된 복사 생성자</target>
        </trans-unit>
        <trans-unit id="88095a2668d811c3785a1fa8299728b3a2949e56" translate="yes" xml:space="preserve">
          <source>Implicitly-declared default constructor</source>
          <target state="translated">암시 적으로 선언 된 기본 생성자</target>
        </trans-unit>
        <trans-unit id="58d35239637c6ad0d309cc3ac73e345488ae6f80" translate="yes" xml:space="preserve">
          <source>Implicitly-declared destructor</source>
          <target state="translated">암시 적으로 선언 된 소멸자</target>
        </trans-unit>
        <trans-unit id="a122664f9fa35a0ead17f50a517e4e30c5f78e62" translate="yes" xml:space="preserve">
          <source>Implicitly-declared move assignment operator</source>
          <target state="translated">암시 적으로 선언 된 이동 할당 연산자</target>
        </trans-unit>
        <trans-unit id="2c98bb0a4aaf09d346ed78f5a0b9b9a10f6c45be" translate="yes" xml:space="preserve">
          <source>Implicitly-declared move constructor</source>
          <target state="translated">암시 적으로 선언 된 이동 생성자</target>
        </trans-unit>
        <trans-unit id="2deeed834989276fef215f6f2897d39d3740f2f0" translate="yes" xml:space="preserve">
          <source>Implicitly-defined copy assignment operator</source>
          <target state="translated">암시 적으로 정의 된 복사 할당 연산자</target>
        </trans-unit>
        <trans-unit id="d011d88c050a6f60568345047d29ebc388337773" translate="yes" xml:space="preserve">
          <source>Implicitly-defined copy constructor</source>
          <target state="translated">암시 적으로 정의 된 복사 생성자</target>
        </trans-unit>
        <trans-unit id="fa97e996fd2560cf2c05804b139c35767f0e76e5" translate="yes" xml:space="preserve">
          <source>Implicitly-defined default constructor</source>
          <target state="translated">암시 적으로 정의 된 기본 생성자</target>
        </trans-unit>
        <trans-unit id="061bd07a1bb1a33b801c708770977b87d559dec3" translate="yes" xml:space="preserve">
          <source>Implicitly-defined destructor</source>
          <target state="translated">암시 적으로 정의 된 소멸자</target>
        </trans-unit>
        <trans-unit id="2904db3125ebf0c63383992eb2b2968ba47ba5e2" translate="yes" xml:space="preserve">
          <source>Implicitly-defined member functions</source>
          <target state="translated">암시 적으로 정의 된 멤버 함수</target>
        </trans-unit>
        <trans-unit id="e45913a1e2322cc7a36b3505067db026e25257da" translate="yes" xml:space="preserve">
          <source>Implicitly-defined move assignment operator</source>
          <target state="translated">암시 적으로 정의 된 이동 할당 연산자</target>
        </trans-unit>
        <trans-unit id="4ebcbcc97e562ec198f2e53e43d491b81d9344ee" translate="yes" xml:space="preserve">
          <source>Implicitly-defined move constructor</source>
          <target state="translated">암시 적으로 정의 된 이동 생성자</target>
        </trans-unit>
        <trans-unit id="2f48272a7bcd8ca888d2cfc92fd1bc8b4d291257" translate="yes" xml:space="preserve">
          <source>Implicitly-generated deduction guides</source>
          <target state="translated">암시 적으로 생성 된 추론 가이드</target>
        </trans-unit>
        <trans-unit id="27328a2eb2f15815a68b1653d19575045b8cf992" translate="yes" xml:space="preserve">
          <source>In 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type int, INT_MIN is -2147483648, but the would-be result 2147483648 is greater than INT_MAX, which is 2147483647.</source>
          <target state="translated">2의 보수 시스템에서 가장 음의 값의 절대 값이 범위를 벗어났습니다 (예 : 32 비트 2의 보수 유형 int의 경우 INT_MIN은 -2147483648이지만 결과는 2147483648은 INT_MAX보다 큽니다)는 2147483647입니다.</target>
        </trans-unit>
        <trans-unit id="b5fd98f8c63f3d298c51c647d77132a000415d4f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;, when a namespace is added to the set of associated namespaces, its inline namespaces are added as well, and if an inline namespace is added to the list of associated namespaces, its enclosing namespace is added as well.</source>
          <target state="translated">에서는 &lt;a href=&quot;adl&quot;&gt;인자 의존적 룩업&lt;/a&gt; 네임 스페이스와 연관된 네임 스페이스 세트에 추가되면, 그 인라인 네임이 아니라 첨가하고, 인라인 네임 스페이스와 연관된 네임의리스트에 추가되는 경우, 그 둘러싸는 공간이 아니라 첨가한다.</target>
        </trans-unit>
        <trans-unit id="9fd1e0ac5e63fbea64f332e88d4780d848f55564" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; and &lt;a href=&quot;constant_initialization&quot;&gt;constant initialization&lt;/a&gt;, return value optimization (RVO) is guaranteed, however, named return value optimization (NRVO) is forbidden (note: this is specified by post-C++14 defect report CWG 2022 and reversed by defect report CWG 2278):</source>
          <target state="translated">에서 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현&lt;/a&gt; 및 &lt;a href=&quot;constant_initialization&quot;&gt;일정 초기화&lt;/a&gt; 보장, 반환 값 최적화 (RVO), 그러나, 이름 반환 값 최적화 (NRVO)는 (금지주의 : 이것은 결함 보고서 CWG에 의해 사후 C ++ 14 결함 보고서 CWG 2022 년 지정 반전 2278) :</target>
        </trans-unit>
        <trans-unit id="4438658486a8aa1c2ccb17440e6244e19bb12c43" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;coroutines&quot;&gt;coroutines&lt;/a&gt;, copy/move of the parameter into coroutine state may be elided where this does not change the behavior of the program other than by omitting the calls to the parameter's constructor and destructor. This can take place if the parameter is never referenced after a suspension point or when the entire coroutine state was never heap-allocated in the first place.</source>
          <target state="translated">에서 &lt;a href=&quot;coroutines&quot;&gt;코 루틴&lt;/a&gt; ,이 매개 변수의 생성자와 소멸자에 대한 호출을 생략하여 이외의 프로그램의 동작을 변경하지 않는 경우 코 루틴 상태로 매개 변수의 / 이동이 생략 될 수 있습니다 복사합니다. 서스펜션 지점 이후에 매개 변수가 참조되지 않거나 전체 코 루틴 상태가 처음에 힙 할당되지 않은 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="752b262a5dc8786ae6cab7940e196fea49ff6ccb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;fold&quot;&gt;fold-expressions&lt;/a&gt;, the pattern is the entire subexpression that does not contain an unexpanded parameter pack.</source>
          <target state="translated">에서 &lt;a href=&quot;fold&quot;&gt;접이식 표현&lt;/a&gt; , 패턴은 확장되지 않은 매개 변수 팩을 포함하지 않는 전체 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="2242cd439921fc4c92bc135cffe3759d57213422" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt;, the argument is a braced-init-list, which isn't an expression, so the implicit conversion sequence into the parameter type for the purpose of overload resolution is decided by the following special rules:</source>
          <target state="translated">에서 &lt;a href=&quot;list_initialization&quot;&gt;목록 초기화&lt;/a&gt; , 인수는 오버로드 확인하기위한 목적으로 매개 변수 유형으로 암시 적 변환 순서는 다음과 같은 특별 규정에 의해 결정되도록 표현이 아닌 보강-INIT-목록입니다 :</target>
        </trans-unit>
        <trans-unit id="1cc4dbef738efa286661d780a703351be8b0b7f1" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Best_viable_function&quot;&gt;overload resolution&lt;/a&gt;, partial ordering takes precedence over whether a function template is generated from a guide: if the function template generated from the constructor is more specialized than the one generated from the deduction guide, the one generated from the constructor is chosen. Because the copy deduction candidate is typically more specialized than a wrapping constructor, this rule means that copying is generally preferred over wrapping.</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Best_viable_function&quot;&gt;오버로드 확인&lt;/a&gt; , 부분 순서는 함수 템플릿이 가이드에서 생성되는지 여부보다 우선합니다 : 생성자에서 생성 된 함수 템플릿을 더 공제 가이드에서 생성 한 생성자가 선택에서 생성 한보다 전문합니다. 복사 추론 후보는 일반적으로 랩핑 생성자보다 더 전문화되어 있기 때문에이 규칙은 일반적으로 랩핑보다 복사가 선호됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4809c5e41e7473cccbc72a4bb155bdc02191303e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every combination of types &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, where class type &lt;code&gt;B&lt;/code&gt; is either the same class as &lt;code&gt;D&lt;/code&gt; or an unambiguous and accessible base class of &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;R&lt;/code&gt; is either an object or function type, the following function signature participates in overload resolution:</source>
          <target state="translated">에서는 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 연산자에 대한 과부하 해상도&lt;/a&gt; 유형의 각 조합에 대해, &lt;code&gt;D&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; 클래스 타입, &lt;code&gt;B&lt;/code&gt; 는 같은 클래스 중 하나 인 &lt;code&gt;D&lt;/code&gt; 또는 명백한 접근 기본 클래스 &lt;code&gt;D&lt;/code&gt; 가 , 그리고 &lt;code&gt;R&lt;/code&gt; 은 어느 객체 또는 함수 타입 다음 함수 서명은 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="624c4590775fbf40a4b7d04856d19fc9508c5fa6" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every object type &lt;code&gt;T&lt;/code&gt; (possibly cv-qualified), the following function signature participates in overload resolution:</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 사업자에 대한 오버로드 확인&lt;/a&gt; , 모든 객체 유형에 대한 &lt;code&gt;T&lt;/code&gt; (아마도 이력서 자격), 오버로드 확인에 다음 함수 서명 참여하는 :</target>
        </trans-unit>
        <trans-unit id="307ea5bb116870783914632b4b12d175efc040fc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every optionally volatile-qualified arithmetic type &lt;code&gt;A&lt;/code&gt; other than &lt;code&gt;bool&lt;/code&gt;, and for every optionally volatile-qualified pointer &lt;code&gt;P&lt;/code&gt; to optionally cv-qualified object type, the following function signatures participate in overload resolution:</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 사업자에 대한 오버로드 확인&lt;/a&gt; , 모든 선택적 휘발성 자격을 갖춘 산술 형에 대한 이외의 &lt;code&gt;bool&lt;/code&gt; , 모든 선택적 휘발성 자격 포인터에 대한 &lt;code&gt;P&lt;/code&gt; 선택적으로의 이력서 자격을 갖춘 객체 유형, 다음 함수 서명은 오버로드 확인에 참여 : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5990cf25ac820a864a2b308a05c41a666871b396" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair A1 and A2, where A1 is an arithmetic type (optionally volatile-qualified) and A2 is a promoted arithmetic type, the following function signatures participate in overload resolution:</source>
          <target state="translated">에서는 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 연산자에 대한 과부하 해상도&lt;/a&gt; 모든 쌍 A1 산술 형 (임의로 휘발성 정규화)이며 A2가 촉진 산술 타입 A1 및 A2에 대해, 다음과 같은 기능 서명 과부하 해석에 참가 :</target>
        </trans-unit>
        <trans-unit id="8d3869a5bce1a140062b4b7e7874a7e2f0b63bc7" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; and for every object type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">에서는 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의에 대한 연산자 과부하 해상도&lt;/a&gt; 촉진 산술 유형의 모든 쌍에 대해, &lt;code&gt;L&lt;/code&gt; 및 &lt;code&gt;R&lt;/code&gt; 모든 오브젝트 유형에 대한 &lt;code&gt;T&lt;/code&gt; 다음 함수 서명 과부하 해석에 참가 :</target>
        </trans-unit>
        <trans-unit id="b24752ca21e578d5ccc2e9cc894a56665fc96230" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;, including enumeration types, the following function signatures participate in overload resolution:</source>
          <target state="translated">에서는 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의에 대한 연산자 과부하 해상도&lt;/a&gt; 촉진 산술 형식의 각 쌍에 대해, &lt;code&gt;L&lt;/code&gt; 및 &lt;code&gt;R&lt;/code&gt; 열거 타입을 포함, 다음 함수 서명 과부하 해석에 참가 :</target>
        </trans-unit>
        <trans-unit id="fd26ab1ed7c9b56dae3b9425960ee35cb9730a3f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;LA&lt;/code&gt; and &lt;code&gt;RA&lt;/code&gt; and for every pair of promoted integral types &lt;code&gt;LI&lt;/code&gt; and &lt;code&gt;RI&lt;/code&gt; the following function signatures participate in overload resolution:</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자가 정의한 통신 사업자에 오버로드 확인&lt;/a&gt; 승진 산술 종류의 모든 쌍, &lt;code&gt;LA&lt;/code&gt; 와 &lt;code&gt;RA&lt;/code&gt; 및 추진 정수형의 모든 쌍 &lt;code&gt;LI&lt;/code&gt; 및 &lt;code&gt;RI&lt;/code&gt; 다음 함수 서명 과부하 해석에 참가 :</target>
        </trans-unit>
        <trans-unit id="f476dbd74c2f442c1c2e2829bce88b4a88341d7d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted integral types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; the following function signatures participate in overload resolution:</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 사업자에 대한 오버로드 확인&lt;/a&gt; , 승진 통합 유형의 모든 쌍에 대해 &lt;code&gt;L&lt;/code&gt; 과 &lt;code&gt;R&lt;/code&gt; 다음 함수 서명은 오버로드 확인에 참여 :</target>
        </trans-unit>
        <trans-unit id="eb835b282c835e4cba40899b90f1b4b1b4026a72" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted integral types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 사업자에 대한 오버로드 확인&lt;/a&gt; 승진 통합 유형의 모든 쌍, &lt;code&gt;L&lt;/code&gt; 과 &lt;code&gt;R&lt;/code&gt; , 다음 함수 서명은 오버로드 확인에 참여 :</target>
        </trans-unit>
        <trans-unit id="c4a93fe8e1bc45c860bc0b892d8c877cf026beb8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every promoted arithmetic type &lt;code&gt;A&lt;/code&gt; and for every type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 사업자에 대한 오버로드 확인&lt;/a&gt; , 모든 승진 산술 유형 및 모든 유형 &lt;code&gt;T&lt;/code&gt; , 다음 함수 서명은 오버로드 확인에 참여 : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb2d8e1a38d1a77a396a0e77f09d5580ac4be3ba" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every type &lt;code&gt;T&lt;/code&gt; that is either object type (possibly cv-qualified) or function type (not const- or ref-qualified), the following function signature participates in overload resolution:</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 사업자에 대한 오버로드 확인&lt;/a&gt; 모든 유형에 대한, &lt;code&gt;T&lt;/code&gt; 중 객체 유형 (아마도 이력서 자격) 또는 (const- 또는 심판 자격을 갖춘되지 않음) 기능의 유형, 오버로드 확인에 다음 함수 서명 참여하는 :</target>
        </trans-unit>
        <trans-unit id="401b7699fa1e8e938b279018437f1606b4040a67" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 사업자에 대한 오버로드 확인&lt;/a&gt; , 모든 종류의에 대한 &lt;code&gt;T&lt;/code&gt; , 다음 함수 서명은 오버로드 확인에 참여 :</target>
        </trans-unit>
        <trans-unit id="0c2aad84e7da44f63319332803f4b852d30346b4" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for pointer or enumeration type &lt;code&gt;T&lt;/code&gt;, the following function signature participates in overload resolution:</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 사업자에 대한 오버로드 확인&lt;/a&gt; 포인터 나 열거 형에 대한, &lt;code&gt;T&lt;/code&gt; , 오버로드 확인에 다음 함수 서명 참여하는 :</target>
        </trans-unit>
        <trans-unit id="5cea19a589fd752a8bdd766f6cd3803387a4d265" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, the following built-in function signatures participate in overload resolution:</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 사업자에 대한 오버로드 확인&lt;/a&gt; , 내장 다음 함수 서명은 오버로드 확인에 참여 :</target>
        </trans-unit>
        <trans-unit id="ee813279dc64b0e3db6b8e7e767214afb0a3c85c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, this operator does not introduce any additional function signatures: built-in address-of operator does not apply if there exists an overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt; that is a &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;viable function&lt;/a&gt;.</source>
          <target state="translated">에서 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 사업자에 오버로드 확인&lt;/a&gt; 이 운영자는 추가 기능의 서명을 소개하지 않습니다 거기에 오버로드가있는 경우에는 적용되지 않습니다 연산자 주소의 내장 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 그가 있습니다 &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;가능한 기능&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd138803f2292cc51a5e2969a85f684f859f9f88" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;, ellipsis may appear in the list of declarators, this is useful when deriving from a parameter pack:</source>
          <target state="translated">에서 &lt;a href=&quot;using_declaration&quot;&gt;선언을 사용하여&lt;/a&gt; 매개 변수 팩에서 파생 때, 줄임표는 선언자 목록에 나타날 수 있습니다,이 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="c58f1f0803bbe584686a6a997ca2d9633a806b36" translate="yes" xml:space="preserve">
          <source>In C prior to C99 (but not in C++), unsuffixed decimal values that do not fit in &lt;code&gt;long int&lt;/code&gt; are allowed to have the type &lt;code&gt;unsigned long int&lt;/code&gt;.</source>
          <target state="translated">C99 이전의 C (C ++에서는 아님)에서 &lt;code&gt;long int&lt;/code&gt; 에 맞지 않는 접미사없는 10 진수 값은 &lt;code&gt;unsigned long int&lt;/code&gt; 유형을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11a679b4f1f70ac38a1af627d070d394e3b260d2" translate="yes" xml:space="preserve">
          <source>In C++, unlike C, variables cannot be declared &lt;code&gt;register&lt;/code&gt;.</source>
          <target state="translated">C ++에서는 C와 달리 변수를 &lt;code&gt;register&lt;/code&gt; 로 선언 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9036e8af52064611d82c261ee7c4ae9a4cdd7015" translate="yes" xml:space="preserve">
          <source>In C++11 and C++14 it is valid to construct a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">C ++ 11 및 C ++ 14에서는 &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; &amp;lt;T []&amp;gt; 에서 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 을 구성하는 것이 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="d7851c45dc812ab508d940b1e3b960f585dcd4c8" translate="yes" xml:space="preserve">
          <source>In C++11, &lt;code&gt;broken_promise&lt;/code&gt; was specified to equal zero despite &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; using zero to mean &quot;no error&quot;. This was fixed in C++14.</source>
          <target state="translated">C ++ 11에서, &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 에도 불구하고 &lt;code&gt;broken_promise&lt;/code&gt; 는 0이되도록 지정되었습니다 . &quot;오류 없음&quot;을 의미합니다. 이것은 C ++ 14에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="c2a0733225045f42e4ffac4f7cced1fd8bd01edc" translate="yes" xml:space="preserve">
          <source>In C++11, expressions that:</source>
          <target state="translated">C ++ 11에서 다음과 같은 표현식 :</target>
        </trans-unit>
        <trans-unit id="8a471ce8454b0c44c542d11c1ba3841025440979" translate="yes" xml:space="preserve">
          <source>In C++11, these constants were specified with redundant keyword &lt;code&gt;static&lt;/code&gt;, which was removed by C++14 via &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2053&quot;&gt;LWG issue 2053&lt;/a&gt;.</source>
          <target state="translated">C ++ 11에서 이러한 상수는 중복 키워드 &lt;code&gt;static&lt;/code&gt; 으로 지정되었으며 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2053&quot;&gt;LWG 이슈 2053을&lt;/a&gt; 통해 C ++ 14에 의해 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="984160a3e04fdf728c84931473e5065db87d2de8" translate="yes" xml:space="preserve">
          <source>In C++17, &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt; was made mandatory in some situations, and that required separation of prvalue expressions from the temporary objects initialized by them, resulting in the system we have today. Note that, in contrast with the C++11 scheme, prvalues are no longer moved from.</source>
          <target state="translated">C ++ 17에서는 일부 상황에서 &lt;a href=&quot;copy_elision&quot;&gt;복사 제거&lt;/a&gt; 가 필수적이었으며, 임시 값에서 prvalue 표현식을 분리해야했기 때문에 오늘날 시스템이 만들어졌습니다. C ++ 11 구성표와 달리 prvalue는 더 이상 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f1bbad23b5985f92e8fd5da90bac9e6e27f0dfa" translate="yes" xml:space="preserve">
          <source>In C++98 prior to C++03 (which introduced value initialization), the expression &lt;code&gt;new T()&lt;/code&gt; was classified as default initialization and specified zero-initialization.</source>
          <target state="translated">C ++ 03 (값 초기화를 도입 한) 이전의 C ++ 98에서 &lt;code&gt;new T()&lt;/code&gt; 표현식 은 기본 초기화로 분류되고 0으로 초기화되었습니다.</target>
        </trans-unit>
        <trans-unit id="9476240519883d62813958bad1862fa3943959d8" translate="yes" xml:space="preserve">
          <source>In C++98/C++03, if an error occurs, &lt;code&gt;v&lt;/code&gt; is left unchanged. In C++11, it is set to a value as described above.</source>
          <target state="translated">C ++ 98 / C ++ 03에서 오류가 발생하면 &lt;code&gt;v&lt;/code&gt; 는 변경되지 않습니다. C ++ 11에서는 위에서 설명한대로 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5a00b4bd83d09e5862a084a0513a75ec121bbf2e" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;putc()&lt;/code&gt; may be implemented as a macro, which is disallowed in C++. Therefore calls to &lt;code&gt;std::fputc()&lt;/code&gt; and &lt;code&gt;std::putc()&lt;/code&gt; always have the same effect.</source>
          <target state="translated">C에서 &lt;code&gt;putc()&lt;/code&gt; 는 C ++에서 허용되지 않는 매크로로 구현 될 수 있습니다. 따라서 &lt;code&gt;std::fputc()&lt;/code&gt; 및 &lt;code&gt;std::putc()&lt;/code&gt; 호출은 항상 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="cf9734438af23c6dfb132972af4a721d26ce5a2e" translate="yes" xml:space="preserve">
          <source>In C, character array of size one less than the size of the string literal may be initialized from a string literal; the resulting array is not null-terminated. This is not allowed in C++.</source>
          <target state="translated">C에서, 문자열 리터럴의 크기보다 하나 작은 크기의 문자 배열은 문자열 리터럴에서 초기화 될 수 있습니다. 결과 배열은 null로 끝나지 않습니다. C ++에서는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38e0a2f5a0dd182661a588f644d0e761c91db444" translate="yes" xml:space="preserve">
          <source>In C, character constants such as &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt; have type &lt;code&gt;int&lt;/code&gt;, rather than &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">C에서 &lt;code&gt;'a'&lt;/code&gt; 또는 &lt;code&gt;'\n'&lt;/code&gt; 과 같은 문자 상수 는 &lt;code&gt;char&lt;/code&gt; 대신 &lt;code&gt;int&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="c022ffe44f1e1cb8c1253d8ca27c1f6f5d7901e9" translate="yes" xml:space="preserve">
          <source>In C, inline functions do not have to be declared inline in every translation unit (at most one may be non-inline or extern inline), the function definitions do not have to be identical (but the behavior of the program must not depend on which one is called), and the function-local statics are distinct between different definitions of the same function.</source>
          <target state="translated">C에서 인라인 함수는 모든 변환 단위에서 인라인으로 선언 될 필요가 없으며 (대부분은 인라인이 아닌 인턴 또는 인턴 인라인 일 수 있음) 함수 정의가 동일 할 필요는 없습니다 (그러나 프로그램의 동작은 어떤 함수가 호출되는지) 함수 로컬 정적은 동일한 함수의 서로 다른 정의간에 구별됩니다.</target>
        </trans-unit>
        <trans-unit id="c2835e1b41b93ce6d5849cf55c8cf7a0e81c4f48" translate="yes" xml:space="preserve">
          <source>In C, string literals are of type &lt;code&gt;char[]&lt;/code&gt;, and can be assigned directly to a (non-const) &lt;code&gt;char*&lt;/code&gt;. C++03 allowed it as well (but deprecated it, as literals are &lt;code&gt;const&lt;/code&gt; in C++). C++11 no longer allows such assignments without a cast.</source>
          <target state="translated">C에서 문자열 리터럴은 &lt;code&gt;char[]&lt;/code&gt; 유형 이며 (const가 아닌) &lt;code&gt;char*&lt;/code&gt; 에 직접 할당 될 수 있습니다 . C ++ 03도 그것을 허용했습니다 (그러나 리터럴이 C ++의 &lt;code&gt;const&lt;/code&gt; 이기 때문에 더 이상 사용되지 않습니다 ). C ++ 11은 더 이상 캐스트없이 이러한 할당을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ab9e9edb5ce53cff5c0a794854dbeaa98df7eba" translate="yes" xml:space="preserve">
          <source>In C, the address of a &lt;code&gt;register&lt;/code&gt; variable cannot be taken, but in C++, a variable declared &lt;code&gt;register&lt;/code&gt; is semantically indistinguishable from a variable declared without any storage class specifiers.</source>
          <target state="translated">C에서는 &lt;code&gt;register&lt;/code&gt; 변수 의 주소를 사용할 수 없지만 C ++에서는 &lt;code&gt;register&lt;/code&gt; 로 선언 된 변수를 스토리지 클래스 지정자없이 선언 된 변수와 의미 적으로 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c82c0f1785717e06dc6cfec64c1ec49afdff6848" translate="yes" xml:space="preserve">
          <source>In C, the macro &lt;code&gt;NULL&lt;/code&gt; may have the type &lt;code&gt;void*&lt;/code&gt;, but that is not allowed in C++.</source>
          <target state="translated">C에서 매크로 &lt;code&gt;NULL&lt;/code&gt; 은 &lt;code&gt;void*&lt;/code&gt; 유형을 가질 수 있지만 C ++에서는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0bfb9c61efe498d3321fdcd4f4cc72588b7c2a9" translate="yes" xml:space="preserve">
          <source>In C, the ternary conditional operator has higher precedence than assignment operators. Therefore, the expression &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt;, which is parsed in C++ as &lt;code&gt;e = ((a &amp;lt; d) ? (a++) : (a = d))&lt;/code&gt;, will fail to compile in C due to grammatical or semantic constraints in C. See the corresponding C page for details.</source>
          <target state="translated">C에서 삼항 조건 연산자는 대입 연산자보다 우선 순위가 높습니다. 따라서 식 &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; C ++에서 &lt;code&gt;e = ((a &amp;lt; d) ? (a++) : (a = d))&lt;/code&gt; 로 구문 분석되는 a ++ : a = d 는 C의 문법적 또는 의미 적 제약으로 인해 C에서 컴파일되지 않습니다. 자세한 내용은 C 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c59c494dc7b28d6f1ae3f3e1fba28d7c33f040e5" translate="yes" xml:space="preserve">
          <source>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="translated">IS0에서 8601주는 월요일부터 시작하여 일년의 첫주는 다음 요구 사항을 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2409d0ab324438044b126d5eaae356ad25d17dc" translate="yes" xml:space="preserve">
          <source>In ISO 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="translated">ISO 8601 주에서 월요일부터 시작하여 연중 첫 번째 주가 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f2df198c19b4d3aee57fa1d2f0a4c70b3d8c1de" translate="yes" xml:space="preserve">
          <source>In a</source>
          <target state="translated">안에</target>
        </trans-unit>
        <trans-unit id="0c962fc44a425f14d1e80539f2eadaa9d9481b53" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../language/templates&quot;&gt; template declaration&lt;/a&gt;, &lt;code&gt;class&lt;/code&gt; can be used to introduce &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt; type template parameters&lt;/a&gt; and &lt;a href=&quot;../language/template_parameters#Template_template_parameter&quot;&gt; template template parameters&lt;/a&gt;</source>
          <target state="translated">A의 &lt;a href=&quot;../language/templates&quot;&gt;템플릿 선언&lt;/a&gt; , &lt;code&gt;class&lt;/code&gt; 소개하는 데 사용할 수 있습니다 &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;타입 템플릿 매개 변수&lt;/a&gt; 및 &lt;a href=&quot;../language/template_parameters#Template_template_parameter&quot;&gt;템플릿 템플릿 매개 변수를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b62c4f9f476c687ff843ca517e75f7940028ba13" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../language/templates&quot;&gt; template declaration&lt;/a&gt;, &lt;code&gt;typename&lt;/code&gt; can be used as an alternative to &lt;a href=&quot;class&quot;&gt; class&lt;/a&gt; to declare &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;type template parameters&lt;/a&gt;and template template parameters(since C++17).</source>
          <target state="translated">(A)에 &lt;a href=&quot;../language/templates&quot;&gt;템플릿 선언&lt;/a&gt; , &lt;code&gt;typename&lt;/code&gt; 하는 대신 이용 될 수 &lt;a href=&quot;class&quot;&gt;클래스&lt;/a&gt; 선언 &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;형 템플리트 파라미터&lt;/a&gt; (17 C ++ 때문에) 및 틀 틀 파라미터.</target>
        </trans-unit>
        <trans-unit id="6c62102a69b04462fa302dbc2df4626b43048568" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; declaration, it appears either immediately after the capture list, or immediately after the (keyword &lt;code&gt;mutable&lt;/code&gt; (if one is used).</source>
          <target state="translated">A의 &lt;a href=&quot;lambda&quot;&gt;람다&lt;/a&gt; 선언, 즉시 캡처 목록 이후에 나타나거나 즉시 (키워드 후 &lt;code&gt;mutable&lt;/code&gt; (하나를 사용하는 경우).</target>
        </trans-unit>
        <trans-unit id="e1d855aa75c086efbd816d762abc1c86bd8016f1" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, when the operand is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the function return type:</source>
          <target state="translated">A의 &lt;a href=&quot;return&quot;&gt;return 문&lt;/a&gt; 피연산자가있다, &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; 같은 클래스 형의 (무시 &lt;a href=&quot;cv&quot;&gt;CV-자격&lt;/a&gt; 함수 반환 유형으로 일) :</target>
        </trans-unit>
        <trans-unit id="177a6daaadac5e744a3c9483ebb25b9c5956b8d4" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and which is of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the function return type. This variant of copy elision is known as NRVO, &quot;named return value optimization&quot;.</source>
          <target state="translated">A의 &lt;a href=&quot;return&quot;&gt;return 문&lt;/a&gt; 피연산자가 함수 매개 변수 또는 캐치 절 매개 변수없는 자동 저장 기간이 비 휘발성 객체의 이름이고, 같은 클래스 타입 인 (무시 &lt;a href=&quot;cv&quot;&gt;CV-자격&lt;/a&gt; 으로) 함수 반환 타입 이러한 복제 제거 유형은 &quot;명명 된 리턴 값 최적화&quot;인 NRVO로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="fde11b27cc6006e08d96a8f3a53a33443f577fd4" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and whose scope does not extend past the innermost try-block (if there is a try-block).</source>
          <target state="translated">A의 &lt;a href=&quot;throw&quot;&gt;스로인 식&lt;/a&gt; 피연산자 범위 최 시도 블록을 지나서 연장되지 않는 함수 파라미터 또는 캐치 절 매개되지 않고, 자동 저장 기간이 비 휘발성 객체의 이름, (만약 try-block이 있습니다).</target>
        </trans-unit>
        <trans-unit id="601aeec487cb6099c489a8b16b96b24dfb6cd755" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;try_catch&quot;&gt;catch clause&lt;/a&gt;, when the argument is of the same type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the exception object thrown, the copy of the exception object is omitted and the body of the catch clause accesses the exception object directly, as if caught by reference (there cannot be a move from the exception object because it is always an lvalue). This is disabled if such copy elision would change the observable behavior of the program for any reason other than skipping the copy constructor and the destructor of the catch clause argument (for example, if the catch clause argument is modified, and the exception object is rethrown with &lt;code&gt;throw&lt;/code&gt;).</source>
          <target state="translated">A의 &lt;a href=&quot;try_catch&quot;&gt;캐치 절&lt;/a&gt; 인수는 동일한 타입이다 (무시 &lt;a href=&quot;cv&quot;&gt;CV-자격&lt;/a&gt; 예외 객체의 복사본을 생략 의해 잡힌 것처럼 catch 마디의 본체가 직접 예외 오브젝트 액세스 예외 1 오브젝트로서)을 참조 (항상 lvalue이므로 예외 오브젝트에서 이동할 수 없습니다). 이러한 복사 제거가 복사 생성자와 catch 절 인수의 소멸자를 건너 뛰는 것 이외의 이유로 (예를 들어, catch 절 인수가 수정되고 예외 오브젝트가 다시 발생하는 경우) 다른 이유로 프로그램의 관찰 가능한 동작을 변경하는 경우에는 사용 불가능합니다. 에 &lt;code&gt;throw&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="556d00127671f5f34cb70b7e4bc4f78905db67ff" translate="yes" xml:space="preserve">
          <source>In a base-specifier of a &lt;a href=&quot;derived_class&quot;&gt;derived class&lt;/a&gt; declaration, define the accessibility of inherited members of the subsequent base class.</source>
          <target state="translated">&lt;a href=&quot;derived_class&quot;&gt;파생 클래스&lt;/a&gt; 선언 의 기본 지정자 에서 후속 기본 클래스의 상속 된 멤버의 액세스 가능성을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="02b565401cf5d5664e816543f1fd59c4e0eec827" translate="yes" xml:space="preserve">
          <source>In a class scope, the name of the current class is treated as if it were a public member name; this is called</source>
          <target state="translated">클래스 범위에서 현재 클래스의 이름은 마치 공개 멤버 이름 인 것처럼 처리됩니다. 이것은 ... 불리운다</target>
        </trans-unit>
        <trans-unit id="dd0fdaa3d2c6bc7e7e1f68aa336ca282ee91f5ee" translate="yes" xml:space="preserve">
          <source>In a class template, the injected-class-name can be used either as a template name that refers to the current template, or as a class name that refers to the current instantiation.</source>
          <target state="translated">클래스 템플릿에서 주입 된 클래스 이름은 현재 템플릿을 참조하는 템플릿 이름 또는 현재 인스턴스화를 참조하는 클래스 이름으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44fa3b441a0dd74cd09577454cd3ff350af83aaa" translate="yes" xml:space="preserve">
          <source>In a comma expression &lt;code&gt;E1, E2&lt;/code&gt;, the expression &lt;code&gt;E1&lt;/code&gt; is evaluated, its result is &lt;a href=&quot;expressions#Discarded-value_expressions&quot;&gt;discarded&lt;/a&gt; (although if it has class type, it won't be destroyed &lt;a href=&quot;lifetime#Temporary_object_lifetime&quot;&gt;until the end of the containing full expression&lt;/a&gt;), and its side effects are completed before evaluation of the expression &lt;code&gt;E2&lt;/code&gt; begins (note that a user-defined &lt;code&gt;operator,&lt;/code&gt; cannot guarantee sequencing)(until C++17).</source>
          <target state="translated">쉼표 표현식 &lt;code&gt;E1, E2&lt;/code&gt; 에서 표현식 &lt;code&gt;E1&lt;/code&gt; 을 평가하고 결과를 &lt;a href=&quot;expressions#Discarded-value_expressions&quot;&gt;버립니다&lt;/a&gt; (클래스 유형이있는 경우에도 &lt;a href=&quot;lifetime#Temporary_object_lifetime&quot;&gt;전체 표현식이 끝날 때까지&lt;/a&gt; 파기되지 않음 ). 부작용은 평가 전에 완료됩니다. 식 &lt;code&gt;E2&lt;/code&gt; 의 시작 (사용자 정의 &lt;code&gt;operator,&lt;/code&gt; 는 시퀀싱을 보장 할 수 없음에 주의하십시오 ) (C ++ 17까지).</target>
        </trans-unit>
        <trans-unit id="6d39978f8296a8c3b0b3811afba0c562703be315" translate="yes" xml:space="preserve">
          <source>In a constexpr if statement, the value of condition must be a &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;contextually converted constant expression of type &lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. If the value is &lt;code&gt;true&lt;/code&gt;, then statement-false is discarded (if present), otherwise, statement-true is discarded.</source>
          <target state="translated">constexpr if 문에서 조건의 값은 &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형 의 컨텍스트 변환 상수 표현식 이어야합니다 . 값이 &lt;code&gt;true&lt;/code&gt; 이면 statement-false가 삭제되고 (있는 경우), 그렇지 않으면 statement-true가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ffa4404e890de02936df9088f71b377c51dc866e" translate="yes" xml:space="preserve">
          <source>In a declaration or a definition of a template, including alias template, a name that is not a member of the</source>
          <target state="translated">별칭 템플릿을 포함한 템플릿의 선언 또는 정의에서</target>
        </trans-unit>
        <trans-unit id="0d44582f7d0710a8597f720797b494b72912bece" translate="yes" xml:space="preserve">
          <source>In a function declaration, after a parameter with a default argument, all subsequent parameters must.</source>
          <target state="translated">함수 선언에서 기본 인수가있는 매개 변수 뒤에 모든 후속 매개 변수가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="29bba75b946ab8a0a1465e021f70b5a3cf77b940" translate="yes" xml:space="preserve">
          <source>In a function parameter list, if an ellipsis appears in a parameter declaration (whether it names a function parameter pack (as in, Args&lt;code&gt;...&lt;/code&gt;args) or not) the parameter declaration is the pattern:</source>
          <target state="translated">함수 매개 변수 목록에서 생략 부호가 매개 변수 선언에 나타나는 경우 (Args &lt;code&gt;...&lt;/code&gt; args 에서와 같이 함수 매개 변수 팩의 이름 지정 여부 ) 매개 변수 선언은 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="ff38e5d5bc4cb779e7363c8977789202cfec1e6e" translate="yes" xml:space="preserve">
          <source>In a function returning &lt;code&gt;void&lt;/code&gt;, the return statement with expression can be used, if the expression type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 를 반환하는 함수 에서 표현식 유형이 &lt;code&gt;void&lt;/code&gt; 인 경우 expression이 포함 된 return 문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9aa7f5d4e2a651b7a8c4283d212b044b1deb7ca" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;a href=&quot;mutex&quot;&gt;&lt;code&gt;mutex&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;timed_mutex&lt;/code&gt; offers exclusive, non-recursive ownership semantics. In addition, &lt;code&gt;timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">비슷한 방식으로 &lt;a href=&quot;mutex&quot;&gt; &lt;code&gt;mutex&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;timed_mutex&lt;/code&gt; 는 독점, 비 재귀 소유의 의미를 제공합니다. 또한 &lt;code&gt;timed_mutex&lt;/code&gt; 는 &lt;a href=&quot;timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 시간 초과 로 &lt;code&gt;timed_mutex&lt;/code&gt; 의 소유권을 주장하려고 시도하는 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a105c84562cad718ddfbcbaeae2b0d01a57bb6a5" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;a href=&quot;timed_mutex&quot;&gt;&lt;code&gt;timed_mutex&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;shared_timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;shared_timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;shared_timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_shared_for&quot;&gt;&lt;code&gt;try_lock_shared_for()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_shared_until&quot;&gt;&lt;code&gt;try_lock_shared_until()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">유사한 방식으로 &lt;a href=&quot;timed_mutex&quot;&gt; &lt;code&gt;timed_mutex&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;shared_timed_mutex&lt;/code&gt; 는 (A)의 제 소유를 시도하는 기능 제공 &lt;code&gt;shared_timed_mutex&lt;/code&gt; 비아 타임 아웃 &lt;a href=&quot;shared_timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;shared_timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;shared_timed_mutex/try_lock_shared_for&quot;&gt; &lt;code&gt;try_lock_shared_for()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;shared_timed_mutex/try_lock_shared_until&quot;&gt; &lt;code&gt;try_lock_shared_until()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="73ef1571fcba32d6299f7cfb10f71f4b33622399" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;code&gt;&lt;a href=&quot;recursive_mutex&quot;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; provides exclusive, recursive ownership semantics. In addition, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;recursive_timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;recursive_timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;recursive_timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">유사한 방식으로 &lt;code&gt;&lt;a href=&quot;recursive_mutex&quot;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;recursive_timed_mutex&lt;/code&gt; 는 독점, 재귀 소유의 의미를 제공한다. 또한 &lt;code&gt;recursive_timed_mutex&lt;/code&gt; 는 &lt;a href=&quot;recursive_timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;recursive_timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 시간 초과 로 &lt;code&gt;recursive_timed_mutex&lt;/code&gt; 의 소유권을 주장하려고 시도하는 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6849ef8c2becfa3fc06c88b17ac43d2f4c411e40" translate="yes" xml:space="preserve">
          <source>In a member function declaration or definition, &lt;code&gt;override&lt;/code&gt; ensures that the function is virtual and is overriding a virtual function from a base class. The program is ill-formed (a compile-time error is generated) if this is not true.</source>
          <target state="translated">멤버 함수 선언 또는 정의에서 &lt;code&gt;override&lt;/code&gt; 는 함수가 가상이고 기본 클래스에서 가상 함수를 재정의하도록합니다. 이것이 사실이 아닌 경우 프로그램이 잘못 구성됩니다 (컴파일 타임 오류가 생성됨).</target>
        </trans-unit>
        <trans-unit id="e4f5d5b55ed5d6a1476b0d473859397b31a64db5" translate="yes" xml:space="preserve">
          <source>In a member-specification of a &lt;a href=&quot;class&quot;&gt;class/struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, define the accessibility of subsequent members.</source>
          <target state="translated">(A)의 멤버-규격에 &lt;a href=&quot;class&quot;&gt;클래스 / 구조체&lt;/a&gt; 또는 &lt;a href=&quot;union&quot;&gt;조합&lt;/a&gt; , 이후 멤버의 접근성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="94c1a387b407acb6d65fdcd502fe4af3873221a8" translate="yes" xml:space="preserve">
          <source>In a primary class template, the template parameter pack must be the final parameter in the template parameter list. In a function template, the template parameter pack may appear earlier in the list provided that all following parameters can be deduced from the function arguments, or have default arguments:</source>
          <target state="translated">기본 클래스 템플릿에서 템플릿 매개 변수 팩은 템플릿 매개 변수 목록의 마지막 매개 변수 여야합니다. 함수 템플릿에서 템플릿 매개 변수 팩은 함수 인수에서 추론되거나 기본 인수가있는 경우 목록의 앞부분에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d0f0e8e5fc7ee584cfdd9cc8db60b33727fe5d0" translate="yes" xml:space="preserve">
          <source>In a qualified name &lt;code&gt;C::D&lt;/code&gt;, if.</source>
          <target state="translated">정규화 된 이름으로 &lt;code&gt;C::D&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="72a217ab1ac4987acb0fd819dc67e7faf17facb8" translate="yes" xml:space="preserve">
          <source>In a return statement or a throw-expression, if the compiler cannot perform copy elision but the conditions for copy elision are met or would be met, except that the source is a function parameter, the compiler will attempt to use the move constructor even if the object is designated by an lvalue; see &lt;a href=&quot;return#Notes&quot;&gt;return statement&lt;/a&gt; for details.</source>
          <target state="translated">return 문 또는 throw-expression에서 컴파일러가 복사 제거를 수행 할 수 없지만 소스가 함수 매개 변수 인 것을 제외하고 복사 제거 조건이 충족되거나 충족되는 경우 컴파일러는 다음과 같은 경우에도 이동 생성자를 사용하려고 시도합니다. 객체는 lvalue로 지정됩니다. 자세한 내용은 &lt;a href=&quot;return#Notes&quot;&gt;return 문&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cb9d44c1145d9374305ce7d0683c7666a1a8faf1" translate="yes" xml:space="preserve">
          <source>In a standard-layout union with an active member of non-union class type &lt;code&gt;T1&lt;/code&gt;, it is permitted to read a non-static data member &lt;code&gt;m&lt;/code&gt; of another union member of non-union class type &lt;code&gt;T2&lt;/code&gt; provided &lt;code&gt;m&lt;/code&gt; is part of the common initial sequence of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; (except that reading a volatile member through non-volatile glvalue is undefined).</source>
          <target state="translated">비 유니언 클래스 유형 &lt;code&gt;T1&lt;/code&gt; 의 활성 멤버와 표준 레이아웃 유니온에서 &lt;code&gt;m&lt;/code&gt; 이 공통 초기 시퀀스의 일부인 경우 비 유니언 클래스 유형 &lt;code&gt;T2&lt;/code&gt; 의 다른 조합 멤버의 비 정적 데이터 멤버 &lt;code&gt;m&lt;/code&gt; 을 읽을 수 있습니다. 비 휘발성 glvalue를 통해 휘발성 멤버를 읽는 것은 정의되지 않은 것을 제외하고 는 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="57d94135b1f4411284cd0b70dd280cd47ea7b667" translate="yes" xml:space="preserve">
          <source>In a typical implementation, &lt;code&gt;std::shared_ptr&lt;/code&gt; holds only two pointers:</source>
          <target state="translated">일반적인 구현에서 &lt;code&gt;std::shared_ptr&lt;/code&gt; 에는 두 개의 포인터 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="302df27cb656ad4b16b22d1abb7ca751d6dcd20f" translate="yes" xml:space="preserve">
          <source>In a typical implementation, the only data members of &lt;code&gt;std::ostream_iterator&lt;/code&gt; are a pointer to the associated &lt;code&gt;std::basic_ostream&lt;/code&gt; and a pointer to the first character in the delimiter string.</source>
          <target state="translated">일반적인 구현에서 &lt;code&gt;std::ostream_iterator&lt;/code&gt; 의 유일한 데이터 멤버 는 연관된 &lt;code&gt;std::basic_ostream&lt;/code&gt; 에 대한 포인터 및 구분 기호 문자열의 첫 번째 문자에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="28d88a36238effdebec563fabaf3d6addb51154c" translate="yes" xml:space="preserve">
          <source>In a typical implementation, the only data members of &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; are a pointer to the associated &lt;code&gt;std::basic_streambuf&lt;/code&gt; and a boolean flag indicating if the the end of file condition has been reached.</source>
          <target state="translated">일반적인 구현에서 &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; 의 유일한 데이터 멤버 는 연관된 &lt;code&gt;std::basic_streambuf&lt;/code&gt; 대한 포인터 와 파일의 끝에 도달했는지 여부를 나타내는 부울 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="cf627f59eb9ce680a79832f3ab2b75fd54c9e5dc" translate="yes" xml:space="preserve">
          <source>In a valid C++ program, every thread eventually does one of the following:</source>
          <target state="translated">유효한 C ++ 프로그램에서 모든 스레드는 결국 다음 중 하나를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5fae65e7ec13a45d7642866607e117019083d5bd" translate="yes" xml:space="preserve">
          <source>In addition to being available via inclusion of the &amp;lt;tuple&amp;gt; header, the templates (3-5) are available when either of the headers &amp;lt;array&amp;gt; or &amp;lt;utility&amp;gt; are included.</source>
          <target state="translated">In addition to being available via inclusion of the &amp;lt;tuple&amp;gt; header, the templates (3-5) are available when either of the headers &amp;lt;array&amp;gt; or &amp;lt;utility&amp;gt; are included.</target>
        </trans-unit>
        <trans-unit id="15c8d22eeeed9e3926980c7851a1d6015cd58fda" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::begin&lt;/code&gt; and &lt;code&gt;std::cbegin&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">에 포함되지 외에도 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::begin&lt;/code&gt; 및 &lt;code&gt;std::cbegin&lt;/code&gt; 사용할 수있게 보장되는 다음 헤더 중 하나가 포함 된 경우 : &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (C ++ 20 이후), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (C ++ 17 이후), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="338a7c84c19f8a1e820335032a79e38ce0602216" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::data&lt;/code&gt; is guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">에 포함되지 외에도 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::data&lt;/code&gt; 다음 헤더 중 하나가 포함 된 경우 사용할 수있게 보장 : &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (C ++ 20부터), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8ecedc3305486dab3dbe344b85d3d2b73a9d8eb" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::empty&lt;/code&gt; is guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">에 포함되지 외에도 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::empty&lt;/code&gt; 사용할 수있게 보장 다음 헤더 중 하나가 포함 된 경우 : &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (C ++ 20부터), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9360d86ce66685d75aa6a0b3e3f9a322ab2b75da" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::end&lt;/code&gt; and &lt;code&gt;std::cend&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">에 포함되지 외에도 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::end&lt;/code&gt; 과 &lt;code&gt;std::cend&lt;/code&gt; 다음과 같은 헤더라도 포함하는 경우 사용할 수있게 보장됩니다 : &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (C ++ 20 이후), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (C ++ 17 이후), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4a73cea37076402c9805971389b5c85fd80eb64" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::rbegin&lt;/code&gt; and &lt;code&gt;std::crbegin&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">에 포함되지 외에도 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::rbegin&lt;/code&gt; 및 &lt;code&gt;std::crbegin&lt;/code&gt; 다음 헤더 중 하나가 포함 된 경우 사용할 수있게 보장됩니다 : &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (C ++ 20 이후), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (C ++ 17 이후), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80150b5d7065d7588ce5758ee13c5f0c81f3d9cb" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::rend&lt;/code&gt; and &lt;code&gt;std::crend&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">에 포함되지 외에도 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::rend&lt;/code&gt; 와 &lt;code&gt;std::crend&lt;/code&gt; 다음 헤더의이 포함 된 경우 사용할 수있게 보장됩니다 : &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (C ++ 20 이후), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (C ++ 17 이후), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ece481ac1f67deffb145ed3b4d4e6b31704b49ce" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::size&lt;/code&gt; and &lt;code&gt;std::ssize&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">에 포함되지 외에도 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::size&lt;/code&gt; 및 &lt;code&gt;std::ssize&lt;/code&gt; 다음 헤더 중 하나가 포함 된 경우 사용할 수있게 보장됩니다 : &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (C ++ 20부터), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a875ba5ef1aeb5e5a529dc3dc7727bb4112f85b1" translate="yes" xml:space="preserve">
          <source>In addition to changing the file position indicator, &lt;code&gt;fseek&lt;/code&gt; undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file status, if applicable.</source>
          <target state="translated">&lt;code&gt;fseek&lt;/code&gt; 는 파일 위치 표시기를 변경하는 것 외에도 &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; 의 효과를 취소하고 적용 가능한 경우 파일 끝 상태를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="cf1188534c30ece32fd46ec4ab40935b4238d277" translate="yes" xml:space="preserve">
          <source>In addition to keywords, there are</source>
          <target state="translated">키워드 외에도</target>
        </trans-unit>
        <trans-unit id="271348d0f95843d6de9b4a3bea7c7a4b2fb93975" translate="yes" xml:space="preserve">
          <source>In addition to sophisticated locale-dependent parsers and formatters provided by the &lt;a href=&quot;io&quot;&gt;C++ I/O&lt;/a&gt; library, the &lt;a href=&quot;io/c&quot;&gt;C I/O&lt;/a&gt; library, &lt;a href=&quot;string/basic_string#Numeric_conversions&quot;&gt;C++ string converters&lt;/a&gt;, and &lt;a href=&quot;string/byte#Conversions_to_numeric_formats&quot;&gt;C string converters&lt;/a&gt;, the header &lt;a href=&quot;header/charconv&quot;&gt;&lt;code&gt;&amp;lt;charconv&amp;gt;&lt;/code&gt;&lt;/a&gt; provides light-weight, locale-independent, non-allocating, non-throwing, ASCII-only parsers and formatters for arithmetic types.</source>
          <target state="translated">&lt;a href=&quot;io&quot;&gt;C ++ I / O&lt;/a&gt; 라이브러리, &lt;a href=&quot;io/c&quot;&gt;CI / O&lt;/a&gt; 라이브러리, &lt;a href=&quot;string/basic_string#Numeric_conversions&quot;&gt;C ++ 문자열 변환기&lt;/a&gt; 및 &lt;a href=&quot;string/byte#Conversions_to_numeric_formats&quot;&gt;C 문자열 변환기&lt;/a&gt; 에서 제공하는 정교한 로케일 종속 파서 및 포맷터 &lt;a href=&quot;header/charconv&quot;&gt; &lt;code&gt;&amp;lt;charconv&amp;gt;&lt;/code&gt; &lt;/a&gt; 헤더 는 가볍고 로케일 독립적이며 비 로컬을 제공합니다. 산술 유형에 대한 비 투척 ASCII 전용 파서 및 포맷터 할당</target>
        </trans-unit>
        <trans-unit id="792f40a7aa00c160ead2eca530fe86663d38f9ab" translate="yes" xml:space="preserve">
          <source>In addition to the above, the composite pointer type between pointer to function and pointer to noexcept function (as long as the function type is the same) is pointer to function.</source>
          <target state="translated">위의 것 외에도, 함수에 대한 포인터와 noexcept 함수에 대한 포인터 사이의 복합 포인터 유형은 함수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="ae9ffad79cce78b91bc762e83fe3fface28c2158" translate="yes" xml:space="preserve">
          <source>In addition to the above, the standard library provides specializations for all (scoped and unscoped) enumeration types. These may be (but are not required to be) implemented as &lt;code&gt;std::hash&amp;lt;&lt;a href=&quot;../types/underlying_type&quot;&gt;std::underlying_type&lt;/a&gt;&amp;lt;Enum&amp;gt;::type&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">위의 것 외에도 표준 라이브러리는 모든 범위와 범위가없는 열거 유형에 대한 전문화를 제공합니다. 이것들은 &lt;code&gt;std::hash&amp;lt;&lt;a href=&quot;../types/underlying_type&quot;&gt;std::underlying_type&lt;/a&gt;&amp;lt;Enum&amp;gt;::type&amp;gt;&lt;/code&gt; 구현 될 수도 있지만 반드시 그런 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="0d12b27afe84f919d4cf85c2c720f51dd78c7c47" translate="yes" xml:space="preserve">
          <source>In addition to the engines and distributions described above, the functions and constants from the C random library are also available though not recommended:</source>
          <target state="translated">위에서 설명한 엔진과 분포 외에도 C 랜덤 라이브러리의 함수와 상수도 권장하지는 않지만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7885497c8e90724cd51455d17a67e9d4213e9e7" translate="yes" xml:space="preserve">
          <source>In addition to the use in collation, the implementation-specific format of the transformed string is known to &lt;a href=&quot;../../regex/regex_traits/transform_primary&quot;&gt;std::regex_traits&amp;lt;&amp;gt;::transform_primary&lt;/a&gt;, which is able to extract the equivalence class information.</source>
          <target state="translated">데이터 정렬에서의 사용 외에도 변환 된 문자열의 구현 별 형식은 &lt;a href=&quot;../../regex/regex_traits/transform_primary&quot;&gt;std :: regex_traits &amp;lt;&amp;gt; :: transform_primary&lt;/a&gt; 로 알려져 있으며 , 이는 등가 클래스 정보를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a698de81532c150ff1ad39e8d086bac28e3d07da" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;bit_field&quot;&gt;bit field declarations&lt;/a&gt; are allowed.</source>
          <target state="translated">또한 &lt;a href=&quot;bit_field&quot;&gt;비트 필드 선언&lt;/a&gt; 이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b8e054656c974f48dccf563843687d3cffa39b2" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; can be value-initialized to clear state with the expression &lt;code&gt;&lt;a href=&quot;../atomic_flag_init&quot;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt;. For an atomic_flag with static &lt;a href=&quot;../../language/storage_duration#Storage_duration&quot;&gt;storage duration&lt;/a&gt;, this guarantees &lt;a href=&quot;../../language/initialization#Static_initialization&quot;&gt;static initialization&lt;/a&gt;: the flag can be used in constructors of static objects.</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 를 값 초기화하여 &lt;code&gt;&lt;a href=&quot;../atomic_flag_init&quot;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt; 표현식으로 상태를 지울 수 있습니다 . 정적 &lt;a href=&quot;../../language/storage_duration#Storage_duration&quot;&gt;저장 시간을&lt;/a&gt; 갖는 atomic_flag의 경우 &lt;a href=&quot;../../language/initialization#Static_initialization&quot;&gt;정적 초기화가&lt;/a&gt; 보장 됩니다 . 플래그는 정적 객체의 생성자에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f193d95fb5f81fb5974342efbdfb55ebd6bb874" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;std::cerr.tie()&lt;/code&gt; returns &lt;code&gt;&amp;amp;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; (same for &lt;code&gt;wcerr&lt;/code&gt; and &lt;code&gt;wcout&lt;/code&gt;), meaning that any output operation on &lt;code&gt;std::cerr&lt;/code&gt; first executes &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; (via &lt;code&gt;&lt;a href=&quot;basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt;'s constructor) (since C++11).</source>
          <target state="translated">또한 &lt;code&gt;std::cerr.tie()&lt;/code&gt; 는 &lt;code&gt;&amp;amp;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;wcerr&lt;/code&gt; 및 &lt;code&gt;wcout&lt;/code&gt; 과 동일 )을 리턴합니다 . 이는 &lt;code&gt;std::cerr&lt;/code&gt; 모든 출력 조작이 &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; 먼저 실행 함을 의미합니다 ( &lt;code&gt;&lt;a href=&quot;basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; 의 생성자) (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="fa95bff2b2f1d155be7f57dab28372be4d7eb068" translate="yes" xml:space="preserve">
          <source>In addition, C-style cast notation is allowed to cast from, to, and between pointers to incomplete class type. If both expression and new_type are pointers to incomplete class types, it's unspecified whether static_cast or reinterpret_cast gets selected.</source>
          <target state="translated">또한 C 스타일 캐스트 표기법은 포인터가 불완전한 클래스 유형에 대해 포인터간에 전송되도록 허용합니다. expression과 new_type이 모두 불완전한 클래스 유형에 대한 포인터 인 경우 static_cast 또는 reinterpret_cast를 선택할지 여부는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce46012134e55d98fb6c46e02b9a75f51edf17ba" translate="yes" xml:space="preserve">
          <source>In addition, a typical implementation holds a data member of type &lt;code&gt;&lt;a href=&quot;ios_base/openmode&quot;&gt;std::ios_base::openmode&lt;/a&gt;&lt;/code&gt; to indicate the status of the stream (input-only, output-only, input/output, at-end, etc).</source>
          <target state="translated">또한 일반적인 구현은 &lt;code&gt;&lt;a href=&quot;ios_base/openmode&quot;&gt;std::ios_base::openmode&lt;/a&gt;&lt;/code&gt; 유형의 데이터 멤버를 보유 하여 스트림 상태 (입력 전용, 출력 전용, 입력 / 출력, 종료 등)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f488b539106ae565b1a7adaef610b9d6be03b1fa" translate="yes" xml:space="preserve">
          <source>In addition, a value-initialized object of the type must produce a null value of that type. This null value shall only be equivalent to itself. Default initialization of the type may have an indeterminate value.</source>
          <target state="translated">또한 유형의 값으로 초기화 된 객체는 해당 유형의 null 값을 생성해야합니다. 이 null 값은 그 자체와 동일해야합니다. 유형의 기본 초기화에 불확실한 값이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a8db860cf41b64de062e0a8128719f25222688f" translate="yes" xml:space="preserve">
          <source>In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">또한 원자 객체에 대한 액세스는 스레드 간 동기화를 설정하고 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; 지정된대로 비 원자 메모리 액세스를 정렬 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15638d0e65e84f9a793f46e162b9a6f8ac56803a" translate="yes" xml:space="preserve">
          <source>In addition, all names declared in &lt;a href=&quot;namespace&quot;&gt;unnamed namespace&lt;/a&gt; or a namespace within an unnamed namespace, even ones explicitly declared &lt;code&gt;extern&lt;/code&gt;, have internal linkage.</source>
          <target state="translated">또한 &lt;a href=&quot;namespace&quot;&gt;명명되지 않은 네임 스페이스&lt;/a&gt; 또는 명명되지 않은 네임 스페이스 내의 네임 스페이스 (명시 적으로 &lt;code&gt;extern&lt;/code&gt; 으로 선언 된 네임 스페이스)에 선언 된 모든 이름 에는 내부 연결이 있습니다.</target>
        </trans-unit>
        <trans-unit id="49487efebaebbb07ca06e7cb34f9dc3b236bdf9b" translate="yes" xml:space="preserve">
          <source>In addition, evaluation of that expression is not allowed to call non-const member functions of the dereferenced iterators.</source>
          <target state="translated">또한 해당 표현식의 평가는 역 참조 된 반복자의 비 const 멤버 함수를 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff0e19edf9941c628d63cc46fd91d50b5ee3522e" translate="yes" xml:space="preserve">
          <source>In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these four specializations.</source>
          <target state="translated">또한 C ++ 프로그램으로 작성된 모든 로케일 오브젝트는이 네 가지 특수화의 고유 (로케일 특정) 버전을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="34a1ac7c8b7c33c94bfab7f6061398698b960b4f" translate="yes" xml:space="preserve">
          <source>In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these specializations.</source>
          <target state="translated">또한 C ++ 프로그램으로 작성된 모든 로케일 오브젝트는 이러한 특수화의 고유 (로케일 별) 버전을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d46580f66bb3168b2878f24c3024ecea21ce496c" translate="yes" xml:space="preserve">
          <source>In addition, for each class template &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; declared in this header, &lt;code&gt;std::&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;std::w&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; are declared as a synonym of &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; respectively.</source>
          <target state="translated">또한 이 헤더에 선언 된 각 클래스 템플리트 &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; 에 대해 &lt;code&gt;std::&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; 및 &lt;code&gt;std::w&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; 는 &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 및 &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; 의 동의어로 선언됩니다. 각기.</target>
        </trans-unit>
        <trans-unit id="5d1d9f9e3417a73b82b4272cc321a2469fc45949" translate="yes" xml:space="preserve">
          <source>In addition, if the lvalue is of volatile-qualified class type, a volatile copy-constructor is required to initialize the resulting rvalue temporary.</source>
          <target state="translated">또한 lvalue가 volatile로 한정된 클래스 유형 인 경우 결과 rvalue를 임시로 초기화하려면 휘발성 복사 생성자가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9ce4f9734cf334aa096d562134cd27bb864fe82d" translate="yes" xml:space="preserve">
          <source>In addition, implementations are allowed to:</source>
          <target state="translated">또한 구현은 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fca944845bc26e72a63f6ee2aaf3fc85bb418c7" translate="yes" xml:space="preserve">
          <source>In addition, it's undefined behavior to #define or #undef names identical to &lt;a href=&quot;../keywords&quot;&gt;keywords&lt;/a&gt;. If at least one standard library header is included, it's undefined behavior to #define or #undef identifiers identical to names declared in any standard library header.</source>
          <target state="translated">또한 &lt;a href=&quot;../keywords&quot;&gt;키워드와&lt;/a&gt; 동일한 #define 또는 #undef 이름에 대한 정의되지 않은 동작 입니다. 하나 이상의 표준 라이브러리 헤더가 포함 된 경우 표준 라이브러리 헤더에 선언 된 이름과 동일한 #define 또는 #undef 식별자에 대해 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="9d2f44e82fedbe71cbece0ffe227d0a0158a8b14" translate="yes" xml:space="preserve">
          <source>In addition, many &lt;a href=&quot;../types&quot;&gt;type traits&lt;/a&gt; are implemented using SFINAE.</source>
          <target state="translated">또한 SFINAE를 사용하여 많은 &lt;a href=&quot;../types&quot;&gt;유형 특성&lt;/a&gt; 이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="e92c1e872be57b036dbc2507bb5706e7b76dcd09" translate="yes" xml:space="preserve">
          <source>In addition, member and non-member functions are provided to support the following operations:</source>
          <target state="translated">또한 멤버 및 비 멤버 기능이 제공되어 다음 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="89093684fff07258cc05ff168ca489272759c61f" translate="yes" xml:space="preserve">
          <source>In addition, so-called</source>
          <target state="translated">또한 소위</target>
        </trans-unit>
        <trans-unit id="29000479e98fa4979896c6eb46f598587861c215" translate="yes" xml:space="preserve">
          <source>In addition, synchronized C++ streams are guaranteed to be thread-safe (individual characters output from multiple threads may interleave, but no data races occur).</source>
          <target state="translated">또한 동기화 된 C ++ 스트림은 스레드 안전성을 보장합니다 (여러 스레드에서 출력 된 개별 문자는 인터리브 할 수 있지만 데이터 경쟁은 발생하지 않음).</target>
        </trans-unit>
        <trans-unit id="5fea8ea2966b10c7537944404433308f3b7b4ff6" translate="yes" xml:space="preserve">
          <source>In addition, the following standard library facilities accept any Callable type (not just &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;).</source>
          <target state="translated">또한 다음 표준 라이브러리 &lt;a href=&quot;functionobject&quot;&gt;기능&lt;/a&gt; 은 FunctionObject 뿐만 아니라 모든 Callable 유형을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="6c22d022938dfbf51f3ef71122c0c58581f4ff83" translate="yes" xml:space="preserve">
          <source>In addition, the implicit conversion in copy-initialization must produce &lt;code&gt;T&lt;/code&gt; directly from the initializer, while, e.g. direct-initialization expects an implicit conversion from the initializer to an argument of &lt;code&gt;T&lt;/code&gt;'s constructor.</source>
          <target state="translated">또한 복사 초기화의 암시 적 변환은 이니셜 라이저 에서 직접 &lt;code&gt;T&lt;/code&gt; 를 생성해야하는 반면 직접 초기화는 이니셜 라이저에서 &lt;code&gt;T&lt;/code&gt; 의 생성자 인수로의 암시 적 변환을 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="92a67045a12eca5e07b1c4404b9093c3441f456c" translate="yes" xml:space="preserve">
          <source>In addition, the standard exception types &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../overflow_error/overflow_error&quot;&gt;std::overflow_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../underflow_error/underflow_error&quot;&gt;std::underflow_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../regex/regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;std::runtime_error&lt;/code&gt;.</source>
          <target state="translated">또한 표준 예외 유형 &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../overflow_error/overflow_error&quot;&gt;std::overflow_error&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../underflow_error/underflow_error&quot;&gt;std::underflow_error&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../regex/regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;std::runtime_error&lt;/code&gt; 에서 파생됩니다 .</target>
        </trans-unit>
        <trans-unit id="46ca753eadbc6e64c330f063c04cf76079373fe6" translate="yes" xml:space="preserve">
          <source>In addition, the standard library offers several RAII wrappers to manage user-provided resources:</source>
          <target state="translated">또한 표준 라이브러리는 사용자 제공 리소스를 관리하기위한 여러 RAII 래퍼를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="891107f99b45712dab34dbd0d5adc64b629b07b9" translate="yes" xml:space="preserve">
          <source>In addition, two function templates are</source>
          <target state="translated">또한 두 가지 기능 템플릿이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff24fd16f36ec6c36c829ad13c5fdc98ceb02332" translate="yes" xml:space="preserve">
          <source>In addition, unparenthesized type is greedy: it will include every token that can be a part of a declarator:</source>
          <target state="translated">또한 괄호로 묶지 않은 유형은 탐욕스러워 : 선언자의 일부가 될 수있는 모든 토큰이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="33a1d90854c6b62d20682a431d3deb3e352e1570" translate="yes" xml:space="preserve">
          <source>In addition, volatile accesses are not atomic (concurrent read and write is a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).</source>
          <target state="translated">또한, 휘발성 액세스는 원자 적이 지 않으며 (동시 읽기 및 쓰기는 &lt;a href=&quot;../language/memory_model&quot;&gt;데이터 경쟁입니다&lt;/a&gt; ) 메모리를 정렬하지 않습니다 (비 휘발성 메모리 액세스는 휘발성 액세스를 중심으로 자유롭게 재정렬 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="3cb2abcf8bbfd3a7bfabbd1249bd200fcbc8e347" translate="yes" xml:space="preserve">
          <source>In addition, within the namespace &lt;code&gt;std::chrono&lt;/code&gt;, the directive &lt;code&gt;using namespace literals::chrono_literals;&lt;/code&gt; is provided by the standard library, so that if a programmer uses &lt;code&gt;using namespace std::chrono;&lt;/code&gt; to gain access to the classes in the chrono library, the corresponding literal operators become visible as well.</source>
          <target state="translated">또한 네임 스페이스 &lt;code&gt;std::chrono&lt;/code&gt; 내에서 네임 &lt;code&gt;using namespace literals::chrono_literals;&lt;/code&gt; 하는 지시문 :: chrono_literals; 표준 라이브러리에 의해 제공되므로 프로그래머가 &lt;code&gt;using namespace std::chrono;&lt;/code&gt; 사용하는 경우 std :: chrono; 크로노 라이브러리의 클래스에 액세스하기 위해 해당 리터럴 연산자도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="208c76a1040cc2d170e334de617b92960c4a9549" translate="yes" xml:space="preserve">
          <source>In all cases in which the call to &lt;code&gt;regex_search&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;match.prefix().first&lt;/code&gt; will be equal to the previous value of &lt;code&gt;match[0].second&lt;/code&gt; and for each index</source>
          <target state="translated">모든 경우에 있어서는 호출하는 &lt;code&gt;regex_search&lt;/code&gt; 공히 복귀 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;match.prefix().first&lt;/code&gt; 의 이전 값과 동일 할 것이다 &lt;code&gt;match[0].second&lt;/code&gt; 각 인덱스</target>
        </trans-unit>
        <trans-unit id="b3e3fd9de0235c44f06b8f45f6682e2f71d0e99c" translate="yes" xml:space="preserve">
          <source>In all cases the deleter is initialized from &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;decltype(d)&amp;gt;(d)&lt;/code&gt;.</source>
          <target state="translated">모든 경우에 삭제 프로그램은 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;decltype(d)&amp;gt;(d)&lt;/code&gt; 에서 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="702fc4c8ea20caf42025f3c5b2479929ca73939e" translate="yes" xml:space="preserve">
          <source>In all cases, a constructor selected to copy or move an object is odr-used even if &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt; takes place.</source>
          <target state="translated">모든 경우에, &lt;a href=&quot;copy_elision&quot;&gt;복사 제거&lt;/a&gt; 가 발생 하더라도 개체를 복사하거나 이동하도록 선택된 생성자는 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="448921a2325557aed9e228f8da4e834b6e28cdeb" translate="yes" xml:space="preserve">
          <source>In all cases, attr is an optional sequence of &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;. When appearing immediately after the identifier, it applies to the object being declared.</source>
          <target state="translated">모든 경우에 attr은 선택적 &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 순서입니다 . 식별자 바로 뒤에 나타날 때 선언되는 객체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="83161a84bc1a7a51d78f0506c4b7ea19c215e3d3" translate="yes" xml:space="preserve">
          <source>In all cases, cv-qualifiers are ignored by typeid (that is, &lt;code&gt;typeid(const T) == typeid(T)&lt;/code&gt;).</source>
          <target state="translated">모든 경우에 cv 한정자는 typeid (즉, &lt;code&gt;typeid(const T) == typeid(T)&lt;/code&gt; )에 의해 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="10f7d85b749093104c6f7b42f1410b3aa41a5078" translate="yes" xml:space="preserve">
          <source>In all cases, equality is checked by calling &lt;a href=&quot;../char_traits/cmp&quot;&gt;&lt;code&gt;Traits::eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 경우에 &lt;a href=&quot;../char_traits/cmp&quot;&gt; &lt;code&gt;Traits::eq&lt;/code&gt; &lt;/a&gt; 를 호출하여 동등성을 검사합니다 .</target>
        </trans-unit>
        <trans-unit id="e78e8c07f5b30e31f34be5630e807f2679203b79" translate="yes" xml:space="preserve">
          <source>In all cases, equality is checked by calling &lt;a href=&quot;../char_traits/cmp&quot;&gt;Traits::eq&lt;/a&gt;.</source>
          <target state="translated">모든 경우에 &lt;a href=&quot;../char_traits/cmp&quot;&gt;Traits :: eq&lt;/a&gt; 를 호출하여 동등성을 검사합니다 .</target>
        </trans-unit>
        <trans-unit id="42ce3a010af7213a4ee16fafe2f69cd257e4ea24" translate="yes" xml:space="preserve">
          <source>In all cases, for the built-in operators, lhs and rhs must have either.</source>
          <target state="translated">모든 경우에 내장 연산자의 경우 lhs 및 rhs 중 하나가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="773f0f51c30de4ead22498372e4d412e3f3708c1" translate="yes" xml:space="preserve">
          <source>In all cases, if &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the standard library deallocation functions do nothing. If the pointer passed to the standard library deallocation function was not obtained from the corresponding standard library allocation function, the behavior is undefined.</source>
          <target state="translated">모든 경우에, &lt;code&gt;ptr&lt;/code&gt; 이 널 포인터 인 경우 표준 라이브러리 할당 해제 함수는 아무 것도 수행하지 않습니다. 표준 라이브러리 할당 해제 함수에 전달 된 포인터가 해당 표준 라이브러리 할당 함수에서 확보되지 않은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="013ee203d2185f13defcfecaa9d4ae3f3d4ae52b" translate="yes" xml:space="preserve">
          <source>In all cases, if the empty pair of braces &lt;code&gt;{} &lt;/code&gt; is used and &lt;code&gt;T&lt;/code&gt; is an</source>
          <target state="translated">모든 경우에 빈 쌍의 중괄호 &lt;code&gt;{} &lt;/code&gt; 가 사용되고 &lt;code&gt;T&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="9dfb4259d8b5e6ee928f73bc11c3685d70ea5622" translate="yes" xml:space="preserve">
          <source>In all cases, it is the stored pointer (the one returned by &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt;) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a shared_ptr created using the aliasing constructor.</source>
          <target state="translated">모든 경우에, 관리되는 포인터 (use_count가 0이 될 때 deleter에 전달 된 포인터)가 아닌 저장된 포인터 ( &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; 반환 한 포인터)입니다. 앨리어싱 생성자를 사용하여 만든 shared_ptr에서 두 포인터가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f050a06aeea57760c69721a08f3162ee7c38913e" translate="yes" xml:space="preserve">
          <source>In all cases, the conversion begins in initial shift state, unless non-initial starting state was provided to this &lt;code&gt;wstring_convert&lt;/code&gt; constructor. The number of characters converted and the final value of the conversion state are remembered and can be accessed with &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;converted&quot;&gt;converted()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">초기 값이 아닌 시작 상태가이 &lt;code&gt;wstring_convert&lt;/code&gt; 생성자 에 제공되지 않는 한 모든 경우에 변환은 초기 시프트 상태에서 시작됩니다 . 문자 수 변환하고 변환 된 상태의 최종 값으로 기억되고 액세스 될 수 &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;converted&quot;&gt;converted()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89b8bdb3cdd26cc5757a5fc307bf6e8cbadfa071" translate="yes" xml:space="preserve">
          <source>In all cases, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;size() + ins_count &amp;gt; max_size()&lt;/code&gt; where &lt;code&gt;ins_count&lt;/code&gt; is the number of characters that will be inserted and may throw any exceptions thrown by &lt;code&gt;Allocator::allocate&lt;/code&gt;.</source>
          <target state="translated">모든 경우에, &lt;code&gt;size() + ins_count &amp;gt; max_size()&lt;/code&gt; 이면 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 발생 합니다. 여기서 &lt;code&gt;ins_count&lt;/code&gt; 는 삽입 될 문자 수이며 &lt;code&gt;Allocator::allocate&lt;/code&gt; 의해 발생 된 예외를 발생시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6bec4825b469bd22420b217d83b3fa4ef3c1c3f" translate="yes" xml:space="preserve">
          <source>In all other cases the result is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">다른 모든 경우에 결과는 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c0ee8040c05c6072650b3fc884f5719734c12fb2" translate="yes" xml:space="preserve">
          <source>In all other cases, neither template is more specialized than the other with regards to the type(s) deduced by this P/A pair.</source>
          <target state="translated">다른 모든 경우에,이 P / A 쌍에 의해 추론 된 유형과 관련하여 어떤 템플릿도 다른 템플릿보다 더 전문화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e58e6d192ec64176fdc1379f81dba51aa0d986c8" translate="yes" xml:space="preserve">
          <source>In all other cases, the result is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">다른 모든 경우에는 결과가 정확하고 ( &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 는 절대 발생하지 않음) &lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드&lt;/a&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="725c5378c2d25e77fa8739dfffb5cdbf3d501bf2" translate="yes" xml:space="preserve">
          <source>In all these contexts, the function selected from the overload set is the function whose type matches the pointer to function, reference to function, or pointer to member function type that is expected by</source>
          <target state="translated">이러한 모든 상황에서, 과부하 세트에서 선택된 함수는 함수에 대한 포인터, 함수에 대한 참조 또는 멤버 함수에 대한 포인터와 일치하는 유형의 함수입니다.</target>
        </trans-unit>
        <trans-unit id="42e33142558dfcb4a52d9857fc0366f3d6fbcb3d" translate="yes" xml:space="preserve">
          <source>In an inline function,</source>
          <target state="translated">인라인 함수에서</target>
        </trans-unit>
        <trans-unit id="e54ee587ae8370595daaa17b48b214c6cedbda36" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;std::terminate&lt;/code&gt; calls the currently installed &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt;. The default &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">어쨌든 &lt;code&gt;std::terminate&lt;/code&gt; 는 현재 설치된 &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; 호출합니다 . 기본 &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d3dd5c3a82e6a3c58b090861766b926905a15762" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;str.width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">어떤 경우, &lt;code&gt;str.width(0)&lt;/code&gt; 의 효과를 취소하기 위해 호출됩니다 &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c3348754a124fedffbdcc31ba4b5c403932481c" translate="yes" xml:space="preserve">
          <source>In any case, an additional fictional function template derived as above from a hypothetical constructor &lt;code&gt;C(C)&lt;/code&gt; is added, called the copy deduction candidate.</source>
          <target state="translated">어쨌든, 가상 생성자 &lt;code&gt;C(C)&lt;/code&gt; 에서 위와 같이 파생 된 추가 허구 함수 템플릿 이 복사 공제 후보라고합니다.</target>
        </trans-unit>
        <trans-unit id="fa4b872de2f5ce03a3a38ccff298fd27acc8cd7f" translate="yes" xml:space="preserve">
          <source>In any case, container operations (as well as algorithms, or any other C++ standard library functions) may be parallelized internally as long as this does not change the user-visible results (e.g. &lt;code&gt;&lt;a href=&quot;algorithm/transform&quot;&gt;std::transform&lt;/a&gt;&lt;/code&gt; may be parallelized, but not &lt;code&gt;&lt;a href=&quot;algorithm/for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt; which is specified to visit each element of a sequence in order)</source>
          <target state="translated">어쨌든 컨테이너 작업 (알고리즘 또는 다른 C ++ 표준 라이브러리 함수)은 사용자가 볼 수있는 결과를 변경하지 않는 한 내부적으로 병렬화 될 수 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;algorithm/transform&quot;&gt;std::transform&lt;/a&gt;&lt;/code&gt; 은 병렬화 될 수 있지만 &lt;code&gt;&lt;a href=&quot;algorithm/for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt; 아닙니다 . : for_each 는 순서의 각 요소를 순서대로 방문하도록 지정됨)</target>
        </trans-unit>
        <trans-unit id="2da0390056e4062badb9f03f93f263c86a863ecf" translate="yes" xml:space="preserve">
          <source>In any case, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, it then stores a null character &lt;code&gt;CharT()&lt;/code&gt; into the next successive location of the array and updates &lt;code&gt;gcount()&lt;/code&gt;.</source>
          <target state="translated">어쨌든 &lt;code&gt;count&amp;gt;0&lt;/code&gt; 인 경우 null 문자 &lt;code&gt;CharT()&lt;/code&gt; 를 배열의 다음 연속 위치에 저장하고 &lt;code&gt;gcount()&lt;/code&gt; 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="4df2d850754842c746a077f1d7414c07173a5713" translate="yes" xml:space="preserve">
          <source>In any case, if U is an incomplete type, the program is ill-formed.</source>
          <target state="translated">어쨌든 U가 불완전한 유형이면 프로그램이 잘못 형성됩니다.</target>
        </trans-unit>
        <trans-unit id="ea9753e092b975406e86e9a75ca8490421b85d80" translate="yes" xml:space="preserve">
          <source>In any case, if an exception is thrown for any reason, this function has no effect (strong exception guarantee).</source>
          <target state="translated">어쨌든 어떤 이유로 든 예외가 발생하면이 기능은 영향을 미치지 않습니다 (강력한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="6ea5742f9037c3ece834bf38253ccb990e6ae335" translate="yes" xml:space="preserve">
          <source>In any case, if an exception is thrown for any reason, this function has no effect (strong exception guarantee).(since C++11).</source>
          <target state="translated">어쨌든 어떤 이유로 든 예외가 발생하면이 함수는 아무런 영향을 미치지 않습니다 (강력한 예외 보장). (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="5ad29af16c7a4b0eae9f716a384a3fe434c038e3" translate="yes" xml:space="preserve">
          <source>In any case, if any part of a type name is non-deduced, the entire type name is non-deduced context. However, compound types can include both deduced and non-deduced type names. For example, in &lt;code&gt;A&amp;lt;T&amp;gt;::B&amp;lt;T2&amp;gt;&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; is non-deduced because of rule #1 (nested name specifier), and &lt;code&gt;T2&lt;/code&gt; is non-deduced because it is part of the same type name, but in &lt;code&gt;void(*f)(typename A&amp;lt;T&amp;gt;::B, A&amp;lt;T&amp;gt;)&lt;/code&gt;, the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;A&amp;lt;T&amp;gt;::B&lt;/code&gt; is non-deduced (because of the same rule), while the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is deduced.</source>
          <target state="translated">어쨌든 유형 이름의 일부가 교육되지 않은 경우 전체 유형 이름은 교육되지 않은 컨텍스트입니다. 그러나 복합 유형에는 추론 된 유형 이름과 교육되지 않은 유형 이름이 모두 포함될 수 있습니다. 예를 들어, &lt;code&gt;A&amp;lt;T&amp;gt;::B&amp;lt;T2&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 는 규칙 # 1 (중첩 이름 지정자) 때문에 삭제되지 않으며 &lt;code&gt;T2&lt;/code&gt; 는 동일한 유형 이름의 일부이지만 &lt;code&gt;void(*f)(typename A&amp;lt;T&amp;gt;::B, A&amp;lt;T&amp;gt;)&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;A&amp;lt;T&amp;gt;::B&lt;/code&gt; 비 - 추론 (인해 동일한 규칙)하면서 &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="bac936a68f34bcde27ef8af2c5541d05870721a4" translate="yes" xml:space="preserve">
          <source>In any case, if the conversion function fails &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;</source>
          <target state="translated">어쨌든 변환 함수가 실패하면 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;err&lt;/code&gt; 에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="f692dd6979a28b812ff55210b84b6db94eddba7d" translate="yes" xml:space="preserve">
          <source>In any case, if the pointed-to type is different from the array element type, disregarding cv qualifications, at every level if the elements are themselves pointers, the behavior of pointer arithmetic is undefined. In particular, pointer arithmetic with pointer to base, which is pointing at an element of an array of derived objects is undefined.</source>
          <target state="translated">어쨌든 뾰족 대상 유형이 배열 요소 유형과 다르면 cv 규정을 무시하고 모든 레벨에서 요소 자체가 포인터 인 경우 포인터 산술의 동작은 정의되지 않습니다. 특히 파생 객체의 배열 요소를 가리키는 base에 대한 포인터를 사용한 포인터 산술은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6713811e3c955566cd61aabae4ba44639991bc9" translate="yes" xml:space="preserve">
          <source>In any case, if the value of the right operand is negative or is greater or equal to the number of bits in the promoted left operand, the behavior is undefined.</source>
          <target state="translated">어쨌든, 오른쪽 피연산자의 값이 음수이거나 승격 된 왼쪽 피연산자의 비트 수보다 크거나 같으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e408e1ffc24f4902a539b882cf7a3ebb2a011be7" translate="yes" xml:space="preserve">
          <source>In any case, sets the &lt;code&gt;gcount()&lt;/code&gt; counter to zero.</source>
          <target state="translated">&lt;code&gt;gcount()&lt;/code&gt; 카운터를 0으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d278d5d6ccb754380b757eb2f8bd5786624cf05" translate="yes" xml:space="preserve">
          <source>In any case, the argument list for the purpose of overload resolution is the argument list of the function call expression preceded by the implied object argument &lt;code&gt;E&lt;/code&gt; (when matching against the surrogate function, the user-defined conversion will automatically convert the implied object argument to the first argument of the surrogate function).</source>
          <target state="translated">어쨌든, 과부하 해결을 목적으로하는 인수 목록은 함축 된 객체 인수 &lt;code&gt;E&lt;/code&gt; 가 앞에 오는 함수 호출 표현식의 인수 목록입니다 (대리 함수와 일치하는 경우 사용자 정의 변환은 암시 적 객체 인수를 자동으로 변환합니다) 대리 함수의 첫 번째 인수).</target>
        </trans-unit>
        <trans-unit id="ba7e54962dc6ba91c1893f539a5af9b0dd3bcd03" translate="yes" xml:space="preserve">
          <source>In any case, the call to &lt;code&gt;std::async&lt;/code&gt;</source>
          <target state="translated">어쨌든 &lt;code&gt;std::async&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="ac7f68c6ecc54f2511911cdf7e14078e65684035" translate="yes" xml:space="preserve">
          <source>In any case, the check is made whether the &lt;code&gt;char&lt;/code&gt; obtained from the previous steps is allowed in the input field that would be parsed by &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; given the conversion specifier selected in Stage 1. If it is allowed, it is accumulated in a temporary buffer and Stage 2 repeats. If it is not allowed, Stage 2 terminates.</source>
          <target state="translated">어쨌든 이전 단계에서 얻은 &lt;code&gt;char&lt;/code&gt; 가 1 단계에서 선택한 변환 지정자를 지정하면 &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; 로 구문 분석 할 입력 필드에 허용 되는지 여부를 확인 합니다. 임시 버퍼 및 2 단계 반복. 허용되지 않으면 2 단계가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="7239f4c6ede432f98a1ba74015ef9a8efc5ff852" translate="yes" xml:space="preserve">
          <source>In any case, the path class behaves as if it stores a pathname in the native format and automatically converts to generic format as needed (each member function specifies which format it interprets the path as).</source>
          <target state="translated">어쨌든 경로 클래스는 경로 이름을 기본 형식으로 저장하는 것처럼 동작하고 필요에 따라 일반 형식으로 자동 변환합니다 (각 멤버 함수는 경로를 해석하는 형식을 지정합니다).</target>
        </trans-unit>
        <trans-unit id="d3d5f9fb69cc2220358beed9110dba0f5144fa1f" translate="yes" xml:space="preserve">
          <source>In any case, the result is a &lt;code&gt;bool&lt;/code&gt; prvalue.</source>
          <target state="translated">어쨌든 결과는 &lt;code&gt;bool&lt;/code&gt; prvalue입니다.</target>
        </trans-unit>
        <trans-unit id="bdbc8735ab228c93f4f0db0b86729ff991ed9876" translate="yes" xml:space="preserve">
          <source>In any case, the resulting value is one of at most two floating-point values closest to the value of the string matching the pattern, after rounding according to &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/float_round_style&quot;&gt;std::round_to_nearest&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">어쨌든 결과 값은 &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/float_round_style&quot;&gt;std::round_to_nearest&lt;/a&gt;&lt;/code&gt; 에 따라 반올림 한 후 패턴과 일치하는 문자열 값에 가장 가까운 최대 두 개의 부동 소수점 값 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="c407d2239a1860dec731b410278172d7d1e7af2e" translate="yes" xml:space="preserve">
          <source>In any case, updates the private member variable that is accessed by &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">어쨌든 &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; 의해 액세스되는 개인 멤버 변수를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="fd58a7b2537b4b1d9769b336c69ed0405e2bf357" translate="yes" xml:space="preserve">
          <source>In any event, whether terminating by exception or returning, the sentry's destructor is called before leaving this function.</source>
          <target state="translated">어떤 경우 든 예외로 종료하든 반환하든이 함수를 떠나기 전에 센트리 소멸자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9d70a008be456375cc51641818d2f498b0e8cfe0" translate="yes" xml:space="preserve">
          <source>In both cases, virt-specifier-seq, if used, is either &lt;code&gt;override&lt;/code&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;, or &lt;code&gt;final override&lt;/code&gt; or &lt;code&gt;override final&lt;/code&gt;.</source>
          <target state="translated">두 경우 모두 virt-specifier-seq는 사용되는 경우 &lt;code&gt;override&lt;/code&gt; 또는 &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; 또는 &lt;code&gt;final override&lt;/code&gt; 또는 &lt;code&gt;override final&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7735a0f86f64131cc2baeb3f9d91024df4a0f2ac" translate="yes" xml:space="preserve">
          <source>In brief, a class that defines &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; automatically gets compiler-generated operators ==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, and &amp;gt;=. A class can define &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; as defaulted, in which case the compiler will also generate the code for that operator.</source>
          <target state="translated">간단히 말해서 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 를 정의하는 클래스 는 컴파일러 생성 연산자 ==,! =, &amp;lt;, &amp;lt;=,&amp;gt; 및&amp;gt; =를 자동으로 가져 옵니다 . 클래스는 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 를 기본값으로 정의 할 수 있으며 ,이 경우 컴파일러는 해당 연산자에 대한 코드도 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b4aca348b75aa570f1a0831d21e79e759aa35c7a" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between a variable declaration using the direct-initialization syntax (1) (with round parentheses) and a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;, the compiler always chooses function declaration. This disambiguation rule is sometimes counter-intuitive and has been called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Most_vexing_parse&quot;&gt;most vexing parse&lt;/a&gt;.</source>
          <target state="translated">(둥근 괄호) 직접 초기화 구 (1)를 사용하여 변수 선언 및 사이 모호한 경우 &lt;a href=&quot;function&quot;&gt;함수 선언&lt;/a&gt; 컴파일러는 항상 함수 선언을 선택한다. 이 명확성 규칙은 때로는 직관적이지 않으며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Most_vexing_parse&quot;&gt;가장 까다로운 구문 분석&lt;/a&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="901202dfb183bd5273740fd75a6cb4999a9adde4" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between a variable declaration using the direct-initialization syntax and a function declaration, the compiler always chooses function declaration; see &lt;a href=&quot;direct_initialization#Notes&quot;&gt;direct-initialization&lt;/a&gt;.</source>
          <target state="translated">직접 초기화 구문을 사용한 변수 선언과 함수 선언이 모호한 경우 컴파일러는 항상 함수 선언을 선택합니다. &lt;a href=&quot;direct_initialization#Notes&quot;&gt;직접 초기화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="584cb1daba5fb668ec776aaad71f0f0a1e678a65" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between the size of the bit field and the default member initializer, the longest sequence of tokens that forms a valid size is chosen:</source>
          <target state="translated">비트 필드의 크기와 기본 멤버 이니셜 라이저 사이에 모호성이있는 경우 유효한 크기를 형성하는 가장 긴 토큰 시퀀스가 ​​선택됩니다.</target>
        </trans-unit>
        <trans-unit id="c60f89be5e6a24d3e9af482fb30cc5225a2b9c40" translate="yes" xml:space="preserve">
          <source>In class definition</source>
          <target state="translated">클래스 정의에서</target>
        </trans-unit>
        <trans-unit id="0ed480b0f5f767a36b4cca750fd3df5eb7dea2c0" translate="yes" xml:space="preserve">
          <source>In class template</source>
          <target state="translated">수업 템플릿에서</target>
        </trans-unit>
        <trans-unit id="88cf7e36aa40464925cb0cdb822a38f9a11a2e03" translate="yes" xml:space="preserve">
          <source>In class templates, &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;dependent_name&quot;&gt;dependent expression&lt;/a&gt;, and explicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; may be used to force another expression to become dependent.</source>
          <target state="translated">클래스 템플릿에서, &lt;code&gt;this&lt;/code&gt; A는 &lt;a href=&quot;dependent_name&quot;&gt;의존 표현&lt;/a&gt; 하고, 명시 적 &lt;code&gt;this-&amp;gt;&lt;/code&gt; 을 의존하는 다른 표현을 강제로 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="9bb902edc779601077555fd4ba8ae150af319a7a" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;std::fmod()&lt;/a&gt;&lt;/code&gt;, the returned value is not guaranteed to have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">대조적으로 &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;std::fmod()&lt;/a&gt;&lt;/code&gt; , 반환 값은 같은 부호가 보장되지 않습니다 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29e6d4a4833ba899fe54d6d48cb6237bf996c237" translate="yes" xml:space="preserve">
          <source>In copy-list-initialization, if phase 2 selects an explicit constructor, the initialization is ill-formed (as opposed to all over copy-initializations where explicit constructors are not even considered).</source>
          <target state="translated">copy-list-initialization에서 2 단계에서 명시 적 생성자를 선택하면 초기화가 잘못됩니다 (명시 적 생성자가 고려되지 않은 전체 복사 초기화와 반대).</target>
        </trans-unit>
        <trans-unit id="0f662aa9e7fe6829be9755a0bb2464c6d5830c0c" translate="yes" xml:space="preserve">
          <source>In declarations</source>
          <target state="translated">선언에서</target>
        </trans-unit>
        <trans-unit id="6cfdd0eb8f38950930fcb84521ccaa8ab0f3a576" translate="yes" xml:space="preserve">
          <source>In declarations, attributes may appear both before the whole declaration and directly after the name of the entity that is declared, in which case they are combined. In most other situations, attributes apply to the directly preceding entity.</source>
          <target state="translated">선언에서, 속성은 전체 선언 이전과 선언 된 엔티티의 이름 바로 뒤에 나타날 수 있으며이 경우 속성이 결합됩니다. 대부분의 다른 상황에서 속성은 직전의 엔터티에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2913833b48b2894352d88e1660f11e59aa09d3c6" translate="yes" xml:space="preserve">
          <source>In detail</source>
          <target state="translated">상세히</target>
        </trans-unit>
        <trans-unit id="9ea333fa04508f8dc9aec394ed0e05cc9396345e" translate="yes" xml:space="preserve">
          <source>In detail, the common comparison type of a list of n types T0...Tn-1 is defined as follows:</source>
          <target state="translated">구체적으로, n 타입 T0 ... Tn-1의리스트의 공통 비교 타입은 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="0c0bc79ad40602f6280764ba3e86b0386a7085c2" translate="yes" xml:space="preserve">
          <source>In detail:</source>
          <target state="translated">상세히:</target>
        </trans-unit>
        <trans-unit id="c02c2129e19b776dcabd51f1ec40f2e879325a96" translate="yes" xml:space="preserve">
          <source>In direct-list-initialization (but not in copy-list-initalization), when deducing the meaning of the &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; from a braced-init-list, the braced-init-list must contain only one element, and the type of auto will be the type of that element:</source>
          <target state="translated">직접 목록 초기화 (복사 목록 초기화는 아님) 에서 braced-init-list에서 &lt;a href=&quot;auto&quot;&gt;자동차&lt;/a&gt; 의 의미를 추론 할 때 braced-init-list는 하나의 요소 만 포함해야하며 auto 유형은 해당 요소의 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c32c9ac9a30d2bf4ad4aaca0daac65dbd6f4dbc0" translate="yes" xml:space="preserve">
          <source>In each case</source>
          <target state="translated">각각의 경우</target>
        </trans-unit>
        <trans-unit id="8ff5c44b9f8d73aec0aa66262a809a1b948e7c53" translate="yes" xml:space="preserve">
          <source>In each case, the object (or individual elements if &lt;code&gt;T&lt;/code&gt; is an array type)(since C++20) will be destroyed by &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;X&lt;/code&gt; is its type.</source>
          <target state="translated">각각의 경우에 객체 (또는 &lt;code&gt;T&lt;/code&gt; 가 배열 유형 인 경우 개별 요소 ) (C ++ 20부터)는 &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt; 의해 파괴됩니다 . 여기서 &lt;code&gt;p&lt;/code&gt; 는 객체에 대한 포인터이고 &lt;code&gt;X&lt;/code&gt; 는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a0acff1fbd7c81794afc6d04ed614676c2d1a5ea" translate="yes" xml:space="preserve">
          <source>In each context, the name of an overloaded function may be preceded by address-of operator &lt;code&gt;&amp;amp;&lt;/code&gt; and may be enclosed in a redundant set of parentheses.</source>
          <target state="translated">각각의 상황에서, 오버로드 된 함수의 이름 앞에는 주소 연산자 &lt;code&gt;&amp;amp;&lt;/code&gt; 가 올 수 있으며 중복 된 괄호 세트로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="580d311d2c3830913522a71b0ee0845b37f593cf" translate="yes" xml:space="preserve">
          <source>In either case, &lt;code&gt;std::unexpected&lt;/code&gt; calls the currently installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;. The default &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;std::unexpected&lt;/code&gt; 는 현재 설치된 &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; 호출합니다 . 기본 &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="6513d1fe43b0727e95c4ecbedbc97f1ff6159779" translate="yes" xml:space="preserve">
          <source>In either case, an additional null character value &lt;code&gt;CharT()&lt;/code&gt; is stored at the end of the output. If no characters were extracted, sets &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;failbit&lt;/code&gt;&lt;/a&gt; (the null character is still written, to the first position in the output). Finally, calls &lt;code&gt;st.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.  3).</source>
          <target state="translated">두 경우 모두 추가 null 문자 값 &lt;code&gt;CharT()&lt;/code&gt; 가 출력 끝에 저장됩니다. 추출 된 문자가없는 경우 &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;failbit&lt;/code&gt; &lt;/a&gt; 설정합니다 (널 문자는 여전히 출력의 첫 번째 위치에 기록됨). 마지막으로 &lt;code&gt;st.width(0)&lt;/code&gt; 을 호출 하여 &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 의 영향을 취소합니다 (있는 경우). 삼).</target>
        </trans-unit>
        <trans-unit id="8164d479fcc12457fe047a38c7a34d5e26adfd63" translate="yes" xml:space="preserve">
          <source>In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed (rebalancing may occur, as with &lt;code&gt;&lt;a href=&quot;erase&quot;&gt;erase()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">두 경우 모두 요소를 복사하거나 이동하지 않으며 컨테이너 노드의 내부 포인터 만 재 지정됩니다 (rease &lt;code&gt;&lt;a href=&quot;erase&quot;&gt;erase()&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 재조정이 발생할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="3eb50cbaf3e01225bd1ecea1bf00b9412ffb6b4a" translate="yes" xml:space="preserve">
          <source>In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed.</source>
          <target state="translated">두 경우 모두 요소를 복사하거나 이동하지 않으며 컨테이너 노드의 내부 포인터 만 다시 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="c657cee6a5de51a9466de54eb7a34b06cf204249" translate="yes" xml:space="preserve">
          <source>In either case, stores the number of characters extracted in the member variable accessed by subsequent calls to &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;sb&lt;/code&gt; is a null pointer or if no characters were inserted into &lt;code&gt;sb&lt;/code&gt;, calls &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if enabled).</source>
          <target state="translated">두 경우 모두 후속 &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; 호출로 액세스 한 멤버 변수에서 추출 된 문자 수를 저장합니다 . 경우 &lt;code&gt;sb&lt;/code&gt; 널 포인터인지, 또는 문자가 삽입되어 있지 않은 경우, &lt;code&gt;sb&lt;/code&gt; 호출 &lt;code&gt;setstate(failbit)&lt;/code&gt; (던질 수 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 사용할 수있는 경우)를.</target>
        </trans-unit>
        <trans-unit id="f958e451ccea1b7f622427f43a20430e7db91448" translate="yes" xml:space="preserve">
          <source>In existing implementations, the number of weak pointers is incremented (&lt;a href=&quot;https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p&quot;&gt;[2]&lt;/a&gt;) if there is a shared pointer to the same control block.</source>
          <target state="translated">기존 구현에서, 동일한 제어 블록에 대한 공유 포인터가있는 경우 약한 포인터의 수가 증가합니다 ( &lt;a href=&quot;https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected&quot;&gt;[1]&lt;/a&gt; , &lt;a href=&quot;https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p&quot;&gt;[2]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1241f4b4a5871614c0b0e937d887dd31b0d585a9" translate="yes" xml:space="preserve">
          <source>In expressions</source>
          <target state="translated">식에서</target>
        </trans-unit>
        <trans-unit id="db2370d3e7ba69273bdb62a10e047b42c0843bf1" translate="yes" xml:space="preserve">
          <source>In function-like macros, a &lt;code&gt;#&lt;/code&gt; operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called &quot;stringification&quot;. If the result of stringification is not a valid string literal, the behavior is undefined.</source>
          <target state="translated">함수형 매크로 에서 교체 목록의 식별자 앞에 있는 &lt;code&gt;#&lt;/code&gt; 연산자는 매개 변수 교체를 통해 식별자를 실행하고 결과를 따옴표로 묶어 문자열 리터럴을 효과적으로 만듭니다. 또한 프리 프로세서는 백 슬래시를 추가하여 임베드 된 문자열 리터럴을 둘러싼 따옴표를 이스케이프하고 필요한 경우 문자열 내 백 슬래시를 두 배로 늘립니다. 모든 선행 및 후행 공백이 제거되고 텍스트 중간에 포함 된 문자열 리터럴은 포함되지 않지만 일련의 공백은 단일 공백으로 축소됩니다. 이 작업을 &quot;문자열&quot;이라고합니다. 문자열 화 결과가 유효한 문자열 리터럴이 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a66e73cddda4a347472a74c2bcb63aabea7fcb6" translate="yes" xml:space="preserve">
          <source>In general, for any trivially copyable type &lt;code&gt;T&lt;/code&gt; and an object &lt;code&gt;obj1&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;, the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; can be copied (e.g. by means of &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;) into an array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt; or &lt;a href=&quot;byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt; or into &lt;code&gt;obj2&lt;/code&gt;, a distinct object of &lt;code&gt;T&lt;/code&gt;. Neither &lt;code&gt;obj1&lt;/code&gt; nor &lt;code&gt;obj2&lt;/code&gt; may be a potentially-overlapping subobject.</source>
          <target state="translated">일반적으로, 임의의 사소 복사 가능한 타입 &lt;code&gt;T&lt;/code&gt; 와 객체 &lt;code&gt;obj1&lt;/code&gt; 의 &lt;code&gt;T&lt;/code&gt; 의 하부 바이트 &lt;code&gt;obj1&lt;/code&gt; 복사 될 수있다 (예를 이용하여 &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; )의 배열로 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;a href=&quot;byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;obj2&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; 의 별개의 객체 . 둘 &lt;code&gt;obj1&lt;/code&gt; 도 &lt;code&gt;obj2&lt;/code&gt; 잠재적으로 중첩 하위 개체 일 수 없다.</target>
        </trans-unit>
        <trans-unit id="38fcfe4d6a87e17a455c75a9b0e425f272558b3d" translate="yes" xml:space="preserve">
          <source>In general, implicit conversion from one multi-level pointer to another follows the rules described in &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;qualification conversions&lt;/a&gt; and in &lt;a href=&quot;operator_comparison#Pointer_comparison_operators&quot;&gt;pointer comparison operators&lt;/a&gt;.</source>
          <target state="translated">일반적으로 한 멀티 레벨 포인터에서 다른 멀티 레벨 포인터로의 암시 적 변환은 &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;자격 변환&lt;/a&gt; 및 &lt;a href=&quot;operator_comparison#Pointer_comparison_operators&quot;&gt;포인터 비교 연산자&lt;/a&gt; 에 설명 된 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="81b4dfcd41b67e7e484427a572743c0af786423b" translate="yes" xml:space="preserve">
          <source>In general, the candidate function whose parameters match the arguments most closely is the one that is called.</source>
          <target state="translated">일반적으로 매개 변수가 인수와 가장 일치하는 후보 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1c76635c26067171ee4fb88a5e53efe29ca5200a" translate="yes" xml:space="preserve">
          <source>In general, the lifetime of a temporary cannot be further extended by &quot;passing it on&quot;: a second reference, initialized from the reference to which the temporary was bound, does not affect its lifetime.</source>
          <target state="translated">일반적으로 임시의 수명은 &quot;통과&quot;하여 연장 할 수 없습니다. 임시가 바인딩 된 참조에서 초기화 된 두 번째 참조는 수명에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b068778e762f7be532eacfc3e630095231dc1ab" translate="yes" xml:space="preserve">
          <source>In generic contexts, the destructor call syntax can be used with an object of non-class type; this is known as pseudo-destructor call: see &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member access operator&lt;/a&gt;.</source>
          <target state="translated">일반적인 문맥에서 소멸자 호출 구문은 비 클래스 유형의 객체와 함께 사용할 수 있습니다. 이것을 의사 소멸자 호출이라고합니다. &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;멤버 액세스 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e96e30536ed7d7370721a29eb0a3baf8e9861d0" translate="yes" xml:space="preserve">
          <source>In locales other than &lt;code&gt;&quot;C&quot;&lt;/code&gt;, an alphabetic character is a character for which &lt;code&gt;std::isupper()&lt;/code&gt; or &lt;code&gt;std::islower()&lt;/code&gt; returns non-zero or any other character considered alphabetic by the locale. In any case, &lt;code&gt;std::iscntrl()&lt;/code&gt;, &lt;code&gt;std::isdigit()&lt;/code&gt;, &lt;code&gt;std::ispunct()&lt;/code&gt; and &lt;code&gt;std::isspace()&lt;/code&gt; will return zero for this character.</source>
          <target state="translated">&lt;code&gt;&quot;C&quot;&lt;/code&gt; 이외의 로케일 에서 알파벳 문자는 &lt;code&gt;std::isupper()&lt;/code&gt; 또는 &lt;code&gt;std::islower()&lt;/code&gt; 가 0이 아닌 문자 또는 로케일에 의해 알파벳으로 간주되는 다른 문자를 리턴하는 문자입니다. 어쨌든 &lt;code&gt;std::iscntrl()&lt;/code&gt; , &lt;code&gt;std::isdigit()&lt;/code&gt; , &lt;code&gt;std::ispunct()&lt;/code&gt; 및 &lt;code&gt;std::isspace()&lt;/code&gt; 는이 문자에 대해 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c7ad051625c76a00388473f47c41ae5d264a453" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">많은 구현에서 &lt;code&gt;is_nothrow_constructible&lt;/code&gt; 은 효과적으로 &lt;code&gt;noexcept(T(arg))&lt;/code&gt; 이므로 소멸자가 던지는 지 확인합니다 . &lt;code&gt;is_trivially_constructible&lt;/code&gt; 에도 동일하게 적용되며 ,이 구현에서는 소멸자가 간단해야합니다. &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC 버그 51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG 문제 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33323ec4f069d0c0b878342b0a8185699b19819e" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_copy_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_copy_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">많은 구현에서 &lt;code&gt;is_nothrow_copy_constructible&lt;/code&gt; 은 효과적으로 &lt;code&gt;noexcept(T(arg))&lt;/code&gt; 이므로 소멸자가 던지는 지 확인합니다 . &lt;code&gt;is_trivially_copy_constructible&lt;/code&gt; 에도 동일하게 적용되며 ,이 구현에서는 소멸자가 간단해야합니다. &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC 버그 51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG 문제 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="accf831c87b14d37d2cc6eafd0090b844f5f9b51" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_default_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T())&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_default_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">많은 구현에서 &lt;code&gt;is_nothrow_default_constructible&lt;/code&gt; 은 효과적으로 &lt;code&gt;noexcept(T())&lt;/code&gt; 이므로 소멸자가 던지는 지 확인합니다 . &lt;code&gt;is_trivially_default_constructible&lt;/code&gt; 에도 동일하게 적용되며 ,이 구현에서는 소멸자가 간단해야합니다. &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d90dd0a15587a98cbedbb69df63e111504c94d0" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_move_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_move_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">많은 구현에서 &lt;code&gt;is_nothrow_move_constructible&lt;/code&gt; 은 효과적으로 &lt;code&gt;noexcept(T(arg))&lt;/code&gt; 이므로 소멸자가 던지는 지 확인합니다 . &lt;code&gt;is_trivially_move_constructible&lt;/code&gt; 에도 동일하게 적용되며 ,이 구현에서는 소멸자가 간단해야합니다. &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC 버그 51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG 문제 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f61cbb399593cd96a01d7c1e70f3b86ca51dd80" translate="yes" xml:space="preserve">
          <source>In many implementations, standard output is line-buffered, and writing &lt;code&gt;'\n'&lt;/code&gt; causes a flush anyway, unless &lt;code&gt;std::ios::sync_with_stdio(false)&lt;/code&gt; was executed. In those situations, unnecessary &lt;code&gt;endl&lt;/code&gt; only degrades the performance of file output, not standard output.</source>
          <target state="translated">많은 구현에서 표준 출력은 라인 버퍼링되며 &lt;code&gt;std::ios::sync_with_stdio(false)&lt;/code&gt; 를 실행 하지 않으면 &lt;code&gt;'\n'&lt;/code&gt; 쓰면 플러시가 발생합니다 . 이러한 상황에서 불필요한 &lt;code&gt;endl&lt;/code&gt; 은 표준 출력이 아닌 파일 출력의 성능 만 저하시킵니다.</target>
        </trans-unit>
        <trans-unit id="b5cc9d63c613364dc5793e8e7ac9b68a692864f4" translate="yes" xml:space="preserve">
          <source>In many situations, copy constructors are optimized out even if they would produce observable side-effects, see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">많은 상황에서 복사 생성자는 관찰 가능한 부작용을 생성하더라도 최적화됩니다 . &lt;a href=&quot;copy_elision&quot;&gt;복사&lt;/a&gt; 제거를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="361bbab390512b139df616a956291652c3a5e8eb" translate="yes" xml:space="preserve">
          <source>In most implementations, this function updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">대부분의 구현에서이 함수 는 문자열을 통해 처리 할 때 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 유형의 전역 정적 객체를 업데이트하며 두 스레드에서 동시에 호출 할 수 없으므로 &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="49690d1d0c037eea359d8320b2de46145cef5181" translate="yes" xml:space="preserve">
          <source>In most implementations, this function updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">대부분의 구현에서이 함수 는 문자열을 통해 처리 할 때 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 유형의 전역 정적 객체를 업데이트하며 두 스레드에서 동시에 호출 할 수 없으므로 &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="88d76a48f8f96c35da8c08d45a4e62de40b811d7" translate="yes" xml:space="preserve">
          <source>In most implementations, this returns &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt;.</source>
          <target state="translated">대부분의 구현에서 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9dfeb8ee21790e4ab7902716cd854784402ed77a" translate="yes" xml:space="preserve">
          <source>In multithreaded environment, the value returned by use_count is approximate (typical implementations use a &lt;a href=&quot;../../atomic/memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt; load).</source>
          <target state="translated">멀티 스레드 환경에서 use_count에 의해 리턴되는 값은 근사치입니다 (일반적인 구현에서는 &lt;a href=&quot;../../atomic/memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt; 로드 사용).</target>
        </trans-unit>
        <trans-unit id="b0b00c8c047435001bd2de135f45ca01beaae4c1" translate="yes" xml:space="preserve">
          <source>In namespace and block scope</source>
          <target state="translated">네임 스페이스 및 블록 범위에서</target>
        </trans-unit>
        <trans-unit id="20891e1e3bb66c9419f1d516300d8501998694a6" translate="yes" xml:space="preserve">
          <source>In old or nonconforming compilers, using the &lt;a href=&quot;../language/operator_alternative&quot;&gt;alternative operator representations&lt;/a&gt; may still require including this header.</source>
          <target state="translated">구형 또는 부적합 컴파일러에서 &lt;a href=&quot;../language/operator_alternative&quot;&gt;대체 연산자 표현을&lt;/a&gt; 사용하려면 이 헤더를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="976a60901e43304c76c9540f3f429a8d9f4c6a87" translate="yes" xml:space="preserve">
          <source>In order for a template to be instantiated, every template parameter (type, non-type, or template) must be replaced by a corresponding template argument. For &lt;a href=&quot;class_template&quot;&gt;class templates&lt;/a&gt;, the arguments are either explicitly provided, &lt;a href=&quot;deduction_guide&quot;&gt;deduced from the initializer&lt;/a&gt;, (since C++17) or defaulted. For &lt;a href=&quot;function_template&quot;&gt;function templates&lt;/a&gt;, the arguments are explicitly provided, &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced from the context&lt;/a&gt;, or defaulted.</source>
          <target state="translated">템플릿을 인스턴스화하려면 모든 템플릿 매개 변수 (유형, 비 유형 또는 템플릿)를 해당 템플릿 인수로 바꿔야합니다. 들어 &lt;a href=&quot;class_template&quot;&gt;클래스 템플릿&lt;/a&gt; , 인수가 명시 적으로 제공됩니다 &lt;a href=&quot;deduction_guide&quot;&gt;이니셜 라이저에서 추론&lt;/a&gt; (17 ++ C 이후) 또는 기본값. 들어 &lt;a href=&quot;function_template&quot;&gt;기능 템플릿&lt;/a&gt; , 인수는 명시 적으로 제공되는 &lt;a href=&quot;template_argument_deduction&quot;&gt;문맥에서 추론&lt;/a&gt; , 또는 기본값.</target>
        </trans-unit>
        <trans-unit id="2d740db339a5645df895be9040440821225a705c" translate="yes" xml:space="preserve">
          <source>In order for an exception to be caught, the throw-expression has to be inside a &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt; or inside a function called from a try-block, and there has to be a &lt;a href=&quot;try_catch&quot;&gt;catch clause&lt;/a&gt; that matches the type of the exception object.</source>
          <target state="translated">예외를 포착하려면 throw-expression이 &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt; 내부 또는 try-block 에서 호출 된 함수 내에 있어야하며 예외 객체의 유형과 일치 하는 &lt;a href=&quot;try_catch&quot;&gt;catch 절이&lt;/a&gt; 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b7a11d6633f27612217d043955d8513b0eaf805c" translate="yes" xml:space="preserve">
          <source>In order to compile a function call, the compiler must first perform &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, which, for functions, may involve &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;, and for function templates may be followed by &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;. If these steps produce more than one</source>
          <target state="translated">함수 호출을 컴파일하려면 컴파일러는 먼저 &lt;a href=&quot;lookup&quot;&gt;이름 조회를&lt;/a&gt; 수행해야합니다. 이름 조회 는 함수의 경우 &lt;a href=&quot;adl&quot;&gt;인수 종속 조회를&lt;/a&gt; 포함 할 수 있으며 함수 템플리트의 경우 &lt;a href=&quot;template_argument_deduction&quot;&gt;템플리트 인수 추론&lt;/a&gt; 이 뒤따를 수 있습니다 . 이 단계에서 둘 이상을 생성하는 경우</target>
        </trans-unit>
        <trans-unit id="c439dee89b66538a41331ba7addd781be9e95710" translate="yes" xml:space="preserve">
          <source>In order to examine all matches within the target sequence, &lt;code&gt;std::regex_search&lt;/code&gt; may be called in a loop, restarting each time from &lt;code&gt;m[0].second&lt;/code&gt; of the previous call. &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; offers an easy interface to this iteration.</source>
          <target state="translated">대상 시퀀스 내의 모든 일치 항목을 검사하기 위해 &lt;code&gt;std::regex_search&lt;/code&gt; 가 루프에서 호출되어 매번 이전 호출의 &lt;code&gt;m[0].second&lt;/code&gt; 부터 다시 시작될 수 있습니다. &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; 는이 반복에 대한 쉬운 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="93e5fcbc9e67b4e1b987a567473422ebf0dee92c" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt;, every template argument must be known, but not every template argument has to be specified. In the following contexts the compiler will deduce the missing template arguments from the type of the initializer:</source>
          <target state="translated">&lt;a href=&quot;class_template&quot;&gt;클래스 템플릿&lt;/a&gt; 을 인스턴스화하려면 모든 템플릿 인수를 알아야하지만 모든 템플릿 인수를 지정해야하는 것은 아닙니다. 다음 컨텍스트에서 컴파일러는 이니셜 라이저 형식에서 누락 된 템플릿 인수를 추론합니다.</target>
        </trans-unit>
        <trans-unit id="9bf61b9c2f6c8ed792b21ac9dd2327e234ccbf15" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted, when an address of a function template is taken, and in some &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;other contexts&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;function_template&quot;&gt;함수 template&lt;/a&gt; 을 인스턴스화하려면 모든 템플릿 인수를 알아야하지만 모든 템플릿 인수를 지정해야하는 것은 아닙니다. 가능한 경우 컴파일러는 함수 인수에서 누락 된 템플리트 인수를 추론합니다. 이것은 함수 호출이 시도 될 때, 함수 템플릿의 주소가 취해질 때, 그리고 &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;다른 상황에서 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8076ca3c217ff4a7a98ccc16264bf0332155e2a1" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;strong&gt;function template&lt;/strong&gt;, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted and when an address of a function template is taken.</source>
          <target state="translated">&lt;strong&gt;함수 template&lt;/strong&gt; 을 인스턴스화하려면 모든 템플릿 인수를 알아야하지만 모든 템플릿 인수를 지정해야하는 것은 아닙니다. 가능한 경우 컴파일러는 함수 인수에서 누락 된 템플리트 인수를 추론합니다. 함수 호출을 시도 할 때와 함수 템플리트의 주소를 가져올 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed244da1aecd793a261081beab12c67de2da00bb" translate="yes" xml:space="preserve">
          <source>In order to satisfy alignment requirements of all non-static members of a &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt;,</source>
          <target state="translated">순서에서의 모든 비 정적 멤버의 정렬 요구 사항을 만족하는 &lt;a href=&quot;class&quot;&gt;클래스를&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="2dce1c16904fec9d3889052abdb4ab00a4c0f330" translate="yes" xml:space="preserve">
          <source>In order to satisfy the requirements of array-oriented access, an implementation is constrained to store the real and imaginary components of a &lt;code&gt;std::complex&lt;/code&gt; specialization in separate and adjacent memory locations. Possible declarations for its non-static data members include:</source>
          <target state="translated">어레이 지향 액세스의 요구 사항을 만족시키기 위해, 구현은 &lt;code&gt;std::complex&lt;/code&gt; 전문화 의 실제 및 가상 컴포넌트를 별개의 인접 메모리 위치 에 저장하도록 제한된다 . 비 정적 데이터 멤버에 가능한 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d223a004acbe8c2ee4258ddff41fb5bd9c563a88" translate="yes" xml:space="preserve">
          <source>In order to wait in a shared mutex in shared ownership mode, &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; can be used (&lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; requires &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and so can only wait in unique ownership mode).</source>
          <target state="translated">공유 소유권 모드의 공유 뮤텍스에서 대기하려면 &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; 필요 하므로 고유 한 소유권 모드에서만 대기 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="a0570d7fb641b108923426180a7da145cd589a42" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;std::bind_front(f, bound_args...)(call_args...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(f, bound_args..., call_args....)&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;std::bind_front(f, bound_args...)(call_args...)&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(f, bound_args..., call_args....)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9c4cf6f1de09d5243e6d12c4b6e447d38d42628" translate="yes" xml:space="preserve">
          <source>In other words, after replacing the type (e.g. an iterator type) in a well-formed non-aggregate initialization with &lt;code&gt;dangling&lt;/code&gt;, the resulting initialization is also well-formed.</source>
          <target state="translated">다시 말해, 잘 구성된 비 집계 초기화의 유형 (예 : 반복자 유형)을 &lt;code&gt;dangling&lt;/code&gt; 으로 바꾼 후 결과 초기화도 올바르게 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2fdcde52c9613f8d9965c24cc761c64f7f29bbf9" translate="yes" xml:space="preserve">
          <source>In other words, if an algorithm takes a Predicate &lt;code&gt;pred&lt;/code&gt; and an iterator &lt;code&gt;first&lt;/code&gt;, it should be able to test the object of the type pointed to by the iterator &lt;code&gt;first&lt;/code&gt; using the given predicate via a construct like &lt;code&gt;if(pred(*first)) {...}&lt;/code&gt;.</source>
          <target state="translated">알고리즘이 걸리면 즉, 술어 &lt;code&gt;pred&lt;/code&gt; 이터레이터는 &lt;code&gt;first&lt;/code&gt; , 그 유형의 오브젝트가 반복자 가리키는 테스트 할 수 있어야 &lt;code&gt;first&lt;/code&gt; 컨스 통해 주어진 술어를 사용하여 같은 &lt;code&gt;if(pred(*first)) {...}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="491de468bd659078aefdfec90cf19da2bcde4cae" translate="yes" xml:space="preserve">
          <source>In other words, the conversion to the common reference type must preserve equality.</source>
          <target state="translated">즉, 공통 참조 유형으로의 변환은 동등성을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="1515a939c60d7a0551eb77267cda9623a3ec082e" translate="yes" xml:space="preserve">
          <source>In other words, the conversion to the common type must preserve equality.</source>
          <target state="translated">다시 말해, 공통 유형으로의 변환은 평등을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7bf915fd2c7af366ac00ae6abbc509a778d1910" translate="yes" xml:space="preserve">
          <source>In other words, the summation operations may be performed in arbitrary order, and the behavior is nondeterministic if &lt;code&gt;binary_op&lt;/code&gt; is not associative.</source>
          <target state="translated">다시 말해서, 합산 동작은 임의의 순서로 수행 될 수 있으며, &lt;code&gt;binary_op&lt;/code&gt; 가 연관되지 않으면 동작은 비 결정적 이다.</target>
        </trans-unit>
        <trans-unit id="a80c785731fa7946b71b60f0a1b2f2901be26657" translate="yes" xml:space="preserve">
          <source>In overload (1), if &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and T is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">경우 과부하 (1)에서, &lt;code&gt;T&lt;/code&gt; 의 이동 생성자가 아닌 &lt;code&gt;noexcept&lt;/code&gt; 및 T가 아닌 &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; 에 &lt;code&gt;*this&lt;/code&gt; , 벡터 던지는 이동 생성자를 사용합니다. 던지면 보증이 면제되고 효과는 명시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da0255ac708e972224b54cc46137f223d8fcb17c" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;std::move&lt;/code&gt; produces an &lt;a href=&quot;../language/value_category&quot;&gt;xvalue expression&lt;/a&gt; that identifies its argument &lt;code&gt;t&lt;/code&gt;. It is exactly equivalent to a static_cast to an rvalue reference type.</source>
          <target state="translated">특히 &lt;code&gt;std::move&lt;/code&gt; 는 인수 &lt;code&gt;t&lt;/code&gt; 를 식별 하는 &lt;a href=&quot;../language/value_category&quot;&gt;xvalue 표현식&lt;/a&gt; 을 생성합니다 . rvalue 참조 유형에 대한 static_cast와 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bc5f562f16c7f3516fd8ac3ab2d0a32811211b88" translate="yes" xml:space="preserve">
          <source>In particular, all hard links for the same file or directory are equivalent, and a symlink and its target on the same file system are equivalent.</source>
          <target state="translated">특히, 동일한 파일 또는 디렉토리에 대한 모든 하드 링크는 동일하며 동일한 파일 시스템의 심볼릭 링크 및 대상은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6c9eea59b15650f810d84d6038841dd320cdfa3e" translate="yes" xml:space="preserve">
          <source>In particular, for negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt;, the formatting may appear as &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt;, while for negative_sign of &lt;code&gt;&quot;()&quot;&lt;/code&gt; it would appear as &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt;.</source>
          <target state="translated">특히, &lt;code&gt;&quot;-&quot;&lt;/code&gt; 의 negative_sign의 경우 형식은 &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; 로 나타날 수 있지만 &lt;code&gt;&quot;()&quot;&lt;/code&gt; 의 negative_sign의 경우 &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; 로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="e9805358780c9313bdf8b46c3d77f45f54ffa9c0" translate="yes" xml:space="preserve">
          <source>In particular, like all rvalues, xvalues bind to rvalue references, and like all glvalues, xvalues may be &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;, and non-class xvalues may be &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;.</source>
          <target state="translated">특히, 모든 rvalue와 마찬가지로 xvalue도 rvalue 참조에 바인딩되며 모든 glvalue와 마찬가지로 xvalue는 &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;다형성&lt;/a&gt; 일 수 있으며 비 클래스 xvalue는 &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3440815d0cff772e37f45dd6a4e47c1dc0bf363e" translate="yes" xml:space="preserve">
          <source>In particular, non-copyable arguments and array to pointer conversion.</source>
          <target state="translated">특히 복사 할 수없는 인수와 배열에서 포인터로의 변환입니다.</target>
        </trans-unit>
        <trans-unit id="25d069cd55a0e3cbff6493480ec850fae36c0fdc" translate="yes" xml:space="preserve">
          <source>In particular, this implies that string literals, addresses of array elements, and addresses of non-static members cannot be used as template arguments to instantiate templates whose corresponding non-type template parameters are pointers to objects.</source>
          <target state="translated">특히, 이는 문자열 리터럴, 배열 요소의 주소 및 비 정적 멤버의 주소를 해당 비 타입 템플릿 매개 변수가 객체에 대한 포인터 인 템플릿을 인스턴스화하기위한 템플릿 인수로 사용할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="16b8d6ec9c39d406c45bf8c3a95070cf38451515" translate="yes" xml:space="preserve">
          <source>In particular, this implies that the failures of constructors (see also &lt;a href=&quot;raii&quot;&gt;RAII&lt;/a&gt;) and most operators should be reported by throwing exceptions.</source>
          <target state="translated">특히, 이는 생성자의 실패 ( &lt;a href=&quot;raii&quot;&gt;RAII&lt;/a&gt; 참조 ) 및 대부분의 연산자는 예외를 발생시켜보고해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6bd64e741fcbffe364b20bed2e39dc776e83f8c6" translate="yes" xml:space="preserve">
          <source>In particular, this implies that.</source>
          <target state="translated">특히 이것은 이것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7778e57383bfe144db5dc5276001e50344a7eb81" translate="yes" xml:space="preserve">
          <source>In practice, constant initialization is performed at compile time, and pre-calculated object representations are stored as part of the program image (e.g. in the &lt;code&gt;.data&lt;/code&gt; section). If a variable is both &lt;code&gt;const&lt;/code&gt; and constant-initialized, its object representation may be stored in a read-only section of the program image (e.g. the &lt;code&gt;.rodata&lt;/code&gt; section).</source>
          <target state="translated">실제로, 컴파일시 상수 초기화가 수행되고 사전 계산 된 객체 표현이 프로그램 이미지의 일부 (예 : &lt;code&gt;.data&lt;/code&gt; 섹션)로 저장됩니다. 변수가 &lt;code&gt;const&lt;/code&gt; 이고 상수로 초기화 된 경우, 객체 표현은 프로그램 이미지의 읽기 전용 섹션 (예 : &lt;code&gt;.rodata&lt;/code&gt; 섹션)에 저장 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5f7e6132c24b431ab05a1b29a68ed1255266ac7" translate="yes" xml:space="preserve">
          <source>In practice, implementations of &lt;code&gt;std::copy&lt;/code&gt; avoid multiple assignments and use bulk copy functions such as &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; if the value type is &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;.</source>
          <target state="translated">실제로 &lt;code&gt;std::copy&lt;/code&gt; 구현은 다중 지정을 피하고 값 유형이 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable 인&lt;/a&gt; 경우 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; 와 같은 대량 복사 기능을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="4166dd075003042b54540673bbf26b17c11851e9" translate="yes" xml:space="preserve">
          <source>In practice, they may be implemented as function objects, or with special compiler extensions.</source>
          <target state="translated">실제로는 함수 객체 또는 특수 컴파일러 확장으로 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66affe68d971b057413c1675fbe61348d2fbb2ee" translate="yes" xml:space="preserve">
          <source>In practice, this means that the synchronized C++ streams are unbuffered, and each I/O operation on a C++ stream is immediately applied to the corresponding C stream's buffer. This makes it possible to freely mix C++ and C I/O.</source>
          <target state="translated">실제로 이는 동기화 된 C ++ 스트림이 버퍼되지 않고 C ++ 스트림의 각 I / O 작업이 해당 C 스트림의 버퍼에 즉시 적용됨을 의미합니다. 이를 통해 C ++와 CI / O를 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9d5344404c3cda159f179c91a199091db72dee1" translate="yes" xml:space="preserve">
          <source>In simple cases, both pImpl and factory method break compile-time dependency between the implementation and the users of the class interface. Factory method creates a hidden dependency on the vtable, and so reordering, adding, or removing virtual member functions breaks the ABI. The pImpl approach has no hidden dependencies, however if the implementation class is a class template specialization, the compilation firewall benefit is lost: the users of the interface must observe the entire template definition in order to instantiate the correct specialization. A common design approach in this case is to refactor the implementation in a way that avoids parametrization, this is another use case for the C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rt-scary&quot;&gt;T.61 Do not over-parametrize members&lt;/a&gt; and &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface&quot;&gt;T.84 Use a non-template core implementation to provide an ABI-stable interface&lt;/a&gt;.</source>
          <target state="translated">간단한 경우, pImpl과 팩토리 메소드는 구현과 클래스 인터페이스 사용자 사이의 컴파일 타임 종속성을 손상시킵니다. 팩토리 메소드는 vtable에 숨겨진 종속성을 작성하므로 가상 멤버 함수를 재정렬, 추가 또는 제거하면 ABI가 중단됩니다. pImpl 접근 방식에는 숨겨진 종속성이 없지만 구현 클래스가 클래스 템플리트 전문화 인 경우 컴파일 방화벽 이점이 손실됩니다. 인터페이스 사용자는 올바른 특수화를 인스턴스화하기 위해 전체 템플리트 정의를 관찰해야합니다. 이 경우 일반적인 디자인 접근 방식은 매개 변수화를 방지하는 방식으로 구현을 리팩토링하는 것입니다, 이것은 C ++ 핵심 가이드 라인에 대한 또 다른 사용 사례입니다 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rt-scary&quot;&gt;T.61 음주하지 오버 변수화 회원&lt;/a&gt; 및&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface&quot;&gt;T.84 템플릿이 아닌 핵심 구현을 사용하여 ABI 안정적인 인터페이스를 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e257383e8a791be56a7795dcfa164d94b6cff0ea" translate="yes" xml:space="preserve">
          <source>In some contexts, only type names can validly appear. In these contexts, a dependent qualified name is assumed to name a type and no &lt;code&gt;typename&lt;/code&gt; is required:</source>
          <target state="translated">일부 상황에서는 유형 이름 만 유효하게 나타날 수 있습니다. 이러한 맥락에서, 종속 자격을 갖춘 이름은 형의 이름을 가정하고 어떤 &lt;code&gt;typename&lt;/code&gt; 필요하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="b4f0ab4a86013d411969196467703372e7da8ad4" translate="yes" xml:space="preserve">
          <source>In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as &quot;shift sequences&quot;. Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are the 7-bit JIS, BOCU-1 and &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt;.</source>
          <target state="translated">일부 멀티 바이트 인코딩에서, 임의의 주어진 멀티 바이트 문자 시퀀스는 &quot;시프트 시퀀스&quot;로 알려진 이전 바이트 시퀀스에 따라 다른 문자를 나타낼 수있다. 이러한 인코딩은 상태에 따라 다릅니다. 각 문자를 해석하려면 현재 이동 상태에 대한 지식이 필요합니다. NTMBS는 초기 시프트 상태에서 시작하고 끝나는 경우에만 유효합니다. 시프트 시퀀스가 ​​사용 된 경우 해당하는 언 시프트 시퀀스는 종료 널 문자 앞에 있어야합니다. 이러한 인코딩의 예는 7 비트 JIS, BOCU-1 및 &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="621567d318323c5c0c22b8501fb1f3c5e2acd90e" translate="yes" xml:space="preserve">
          <source>In such a nested declaration, some of the levels may remain unspecialized (except that it can't specialize a class member template if its enclosing class is unspecialized). For each of those levels, the declaration needs &lt;code&gt;template&amp;lt;arguments&amp;gt;&lt;/code&gt;, because such specializations are themselves templates:</source>
          <target state="translated">이러한 중첩 선언에서 일부 레벨은 특수화되지 않은 상태로 남아있을 수 있습니다 (클로징 클래스가 특수화되지 않은 경우 클래스 멤버 템플리트를 특수화 할 수없는 경우 제외). 각 레벨마다 선언은 &lt;code&gt;template&amp;lt;arguments&amp;gt;&lt;/code&gt; 필요합니다. 이러한 전문화 자체는 템플리트이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="816350383b2c1e072a6ac4d701ae17bc019c55f8" translate="yes" xml:space="preserve">
          <source>In the C programming language, at least one named parameter must appear before the ellipsis parameter, so &lt;code&gt;printz(...);&lt;/code&gt; is not valid. In C++, this form is allowed even though the arguments passed to such function are not accessible, and is commonly used as the fallback overload in &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;, exploiting the lowest priority of the ellipsis conversion in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="translated">C 프로그래밍 언어에서 하나 이상의 명명 된 매개 변수가 생략 매개 변수 앞에 나타나므로 &lt;code&gt;printz(...);&lt;/code&gt; 유효하지 않습니다. C ++에서는 이러한 함수에 전달 된 인수에 액세스 할 수없는 경우에도이 형식이 허용되며 일반적으로 &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; 에서 폴백 오버로드로 사용 되어 &lt;a href=&quot;overload_resolution&quot;&gt;오버로드 해상도&lt;/a&gt; 에서 줄임표 변환의 우선 순위가 가장 낮습니다 .</target>
        </trans-unit>
        <trans-unit id="b7448b8bb4cfc9ef5b6d6148816f9abc314f332d" translate="yes" xml:space="preserve">
          <source>In the C programming language, the &lt;code&gt;goto&lt;/code&gt; statement has fewer restrictions and can enter the scope of any variable other than variable-length array or variably-modified pointer.</source>
          <target state="translated">C 프로그래밍 언어에서 &lt;code&gt;goto&lt;/code&gt; 문은 제한이 적으며 가변 길이 배열 또는 가변적으로 수정 된 포인터 이외의 변수 범위를 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11df4d5daefca94681eb0c6608609ae515a3f4d3" translate="yes" xml:space="preserve">
          <source>In the C programming language, the width of a bit field cannot exceed the width of the underlying type.</source>
          <target state="translated">C 프로그래밍 언어에서 비트 필드의 너비는 기본 유형의 너비를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfc682244d852627ff0d041c2287a081b50d47c4" translate="yes" xml:space="preserve">
          <source>In the above example, if non-ADL lookup for operator&amp;lt;&amp;lt; were allowed from the instantiation context, the instantiation of &lt;code&gt;E::writeObject&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; would have two different definitions: one using &lt;code&gt;P1::operator&amp;lt;&amp;lt;&lt;/code&gt; and one using &lt;code&gt;P2::operator&amp;lt;&amp;lt;&lt;/code&gt;. Such ODR violation may not be detected by the linker, leading to one or the other being used in both instances.</source>
          <target state="translated">위의 예에서 인스턴스화 컨텍스트에서 operator &amp;lt;&amp;lt;에 대한 비 ADL 조회가 허용 된 경우 &lt;code&gt;E::writeObject&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; 의 인스턴스화 는 두 가지 다른 정의를 갖습니다. 하나는 &lt;code&gt;P1::operator&amp;lt;&amp;lt;&lt;/code&gt; 하고 하나는 사용 &lt;code&gt;P2::operator&amp;lt;&amp;lt;&lt;/code&gt; . 이러한 ODR 위반은 링커에 의해 감지되지 않을 수 있으며 이로 인해 두 인스턴스에서 하나 또는 다른 하나가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="translated">위의</target>
        </trans-unit>
        <trans-unit id="f761fd1f890c95288965ab17065f5bc7b6d6b538" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;Alloc&lt;/code&gt; is a type that satisfies &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;or is a pointer type convertible to &lt;code&gt;std::experimental::pmr::memory_resource*&lt;/code&gt;(library fundamentals TS).</source>
          <target state="translated">위의 &lt;code&gt;Alloc&lt;/code&gt; 은 &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; 를 만족하는 유형 이거나 &lt;code&gt;std::experimental::pmr::memory_resource*&lt;/code&gt; (라이브러리 기본 TS) 로 변환 할 수있는 포인터 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="4cc61cf6708e3ef42bac60b85582a7b7be2f3f6f" translate="yes" xml:space="preserve">
          <source>In the body of a cv-qualified function, the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer is cv-qualified, e.g. in a &lt;code&gt;const&lt;/code&gt; member function, only other const member functions may be called normally. (A non-const member function may still be called if &lt;a href=&quot;const_cast&quot;&gt;const_cast&lt;/a&gt; is applied or through an access path that does not involve &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt;.).</source>
          <target state="translated">cv-qualified 함수의 본문 &lt;a href=&quot;this&quot;&gt;에서이&lt;/a&gt; 포인터는 cv-qualified입니다 (예 : &lt;code&gt;const&lt;/code&gt; 멤버 함수). 다른 const 멤버 함수 만 정상적으로 호출 될 수 있습니다. &lt;a href=&quot;const_cast&quot;&gt;const_cast&lt;/a&gt; 가 적용되거나 &lt;a href=&quot;this&quot;&gt;이와&lt;/a&gt; 관련되지 않은 액세스 경로를 통해 비 const 멤버 함수가 여전히 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="893e73a07f97db13bb810fec92b5bc2d9c3779e6" translate="yes" xml:space="preserve">
          <source>In the body of the loop, the following steps take place:</source>
          <target state="translated">루프 본문에서 다음 단계가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="905f50bd3c725e6724b6b75435c36c4e71558664" translate="yes" xml:space="preserve">
          <source>In the body of the template declaration, the name of a type parameter is a typedef-name which aliases the type supplied when the template is instantiated.</source>
          <target state="translated">템플릿 선언 본문에서 형식 매개 변수의 이름은 템플릿이 인스턴스화 될 때 제공되는 형식의 별칭을 지정하는 typedef-name입니다.</target>
        </trans-unit>
        <trans-unit id="7218fc3a4992cbcd0152232cad3f51efabb5d84f" translate="yes" xml:space="preserve">
          <source>In the body of the template declaration, the name of this parameter is a template-name (and needs arguments to be instantiated).</source>
          <target state="translated">템플리트 선언의 본문에서이 매개 변수의 이름은 template-name이며 인수를 인스턴스화해야합니다.</target>
        </trans-unit>
        <trans-unit id="900936499efddab53cef702850868c269921a8b7" translate="yes" xml:space="preserve">
          <source>In the case of equality, as determined by &lt;code&gt;operator==&lt;/code&gt;, only lexical representations are compared. Therefore, &lt;code&gt;path(&quot;a&quot;) == path(&quot;b&quot;)&lt;/code&gt; is never &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">등호 인 경우 &lt;code&gt;operator==&lt;/code&gt; 의해 결정된대로 어휘 표현 만 비교됩니다. 따라서 &lt;code&gt;path(&quot;a&quot;) == path(&quot;b&quot;)&lt;/code&gt; 는 절대 &lt;code&gt;true&lt;/code&gt; 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="9ea417255bb9a3e4e66840a148e5a0eeb99a4a75" translate="yes" xml:space="preserve">
          <source>In the case of equivalence, as determined by &lt;a href=&quot;../equivalent&quot;&gt;&lt;code&gt;equivalent()&lt;/code&gt;&lt;/a&gt;, it is checked whether two paths</source>
          <target state="translated">동등성의 경우 &lt;a href=&quot;../equivalent&quot;&gt; &lt;code&gt;equivalent()&lt;/code&gt; &lt;/a&gt; 의해 결정된대로 두 경로가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0918c8dba94ff6fd94b2510e1844c87eba4fa8bc" translate="yes" xml:space="preserve">
          <source>In the case of thrown exception, the states of the contained values of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are determined by the exception safety guarantees of &lt;code&gt;swap&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;'s move constructor, whichever is called. For both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, if the object contained a value, it is left containing a value, and the other way round.</source>
          <target state="translated">예외가 throw 된 경우 &lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 의 포함 된 값의 상태는 &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;T&lt;/code&gt; 이동 생성자 유형 의 &lt;code&gt;swap&lt;/code&gt; 에 대한 예외 안전 보장에 의해 결정됩니다 . 모두 &lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 목적은 값을 포함하는 경우, 그것의 값과 다른 방식 라운드 함유 남겨진다.</target>
        </trans-unit>
        <trans-unit id="74253cd795fea072a07aa9a7e78a4232e8101c59" translate="yes" xml:space="preserve">
          <source>In the cases (1,2), virt-specifier-seq, if used, is either &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;code&gt;final&lt;/code&gt;, or &lt;code&gt;final override&lt;/code&gt; or &lt;code&gt;override final&lt;/code&gt;. In the case (3), the only allowed value of class-virt-specifier, if used, is &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">(1,2)의 경우 virt-specifier-seq는 사용되는 경우 &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; 또는 &lt;code&gt;final&lt;/code&gt; 또는 &lt;code&gt;final override&lt;/code&gt; 또는 &lt;code&gt;override final&lt;/code&gt; 입니다. (3)의 경우 class-virt-specifier의 유일한 허용 값은 &lt;code&gt;final&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="64cdd0ab070b191de582e146726ae3b52445aff7" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt;, a &lt;code&gt;bool&lt;/code&gt; object may be initialized from a prvalue of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, including &lt;code&gt;nullptr&lt;/code&gt;. The resulting value is &lt;code&gt;false&lt;/code&gt;. However, this is not considered to be an implicit conversion.</source>
          <target state="translated">&lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 의 맥락 에서, &lt;code&gt;bool&lt;/code&gt; 객체는 &lt;code&gt;nullptr&lt;/code&gt; 을 포함하여 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 유형의 prvalue에서 초기화 될 수 있습니다 . 결과 값은 &lt;code&gt;false&lt;/code&gt; 입니다. 그러나 이것은 암시 적 변환으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2371f6402972bc45972f3f09d5d022fcbd00df0" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; are replaced with respective uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;.</source>
          <target state="translated">기본 &quot;C&quot;로케일에서 다음 소문자 &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; 는 각각의 대문자 &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="f82450bef11bed620bb59a03e863ef7afabcdad8" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; are replaced with respective lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;.</source>
          <target state="translated">기본 &quot;C&quot;로케일에서 다음 대문자 &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; 는 각각의 소문자 &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="27d01f4ee118275f671ea1fc69da0b10c876ae4d" translate="yes" xml:space="preserve">
          <source>In the definition above,</source>
          <target state="translated">위의 정의에서</target>
        </trans-unit>
        <trans-unit id="b73a608fd45fbdf0b5c22a44851fbc673377e55d" translate="yes" xml:space="preserve">
          <source>In the definition of a constructor of a class,</source>
          <target state="translated">클래스 생성자의 정의에서</target>
        </trans-unit>
        <trans-unit id="92eaf109eca502313374c00968739b34523e2380" translate="yes" xml:space="preserve">
          <source>In the definitions above,</source>
          <target state="translated">위의 정의에서</target>
        </trans-unit>
        <trans-unit id="817086841623d69755c18cd1a550bd17dbc9cec2" translate="yes" xml:space="preserve">
          <source>In the end, calls &lt;code&gt;str.width(0)&lt;/code&gt; to cancel the effects of any &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">결국 &lt;code&gt;str.width(0)&lt;/code&gt; 을 호출 하여 &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 의 효과를 취소하십시오 .</target>
        </trans-unit>
        <trans-unit id="c655d96839ca7780fa82778f8220c935df02845d" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;E1.*E2&lt;/code&gt;:</source>
          <target state="translated">식에 &lt;code&gt;E1.*E2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7b082767dd5ca682cdbd1f19496a9ffb37833f35" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;E1.E2&lt;/code&gt;:</source>
          <target state="translated">식 &lt;code&gt;E1.E2&lt;/code&gt; 에서 :</target>
        </trans-unit>
        <trans-unit id="9db07dd430b24754012846b56b013710f95fae18" translate="yes" xml:space="preserve">
          <source>In the expression above, the identifier &lt;code&gt;swap&lt;/code&gt; is looked up in the same manner as the one used by the C++17 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; trait.</source>
          <target state="translated">위 식에서 식별자 &lt;code&gt;swap&lt;/code&gt; 은 C ++ 17 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; 특성에서 사용 된 것과 동일한 방식으로 조회 됩니다.</target>
        </trans-unit>
        <trans-unit id="4e914c03795fc0434d207252646fcc5c2fbb853f" translate="yes" xml:space="preserve">
          <source>In the following cases the expression specifying the first dimension is erroneous:</source>
          <target state="translated">다음과 같은 경우 첫 번째 차원을 지정하는 표현식이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb90da930e22170c110ed69983a4cd8c89699138" translate="yes" xml:space="preserve">
          <source>In the following cases, the injected-class-name is treated as a template-name of the class template itself:</source>
          <target state="translated">다음과 같은 경우에 주입 된 클래스 이름은 클래스 템플리트 자체의 템플리트 이름으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="6f57e7c031dc103138aa47aafe5169cd4d0818a3" translate="yes" xml:space="preserve">
          <source>In the following cases, the types, templates, and non-type values that are used to compose &lt;code&gt;P&lt;/code&gt; do not participate in template argument deduction, but instead</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;P&lt;/code&gt; 를 구성하는 데 사용되는 유형, 템플릿 및 유형이 아닌 값 은 템플릿 인수 공제에 참여하지 않고 대신</target>
        </trans-unit>
        <trans-unit id="18a089e2076eb0c963948461ded82840d2c5491f" translate="yes" xml:space="preserve">
          <source>In the following contexts ADL-only lookup (that is, lookup in associated namespaces only) takes place:</source>
          <target state="translated">다음 컨텍스트에서 ADL 전용 조회 (즉, 연관된 네임 스페이스에서만 조회)가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1e7e564013cddb0a744a7b7d9845915473666e88" translate="yes" xml:space="preserve">
          <source>In the following contexts, a context-specific type &lt;code&gt;T&lt;/code&gt; is expected, and the expression &lt;code&gt;e&lt;/code&gt; of class type &lt;code&gt;E&lt;/code&gt; is only allowed if &lt;code&gt;E&lt;/code&gt; has a single non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; to an allowable type(until C++14)there is exactly one type &lt;code&gt;T&lt;/code&gt; among the allowable types such that &lt;code&gt;E&lt;/code&gt; has non-explicit conversion functions whose return types are (possibly cv-qualified) &lt;code&gt;T&lt;/code&gt; or reference to (possibly cv-qualified) &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;e&lt;/code&gt; is implicitly convertible to &lt;code&gt;T&lt;/code&gt;(since C++14). Such expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">다음과 같은 상황에서, 콘텍스트 특정 유형 &lt;code&gt;T&lt;/code&gt; 가 예상되고, 식 &lt;code&gt;e&lt;/code&gt; 클래스 타입의 &lt;code&gt;E&lt;/code&gt; 는 경우에만 허용된다 &lt;code&gt;E&lt;/code&gt; 는 단일 비 - 명시 갖는 &lt;a href=&quot;cast_operator&quot;&gt;사용자 정의 변환 기능&lt;/a&gt; 허용 유형을 (까지 C ++ 14)가 한 유형 정확히 &lt;code&gt;T&lt;/code&gt; 되도록 허용 유형 중 &lt;code&gt;E&lt;/code&gt; 는 리턴 타입 (아마도 CV 정규화)되어 비 - 명시 적 변환 기능을 갖는 &lt;code&gt;T&lt;/code&gt; 또는 참조 (아마도 CV 수식)로 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;e&lt;/code&gt; 에 내재적 컨버터블 &lt;code&gt;T&lt;/code&gt; 를 C 보낸 ( ++ 14). 이러한 표현 &lt;code&gt;e&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="e9d454a482529bf2ee5e3a62d016e12659bf0446" translate="yes" xml:space="preserve">
          <source>In the following contexts, the type &lt;code&gt;bool&lt;/code&gt; is expected and the implicit conversion is performed if the declaration &lt;code&gt;bool t(e);&lt;/code&gt; is well-formed (that is, an explicit conversion function such as &lt;code&gt;explicit T::operator bool() const;&lt;/code&gt; is considered). Such expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">다음과 같은 맥락에서, &lt;code&gt;bool&lt;/code&gt; 유형 이 예상되며 선언이 &lt;code&gt;bool t(e);&lt;/code&gt; 이면 암시 적 변환이 수행됩니다 . 잘 구성되어 있습니다 (즉, &lt;code&gt;explicit T::operator bool() const;&lt;/code&gt; 와 같은 명시 적 변환 함수 가 고려 됨). 이러한 표현 &lt;code&gt;e&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="e8e08b92d2240f4a88c69d4e69a8df8c00816b49" translate="yes" xml:space="preserve">
          <source>In the following examples, the fictitious arguments will be called U1, U2.</source>
          <target state="translated">다음 예에서 가상의 인수는 U1, U2라고합니다.</target>
        </trans-unit>
        <trans-unit id="2ebb63b824c4cdb079972404f91cbe60baeddcf6" translate="yes" xml:space="preserve">
          <source>In the implementation used to execute this example, overflow() over-allocates the put area to 512 bytes: a call to str() would only return the four initialized bytes, but the next 508 calls to sputc() would not require new calls to overflow().</source>
          <target state="translated">이 예제를 실행하는 데 사용 된 구현에서 overflow ()는 넣기 영역을 512 바이트로 오버 할당합니다. str ()에 대한 호출은 초기화 된 4 개의 바이트 만 반환하지만 sputc ()에 대한 다음 508 호출에는 새로운 호출이 필요하지 않습니다. overflow ().</target>
        </trans-unit>
        <trans-unit id="f8c299b36b8a4498bc3547746db843fd4f953399" translate="yes" xml:space="preserve">
          <source>In the initialization of a variable, when the initializer expression is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the variable type:</source>
          <target state="translated">변수 초기화에서 이니셜 라이저 표현식이 변수 유형과 동일한 클래스 유형 ( &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt; 무시 )의 &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; 인 경우 :</target>
        </trans-unit>
        <trans-unit id="27c642266c0731a2e8f833d8f0a3ec3946651726" translate="yes" xml:space="preserve">
          <source>In the initialization of an object, when the source object is a nameless temporary and is of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the target object. When the nameless temporary is the operand of a return statement, this variant of copy elision is known as RVO, &quot;return value optimization&quot;.</source>
          <target state="translated">객체를 초기화 할 때 소스 객체가 이름이없는 임시이고 대상 객체 와 동일한 클래스 유형 ( &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt; 무시 ) 인 경우. 이름없는 임시가 리턴 명령문의 피연산자 인 경우,이 사본 제거 변형을 &quot;반환 값 최적화&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="5c373829034265c5b0e2556da1a4e7ca6ed3781b" translate="yes" xml:space="preserve">
          <source>In the integer and floating-point digit sequences, optional separators &lt;code&gt;'&lt;/code&gt; are allowed between any two digits and are ignored</source>
          <target state="translated">정수 및 부동 소수점 숫자 시퀀스에서 선택적 구분 기호 &lt;code&gt;'&lt;/code&gt; 는 두 숫자 사이에 허용되며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1597dcf21e743f45fe04b66865d76eb95469ddd2" translate="yes" xml:space="preserve">
          <source>In the published C++11 and C++14 standards, this function was specified to require &lt;code&gt;mapped_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; and &lt;code&gt;key_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;. This specification was defective and was fixed by &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-defects.html#2469&quot;&gt;LWG issue 2469&lt;/a&gt;, and the description above incorporates the resolution of that issue.</source>
          <target state="translated">게시 된 C ++ (11)와 C ++ 14 개 표준에서는이 기능을 필요로 지정된 &lt;code&gt;mapped_type&lt;/code&gt; 을 할 &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; 과 &lt;code&gt;key_type&lt;/code&gt; 을 할 &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; 또는 &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; 에 &lt;code&gt;*this&lt;/code&gt; . 이 사양은 결함이 있으며 &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-defects.html#2469&quot;&gt;LWG 문제 2469&lt;/a&gt; 로 수정되었으며 위의 설명은 해당 문제의 해결 방법을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="984b95b188d8b6ed51c0929b5bbcca151d81d732" translate="yes" xml:space="preserve">
          <source>In the second form of if statement (the one including else), if statement-true is also an if statement then that inner if statement must contain an else part as well (in other words, in nested if-statements, the else is associated with the closest if that doesn't have an else).</source>
          <target state="translated">if 문의 두 번째 형식 (다른 것을 포함하는 것)에서 if statement-true 또한 if 문인 경우 내부 if 문은 else 부분도 포함해야합니다 (즉, 중첩 된 if 문에서 else는 연결되어 있습니다) 그렇지 않은 경우 가장 가까운).</target>
        </trans-unit>
        <trans-unit id="b7c2588aa39c2094ccbf6764f2545ff5d48d7081" translate="yes" xml:space="preserve">
          <source>In the unary-binary overload (3,6), &lt;code&gt;unary_op&lt;/code&gt; is not applied to &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">이진 이진 과부하 (3,6)에서 &lt;code&gt;unary_op&lt;/code&gt; 는 &lt;code&gt;init&lt;/code&gt; 에 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f46af473d10885afbc17d62f3973969b56f43750" translate="yes" xml:space="preserve">
          <source>In these initializer expressions, &lt;code&gt;e&lt;/code&gt; is an lvalue if the type of the entity &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is an lvalue reference (this only happens if the ref-operator is &lt;code&gt;&amp;amp;&lt;/code&gt; or if it is &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and the initializer expression is an lvalue) and an xvalue otherwise (this effectively performs a kind of perfect forwarding), &lt;code&gt;i&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; prvalue, and &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; is always interpreted as a template parameter list.</source>
          <target state="translated">이러한 초기화 식에서, &lt;code&gt;e&lt;/code&gt; 엔티티의 입력하면 좌변은 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; 좌변 기준 (이 경우에만 REF 연산자 경우 발생이다 &lt;code&gt;&amp;amp;&lt;/code&gt; 또는이면 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 초기화 식 좌변이다)와 그렇지 않은 경우가 xValue (이 효율적으로 완벽하게 전달의 일종)을 수행, &lt;code&gt;i&lt;/code&gt; 하는 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; prvalue, 그리고 &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; 항상 템플릿 매개 변수 목록으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="5edaaa50a68b7de4d405f0db9e2d071386701607" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; F in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after Y.</source>
          <target state="translated">이 경우, 스레드 A에서 F &lt;a href=&quot;memory_order&quot;&gt;이전에 시퀀싱&lt;/a&gt; 된 모든 비 원자 및 완화 원자 저장소는 Y 이후 스레드 B에서 작성된 동일한 위치에서 모든 비 원자 및 완화 원자로드 &lt;a href=&quot;memory_order&quot;&gt;전에 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0a4cf3adc0dea1f1e86d6ff23d2e32a0caa67f56" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; FA in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after FB.</source>
          <target state="translated">이 경우 스레드 A에서 FA &lt;a href=&quot;memory_order&quot;&gt;이전에 시퀀싱&lt;/a&gt; 된 모든 비 원자 및 이완 원자 저장소는 FB 이후 스레드 B에서 작성된 동일한 위치에서 모든 비 원자 및 이완 원자로드 &lt;a href=&quot;memory_order&quot;&gt;전에 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8725b52d3c1fdf65bcce6d3f222c3cb193f19490" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; X in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after F.</source>
          <target state="translated">이 경우 스레드 A에서 X &lt;a href=&quot;memory_order&quot;&gt;이전에 시퀀싱&lt;/a&gt; 된 모든 비 원자 및 완화 원자 저장소는 F 이후 스레드 B에서 작성된 동일한 위치에서 모든 비 원자 및 완화 원자로드 &lt;a href=&quot;memory_order&quot;&gt;전에 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c0eb534d99bfe7cabd6fc507165a3b864a58be3c" translate="yes" xml:space="preserve">
          <source>In this case, the keyword</source>
          <target state="translated">이 경우 키워드</target>
        </trans-unit>
        <trans-unit id="353019d63051611e784bf71d2adc4b77fb808f2b" translate="yes" xml:space="preserve">
          <source>In this case, the member of any specialization of A becomes a friend. This does not involve instantiating the primary template A: the only requirements are that the deduction of the template parameters of A from that specialization succeeds, and that substitution of the deduced template arguments into the friend declaration produces a declaration that would be a valid redeclaration of the member of the specialization:</source>
          <target state="translated">이 경우 A 전문화 영역의 구성원이 친구가됩니다. 여기에는 기본 템플릿 A를 인스턴스화하는 것이 포함되지 않습니다. 유일한 요구 사항은 해당 전문화에서 A의 템플릿 매개 변수를 추론하고 추론 된 템플릿 인수를 친구 선언으로 대체하면 유효한 선언으로 선언됩니다. 전문화 멤버 :</target>
        </trans-unit>
        <trans-unit id="216570cc099d91d9e8fcba19ae0d75946676ed16" translate="yes" xml:space="preserve">
          <source>In this case, the target constructor is selected by overload resolution and executed first, then the control returns to the delegating constructor and its body is executed.</source>
          <target state="translated">이 경우 대상 생성자는 과부하 해결에 의해 선택되어 먼저 실행 된 다음 제어가 위임 생성자로 돌아가고 본문이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="06f9e15b2ae9be584dce74848cf7b7f2676331fc" translate="yes" xml:space="preserve">
          <source>In this example, initial allocation of the underlying array was for 16 bytes.</source>
          <target state="translated">이 예에서 기본 배열의 초기 할당은 16 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="330c586d17d06314846a2d3fffc6301809c539ee" translate="yes" xml:space="preserve">
          <source>In this example, two values that compare equal under this comparison (which is case-insensitive on the member &lt;code&gt;name&lt;/code&gt; can be distinguished by functions that are case-sensitive:</source>
          <target state="translated">이 예제에서이 비교에서 동일하게 비교되는 두 값 (멤버 &lt;code&gt;name&lt;/code&gt; 에서 대소 문자를 구분하지 않음)은 대소 문자를 구분하는 함수로 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff5a35c9480e5a35d467f9e8b2a4ffafdc16c703" translate="yes" xml:space="preserve">
          <source>In those situations where copy assignment cannot benefit from resource reuse (it does not manage a heap-allocated array and does not have a (possibly transitive) member that does, such as a member &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;), there is a popular convenient shorthand: the copy-and-swap assignment operator, which takes its parameter by value (thus working as both copy- and move-assignment depending on the value category of the argument), swaps with the parameter, and lets the destructor clean it up.</source>
          <target state="translated">사본 할당이 자원 재사용의 이점을 얻을 수없는 상황 (힙 할당 배열을 관리하지 않고 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 멤버와 같이 수행 할 수있는 전이) 멤버가없는 경우에는 복사 및 스왑 할당 연산자는 널리 사용되는 편리한 속기입니다.이 매개 변수는 값을 기준으로 매개 변수를 사용하므로 (인수의 값 범주에 따라 복사 및 이동 할당으로 작동) 매개 변수와 스왑합니다. 소멸자가 청소하십시오.</target>
        </trans-unit>
        <trans-unit id="44d42e4e7cdc63f569100975fee76f3a07f480d3" translate="yes" xml:space="preserve">
          <source>In typical usage, &lt;code&gt;count&lt;/code&gt; is the size of the destination array.</source>
          <target state="translated">일반적인 사용법에서 &lt;code&gt;count&lt;/code&gt; 는 대상 배열의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="4027a85dd787fe56399bbb11ac7adf2fe0eee28f" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error. &lt;code&gt;eof()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fail&quot;&gt;fail()&lt;/a&gt;&lt;/code&gt; can then be used to distinguish between different error conditions.</source>
          <target state="translated">일반적인 사용법에서 입력 스트림 처리는 오류가 발생하면 중지됩니다. 그런 다음 &lt;code&gt;eof()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;fail&quot;&gt;fail()&lt;/a&gt;&lt;/code&gt; 을 사용하여 다른 오류 조건을 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c6002149b8d6c5a43ae8ee73b0dbdfdf5535c0c" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error; &lt;code&gt;feof&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; are then used to distinguish between different error conditions.</source>
          <target state="translated">일반적인 사용법에서 입력 스트림 처리는 오류가 발생하면 중지됩니다. 그런 다음 &lt;code&gt;feof&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; 를 사용하여 다른 오류 조건을 구별합니다.</target>
        </trans-unit>
        <trans-unit id="21e3e82b3a013fa09de3345372c2bcda63c11cf0" translate="yes" xml:space="preserve">
          <source>In typical use cases, this function is the last thing called by a detached thread.</source>
          <target state="translated">일반적인 사용 사례에서이 함수는 분리 된 스레드가 마지막으로 호출 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7790a0c7a8cccc64f38d56e2325db218d5c6811d" translate="yes" xml:space="preserve">
          <source>Inappropriate I/O control operation</source>
          <target state="translated">부적절한 I / O 제어 작동</target>
        </trans-unit>
        <trans-unit id="db54974f7f0ad531e35648ba85b9388029b4d7ef" translate="yes" xml:space="preserve">
          <source>Includes</source>
          <target state="translated">Includes</target>
        </trans-unit>
        <trans-unit id="8705867aeef60bcf6e033673dc025bf70ea7c829" translate="yes" xml:space="preserve">
          <source>Includes January 4</source>
          <target state="translated">1 월 4 일 포함</target>
        </trans-unit>
        <trans-unit id="ea5fdcf7120862d98b9dd3dd4a179e2277f2b2e6" translate="yes" xml:space="preserve">
          <source>Includes e.g. &lt;a href=&quot;memory/new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;memory/new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;memory/new/set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;memory/new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;memory/new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;memory/new/set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bbc9d5a2379fe53e6888d69ff2cfd239b49d1c65" translate="yes" xml:space="preserve">
          <source>Includes e.g. &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory/c/free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;memory/c/free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="1e25648908297ca3a4ff1a029bba15e376074f7a" translate="yes" xml:space="preserve">
          <source>Includes first Thursday of the year</source>
          <target state="translated">연중 첫 번째 목요일 포함</target>
        </trans-unit>
        <trans-unit id="2effbb73909ece6a25dcb3109ac70345242cea64" translate="yes" xml:space="preserve">
          <source>Includes other source file into current source file at the line immediately after the directive.</source>
          <target state="translated">지시문 바로 다음 줄에서 다른 소스 파일을 현재 소스 파일에 포함합니다.</target>
        </trans-unit>
        <trans-unit id="28d47aeec93ecafec39966de5877d68ae0fa0071" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; behaves as if it defines a static storage duration object of type &lt;code&gt;&lt;a href=&quot;../io/ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt;, whose constructor initializes the standard stream objects if it is the first &lt;code&gt;std::ios_base::Init&lt;/code&gt; object to be constructed, and whose destructor flushes those objects (except for &lt;code&gt;cin&lt;/code&gt; and &lt;code&gt;wcin&lt;/code&gt;) if it is the last &lt;code&gt;std::ios_base::Init&lt;/code&gt; object to be destroyed.</source>
          <target state="translated">&lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; 을 포함 하면 &lt;code&gt;&lt;a href=&quot;../io/ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; 유형의 정적 저장 기간 객체를 정의하는 것처럼 동작합니다. 생성자의 표준 &lt;code&gt;std::ios_base::Init&lt;/code&gt; 객체 인 생성자는 표준 스트림 객체를 초기화 합니다. 소멸자 가 마지막 &lt;code&gt;std::ios_base::Init&lt;/code&gt; 객체 인 경우 소멸자는 해당 객체를 플러시합니다 ( &lt;code&gt;cin&lt;/code&gt; 및 &lt;code&gt;wcin&lt;/code&gt; 제외 ) .</target>
        </trans-unit>
        <trans-unit id="5cd1c15a802ac17b19b885143fcfe2ec21636c5b" translate="yes" xml:space="preserve">
          <source>Including &lt;strong&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/strong&gt; also defines all &lt;a href=&quot;../feature_test#Library_features&quot;&gt;library feature-testing macros&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; 을&lt;/strong&gt; 포함하면 모든 &lt;a href=&quot;../feature_test#Library_features&quot;&gt;라이브러리 기능 테스트 매크로&lt;/a&gt; 도 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="1221ac54217af05f258b4f8aa9f00478c543372d" translate="yes" xml:space="preserve">
          <source>Incomparable values are..</source>
          <target state="translated">비교할 수없는 가치는</target>
        </trans-unit>
        <trans-unit id="1ab3146cdd793eb63530b9c56d89f5648c4b83e9" translate="yes" xml:space="preserve">
          <source>Incomplete type</source>
          <target state="translated">불완전한 유형</target>
        </trans-unit>
        <trans-unit id="38e49d07d428f67ddcca69cc70a81d4cae36a937" translate="yes" xml:space="preserve">
          <source>Increase the capacity of the vector to a value that's greater or equal to &lt;code&gt;new_cap&lt;/code&gt;. If &lt;code&gt;new_cap&lt;/code&gt; is greater than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, new storage is allocated, otherwise the method does nothing.</source>
          <target state="translated">벡터의 용량을 &lt;code&gt;new_cap&lt;/code&gt; 보다 크거나 같은 값으로 늘리십시오 . 경우 &lt;code&gt;new_cap&lt;/code&gt; 이 현재보다 큰 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , 새로운 스토리지는 달리 방법이 아무것도하지 않는, 분배한다.</target>
        </trans-unit>
        <trans-unit id="7e427ab8b4862191565a1a29a01d981f9c08b30f" translate="yes" xml:space="preserve">
          <source>Increment and decrement</source>
          <target state="translated">증감</target>
        </trans-unit>
        <trans-unit id="cfe414b6ddcaa8292d016a5a3592ec3f7ea7fada" translate="yes" xml:space="preserve">
          <source>Increment and decrement operators are overloaded for many standard library types. In particular, every &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; overloads operator++ and every &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; overloads operator--, even if those operators are no-ops for the particular iterator.</source>
          <target state="translated">증분 및 감소 연산자는 많은 표준 라이브러리 유형에 대해 오버로드됩니다. 특히, 모든 &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator는&lt;/a&gt; 연산자 ++를 오버로드하고 모든 &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator는&lt;/a&gt; 연산자를 오버로드합니다 (해당 연산자가 특정 반복자에 대해 운영 체제가없는 경우에도).</target>
        </trans-unit>
        <trans-unit id="f17d70be0f16733c0dc8c67eabfb624d43b60216" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators</source>
          <target state="translated">증감 연산자</target>
        </trans-unit>
        <trans-unit id="cc787748953bd4e94e67cc95ac787d4d3cfb9a68" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators increment or decrement the value of the object.</source>
          <target state="translated">증감 연산자는 객체의 값을 증감시킵니다.</target>
        </trans-unit>
        <trans-unit id="0f9b5e452f10a6b34da1fb48e02ee30bd5033db1" translate="yes" xml:space="preserve">
          <source>Incrementable</source>
          <target state="translated">Incrementable</target>
        </trans-unit>
        <trans-unit id="cc5ea811af56aeeaf46a0c9737e89031c9af2a17" translate="yes" xml:space="preserve">
          <source>Increments given iterator &lt;code&gt;it&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">증분 반복자에게 부여 &lt;code&gt;it&lt;/code&gt; 함으로써 &lt;code&gt;n&lt;/code&gt; 요소.</target>
        </trans-unit>
        <trans-unit id="e3348f80bc84ba16802159a506f193e84a80b03d" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator.</source>
          <target state="translated">반복자를 늘리거나 줄입니다.</target>
        </trans-unit>
        <trans-unit id="84c43591c7009c31f153f3e91418e222e8d0fdab" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator. Inverse operations are applied to the underlying operator because of the reverse order.</source>
          <target state="translated">반복자를 늘리거나 줄입니다. 역 연산으로 인해 역 연산이 기본 연산자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="39764a20978ad7b2e0a6b9bd65f20bac9b65b929" translate="yes" xml:space="preserve">
          <source>Increments or decrements the number of ticks for this duration.</source>
          <target state="translated">이 기간 동안의 틱 수를 늘리거나 줄입니다.</target>
        </trans-unit>
        <trans-unit id="910224cadb5c448e8d25dd0213abaae95c58e5ea" translate="yes" xml:space="preserve">
          <source>Index into the array pointed to by the stored pointer.</source>
          <target state="translated">저장된 포인터가 가리키는 배열로 색인합니다.</target>
        </trans-unit>
        <trans-unit id="9d3b08115f1b71f8141facbb6d5edfd271773b19" translate="yes" xml:space="preserve">
          <source>Indicated by a trailing &lt;code&gt;...&lt;/code&gt;(other than one introducing a pack expansion)(since C++11) following the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="translated">트레일로 나타낸 &lt;code&gt;...&lt;/code&gt; (A)의 파라미터리스트하기 (11 ++ C 보낸) (팩 확장 도입 이외) &lt;a href=&quot;function&quot;&gt;함수 선언&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d49ada4a4f9e6394d6c031cdd3db87968627070f" translate="yes" xml:space="preserve">
          <source>Indicated by using the following syntax for a parameter in the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt;함수 선언&lt;/a&gt; 의 매개 변수 목록에서 매개 변수에 다음 구문을 사용하여 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="1712d2e8f937518e01b0931bd205206ed1a8017a" translate="yes" xml:space="preserve">
          <source>Indicates if the match results are ready (valid) or not.</source>
          <target state="translated">일치 결과가 준비되었는지 (유효한지) 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="05d56af25aa45704ec160c601a10df5e1c115f08" translate="yes" xml:space="preserve">
          <source>Indicates if this match was successful</source>
          <target state="translated">이 일치가 성공했는지 나타냅니다</target>
        </trans-unit>
        <trans-unit id="fb13d85a03c61cb1a77aee405db444e1e7dd0d1e" translate="yes" xml:space="preserve">
          <source>Indicates that dependency chain in release-consume &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; propagates in and out of the function, which allows the compiler to skip unnecessary memory fence instructions.</source>
          <target state="translated">release-consume &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; 종속성 체인 이 함수 안팎으로 전파되어 컴파일러가 불필요한 메모리 차단 명령어를 건너 뛸 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b1eef975978a88d290550921db3dd4b23de6ed3c" translate="yes" xml:space="preserve">
          <source>Indicates that the fall through from the previous case label is intentional and should not be diagnosed by a compiler that warns on fallthrough.</source>
          <target state="translated">이전 사례 라벨에서 제외 된 것은 의도적 인 것이며, 넘어짐에 대해 경고하는 컴파일러에 의해 진단되어서는 안됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="07a894f6f65f599ff826de67eb639e25aa960be1" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;.</source>
          <target state="translated">함수 정의가 &lt;a href=&quot;../transactional_memory&quot;&gt;동기화 된 명령문&lt;/a&gt; 에서 호출하도록 최적화되어야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="404bc23b0c3c1dc2dde1e96665adb2a133cb2f1a" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;. In particular, it avoids serializing synchronized blocks that make a call to a function that is transaction-safe for the majority of calls, but not for all calls.</source>
          <target state="translated">함수 정의가 &lt;a href=&quot;../transactional_memory&quot;&gt;동기화 된 명령문&lt;/a&gt; 에서 호출하도록 최적화되어야 함을 나타냅니다 . 특히, 대부분의 통화에 대해 트랜잭션에 안전한 기능을 호출하지만 모든 통화에 대해 호출되는 기능을 호출하지 않는 동기화 된 블록을 직렬화하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="3763a0ac1424ab7603605b2e6e73c73516778f16" translate="yes" xml:space="preserve">
          <source>Indicates that the function does not return.</source>
          <target state="translated">함수가 반환되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aadf5ff318f6e9ff51544f26ee3de70c127e4ff5" translate="yes" xml:space="preserve">
          <source>Indicates that the name or entity declared with this attribute is &lt;a href=&quot;https://en.wikipedia.org/wiki/Deprecation&quot;&gt;deprecated&lt;/a&gt;, that is, the use is allowed, but discouraged for some reason.</source>
          <target state="translated">이 속성으로 선언 된 이름 또는 엔티티는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Deprecation&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; . 즉, 사용이 허용되지만 어떤 이유로 사용 하지 않는 것을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="eb1d4e9c5ff0d33dedb5c76e1e3e0a72c774ec1e" translate="yes" xml:space="preserve">
          <source>Indicates that the use of the name or entity declared with this attribute is allowed, but discouraged for some reason. Compilers typically issue warnings on such uses. The string-literal, if specified, is usually included in the warnings.</source>
          <target state="translated">이 속성으로 선언 된 이름 또는 엔티티를 사용할 수 있지만 어떤 이유로 권장하지 않음을 나타냅니다. 컴파일러는 일반적으로 이러한 용도로 경고를 발행합니다. 문자열 리터럴 (지정된 경우)은 일반적으로 경고에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1b877dccdb68430deec81ae5c7d0c2899c1a04b6" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class.</source>
          <target state="translated">이 데이터 멤버가 해당 클래스의 다른 모든 비 정적 데이터 멤버와 다른 주소를 가질 필요는 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6a97cea227e92a547c1dd0162d3c17f7d0180b0c" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class. This means that if the member has an empty type (e.g. stateless Allocator), the compiler may optimise it to occupy no space, just like if it were an &lt;a href=&quot;../ebo&quot;&gt;empty base&lt;/a&gt;. If the member is not empty, any tail padding in it may be also reused to store other data members.</source>
          <target state="translated">이 데이터 멤버가 해당 클래스의 다른 모든 비 정적 데이터 멤버와 다른 주소를 가질 필요는 없음을 나타냅니다. 즉, 멤버에 빈 유형 (예 : Stateless Allocator)이 있으면 컴파일러는 &lt;a href=&quot;../ebo&quot;&gt;빈베이스 인&lt;/a&gt; 것처럼 공간을 차지하지 않도록 최적화 할 수 있습니다 . 멤버가 비어 있지 않으면 다른 데이터 멤버를 저장하기 위해 테일 패딩을 재사용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e16e5df080d66d35fd0fc9ce14ca2cddaaf531e" translate="yes" xml:space="preserve">
          <source>Indicates the endianness of all &lt;a href=&quot;../language/type-id&quot;&gt;scalar types&lt;/a&gt;:</source>
          <target state="translated">모든 &lt;a href=&quot;../language/type-id&quot;&gt;스칼라 유형&lt;/a&gt; 의 엔디안을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b7ced8b89669e17290208433d069c305c4668cd4" translate="yes" xml:space="preserve">
          <source>Indirect access</source>
          <target state="translated">간접 액세스</target>
        </trans-unit>
        <trans-unit id="945f4467f9e3980b9bc435c192be55e1cdba33ac" translate="yes" xml:space="preserve">
          <source>Indirect callable concepts</source>
          <target state="translated">간접 호출 가능 개념</target>
        </trans-unit>
        <trans-unit id="615d0df84a8bde5c3b3b45942556ad9ee41f5c88" translate="yes" xml:space="preserve">
          <source>IndirectRelation</source>
          <target state="translated">IndirectRelation</target>
        </trans-unit>
        <trans-unit id="a517704fa906449a7f15a8ece89573834bd716d4" translate="yes" xml:space="preserve">
          <source>IndirectStrictWeakOrder</source>
          <target state="translated">IndirectStrictWeakOrder</target>
        </trans-unit>
        <trans-unit id="4fd88b3054ecad93f1a95a527c3891631b31f23d" translate="yes" xml:space="preserve">
          <source>IndirectUnaryInvocableIndirectRegularUnaryInvocable</source>
          <target state="translated">IndirectUnaryInvocableIndirectRegularUnaryInvocable</target>
        </trans-unit>
        <trans-unit id="d4d035f7c30e113629f27edd40bf70e82d6284b2" translate="yes" xml:space="preserve">
          <source>IndirectUnaryPredicate</source>
          <target state="translated">IndirectUnaryPredicate</target>
        </trans-unit>
        <trans-unit id="1ba4d5bf8c849bf8c04b9c6e21cc8e1df44157c8" translate="yes" xml:space="preserve">
          <source>Indirection through a pointer that became invalid in this manner and passing it to a deallocation function (double-delete) is undefined behavior. Any other use is implementation-defined.</source>
          <target state="translated">이런 방식으로 유효하지 않은 포인터를 통한 간접 할당 및 할당 해제 기능 (이중 삭제)에 전달하는 것은 정의되지 않은 동작입니다. 다른 용도는 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="fc6c8e1f0dc3858c691ccb1300793e524ab1874b" translate="yes" xml:space="preserve">
          <source>Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has implementation-defined behavior.</source>
          <target state="translated">유효하지 않은 포인터 값을 통한 간접 처리 및 유효하지 않은 포인터 값을 할당 해제 함수에 전달하면 동작이 정의되지 않습니다. 유효하지 않은 포인터 값을 사용하면 구현 정의 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="caa250f6b40fd31e6e435ad3ec42b55df8c15198" translate="yes" xml:space="preserve">
          <source>IndirectlyComparable</source>
          <target state="translated">IndirectlyComparable</target>
        </trans-unit>
        <trans-unit id="79246d49d2de7bde0e84161dfa390e35ead80dbb" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyable</source>
          <target state="translated">IndirectlyCopyable</target>
        </trans-unit>
        <trans-unit id="c1b4de1846b6ae50bbf1bb567d1c5423353b3f7c" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyableStorable</source>
          <target state="translated">IndirectlyCopyableStorable</target>
        </trans-unit>
        <trans-unit id="4f10a919177009406f024b0a5f8b598cade73a1d" translate="yes" xml:space="preserve">
          <source>IndirectlyMovable</source>
          <target state="translated">IndirectlyMovable</target>
        </trans-unit>
        <trans-unit id="be4b7238e8cf0d8749bb2f509a225195d878018a" translate="yes" xml:space="preserve">
          <source>IndirectlyMovableStorable</source>
          <target state="translated">IndirectlyMovableStorable</target>
        </trans-unit>
        <trans-unit id="1fb085c0bd571e7f0dafcbf700d51d838a32da50" translate="yes" xml:space="preserve">
          <source>IndirectlySwappable</source>
          <target state="translated">IndirectlySwappable</target>
        </trans-unit>
        <trans-unit id="b5f6e97cd4faf7045970097d59a8c5be90de03ff" translate="yes" xml:space="preserve">
          <source>Inexact result</source>
          <target state="translated">부정확 한 결과</target>
        </trans-unit>
        <trans-unit id="98df9b88a5e801dd458f9dea0b5eb524b074282a" translate="yes" xml:space="preserve">
          <source>Infinite loop without side-effects</source>
          <target state="translated">부작용없는 무한 루프</target>
        </trans-unit>
        <trans-unit id="8f1b65e86ba58e7d09ad5b638567441248d44fd1" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts a subset of the types that B accepts&quot;.</source>
          <target state="translated">비공식적으로 &quot;A가 B보다 더 전문화 됨&quot;은 &quot;A가 B가 수용하는 유형의 서브 세트를 승인 함&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8e26416412a250dc41f16163d325bfe0d9375649" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts fewer types than B&quot;.</source>
          <target state="translated">비공식적으로 &quot;A가 B보다 더 전문화 됨&quot;은 &quot;A가 B보다 적은 유형을 받아들입니다&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="837818b163877df19b00b59309303eba5812d227" translate="yes" xml:space="preserve">
          <source>Informally, an object is odr-used if its value is read (unless it is a compile time constant) or written, its address is taken, or a reference is bound to it; a reference is odr-used if it is used and its referent is not known at compile time; and a function is odr-used if a function call to it is made or its address is taken. If an object, a reference or a function is odr-used, its definition must exist somewhere in the program; a violation of that is usually a link-time error.</source>
          <target state="translated">비공식적으로, 객체가 값을 읽거나 (컴파일 시간 상수가 아닌 한) 기록되면, 주소가 취해 지거나 참조가 바인드됩니다. 참조가 사용되고 참조가 컴파일 타임에 알려지지 않은 경우 참조는 odr-used입니다. 함수를 호출하거나 주소를 가져 오면 함수가 사용됩니다. 객체, 참조 또는 함수를 사용하는 경우 해당 정의는 프로그램 어딘가에 존재해야합니다. 이를 위반하면 대개 링크 타임 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c6ae6b7147966f4caadf3becb3a298c96ec40912" translate="yes" xml:space="preserve">
          <source>Informally, two types are</source>
          <target state="translated">비공식적으로 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="37bbacc3d1827431eb0e90015863e8cd1f6d09b3" translate="yes" xml:space="preserve">
          <source>Informs the compiler that the dependency tree started by an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; atomic load operation does not extend past the return value of &lt;code&gt;std::kill_dependency&lt;/code&gt;; that is, the argument does not carry a dependency into the return value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; 원자로드 조작으로 시작된 종속성 트리 가 &lt;code&gt;std::kill_dependency&lt;/code&gt; 의 리턴 값을 초과 하여 확장되지 않음을 컴파일러에 알립니다 . 즉, 인수는 리턴 값에 종속성을 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9f0d94767eeb4fdf66bcb63f83f831a24817f3f" translate="yes" xml:space="preserve">
          <source>Informs the garbage collector or leak detector that the specified memory region (&lt;code&gt;n&lt;/code&gt; bytes beginning at the byte pointed to by &lt;code&gt;p&lt;/code&gt;) contains no traceable pointers. If any part of the region is within an allocated object, the entire region must be contained in the same object.</source>
          <target state="translated">지정된 메모리 영역 ( &lt;code&gt;p&lt;/code&gt; 가 가리키는 바이트에서 시작하는 &lt;code&gt;n&lt;/code&gt; 바이트 )에 추적 가능한 포인터가 없음을 가비지 수집기 또는 누출 감지기에 알립니다 . 영역의 일부가 할당 된 개체 내에 있으면 전체 영역이 동일한 개체에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b00d875f974811886ac196dcb915203f177f6a1" translate="yes" xml:space="preserve">
          <source>Informs the implementation that the object &lt;code&gt;ptr&lt;/code&gt; points to is aligned to at least &lt;code&gt;N&lt;/code&gt;. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of &lt;code&gt;assume_aligned&lt;/code&gt;.</source>
          <target state="translated">오브젝트 &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 &lt;code&gt;N&lt;/code&gt; 이 최소한 의 구현을 통지합니다 . 구현 &lt;code&gt;assume_aligned&lt;/code&gt; 정보를 사용하여보다 효율적인 코드를 생성 할 수 있지만 객체가 assume_aligned 의 반환 값을 통해 액세스하는 경우에만이 가정을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="24e63953e4f041a3bb4ac3148f230860861e7ff3" translate="yes" xml:space="preserve">
          <source>Inheritance diagram.</source>
          <target state="translated">상속 다이어그램.</target>
        </trans-unit>
        <trans-unit id="43a9b1d67674ea8718fc711a00f7bb00fbb4c4df" translate="yes" xml:space="preserve">
          <source>Inherited copy and move constructors are not included in the list of candidate functions when constructing a derived class object.</source>
          <target state="translated">상속 된 복사 및 이동 생성자는 파생 클래스 개체를 생성 할 때 후보 함수 목록에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f06971d5187bb5c21be32f180285afdb914b12b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../../types/integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; 에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="f30304d5307d8a19e13fb3ed0a2bac9d82e0a424" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../error/exception&quot;&gt;std :: exception&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="01fe97cbbb0941b6f2a72d6bcbf5bf30c49dc7b1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="179a5175974c4d0f1231cb42168b0c03c785293b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../error/system_error&quot;&gt;std :: system_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="7a80e3d34750b628e39956fcaf30d5d8a1ed24f4" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../types/integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; 에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="dc3357171bb4abff2c5bcfa928f18def082a907c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../error/exception&quot;&gt;std :: exception&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="30b72f9cdb58e5970783c671d3934c33faeb1623" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/logic_error/logic_error&quot;&gt; std::logic_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../error/logic_error/logic_error&quot;&gt;std :: logic_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="957863018da5b123ab6f6ee5e33f1ffffd93019e" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="4810ddaa7ee3800c8518272cbd3eab0a576e08e1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../error/system_error&quot;&gt;std :: system_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="8f42576c785a3be8154970999da87190cb9371f9" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../exception&quot;&gt;std :: exception&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="1ff5d17ac32734b6c4b40b6f4b8d2dbbce7f1b33" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../types/integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; 에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="64a89d3879a72da7c6ee665cb1868939227a129a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../utility/pair&quot;&gt; std::pair&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../utility/pair&quot;&gt;std :: pair&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="ad227e6a5a2991b9ae2118d21b1ded53643ffeb6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;bad_alloc&quot;&gt; std::bad_alloc&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bad_alloc&quot;&gt;std :: bad_alloc&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="0640747e62ff14ba1b29b108a996ca8f524d1b5a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ios&quot;&gt; std::basic_ios&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;basic_ios&quot;&gt;std :: basic_ios&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="de0c89b89174954a9f92de2b010f4eba6cf65be6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_istream&quot;&gt; std::basic_istream&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;basic_istream&quot;&gt;std :: basic_istream&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="5294336a5cb08c884f1c1c77c83e45be59fa6ba0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ostream&quot;&gt; std::basic_ostream&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;basic_ostream&quot;&gt;std :: basic_ostream&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="9055f46788224b7f31bcf6f24250ff5d47695175" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_streambuf&quot;&gt; std::basic_streambuf&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;basic_streambuf&quot;&gt;std :: basic_streambuf&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="538de0fbed9b76df7a6ab5144cdd294244e05923" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt&quot;&gt; std::codecvt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;codecvt&quot;&gt;std :: codecvt&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="691ededb623378951567ffd0bfa980099fbe3761" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt_base&quot;&gt; std::codecvt_base&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;codecvt_base&quot;&gt;std :: codecvt_base&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="55051117752349a92484d2d68e1536f7ba751ac6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;collate&quot;&gt; std::collate&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;collate&quot;&gt;std :: collate&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="646bf27bfd425c0266f785460d8846b085490446" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;exception&quot;&gt;std :: exception&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="2b1e16a440f913fb0c212304822e1171df74e082" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; 에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="3d307388b240b50355fd55953eea3dcf640dd433" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;ios_base&quot;&gt; std::ios_base&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ios_base&quot;&gt;std :: ios_base&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="e507c076782fb8eb8b54d375f2f956f7369f545d" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;messages&quot;&gt; std::messages&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;messages&quot;&gt;std :: messages&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="f67af012ab32d51632e38d03380caedc6cb1fd11" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;money_base&quot;&gt;std::money_base&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;money_base&quot;&gt;std :: money_base&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="88842694e8b959006d435b6cad10e7a20f4f86fe" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;moneypunct&quot;&gt; std::moneypunct&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;moneypunct&quot;&gt;std :: moneypunct&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="4d17a29ada80f7d12d7692d7e6aaa8521d515613" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;numpunct&quot;&gt; std::numpunct&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpunct&quot;&gt;std :: numpunct&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="96f6c2f33d9e5a486e8905be371715ec2d5e0e4c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="7efc4c44fcbc8224af5b604f6ea179f896007df5" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_get&quot;&gt; std::time_get&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;time_get&quot;&gt;std :: time_get&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="6fda6ad022c33ce0f5b1400e8f343ad50076eeb0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_put&quot;&gt; std::time_put&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;time_put&quot;&gt;std :: time_put&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="e7135edcc0660dff5ef07a7531f5a314d1a14345" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;CharT&amp;gt;</source>
          <target state="translated">std :: ctype &amp;lt;CharT&amp;gt;에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="96606dedfe0d1180adfbb7cf5dc6b000d690eeaa" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;char&amp;gt;</source>
          <target state="translated">std :: ctype &amp;lt;char&amp;gt;에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="6835bd4de94e4c8ff9fa81f21f0a45e937163c89" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype_base</source>
          <target state="translated">std :: ctype_base에서 상속</target>
        </trans-unit>
        <trans-unit id="2a9684185e4ab4b7acc08548b265978c0ac9b665" translate="yes" xml:space="preserve">
          <source>Inherited from std::messages_base</source>
          <target state="translated">std :: messages_base에서 상속</target>
        </trans-unit>
        <trans-unit id="ec11a5942722961cf6c8bf90cef0c0ab7cbfd804" translate="yes" xml:space="preserve">
          <source>Inherited from std::time_base</source>
          <target state="translated">std :: time_base에서 상속</target>
        </trans-unit>
        <trans-unit id="a162155e80acef2e40d64da7fae4b6cef737ccc3" translate="yes" xml:space="preserve">
          <source>Inheriting constructors</source>
          <target state="translated">상속 생성자</target>
        </trans-unit>
        <trans-unit id="ed212d227256484af63b60ae12f72487723786d7" translate="yes" xml:space="preserve">
          <source>Inheriting from empty base classes usually does not increase the size of a class due to &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;.</source>
          <target state="translated">빈 기본 클래스에서 상속해도 &lt;a href=&quot;../language/ebo&quot;&gt;빈 기본 최적화&lt;/a&gt; 로 인해 클래스 크기가 증가하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="f6e1e46e4baf5716e3220f3484c1af85b95e71c8" translate="yes" xml:space="preserve">
          <source>Initialization by constructor</source>
          <target state="translated">생성자 별 초기화</target>
        </trans-unit>
        <trans-unit id="d0105ebd75116f796a8152546a960d90f6068ea4" translate="yes" xml:space="preserve">
          <source>Initialization of &lt;a href=&quot;../language/storage_duration#Static_local_variables&quot;&gt;function-local statics&lt;/a&gt; is guaranteed to occur only once even when called from multiple threads, and may be more efficient than the equivalent code using &lt;code&gt;std::call_once&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../language/storage_duration#Static_local_variables&quot;&gt;함수 로컬 스태틱의&lt;/a&gt; 초기화는 여러 스레드에서 호출 된 경우에도 한 번만 발생하며 &lt;code&gt;std::call_once&lt;/code&gt; 사용하는 동등한 코드보다 효율적일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d91f501eae2c832f1b0b7e4d4973d0855f66060e" translate="yes" xml:space="preserve">
          <source>Initialization order</source>
          <target state="translated">초기화 순서</target>
        </trans-unit>
        <trans-unit id="49fb3cd233b01d2f3fca6d231ff8868b279e8d64" translate="yes" xml:space="preserve">
          <source>Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).</source>
          <target state="translated">모든 비트를 0으로 초기화한다고해서 부동 소수점 또는 포인터가 각각 0.0과 널 포인터 값으로 초기화되는 것은 아닙니다 (모든 공통 플랫폼에서 적용됨).</target>
        </trans-unit>
        <trans-unit id="6ea9d5c7645589c136d59cd57df44af49ce9783f" translate="yes" xml:space="preserve">
          <source>Initialization with a &lt;a href=&quot;../../language/string_literal&quot;&gt;string literal&lt;/a&gt; that contains embedded &lt;code&gt;'\0'&lt;/code&gt; characters uses the overload (5), which stops at the first null character. This can be avoided by specifying a different constructor or by using &lt;a href=&quot;operator_q__q_s&quot;&gt;&lt;code&gt;operator&quot;&quot;s&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">포함 된 &lt;code&gt;'\0'&lt;/code&gt; 문자 가 포함 된 &lt;a href=&quot;../../language/string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 을 사용하여 초기화 하면 첫 번째 null 문자에서 중지되는 오버로드 (5)가 사용됩니다. 다른 생성자를 지정하거나 &lt;a href=&quot;operator_q__q_s&quot;&gt; &lt;code&gt;operator&quot;&quot;s&lt;/code&gt; &lt;/a&gt; 사용하면이를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8b6090f523a6604aaf83ad226d272f3e664763f" translate="yes" xml:space="preserve">
          <source>Initializer lists</source>
          <target state="translated">이니셜 라이저 목록</target>
        </trans-unit>
        <trans-unit id="5205b0ca0f0fefcfe68c33103c2c9c1ce338c249" translate="yes" xml:space="preserve">
          <source>Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a &lt;code&gt;std::initializer_list&lt;/code&gt; does not copy the underlying objects.</source>
          <target state="translated">이니셜 라이저 목록은 한 쌍의 포인터 또는 포인터와 길이로 구현 될 수 있습니다. 카피 &lt;code&gt;std::initializer_list&lt;/code&gt; 기본 개체를 복사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4cd615dbf08a4b7ea3976db14aee644d6937efce" translate="yes" xml:space="preserve">
          <source>Initializes an aggregate from braced-init-list.</source>
          <target state="translated">braced-init-list에서 집계를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="44dcbda2c857e660e975019d6dd123883526dd75" translate="yes" xml:space="preserve">
          <source>Initializes an object from another object.</source>
          <target state="translated">다른 객체에서 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0d3ed04db9734c04b00626e83cd3a554c91216b4" translate="yes" xml:space="preserve">
          <source>Initializes an object from braced-init-list.</source>
          <target state="translated">braced-init-list에서 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="b28ee811ef30d6e7a7f950db96ff44c9ab341ca0" translate="yes" xml:space="preserve">
          <source>Initializes an object from explicit set of constructor arguments.</source>
          <target state="translated">명시적인 생성자 인수 집합에서 개체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="3612fbe04b3d4f902d2d49989872e1c625ef8e37" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;bound_&lt;/code&gt; with &lt;code&gt;bound&lt;/code&gt;.</source>
          <target state="translated">박람회 전용 데이터 멤버 &lt;code&gt;bound_&lt;/code&gt; 를 &lt;code&gt;bound&lt;/code&gt; 로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="e582f41fbe9142faa1edac6dc025f737e0f1efef" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;current_&lt;/code&gt; with &lt;code&gt;current&lt;/code&gt; and exposition-only data members &lt;code&gt;parent_&lt;/code&gt; with &lt;code&gt;addressof(parent)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;addressof(parent)&lt;/code&gt; 하여 &lt;code&gt;current&lt;/code&gt; 및 박람회 전용 데이터 멤버 &lt;code&gt;parent_&lt;/code&gt; 로 노출 전용 데이터 멤버 &lt;code&gt;current_&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="687eeb5c76107cbf76d277e107912b3a093ddbf0" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;end_&lt;/code&gt; with &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="translated">박람회 전용 데이터 멤버 &lt;code&gt;end_&lt;/code&gt; 를 &lt;code&gt;parent&lt;/code&gt; 로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="45a2d2edd8a0c33265b1f7964c619dbe931e75f5" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;value_&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. This value will be returned by operator* and incremented by operator++</source>
          <target state="translated">&lt;code&gt;value_&lt;/code&gt; 하여 박람회 전용 데이터 멤버 value_ 를 초기화 &lt;code&gt;value&lt;/code&gt; . 이 값은 operator *에 의해 반환되고 operator ++에 의해 증가합니다.</target>
        </trans-unit>
        <trans-unit id="3ed19383d0a866bf81dc2a8bf40d1563412b85cf" translate="yes" xml:space="preserve">
          <source>Initializes the</source>
          <target state="translated">초기화</target>
        </trans-unit>
        <trans-unit id="a8d332dbed9d2af60e29bd52e5cde6a80c7ad53b" translate="yes" xml:space="preserve">
          <source>Initializes the default-constructed atomic object &lt;code&gt;obj&lt;/code&gt; with the value &lt;code&gt;desired&lt;/code&gt;. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.</source>
          <target state="translated">기본 구성된 원자 객체 &lt;code&gt;obj&lt;/code&gt; 를 &lt;code&gt;desired&lt;/code&gt; 값 으로 초기화합니다 . 이 기능은 원 자성이 아닙니다. 원자 연산을 통해 다른 스레드에서 동시 액세스하는 것은 데이터 경쟁입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
