<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="fc3b6bc12209467d6e9ff3af29b87f5253e0c47e" translate="yes" xml:space="preserve">
          <source>The base class version of the function returns the value returned by &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">함수의 기본 클래스 버전은 &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 반환 한 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b1d208bfa2329a65807001e6d36d39a0f1677250" translate="yes" xml:space="preserve">
          <source>The base class version returns &lt;code&gt;​0​&lt;/code&gt;, which has the meaning of &quot;unsure if there are characters available in the associated sequence&quot;.</source>
          <target state="translated">기본 클래스 버전을 반환 &lt;code&gt;​0​&lt;/code&gt; &quot;관련 시퀀스에서 사용할 수있는 문자가 있는지 확실&quot;의 의미를 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="65be7b19f119502c0eb14febca8650a896002b94" translate="yes" xml:space="preserve">
          <source>The base engine is initialized as if by its default constructor.</source>
          <target state="translated">기본 엔진은 기본 생성자로 마치 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="d2f48c59a2026f01e1913fb4af0ac9ade58b0ac5" translate="yes" xml:space="preserve">
          <source>The base engine is initialized with &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="translated">기본 엔진은 &lt;code&gt;q&lt;/code&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="3807d81685568779c783145cd5e183ce61fc3a1c" translate="yes" xml:space="preserve">
          <source>The base engine is initialized with &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">기본 엔진은 &lt;code&gt;s&lt;/code&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="ebf5c9f5b0b3f9e2e22420142fce565a3b32cfbc" translate="yes" xml:space="preserve">
          <source>The base iterator refers to the element that is next (from the &lt;code&gt;std::reverse_iterator::iterator_type&lt;/code&gt; perspective) to the element the &lt;code&gt;reverse_iterator&lt;/code&gt; is currently pointing to. That is &lt;code&gt;&amp;amp;*(rit.base() - 1) == &amp;amp;*rit&lt;/code&gt;.</source>
          <target state="translated">기본 반복자는 다음 요소 ( &lt;code&gt;std::reverse_iterator::iterator_type&lt;/code&gt; 관점에서)와 &lt;code&gt;reverse_iterator&lt;/code&gt; 가 현재 가리키는 요소를 가리 킵니다. 즉 &lt;code&gt;&amp;amp;*(rit.base() - 1) == &amp;amp;*rit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04894fdb5441816fc37a586ae5bb96e48ec6f568" translate="yes" xml:space="preserve">
          <source>The begin iterator is not decrementable and the behavior is undefined if &lt;code&gt;--container.begin()&lt;/code&gt; is evaluated.</source>
          <target state="translated">begin iterator는 감소 할 수 없으며 &lt;code&gt;--container.begin()&lt;/code&gt; 이 평가 되면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="03aff1e4e14290c56daca1d059d5794d57d8f115" translate="yes" xml:space="preserve">
          <source>The behavior is &lt;a href=&quot;language/ub&quot;&gt;undefined&lt;/a&gt; if the calls to functions in this library introduce a</source>
          <target state="translated">동작입니다 &lt;a href=&quot;language/ub&quot;&gt;정의되지 않은&lt;/a&gt; 이 라이브러리 함수에 대한 호출이를 소개하면</target>
        </trans-unit>
        <trans-unit id="b94ed51c2a7132f52ba92dc74b4b5db56131e5d8" translate="yes" xml:space="preserve">
          <source>The behavior is also implementation-defined (rather than undefined) if the glvalue contains a pointer value that was invalidated.</source>
          <target state="translated">glvalue에 무효화 된 포인터 값이 포함 된 경우 동작은 정의되지 않은 것이 아니라 구현에서 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d32d3770c8427099c568e7f5878b1512fe78f9b0" translate="yes" xml:space="preserve">
          <source>The behavior is also undefined if &lt;code&gt;hash_function()&lt;/code&gt; and &lt;code&gt;key_eq()&lt;/code&gt; do(until C++20)&lt;code&gt;key_eq()&lt;/code&gt; does(since C++20) not have the same behavior on &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; or if &lt;code&gt;operator==&lt;/code&gt; for &lt;code&gt;Key&lt;/code&gt; is not a refinement of the partition into equivalent-key groups introduced by &lt;code&gt;key_eq()&lt;/code&gt; (that is, if two elements that compare equal using &lt;code&gt;operator==&lt;/code&gt; fall into different partitions).</source>
          <target state="translated">동작은 또한 경우에 정의되지 &lt;code&gt;hash_function()&lt;/code&gt; 및 &lt;code&gt;key_eq()&lt;/code&gt; (20 ++ C까지) 할 &lt;code&gt;key_eq()&lt;/code&gt; (C는 ++ 20 이후)에서 같은 동작이없는 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 또는 경우를 &lt;code&gt;operator==&lt;/code&gt; 위한 &lt;code&gt;Key&lt;/code&gt; 아니다 &lt;code&gt;key_eq()&lt;/code&gt; 의해 도입 된 동등한 키 그룹으로 파티션을 세분화합니다 (즉, &lt;code&gt;operator==&lt;/code&gt; 사용하여 동일하게 비교하는 두 요소가 다른 파티션에 속하는 경우).</target>
        </trans-unit>
        <trans-unit id="e8fd329b7e8ee3bfdaf431a851607c95c9f9bfb8" translate="yes" xml:space="preserve">
          <source>The behavior is as follows:</source>
          <target state="translated">동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7eea08832bb23fb78c997d9dfc59bf05fa204a8d" translate="yes" xml:space="preserve">
          <source>The behavior is non-deterministic if &lt;code&gt;binary_op&lt;/code&gt; is not associative or not commutative.</source>
          <target state="translated">&lt;code&gt;binary_op&lt;/code&gt; 가 연관되지 않거나 정식 이 아닌 경우 동작이 결정적 이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07f39a83d0e9e90b80ce955a114fea2806db89fa" translate="yes" xml:space="preserve">
          <source>The behavior is non-deterministic if &lt;code&gt;binary_op&lt;/code&gt;/&lt;code&gt;binary_op2&lt;/code&gt; is not associative or not commutative.</source>
          <target state="translated">&lt;code&gt;binary_op&lt;/code&gt; / &lt;code&gt;binary_op2&lt;/code&gt; 가 연관되지 않거나 정식 이 아닌 경우 동작이 결정적 이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7236e1de843ba22b290511e64b6b85d4a7183b5b" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;a href=&quot;../future/valid&quot;&gt;&lt;code&gt;valid()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;== false&lt;/code&gt; before the call to this function.</source>
          <target state="translated">이 함수를 호출하기 전에 &lt;a href=&quot;../future/valid&quot;&gt; &lt;code&gt;valid()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;== false&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="06568324069c072f68418be5d52202edbce2a0f2" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;valid()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;== false&lt;/code&gt; before the call to this function.</source>
          <target state="translated">이 함수를 호출하기 전에 &lt;a href=&quot;valid&quot;&gt; &lt;code&gt;valid()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;== false&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="324200d2b8e9375f7586ca7351ca997ba0cea540" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;*this&lt;/code&gt; does not contain a value.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 값을 포함하지 않으면 동작이 정의 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c19a694085eaee2a80ad969fe60b2ac2a9024625" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;*this&lt;/code&gt; is the end iterator.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 엔드 반복자 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7a471c0f8892871ea303ee0c08e508e5150eccd3" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;&lt;a href=&quot;bucket_count&quot;&gt;bucket_count()&lt;/a&gt;&lt;/code&gt; is zero.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;bucket_count&quot;&gt;bucket_count()&lt;/a&gt;&lt;/code&gt; 가 0 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="476c74c56a725e606183d893014a83fc4be3c687" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is an incomplete type and not (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 불완전한 유형이고 (cv-qualified) &lt;code&gt;void&lt;/code&gt; 가 아닌 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1ef784ec6729fb716d0e83738d463a642f5a064e" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is an incomplete type other than (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 (cv-qualified) &lt;code&gt;void&lt;/code&gt; 이외의 불완전한 유형 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3512a4717910c6e0ec680f0e9ee0792822982829" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; before the call to this function.</source>
          <target state="translated">이 함수를 호출하기 전에 &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d9de1ac8e09598bd1314c36343d514e145b20e5a" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;Allocator&lt;/code&gt; does not propagate on swap and the allocators of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are unequal.</source>
          <target state="translated">&lt;code&gt;Allocator&lt;/code&gt; 가 스왑시 전파되지 않고 &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 의 할당 자가 동일 하지 않은 경우 동작이 정의 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e1eb022d90c2587b502830f55c339645ff1ae6db" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;Key&lt;/code&gt; is not &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; 이 아닌 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="735ab6f78eae524da546644a47d6f981e069b743" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;Key&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt; are not &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 또는 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; 이 아닌 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="82a17b18b659f4ccc9ce4566182a3cc7f42114d5" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;Len == 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Len == 0&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="59a8e068249dac51d245ed2c490d5c1490704809" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;T&lt;/code&gt; is an incomplete type other than (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt; or array of unknown bound.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;void&lt;/code&gt; 이거나 cv-qualified 이외의 불완전한 유형 인 경우 동작은 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0a1770e1354089d9317ac474ffc747e7d82a8c14" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;a&amp;gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&amp;gt;b&lt;/code&gt; 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3b63ea882cbcdea68d7571db64ae9203a71aaf73" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;base.size() != exp.size()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;base.size() != exp.size()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="67d354f1293c1b737ce0d288b1b9be686bda37d3" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;binary_op&lt;/code&gt; modifies any element or invalidates any iterator in [first; last], including the end iterator.</source>
          <target state="translated">동작은 정의되지 경우 &lt;code&gt;binary_op&lt;/code&gt; 수정 어떤 요소 또는 무효화 [제 어느 반복기; 마지막 반복자 포함.</target>
        </trans-unit>
        <trans-unit id="469e1d9d1c4068bbf6e1c2e697e7ffac8b8ba7f6" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;d_last&lt;/code&gt; is within &lt;code&gt;(first, last]&lt;/code&gt;. &lt;a href=&quot;move&quot;&gt; std::move&lt;/a&gt; must be used instead of &lt;code&gt;std::move_backward&lt;/code&gt; in that case.</source>
          <target state="translated">경우의 동작은 정의되지 않는다 &lt;code&gt;d_last&lt;/code&gt; 이 내 &lt;code&gt;(first, last]&lt;/code&gt; . &lt;a href=&quot;move&quot;&gt;표준 : 움직임이&lt;/a&gt; 대신 사용해야합니다 &lt;code&gt;std::move_backward&lt;/code&gt; 그 경우.</target>
        </trans-unit>
        <trans-unit id="6a69976aa807aa840671bdf8c84727126ce414a6" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;d_last&lt;/code&gt; is within &lt;code&gt;(first, last]&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;copy&quot;&gt;std::copy&lt;/a&gt;&lt;/code&gt; must be used instead of &lt;code&gt;std::copy_backward&lt;/code&gt; in that case.</source>
          <target state="translated">경우의 동작은 정의되지 않는다 &lt;code&gt;d_last&lt;/code&gt; 이 내 &lt;code&gt;(first, last]&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;copy&quot;&gt;std::copy&lt;/a&gt;&lt;/code&gt; 대신 사용해야합니다 &lt;code&gt;std::copy_backward&lt;/code&gt; 경우에.</target>
        </trans-unit>
        <trans-unit id="47d791dc5191e81ae3d09e89daf7bf07163ce6b8" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; are iterators into &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 이 &lt;code&gt;*this&lt;/code&gt; 의 반복자 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c6f3ff6f9cbc2b439afb2795f2f721f59948f3bf" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;g&lt;/code&gt; has volatile-qualified type.</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 에 volatile 한정 유형이있는 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2e9b7d5ca68b1370aed4912faec1a4760bc6179d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;get() == nullptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get() == nullptr&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6f4c18e6c7b6aea27fce5ed64368841d49ce9361" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;get_allocator() != source.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get_allocator() != source.get_allocator()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6eab0581058a4c2b12e5109fd370a8ece52140ed" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;i.result != std::chrono::local_info::ambiguous&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i.result != std::chrono::local_info::ambiguous&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="200bd29a30796e7a2a3ff517a5b5bad4ed78c850" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;i.result != std::chrono::local_info::nonexistent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i.result != std::chrono::local_info::nonexistent&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="df9572d7c8906a33d2e15c5a66892b297a9356be" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; by (possibly repeatedly) incrementing &lt;code&gt;first&lt;/code&gt;.</source>
          <target state="translated">만약 동작이 정의되고 &lt;code&gt;last&lt;/code&gt; 으로 도달 할 수없는 &lt;code&gt;first&lt;/code&gt; 증분 (아마도 반복)에 의해 &lt;code&gt;first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="464b76a8eef218307890a469421e1b605b19821f" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; are not pointers to null-terminated strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44460391a952d80167639892da39becaef08fba" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; are not pointers to null-terminated wide strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cbc83b4c31a10cebd8ea7ff74d24d3b67882e3e" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;m&lt;/code&gt; is destroyed before the &lt;code&gt;lock_guard&lt;/code&gt; object is.</source>
          <target state="translated">&lt;code&gt;lock_guard&lt;/code&gt; 객체가 제거 되기 전에 &lt;code&gt;m&lt;/code&gt; 이 제거 되면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="07f9df56c1dbfe24c25522fd1a56bdba0c1947fd" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;m&lt;/code&gt; is destroyed before the &lt;code&gt;scoped_lock&lt;/code&gt; object is.</source>
          <target state="translated">&lt;code&gt;scoped_lock&lt;/code&gt; 객체가 제거 되기 전에 &lt;code&gt;m&lt;/code&gt; 이 제거 되면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1433c58daafe2f6adc50c6512f38c69c4063319e" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;n &amp;gt; size()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n &amp;gt; size()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e976404215147707f2898a7fda666454bbfd437" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;r&lt;/code&gt; is negative or NaN, or if &lt;code&gt;theta&lt;/code&gt; is infinite.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 이 음수 또는 NaN이거나 &lt;code&gt;theta&lt;/code&gt; 가 무한한 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ad1c12decd3487f7e9d9505be86f84f4573eda77" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;size() != v.size()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size() != v.size()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="328698c40f8c76810b54bff78f2c1e778e3afda9" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;unary_op&lt;/code&gt;, &lt;code&gt;binary_op&lt;/code&gt;, &lt;code&gt;binary_op1&lt;/code&gt;, or &lt;code&gt;binary_op2&lt;/code&gt; modifies any element or invalidates any iterator in the input ranges, including their end iterators.</source>
          <target state="translated">&lt;code&gt;unary_op&lt;/code&gt; , &lt;code&gt;binary_op&lt;/code&gt; , &lt;code&gt;binary_op1&lt;/code&gt; 또는 &lt;code&gt;binary_op2&lt;/code&gt; 가 요소를 수정하거나 입력 범위에서 종료 반복자를 포함하여 반복자를 무효화하는 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="48b55273057377763eaf4481f69ee31839fd7bf3" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;x.size() != y.size()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x.size() != y.size()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6ef58144c8fcfd8d89e4718f215607421aaf5e1d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;|m|&lt;/code&gt;, &lt;code&gt;|n|&lt;/code&gt;, or the least common multiple of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt; is not representable as a value of type &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">동작이 정의되어 있지 않으면 &lt;code&gt;|m|&lt;/code&gt; , &lt;code&gt;|n|&lt;/code&gt; , 또는 &lt;code&gt;|m|&lt;/code&gt; 의 최소 ​​공배수 그리고 &lt;code&gt;|n|&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt; 유형의 값으로 표시 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e848deb0f28b1b253878c2a2ace5cb1ba25e1fa0" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if after &lt;code&gt;std::free&lt;/code&gt; returns, an access is made through the pointer &lt;code&gt;ptr&lt;/code&gt; (unless another allocation function happened to result in a pointer value equal to &lt;code&gt;ptr&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::free&lt;/code&gt; 리턴 된 후 포인터 &lt;code&gt;ptr&lt;/code&gt; 을 통해 액세스가 수행되는 경우 (다른 할당 함수가 발생하여 &lt;code&gt;ptr&lt;/code&gt; 과 동일한 포인터 값을 생성하지 않는 한) 동작은 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="382731f74485efa9af2996234b21df03cf6b975e" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if alignment is not a power of two.</source>
          <target state="translated">정렬이 2의 거듭 제곱이 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d06e069b4a8563c91c2582a692292a002622d32d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any member function other than the destructor, the copy-assignment operator, the move-assignment operator, or &lt;code&gt;valid&lt;/code&gt; is called on a &lt;code&gt;shared_future &lt;/code&gt; that does not refer to shared state (although implementations are encouraged to throw &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; indicating &lt;code&gt;no_state&lt;/code&gt; in this case). It is valid to move or copy from a shared_future object for which &lt;code&gt;valid()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">소멸자 이외의 멤버 함수가, 복사 할당 연산자, 이동 할당 연산자, 또는 경우의 동작은 정의되지 않습니다 &lt;code&gt;valid&lt;/code&gt; A의 호출 &lt;code&gt;shared_future &lt;/code&gt; 구현을 던질 것을 권장하지만 (공유 상태를 참조하지 않는 &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; 이 경우 &lt;code&gt;no_state&lt;/code&gt; 를 나타냅니다 ). &lt;code&gt;valid()&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 shared_future 객체에서 이동하거나 복사하는 것이 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="cc5d01f26b171ac39957879df053b774c1281eb1" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any member function other than the destructor, the move-assignment operator, or &lt;code&gt;valid&lt;/code&gt; is called on a &lt;code&gt;future &lt;/code&gt; that does not refer to shared state (although implementations are encouraged to throw &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; indicating &lt;code&gt;no_state&lt;/code&gt; in this case). It is valid to move from a future object for which &lt;code&gt;valid()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">소멸자, 이동 할당 연산자 또는 &lt;code&gt;valid&lt;/code&gt; 멤버 함수가 아닌 다른 멤버 함수 가 공유 상태를 참조하지 않는 &lt;code&gt;future &lt;/code&gt; 호출되는 경우 (이 경우 &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; 나타내는 std :: future_error 를 발생 &lt;code&gt;no_state&lt;/code&gt; 것이 권장되지만) 동작은 정의 되지 않습니다. . &lt;code&gt;valid()&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 미래 객체에서 이동하는 것이 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="62628ae7a2e9ed6f36760144718a5aa1f461c465" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any member of &lt;code&gt;*time_ptr&lt;/code&gt; is outside its normal range.</source>
          <target state="translated">&lt;code&gt;*time_ptr&lt;/code&gt; 의 멤버가 정상 범위를 벗어나 면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7b08c4eddc360f739319b35a38b8c070e8e78766" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any of the values in &lt;code&gt;v&lt;/code&gt; is computed during the assignment and depends on any of the values in &lt;code&gt;*this&lt;/code&gt;, that is, the expression on the right side of the assignment refers to a variable in the left side of the assignment.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 값 중 하나가 할당 중에 계산되고 &lt;code&gt;*this&lt;/code&gt; 의 값 중 하나에 의존하는 경우 동작이 정의되지 않습니다. 즉 , 할당 의 오른쪽에있는 표현식은 할당의 왼쪽에있는 변수를 나타냅니다. .</target>
        </trans-unit>
        <trans-unit id="d9d5b90cd8c93c2f355de5aef5abe9774372544d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any signal handler performs any of the following:</source>
          <target state="translated">신호 핸들러가 다음 중 하나를 수행하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f419695a80fdd6f9b48c829076db22a0d882bf7" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any value in &lt;code&gt;submatches&lt;/code&gt; is less than &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">부분 &lt;code&gt;submatches&lt;/code&gt; 값 이 &lt;code&gt;-1&lt;/code&gt; 보다 작은 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4d24b4310a27da92c3b82ad83df3a91418db2bf1" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if copied character ranges overlap, i.e. &lt;code&gt;src&lt;/code&gt; is in [&lt;code&gt;dest&lt;/code&gt;, &lt;code&gt;dest + count&lt;/code&gt;).</source>
          <target state="translated">복사 된 문자 범위가 겹치면 (예 : &lt;code&gt;src&lt;/code&gt; 가 [ &lt;code&gt;dest&lt;/code&gt; , &lt;code&gt;dest + count&lt;/code&gt; ) 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6683df606df41a9fba0766574236a56020142574" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if either &lt;code&gt;Offset&lt;/code&gt; or &lt;code&gt;Count&lt;/code&gt; is out of range. This happens if.</source>
          <target state="translated">&lt;code&gt;Offset&lt;/code&gt; 또는 &lt;code&gt;Count&lt;/code&gt; 가 범위를 벗어나 면 동작이 정의되지 않습니다 . 이 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d55697ed5f2c15128a892f22aa16ff4ee37bf2b" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if more than one replacement is provided in the program for any of the replaceable allocation function, or if a replacement is defined with the &lt;code&gt;inline&lt;/code&gt; specifier. The program is ill-formed if a replacement is defined in namespace other than global namespace, or if it is defined as a static non-member function at global scope.</source>
          <target state="translated">프로그램에 교체 가능한 할당 함수 중 하나 이상에 대해 둘 이상의 교체가 제공되거나 &lt;code&gt;inline&lt;/code&gt; 지정자 로 교체가 정의 된 경우 동작이 정의되지 않습니다 . 대체가 글로벌 네임 스페이스 이외의 네임 스페이스에 정의되어 있거나 글로벌 범위에서 정적 비 멤버 함수로 정의 된 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="038cb1cc5613100b7d719c178ef2592ef2ae999d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if more than one replacement is provided in the program or if a replacement is defined with the &lt;code&gt;inline&lt;/code&gt; specifier, the program is ill-formed if a replacement is defined in namespace other than global namespace, or if it is defined as a static non-member function at global scope.</source>
          <target state="translated">프로그램에 둘 이상의 대체가 제공되거나 &lt;code&gt;inline&lt;/code&gt; 지정자로 대체가 정의 된 경우, 대체가 글로벌 네임 스페이스 이외의 네임 스페이스에 정의되어 있거나 대체로 정의 된 경우 프로그램이 잘못 구성됩니다. 전역 범위에서 정적 비 멤버 함수.</target>
        </trans-unit>
        <trans-unit id="a20a9dd22a45ec31e734ddcf820693b4431349ff" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the &lt;code&gt;dest&lt;/code&gt; array is not large enough. The behavior is undefined if &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c627b5e29de481b45829af3c304be965f578d75f" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the &lt;code&gt;dest&lt;/code&gt; array is not large enough. The behavior is undefined if the strings overlap.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 배열이 충분히 크지 않은 경우 동작이 정의되지 않습니다. 문자열이 겹치는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e672d6612cb2434a04c81125a1da0fb7697ed68f" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the array is not already partitioned in ascending order with respect to key, according to the same criterion that &lt;code&gt;comp&lt;/code&gt; uses.</source>
          <target state="translated">&lt;code&gt;comp&lt;/code&gt; 가 사용 하는 동일한 기준에 따라 배열이 키와 관련하여 오름차순으로 분할되지 않은 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="eaab6c269f8944718df63cc4ed6bf2f8b08bc9eb" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the calendar year indicated by &lt;code&gt;time_ptr-&amp;gt;tm_year&lt;/code&gt; has more than 4 digits or is less than the year 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107f0ca619ed1641b4b32723442cde5cad358fd0" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the calling thread already owns the mutex (except if m is &lt;code&gt;&lt;a href=&quot;../thread/recursive_mutex&quot;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../thread/recursive_timed_mutex&quot;&gt;std::recursive_timed_mutex&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">호출하는 스레드가 이미 뮤텍스를 소유 한 경우 동작이 정의되지 않습니다 (m이 &lt;code&gt;&lt;a href=&quot;../thread/recursive_mutex&quot;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../thread/recursive_timed_mutex&quot;&gt;std::recursive_timed_mutex&lt;/a&gt;&lt;/code&gt; 경우 제외 )</target>
        </trans-unit>
        <trans-unit id="9597012e6d1c284aaae1be16fd72723a227375b3" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the calling thread already owns the mutex (except if m is &lt;code&gt;&lt;a href=&quot;../thread/recursive_timed_mutex&quot;&gt;std::recursive_timed_mutex&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">호출하는 스레드가 이미 뮤텍스를 소유 한 경우 동작이 정의되지 않습니다 (m이 &lt;code&gt;&lt;a href=&quot;../thread/recursive_timed_mutex&quot;&gt;std::recursive_timed_mutex&lt;/a&gt;&lt;/code&gt; 경우 제외 )</target>
        </trans-unit>
        <trans-unit id="e25ed56c543893145387cece9238aaefbb7962a5" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the calling thread already owns the mutex in any mode</source>
          <target state="translated">호출하는 스레드가 이미 모든 모드에서 뮤텍스를 소유 한 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="455f5ecf93a29b785f85a3650b334e47e270bc5d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the calling thread already owns the mutex in any mode.</source>
          <target state="translated">호출하는 스레드가 이미 모든 모드에서 뮤텍스를 소유 한 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf93000628919e2e36b8899ced4ef2e9aa80147b" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the calling thread does not own the mutex.</source>
          <target state="translated">호출하는 스레드가 뮤텍스를 소유하지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6f8ed0e1bf41e45825ee88de1ec4684196a97f1" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the catch-clause of a function-try-block used on a constructor or a destructor accesses a base or a non-static member of the object.</source>
          <target state="translated">생성자 또는 소멸자에 사용 된 function-try-block의 catch-clause가 객체의 기본 또는 비 정적 멤버에 액세스하는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10ffe7d432f0c823f0efa899069f10112e24be9a" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the destination array is not large enough for the contents of both &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; and the terminating null character.</source>
          <target state="translated">대상 배열이 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;dest&lt;/code&gt; 및 종료 null 문자 의 내용에 비해 충분히 크지 않은 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="75927258cde7082c64c027c4137cbfc360391f60" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the destination array is not large enough for the contents of both &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; and the terminating null wide character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de04579470349e59afe3e218735c91270b339460" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the destination range overlaps either of the input ranges (the input ranges may overlap each other).</source>
          <target state="translated">대상 범위가 입력 범위 중 하나와 겹치는 경우 동작이 정의되지 않습니다 (입력 범위가 서로 겹칠 수 있음).</target>
        </trans-unit>
        <trans-unit id="a37e086cae0a28fd2aae005d5f6cf8a3dd482110" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the input and output ranges overlap in any way.</source>
          <target state="translated">입력 및 출력 범위가 어떤 방식으로 겹치는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4fe485020cbf1d9a076309617005f2501c31bbb" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the input range overlaps either of the output ranges.</source>
          <target state="translated">입력 범위가 출력 범위 중 하나와 겹치는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ebe26f9bedb970f8dfbe805816ca874ada90946" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the iterator is end-of-sequence iterator.</source>
          <target state="translated">반복자가 시퀀스 끝 반복자 인 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c2d58529416e22c80b57ff0a56588fb399c9711" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the iterator is end-of-stream iterator.</source>
          <target state="translated">반복자가 스트림 끝 반복기 인 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd152c1ef8ff8aa5b3b3aae81e6c153ee0d2ce45" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the memory area referred to by &lt;code&gt;ptr&lt;/code&gt; has already been deallocated, that is, &lt;code&gt;std::free&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt; has already been called with &lt;code&gt;ptr&lt;/code&gt; as the argument and no calls to &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;std::calloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt;(since C++17), or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt; resulted in a pointer equal to &lt;code&gt;ptr&lt;/code&gt; afterwards.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 참조하는 메모리 영역 이 이미 할당 해제 된 경우 (즉, &lt;code&gt;std::free&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt; 가 이미 &lt;code&gt;ptr&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;std::calloc&lt;/a&gt;&lt;/code&gt; 호출하지 않은 경우) 동작이 정의되지 않았습니다. calloc , &lt;code&gt;&lt;a href=&quot;aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt; (C ++ 17 이후) 또는 &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt; 결과 이후 에 &lt;code&gt;ptr&lt;/code&gt; 과 동일한 포인터가 발생 했습니다.</target>
        </trans-unit>
        <trans-unit id="a3b10348058d0a2ba715c0cfc12ae65b467b766d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the mode is not one of the strings listed above. Some implementations define additional supported modes (e.g. &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/yeby3zcb.aspx&quot;&gt;Windows&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1bb7b6150b3145c9cf5771803ad15255ccd6ca" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the mutex is owned by any thread or if any thread terminates while holding any ownership of the mutex.</source>
          <target state="translated">스레드가 뮤텍스를 소유하거나 뮤텍스의 소유권을 보유한 상태에서 스레드가 종료되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a736eddc553ced80be2216fe88e77227b189294" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the path has no filename component (&lt;a href=&quot;has_path&quot;&gt;&lt;code&gt;has_filename&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">경로에 파일 이름 구성 요소가 없으면 동작이 정의되지 않습니다 ( &lt;a href=&quot;has_path&quot;&gt; &lt;code&gt;has_filename&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;false&lt;/code&gt; 를 반환 함 ).</target>
        </trans-unit>
        <trans-unit id="4e88a36bd0409a39cc3f312c7891e7e04c61f4ec" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the specified sequence of increments or decrements would require that a non-incrementable iterator (such as the past-the-end iterator) is incremented, or that a non-decrementable iterator (such as the front iterator or the singular iterator) is decremented.</source>
          <target state="translated">지정된 증분 또는 감소 시퀀스에서 증가 불가능한 반복기 (예 : 과거 반복기)가 증가되거나 감소 불가능한 반복기 (예 : 전면 반복기 또는 단수형)가 필요한 경우 동작이 정의되지 않습니다. 반복자)가 감소합니다.</target>
        </trans-unit>
        <trans-unit id="fefc04e4dd8c7088f908a5a38768eb505eba3844" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the stored pointer is null or if &lt;code&gt;idx&lt;/code&gt; is negative.</source>
          <target state="translated">저장된 포인터가 null이거나 &lt;code&gt;idx&lt;/code&gt; 가 음수 이면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="07d8fb77eabde35598fe8c80befa5c3efd1b6afe" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the strings overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467de494ac1ab3cfba0347a44deafd4ffc902185" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the time zone pointer (initialized as described above) does not refer to a time zone.</source>
          <target state="translated">표준 시간대 포인터 (위에서 설명한대로 초기화 됨)가 표준 시간대를 참조하지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4f6e5fd0799a493d3ed5fbd1465ab009b4ab908" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of &lt;code&gt;ch&lt;/code&gt; is not representable as &lt;code&gt;unsigned char&lt;/code&gt; and is not equal to &lt;code&gt;&lt;a href=&quot;../../io/c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 의 값이 &lt;code&gt;unsigned char&lt;/code&gt; 로 표현할 수 없고 &lt;code&gt;&lt;a href=&quot;../../io/c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 와 같지 않은 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="46390890d024c2fe54bd86ac81e354e42a17be4a" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of &lt;code&gt;ch&lt;/code&gt; is not representable as &lt;code&gt;unsigned char&lt;/code&gt; or is not equal to &lt;code&gt;&lt;a href=&quot;../../io/c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 값이 &lt;code&gt;unsigned char&lt;/code&gt; 로 표시 되지 않거나 &lt;code&gt;&lt;a href=&quot;../../io/c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 와 같지 않은 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="be24c4852e2e843d7e203b20ddb3314d5ddf20fe" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of &lt;code&gt;lo&lt;/code&gt; is greater than &lt;code&gt;hi&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lo&lt;/code&gt; 값 이 &lt;code&gt;hi&lt;/code&gt; 보다 큰 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4523c55aa073bbcabcbf7211d98894138b5c4a1e" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of &lt;code&gt;ptr&lt;/code&gt; does not equal a value returned earlier by &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;std::calloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt;(since C++17), or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 의 값이 &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;std::calloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt; (C ++ 17부터) 또는 &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt; 의해 이전에 리턴 된 값과 같지 않으면 동작이 정의 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="adacf118e6e6367d1ffb7672550f2db2bee36eb9" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of the pointer &lt;code&gt;stream&lt;/code&gt; is used after &lt;code&gt;fclose&lt;/code&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4fc5e3be71e180961358ca48ec87dd4644a1d35" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if there is no null character in the wide character array pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 와이드 문자 배열에 널 문자가없는 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ca13d3610cc8acabf5605d3450cc86e88d5a1571" translate="yes" xml:space="preserve">
          <source>The behavior is undefined unless &lt;code&gt;pred_.has_value()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred_.has_value()&lt;/code&gt; 아니면 동작은 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9674318ad2388398bc699c0f1e758e7d7459f5e2" translate="yes" xml:space="preserve">
          <source>The behavior is undefined unless &lt;code&gt;ready() == true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ready() == true&lt;/code&gt; 아니면 동작은 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="406f2fe80d5a065bb971ef51da29f2af631a441d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined unless lvalues of type &lt;code&gt;T_i&lt;/code&gt; are &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;.</source>
          <target state="translated">유형의 lvalues하지 않는 동작은 정의되지 않는다 &lt;code&gt;T_i&lt;/code&gt; 가 있다 &lt;a href=&quot;../../named_req/swappable&quot;&gt;스왑&lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 모든 &lt;code&gt;T_i&lt;/code&gt; 의 &lt;code&gt;Types...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="917418d84788b1fdd126a7e96c4addb503f82edf" translate="yes" xml:space="preserve">
          <source>The behavior may be undefined for the values of time_t that result in the string longer than 25 characters (e.g. year 10000).</source>
          <target state="translated">문자열이 25자를 초과하는 time_t 값에 대해 동작이 정의되지 않을 수 있습니다 (예 : 10000 년).</target>
        </trans-unit>
        <trans-unit id="2f2a15c80a11a41121cee37ced35f06f62fddb0b" translate="yes" xml:space="preserve">
          <source>The behavior of (3) when &lt;code&gt;!this-&amp;gt;ok()&lt;/code&gt; is not currently defined. It likely will be defined to return some invalid day in that case (such as &lt;code&gt;&lt;a href=&quot;../day&quot;&gt;std::chrono::day&lt;/a&gt;(0)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;!this-&amp;gt;ok()&lt;/code&gt; 가 현재 정의되지 않은 경우 (3)의 동작입니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;../day&quot;&gt;std::chrono::day&lt;/a&gt;(0)&lt;/code&gt; 과 같이 유효하지 않은 날을 반환하도록 정의되었을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5b4ba4a6d915fb2e3df2c635049c6d76bc1457c" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;format&lt;/code&gt; is undefined if &lt;code&gt;ready() != true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ready() != true&lt;/code&gt; 경우 &lt;code&gt;format&lt;/code&gt; 의 동작 은 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ca203a86e906eeb394e7069d318a97c64eebac21" translate="yes" xml:space="preserve">
          <source>The behavior of a program is undefined if a &lt;code&gt;mutex&lt;/code&gt; is destroyed while still owned by any threads, or a thread terminates while owning a &lt;code&gt;mutex&lt;/code&gt;. The &lt;code&gt;mutex&lt;/code&gt; class satisfies all requirements of &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; and &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">스레드가 여전히 소유하고있는 동안 &lt;code&gt;mutex&lt;/code&gt; 가 소멸되거나 &lt;code&gt;mutex&lt;/code&gt; 를 소유 한 상태에서 스레드가 종료 되면 프로그램의 동작은 정의되지 않습니다 . &lt;code&gt;mutex&lt;/code&gt; 클래스 만족의 모든 요구 사항 &lt;a href=&quot;../named_req/mutex&quot;&gt;뮤텍스&lt;/a&gt; 와 &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d637b696daf6b97a6b242ae05bf8fc254c5c107d" translate="yes" xml:space="preserve">
          <source>The behavior of a program is undefined if a &lt;code&gt;recursive_mutex&lt;/code&gt; is destroyed while still owned by some thread. The &lt;code&gt;recursive_mutex&lt;/code&gt; class satisfies all requirements of &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; and &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">일부 스레드가 여전히 소유하고있는 동안 &lt;code&gt;recursive_mutex&lt;/code&gt; 가 파괴 되면 프로그램의 동작은 정의되지 않습니다 . &lt;code&gt;recursive_mutex&lt;/code&gt; 의 클래스 만족의 모든 요구 사항 &lt;a href=&quot;../named_req/mutex&quot;&gt;뮤텍스&lt;/a&gt; 와 &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d49cad771a61588b17892aad75be8c0152d1db33" translate="yes" xml:space="preserve">
          <source>The behavior of a program that adds specializations for &lt;code&gt;is_clock&lt;/code&gt; is undefined.</source>
          <target state="translated">&lt;code&gt;is_clock&lt;/code&gt; 에 대한 전문화를 추가하는 프로그램의 동작 은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c62ef06b85f3980f7319fc86df63b92629337cbc" translate="yes" xml:space="preserve">
          <source>The behavior of a program that adds specializations for &lt;code&gt;std::is_execution_policy&lt;/code&gt; is undefined.</source>
          <target state="translated">&lt;code&gt;std::is_execution_policy&lt;/code&gt; 대한 전문화를 추가하는 프로그램의 동작 은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f078fbe14df7a291d872a9486b4bd6555ed5825" translate="yes" xml:space="preserve">
          <source>The behavior of a program that attempts to compare a &lt;code&gt;partial_ordering&lt;/code&gt; with anything other than the integer literal &lt;code&gt;​0​&lt;/code&gt; is undefined.</source>
          <target state="translated">시도는 비교하는 프로그램의 동작 &lt;code&gt;partial_ordering&lt;/code&gt; 를 리터럴 정수 이외로 &lt;code&gt;​0​&lt;/code&gt; 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7ee937b20b027f674ae8d49d4264fc5e59233e5" translate="yes" xml:space="preserve">
          <source>The behavior of a program that attempts to compare a &lt;code&gt;strong_equality&lt;/code&gt; with anything other than the integer literal &lt;code&gt;​0​&lt;/code&gt; is undefined.</source>
          <target state="translated">시도는 비교하는 프로그램의 동작 &lt;code&gt;strong_equality&lt;/code&gt; 를 리터럴 정수 이외로 &lt;code&gt;​0​&lt;/code&gt; 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1b3bcf18493a49d0f0a3e38ba5ff9aa51112925" translate="yes" xml:space="preserve">
          <source>The behavior of a program that attempts to compare a &lt;code&gt;strong_ordering&lt;/code&gt; with anything other than the integer literal &lt;code&gt;​0​&lt;/code&gt; is undefined.</source>
          <target state="translated">시도는 비교하는 프로그램의 동작 &lt;code&gt;strong_ordering&lt;/code&gt; 를 리터럴 정수 이외로 &lt;code&gt;​0​&lt;/code&gt; 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d61242b78813c2cd2a1388ea1adcd3850a86e08" translate="yes" xml:space="preserve">
          <source>The behavior of a program that attempts to compare a &lt;code&gt;weak_equality&lt;/code&gt; with anything other than the integer literal &lt;code&gt;​0​&lt;/code&gt; is undefined.</source>
          <target state="translated">시도는 비교하는 프로그램의 동작 &lt;code&gt;weak_equality&lt;/code&gt; 를 리터럴 정수 이외로 &lt;code&gt;​0​&lt;/code&gt; 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f409f18748c9c4847731aabfeae21ea3a47fd063" translate="yes" xml:space="preserve">
          <source>The behavior of a program that attempts to compare a &lt;code&gt;weak_ordering&lt;/code&gt; with anything other than the integer literal &lt;code&gt;​0​&lt;/code&gt; is undefined.</source>
          <target state="translated">시도는 비교하는 프로그램의 동작 &lt;code&gt;weak_ordering&lt;/code&gt; 를 리터럴 정수 이외로 &lt;code&gt;​0​&lt;/code&gt; 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b94d39763b7ebd91bb01eceb89eba346e398751" translate="yes" xml:space="preserve">
          <source>The behavior of every builtin compound-assignment expression &lt;code&gt;E1 op= E2&lt;/code&gt; (where E1 is a modifiable lvalue expression and E2 is an rvalue expression or a</source>
          <target state="translated">모든 내장 복합 할당 표현식 &lt;code&gt;E1 op= E2&lt;/code&gt; (여기서 E1은 수정 가능한 lvalue 표현식이고 E2는 rvalue 표현식 또는 a</target>
        </trans-unit>
        <trans-unit id="e6954be3777df41717ca04669e7dc00a5a0665f5" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;&lt;a href=&quot;../utility/variadic/va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; macro is undefined if the last parameter before the ellipsis has reference type, or has type that is not compatible with the type that results from default argument promotions.</source>
          <target state="translated">줄임표 앞의 마지막 매개 변수에 참조 유형이 있거나 기본 인수 승격에서 생성 된 유형과 호환되지 않는 유형이있는 경우 &lt;code&gt;&lt;a href=&quot;../utility/variadic/va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; 매크로 의 동작 은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8074475f951313711bd97c915bb6378866643af6" translate="yes" xml:space="preserve">
          <source>The behavior of the program is undefined if any of the three pragmas above appear in any context other than outside all external declarations or preceding all explicit declarations and statements inside a compound statement.</source>
          <target state="translated">위의 세 가지 pragma 중 하나가 모든 외부 선언 외부 또는 복합 명령문 내부의 모든 명시 적 선언 및 명령문 이외의 컨텍스트에 나타나는 경우 프로그램의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bc2f5dca6b44b3d5ac638731b105153f018e41b" translate="yes" xml:space="preserve">
          <source>The behavior of these functions is undefined unless the corresponding cast from &lt;code&gt;U*&lt;/code&gt; to &lt;code&gt;T*&lt;/code&gt; is well formed:</source>
          <target state="translated">이러한 함수의 동작은 &lt;code&gt;U*&lt;/code&gt; 에서 &lt;code&gt;T*&lt;/code&gt; 로의 해당 캐스트가 제대로 형성되지 않으면 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="09e007f07c00729f2bd588f5cb9fcab293788a91" translate="yes" xml:space="preserve">
          <source>The behavior of these functions is undefined unless:</source>
          <target state="translated">다음과 같은 경우가 아니면 이러한 함수의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d1872e5d43013c5012c32fbca7899bc44f2512b" translate="yes" xml:space="preserve">
          <source>The behavior of this function is equivalent to &lt;code&gt;&lt;a href=&quot;log&quot;&gt;std::log&lt;/a&gt;(z)/&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(T(10))&lt;/code&gt;.</source>
          <target state="translated">이 함수의 동작은 &lt;code&gt;&lt;a href=&quot;log&quot;&gt;std::log&lt;/a&gt;(z)/&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(T(10))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78658dc32dbfdd3ab57b055b36ff50a24fbe1eb" translate="yes" xml:space="preserve">
          <source>The behavior of this function is highly implementation-specific. For example, when used with &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::ifstream&lt;/a&gt;&lt;/code&gt;, some library implementations fill the underlying filebuf with data as soon as the file is opened (and readsome() on such implementations reads data, potentially, but not necessarily, the entire file), while other implementations only read from file when an actual input operation is requested (and readsome() issued after file opening never extracts any characters). Likewise, a call to &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;.readsome()&lt;/code&gt; may return all pending unprocessed console input, or may always return zero and extract no characters.</source>
          <target state="translated">이 함수의 동작은 구현에 따라 다릅니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::ifstream&lt;/a&gt;&lt;/code&gt; 과 함께 사용 하면 일부 라이브러리 구현은 파일을 열 자마자 기본 filebuf에 데이터를 채 웁니다 (그리고 이러한 구현의 readsome ()은 잠재적으로 전체 파일을 읽을 수는 없지만 반드시 전체 파일을 읽음). 다른 구현은 실제 입력 조작이 요청 될 때만 파일에서 읽습니다 (파일을 연 후 발행 된 readsome ()은 문자를 추출하지 않습니다). 마찬가지로 &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;.readsome()&lt;/code&gt; 호출하면 보류중인 처리되지 않은 모든 콘솔 입력을 반환하거나 항상 0을 반환하고 문자를 추출하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="758a6e7c6a9e16cd02a8726a32f107929f57f9bd" translate="yes" xml:space="preserve">
          <source>The behaviour is undefined when the two arguments are valarrays with different sizes.</source>
          <target state="translated">두 인수가 서로 다른 크기의 valarray 인 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c08434d32154e6b925a05a299485361cd8506034" translate="yes" xml:space="preserve">
          <source>The binary additive arithmetic operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7176da4edb44fdfb24d715e7d3669be25b36085b" translate="yes" xml:space="preserve">
          <source>The binary multiplicative arithmetic operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d70c467c5191ec0088e791afe7de4cb3b6b3ea" translate="yes" xml:space="preserve">
          <source>The binary operator % yields the remainder of the integer division of the first operand by the second (after usual arithmetic conversions; note that the operand types must be integral types). If the quotient &lt;code&gt;a/b&lt;/code&gt; is representable in the result type, &lt;code&gt;(a/b)*b + a%b == a&lt;/code&gt;. If the second operand is zero, the behavior is undefined. If the quotient &lt;code&gt;a/b&lt;/code&gt; is not representable in the result type, the behavior of both &lt;code&gt;a/b&lt;/code&gt; and &lt;code&gt;a%b&lt;/code&gt; is undefined (that means &lt;code&gt;INT_MIN%-1&lt;/code&gt; is undefined on 2's complement systems).</source>
          <target state="translated">이항 연산자 %는 첫 번째 피연산자의 정수 나누기의 나머지를 두 번째로 나눕니다 (일반 산술 변환 후, 피연산자 유형은 정수 유형이어야 함). 몫 &lt;code&gt;a/b&lt;/code&gt; 가 결과 유형으로 표현 가능하면 &lt;code&gt;(a/b)*b + a%b == a&lt;/code&gt; 입니다. 두 번째 피연산자가 0이면 동작이 정의되지 않은 것입니다. 몫 &lt;code&gt;a/b&lt;/code&gt; 가 결과 유형에서 표현할 수없는 경우 &lt;code&gt;a/b&lt;/code&gt; 및 &lt;code&gt;a%b&lt;/code&gt; 이 정의되지 않습니다 (즉 , 2의 보수 시스템에서 &lt;code&gt;INT_MIN%-1&lt;/code&gt; 이 정의되지 않음).</target>
        </trans-unit>
        <trans-unit id="90b1bb5e76b233c8735f62c8c50b711347fc46d8" translate="yes" xml:space="preserve">
          <source>The binary operator * performs multiplication of its operands (after usual arithmetic conversions), except that, for floating-point multiplication,</source>
          <target state="translated">이항 연산자 *는 부동 소수점 곱셈의 경우를 제외하고 피연산자의 곱셈을 수행합니다 (일반적인 산술 변환 후).</target>
        </trans-unit>
        <trans-unit id="d7a4dafd592df3f084192d6d03e8e8be221a2756" translate="yes" xml:space="preserve">
          <source>The binary operator / divides the first operand by the second (after usual arithmetic conversions).</source>
          <target state="translated">The binary operator / divides the first operand by the second (after usual arithmetic conversions).</target>
        </trans-unit>
        <trans-unit id="c4683b3a303b5dfbbf64b647e53044a1b9f6fca7" translate="yes" xml:space="preserve">
          <source>The binary predicate type must define two member types, &lt;code&gt;first_argument_type&lt;/code&gt; and &lt;code&gt;second_argument_type&lt;/code&gt;, that are convertible to the predicate's parameter types. The function objects obtained from &lt;code&gt;&lt;a href=&quot;../../memory/owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;plus&quot;&gt;std::plus&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;minus&quot;&gt;std::minus&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;multiplies&quot;&gt;std::multiplies&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;divides&quot;&gt;std::divides&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;modulus&quot;&gt;std::modulus&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;equal_to&quot;&gt;std::equal_to&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_or&quot;&gt;std::logical_or&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;bit_and&quot;&gt;std::bit_and&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;bit_or&quot;&gt;std::bit_or&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::bit_xor&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../container/map/value_comp&quot;&gt;std::map::value_comp&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../container/multimap/value_comp&quot;&gt;std::multimap::value_comp&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, or from a call to &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; have these types defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;binary_function&quot;&gt;std::binary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이진 술어 유형은 술어의 매개 변수 유형으로 변환 가능한 &lt;code&gt;first_argument_type&lt;/code&gt; 및 &lt;code&gt;second_argument_type&lt;/code&gt; 의 두 가지 멤버 유형을 정의해야합니다 . &lt;code&gt;&lt;a href=&quot;../../memory/owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;plus&quot;&gt;std::plus&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;minus&quot;&gt;std::minus&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;multiplies&quot;&gt;std::multiplies&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;divides&quot;&gt;std::divides&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;modulus&quot;&gt;std::modulus&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;equal_to&quot;&gt;std::equal_to&lt;/a&gt;&lt;/code&gt; , 에서 얻은 함수 객체 &lt;code&gt;&lt;a href=&quot;not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;logical_or&quot;&gt;std::logical_or&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;bit_and&quot;&gt;std::bit_and&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;bit_or&quot;&gt;std::bit_or&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::bit_xor&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../container/map/value_comp&quot;&gt;std::map::value_comp&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../container/multimap/value_comp&quot;&gt;std::multimap::value_comp&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 또는 a에서 &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; 대한 호출 은 더 이상 사용되지 않는 &lt;code&gt;&lt;a href=&quot;binary_function&quot;&gt;std::binary_function&lt;/a&gt;&lt;/code&gt; 에서 파생 된 함수 객체와 마찬가지로 이러한 유형을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="3e74ca064fe8afd8f7fd74a0aad91022a0b4b633" translate="yes" xml:space="preserve">
          <source>The binary predicate type must define two member types, &lt;code&gt;first_argument_type&lt;/code&gt; and &lt;code&gt;second_argument_type&lt;/code&gt;, that are convertible to the predicate's parameter types. The function objects obtained from &lt;code&gt;&lt;a href=&quot;../../memory/owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;plus&quot;&gt;std::plus&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;minus&quot;&gt;std::minus&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;multiplies&quot;&gt;std::multiplies&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;divides&quot;&gt;std::divides&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;modulus&quot;&gt;std::modulus&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;equal_to&quot;&gt;std::equal_to&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_or&quot;&gt;std::logical_or&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;bit_and&quot;&gt;std::bit_and&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;bit_or&quot;&gt;std::bit_or&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::bit_xor&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::map::value_comp&lt;/code&gt;, &lt;code&gt;std::multimap::value_comp&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, or from another call to &lt;code&gt;std::not2&lt;/code&gt; have these types defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;binary_function&quot;&gt;std::binary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이진 술어 유형은 술어의 매개 변수 유형으로 변환 가능한 &lt;code&gt;first_argument_type&lt;/code&gt; 및 &lt;code&gt;second_argument_type&lt;/code&gt; 의 두 가지 멤버 유형을 정의해야합니다 . &lt;code&gt;&lt;a href=&quot;../../memory/owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;plus&quot;&gt;std::plus&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;minus&quot;&gt;std::minus&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;multiplies&quot;&gt;std::multiplies&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;divides&quot;&gt;std::divides&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;modulus&quot;&gt;std::modulus&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;equal_to&quot;&gt;std::equal_to&lt;/a&gt;&lt;/code&gt; , 에서 얻은 함수 객체 &lt;code&gt;&lt;a href=&quot;not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;logical_or&quot;&gt;std::logical_or&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;bit_and&quot;&gt;std::bit_and&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;bit_or&quot;&gt;std::bit_or&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::bit_xor&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::map::value_comp&lt;/code&gt; , &lt;code&gt;std::multimap::value_comp&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 또는 다른 곳에서 &lt;code&gt;std::not2&lt;/code&gt; 대한 호출 은 더 이상 사용되지 않는 &lt;code&gt;&lt;a href=&quot;binary_function&quot;&gt;std::binary_function&lt;/a&gt;&lt;/code&gt; 에서 파생 된 함수 객체와 마찬가지로 이러한 유형을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="effff8b4f81bd6ea12cc6ac7cfd98223d06e7f20" translate="yes" xml:space="preserve">
          <source>The bitmask representing the character classification determined by the given character class, or &lt;code&gt;char_class_type()&lt;/code&gt; if the class is unknown.</source>
          <target state="translated">지정된 문자 클래스에 의해 결정된 문자 분류를 나타내는 비트 마스크 또는 클래스를 알 수없는 경우 &lt;code&gt;char_class_type()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="100851a34642290acbb870e0a5584e24eb5ee801" translate="yes" xml:space="preserve">
          <source>The bitmask type supports a finite number of bitmask elements, which are distinct non-zero values of the bitmask type, such that, for any pair Ci and Cj, &lt;code&gt;Ci &amp;amp; Ci&lt;/code&gt; is nonzero and &lt;code&gt;Ci &amp;amp; Cj&lt;/code&gt; is zero. In addition, the value &lt;code&gt;0&lt;/code&gt; is used to represent an empty bitmask, with no values set.</source>
          <target state="translated">비트 마스크 유형은 비트 마스크 유형의 고유 한 0이 아닌 값인 유한 수의 비트 마스크 요소를 지원합니다. 따라서 Ci와 Cj 쌍에서 &lt;code&gt;Ci &amp;amp; Ci&lt;/code&gt; 는 0이 아니고 &lt;code&gt;Ci &amp;amp; Cj&lt;/code&gt; 는 0입니다. 또한 값 &lt;code&gt;0&lt;/code&gt; 은 값이 설정되지 않은 빈 비트 마스크를 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9b53aa8540cf3072f1caa4828d4f3227016694d" translate="yes" xml:space="preserve">
          <source>The bitwise arithmetic operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369d078387439db964ec186ce1ea0b0074753233" translate="yes" xml:space="preserve">
          <source>The bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for values of the bitmask type and have the same semantics as the corresponding built-in operators on unsigned integers would have if the bitmask elements were the distinct integer powers of two.</source>
          <target state="translated">비트 연산자 &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; 및 &lt;code&gt;operator^=&lt;/code&gt; 는 비트 마스크 유형의 값에 대해 정의되며 비트 마스크 요소가 고유 한 경우 부호없는 정수의 해당 내장 연산자와 동일한 의미를 갖습니다. 2의 정수 제곱.</target>
        </trans-unit>
        <trans-unit id="b023ae87ef451cdf626ad0291435d5b825d5fd03" translate="yes" xml:space="preserve">
          <source>The bitwise shift operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca1ed96156947db52e3afd7acb31f7ff0f939a2" translate="yes" xml:space="preserve">
          <source>The body of a &lt;a href=&quot;function&quot;&gt;function definition&lt;/a&gt; of any constructor, before the opening brace of the compound statement, may include the</source>
          <target state="translated">복합 명령문의 여는 중괄호 앞에 생성자 의 &lt;a href=&quot;function&quot;&gt;함수 정의&lt;/a&gt; 본문 에는 다음이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7060cde55d88c14aaece02d89a680f9d4f458298" translate="yes" xml:space="preserve">
          <source>The body of a switch statement may have an arbitrary number of &lt;code&gt;case:&lt;/code&gt; labels, as long as the values of all constant_expressions are unique (after conversions/promotions). At most one &lt;code&gt;default:&lt;/code&gt; label may be present (although nested switch statements may use their own &lt;code&gt;default:&lt;/code&gt; labels or have &lt;code&gt;case:&lt;/code&gt; labels whose constants are identical to the ones used in the enclosing switch).</source>
          <target state="translated">switch 문의 본문에는 모든 constant_expressions 값이 고유 한 경우 (변환 / 프로모션 후) 임의의 수의 &lt;code&gt;case:&lt;/code&gt; 레이블 이있을 수 있습니다 . 최대 하나의 &lt;code&gt;default:&lt;/code&gt; 레이블이 존재할 수 있습니다 (중첩 된 스위치 명령문은 고유 한 &lt;code&gt;default:&lt;/code&gt; 레이블을 사용하거나 대 / &lt;code&gt;case:&lt;/code&gt; 를 포함 할 수 있음). 상수는 둘러싸는 스위치에 사용 된 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fd894a48420a86ae1a785a1f4f06ed146adeaad1" translate="yes" xml:space="preserve">
          <source>The body of the main function</source>
          <target state="translated">주요 기능의 본문</target>
        </trans-unit>
        <trans-unit id="4d4e808b1a94155a447d2ba6b8aae0ce2aed1e13" translate="yes" xml:space="preserve">
          <source>The boolean logic operators, &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;operator||&lt;/code&gt;. Unlike the built-in versions, the overloads cannot implement short-circuit evaluation. Also unlike the built-in versions, they do not sequence their left operand before the right one.(until C++17) In the standard library, these operators are only overloaded for &lt;code&gt;&lt;a href=&quot;../numeric/valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">부울 논리 연산자, &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;operator||&lt;/code&gt; . 내장 버전과 달리 과부하는 단락 평가를 구현할 수 없습니다. 또한 기본 제공 버전과 달리 왼쪽 피연산자를 오른쪽 피연산자 앞에 시퀀싱하지 않습니다. (C ++ 17까지) 표준 라이브러리에서 이러한 연산자는 &lt;code&gt;&lt;a href=&quot;../numeric/valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 대해서만 오버로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="be9b5d4b5d4c705cb17f7416c8fc4ab7e8cb9ee5" translate="yes" xml:space="preserve">
          <source>The boolean result of the comparison as described above.</source>
          <target state="translated">위에서 설명한 비교의 부울 결과입니다.</target>
        </trans-unit>
        <trans-unit id="ecf2e3902eed13149644949cf013da30e0846854" translate="yes" xml:space="preserve">
          <source>The braces of the language specification do not establish a scope.</source>
          <target state="translated">언어 사양의 중괄호는 범위를 설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea016ec910e6873dfc79ae24437a3c519704144a" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; for floating-point numbers may set &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd808c844289be1c901eea1e57131ddc87294a7" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;gt;=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fa125b7f1d723b624671e912e92993b1585ff7" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of the expression &lt;code&gt;x &amp;lt; y || x &amp;gt; y&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 숫자에 대한 내장 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 는 인수 중 하나 또는 둘 다가 NaN 인 경우 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 를 발생 시킬 수 있습니다 . 이 함수는 표현식 &lt;code&gt;x &amp;lt; y || x &amp;gt; y&lt;/code&gt; 의 &quot;quiet&quot;버전입니다. x&amp;gt; y .</target>
        </trans-unit>
        <trans-unit id="ac907543c60c06a9a51c071f27b11749c7308d57" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55246b361f4bd424491e57d0679d399ec77fce75" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;lt;=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5fbdb85b383f1652e18638359a36e108ea3a07" translate="yes" xml:space="preserve">
          <source>The built-in subscript expression &lt;code&gt;E1[E2]&lt;/code&gt; is exactly identical to the expression &lt;code&gt;*(E1 + E2)&lt;/code&gt; except &lt;a href=&quot;eval_order&quot;&gt;evaluation order&lt;/a&gt;(since C++17), that is, the pointer operand (which may be a result of array-to-pointer conversion, and which must point to an element of some array or one past the end) is adjusted to point to another element of the same array, following the rules of &lt;a href=&quot;operator_arithmetic&quot;&gt;pointer arithmetics&lt;/a&gt;, and is then dereferenced.</source>
          <target state="translated">내장 첨자 표현식 &lt;code&gt;E1[E2]&lt;/code&gt; 는 &lt;a href=&quot;eval_order&quot;&gt;평가 순서&lt;/a&gt; (C ++ 17부터), 즉 포인터 피연산자 (배열에 대한 결과 일 수 있음 &lt;code&gt;*(E1 + E2)&lt;/code&gt; 제외하고 표현식 * (E1 + E2) 와 정확히 동일합니다. 포인터 변환 (및 일부 배열의 요소 또는 끝을지나 쳐야 함)은 &lt;a href=&quot;operator_arithmetic&quot;&gt;포인터 산술&lt;/a&gt; 규칙에 따라 동일한 배열의 다른 요소를 가리 키도록 조정 된 다음 역 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="dad1ba0648301ebf8046390e4a32c1f9873801f7" translate="yes" xml:space="preserve">
          <source>The built-in unary plus operator returns the value of its operand. The only situation where it is not a no-op is when the operand has integral type or unscoped enumeration type, which is changed by integral promotion, e.g, it converts &lt;code&gt;char&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt; or if the operand is subject to lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversion.</source>
          <target state="translated">내장 단항 더하기 연산자는 피연산자의 값을 반환합니다. 이 무 조작하지없는 유일한 상황은 피연산자 예 일체형 또는 일체 프로모션에 의해 변경되는 범위가 지정되지 않은 열거 형을 갖는 경우, 그 변환이다 &lt;code&gt;char&lt;/code&gt; 에 &lt;code&gt;int&lt;/code&gt; 또는 피연산자 좌변 투 r- 수치 될 경우, 배열에서 포인터로 또는 함수에서 포인터로 변환</target>
        </trans-unit>
        <trans-unit id="04d132ee6ec1ba9ecfd11952d40819b6ddf5709f" translate="yes" xml:space="preserve">
          <source>The builtin unary minus operator calculates the negative of its promoted operand. For unsigned &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;-a&lt;/code&gt; is 2b</source>
          <target state="translated">내장 단항 빼기 연산자는 승격 된 피연산자의 음수를 계산합니다. 부호없는 &lt;code&gt;a&lt;/code&gt; 의 경우 &lt;code&gt;-a&lt;/code&gt; 값 은 2b입니다.</target>
        </trans-unit>
        <trans-unit id="5b0dd408f6ab2c6addd6c06732e19880156ebd2e" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;std::nan(&quot;&quot;)&lt;/code&gt; is equivalent to the call &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(&quot;NAN()&quot;, (char**)nullptr);&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;std::nan(&quot;&quot;)&lt;/code&gt; 호출하는 것과 같습니다 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(&quot;NAN()&quot;, (char**)nullptr);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7567df6e5bfc77fb6213d590212bee2233bcb69a" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;std::nan(&quot;n-char-sequence&quot;)&lt;/code&gt;, where &lt;code&gt;n-char-sequence&lt;/code&gt; is a sequence of digits, Latin letters, and underscores, is equivalent to the call &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(&quot;NAN(n-char-sequence)&quot;, (char**)nullptr);&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::nan(&quot;n-char-sequence&quot;)&lt;/code&gt; 호출 . 여기서 &lt;code&gt;n-char-sequence&lt;/code&gt; 는 일련의 숫자, 라틴 문자 및 밑줄이며 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(&quot;NAN(n-char-sequence)&quot;, (char**)nullptr);&lt;/code&gt; 호출 ( &quot;NAN (n-char)과 같습니다. -시퀀스) &quot;, (char **) nullptr); .</target>
        </trans-unit>
        <trans-unit id="3bb18577641139ae5227c7592e36b1c655fd5a87" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;std::nan(&quot;string&quot;)&lt;/code&gt;, where &lt;code&gt;string&lt;/code&gt; is neither an n-char-sequence nor an empty string, is equivalent to the call &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(&quot;NAN&quot;, (char**)nullptr);&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::nan(&quot;string&quot;)&lt;/code&gt; 호출 ( 여기서 &lt;code&gt;string&lt;/code&gt; 은 n 문자 순서도 아니고 빈 문자열도 아닙니다)는 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(&quot;NAN&quot;, (char**)nullptr);&lt;/code&gt; 호출과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="b5ff4abb5e0ea3aa7864a0b18b7e95fdf8974f33" translate="yes" xml:space="preserve">
          <source>The call is equivalent to &lt;code&gt;(*this)[n].length()&lt;/code&gt;.</source>
          <target state="translated">호출은 &lt;code&gt;(*this)[n].length()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd2e2ab41b6da2e04d11a8d565e0c040634df556" translate="yes" xml:space="preserve">
          <source>The call is equivalent to &lt;code&gt;string_type((*this)[n])&lt;/code&gt;;</source>
          <target state="translated">호출은 &lt;code&gt;string_type((*this)[n])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8539f22fc056117494fbef42d83b731614e0acf" translate="yes" xml:space="preserve">
          <source>The call modifies the pending recursion flag on the iterator in such a way that the next time &lt;a href=&quot;increment&quot;&gt;&lt;code&gt;increment&lt;/code&gt;&lt;/a&gt; is called, the iterator will advance within the current directly even if it is currently referring to a subdirectory that hasn't been visited.</source>
          <target state="translated">이 호출은 다음 번 &lt;a href=&quot;increment&quot;&gt; &lt;code&gt;increment&lt;/code&gt; &lt;/a&gt; 이 호출 되는 방식으로 반복자의 보류중인 재귀 플래그를 수정 하며, 현재 방문하지 않은 서브 디렉토리를 참조하더라도 반복자는 현재 내에서 직접 진행합니다.</target>
        </trans-unit>
        <trans-unit id="534dac31ce734bf4cbcd27cdcaefba61f04409b9" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; can be optimized out (even if custom allocator is used) if.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; 호출 은 사용자 지정 할당자를 사용하더라도 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f89a83188d1d3b695f6bf3795b5c9bc24c27ae3" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze()&lt;/a&gt;&lt;/code&gt; guarantees that the returned pointer remains valid until the next explicit call to &lt;code&gt;freeze(false)&lt;/code&gt;: otherwise (on a dynamic buffer) any output operation could trigger buffer reallocation which would invalidate the pointer. It also causes a memory leak in the destructor of &lt;code&gt;std::strstreambuf&lt;/code&gt;, unless &lt;code&gt;freeze(false)&lt;/code&gt; is called before the buffer (or, more commonly, the &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; that manages it) is destroyed.</source>
          <target state="translated">호출하기 &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze()&lt;/a&gt;&lt;/code&gt; 다음 명시 적으로 호출 할 때까지 반환 된 포인터가 유효 것을 보장 &lt;code&gt;freeze(false)&lt;/code&gt; 모든 출력 작업이 포인터를 무효화 할 버퍼 재 할당을 게재 할 수 그렇지 않으면 (동적 버퍼에). 또한 버퍼 (또는보다 일반적으로 이를 관리 하는 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; )가 파괴 되기 전에 &lt;code&gt;freeze(false)&lt;/code&gt; 를 호출 하지 않으면 &lt;code&gt;std::strstreambuf&lt;/code&gt; 소멸자에서 메모리 누수가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="e94bc704a1f2a718446c9b31af0e5fa96d1fb293" translate="yes" xml:space="preserve">
          <source>The call to the class-specific &lt;code&gt;T::operator delete&lt;/code&gt; on a polymorphic class is the only case where a static member function is called through dynamic dispatch.</source>
          <target state="translated">다형성 클래스 에서 클래스 별 &lt;code&gt;T::operator delete&lt;/code&gt; 호출은 정적 디스패치 함수가 동적 디스패치를 ​​통해 호출되는 유일한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="efdb0b51b48b9bcd6bb30a4d0b0da24f53593e93" translate="yes" xml:space="preserve">
          <source>The callbacks are called in the reverse order of registration (in other words, &lt;code&gt;register_callback()&lt;/code&gt; pushes a callback pair on the callback stack). If &lt;code&gt;register_callback()&lt;/code&gt; is called from within a callback function to add a new callback, the new callback is only called on the next event.</source>
          <target state="translated">콜백은 등록 순서와 반대로 호출됩니다 (즉, &lt;code&gt;register_callback()&lt;/code&gt; 은 콜백 스택에서 콜백 쌍을 푸시합니다). 경우 &lt;code&gt;register_callback()&lt;/code&gt; 새로운 콜백을 추가 할 콜백 함수 내에서 호출되어, 새로운 콜백은 다음 이벤트에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2f897118aebcd041bc3c35c8035c63c94fdfec84" translate="yes" xml:space="preserve">
          <source>The canonical copy-assignment operator is expected to &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c62-make-copy-assignment-safe-for-self-assignment&quot;&gt;perform no action on self-assignment&lt;/a&gt;, and to return the lhs by reference:</source>
          <target state="translated">표준 복사 할당 연산자는 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c62-make-copy-assignment-safe-for-self-assignment&quot;&gt;자체 할당에 대한 조치&lt;/a&gt; 를 수행하지 않고 참조로 lh를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec5078dd7a065edc2083fa12ace4434f4c0077ba" translate="yes" xml:space="preserve">
          <source>The canonical move assignment is expected to &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state&quot;&gt;leave the moved-from object in valid state&lt;/a&gt; (that is, a state with class invariants intact), and either &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c65-make-move-assignment-safe-for-self-assignment&quot;&gt;do nothing&lt;/a&gt; or at least leave the object in a valid state on self-assignment, and return the lhs by reference to non-const, and be noexcept:</source>
          <target state="translated">정식 이동 할당은 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state&quot;&gt;이동 된 객체를 유효한 상태&lt;/a&gt; (즉, 클래스 불변 값이있는 상태)로 유지 하고 자체 할당시 객체를 유효한 상태로 두거나 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c65-make-move-assignment-safe-for-self-assignment&quot;&gt;아무 것도&lt;/a&gt; 두지 않아야합니다. 비 Const와 관련하여 lhs이며 예외는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="28df12d743e66354dc16272de0483a1adb821f60" translate="yes" xml:space="preserve">
          <source>The captures is a comma-separated list of zero or more</source>
          <target state="translated">캡처는 쉼표로 구분 된 0 이상의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="13cf37550f6560dbfd18d33f41b7e0c3128acf14" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C (to which C++ defers), but it is defined as a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/sin.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="translated">인수가 무한한 경우는 C에서 도메인 오류 (C ++로 지연)로 지정되지 않지만 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/sin.html&quot;&gt;POSIX에서 도메인 오류&lt;/a&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7f85d60c57cf322439b1e5b7790bc83208f4f5b" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C (to which C++ defers), but it is defined as a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="translated">인수가 무한한 경우는 C에서 도메인 오류 (C ++로 지연)로 지정되지 않지만 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html&quot;&gt;POSIX에서 도메인 오류&lt;/a&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e0a943ad67969e22cbc79ab2e94f2ba315815da" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/cos.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5aa9b2785befe3ac51560ee601e2aaa94d1a31" translate="yes" xml:space="preserve">
          <source>The case-insensitive comparison for the non-whitespace non-&lt;code&gt;'%'&lt;/code&gt; characters in the format string, the &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet of the locale provided by &lt;code&gt;str&lt;/code&gt; is typically, but not necessarily, used.</source>
          <target state="translated">형식 문자열에서 공백이 아닌 &lt;code&gt;'%'&lt;/code&gt; 문자에 대해 대소 문자를 구분하지 않는 비교 인 &lt;code&gt;str&lt;/code&gt; 이 제공하는 로케일 의 &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; 패싯 이 일반적으로 사용되지만 반드시 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9313e91b45e2be0a3799d16fb75da830d5892cc8" translate="yes" xml:space="preserve">
          <source>The case-insensitive comparison key for &lt;code&gt;c&lt;/code&gt; in the currently imbued locale.</source>
          <target state="translated">현재 삽입 된 로케일의 &lt;code&gt;c&lt;/code&gt; 에 대해 대소 문자를 구분하지 않는 비교 키입니다 .</target>
        </trans-unit>
        <trans-unit id="67cdfac77816d6a726c77e23a3f364e8d4647a48" translate="yes" xml:space="preserve">
          <source>The catch-all clause &lt;code&gt;catch (...)&lt;/code&gt; matches exceptions of any type. If present, it has to be the last catch clause in the handler-seq. Catch-all block may be used to ensure that no uncaught exceptions can possibly escape from a function that offers &lt;a href=&quot;exceptions&quot;&gt;nothrow exception guarantee&lt;/a&gt;.</source>
          <target state="translated">catch-all 절 &lt;code&gt;catch (...)&lt;/code&gt; 는 모든 유형의 예외와 일치합니다. 존재하는 경우, handler-seq의 마지막 catch 절이어야합니다. catch-all 블록은 catch되지 않은 예외가 &lt;a href=&quot;exceptions&quot;&gt;nothrow 예외 보증&lt;/a&gt; 을 제공하는 함수에서 벗어날 수 없도록 보장하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25bc4efefc84d37cdf5da26ff6ceab175e1c6aaf" translate="yes" xml:space="preserve">
          <source>The character array and single character overloads of &lt;a href=&quot;../basic_istream/operator_gtgt2&quot;&gt;&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if they fail to extract any characters.</source>
          <target state="translated">문자 배열 을 추출하지 못하면 &lt;a href=&quot;../basic_istream/operator_gtgt2&quot;&gt; &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 문자 배열과 단일 문자 과부하가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a48f4e44be4acbc878599ffe7694d1a4bc87d3cc" translate="yes" xml:space="preserve">
          <source>The character extraction overloads of &lt;a href=&quot;../basic_istream/operator_gtgt2&quot;&gt;&lt;code&gt;operator&amp;gt;&amp;gt;std::basic_istream&lt;/code&gt;&lt;/a&gt;, if the end of the stream is reached before the limit (if any) on the number of characters to be extracted.</source>
          <target state="translated">추출 할 문자 수 의 한계 (있는 경우) 이전에 스트림의 끝에 도달하면 &lt;a href=&quot;../basic_istream/operator_gtgt2&quot;&gt; &lt;code&gt;operator&amp;gt;&amp;gt;std::basic_istream&lt;/code&gt; &lt;/a&gt; 의 문자 추출 과부하입니다 .</target>
        </trans-unit>
        <trans-unit id="65d8f3b0f6e704d789a5d4f4bd154ae73e6fa9c4" translate="yes" xml:space="preserve">
          <source>The character representation and encoding in the controlled sequence may be different from the character representations in the associated sequence, in which case a &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; locale facet is typically used to perform the conversion. Common examples are UTF-8 (or other multibyte) files accessed through &lt;code&gt;&lt;a href=&quot;basic_fstream&quot;&gt;std::wfstream&lt;/a&gt;&lt;/code&gt; objects: the controlled sequence consists of &lt;code&gt;wchar_t&lt;/code&gt; characters, but the associated sequence consists of bytes.</source>
          <target state="translated">제어 된 시퀀스에서의 문자 표현 및 인코딩은 연관된 시퀀스에서의 문자 표현과 다를 수 있으며,이 경우에 &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 로케일 패싯이 전형적으로 변환을 수행하는데 사용된다. 일반적인 예는 &lt;code&gt;&lt;a href=&quot;basic_fstream&quot;&gt;std::wfstream&lt;/a&gt;&lt;/code&gt; 객체를 통해 액세스되는 UTF-8 (또는 기타 멀티 바이트) 파일입니다 . 제어 된 시퀀스는 &lt;code&gt;wchar_t&lt;/code&gt; 문자 로 구성 되지만 관련 시퀀스는 바이트로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="926a2b9c5d9e0f6df7a1c8599b95afbe627a76bc" translate="yes" xml:space="preserve">
          <source>The character stream that was operated on, e.g. &lt;code&gt;os&lt;/code&gt; or &lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">에 예를 들어 운영 된 문자 스트림 &lt;code&gt;os&lt;/code&gt; 또는 &lt;code&gt;is&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a135798382138f1d168ced859370bfbbb31e66a" translate="yes" xml:space="preserve">
          <source>The character to use as decimal point character is determined by the numpunct facet of the locale imbued in the stream at the time of output, as described in &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">소수점 문자로 사용할 문자는 &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::put&lt;/a&gt;&lt;/code&gt; 설명 된대로 출력시 스트림에 임베드 된 로케일의 숫자 패싯에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="29a30c51583aaf8336af6480761031b5d4dd3ee7" translate="yes" xml:space="preserve">
          <source>The character types &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;(since C++20), &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, and &lt;code&gt;wchar_t&lt;/code&gt;;</source>
          <target state="translated">문자 유형 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; (C ++ 20부터), &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; 및 &lt;code&gt;wchar_t&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="de5230b19ff6d3b6862f39e1e4b2ca7bccdab9a8" translate="yes" xml:space="preserve">
          <source>The characters &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt; are invariant under ISO-646, but alternatives are provided for the tokens that use these characters anyway to accomodate even more restrictive historical charsets.</source>
          <target state="translated">문자 &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;!&lt;/code&gt; 는 ISO-646에 따라 변하지 않지만 어쨌든 이러한 문자를 사용하여 훨씬 더 제한적인 역사적 문자 세트를 수용하는 토큰에 대한 대안이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b214f3ed1bb00f84b126e636c023f9506df83f29" translate="yes" xml:space="preserve">
          <source>The characters of the C-strings pointed to by &lt;code&gt;grouping&lt;/code&gt; and &lt;code&gt;mon_grouping&lt;/code&gt; are interpreted according to their numeric values. When the terminating &lt;code&gt;'\0'&lt;/code&gt; is encountered, the last value seen is assumed to repeat for the remainder of digits. If &lt;code&gt;&lt;a href=&quot;../types/climits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; is encountered, no further digits are grouped. the typical grouping of three digits at a time is &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;grouping&lt;/code&gt; 및 &lt;code&gt;mon_grouping&lt;/code&gt; 으로 가리키는 C- 문자열의 문자는 숫자 값에 따라 해석됩니다. 종료 &lt;code&gt;'\0'&lt;/code&gt; 이 발생하면 마지막으로 본 값이 나머지 숫자에 대해 반복되는 것으로 가정합니다. 경우 &lt;code&gt;&lt;a href=&quot;../types/climits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; 가 발생, 더 이상의 숫자가 그룹화되지 않습니다. 한 번에 3 자리 숫자의 일반적인 그룹은 &lt;code&gt;&quot;\003&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="50e61c5054d2f85ac64df9adcc0316f25e4682e2" translate="yes" xml:space="preserve">
          <source>The choice of which engine to use involves a number of tradeoffs: the linear congruential engine is moderately fast and has a very small storage requirement for state. The lagged Fibonacci generators are very fast even on processors without advanced arithmetic instruction sets, at the expense of greater state storage and sometimes less desirable spectral characteristics. The Mersenne twister is slower and has greater state storage requirements but with the right parameters has the longest non-repeating sequence with the most desirable spectral characteristics (for a given definition of desirable).</source>
          <target state="translated">어떤 엔진을 사용할지 선택하는 것은 많은 트레이드 오프가 필요합니다. 선형 합동 엔진은 적당히 빠르며 상태에 대한 저장 요구 사항이 매우 작습니다. 지연 피보나치 발생기는 고급 산술 명령어 세트가없는 프로세서에서도 상태 저장 용량이 높고 때로는 스펙트럼 특성이 좋지 않은 경우에도 매우 빠릅니다. 메르 센 트위스터는 속도가 느리고 상태 저장 요구 사항이 더 크지 만 올바른 매개 변수를 사용하면 가장 바람직한 스펙트럼 특성을 가진 가장 긴 비 반복 시퀀스가 ​​있습니다 (주어진 주어진 정의에 대해).</target>
        </trans-unit>
        <trans-unit id="389756ed6e9c288a5d7721af8a052706a08051ec" translate="yes" xml:space="preserve">
          <source>The choices made by each implementation about the sizes of the fundamental types are collectively known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ffe543c1f7cc269e00940b5664a9591d581f02" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;any&lt;/code&gt; describes a type-safe container for single values of any type.</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; 클래스 는 모든 유형의 단일 값에 대한 유형 안전 컨테이너를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="343de7297b1a09b656158540d019c5105d45a580" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;basic_streambuf&lt;/code&gt; controls input and output to a character sequence. It includes and provides access to.</source>
          <target state="translated">&lt;code&gt;basic_streambuf&lt;/code&gt; 클래스 는 입력 및 출력을 문자 순서로 제어합니다. 여기에는 액세스 권한이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc3b7d04e5b01d17ca16c3dd7eb6a668493520a7" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;contract_violation&lt;/code&gt; describes information about a &lt;a href=&quot;../language/attributes/contract&quot;&gt;contract violation&lt;/a&gt;. It is generated by a C++ implementation and passed to a contract violation handler when a contract violation is detected.</source>
          <target state="translated">&lt;code&gt;contract_violation&lt;/code&gt; 클래스 는 &lt;a href=&quot;../language/attributes/contract&quot;&gt;계약 위반&lt;/a&gt; 에 대한 정보를 설명합니다 . C ++ 구현에서 생성되며 계약 위반이 감지되면 계약 위반 핸들러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0933dd797b634fb57481e64c84a2e2ad46d4ec11" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;contract_violation&lt;/code&gt; is used by the implementation to report information about a contract violation to the violation handler.</source>
          <target state="translated">&lt;code&gt;contract_violation&lt;/code&gt; 클래스 는 구현에서 계약 위반에 대한 정보를 위반 핸들러에보고하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3d108383c7a03d1c8ed761859ac19042a6996b74" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;day&lt;/code&gt; represents a day in a month. Its normal range is [1, 31], but it may hold any number in [0, 255].</source>
          <target state="translated">수업 &lt;code&gt;day&lt;/code&gt; 한 달의 일을 나타냅니다. 정상 범위는 [1, 31]이지만 [0, 255]의 숫자를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb1865a269f77db6239124ab3f4f7037e783663b" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;ios_base&lt;/code&gt; is a multipurpose class that serves as the base class for all I/O stream classes. It maintains several kinds of data:</source>
          <target state="translated">클래스 &lt;code&gt;ios_base&lt;/code&gt; 는 모든 I / O 스트림 클래스의 기본 클래스로서의 범용 클래스이다. 여러 종류의 데이터를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f3ae56fc04b1b726fbae27b7509b3c5a19f45554" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;istrstream&lt;/code&gt; implements input operations on array-backed streams. It essentially wraps a raw array I/O device implementation (&lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;) into the higher-level interface of &lt;code&gt;&lt;a href=&quot;basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;istrstream&lt;/code&gt; 클래스 는 배열 지원 스트림에서 입력 작업을 구현합니다. 기본적으로 원시 배열 I / O 장치 구현 ( &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 의 상위 레벨 인터페이스로 랩핑합니다 .</target>
        </trans-unit>
        <trans-unit id="d68c9d9976237e7bad1d9c374222a16482710351" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;leap&lt;/code&gt; represents the date and time of a leap second insertion.</source>
          <target state="translated">클래스 &lt;code&gt;leap&lt;/code&gt; 은 윤초 삽입 날짜 및 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="abf01ffffb7311c0e4b841a0f6111a62e524be1c" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;link&lt;/code&gt; represents an alternative name for a time zone.</source>
          <target state="translated">클래스 &lt;code&gt;link&lt;/code&gt; 는 시간대의 대체 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="83b88fa0a429df9a4f0587056fe07f11f7518785" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;local_info&lt;/code&gt; describes the result of converting a &lt;code&gt;std::chrono::local_time&lt;/code&gt; to a &lt;code&gt;std::chrono::sys_time&lt;/code&gt;.</source>
          <target state="translated">클래스 &lt;code&gt;local_info&lt;/code&gt; 는 A 변환의 결과에 대해 설명 &lt;code&gt;std::chrono::local_time&lt;/code&gt; 에 &lt;code&gt;std::chrono::sys_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c75928d0fbd7736eb6e55c560a45d617e4a37b4" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;local_t&lt;/code&gt; is a pseudo-clock that is used as the first template argument to &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; to indicate that the time point represents local time with respect of a not-yet-specified time zone. &lt;code&gt;local_time&lt;/code&gt; supports streaming and the full set of time point arithmetic.</source>
          <target state="translated">&lt;code&gt;local_t&lt;/code&gt; 클래스 는 &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; 의 첫 번째 템플리트 인수로 사용되는 의사 클록으로, 아직 지정되지 않은 시간대와 관련하여 해당 시점이 현지 시간을 나타냄을 나타냅니다. &lt;code&gt;local_time&lt;/code&gt; 은 스트리밍 및 전체 시점 산술 연산을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="85fde950b1bc4e1c3294d21a994f67ff82dbbb5c" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;lock_guard&lt;/code&gt; is a mutex wrapper that provides a convenient &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII-style&lt;/a&gt; mechanism for owning a mutex for the duration of a scoped block.</source>
          <target state="translated">&lt;code&gt;lock_guard&lt;/code&gt; 클래스 는 범위가 지정된 블록 기간 동안 뮤텍스를 소유하기위한 편리한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII 스타일&lt;/a&gt; 메커니즘을 제공하는 뮤텍스 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="5e3e91707414ba3f649b0438a0caa5eecbc19288" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;month&lt;/code&gt; represents a month in a year. Its normal range is [1, 12], but it may hold any number in [0, 255]. Twelve named constants are predefined in the &lt;code&gt;std::chrono&lt;/code&gt; namespace for the twelve months of the year.</source>
          <target state="translated">수업 &lt;code&gt;month&lt;/code&gt; 은 1 년의 월을 나타냅니다. 정상 범위는 [1, 12]이지만 [0, 255]의 숫자를 보유 할 수 있습니다. 12 개의 명명 된 상수는 연중 12 개월 동안 &lt;code&gt;std::chrono&lt;/code&gt; 네임 스페이스에 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be877235dcb20278d04c1100fddd27e40cf1b12" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;month_day&lt;/code&gt; represents a specific day of a specific month, of some yet to be specified year.</source>
          <target state="translated">&lt;code&gt;month_day&lt;/code&gt; 클래스 는 특정 월의 특정 날짜를 나타내며, 일부는 아직 지정되지 않은 연도입니다.</target>
        </trans-unit>
        <trans-unit id="27d369a1177433899c27498902657b823de0b4a1" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;month_day_last&lt;/code&gt; represents the last day of a specific month, of some yet to be specified year.</source>
          <target state="translated">&lt;code&gt;month_day_last&lt;/code&gt; 클래스 는 특정 월의 마지막 날을 나타내며, 일부는 아직 지정되지 않은 연도입니다.</target>
        </trans-unit>
        <trans-unit id="a02c9e9c27d118fe7b2b716108aa5426e365f9ab" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;month_weekday&lt;/code&gt; represents the n-th weekday of a specific month, of some yet to be specified year.</source>
          <target state="translated">&lt;code&gt;month_weekday&lt;/code&gt; 클래스 는 특정 월의 n 번째 주중을 나타내며 일부는 아직 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="44105f2554e4f171648141fde22e5433de042035" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;month_weekday_last&lt;/code&gt; represents the last weekday of a specific month, of some yet to be specified year.</source>
          <target state="translated">&lt;code&gt;month_weekday_last&lt;/code&gt; 클래스 는 특정 월의 마지막 요일을 나타내며 일부는 아직 지정되지 않은 연도입니다.</target>
        </trans-unit>
        <trans-unit id="1f2c0f32bd49d3aa755a1b9b297f856980dea582" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;ostrstream&lt;/code&gt; implements output operations on array-backed streams. It essentially wraps a raw array I/O device implementation (&lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;) into the higher-level interface of &lt;code&gt;&lt;a href=&quot;basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ostrstream&lt;/code&gt; 클래스 는 배열 지원 스트림에서 출력 작업을 구현합니다. 기본적으로 원시 배열 I / O 장치 구현 ( &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 의 상위 레벨 인터페이스로 랩핑 합니다.</target>
        </trans-unit>
        <trans-unit id="769240ff129de8435a169aeae14402f048004721" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;scoped_lock&lt;/code&gt; is a mutex wrapper that provides a convenient &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII-style&lt;/a&gt; mechanism for owning one or more mutexes for the duration of a scoped block.</source>
          <target state="translated">&lt;code&gt;scoped_lock&lt;/code&gt; 클래스 는 범위가 지정된 블록 기간 동안 하나 이상의 뮤텍스를 소유하기위한 편리한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII 스타일&lt;/a&gt; 메커니즘을 제공하는 뮤텍스 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="c6811a8286c51846f2769a21dff0527daa3ee835" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;shared_lock&lt;/code&gt; is a general-purpose shared mutex ownership wrapper allowing deferred locking, timed locking and transfer of lock ownership. Locking a &lt;code&gt;shared_lock&lt;/code&gt; locks the associated shared mutex in shared mode (to lock it in exclusive mode, &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; can be used).</source>
          <target state="translated">&lt;code&gt;shared_lock&lt;/code&gt; 클래스 는 지연된 잠금, 시간 제한 잠금 및 잠금 소유권 전송을 허용하는 범용 공유 뮤텍스 소유권 래퍼입니다. &lt;code&gt;shared_lock&lt;/code&gt; 을 잠그면 공유 모드에서 연관된 공유 뮤텍스를 잠급니다 (독점 모드로 잠 그려면 &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="4a04136447f2a3087a3adb2c5a6a7425d2efc14b" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::basic_ios&lt;/code&gt; provides facilities for interfacing with objects that have &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; interface. Several &lt;code&gt;std::basic_ios&lt;/code&gt; objects can refer to one actual &lt;code&gt;std::basic_streambuf&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;std::basic_ios&lt;/code&gt; 클래스 는 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 인터페이스 가있는 객체와 인터페이스하기위한 기능을 제공합니다 . 여러 &lt;code&gt;std::basic_ios&lt;/code&gt; 객체는 하나의 실제 &lt;code&gt;std::basic_streambuf&lt;/code&gt; 객체를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97c6fc6eb4b60c014d29122cfc63ff1263ce47ce" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::codecvt_base&lt;/code&gt; provides the conversion status constants which are inherited and used by the &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facets.</source>
          <target state="translated">&lt;code&gt;std::codecvt_base&lt;/code&gt; 클래스 는 &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 패싯에 상속되고 사용되는 변환 상태 상수를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d9ae791d8d2658200164a1dd8dfceee3dc1247dc" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::condition_variable&lt;/code&gt; is a &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;. It is not &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, or &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::condition_variable&lt;/code&gt; 클래스 는 &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; 입니다. 그것은 아니다 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; , &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , 또는 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88ef9662f4f2d2a563f792987ec222a76d7e5cb8" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::condition_variable_any&lt;/code&gt; is a &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;. It is not &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, or &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::condition_variable_any&lt;/code&gt; 클래스 는 &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; 입니다. 그것은 아니다 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; , &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , 또는 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4367df265d7c6ec7ea71f793499b528dbf39047" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::ctype_base&lt;/code&gt; lists the character classification categories which are inherited by the &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facets.</source>
          <target state="translated">&lt;code&gt;std::ctype_base&lt;/code&gt; 클래스 는 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 상속되는 문자 분류 범주를 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="ba06b286ffcbc23cbd4bfc450a7db3ee5ce16c7a" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::filesystem::filesystem_error&lt;/code&gt; defines an exception object that is thrown on failure by the throwing overloads of the functions in the filesystem library.</source>
          <target state="translated">&lt;code&gt;std::filesystem::filesystem_error&lt;/code&gt; 클래스 는 파일 시스템 라이브러리에서 함수 오버로드로 인해 실패시 발생하는 예외 오브젝트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5e0154cf7a71928c2d8b4fa91dfe5c5d79f98fa8" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::future_error&lt;/code&gt; defines an exception object that is thrown on failure by the functions in the thread library that deal with asynchronous execution and shared states (&lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;, etc). Similar to &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;, this exception carries an error code compatible with &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::future_error&lt;/code&gt; 클래스 는 비동기 실행 및 공유 상태 ( &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 등) 를 처리하는 스레드 라이브러리의 함수에 의해 실패시 발생하는 예외 오브젝트를 정의합니다 . &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 와 유사 하게이 예외는 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 와 호환되는 오류 코드를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="ad146a3cfff3f9b13f932bc525af9165bd2add0a" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::ios_base::failure&lt;/code&gt; defines an exception object that is thrown on failure by the functions in the Input/Output library.</source>
          <target state="translated">&lt;code&gt;std::ios_base::failure&lt;/code&gt; 클래스 는 입 / 출력 라이브러리의 함수에 의해 실패시 발생하는 예외 객체를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0a418ed2810a4fe8c19866d4e7bae5bd608b69ce" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::lconv&lt;/code&gt; contains numeric and monetary formatting rules as defined by a C locale. Objects of this struct may be obtained with &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;std::localeconv&lt;/a&gt;&lt;/code&gt;. The members of &lt;code&gt;std::lconv&lt;/code&gt; are values of type &lt;code&gt;char&lt;/code&gt; and of type &lt;code&gt;char*&lt;/code&gt;. Each &lt;code&gt;char*&lt;/code&gt; member except &lt;code&gt;decimal_point&lt;/code&gt; may be pointing at a null character (that is, at an empty C-string). The members of type &lt;code&gt;char&lt;/code&gt; are all non-negative numbers, any of which may be &lt;code&gt;&lt;a href=&quot;../types/climits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; if the corresponding value is not available in the current C locale.</source>
          <target state="translated">&lt;code&gt;std::lconv&lt;/code&gt; 클래스 는 C 로케일로 정의 된 숫자 및 통화 형식화 규칙을 포함합니다. 이 구조체의 객체는 &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;std::localeconv&lt;/a&gt;&lt;/code&gt; 로 얻을 수 있습니다 . &lt;code&gt;std::lconv&lt;/code&gt; 의 멤버는 &lt;code&gt;char&lt;/code&gt; 유형 및 &lt;code&gt;char*&lt;/code&gt; 유형의 값입니다 . &lt;code&gt;decimal_point&lt;/code&gt; 를 제외한 각 &lt;code&gt;char*&lt;/code&gt; 멤버 는 null 문자 (즉, 빈 C- 문자열)를 가리킬 수 있습니다. &lt;code&gt;char&lt;/code&gt; 유형의 멤버 는 모두 음수가 아닌 숫자이며 , 현재 C 로케일에서 해당 값을 사용할 수없는 경우 &lt;code&gt;&lt;a href=&quot;../types/climits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0406c5e2f8f02bc0cdae46eef28c4cdd8a5777f" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::locale::id&lt;/code&gt; provides implementation-specific identification of a locale facet. Each class derived from &lt;code&gt;&lt;a href=&quot;facet&quot;&gt;std::locale::facet&lt;/a&gt;&lt;/code&gt; must have a public static member named &lt;code&gt;id&lt;/code&gt; of type &lt;code&gt;std::locale::id&lt;/code&gt; and each &lt;code&gt;&lt;a href=&quot;../locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; object maintains a list of facets it implements, indexed by their &lt;code&gt;id&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;std::locale::id&lt;/code&gt; 클래스 는 로케일 패싯의 구현 별 식별을 제공합니다. &lt;code&gt;&lt;a href=&quot;facet&quot;&gt;std::locale::facet&lt;/a&gt;&lt;/code&gt; 에서 파생 된 각 클래스 에는 &lt;code&gt;std::locale::id&lt;/code&gt; 유형의 &lt;code&gt;id&lt;/code&gt; 라는 공용 정적 멤버가 있어야 하고 각 &lt;code&gt;&lt;a href=&quot;../locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; 객체는 구현 한 패싯 목록을 유지 관리하고 &lt;code&gt;id&lt;/code&gt; 별로 색인화합니다 .</target>
        </trans-unit>
        <trans-unit id="cdf91a0e81751be421b2176d042a5260df6ec784" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::messages_base&lt;/code&gt; provides a type definition which is inherited and used by the &lt;code&gt;&lt;a href=&quot;messages&quot;&gt;std::messages&lt;/a&gt;&lt;/code&gt; facets.</source>
          <target state="translated">&lt;code&gt;std::messages_base&lt;/code&gt; 클래스 는 &lt;code&gt;&lt;a href=&quot;messages&quot;&gt;std::messages&lt;/a&gt;&lt;/code&gt; 패싯 이 상속하고 사용하는 유형 정의를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a6d1424f3444c8e56160a47686df975e8d4653aa" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::money_base&lt;/code&gt; provides constants which are inherited and used by the &lt;code&gt;&lt;a href=&quot;moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; facets.</source>
          <target state="translated">&lt;code&gt;std::money_base&lt;/code&gt; 클래스 는 &lt;code&gt;&lt;a href=&quot;moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; 패싯에서 상속하고 사용하는 상수를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8cf7e0952b844bfd5add19a1d11fb8b44f736538" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::once_flag&lt;/code&gt; is a helper structure for &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">클래스 &lt;code&gt;std::once_flag&lt;/code&gt; 위한 헬퍼 구조 &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5643e960d4858b6091b7d6543cf83a75143fd7d" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::pmr::memory_resource&lt;/code&gt; is an abstract interface to an unbounded set of classes encapsulating memory resources.</source>
          <target state="translated">클래스 &lt;code&gt;std::pmr::memory_resource&lt;/code&gt; 메모리 리소스를 캡슐화 클래스의 무제한의 세트에 추상 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="943f3d426461d3dce2b925bcd3c4394d9a659d70" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::pmr::monotonic_buffer_resource&lt;/code&gt; is a special-purpose memory resource class that releases the allocated memory only when the resource is destroyed. It is intended for very fast memory allocations in situations where memory is used to build up a few objects and then is released all at once.</source>
          <target state="translated">클래스 &lt;code&gt;std::pmr::monotonic_buffer_resource&lt;/code&gt; 릴리스 할당 된 메모리 것은 자원이 파괴에만있는 특별한 목적의 메모리 리소스 클래스입니다. 메모리를 사용하여 몇 개의 오브젝트를 빌드 한 다음 한 번에 해제하는 상황에서 매우 빠른 메모리 할당을 위해 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="33dea3b4b913a14a5256d070fe38c44fa588bc34" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::pmr::synchronized_pool_resource&lt;/code&gt; is a general-purpose memory resource class with the following properties:</source>
          <target state="translated">클래스 &lt;code&gt;std::pmr::synchronized_pool_resource&lt;/code&gt; 다음과 같은 특성을 가진 범용 메모리 리소스 클래스입니다 :</target>
        </trans-unit>
        <trans-unit id="027578ac1b5d02b14a361542f6c39eac7ac5db51" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::pmr::unsynchronized_pool_resource&lt;/code&gt; is a general-purpose memory resource class with the following properties:</source>
          <target state="translated">클래스 &lt;code&gt;std::pmr::unsynchronized_pool_resource&lt;/code&gt; 다음과 같은 특성을 가진 범용 메모리 자원 클래스는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="450a8b0e0258e20a57c1fc8d5cc34c4deaa0f733" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;std::time_base&lt;/code&gt; provides the date order constants which are inherited by the &lt;code&gt;&lt;a href=&quot;time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; facets.</source>
          <target state="translated">&lt;code&gt;std::time_base&lt;/code&gt; 클래스 는 &lt;code&gt;&lt;a href=&quot;time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; 패싯에 의해 상속되는 날짜 순서 상수를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="79d8e7749b4e29f198a0e5858155e9704c6f9c0d" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;strstream&lt;/code&gt; implements input and output operations on array-backed streams. It essentially wraps a raw array I/O device implementation (&lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;) into the higher-level interface of &lt;code&gt;&lt;a href=&quot;basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strstream&lt;/code&gt; 클래스 는 배열 지원 스트림에서 입력 및 출력 작업을 구현합니다. 기본적으로 원시 배열 I / O 장치 구현 ( &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; 의 상위 레벨 인터페이스로 랩핑 합니다.</target>
        </trans-unit>
        <trans-unit id="476561dd0cc52ac621dba8650897d75d20ccf296" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;sys_info&lt;/code&gt; describes time zone information associated with a time zone at a particular point in time (represented as either a &lt;code&gt;std::chrono::sys_time&lt;/code&gt; or a &lt;code&gt;std::chrono::local_time&lt;/code&gt;). This is a low-level data structure typically not used directly by user code.</source>
          <target state="translated">&lt;code&gt;sys_info&lt;/code&gt; 클래스 는 특정 시점의 표준 시간대와 관련된 표준 시간대 정보를 설명합니다 ( &lt;code&gt;std::chrono::sys_time&lt;/code&gt; 또는 &lt;code&gt;std::chrono::local_time&lt;/code&gt; ). 이것은 일반적으로 사용자 코드에서 직접 사용하지 않는 저수준 데이터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="f600d7fa13ee6ce89183cf7a00b0eb82822e5acf" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;thread::id&lt;/code&gt; is a lightweight, trivially copyable class that serves as a unique identifier of &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; objects.</source>
          <target state="translated">class &lt;code&gt;thread::id&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 객체 의 고유 식별자 역할을하는 가볍고 간단하게 복사 가능한 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="2a728f613fc7e5144eda285d5079bb6d95a187b5" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;thread&lt;/code&gt; represents &lt;a href=&quot;https://en.wikipedia.org/wiki/Thread_(computing)&quot;&gt;a single thread of execution&lt;/a&gt;. Threads allow multiple functions to execute concurrently.</source>
          <target state="translated">클래스 &lt;code&gt;thread&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Thread_(computing)&quot;&gt;단일 실행 &lt;/a&gt;스레드를 나타냅니다 . 스레드는 여러 함수가 동시에 실행될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="ef52a5afa98a54aad697e77e7c88eec364695c1f" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;time_zone&lt;/code&gt; represents all time zone transitions for a specific geographic area.</source>
          <target state="translated">&lt;code&gt;time_zone&lt;/code&gt; 클래스 는 특정 지역에 대한 모든 시간대 전환을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9fc764d5e8685dc9a3d7e91f0a64416a46a20991" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;type_info&lt;/code&gt; holds implementation-specific information about a type, including the name of the type and means to compare two types for equality or collating order. This is the class returned by the &lt;a href=&quot;../language/typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt; operator.</source>
          <target state="translated">&lt;code&gt;type_info&lt;/code&gt; 클래스 는 유형 이름을 포함하여 유형에 대한 구현 별 정보를 보유하며 두 유형을 동등 또는 조합 순서로 비교하는 수단을 보유합니다. 이것은 &lt;a href=&quot;../language/typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt; 연산자가 반환 한 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="abf3f8441b03d07062b86fafd99c0d60e1b784bb" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;tzdb&lt;/code&gt; represents a copy of the &lt;a href=&quot;https://www.iana.org/time-zones&quot;&gt;IANA time zone database&lt;/a&gt;. Users cannot construct a &lt;code&gt;tzdb&lt;/code&gt; and can only obtain read-only access to one via the free functions &lt;code&gt;std::chrono::get_tzdb_list&lt;/code&gt; and &lt;code&gt;std::chrono::get_tzdb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tzdb&lt;/code&gt; 클래스 는 &lt;a href=&quot;https://www.iana.org/time-zones&quot;&gt;IANA 표준 시간대 데이터베이스&lt;/a&gt; 의 복사본을 나타냅니다 . 사용자는 &lt;code&gt;tzdb&lt;/code&gt; 를 구성 할 수 없으며 자유 함수 &lt;code&gt;std::chrono::get_tzdb_list&lt;/code&gt; 및 &lt;code&gt;std::chrono::get_tzdb&lt;/code&gt; 통해서만 tzdb를 구성 할 수 없으며 읽기 전용 액세스 권한 만 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0a8116ecd0276d23a4e127fc68adb47ce5aa791" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;unique_lock&lt;/code&gt; is a general-purpose mutex ownership wrapper allowing deferred locking, time-constrained attempts at locking, recursive locking, transfer of lock ownership, and use with condition variables.</source>
          <target state="translated">&lt;code&gt;unique_lock&lt;/code&gt; 클래스 는 지연된 잠금, 시간 제한적인 잠금 시도, 재귀 적 잠금, 잠금 소유권 전송 및 조건 변수와 함께 사용할 수있는 범용 뮤텍스 소유권 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="0e2099ee784c8c8681479bd233caa16863f4c2a7" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;unique_lock&lt;/code&gt; is movable, but not copyable -- it meets the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; but not of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; or &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;unique_lock&lt;/code&gt; 클래스 는 이동 가능하지만 복사 할 수 없습니다. &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 및 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 의 요구 사항을 충족 하지만 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 또는 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 의 요구 사항은 충족 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cc857ea58c2bf22f34372b5a5a3fb53ce6834f5a" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;unique_lock&lt;/code&gt; meets the &lt;a href=&quot;../named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; requirements. If &lt;b&gt;Mutex&lt;/b&gt; meets the &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; requirements, &lt;code&gt;unique_lock&lt;/code&gt; also meets the &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; requirements (ex.: can be used in &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt;); if &lt;b&gt;Mutex&lt;/b&gt; meets the &lt;a href=&quot;../named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt; requirements, &lt;code&gt;unique_lock&lt;/code&gt; also meets the &lt;a href=&quot;../named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt; requirements.</source>
          <target state="translated">&lt;code&gt;unique_lock&lt;/code&gt; 클래스 는 &lt;a href=&quot;../named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; 요구 사항을 충족합니다 . 경우 &lt;b&gt;뮤텍스는&lt;/b&gt; 충족 &lt;a href=&quot;../named_req/lockable&quot;&gt;잠금&lt;/a&gt; 요구 사항을 &lt;code&gt;unique_lock&lt;/code&gt; 는 또한 충족 &lt;a href=&quot;../named_req/lockable&quot;&gt;잠금&lt;/a&gt; (예는 :에서 사용할 수있는 요구 사항을 &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt; ); 경우 &lt;b&gt;뮤텍스는&lt;/b&gt; 충족 &lt;a href=&quot;../named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt; 요구 사항을 &lt;code&gt;unique_lock&lt;/code&gt; 는 또한 충족 &lt;a href=&quot;../named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt; 요구 사항을.</target>
        </trans-unit>
        <trans-unit id="032091a049e7d6f3c4a2dbc349c7148ff098a4d1" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;weekday&lt;/code&gt; represent a day of the week in the Gregorian calendar. Its normal range is [0, 6], for Sunday through Saturday, but it can hold any value in the range [0, 255]. Seven named constants are predefined in the &lt;code&gt;std::chrono&lt;/code&gt; namespace for the seven days of the week.</source>
          <target state="translated">&lt;code&gt;weekday&lt;/code&gt; 수업 은 그레고리력으로 요일을 나타냅니다. 일반적인 범위는 일요일부터 토요일까지 [0, 6]이지만 [0, 255] 범위의 모든 값을 보유 할 수 있습니다. &lt;code&gt;std::chrono&lt;/code&gt; 네임 스페이스 에는 7 개의 명명 된 상수가 7 일 동안 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="56265c3dc95ef84c57c1c665e4e92d0394b639f7" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;weekday_indexed&lt;/code&gt; combines a &lt;a href=&quot;weekday&quot;&gt;&lt;code&gt;weekday&lt;/code&gt;&lt;/a&gt;, representing a day of the week in the Gregorian calendar, with a small index</source>
          <target state="translated">이 클래스는 &lt;code&gt;weekday_indexed&lt;/code&gt; 콤바인에게 &lt;a href=&quot;weekday&quot;&gt; &lt;code&gt;weekday&lt;/code&gt; &lt;/a&gt; 작은 인덱스, 태양력에서 요일을 나타내는,</target>
        </trans-unit>
        <trans-unit id="8e2bcc4575bcf6a86b21ec2403cfb210002249df" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;weekday_last&lt;/code&gt; represents the last weekday of some month.</source>
          <target state="translated">&lt;code&gt;weekday_last&lt;/code&gt; 클래스 는 몇 달의 마지막 요일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b53e49ba5644235f4f447898a7a3e502042d68b4" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;year&lt;/code&gt; represents a year in the &lt;a href=&quot;https://en.wikipedia.org/wiki/proleptic_Gregorian_calendar&quot;&gt;proleptic Gregorian calendar&lt;/a&gt;. Its range is [-32767, 32767].</source>
          <target state="translated">학급 &lt;code&gt;year&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/proleptic_Gregorian_calendar&quot;&gt;그레고리력 달력&lt;/a&gt; 에서 1 년을 나타냅니다 . 범위는 [-32767, 32767]입니다.</target>
        </trans-unit>
        <trans-unit id="fea87e23deabaacc9943a26e2ca0a144201292df" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;year_month&lt;/code&gt; represents a specific month of a specific year, but with an unspecified day. It is a field-based time point, with a resolution of &lt;code&gt;std::chrono::months&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;year_month&lt;/code&gt; 클래스 는 특정 연도의 특정 월을 나타내지 만 지정된 날짜는 없습니다. &lt;code&gt;std::chrono::months&lt;/code&gt; 의 해상도를 가진 필드 기반의 시점 입니다.</target>
        </trans-unit>
        <trans-unit id="72fdd2f49c8ec1c2127c97fefc1c830ce24e4a83" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;year_month_day&lt;/code&gt; represents a specific year, month, and day. It is a field-based time point, with a resolution of &lt;code&gt;std::chrono::days&lt;/code&gt;. &lt;code&gt;std::chrono::years&lt;/code&gt;- and &lt;code&gt;std::chrono::months&lt;/code&gt;-oriented arithmetic are supported directly. An implicit conversion to and from &lt;code&gt;std::chrono::sys_days&lt;/code&gt; allows &lt;code&gt;std::chrono::days&lt;/code&gt;-oriented arithmetic to be performed efficiently.</source>
          <target state="translated">&lt;code&gt;year_month_day&lt;/code&gt; 클래스 는 특정 연도, 월 및 일을 나타냅니다. &lt;code&gt;std::chrono::days&lt;/code&gt; 의 해상도로 필드 기반의 시점 입니다. &lt;code&gt;std::chrono::years&lt;/code&gt; 및 &lt;code&gt;std::chrono::months&lt;/code&gt; 지향 산술이 직접 지원됩니다. &lt;code&gt;std::chrono::sys_days&lt;/code&gt; 부터) 암시 적으로 변환 하면 &lt;code&gt;std::chrono::days&lt;/code&gt; 지향 산술을 효율적으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5375b9000c2f6d65598dc8525258ea0b2b967f7b" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;year_month_day_last&lt;/code&gt; represents the last day of a specific year and month. It is a field-based time point, with a resolution of &lt;code&gt;std::chrono::days&lt;/code&gt;, subject to the limit that it can only represent the last day of a month.</source>
          <target state="translated">&lt;code&gt;year_month_day_last&lt;/code&gt; 클래스 는 특정 연도 및 월의 마지막 날을 나타냅니다. &lt;code&gt;std::chrono::days&lt;/code&gt; 의 해상도를 가진 필드 기반의 시점으로, 한 달의 마지막 날만 나타낼 수있는 한계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e1c7f2658d8bf0200e0114c2b5f71f556a17286" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;year_month_weekday&lt;/code&gt; represents the n-th weekday of a specific year and month. It is a field-based time point, with a resolution of &lt;code&gt;std::chrono::days&lt;/code&gt;. &lt;code&gt;std::chrono::years&lt;/code&gt;- and &lt;code&gt;std::chrono::months&lt;/code&gt;-oriented arithmetic are supported directly. An implicit conversion to and from &lt;code&gt;std::chrono::sys_days&lt;/code&gt; allows &lt;code&gt;std::chrono::days&lt;/code&gt;-oriented arithmetic to be performed efficiently.</source>
          <target state="translated">&lt;code&gt;year_month_weekday&lt;/code&gt; 클래스 는 특정 연도 및 월의 n 번째 요일을 나타냅니다. &lt;code&gt;std::chrono::days&lt;/code&gt; 의 해상도로 필드 기반의 시점 입니다. &lt;code&gt;std::chrono::years&lt;/code&gt; 및 &lt;code&gt;std::chrono::months&lt;/code&gt; 지향 산술이 직접 지원됩니다. &lt;code&gt;std::chrono::sys_days&lt;/code&gt; 부터) 암시 적으로 변환 하면 &lt;code&gt;std::chrono::days&lt;/code&gt; 지향 산술을 효율적으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cbf6f6b92958e9c9f7ec51c3bde2113037a04ef" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;year_month_weekday_last&lt;/code&gt; represents the last weekday of a specific year and month. It is a field-based time point, with a resolution of &lt;code&gt;std::chrono::days&lt;/code&gt;, except that it is limited to pointing to the last weekday of a year and month. &lt;code&gt;std::chrono::years&lt;/code&gt;- and &lt;code&gt;std::chrono::months&lt;/code&gt;-oriented arithmetic are supported directly. An implicit conversion to &lt;code&gt;std::chrono::sys_days&lt;/code&gt; allows &lt;code&gt;std::chrono::days&lt;/code&gt;-oriented arithmetic to be performed efficiently.</source>
          <target state="translated">&lt;code&gt;year_month_weekday_last&lt;/code&gt; 클래스 는 특정 연도 및 월의 마지막 요일을 나타냅니다. &lt;code&gt;std::chrono::days&lt;/code&gt; 의 해상도를 가진 필드 기반의 시점으로, 연도 및 월의 마지막 주중을 가리키는 것으로 제한됩니다. &lt;code&gt;std::chrono::years&lt;/code&gt; 및 &lt;code&gt;std::chrono::months&lt;/code&gt; 지향 산술이 직접 지원됩니다. &lt;code&gt;std::chrono::sys_days&lt;/code&gt; 암시 적으로 변환 하면 &lt;code&gt;std::chrono::days&lt;/code&gt; 지향 산술을 효율적으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b726267cecb9466b6b380f41a9832d612ade7092" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;zoned_time&lt;/code&gt; represents a logical pairing of a time zone and a &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; whose resolution is &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;zoned_time&lt;/code&gt; 클래스 는 &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; 시간대의 논리적 쌍과 해상도가 &lt;code&gt;Duration&lt;/code&gt; 인 std :: chrono :: time_point 를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f0cab7e0f7bb1c93af1cb9a4666997517ff2fba1" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;zoned_traits&lt;/code&gt; provides a way to customize the behavior of the constructors of &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; with custom time zone pointer types. In particular, it allows such types to specify the default time zone to use and the mapping of a time zone's name to the corresponding time zone pointer. It is acceptable for custom time zone pointer types to not support either operation, in which case the corresponding constructors of &lt;code&gt;zoned_time&lt;/code&gt; will not participate in overload resolution.</source>
          <target state="translated">&lt;code&gt;zoned_traits&lt;/code&gt; 클래스 는 &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; 시간대 포인터 유형을 사용하여 std :: chrono :: zoned_time 생성자의 동작을 사용자 정의하는 방법을 제공합니다 . 특히, 이러한 유형은 사용할 기본 시간대 및 시간대 이름을 해당 시간대 포인터에 맵핑하도록 지정할 수 있습니다. 사용자 지정 표준 시간대 포인터 유형이 두 작업 중 하나를 지원하지 않는 것이 허용됩니다.이 경우 &lt;code&gt;zoned_time&lt;/code&gt; 의 해당 생성자는 과부하 해결에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fce24bd397b3fc59d265ef9283b0603741ea9e6" translate="yes" xml:space="preserve">
          <source>The class defines the following types:</source>
          <target state="translated">이 클래스는 다음 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c1d42e272c367b02bb7a725757feee6591362aaf" translate="yes" xml:space="preserve">
          <source>The class in the return type of &lt;code&gt;Derived::f&lt;/code&gt; must be either &lt;code&gt;Derived&lt;/code&gt; itself, or must be a &lt;a href=&quot;incomplete_type&quot;&gt;complete type&lt;/a&gt; at the point of declaration of &lt;code&gt;Derived::f&lt;/code&gt;.</source>
          <target state="translated">의 반환 형식의 클래스 &lt;code&gt;Derived::f&lt;/code&gt; 하나해야 &lt;code&gt;Derived&lt;/code&gt; 자체, 또는해야 &lt;a href=&quot;incomplete_type&quot;&gt;완전한 형태&lt;/a&gt; 의 선언의 시점에서 &lt;code&gt;Derived::f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23aa8c737cd141728071f9055d6ef22275b56310" translate="yes" xml:space="preserve">
          <source>The class keys &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; are indistinguishable in C++, except that the default &lt;a href=&quot;access&quot;&gt;access mode&lt;/a&gt; and default &lt;a href=&quot;derived_class&quot;&gt;inheritance mode&lt;/a&gt; are &lt;code&gt;public&lt;/code&gt; if class declaration uses the &lt;code&gt;struct&lt;/code&gt; class-key and &lt;code&gt;private&lt;/code&gt; if the class declaration uses the &lt;code&gt;class&lt;/code&gt; class-key. Both &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt; can be used in a &lt;a href=&quot;class&quot;&gt;class definition&lt;/a&gt;.</source>
          <target state="translated">클래스 키 &lt;code&gt;struct&lt;/code&gt; 와 &lt;code&gt;class&lt;/code&gt; 는 C ++에서 구분할 수 없습니다. 단, 클래스 선언이 &lt;code&gt;struct&lt;/code&gt; 클래스 키를 사용하는 경우 기본 &lt;a href=&quot;access&quot;&gt;액세스 모드&lt;/a&gt; 와 기본 &lt;a href=&quot;derived_class&quot;&gt;상속 모드&lt;/a&gt; 는 &lt;code&gt;public&lt;/code&gt; 이고 클래스 선언 이 &lt;code&gt;class&lt;/code&gt; 클래스 키를 사용하는 경우 &lt;code&gt;private&lt;/code&gt; 키입니다. &lt;code&gt;class&lt;/code&gt; 와 &lt;code&gt;struct&lt;/code&gt; 는 모두 클래스 &lt;a href=&quot;class&quot;&gt;정의&lt;/a&gt; 에서 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1586b1dc4e3f7b882ff5d87af7c14b4d7906a5ea" translate="yes" xml:space="preserve">
          <source>The class satisfies the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, but not the requirements of either &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; or &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 및 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 의 요구 사항을 충족 하지만 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 또는 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 의 요구 사항은 충족하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="976424624ce0eeeaf2ff5fa550e55aefe6c4b670" translate="yes" xml:space="preserve">
          <source>The class specifier for a union declaration is similar to &lt;a href=&quot;class&quot;&gt;class or struct&lt;/a&gt; declaration:</source>
          <target state="translated">공용체 선언의 클래스 지정자는 &lt;a href=&quot;class&quot;&gt;클래스 또는 구조체&lt;/a&gt; 선언 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="355599287a2d30891deccc040199bf8dd47ddb92" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;basic_common_reference&lt;/code&gt; is a customization point that allows users to influence the result of &lt;code&gt;common_reference&lt;/code&gt; for user-defined types (typically proxy references). The primary template is empty.</source>
          <target state="translated">클래스 템플리트 &lt;code&gt;basic_common_reference&lt;/code&gt; 는 사용자 정의 유형 (일반적으로 프록시 참조)에 대한 &lt;code&gt;common_reference&lt;/code&gt; 의 결과에 영향을 줄 수있는 사용자 정의 지점입니다 . 기본 템플릿이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dc44e02a34b25badf679ff2fa5512678041ec5e" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;basic_fstream&lt;/code&gt; implements high-level input/output operations on file based streams. It interfaces a file-based streambuffer (&lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;) with the high-level interface of (&lt;code&gt;&lt;a href=&quot;basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;basic_fstream&lt;/code&gt; 클래스 템플릿 은 파일 기반 스트림에서 고급 입력 / 출력 작업을 구현합니다. 파일 기반 &lt;code&gt;&lt;a href=&quot;basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; )를 ( std :: basic_iostream ) 의 고급 인터페이스와 인터페이스 합니다.</target>
        </trans-unit>
        <trans-unit id="038c0fe0b240f396bce88928ba29e4ed89f41c35" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;basic_ifstream&lt;/code&gt; implements high-level input operations on file based streams. It interfaces a file-based streambuffer (&lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;) with the high-level interface of (&lt;code&gt;&lt;a href=&quot;basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;basic_ifstream&lt;/code&gt; 클래스 템플릿 은 파일 기반 스트림에서 고급 입력 작업을 구현합니다. 파일 기반 스트림 버퍼 ( &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; )를 ( &lt;code&gt;&lt;a href=&quot;basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; ) 의 고급 인터페이스와 인터페이스 합니다.</target>
        </trans-unit>
        <trans-unit id="f70957a917c7c6e79e4b69f46be0693edc917904" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;basic_iostream&lt;/code&gt; provides support for high level input/output operations on streams. The supported operations include sequential reading or writing and formatting. This functionality is implemented over the interface provided by the &lt;code&gt;basic_streambuf&lt;/code&gt; class. It is accessed through &lt;code&gt;basic_ios&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;basic_iostream&lt;/code&gt; 클래스 템플릿 은 스트림에서 높은 수준의 입출력 작업을 지원합니다. 지원되는 작업에는 순차적 읽기 또는 쓰기 및 서식이 포함됩니다. 이 기능은 &lt;code&gt;basic_streambuf&lt;/code&gt; 클래스가 제공하는 인터페이스를 통해 구현됩니다 . &lt;code&gt;basic_ios&lt;/code&gt; 클래스를 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="6f48eb60dadf7531f652d15977856f83c57372f1" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;basic_istream&lt;/code&gt; provides support for high level input operations on character streams. The supported operations include formatted input (e.g. integer values or whitespace-separated characters and characters strings) and unformatted input (e.g. raw characters and character arrays). This functionality is implemented in terms of the interface provided by the underlying &lt;code&gt;basic_streambuf&lt;/code&gt; class, accessed through the &lt;code&gt;basic_ios&lt;/code&gt; base class. The only non-inherited data member of &lt;code&gt;basic_istream&lt;/code&gt;, in most implementations, is the value returned by &lt;a href=&quot;basic_istream/gcount&quot;&gt;&lt;code&gt;basic_istream::gcount()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;basic_istream&lt;/code&gt; 클래스 템플릿 은 문자 스트림에서 높은 수준의 입력 작업을 지원합니다. 지원되는 작업에는 형식화 된 입력 (예 : 정수 값 또는 공백으로 구분 된 문자 및 문자열) 및 형식화되지 않은 입력 (예 : 원시 문자 및 문자 배열)이 포함됩니다. 이 기능은 &lt;code&gt;basic_ios&lt;/code&gt; 기본 클래스를 통해 액세스 되는 기본 &lt;code&gt;basic_streambuf&lt;/code&gt; 클래스가 제공하는 인터페이스 측면에서 구현됩니다 . 대부분의 구현에서 &lt;code&gt;basic_istream&lt;/code&gt; 의 상속되지 않은 유일한 데이터 멤버는 &lt;a href=&quot;basic_istream/gcount&quot;&gt; &lt;code&gt;basic_istream::gcount()&lt;/code&gt; &lt;/a&gt; 의해 반환되는 값 입니다.</target>
        </trans-unit>
        <trans-unit id="91ba0965e9c562f3a8c3efae66ebf65ef188a7a8" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;basic_ofstream&lt;/code&gt; implements high-level output operations on file based streams. It interfaces a file-based streambuffer (&lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;) with the high-level interface of (&lt;code&gt;&lt;a href=&quot;basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;basic_ofstream&lt;/code&gt; 클래스 템플릿 은 파일 기반 스트림에서 고급 출력 작업을 구현합니다. 파일 기반 &lt;code&gt;&lt;a href=&quot;basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; )를 ( std :: basic_ostream ) 의 고급 인터페이스와 인터페이스 합니다.</target>
        </trans-unit>
        <trans-unit id="058993ab90ece7b9a84ecbfb0f86f82f2260e21f" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;basic_ostream&lt;/code&gt; provides support for high level output operations on character streams. The supported operations include formatted output (e.g. integer values) and unformatted output (e.g. raw characters and character arrays). This functionality is implemented in terms of the interface provided by the &lt;code&gt;basic_streambuf&lt;/code&gt; class, accessed through the &lt;code&gt;basic_ios&lt;/code&gt; base class. In typical implementations, &lt;code&gt;basic_ostream&lt;/code&gt; has no non-inherited data members.</source>
          <target state="translated">&lt;code&gt;basic_ostream&lt;/code&gt; 클래스 템플릿 은 문자 스트림에서 높은 수준의 출력 작업을 지원합니다. 지원되는 작업에는 형식화 된 출력 (예 : 정수 값) 및 형식화되지 않은 출력 (예 : 원시 문자 및 문자 배열)이 포함됩니다. 이 기능은 &lt;code&gt;basic_ios&lt;/code&gt; 기본 클래스를 통해 액세스 되는 &lt;code&gt;basic_streambuf&lt;/code&gt; 클래스가 제공하는 인터페이스 측면에서 구현됩니다 . 일반적인 구현에서 &lt;code&gt;basic_ostream&lt;/code&gt; 에는 상속되지 않은 데이터 멤버가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e7e639aa5c9b05b5996b19220f4281108f4b3af" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;basic_regex&lt;/code&gt; provides a general framework for holding regular expressions.</source>
          <target state="translated">&lt;code&gt;basic_regex&lt;/code&gt; 클래스 템플리트 는 정규식을 보유하기위한 일반 프레임 워크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b81da74022682d007286a821128a6af2b9668a8d" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;basic_string&lt;/code&gt; stores and manipulates sequences of &lt;a href=&quot;../language/types#Character_types&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;-like objects, which are non-array objects of &lt;a href=&quot;../named_req/trivialtype&quot;&gt;trivial&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;standard-layout&lt;/a&gt; type. The class is dependent neither on the character type nor on the nature of operations on that type. The definitions of the operations are supplied via the &lt;code&gt;Traits&lt;/code&gt; template parameter - a specialization of &lt;code&gt;&lt;a href=&quot;char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; or a compatible traits class. &lt;code&gt;Traits::char_type&lt;/code&gt; and &lt;code&gt;CharT&lt;/code&gt; must name the same type; otherwise the program is ill-formed.</source>
          <target state="translated">&lt;code&gt;basic_string&lt;/code&gt; 클래스 템플리트 는 &lt;a href=&quot;../named_req/trivialtype&quot;&gt;간단한 &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;표준 레이아웃&lt;/a&gt; 유형 의 배열이 아닌 오브젝트 인 &lt;a href=&quot;../language/types#Character_types&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 유사 오브젝트의 시퀀스를 저장하고 조작 합니다. 클래스는 문자 유형이나 해당 유형의 작업 특성에 의존하지 않습니다. 오퍼레이션의 정의는 &lt;code&gt;Traits&lt;/code&gt; 템플리트 매개 변수 &lt;code&gt;&lt;a href=&quot;char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; 또는 호환되는 특성 클래스 의 전문화를 통해 제공됩니다 . &lt;code&gt;Traits::char_type&lt;/code&gt; 및 &lt;code&gt;CharT&lt;/code&gt; 는 동일한 유형의 이름을 지정해야합니다. 그렇지 않으면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3529e9d1493b34a499972b62e42372d741fea4ca" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;basic_string_view&lt;/code&gt; describes an object that can refer to a constant contiguous sequence of &lt;code&gt;char&lt;/code&gt;-like objects with the first element of the sequence at position zero.</source>
          <target state="translated">&lt;code&gt;basic_string_view&lt;/code&gt; 클래스 템플릿 은 위치 0에있는 시퀀스의 첫 번째 요소가있는 연속적인 &lt;code&gt;char&lt;/code&gt; - like 객체 시퀀스를 참조 할 수있는 객체를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="7507c73a003171ab458d8f695b3576c9147c0031" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;bitset&lt;/code&gt; represents a fixed-size sequence of &lt;code&gt;N&lt;/code&gt; bits. Bitsets can be manipulated by standard logic operators and converted to and from strings and integers.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;bitset&lt;/code&gt; 고정 된 크기의 시퀀스 나타내는 &lt;code&gt;N&lt;/code&gt; 의 비트. 비트 세트는 표준 논리 연산자로 조작 할 수 있으며 문자열 및 정수와 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d6cbadd3e49e177a9f79321e48eb0992ca418a2" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;span&lt;/code&gt; describes an object that can refer to a contiguous sequence of objects with the first element of the sequence at position zero. A &lt;code&gt;span&lt;/code&gt; can either have a</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;span&lt;/code&gt; 는 위치 0에서 시퀀스의 첫 번째 요소가있는 연속 된 객체 시퀀스를 참조 할 수있는 객체를 설명합니다. &lt;code&gt;span&lt;/code&gt; 중 하나를 가질 수 있습니다</target>
        </trans-unit>
        <trans-unit id="23d03690a372ed970025d8a63d898a73cc806a78" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::basic_istringstream&lt;/code&gt; implements input operations on memory (&lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;) based streams. It essentially wraps a raw string device implementation (&lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;) into a higher-level interface (&lt;code&gt;&lt;a href=&quot;basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;). The complete interface to unique &lt;code&gt;std::basic_stringbuf&lt;/code&gt; members is provided.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::basic_istringstream&lt;/code&gt; 은 메모리 ( &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; ) 기반 스트림 에서 입력 작업을 구현 합니다. 기본적으로 원시 문자열 장치 구현 ( &lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; )을 상위 레벨 인터페이스 ( &lt;code&gt;&lt;a href=&quot;basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; )로 랩핑합니다 . 고유 한 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 멤버에 대한 완전한 인터페이스 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="caadefd6d3470a314eb57d7f6f435dad008491e3" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::basic_ostringstream&lt;/code&gt; implements output operations on memory (&lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;) based streams. It essentially wraps a raw string device implementation (&lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;) into a higher-level interface (&lt;code&gt;&lt;a href=&quot;basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;). The complete interface to unique &lt;code&gt;std::basic_stringbuf&lt;/code&gt; members is provided.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::basic_ostringstream&lt;/code&gt; 은 메모리 ( &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; ) 기반 스트림 에서 출력 작업을 구현 합니다. 기본적으로 원시 문자열 장치 구현 ( &lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; )을 상위 레벨 인터페이스 ( &lt;code&gt;&lt;a href=&quot;basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; )로 랩핑 합니다. 고유 한 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 멤버에 대한 완전한 인터페이스 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ac98e5b30fb10492d8969c7963b1fe1e68e40896" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::basic_osyncstream&lt;/code&gt; is a convenience wrapper for &lt;a href=&quot;basic_syncbuf&quot;&gt;&lt;code&gt;std::basic_syncbuf&lt;/code&gt;&lt;/a&gt;. It provides a mechanism to synchronize threads writing to the same stream.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::basic_osyncstream&lt;/code&gt; 의 편의를 래퍼입니다 &lt;a href=&quot;basic_syncbuf&quot;&gt; &lt;code&gt;std::basic_syncbuf&lt;/code&gt; &lt;/a&gt; . 스레드를 동일한 스트림에 쓰는 동기화하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bee08bb9ce8d30333290b0627f454f47f97b513c" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::basic_stringstream&lt;/code&gt; implements input/output operations on memory (&lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;) based streams. It essentially wraps a raw string device implementation (&lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;) into a higher-level interface (&lt;code&gt;&lt;a href=&quot;basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt;). The complete interface to unique &lt;code&gt;std::basic_stringbuf&lt;/code&gt; members is provided.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::basic_stringstream&lt;/code&gt; 은 메모리 ( &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; ) 기반 스트림 에서 입출력 작업을 구현 합니다. 기본적으로 원시 문자열 장치 구현 ( &lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; )을 상위 레벨 인터페이스 ( &lt;code&gt;&lt;a href=&quot;basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; )로 랩핑 합니다. 고유 한 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 멤버에 대한 완전한 인터페이스 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="aaa9f8a35a71bdecd961c1c3379e795b83b36290" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::common_comparison_category&lt;/code&gt; provides an alias (as the member typedef &lt;code&gt;type&lt;/code&gt;) for the strongest comparison category to which all of the template arguments &lt;code&gt;Ts...&lt;/code&gt; can be converted.</source>
          <target state="translated">클래스 템플리트 &lt;code&gt;std::common_comparison_category&lt;/code&gt; 는 모든 템플리트 인수 &lt;code&gt;Ts...&lt;/code&gt; 를 변환 할 수있는 가장 강력한 비교 카테고리에 대한 별명 (멤버 typedef &lt;code&gt;type&lt;/code&gt; )을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f74e8175eba48e378e9ab6cf198ec8d71e58b039" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::future&lt;/code&gt; provides a mechanism to access the result of asynchronous operations:</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::future&lt;/code&gt; 는 비동기 작업의 결과에 액세스하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b7a4e20b605046d0489bd9d4193b2c75bc21bd0c" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::integer_sequence&lt;/code&gt; represents a compile-time sequence of integers. When used as an argument to a &lt;a href=&quot;../language/function_template&quot;&gt;function template&lt;/a&gt;, the &lt;a href=&quot;../language/parameter_pack&quot;&gt;parameter pack&lt;/a&gt;&lt;code&gt;Ints&lt;/code&gt; can be deduced and used in pack expansion.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::integer_sequence&lt;/code&gt; 는 컴파일 타임의 정수 시퀀스를 나타냅니다. A와 인수로 사용하는 경우 &lt;a href=&quot;../language/function_template&quot;&gt;함수 템플릿&lt;/a&gt; 의 &lt;a href=&quot;../language/parameter_pack&quot;&gt;매개 변수 팩 &lt;/a&gt; &lt;code&gt;Ints&lt;/code&gt; 추론 및 팩 확장에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="639e2365e83d6e0a1ce1cee5cea25487d0336a45" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::match_results&lt;/code&gt; holds a collection of character sequences that represent the result of a regular expression match.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::match_results&lt;/code&gt; 에는 정규식 일치 결과를 나타내는 문자 시퀀스 모음이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cd218e9c79d048cdc2f4bfc83a128d5a613b938" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::optional&lt;/code&gt; manages an</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::optional&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="7b795144302fc0eec8c45d022d69b16abf2a0f04" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::packaged_task&lt;/code&gt; wraps any &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; target (function, lambda expression, bind expression, or another function object) so that it can be invoked asynchronously. Its return value or exception thrown is stored in a shared state which can be accessed through &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; objects.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::packaged_task&lt;/code&gt; 는 &lt;a href=&quot;../named_req/callable&quot;&gt;호출 가능한&lt;/a&gt; 대상 (함수, 람다 식, 바인드 식 또는 다른 함수 개체)을 래핑하여 비동기식으로 호출 할 수 있도록합니다. 리턴 값 또는 예외는 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 오브젝트를 통해 액세스 할 수있는 공유 상태로 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="d1f55e890f3d93b7c69638340290c189f4316224" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::pmr::polymorphic_allocator&lt;/code&gt; is an &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; whose allocation behavior depends on the memory resource it is constructed with. Thus, different instances of &lt;code&gt;polymorphic_allocator&lt;/code&gt; can exhibit entirely different allocation behavior. This runtime polymorphism allows objects using &lt;code&gt;polymorphic_allocator&lt;/code&gt; to behave as if they used different allocator types at run time despite the identical static allocator type.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::pmr::polymorphic_allocator&lt;/code&gt; 입니다 &lt;a href=&quot;../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; 그 할당 행동이 함께 구성되어 메모리 리소스에 따라 달라집니다. 따라서 &lt;code&gt;polymorphic_allocator&lt;/code&gt; 의 다른 인스턴스 는 완전히 다른 할당 동작을 나타낼 수 있습니다. 이 런타임 다형성을 사용하여 개체 수 &lt;code&gt;polymorphic_allocator&lt;/code&gt; 은 그들이 동일한 정적 할당 유형에도 불구하고 런타임에 서로 다른 할당 유형을 사용하는 것처럼 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64a4aa64274c3e4ddf9c6f8ea707cabe8df1697d" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::promise&lt;/code&gt; provides a facility to store a value or an exception that is later acquired asynchronously via a &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; object created by the &lt;code&gt;std::promise&lt;/code&gt; object. Note that the &lt;code&gt;std::promise&lt;/code&gt; object is meant to be used only once.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::promise&lt;/code&gt; 는 나중에 &lt;code&gt;std::promise&lt;/code&gt; 객체에 의해 생성 된 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 객체 를 통해 비동기 적으로 획득되는 값 또는 예외를 저장하는 기능을 제공 합니다. 있습니다 &lt;code&gt;std::promise&lt;/code&gt; 객체가 한 번만 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="048062dc3b140831e39899a4170ae57a0e64b713" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::ratio&lt;/code&gt; and associated templates provide compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::ratio&lt;/code&gt; 및 관련 템플릿은 컴파일 타임 합리적인 산술 지원을 제공합니다. 이 템플릿의 각 인스턴스화는 유한 합리적인 수를 정확하게 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b714fec242cc94f139481788fee6d47f6bf712bd" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::ratio&lt;/code&gt; provides &lt;a href=&quot;../ratio&quot;&gt;compile-time rational arithmetic&lt;/a&gt; support. Each instantiation of this template exactly represents any finite rational number as long as its numerator &lt;code&gt;Num&lt;/code&gt; and denominator &lt;code&gt;Denom&lt;/code&gt; are representable as compile-time constants of type &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;. In addition, &lt;code&gt;Denom&lt;/code&gt; may not be zero and may not be equal to the most negative value.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::ratio&lt;/code&gt; 는 &lt;a href=&quot;../ratio&quot;&gt;컴파일 타임 합리적인 산술&lt;/a&gt; 지원을 제공합니다. 이 템플릿의 각 인스턴스화는 분자 &lt;code&gt;Num&lt;/code&gt; 및 분모 &lt;code&gt;Denom&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 유형의 컴파일 타임 상수로 표시 될 수있는 한 유한 합리적인 수를 정확하게 나타냅니다 . 또한 &lt;code&gt;Denom&lt;/code&gt; 은 0이 아니고 가장 음의 값과 같지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c48d82d4f5c30984ee05d53392aeeb13cd9e2bc" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::shared_future&lt;/code&gt; provides a mechanism to access the result of asynchronous operations, similar to &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, except that multiple threads are allowed to wait for the same shared state. Unlike &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, which is only moveable (so only one instance can refer to any particular asynchronous result), &lt;code&gt;std::shared_future&lt;/code&gt; is copyable and multiple shared future objects may refer to the same shared state.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::shared_future&lt;/code&gt; 는 여러 스레드가 동일한 공유 상태를 기다릴 수 있다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 와 유사한 비동기 작업의 결과에 액세스하는 메커니즘을 제공합니다 . 움직일 수있는 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 와 달리 (따라서 하나의 인스턴스 만 특정 비동기 결과를 참조 할 수 있음) &lt;code&gt;std::shared_future&lt;/code&gt; 는 복사 가능하며 여러 개의 공유 된 미래 객체는 동일한 공유 상태를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1750b83514f87a70ecb7f6d559c2d4086197e2c5" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;std::variant&lt;/code&gt; represents a type-safe &lt;a href=&quot;../language/union&quot;&gt;union&lt;/a&gt;. An instance of &lt;code&gt;std::variant&lt;/code&gt; at any given time either holds a value of one of its alternative types, or in the case of error - no value (this state is hard to achieve, see &lt;a href=&quot;variant/valueless_by_exception&quot;&gt;&lt;code&gt;valueless_by_exception&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::variant&lt;/code&gt; 는 형식 안전 &lt;a href=&quot;../language/union&quot;&gt;공용체를&lt;/a&gt; 나타냅니다 . 주어진 시간 에 &lt;code&gt;std::variant&lt;/code&gt; 의 인스턴스는 대체 유형 중 하나의 값을 보유하거나 오류가없는 경우 값이 없습니다 (이 상태는 달성하기 어렵습니다 . &lt;a href=&quot;variant/valueless_by_exception&quot;&gt; &lt;code&gt;valueless_by_exception&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="df780d19352ca77a9e81e07d0081e62704dfbeba" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;sub_match&lt;/code&gt; is used by the regular expression engine to denote sequences of characters matched by marked sub-expressions. A match is a &lt;code&gt;[begin, end)&lt;/code&gt; pair within the target range matched by the regular expression, but with additional observer functions to enhance code clarity.</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;sub_match&lt;/code&gt; 는 정규 표현식 엔진에서 표시된 하위 표현식과 일치하는 문자 시퀀스를 표시하는 데 사용됩니다. 일치는 정규 표현식과 일치하는 대상 범위 내의 &lt;code&gt;[begin, end)&lt;/code&gt; 쌍이지만 코드 선명도를 향상시키기 위해 추가 관찰자 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac9704077992d9fc373489a50f4bbca360b3bf54" translate="yes" xml:space="preserve">
          <source>The class template &lt;code&gt;time_of_day&lt;/code&gt; splits a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; representing time since midnight into a &quot;broken down&quot; time such as</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;time_of_day&lt;/code&gt; 분할하는 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 과 같은 &quot;분류&quot;시간으로 자정 이후의 시간을 나타내는</target>
        </trans-unit>
        <trans-unit id="3eb1fefb52f9b56042037b5cf5dfd0d4fbe27478" translate="yes" xml:space="preserve">
          <source>The class template acts as a wrapper to the underlying container - only a specific set of functions is provided. The queue pushes the elements on the back of the underlying container and pops them from the front.</source>
          <target state="translated">클래스 템플릿은 기본 컨테이너의 래퍼 역할을하며 특정 함수 집합 만 제공됩니다. 대기열은 기본 컨테이너의 뒷면에있는 요소를 밀어서 앞에서 튀어 나옵니다.</target>
        </trans-unit>
        <trans-unit id="66376115affc65d77a1dba188bf784079f132234" translate="yes" xml:space="preserve">
          <source>The class template acts as a wrapper to the underlying container - only a specific set of functions is provided. The stack pushes and pops the element from the back of the underlying container, known as the top of the stack.</source>
          <target state="translated">클래스 템플릿은 기본 컨테이너의 래퍼 역할을하며 특정 함수 집합 만 제공됩니다. 스택은 스택의 상단으로 알려진 기본 컨테이너의 후면에서 요소를 밀어 넣습니다.</target>
        </trans-unit>
        <trans-unit id="913d33504f86e60b7d594711e133632d799e9139" translate="yes" xml:space="preserve">
          <source>The class type &lt;code&gt;std::partial_ordering&lt;/code&gt; is the result type of a &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;three-way comparison&lt;/a&gt; that.</source>
          <target state="translated">&lt;code&gt;std::partial_ordering&lt;/code&gt; 클래스 유형 은 &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;3 방향 비교&lt;/a&gt; 의 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="5f8fd1cd051ed62f4aae2af2ef778e18fa5deae5" translate="yes" xml:space="preserve">
          <source>The class type &lt;code&gt;std::strong_equality&lt;/code&gt; is the result type of a &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;three-way comparison&lt;/a&gt; that.</source>
          <target state="translated">&lt;code&gt;std::strong_equality&lt;/code&gt; 클래스 유형 은 &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;3 방향 비교&lt;/a&gt; 의 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="f0b391e8b1d2924cc2df0c071f824a13535a3913" translate="yes" xml:space="preserve">
          <source>The class type &lt;code&gt;std::strong_ordering&lt;/code&gt; is the result type of a &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;three-way comparison&lt;/a&gt; that.</source>
          <target state="translated">클래스 유형 &lt;code&gt;std::strong_ordering&lt;/code&gt; 은 &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;3 방향 비교&lt;/a&gt; 의 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="94948fee4206e5a063212825c1a5dba324d74bc2" translate="yes" xml:space="preserve">
          <source>The class type &lt;code&gt;std::weak_equality&lt;/code&gt; is the result type of a &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;three-way comparison&lt;/a&gt; that.</source>
          <target state="translated">클래스 유형 &lt;code&gt;std::weak_equality&lt;/code&gt; 는 &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;3 방향 비교&lt;/a&gt; 의 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="1ee17c787dc83810d3b5069706ce3e57df0497ff" translate="yes" xml:space="preserve">
          <source>The class type &lt;code&gt;std::weak_ordering&lt;/code&gt; is the result type of a &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;three-way comparison&lt;/a&gt; that.</source>
          <target state="translated">&lt;code&gt;std::weak_ordering&lt;/code&gt; 클래스 유형 은 &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;3 방향 비교&lt;/a&gt; 의 결과 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="4701d5b65a3e69267b74f3e15bd5072a48820566" translate="yes" xml:space="preserve">
          <source>The class-key or &lt;code&gt;enum&lt;/code&gt; keyword present in the elaborated-type-specifier must agree in kind with the declaration to which the name in the elaborated-type-specifier refers.</source>
          <target state="translated">elaborated-type-specifier에있는 class-key 또는 &lt;code&gt;enum&lt;/code&gt; 키워드는 elaborated-type-specifier의 이름이 참조하는 선언과 종류가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="24f685345d705e67dcaed28004c42cbbe5fa66c7" translate="yes" xml:space="preserve">
          <source>The class-name or enum-name in the elaborated type specifier may either be a simple identifier or be a &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified-id&lt;/a&gt;. The name is looked up using &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified name lookup&lt;/a&gt; or &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name lookup&lt;/a&gt;, depending on their appearance. But in either case, non-type names are not considered.</source>
          <target state="translated">정교한 타입 지정자의 class-name 또는 enum-name은 간단한 식별자이거나 &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;Qualified-id 일 수&lt;/a&gt; 있습니다. 이름은 모양에 따라 &lt;a href=&quot;unqualified_lookup&quot;&gt;규정되지 않은 이름 조회&lt;/a&gt; 또는 &lt;a href=&quot;qualified_lookup&quot;&gt;규정 된 이름 조회를&lt;/a&gt; 사용하여 조회 됩니다. 그러나 두 경우 모두 유형이 아닌 이름은 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="354603554cb293c18da720435d03777c84dbb5f8" translate="yes" xml:space="preserve">
          <source>The classes listed in the base-clause are direct base classes. Their bases are indirect base classes. The same class cannot be specified as a direct base class more than once, but the same class can be both direct and indirect base class.</source>
          <target state="translated">기본 조항에 나열된 클래스는 직접 기본 클래스입니다. 그들의베이스는 간접베이스 클래스입니다. 동일한 클래스를 직접 기본 클래스로 두 번 이상 지정할 수는 없지만 동일한 클래스는 직접 및 간접 기본 클래스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cea83cbd5791acb1de079b9452c000b451656d7" translate="yes" xml:space="preserve">
          <source>The classification returned for the string &lt;code&gt;&quot;w&quot;&lt;/code&gt; may be exactly the same as &lt;code&gt;&quot;alnum&quot;&lt;/code&gt;, in which case &lt;code&gt;&lt;a href=&quot;isctype&quot;&gt;isctype()&lt;/a&gt;&lt;/code&gt; adds '_' explicitly.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;w&quot;&lt;/code&gt; 에 대해 반환 된 분류는 &lt;code&gt;&quot;alnum&quot;&lt;/code&gt; 과 정확히 동일 할 수 있습니다 .이 경우 &lt;code&gt;&lt;a href=&quot;isctype&quot;&gt;isctype()&lt;/a&gt;&lt;/code&gt; '_'을 명시 적으로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3f685e71298d6329f3079585486868fc8d36b2af" translate="yes" xml:space="preserve">
          <source>The clock &lt;code&gt;std::chrono::gps_clock&lt;/code&gt; is a &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; that represents Global Positioning System (GPS) time. It measures time since 00:00:00, 6 January 1980 UTC.</source>
          <target state="translated">시계 &lt;code&gt;std::chrono::gps_clock&lt;/code&gt; 은 GPS (Global Positioning System) 시간을 나타내는 &lt;a href=&quot;../named_req/clock&quot;&gt;시계&lt;/a&gt; 입니다. 1980 년 1 월 6 일 00:00:00 (UTC) 이후 시간을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="bfee064193b9d48bafa8ff6f66cf6b7aa290e331" translate="yes" xml:space="preserve">
          <source>The clock &lt;code&gt;std::chrono::tai_clock&lt;/code&gt; is a &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; that represents International Atomic Time (TAI). It measures time since 00:00:00, 1 January 1958, and is offset 10 seconds ahead of UTC at that date (i.e., its epoch, 1958-01-01 00:00:00 TAI, is 1957-12-31 23:59:50 UTC).</source>
          <target state="translated">시계 &lt;code&gt;std::chrono::tai_clock&lt;/code&gt; 된 &lt;a href=&quot;../named_req/clock&quot;&gt;시계&lt;/a&gt; 국제 원자시 (TAI)를 나타냅니다. 1958 년 1 월 1 일 00:00:00 이후의 시간을 측정하고 해당 날짜의 UTC보다 10 초 앞선 오프셋됩니다 (예 : 1958-01-01 00:00:00 TAI, 1957-12-31 23). : 59 : 50 UTC).</target>
        </trans-unit>
        <trans-unit id="e01eb84e78303a21a91228ca5b6543a355d6076f" translate="yes" xml:space="preserve">
          <source>The clock &lt;code&gt;std::chrono::utc_clock&lt;/code&gt; is a &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; that represents Coordinated Universal Time (UTC). It measures time since 00:00:00 UTC, Thursday, 1 January 1970, including leap seconds.</source>
          <target state="translated">시계 &lt;code&gt;std::chrono::utc_clock&lt;/code&gt; 은 UTC (협정 세계시)를 나타내는 &lt;a href=&quot;../named_req/clock&quot;&gt;시계&lt;/a&gt; 입니다. 1970 년 1 월 1 일 목요일 00:00:00 UTC 이후의 윤초를 포함하여 시간을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="2ce385b63b923a15e64d2067b2f70b70f476178d" translate="yes" xml:space="preserve">
          <source>The clock tied to &lt;code&gt;sleep_time&lt;/code&gt; is used, which means that adjustments of the clock are taken into account. Thus, the duration of the block might, but might not, be less or more than &lt;code&gt;sleep_time - Clock::now()&lt;/code&gt; at the time of the call, depending on the direction of the adjustment. The function also may block for longer than until after &lt;code&gt;sleep_time&lt;/code&gt; has been reached due to scheduling or resource contention delays.</source>
          <target state="translated">&lt;code&gt;sleep_time&lt;/code&gt; 에 연결된 시계 가 사용됩니다. 즉, 시계 조정이 고려됩니다. 따라서 블록의 지속 시간은 조정 방향에 따라 호출시 &lt;code&gt;sleep_time - Clock::now()&lt;/code&gt; 보다 작거나 같을 수 있습니다 . 이 기능은 또한 예약 또는 리소스 경합 지연으로 인해 &lt;code&gt;sleep_time&lt;/code&gt; 에 도달 한 후까지 더 오래 차단 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa793d7c160acf63000dc75ea7f5469cf01bff40" translate="yes" xml:space="preserve">
          <source>The clock tied to &lt;code&gt;timeout_time&lt;/code&gt; is used, which is not required to be a monotonic clock.There are no guarantees regarding the behavior of this function if the clock is adjusted discontinuously, but the existing implementations convert &lt;code&gt;timeout_time&lt;/code&gt; from &lt;code&gt;Clock&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../chrono/system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&lt;/code&gt; and delegate to POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html&quot;&gt;pthread_cond_timedwait&lt;/a&gt; so that the wait honors ajustments to the system clock, but not to the the user-provided &lt;code&gt;Clock&lt;/code&gt;. In any case, the function also may wait for longer than until after &lt;code&gt;timeout_time&lt;/code&gt; has been reached due to scheduling or resource contention delays.</source>
          <target state="translated">&lt;code&gt;timeout_time&lt;/code&gt; 에 묶인 시계 가 사용되며 단조로운 시계 일 필요는 없습니다. 시계가 불 연속적으로 조정되는 경우이 함수의 동작에 대해 보장 할 수는 없지만 기존 구현은 &lt;code&gt;timeout_time&lt;/code&gt; 을 &lt;code&gt;Clock&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../../chrono/system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&lt;/code&gt; 로 변환합니다. system_clock 및 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html&quot;&gt;pthread_cond_timedwait에&lt;/a&gt; 위임 하여 대기가 시스템 시계에 대한 조정을 따르지만 사용자가 제공 한 &lt;code&gt;Clock&lt;/code&gt; 에 대해서는 조정하지 않습니다 . 어쨌든, 함수는 스케줄링 또는 자원 경합 지연으로 인해 &lt;code&gt;timeout_time&lt;/code&gt; 에 도달 한 후까지 더 오래 기다릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7c4bc050b740626dbf1fc8c06b8c652935eaf67" translate="yes" xml:space="preserve">
          <source>The clock tied to &lt;code&gt;timeout_time&lt;/code&gt; is used, which means that adjustments of the clock are taken into account. Thus, the maximum duration of the block might, but might not, be less or more than &lt;code&gt;timeout_time - Clock::now()&lt;/code&gt; at the time of the call, depending on the direction of the adjustment. The function also may block for longer than until after &lt;code&gt;timeout_time&lt;/code&gt; has been reached due to scheduling or resource contention delays.</source>
          <target state="translated">&lt;code&gt;timeout_time&lt;/code&gt; 에 연결된 시계 가 사용됩니다. 즉, 시계 조정이 고려됩니다. 따라서 블록의 최대 지속 시간은 조정 방향에 따라 호출시 &lt;code&gt;timeout_time - Clock::now()&lt;/code&gt; 보다 작거나 같을 수 있습니다 . 이 기능은 또한 예약 또는 리소스 경합 지연으로 인해 &lt;code&gt;timeout_time&lt;/code&gt; 에 도달 한 후까지 더 오래 차단 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="894b1ae7ddba598ccce40d8b0f190492deb2041a" translate="yes" xml:space="preserve">
          <source>The code samples on this wiki &lt;a href=&quot;http://www.stroustrup.com/3rd_code.html&quot;&gt;follow Bjarne Stroustrup&lt;/a&gt; and &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rio-endl&quot;&gt;The C++ Core Guidelines&lt;/a&gt; in flushing the standard output only where necessary.</source>
          <target state="translated">이 위키의 코드 샘플은 &lt;a href=&quot;http://www.stroustrup.com/3rd_code.html&quot;&gt;Bjarne Stroustrup&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rio-endl&quot;&gt;C ++ 핵심 지침&lt;/a&gt; 에 따라 필요한 경우에만 표준 출력을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="3cc9e60597f252bb86bd1f42cb5d3cd1cfb8cda0" translate="yes" xml:space="preserve">
          <source>The collation key for the character sequence &lt;code&gt;[first, last)&lt;/code&gt; in the currently imbued locale.</source>
          <target state="translated">현재 마킹 된 로케일 의 문자 순서 &lt;code&gt;[first, last)&lt;/code&gt; 에 대한 조합 키입니다 .</target>
        </trans-unit>
        <trans-unit id="b22d59729b28540e2c261fa1622c17f430bc0333" translate="yes" xml:space="preserve">
          <source>The combination is valid if &lt;code&gt;month()&lt;/code&gt; represents a valid month (&lt;code&gt;month().ok() == true&lt;/code&gt;), &lt;code&gt;unsigned{day()} &amp;gt;= 1&lt;/code&gt;, and &lt;code&gt;unsigned{day()} &amp;lt;= D&lt;/code&gt;, where D is the number of days in the month represented by &lt;code&gt;month()&lt;/code&gt;. The number of days in February is considered to be 29.</source>
          <target state="translated">&lt;code&gt;month()&lt;/code&gt; 가 유효한 월 ( &lt;code&gt;month().ok() == true&lt;/code&gt; ), &lt;code&gt;unsigned{day()} &amp;gt;= 1&lt;/code&gt; 및 &lt;code&gt;unsigned{day()} &amp;lt;= D&lt;/code&gt; 나타내는 경우 조합이 유효합니다 . 여기서 D는 &lt;code&gt;month()&lt;/code&gt; 표시된 월의 일 수입니다 . 2 월의 일 수는 29로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="299149b66129ea51f7209f65e5c9c8a104c2e60d" translate="yes" xml:space="preserve">
          <source>The comma in various comma-separated lists, such as function argument lists (&lt;code&gt;f(a, b, c)&lt;/code&gt;) and initializer lists &lt;code&gt;int a[] = {1,2,3}&lt;/code&gt;, is not the comma operator. If the comma operator needs to be used in such contexts, it has to be parenthesized: &lt;code&gt;f(a, (n++, n+b), c)&lt;/code&gt;.</source>
          <target state="translated">함수 인수 목록 ( &lt;code&gt;f(a, b, c)&lt;/code&gt; ) 및 초기화 목록 &lt;code&gt;int a[] = {1,2,3}&lt;/code&gt; 과 같이 다양한 쉼표로 구분 된 목록 의 쉼표는 쉼표 연산자가 아닙니다. 이러한 상황에서 쉼표 연산자를 사용해야하는 경우 괄호로 묶어야합니다 &lt;code&gt;f(a, (n++, n+b), c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d488bf849908d324aa3b6792f690387cae01a82" translate="yes" xml:space="preserve">
          <source>The comma operator expressions have the form.</source>
          <target state="translated">쉼표 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d08ab7bae20cdd9d29de0eca78f0d5770cf98f4" translate="yes" xml:space="preserve">
          <source>The comma operator is not overloaded by any class in the standard library. The boost library uses &lt;code&gt;operator,&lt;/code&gt; in &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/assign/doc/index.html#intro&quot;&gt;boost.assign&lt;/a&gt;, boost.spirit, and other libraries. The database access library &lt;a href=&quot;http://soci.sourceforge.net/doc.html&quot;&gt;SOCI&lt;/a&gt; also overloads &lt;code&gt;operator,&lt;/code&gt;.</source>
          <target state="translated">쉼표 연산자는 표준 라이브러리의 클래스에 의해 오버로드되지 않습니다. 부스트 라이브러리는 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/assign/doc/index.html#intro&quot;&gt;boost.assign&lt;/a&gt; , boost.spirit 및 기타 라이브러리 에서 &lt;code&gt;operator,&lt;/code&gt; 사용합니다 . 데이터베이스 액세스 라이브러리 &lt;a href=&quot;http://soci.sourceforge.net/doc.html&quot;&gt;SOCI&lt;/a&gt; 는 &lt;code&gt;operator,&lt;/code&gt; 를 오버로드 합니다.</target>
        </trans-unit>
        <trans-unit id="c800df5ac9c3f57a71dd8a0a1e138f4bcc97b764" translate="yes" xml:space="preserve">
          <source>The comma operator, &lt;code&gt;operator,&lt;/code&gt;. Unlike the built-in version, the overloads do not sequence their left operand before the right one.(until C++17) Because this operator may be overloaded, generic libraries use expressions such as &lt;code&gt;a,void(),b&lt;/code&gt; instead of &lt;code&gt;a,b&lt;/code&gt; to sequence execution of expressions of user-defined types. The boost library uses &lt;code&gt;operator,&lt;/code&gt; in &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/assign/doc/index.html#intro&quot;&gt;boost.assign&lt;/a&gt;, &lt;a href=&quot;https://github.com/boostorg/spirit/blob/develop/include/boost/spirit/home/qi/string/symbols.hpp#L317&quot;&gt;boost.spirit&lt;/a&gt;, and other libraries. The database access library &lt;a href=&quot;http://soci.sourceforge.net/doc.html&quot;&gt;SOCI&lt;/a&gt; also overloads &lt;code&gt;operator,&lt;/code&gt;.</source>
          <target state="translated">콤마 연산자, &lt;code&gt;operator,&lt;/code&gt; . 내장 버전과 달리 오버로드는 왼쪽 피연산자를 오른쪽 피연산자 앞에 순서화하지 ​​않습니다. (C ++ 17까지)이 연산자가 오버로드 될 수 있으므로 일반 라이브러리는 &lt;code&gt;a,void(),b&lt;/code&gt; 대신에 a, void (), b 와 같은 표현식을 사용 &lt;code&gt;a,b&lt;/code&gt; 사용자 정의 형식의 식 실행 순서를 지정합니다. 부스트 라이브러리는 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/assign/doc/index.html#intro&quot;&gt;boost.assign&lt;/a&gt; , &lt;a href=&quot;https://github.com/boostorg/spirit/blob/develop/include/boost/spirit/home/qi/string/symbols.hpp#L317&quot;&gt;boost.spirit&lt;/a&gt; 및 기타 라이브러리 에서 &lt;code&gt;operator,&lt;/code&gt; 사용합니다 . 데이터베이스 액세스 라이브러리 &lt;a href=&quot;http://soci.sourceforge.net/doc.html&quot;&gt;SOCI&lt;/a&gt; 는 &lt;code&gt;operator,&lt;/code&gt; 를 오버로드 합니다.</target>
        </trans-unit>
        <trans-unit id="1b6cb0170adc4e3800c9ced00cfa4ccffb490a90" translate="yes" xml:space="preserve">
          <source>The common type of two &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; types is a &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; with the same clock as the two types and the &lt;code&gt;&lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; of their durations.</source>
          <target state="translated">두 &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; 유형 의 공통 유형은 두 유형 과 동일한 시간 및 &lt;code&gt;&lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; 의 지속 시간 과 동일한 &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="098b2560bc5964f50659e0ba25d611da3936a573" translate="yes" xml:space="preserve">
          <source>The common workaround for such a catch-all statement is a type-dependent expression that is always false:</source>
          <target state="translated">이러한 catch-all 문에 대한 일반적인 해결 방법은 항상 잘못된 유형 종속 식입니다.</target>
        </trans-unit>
        <trans-unit id="c070c65d4a405765e86ab073670268a7d75d353d" translate="yes" xml:space="preserve">
          <source>The comparison and copying are bitwise (similar to &lt;code&gt;&lt;a href=&quot;../../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt;); no constructor, assignment operator, or comparison operator are used.</source>
          <target state="translated">비교 및 복사는 비트 단위입니다 ( &lt;code&gt;&lt;a href=&quot;../../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; 와 유사 ). 생성자, 대입 연산자 또는 비교 연산자는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcdbc3a3503f2cf19021453e0957f700ee34d892" translate="yes" xml:space="preserve">
          <source>The comparison between &lt;code&gt;e.code()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc::stream&lt;/a&gt;&lt;/code&gt; compiles because &lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&amp;lt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&amp;lt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&amp;gt;::value == true&lt;/code&gt; &amp;lt; &lt;a href=&quot;../io_errc&quot;&gt;std :: io_errc&lt;/a&gt; &amp;gt; :: value == true 이므로 &lt;code&gt;e.code()&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc::stream&lt;/a&gt;&lt;/code&gt; 의 비교는 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="607651bcf9bec45c6eb29bfa73daf4c7cc4835c3" translate="yes" xml:space="preserve">
          <source>The comparison key for &lt;code&gt;c&lt;/code&gt; in the currently imbued locale.</source>
          <target state="translated">현재 마킹 된 로캘의 &lt;code&gt;c&lt;/code&gt; 에 대한 비교 키입니다 .</target>
        </trans-unit>
        <trans-unit id="a35040839a2bde1c52ffbdf3b521c8b7486fbb42" translate="yes" xml:space="preserve">
          <source>The comparison object with which &lt;code&gt;a&lt;/code&gt; was constructed is returned.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 구성된 비교 객체 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3654e010cde366f1228cb35ead854e1d709174b5" translate="yes" xml:space="preserve">
          <source>The compiler is allowed,</source>
          <target state="translated">컴파일러가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5b0c78bd02c55f195510bbc68ddc1d3066960669" translate="yes" xml:space="preserve">
          <source>The compiler is permitted to initialize other static and thread-local objects using constant initialization, if it can guarantee that the value would be the same as if the standard order of initialization was followed.</source>
          <target state="translated">컴파일러는 표준 초기화 순서를 따르는 것과 동일한 값을 보장 할 수있는 경우 상수 초기화를 사용하여 다른 정적 및 스레드 로컬 객체를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3509d6757108bb243a4a74c41da1164b451bd842" translate="yes" xml:space="preserve">
          <source>The compilers are allowed to initialize dynamically-initialized variables as part of static initialization (essentially, at compile time), if the following conditions are both true:</source>
          <target state="translated">다음 조건에 모두 해당되는 경우 컴파일러는 정적 초기화의 일부로 (필수적으로 컴파일 타임에) 동적으로 초기화 된 변수를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f422b0910e780df0e194f38bdd5cbabced51f14" translate="yes" xml:space="preserve">
          <source>The completion of the invocation of the constructor</source>
          <target state="translated">생성자 호출 완료</target>
        </trans-unit>
        <trans-unit id="50acdbb041b7c9bfeb40868b8f7d12c5991ab7bb" translate="yes" xml:space="preserve">
          <source>The completion of the thread identified by &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 의해 식별 된 스레드의 완료</target>
        </trans-unit>
        <trans-unit id="473d434a9b1e1fa3c3fa95983b0cf370022ebc41" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c5651398368fa9194c75ad0cd42b27eaccd0a5" translate="yes" xml:space="preserve">
          <source>The complex exponential function ez</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec6bf51db38b2ef988daa5b51588addb599916a" translate="yes" xml:space="preserve">
          <source>The complexity (efficiency) of common operations on deques is as follows:</source>
          <target state="translated">대기열에서 공통 작업의 복잡성 (효율)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b6af511fdc68030780724ffc1d216fb7505882d" translate="yes" xml:space="preserve">
          <source>The complexity (efficiency) of common operations on vectors is as follows:</source>
          <target state="translated">벡터에 대한 공통 연산의 복잡성 (효율)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5019eb24db55cd605bd07c28cf8b2f307a537737" translate="yes" xml:space="preserve">
          <source>The complexity is constant (that is, the implementation cannot actually execute the while loop shown in operational semantics)</source>
          <target state="translated">복잡성은 일정합니다 (즉, 구현시 실제로 작동 의미론에 표시된 while 루프를 실행할 수 없음)</target>
        </trans-unit>
        <trans-unit id="f931e366fe99b22ec5e943477363a16341bd0215" translate="yes" xml:space="preserve">
          <source>The complexity of each function of &lt;code&gt;A&lt;/code&gt; does not exceed the complexity of the function of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 각 함수의 복잡성은 &lt;code&gt;B&lt;/code&gt; 의 함수의 복잡성을 초과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83199838a945008228f4ecf7f4a77c745b15a0ca" translate="yes" xml:space="preserve">
          <source>The compound assignment expressions have the form.</source>
          <target state="translated">복합 할당 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="28d0b992d873a598f8d887391cbb97b4c70fe2c0" translate="yes" xml:space="preserve">
          <source>The compound-statement in an atomic block is not allowed to execute any expression or statement or call any function that isn't &lt;code&gt;transaction_safe&lt;/code&gt; (this is a compile time error).</source>
          <target state="translated">원자 블록의 복합 명령문은 표현식이나 명령문을 실행하거나 &lt;code&gt;transaction_safe&lt;/code&gt; 가 아닌 함수를 호출 할 수 없습니다 (컴파일 시간 오류 임).</target>
        </trans-unit>
        <trans-unit id="e4619f547f6df26fd02d4616e6152f98c9f6a5de" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;&lt;a href=&quot;convertibleto&quot;&gt;ConvertibleTo&lt;/a&gt;&amp;lt;From, To&amp;gt;&lt;/code&gt; specifies that an expression of the type and value category specified by &lt;code&gt;From&lt;/code&gt; can be implicitly and explicitly converted to the type &lt;code&gt;To&lt;/code&gt;, and the two forms of conversion are equivalent.</source>
          <target state="translated">개념 &lt;code&gt;&lt;a href=&quot;convertibleto&quot;&gt;ConvertibleTo&lt;/a&gt;&amp;lt;From, To&amp;gt;&lt;/code&gt; 지정에 의해 지정된 타입 및 카테고리의 값을 표현하는 것이 &lt;code&gt;From&lt;/code&gt; 내재적 및 명시 적 형태로 변환 할 수 &lt;code&gt;To&lt;/code&gt; , 전환의 두 가지 형태가 동일하다.</target>
        </trans-unit>
        <trans-unit id="73226dcacd9920f3975d9f5342300c70194c4e84" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;&lt;a href=&quot;derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;Derived, Base&amp;gt;&lt;/code&gt; is satisfied if and only if &lt;code&gt;Base&lt;/code&gt; is a class type that is either &lt;code&gt;Derived&lt;/code&gt; or a public and unambiguous base of &lt;code&gt;Derived&lt;/code&gt;, ignoring cv-qualifiers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;Derived, Base&amp;gt;&lt;/code&gt; 개념 은 &lt;code&gt;Base&lt;/code&gt; 가 &lt;code&gt;Derived&lt;/code&gt; 클래스 이거나 cv 한정자를 무시하고 공개적이고 모호하지 않은 &lt;code&gt;Derived&lt;/code&gt; 기반 클래스 인 경우에만 충족됩니다 .</target>
        </trans-unit>
        <trans-unit id="865542a66c716385b69d90d41b457244ea2ccb89" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;&lt;a href=&quot;integral&quot;&gt;Integral&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is satisfied if and only if &lt;code&gt;T&lt;/code&gt; is an integral type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;integral&quot;&gt;Integral&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 개념 은 &lt;code&gt;T&lt;/code&gt; 가 적분 유형 인 경우에만 충족됩니다 .</target>
        </trans-unit>
        <trans-unit id="13ea350d4b197e122799acfa74b35c5e7b7ca18a" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;Assignable&amp;lt;LHS, RHS&amp;gt;&lt;/code&gt; specifies that an expression of the type and value category specified by &lt;code&gt;RHS&lt;/code&gt; can be assigned to an lvalue expression whose type is specified by &lt;code&gt;LHS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Assignable&amp;lt;LHS, RHS&amp;gt;&lt;/code&gt; 개념 은 &lt;code&gt;RHS&lt;/code&gt; 에 의해 지정된 유형 및 값 범주의 표현식이 &lt;code&gt;LHS&lt;/code&gt; 에 의해 유형이 지정된 lvalue 표현식에 지정 될 수 있도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="af0568be2065f59b0b5a35861c61e4b6efdd42af" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;Boolean&amp;lt;B&amp;gt;&lt;/code&gt; specifies the requirements for a type usable in Boolean contexts. For &lt;code&gt;Boolean&lt;/code&gt; to be satisfied, the logical operators must have the usual behavior (including short-circuiting). More precisely, given.</source>
          <target state="translated">&lt;code&gt;Boolean&amp;lt;B&amp;gt;&lt;/code&gt; 개념 은 부울 컨텍스트에서 사용 가능한 유형에 대한 요구 사항을 지정합니다. 들어 &lt;code&gt;Boolean&lt;/code&gt; 만족하는 논리 연산자 (단락 포함) 일반적인 행동이 있어야합니다. 더 정확하게 말하면,</target>
        </trans-unit>
        <trans-unit id="78c647d18f5fd078ec4a60d8ccae3148788df8c2" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;Common&amp;lt;T, U&amp;gt;&lt;/code&gt; specifies that two types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; share a</source>
          <target state="translated">&lt;code&gt;Common&amp;lt;T, U&amp;gt;&lt;/code&gt; 개념 은 두 유형 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="602d9341f66432b56381f5712bb7c785a9ba46e4" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;CommonReference&amp;lt;T, U&amp;gt;&lt;/code&gt; specifies that two types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; share a</source>
          <target state="translated">&lt;code&gt;CommonReference&amp;lt;T, U&amp;gt;&lt;/code&gt; 개념 은 두 유형 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="bec7861bd36d28545110eeed67204481cd958f23" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;CopyConstructible&lt;/code&gt; is satisfied if &lt;code&gt;T&lt;/code&gt; is an lvalue reference type, or if it is a &lt;a href=&quot;moveconstructible&quot;&gt;&lt;code&gt;MoveConstructible&lt;/code&gt;&lt;/a&gt; object type where an object of that type can constructed from a (possibly const) lvalue or const rvalue of that type in both direct- and copy-initialization contexts with the usual semantics (a copy is constructed with the source unchanged).</source>
          <target state="translated">&lt;code&gt;CopyConstructible&lt;/code&gt; 개념 은 &lt;code&gt;T&lt;/code&gt; 가 lvalue 참조 유형이거나 해당 유형의 오브젝트가 직접 및 복사 초기화에서 해당 유형의 (또는 const) lvalue 또는 const rvalue로 구성 될 수 있는 &lt;a href=&quot;moveconstructible&quot;&gt; &lt;code&gt;MoveConstructible&lt;/code&gt; &lt;/a&gt; 오브젝트 유형 인 경우 충족됩니다. 일반적인 의미론을 가진 문맥 (사본은 변경되지 않은 상태로 구성됨).</target>
        </trans-unit>
        <trans-unit id="f8022dc06d0404b06b8689521dec182dfcfe8dc9" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;Copyable&amp;lt;T&amp;gt;&lt;/code&gt; specifies that &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;movable&quot;&gt;&lt;code&gt;Movable&lt;/code&gt;&lt;/a&gt; object type that can also copied (that is, it supports copy construction and copy assignment).</source>
          <target state="translated">&lt;code&gt;Copyable&amp;lt;T&amp;gt;&lt;/code&gt; 개념 은 &lt;code&gt;T&lt;/code&gt; 가 복사 할 수 있는 &lt;a href=&quot;movable&quot;&gt; &lt;code&gt;Movable&lt;/code&gt; &lt;/a&gt; 객체 유형 (즉, 복사 구성 및 복사 할당을 지원함)을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1ef21317d90ede51d217d9c162660b2f0fa040e8" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;Destructible&lt;/code&gt; specifies the concept of all types whose instances can safely be destroyed at the end of their lifetime (including reference types).</source>
          <target state="translated">개념 &lt;code&gt;Destructible&lt;/code&gt; 인스턴스를 안전하게 (참조 타입을 포함) 그들의 수명이 파괴 될 수있는 모든 종류의 개념을 지정한다.</target>
        </trans-unit>
        <trans-unit id="19adc5ade33dedda46791b5120a34278e3e9fb8d" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;Movable&amp;lt;T&amp;gt;&lt;/code&gt; specifies that &lt;code&gt;T&lt;/code&gt; is an object type that can moved (that is, it can be move constructed, move assigned, and lvalues of type &lt;code&gt;T&lt;/code&gt; can be swapped).</source>
          <target state="translated">&lt;code&gt;Movable&amp;lt;T&amp;gt;&lt;/code&gt; 개념 은 &lt;code&gt;T&lt;/code&gt; 가 이동할 수있는 오브젝트 유형 (즉, 이동 구성, 이동 지정, 유형 &lt;code&gt;T&lt;/code&gt; 의 l 값을 교환 할 수 있음)을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="72b44024301ed4034c4cb4c443a0a34d71d631f0" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;MoveConstructible&lt;/code&gt; is satisfied if &lt;code&gt;T&lt;/code&gt; is a reference type, or if it is an object type where an object of that type can constructed from an rvalue of that type in both direct- and copy-initialization contexts, with the usual semantics.</source>
          <target state="translated">&lt;code&gt;MoveConstructible&lt;/code&gt; 개념 은 &lt;code&gt;T&lt;/code&gt; 가 참조 유형이거나 일반적인 의미론을 사용하여 직접 및 복사 초기화 컨텍스트에서 해당 유형의 rvalue로 해당 유형의 오브젝트를 구성 할 수있는 오브젝트 유형 인 경우 충족됩니다 .</target>
        </trans-unit>
        <trans-unit id="03dbedcdf06a326e5298663f07ce7d9595b129c3" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;Predicate&amp;lt;F, Args...&amp;gt;&lt;/code&gt; specifies that &lt;code&gt;F&lt;/code&gt; is a predicate that accepts arguments whose types and value categories are encoded by &lt;code&gt;Args...&lt;/code&gt;, i.e., it can be invoked with these arguments to produce a &lt;a href=&quot;boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt; result.</source>
          <target state="translated">&lt;code&gt;Predicate&amp;lt;F, Args...&amp;gt;&lt;/code&gt; 개념 은 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Args...&lt;/code&gt; 의해 유형 및 값 범주가 인코딩 된 인수를 허용하는 술어임을 지정합니다 . 즉, 이러한 인수로 호출하여 &lt;a href=&quot;boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 결과 를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9b1aa8e76324363f4f2bf6abad7b7072fe22a3f" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;Relation&amp;lt;R, T, U&amp;gt;&lt;/code&gt; specifies that &lt;code&gt;R&lt;/code&gt; defines a binary relation over the set of expressions whose type and value category are those encoded by either &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Relation&amp;lt;R, T, U&amp;gt;&lt;/code&gt; 개념 은 &lt;code&gt;R&lt;/code&gt; 이 유형 및 값 범주가 &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;U&lt;/code&gt; 로 인코딩 된 표현식 세트에 대해 이진 관계를 정의하도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="6513199fc6b4ce22136fcd67141b170c7b741fee" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;Same&amp;lt;T, U&amp;gt;&lt;/code&gt; is satisfied if and only if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; denote the same type.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 가 같은 유형을 나타내는 경우에만 &lt;code&gt;Same&amp;lt;T, U&amp;gt;&lt;/code&gt; 개념 이 충족됩니다 .</target>
        </trans-unit>
        <trans-unit id="3583800434e81c6a76cacf78f829171638922ff7" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;SignedIntegral&amp;lt;T&amp;gt;&lt;/code&gt; is satisfied if and only if &lt;code&gt;T&lt;/code&gt; is an integral type and &lt;code&gt;&lt;a href=&quot;../types/is_signed&quot;&gt;std::is_signed_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SignedIntegral&amp;lt;T&amp;gt;&lt;/code&gt; 개념 은 &lt;code&gt;T&lt;/code&gt; 가 정수 유형이고 &lt;code&gt;&lt;a href=&quot;../types/is_signed&quot;&gt;std::is_signed_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 충족됩니다 .</target>
        </trans-unit>
        <trans-unit id="672ac5210d2625c6df97d19ab0eb50738d77147b" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;StrictWeakOrder&amp;lt;R, T, U&amp;gt;&lt;/code&gt; specifies that the &lt;a href=&quot;relation&quot;&gt;&lt;code&gt;Relation&lt;/code&gt;&lt;/a&gt;&lt;code&gt;R&lt;/code&gt; imposes a strict weak ordering on its arguments. A relation &lt;code&gt;r&lt;/code&gt; is a strict weak ordering if.</source>
          <target state="translated">&lt;code&gt;StrictWeakOrder&amp;lt;R, T, U&amp;gt;&lt;/code&gt; 개념 은 &lt;a href=&quot;relation&quot;&gt; &lt;code&gt;Relation&lt;/code&gt; &lt;/a&gt; &lt;code&gt;R&lt;/code&gt; 이 인수에 대해 엄격한 약한 순서를 부과 함을 지정합니다 . 관계 &lt;code&gt;r&lt;/code&gt; 은 엄격한 약한 순서입니다.</target>
        </trans-unit>
        <trans-unit id="e363b8f4b98e412296c9f75273fb6e09dac047cd" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;Swappable&amp;lt;T&amp;gt;&lt;/code&gt; specifies that lvalues of type &lt;code&gt;T&lt;/code&gt; are swappable.</source>
          <target state="translated">&lt;code&gt;Swappable&amp;lt;T&amp;gt;&lt;/code&gt; 개념 은 &lt;code&gt;T&lt;/code&gt; 유형의 lvalue 가 스왑 가능 하도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="11f94864e3389b850713fed5e46729da9b5a87f2" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;SwappableWith&amp;lt;T, U&amp;gt;&lt;/code&gt; specifies that expressions of the type and value category encoded by &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are swappable with each other. &lt;code&gt;SwappableWith&amp;lt;T, U&amp;gt;&lt;/code&gt; is satisfied only if a call to &lt;code&gt;&lt;a href=&quot;../utility/ranges/swap&quot;&gt;ranges::swap&lt;/a&gt;(t, u)&lt;/code&gt; exchanges the value of &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt;, that is, given distinct objects &lt;code&gt;t2&lt;/code&gt; equal to &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u2&lt;/code&gt; equal to &lt;code&gt;u&lt;/code&gt;, after evaluating either &lt;code&gt;&lt;a href=&quot;../utility/ranges/swap&quot;&gt;ranges::swap&lt;/a&gt;(t, u)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../utility/ranges/swap&quot;&gt;ranges::swap&lt;/a&gt;(u, t)&lt;/code&gt;, &lt;code&gt;t2&lt;/code&gt; is equal to &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;u2&lt;/code&gt; is equal to &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SwappableWith&amp;lt;T, U&amp;gt;&lt;/code&gt; 개념 은 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;U&lt;/code&gt; 로 인코딩 된 유형 및 값 범주의 표현식이 서로 교환 가능하도록 지정합니다. &lt;code&gt;SwappableWith&amp;lt;T, U&amp;gt;&lt;/code&gt; 을 만족하는 경우에만 호출 &lt;code&gt;&lt;a href=&quot;../utility/ranges/swap&quot;&gt;ranges::swap&lt;/a&gt;(t, u)&lt;/code&gt; 교환의 값 &lt;code&gt;t&lt;/code&gt; 와 &lt;code&gt;u&lt;/code&gt; 이며, 소정의 다른 오브젝트 &lt;code&gt;t2&lt;/code&gt; 과 동일 &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;u2&lt;/code&gt; 동일 &lt;code&gt;u&lt;/code&gt; 어느 평가 한 후 &lt;code&gt;&lt;a href=&quot;../utility/ranges/swap&quot;&gt;ranges::swap&lt;/a&gt;(t, u)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../utility/ranges/swap&quot;&gt;ranges::swap&lt;/a&gt;(u, t)&lt;/code&gt; , &lt;code&gt;t2&lt;/code&gt; 는 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;u2&lt;/code&gt; 와 같습니다. &lt;code&gt;t&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="efaf725ce3f251ac1fc637f5047af514790e0f15" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;UniformRandomBitGenerator &amp;lt;G&amp;gt;&lt;/code&gt; specifies that &lt;code&gt;G&lt;/code&gt; is the type of a uniform random bit generator, that is, objects of type &lt;code&gt;G&lt;/code&gt; is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability of being returned.</source>
          <target state="translated">개념 &lt;code&gt;UniformRandomBitGenerator &amp;lt;G&amp;gt;&lt;/code&gt; 하도록 지정 &lt;code&gt;G&lt;/code&gt; 가 이고 균일 한 랜덤 비트 발생기의 타입이 타입의 객체 &lt;code&gt;G&lt;/code&gt; 는 부호 정수를 반환하는 함수의 목적은 가능한 결과의 범위의 각 값 (이상적으로) 동일한 확률을 갖도록 값이며 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="eff4121d5e5fbc13e5baa52e82079db0250b8a88" translate="yes" xml:space="preserve">
          <source>The concept &lt;code&gt;UnsignedIntegral&amp;lt;T&amp;gt;&lt;/code&gt; is satisfied if and only if &lt;code&gt;T&lt;/code&gt; is an integral type and &lt;code&gt;&lt;a href=&quot;../types/is_signed&quot;&gt;std::is_signed_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UnsignedIntegral&amp;lt;T&amp;gt;&lt;/code&gt; 개념 은 &lt;code&gt;T&lt;/code&gt; 가 정수 유형이고 &lt;code&gt;&lt;a href=&quot;../types/is_signed&quot;&gt;std::is_signed_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 충족됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8cc50209d2b8940fe4165236386b68230d84785" translate="yes" xml:space="preserve">
          <source>The concepts library provides definitions of fundamental library concepts that can be used to perform compile-time validation of template arguments and perform function dispatch based on properties of types. These concepts provide a foundation for equational reasoning in programs.</source>
          <target state="translated">개념 라이브러리는 템플리트 인수의 컴파일 타임 유효성 검증을 수행하고 유형 특성에 따라 함수 디스패치를 ​​수행하는 데 사용할 수있는 기본 라이브러리 개념의 정의를 제공합니다. 이 개념은 프로그램에서 방정식 추론의 기초를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a1026c23f30aa7af3fc22b86cb9c76b42c7b444b" translate="yes" xml:space="preserve">
          <source>The conditional operator expressions have the form.</source>
          <target state="translated">조건부 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="953755a8477688f5085d4c79e1c4af3fc99f75be" translate="yes" xml:space="preserve">
          <source>The conditional preprocessing block starts with &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt; or &lt;code&gt;#ifndef&lt;/code&gt; directive, then optionally includes any number of &lt;code&gt;#elif&lt;/code&gt; directives, then optionally includes at most one &lt;code&gt;#else&lt;/code&gt; directive and is terminated with &lt;code&gt;#endif&lt;/code&gt; directive. Any inner conditional preprocessing blocks are processed separately.</source>
          <target state="translated">조건부 전처리 블록은 &lt;code&gt;#if&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; 또는 &lt;code&gt;#ifndef&lt;/code&gt; 지시문으로 시작한 다음 선택적으로 여러 개의 &lt;code&gt;#elif&lt;/code&gt; 지시문을 포함하고 선택적으로 최대 하나의 &lt;code&gt;#else&lt;/code&gt; 지시문을 포함하며 &lt;code&gt;#endif&lt;/code&gt; 지시문으로 종료됩니다 . 내부 조건부 전처리 블록은 별도로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fb4592b00b29b26bf69b048922d6dcb4a6c4ba74" translate="yes" xml:space="preserve">
          <source>The conditions when this function may be used and the way in which the provided buffer is used is implementation-defined.</source>
          <target state="translated">이 함수가 사용될 수있는 조건과 제공된 버퍼가 사용되는 방식은 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="eb4425137d23b5e3e31f870582e2292af2902e6c" translate="yes" xml:space="preserve">
          <source>The conjunction of two constraints is formed by using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator in the constraint expression:</source>
          <target state="translated">제약 조건 표현식에서 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자를 사용하여 두 제약 조건을 결합 합니다.</target>
        </trans-unit>
        <trans-unit id="f3c47b5b57a2b95648e4ae3ef6e312fe9cd89e65" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;std::piecewise_construct&lt;/code&gt; is an instance of an empty struct tag type &lt;code&gt;&lt;a href=&quot;piecewise_construct_t&quot;&gt;std::piecewise_construct_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상수 &lt;code&gt;std::piecewise_construct&lt;/code&gt; 는 빈 구조체 태그 유형 &lt;code&gt;&lt;a href=&quot;piecewise_construct_t&quot;&gt;std::piecewise_construct_t&lt;/a&gt;&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="b70f496a1d51e8442a69fb3ba6e8a15e510ec9cc" translate="yes" xml:space="preserve">
          <source>The constraint associated with a declaration are determined by &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;normalizing&lt;/a&gt; a logical AND expression whose operands are in the following order:</source>
          <target state="translated">선언과 관련된 제약 조건 은 피연산자가 다음 순서로 논리 AND 식 을 &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;정규화&lt;/a&gt; 하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a102d1707fb829c6a783c3fe78ff549237860bd" translate="yes" xml:space="preserve">
          <source>The constraints on &lt;code&gt;nullopt_t&lt;/code&gt;'s constructors exist to support both &lt;code&gt;op = {};&lt;/code&gt; and &lt;code&gt;op = nullopt;&lt;/code&gt; as the syntax for disengaging an optional object.</source>
          <target state="translated">&lt;code&gt;nullopt_t&lt;/code&gt; 생성자 의 제약 조건은 &lt;code&gt;op = {};&lt;/code&gt; 그리고 &lt;code&gt;op = nullopt;&lt;/code&gt; 선택적 객체를 해제하는 구문으로</target>
        </trans-unit>
        <trans-unit id="be930e842260d797cc680f8145491945ea7d3d77" translate="yes" xml:space="preserve">
          <source>The constructed &lt;code&gt;T&lt;/code&gt; object.</source>
          <target state="translated">생성 된 &lt;code&gt;T&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="eefc9886b95543e22010deacfaa6ae6c51c567c6" translate="yes" xml:space="preserve">
          <source>The constructed optional object.</source>
          <target state="translated">구성된 선택적 객체입니다.</target>
        </trans-unit>
        <trans-unit id="d684d3c8e5eece4b15ad75f687ca9ca6f533a06e" translate="yes" xml:space="preserve">
          <source>The constructor and the copy assignment operator from &lt;code&gt;auto_ptr_ref&lt;/code&gt; is provided to allow copy-constructing and assigning &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; from nameless temporaries. Since its copy constructor and copy assignment operator take the argument as non-const reference, they cannot bind rvalue arguments directly. However, a &lt;a href=&quot;operator_auto_ptr&quot;&gt;user-defined conversion&lt;/a&gt; can be executed (which releases the original auto_ptr), followed by a call to the constructor or copy-assignment operator that take &lt;code&gt;auto_ptr_ref&lt;/code&gt; by value. This is an early implementation of &lt;a href=&quot;../../utility/move&quot;&gt;move semantics&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;auto_ptr_ref&lt;/code&gt; 의 생성자 및 복사 할당 연산자 는 이름없는 임시에서 복사 및 &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; 을 할당 할 수 있도록 제공됩니다 . 복사 생성자 및 복사 할당 연산자는 인수를 상수가 아닌 참조로 사용하므로 rvalue 인수를 직접 바인딩 할 수 없습니다. 그러나 &lt;a href=&quot;operator_auto_ptr&quot;&gt;사용자 정의 변환&lt;/a&gt; (원래 auto_ptr을 릴리스 함)을 실행 한 다음 &lt;code&gt;auto_ptr_ref&lt;/code&gt; 를 값 으로 사용하는 생성자 또는 복사 할당 연산자를 호출 할 수 있습니다 . 이것은 &lt;a href=&quot;../../utility/move&quot;&gt;이동 의미론&lt;/a&gt; 의 초기 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="a88b24b86cbbedb529370f293289727d15460bac" translate="yes" xml:space="preserve">
          <source>The constructor and the copy assignment operator from &lt;code&gt;auto_ptr_ref&lt;/code&gt; is provided to allow copy-constructing and assigning &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; from nameless temporaries. Since its copy constructor and copy assignment operator take the argument as non-const reference, they cannot bind rvalue arguments directly. However, a &lt;strong&gt;user-defined conversion&lt;/strong&gt; can be executed (which releases the original auto_ptr), followed by a call to the constructor or copy-assignment operator that take &lt;code&gt;auto_ptr_ref&lt;/code&gt; by value. This is an early implementation of &lt;a href=&quot;../../utility/move&quot;&gt;move semantics&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;auto_ptr_ref&lt;/code&gt; 의 생성자 및 복사 할당 연산자 는 이름없는 임시에서 복사 및 &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; 을 할당 할 수 있도록 제공됩니다 . 복사 생성자 및 복사 할당 연산자는 인수를 상수가 아닌 참조로 사용하므로 rvalue 인수를 직접 바인딩 할 수 없습니다. 그러나 &lt;strong&gt;사용자 정의 변환&lt;/strong&gt; (원래 auto_ptr을 릴리스 함)을 실행 한 다음 &lt;code&gt;auto_ptr_ref&lt;/code&gt; 를 값 으로 사용하는 생성자 또는 복사 할당 연산자를 호출 할 수 있습니다 . 이것은 &lt;a href=&quot;../../utility/move&quot;&gt;이동 의미론&lt;/a&gt; 의 초기 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="e8f96a3d02cb90d6715ab5ee42669b5a65f12ea9" translate="yes" xml:space="preserve">
          <source>The constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, T0&amp;gt;::value&lt;/code&gt; or &lt;code&gt;std::convertible&amp;lt;U2&amp;amp;&amp;amp;, T1&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, T0&amp;gt;::value&lt;/code&gt; &amp;lt;U1 &amp;amp;&amp;amp;, T0&amp;gt; :: value 또는 &lt;code&gt;std::convertible&amp;lt;U2&amp;amp;&amp;amp;, T1&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 생성자가 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01f5f9ea7415bf4964b071d1eb2b717e453d8da5" translate="yes" xml:space="preserve">
          <source>The constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;Ui&amp;amp;&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for at least one &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;Ui&amp;amp;&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; &amp;lt;Ui &amp;amp;&amp;amp;, Ti&amp;gt; :: value 가 하나 이상의 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;false&lt;/code&gt; 인 경우에만 생성자가 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fe1411ae2f665498529ac31d9d3be15d2754663c" translate="yes" xml:space="preserve">
          <source>The constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const U1&amp;amp;, T0&amp;gt;::value&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const U2&amp;amp;, T1&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const U1&amp;amp;, T0&amp;gt;::value&lt;/code&gt; &amp;lt;const U1 &amp;amp;, T0&amp;gt; :: value 또는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const U2&amp;amp;, T1&amp;gt;::value&lt;/code&gt; &amp;lt;const U2 &amp;amp;, T1&amp;gt; :: value 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 생성자가 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc9d995835de11c6c787cb53fba8d8c3e9580158" translate="yes" xml:space="preserve">
          <source>The constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ui&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for at least one &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ui&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; &amp;lt;const Ui &amp;amp;, Ti&amp;gt; :: value 가 하나 이상의 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;false&lt;/code&gt; 인 경우에만 생성자가 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c239dd429fef286118a0c7a58dcc760a8076f974" translate="yes" xml:space="preserve">
          <source>The constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;Ti&lt;/code&gt; is not implicitly default-constructible for at least one &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ti&lt;/code&gt; 가 적어도 하나의 &lt;code&gt;i&lt;/code&gt; 에 대해 암시 적으로 기본 구성 가능하지 않은 경우에만 생성자가 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4f909c3f83a20755845619fc1848878079ea4072" translate="yes" xml:space="preserve">
          <source>The constructor is not user-provided (i.e., is implicitly-defined or defaulted on its first declaration)</source>
          <target state="translated">생성자는 사용자가 제공하지 않습니다 (즉, 첫 번째 선언에서 암시 적으로 정의되거나 기본값 임)</target>
        </trans-unit>
        <trans-unit id="514317104edd617f7cd6ce3cacd4b37307e546c0" translate="yes" xml:space="preserve">
          <source>The constructor of the element is called with exactly the same arguments as supplied to the function, forwarded with &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">요소의 생성자는 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 전달 된 함수에 제공된 것과 정확히 동일한 인수로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0604af6f2180e7068eb4f4536ff23e9db48698f" translate="yes" xml:space="preserve">
          <source>The constructor of the element type (&lt;code&gt;value_type&lt;/code&gt;, that is, &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;) is called with exactly the same arguments as supplied to the function, forwarded with &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">요소 유형의 생성자 ( &lt;code&gt;value_type&lt;/code&gt; , 즉 &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; )는 함수에 제공된 것과 동일한 인수로 호출되며 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 전달됩니다 . . .</target>
        </trans-unit>
        <trans-unit id="14d17adea26e85b2515064aa28520a083e866af7" translate="yes" xml:space="preserve">
          <source>The constructors (14,16) accept a &lt;code&gt;std::chrono::choose&lt;/code&gt; parameter, but that parameter has no effect.</source>
          <target state="translated">생성자 (14,16)는 &lt;code&gt;std::chrono::choose&lt;/code&gt; 매개 변수를 허용하지만 해당 매개 변수는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecfd8f32fcd60ed391f596bc6ee25cc4c6697d5c" translate="yes" xml:space="preserve">
          <source>The constructors of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; that takes a filename argument, if the file cannot be opened.</source>
          <target state="translated">의 생성자 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 파일을 열 수없는 경우, 파일 이름 인수를합니다.</target>
        </trans-unit>
        <trans-unit id="aeb37a2c7445e4497668ad31fcdc968770634864" translate="yes" xml:space="preserve">
          <source>The constructors of &lt;code&gt;&lt;a href=&quot;../istrstream&quot;&gt;std::istrstream&lt;/a&gt;&lt;/code&gt; do not create the underlying &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; in dynamically allocated mode, so the memory leaks that are possible with &lt;code&gt;&lt;a href=&quot;../ostrstream/~ostrstream&quot;&gt;std::ostrstream::~ostrstream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../strstream/~strstream&quot;&gt;std::strstream::~strstream&lt;/a&gt;&lt;/code&gt; do not apply.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../istrstream&quot;&gt;std::istrstream&lt;/a&gt;&lt;/code&gt; 의 생성자는 동적으로 할당 된 모드에서 기본 &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 를 작성하지 않으므로 &lt;code&gt;&lt;a href=&quot;../ostrstream/~ostrstream&quot;&gt;std::ostrstream::~ostrstream&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../strstream/~strstream&quot;&gt;std::strstream::~strstream&lt;/a&gt;&lt;/code&gt; 으로 가능한 메모리 누수가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9c0b9aa6a8db5a697c059464e94148ae13b0c2c" translate="yes" xml:space="preserve">
          <source>The container manages the storage space that is allocated for its elements and provides member functions to access them, either directly or through iterators (objects with properties similar to pointers).</source>
          <target state="translated">컨테이너는 요소에 할당 된 저장 공간을 관리하고 직접 또는 반복자 (포인터와 비슷한 속성을 가진 개체)를 통해 해당 요소에 액세스 할 수있는 멤버 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="78f3618b6465868448ddccdd694c5e1c8cbbf120" translate="yes" xml:space="preserve">
          <source>The contents of two unordered containers &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal if the following conditions hold:</source>
          <target state="translated">다음과 같은 조건이 충족되면 정렬되지 않은 두 컨테이너 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용 은 같습니다.</target>
        </trans-unit>
        <trans-unit id="6328d65cc72658c8384891f87389511f792722f0" translate="yes" xml:space="preserve">
          <source>The control block is a dynamically-allocated object that holds:</source>
          <target state="translated">제어 블록은 다음을 보유한 동적으로 할당 된 객체입니다.</target>
        </trans-unit>
        <trans-unit id="dabf7c953c7e4ef8b33706dcb060c8334571b8bb" translate="yes" xml:space="preserve">
          <source>The controlled character sequence is an array of &lt;code&gt;CharT&lt;/code&gt; which, at all times, represents a subsequence, or a &quot;window&quot; into the associated character sequence. Its state is described by three pointers:</source>
          <target state="translated">제어 문자 시퀀스는 항상 문자 시퀀스 의 하위 시퀀스 또는 &quot;창&quot;을 나타내는 &lt;code&gt;CharT&lt;/code&gt; 배열입니다 . 상태는 세 개의 포인터로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="26cfcc6f2a939bd6cff12f0bbc7b5ff915a1d154" translate="yes" xml:space="preserve">
          <source>The conversion function (3) is provided so that APIs that accept &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; file names can use pathnames with no changes to code.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 파일 이름 을 허용하는 API가 코드를 변경하지 않고 경로 이름을 사용할 수 있도록 변환 함수 (3)가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b236ef4c5579332c47d6d813a0a9ffeca01e240" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, and &lt;code&gt;l[&lt;/code&gt; perform multibyte-to-wide character conversion as if by calling &lt;a href=&quot;../../string/multibyte/mbrtowc&quot;&gt;&lt;code&gt;mbrtowc()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="translated">변환 지정자 &lt;code&gt;lc&lt;/code&gt; , &lt;code&gt;ls&lt;/code&gt; 및 &lt;code&gt;l[&lt;/code&gt; 은 첫 번째 문자가 변환되기 전에 &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt; &lt;code&gt;mbstate_t&lt;/code&gt; &lt;/a&gt; 객체가 0으로 초기화 된 &lt;a href=&quot;../../string/multibyte/mbrtowc&quot;&gt; &lt;code&gt;mbrtowc()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것처럼 멀티 바이트에서 문자 전체로의 문자 변환을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="03ad1fb8a3c33fbbff42de235e51664745451da8" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;[&lt;/code&gt; always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of &lt;code&gt;%s&lt;/code&gt; or &lt;code&gt;%[&lt;/code&gt;, without specifying the destination array size, is as unsafe as &lt;code&gt;&lt;a href=&quot;gets&quot;&gt;std::gets&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">변환 지정자 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;[&lt;/code&gt; 는 항상 일치하는 문자 외에 널 종료자를 저장합니다. 대상 배열의 크기는 지정된 필드 너비보다 하나 이상 커야합니다. 대상 배열 크기를 지정하지 않고 &lt;code&gt;%s&lt;/code&gt; 또는 &lt;code&gt;%[&lt;/code&gt; 사용 하면 &lt;code&gt;&lt;a href=&quot;gets&quot;&gt;std::gets&lt;/a&gt;&lt;/code&gt; 만큼 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ac471b8f3e3680d0aea88efb3834381526f7e2d3" translate="yes" xml:space="preserve">
          <source>The conversions &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; output &lt;code&gt;INF&lt;/code&gt;, &lt;code&gt;INFINITY&lt;/code&gt;, &lt;code&gt;NAN&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddff1bdc6fe2f15d06629502821413709da3be1a" translate="yes" xml:space="preserve">
          <source>The copy assignment operator for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">다음 사항이 모두 해당되는 경우 클래스 &lt;code&gt;T&lt;/code&gt; 의 복사 할당 연산자 는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="3cf1f689dd70b42e124541368f97c7780c6e3e34" translate="yes" xml:space="preserve">
          <source>The copy assignment operator is called whenever selected by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, e.g. when an object appears on the left side of an assignment expression.</source>
          <target state="translated">복사 할당 연산자는 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결에&lt;/a&gt; 의해 선택 될 때마다 ( 예 : 객체가 할당 표현식의 왼쪽에 나타날 때) 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="759dc17da3835f27b9a0abba76c5a7f15c67c981" translate="yes" xml:space="preserve">
          <source>The copy assignment operator is defined as deleted (and the move assignment operator is not declared). Closure types are not &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">복사 할당 연산자는 삭제 된 것으로 정의되며 이동 할당 연산자는 선언되지 않습니다. 클로저 유형은 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="3d5feaf369ec23df58930d6d9b201805ada42f07" translate="yes" xml:space="preserve">
          <source>The copy constructor and the move constructor are implicitly-declared(until C++14)declared as defaulted(since C++14) and may be implicitly-defined according to the usual rules for &lt;a href=&quot;copy_constructor&quot;&gt;copy constructors&lt;/a&gt; and &lt;a href=&quot;move_constructor&quot;&gt;move constructors&lt;/a&gt;.</source>
          <target state="translated">복사 생성자와 이동 생성자는 C ++ 14 이후로 기본으로 선언되어 (C ++ 14까지) 암시 적으로 선언되며 &lt;a href=&quot;copy_constructor&quot;&gt;복사 생성자&lt;/a&gt; 와 &lt;a href=&quot;move_constructor&quot;&gt;이동 생성자에&lt;/a&gt; 대한 일반적인 규칙에 따라 암시 적으로 정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1fbbb2f2a9873d3581231edb6a3bf3f2f9295e5" translate="yes" xml:space="preserve">
          <source>The copy constructor for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following are true:</source>
          <target state="translated">다음에 모두 해당되는 경우 클래스 &lt;code&gt;T&lt;/code&gt; 의 복사 생성자 는 사소합니다.</target>
        </trans-unit>
        <trans-unit id="5a61f82e1090e197177cd4889d3439e454755975" translate="yes" xml:space="preserve">
          <source>The copy constructor is called whenever an object is &lt;a href=&quot;initialization&quot;&gt;initialized&lt;/a&gt; (by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; or &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;) from another object of the same type (unless &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; selects a better match or the call is &lt;a href=&quot;copy_elision&quot;&gt;elided&lt;/a&gt;), which includes.</source>
          <target state="translated">복사 생성자는 동일한 유형의 다른 객체에서 객체를 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; ( &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 또는 &lt;a href=&quot;copy_initialization&quot;&gt;복사 &lt;/a&gt;초기화에 의해) 할 때마다 호출 됩니다 ( &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해상도&lt;/a&gt; 가 더 나은 일치를 선택하거나 호출이 &lt;a href=&quot;copy_elision&quot;&gt;생략&lt;/a&gt; 되지 않는 한 ).</target>
        </trans-unit>
        <trans-unit id="8507794644c0362a07d03e6394dd36e5ccb79ce2" translate="yes" xml:space="preserve">
          <source>The copy deduction candidate is preferred over all other function templates implicitly generated from a constructor or constructor template.</source>
          <target state="translated">사본 공제 후보는 생성자 또는 생성자 템플릿에서 암시 적으로 생성 된 다른 모든 함수 템플릿보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="747997a874ad1f7bc25037668246d169dc11dcd1" translate="yes" xml:space="preserve">
          <source>The copy of the underlying string returned by &lt;code&gt;str&lt;/code&gt; is a temporary object that will be destructed at the end of the expression, so directly calling &lt;a href=&quot;../../string/basic_string/c_str&quot;&gt;&lt;code&gt;c_str()&lt;/code&gt;&lt;/a&gt; on the result of &lt;code&gt;str()&lt;/code&gt; (for example in &lt;code&gt;auto *ptr = out.str().c_str();&lt;/code&gt;) results in a dangling pointer.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 에 의해 리턴 된 기본 문자열의 사본은 표현식의 끝에 소멸 될 임시 오브젝트이므로 &lt;code&gt;str()&lt;/code&gt; 결과에서 직접 &lt;a href=&quot;../../string/basic_string/c_str&quot;&gt; &lt;code&gt;c_str()&lt;/code&gt; &lt;/a&gt; 을 호출합니다 (예 : &lt;code&gt;auto *ptr = out.str().c_str();&lt;/code&gt; )은 매달려 포인터를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="60d00a31f5602765e3302a63438e51d4f9449061" translate="yes" xml:space="preserve">
          <source>The copy-initialization of the result of the function call is &lt;a href=&quot;eval_order&quot;&gt;sequenced-before&lt;/a&gt; the destruction of all temporaries at the end of expression, which, in turn, is</source>
          <target state="translated">함수 호출 결과의 복사 초기화는 &lt;a href=&quot;eval_order&quot;&gt;시퀀스가 끝나기 전에&lt;/a&gt; 모든 임시가 파괴 되기 전에 순서화 됩니다.</target>
        </trans-unit>
        <trans-unit id="fa429f3126d475d851da7e1318884700c1618d55" translate="yes" xml:space="preserve">
          <source>The coroutine is suspended (its coroutine state is populated with local variables and current suspension point).</source>
          <target state="translated">코 루틴은 일시 중단됩니다 (코 루틴 상태는 지역 변수 및 현재 중단 지점으로 채워짐).</target>
        </trans-unit>
        <trans-unit id="f93ab229d575b110c0f62720474d6f4ce532847b" translate="yes" xml:space="preserve">
          <source>The correct conversion specifications for the &lt;a href=&quot;../../types/integer&quot;&gt;fixed-width integer types&lt;/a&gt; (&lt;code&gt;int8_t&lt;/code&gt;, etc) are defined in the header &lt;a href=&quot;../../types/integer&quot;&gt;&amp;lt;cinttypes&amp;gt;&lt;/a&gt; (although &lt;a href=&quot;../../types/integer&quot;&gt;&lt;code&gt;SCNdMAX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../types/integer&quot;&gt;&lt;code&gt;SCNuMAX&lt;/code&gt;&lt;/a&gt;, etc is synonymous with &lt;code&gt;%jd&lt;/code&gt;, &lt;code&gt;%ju&lt;/code&gt;, etc).</source>
          <target state="translated">&lt;a href=&quot;../../types/integer&quot;&gt;고정 폭 정수 유형&lt;/a&gt; ( &lt;code&gt;int8_t&lt;/code&gt; 등)에 대한 올바른 변환 스펙은 &lt;a href=&quot;../../types/integer&quot;&gt;&amp;lt;cinttypes&amp;gt;&lt;/a&gt; 헤더에 정의되어 있습니다 ( &lt;a href=&quot;../../types/integer&quot;&gt; &lt;code&gt;SCNdMAX&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../types/integer&quot;&gt; &lt;code&gt;SCNuMAX&lt;/code&gt; &lt;/a&gt; 등은 &lt;code&gt;%jd&lt;/code&gt; , &lt;code&gt;%ju&lt;/code&gt; 등과 동의어 임).</target>
        </trans-unit>
        <trans-unit id="15db9249b70354b71fe537b88d8394bd5d81be93" translate="yes" xml:space="preserve">
          <source>The correct conversion specifications for the fixed-width character types (&lt;code&gt;int8_t&lt;/code&gt;, etc) are defined in the header &lt;a href=&quot;../../types/integer&quot;&gt;&amp;lt;cinttypes&amp;gt;&lt;/a&gt; (although &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;PRIdMAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;PRIuMAX&lt;/a&gt;&lt;/code&gt;, etc is synonymous with &lt;code&gt;%jd&lt;/code&gt;, &lt;code&gt;%ju&lt;/code&gt;, etc).</source>
          <target state="translated">고정 너비 문자 유형 ( &lt;code&gt;int8_t&lt;/code&gt; 등)에 대한 올바른 변환 스펙은 &lt;a href=&quot;../../types/integer&quot;&gt;&amp;lt;cinttypes&amp;gt;&lt;/a&gt; 헤더에 정의되어 있습니다 ( &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;PRIdMAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;PRIuMAX&lt;/a&gt;&lt;/code&gt; 등은 &lt;code&gt;%jd&lt;/code&gt; , &lt;code&gt;%ju&lt;/code&gt; 등과 동의어 임).</target>
        </trans-unit>
        <trans-unit id="5bd87815b2a9528ae12a41f936a8bbc8434e62a1" translate="yes" xml:space="preserve">
          <source>The correct length of the buffer that can receive the entire transformed string is &lt;code&gt;1+std::strxfrm(nullptr, src, 0)&lt;/code&gt;.</source>
          <target state="translated">전체 변환 된 문자열을 수신 할 수있는 버퍼의 올바른 길이는 &lt;code&gt;1+std::strxfrm(nullptr, src, 0)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab2bb50ec090349b366ef17811496ea35381fbec" translate="yes" xml:space="preserve">
          <source>The correct length of the buffer that can receive the entire transformed string is &lt;code&gt;1+std::wcsxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt;.</source>
          <target state="translated">변환 된 전체 문자열을 수신 할 수있는 올바른 버퍼 길이는 &lt;code&gt;1+std::wcsxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f06dc76e6d4b421ddcd6b60d3ed2303369b4928" translate="yes" xml:space="preserve">
          <source>The correct result can be represented as &lt;code&gt;int&lt;/code&gt; on all known implementations. For overflow to occur, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; must be less than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LDBL_MAX_EXP&lt;/a&gt;*log2(&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; must be greater than &lt;code&gt;LDBL_MIN_EXP-&lt;a href=&quot;../../types/climits&quot;&gt;LDBL_MANT_DIG&lt;/a&gt;)*log2(&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">모든 알려진 구현에서 올바른 결과를 &lt;code&gt;int&lt;/code&gt; 로 표시 할 수 있습니다 . 발생하는 오버 플로우, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 는 이하이어야 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LDBL_MAX_EXP&lt;/a&gt;*log2(&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; 가 보다 커야 &lt;code&gt;LDBL_MIN_EXP-&lt;a href=&quot;../../types/climits&quot;&gt;LDBL_MANT_DIG&lt;/a&gt;)*log2(&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7284c934a898f61fc7b831e55a0c35b87058795" translate="yes" xml:space="preserve">
          <source>The corresponding type/type templates &lt;code&gt;std::in_place_t&lt;/code&gt;, &lt;code&gt;std::in_place_type_t&lt;/code&gt; and &lt;code&gt;std::in_place_index_t&lt;/code&gt; can be used in the constructor's parameter list to match the intended tag.</source>
          <target state="translated">해당 유형 / 유형 템플릿 &lt;code&gt;std::in_place_t&lt;/code&gt; , &lt;code&gt;std::in_place_type_t&lt;/code&gt; 및 &lt;code&gt;std::in_place_index_t&lt;/code&gt; 를 생성자의 매개 변수 목록에서 사용하여 원하는 태그와 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="942cf9ae9a6d3badc39db24111513090bfb3dd85" translate="yes" xml:space="preserve">
          <source>The cosine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the cosine is cos z =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927374ff66f57aae8836497c2fe39e3cbac93b0e" translate="yes" xml:space="preserve">
          <source>The count and order of floating-point exceptions can be changed by optimization as long as the state as observed by the next floating-point operation is as if no optimization took place:</source>
          <target state="translated">부동 소수점 예외의 수와 순서는 다음 부동 소수점 연산에서 관찰 된 상태가 최적화가 수행되지 않은 것처럼 최적화에 의해 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d17f1800fe564bddef91d5783b748d674aa9406" translate="yes" xml:space="preserve">
          <source>The creator of the asynchronous operation can then use a variety of methods to query, wait for, or extract a value from the &lt;code&gt;std::future&lt;/code&gt;. These methods may block if the asynchronous operation has not yet provided a value.</source>
          <target state="translated">그런 다음 비동기 조작의 작성자는 다양한 메소드를 사용하여 &lt;code&gt;std::future&lt;/code&gt; 에서 값을 조회, 대기 또는 추출 할 수 있습니다 . 비동기 작업이 아직 값을 제공하지 않은 경우 이러한 메서드가 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92bfef5342feb04a9c90c296a397274c28f936b5" translate="yes" xml:space="preserve">
          <source>The currency input manipulator &lt;code&gt;&lt;a href=&quot;../manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; (technically, &lt;a href=&quot;../../locale/money_get/get&quot;&gt;&lt;code&gt;money_get::get&lt;/code&gt;&lt;/a&gt; it calls), if the input cannot be unambiguously parsed as a monetary value according to the locale rules.</source>
          <target state="translated">로케일 규칙에 따라 입력을 모호한 값으로 구문 분석 할 수없는 경우 통화 입력 조작기 &lt;code&gt;&lt;a href=&quot;../manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; (기술적으로 &lt;a href=&quot;../../locale/money_get/get&quot;&gt; &lt;code&gt;money_get::get&lt;/code&gt; &lt;/a&gt; 호출)입니다.</target>
        </trans-unit>
        <trans-unit id="60d7384005cbe496491d405e29d20256cd29de8c" translate="yes" xml:space="preserve">
          <source>The currency units are assumed to be the smallest non-fractional units of the currency: cents in the U.S, yen in Japan.</source>
          <target state="translated">통화 단위는 통화 중 가장 작은 비 분수 단위 인 것으로 가정합니다 (미국의 센트, 일본의 엔).</target>
        </trans-unit>
        <trans-unit id="d4158a75280f5053658832132f5cd7d688bb28fb" translate="yes" xml:space="preserve">
          <source>The currency units are assumed to be the smallest non-fractional units of the currency: cents in the U.S, yen in Japan. Thus, the input sequence &lt;code&gt;&quot;$1,056.23&quot;&lt;/code&gt; in a U.S. locale produces the number &lt;code&gt;105623.0&lt;/code&gt; in &lt;code&gt;units&lt;/code&gt; or a string &lt;code&gt;&quot;105623&quot;&lt;/code&gt; in &lt;code&gt;digits&lt;/code&gt;.</source>
          <target state="translated">통화 단위는 통화 중 가장 작은 비 분수 단위 인 것으로 가정합니다 (미국의 센트, 일본의 엔). 따라서 미국 로케일 의 입력 시퀀스 &lt;code&gt;&quot;$1,056.23&quot;&lt;/code&gt; &lt;code&gt;&quot;105623&quot;&lt;/code&gt; 은 &lt;code&gt;digits&lt;/code&gt; &lt;code&gt;105623.0&lt;/code&gt; 을 &lt;code&gt;units&lt;/code&gt; 또는 문자열 &quot;105623&quot; 을 숫자로 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="333d83e6dc8a3ed3cddeaf85bad80a985040ae63" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt; has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dbf260b47d386ab70f9b32ae1d1e7e30e36d36b" translate="yes" xml:space="preserve">
          <source>The current conversion state.</source>
          <target state="translated">현재 변환 상태입니다.</target>
        </trans-unit>
        <trans-unit id="270d038a0d8b5445d8fe511402abe8b8a19d1179" translate="yes" xml:space="preserve">
          <source>The current execution agent should hold the lock &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">현재 실행 에이전트는 잠금 &lt;code&gt;m&lt;/code&gt; 을 보유해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3ddd134a5cf65243121b9adc3ce8ef2cf27721d8" translate="yes" xml:space="preserve">
          <source>The current fill character may be obtained with &lt;code&gt;&lt;a href=&quot;../basic_ios/fill&quot;&gt;std::ostream::fill&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 채우기 문자는 &lt;code&gt;&lt;a href=&quot;../basic_ios/fill&quot;&gt;std::ostream::fill&lt;/a&gt;&lt;/code&gt; 로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7889788802b761b8ce955626e89d30674dbd0e9c" translate="yes" xml:space="preserve">
          <source>The current locale associated with the regular expression.</source>
          <target state="translated">정규식과 연관된 현재 로캘입니다.</target>
        </trans-unit>
        <trans-unit id="838b6a57f873b1fccedf43d2b0bf89f6151e0997" translate="yes" xml:space="preserve">
          <source>The current locale of the traits object.</source>
          <target state="translated">특성 오브젝트의 현재 로케일.</target>
        </trans-unit>
        <trans-unit id="a3636f5f0c0e84e9153d12d1e93ae93fb45d2fd6" translate="yes" xml:space="preserve">
          <source>The current object (&lt;code&gt;*this&lt;/code&gt;) can be implicitly captured if either capture default is present. If implicitly captured, it is always captured by reference, even if the capture default is &lt;code&gt;=&lt;/code&gt;. The implicit capture of &lt;code&gt;*this&lt;/code&gt; when the capture default is &lt;code&gt;=&lt;/code&gt; is deprecated.(since C++20).</source>
          <target state="translated">캡처 기본값이 존재하면 현재 오브젝트 ( &lt;code&gt;*this&lt;/code&gt; )를 내재적으로 캡처 할 수 있습니다. 내재적으로 캡처 된 경우 캡처 기본값이 &lt;code&gt;=&lt;/code&gt; 인 경우에도 항상 참조로 캡처됩니다 . 캡처 기본값이 &lt;code&gt;=&lt;/code&gt; 일 때 &lt;code&gt;*this&lt;/code&gt; 의 암시 적 캡처 는 더 이상 사용되지 않습니다 (C ++ 20부터).</target>
        </trans-unit>
        <trans-unit id="ad54e387479c8cb969d50cc66d7fa3a22bc9d706" translate="yes" xml:space="preserve">
          <source>The current path as returned by many operating systems is a dangerous global variable. It may be changed unexpectedly by third-party or system library functions, or by another thread.</source>
          <target state="translated">많은 운영 체제에서 반환되는 현재 경로는 위험한 전역 변수입니다. 타사 또는 시스템 라이브러리 기능이나 다른 스레드에 의해 예기치 않게 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a32812c167e23e9a138bf52141f02726895565b" translate="yes" xml:space="preserve">
          <source>The current position of the get pointer on success, &lt;code&gt;pos_type(-1)&lt;/code&gt; on failure.</source>
          <target state="translated">성공시 get 포인터의 현재 위치, 실패시 &lt;code&gt;pos_type(-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcd990c0fc482fb45b1d3492d0748ec8b63e5c22" translate="yes" xml:space="preserve">
          <source>The current rounding mode affects the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430695fef50ce6b9934160789eacb1237ee74fd7" translate="yes" xml:space="preserve">
          <source>The current rounding mode does NOT affect the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0cc9de998b3b2b254e8bf7182d9e5712a8d0e5" translate="yes" xml:space="preserve">
          <source>The current rounding mode, reflecting the effects of the most recent &lt;code&gt;fesetround&lt;/code&gt;, can also be queried with &lt;code&gt;&lt;a href=&quot;../../types/climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가장 최근 &lt;code&gt;fesetround&lt;/code&gt; 의 효과를 반영하는 현재 반올림 모드 도 &lt;code&gt;&lt;a href=&quot;../../types/climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; 로 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="c59c1acaef9b3f40eb4278b9627af71fb04d4d02" translate="yes" xml:space="preserve">
          <source>The current value if &lt;code&gt;*this&lt;/code&gt; has a value, or &lt;code&gt;default_value&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 값이 있으면 현재 값 , 그렇지 않으면 &lt;code&gt;default_value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a689e4fd251e8da5a9a254dcb9427a1223639603" translate="yes" xml:space="preserve">
          <source>The current value of the atomic variable.</source>
          <target state="translated">원자 변수의 현재 값.</target>
        </trans-unit>
        <trans-unit id="6c7d8a7a94fc01bbb7eea5c0e317c1703f34fd70" translate="yes" xml:space="preserve">
          <source>The current value of the referenced object.</source>
          <target state="translated">참조 된 객체의 현재 값</target>
        </trans-unit>
        <trans-unit id="26235287e585eec8570ed00a3d99c3482814f00a" translate="yes" xml:space="preserve">
          <source>The current working directory is the directory, associated with the process, that is used as the starting location in pathname resolution for relative paths.</source>
          <target state="translated">현재 작업 디렉토리는 프로세스와 연관된 디렉토리이며 상대 경로의 경로 이름 분석에서 시작 위치로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c2e989156adf075647db2bbb3a0ace08ea4fdf8" translate="yes" xml:space="preserve">
          <source>The currently installed</source>
          <target state="translated">현재 설치된</target>
        </trans-unit>
        <trans-unit id="4f2c122b6d6e472425a6c170dde1110ad507b7a0" translate="yes" xml:space="preserve">
          <source>The currently installed &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 설치된 &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b4bd18550ac3d44de3e81a240bd6b990bb8c28e" translate="yes" xml:space="preserve">
          <source>The currently installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 설치된 &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a322ed62540daa71393f9a489dc06b4e4497bec8" translate="yes" xml:space="preserve">
          <source>The custom streambuf classes that do not use the get area and do not set the get area pointers in basic_streambuf are required to override this function.</source>
          <target state="translated">get 영역을 사용하지 않고 basic_streambuf에서 get 영역 포인터를 설정하지 않은 사용자 정의 streambuf 클래스는이 함수를 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e2014e10ac3def5949d4073de444574acf0086c" translate="yes" xml:space="preserve">
          <source>The cv-T templates (3-5) are SFINAE-friendly: if &lt;code&gt;std::tuple_size&amp;lt;T&amp;gt;::value&lt;/code&gt; is ill-formed when treated as an unevaluated operand, (3-5) do not provide the member &lt;code&gt;value&lt;/code&gt;. Access checking is performed as if in a context unrelated to &lt;code&gt;tuple_size&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;. Only the validity of the immediate context of the expression is considered. This allows.</source>
          <target state="translated">cv-T 템플릿 (3-5)은 SFINAE에 적합합니다. &lt;code&gt;std::tuple_size&amp;lt;T&amp;gt;::value&lt;/code&gt; 가 평가되지 않은 피연산자로 처리 될 때 잘못된 값 이 형성되면 (3-5)는 멤버 &lt;code&gt;value&lt;/code&gt; 제공하지 않습니다 . &lt;code&gt;tuple_size&lt;/code&gt; 및 &lt;code&gt;T&lt;/code&gt; 와 관련이없는 컨텍스트 에서처럼 액세스 점검이 수행됩니다 . 표현의 즉각적인 맥락의 타당성 만 고려됩니다. 이것은 허용합니다.</target>
        </trans-unit>
        <trans-unit id="afe86358b8ce8ed3f21d2c8bdc99573b37f7b88a" translate="yes" xml:space="preserve">
          <source>The day value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 저장된 일 값 .</target>
        </trans-unit>
        <trans-unit id="5a9a7ddae9e9233b0fb8ad54cb826d1d5361ecfc" translate="yes" xml:space="preserve">
          <source>The deallocation function's name is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; in the scope of the dynamic type of the object pointed to by expression, which means class-specific deallocation functions, if present, are found before the global ones. If &lt;code&gt;::&lt;/code&gt; is present in the &lt;code&gt;delete&lt;/code&gt; expression, only the global namespace is examined by this lookup.</source>
          <target state="translated">할당 해제 함수의 이름은 식으로 가리키는 객체의 동적 유형 범위에서 &lt;a href=&quot;lookup&quot;&gt;조회&lt;/a&gt; 됩니다. 즉, 클래스 별 할당 해제 함수가있는 경우 전역 함수보다 먼저 클래스 별 할당 해제 함수를 찾습니다. 경우 &lt;code&gt;::&lt;/code&gt; 에 존재 &lt;code&gt;delete&lt;/code&gt; 표현 만 글로벌 네임 스페이스는이 조회에 의해 검토된다.</target>
        </trans-unit>
        <trans-unit id="ee3d0e0dfebc3a5c800bd21f9ce6cc65f9cb2736" translate="yes" xml:space="preserve">
          <source>The decimal value &lt;code&gt;0.1&lt;/code&gt; cannot be represented by a binary floating-point type. When stored in an IEEE-745 &lt;code&gt;double&lt;/code&gt;, it falls between 0x1.9999999999999*2-4</source>
          <target state="translated">10 진수 값 &lt;code&gt;0.1&lt;/code&gt; 은 이진 부동 소수점 유형으로 나타낼 수 없습니다. IEEE-745 &lt;code&gt;double&lt;/code&gt; 에 저장 될 때 0x1.9999999999999 * 2-4 사이입니다.</target>
        </trans-unit>
        <trans-unit id="438a3580e45d17ab77478ad47bf10a993c0cab45" translate="yes" xml:space="preserve">
          <source>The declaration inside the class body is not a definition and may declare the member to be of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt; (other than &lt;code&gt;void&lt;/code&gt;), including the type in which the member is declared:</source>
          <target state="translated">클래스 본문 내부의 선언은 정의가 아니며 멤버가 선언 된 유형을 포함하여 멤버가 &lt;a href=&quot;incomplete_type&quot;&gt;불완전한 유형&lt;/a&gt; ( &lt;code&gt;void&lt;/code&gt; 이외 의 유형)으로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="940a93324f0b867fc22c005f3cbb33931f332b0f" translate="yes" xml:space="preserve">
          <source>The declared type of an array object might be an array of incomplete class type and therefore incomplete; if the class type is completed later on in the translation unit, the array type becomes complete; the array type at those two points is the same type.</source>
          <target state="translated">선언 된 배열 객체 유형은 불완전한 클래스 유형의 배열 일 수 있으므로 불완전합니다. 클래스 유형이 나중에 변환 단위에서 완료되면 배열 유형이 완료됩니다. 이 두 지점의 배열 유형은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d1ac1b1b8d3a334743e1a9098fcb2cea503e3b4c" translate="yes" xml:space="preserve">
          <source>The declared type of an array object might be an array of unknown bound and therefore be incomplete at one point in a translation unit and complete later on; the array types at those two points (&quot;array of unknown bound of &lt;code&gt;T&lt;/code&gt;&quot; and &quot;array of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;T&lt;/code&gt;&quot;) are different types.</source>
          <target state="translated">선언 된 배열 객체 유형은 알 수없는 바운드의 배열 일 수 있으므로 변환 단위의 한 지점에서 불완전하며 나중에 완료 될 수 있습니다. ( &quot;미지의 어레이의 결합이 두 지점에서 배열 형 &lt;code&gt;T&lt;/code&gt; &quot;및 &quot;어레이 &lt;code&gt;N&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; 는 &quot;) 다른 유형이다.</target>
        </trans-unit>
        <trans-unit id="18785b0480ebbad388b964ef9874663bccf996c2" translate="yes" xml:space="preserve">
          <source>The deduced types &lt;code&gt;V1&lt;/code&gt; and &lt;code&gt;V2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&lt;/code&gt; (the usual type transformations applied to arguments of functions passed by value) unless application of &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; results in &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; for some type &lt;code&gt;X&lt;/code&gt;, in which case the deduced type is &lt;code&gt;X&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">추론 된 유형 &lt;code&gt;V1&lt;/code&gt; 및 &lt;code&gt;V2&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; 결과를 적용하지 않는 한 값에 의해 전달 된 함수 인수에 적용되는 일반적인 유형 변환)입니다. 에서 &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; 어떤 종류의에 대한 &lt;code&gt;X&lt;/code&gt; 도출 된 유형 인 경우, &lt;code&gt;X&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e02493aa58b5b2fea63d5d88e4dcf79d58481e1" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;operator&amp;lt;&lt;/code&gt; is not defined for weak pointers, and may wrongly consider two shared pointers for the same object non-equivalent (see &lt;a href=&quot;shared_ptr/owner_before&quot;&gt;&lt;code&gt;shared_ptr::owner_before&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">기본 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 는 약한 포인터에 대해 정의되지 않았으며 동일한 객체에 해당하지 않는 두 개의 공유 포인터를 잘못 고려할 수 있습니다 ( &lt;a href=&quot;shared_ptr/owner_before&quot;&gt; &lt;code&gt;shared_ptr::owner_before&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="29a0f4f44719826deb8dc0997c1c24058144c7cf" translate="yes" xml:space="preserve">
          <source>The default allocator satisfies &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">기본 할당자는 &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;할당 기 완전성 요구 사항을 충족시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4141e9de4e7f5923913eec75a044f8b9df31d8c8" translate="yes" xml:space="preserve">
          <source>The default arguments are not part of the function type.</source>
          <target state="translated">기본 인수는 함수 유형의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="193be4dab5a8464a5f47fc22f793c70a383f5c19" translate="yes" xml:space="preserve">
          <source>The default base class version of this function does nothing and returns &lt;code&gt;Traits::eof()&lt;/code&gt; in all situations. This function is overridden by the derived classes: &lt;a href=&quot;../basic_stringbuf/pbackfail&quot;&gt;&lt;code&gt;basic_stringbuf::pbackfail&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_filebuf/pbackfail&quot;&gt;&lt;code&gt;basic_filebuf::pbackfail&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../strstreambuf/pbackfail&quot;&gt;&lt;code&gt;strstreambuf::pbackfail&lt;/code&gt;&lt;/a&gt;, and is expected to be overridden by user-defined and third-party library stream classes.</source>
          <target state="translated">이 함수의 기본 기본 클래스 버전은 아무 작업도 수행하지 않으며 모든 상황에서 &lt;code&gt;Traits::eof()&lt;/code&gt; 를 반환 합니다. 이 함수는 기본 클래스 : &lt;a href=&quot;../basic_stringbuf/pbackfail&quot;&gt; &lt;code&gt;basic_stringbuf::pbackfail&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../basic_filebuf/pbackfail&quot;&gt; &lt;code&gt;basic_filebuf::pbackfail&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../strstreambuf/pbackfail&quot;&gt; &lt;code&gt;strstreambuf::pbackfail&lt;/code&gt; &lt;/a&gt; 로 재정의되며 사용자 정의 및 타사 라이브러리 스트림 클래스로 재정의 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8be97a2a7f2ed1505287b3fbafa565875f570ad4" translate="yes" xml:space="preserve">
          <source>The default behavior of all atomic operations in the library provides for</source>
          <target state="translated">라이브러리에서 모든 원자 연산의 기본 동작은 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6c0727e16ebccb104329148ed9efcf925fc019d2" translate="yes" xml:space="preserve">
          <source>The default behavior when copying directories is the non-recursive copy: the files are copied, but not the subdirectories:</source>
          <target state="translated">디렉토리를 복사 할 때의 기본 동작은 비 재귀 복사입니다. 파일은 복사되지만 하위 디렉토리는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41ed6266dfe4ccf36594ee86ce0193a99a4725f3" translate="yes" xml:space="preserve">
          <source>The default buffer size &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is expected to be the most efficient buffer size for file I/O on the implementation, but POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html&quot;&gt;fstat&lt;/a&gt; often provides a better estimate.</source>
          <target state="translated">기본 버퍼 크기 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; 는 구현시 파일 I / O에 가장 효율적인 버퍼 크기 일 것으로 예상되지만 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html&quot;&gt;fstat는&lt;/a&gt; 종종 더 나은 추정치를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="40fb0d322cfae3c7c913c1207e551679519632db" translate="yes" xml:space="preserve">
          <source>The default constructor for class &lt;code&gt;T&lt;/code&gt; is trivial (i.e. performs no action) if all of the following is true:</source>
          <target state="translated">클래스 &lt;code&gt;T&lt;/code&gt; 의 기본 생성자 는 다음 사항이 모두 충족되면 사소합니다 (즉, 조치를 수행하지 않음).</target>
        </trans-unit>
        <trans-unit id="53354add7be5ca66a4d2ad5f4e234eb66514dd9e" translate="yes" xml:space="preserve">
          <source>The default constructor is implicitly deleted.</source>
          <target state="translated">기본 생성자는 암시 적으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b24fb4c8cd27ffea47b12b41d3f765329cbc2ae5" translate="yes" xml:space="preserve">
          <source>The default error condition for the current error value.</source>
          <target state="translated">현재 오류 값의 기본 오류 조건입니다.</target>
        </trans-unit>
        <trans-unit id="fce8e9993c66d49e40a3975ae3f5de563116be62" translate="yes" xml:space="preserve">
          <source>The default format, returned by the standard specializations of &lt;code&gt;&lt;a href=&quot;moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; 의 표준 전문화에 의해 리턴되는 기본 형식 은 &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="464a94cd50a559a4c8980f122d2681b9028dc369" translate="yes" xml:space="preserve">
          <source>The default implementation throws &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;. The user can install his own</source>
          <target state="translated">기본 구현은 &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 던집니다 . 사용자는 자신의 것을 설치할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="aa5a89dde13e753c4365b630f7ff4e96f11b95d8" translate="yes" xml:space="preserve">
          <source>The default operator&amp;lt;=&amp;gt; performs lexicographical comparison by successively comparing the base (left-to-right depth-first) and then non-static member (in declaration order) subobjects of T to compute &amp;lt;=&amp;gt;, recursively expanding array members (in order of increasing subscript), and stopping early when a not-equal result is found, that is:</source>
          <target state="translated">기본 연산자 &amp;lt;=&amp;gt;는 T의 기본 (왼쪽에서 오른쪽으로 깊이 우선)과 비 정적 멤버 (선언 순서로) 하위 오브젝트를 연속적으로 비교하여 &amp;lt;=&amp;gt;을 계산하고 사전에 배열 멤버를 확장하여 사전 식 비교를 수행합니다 ( 아래 첨자를 증가시키는 순서)와 같지 않은 결과가 발견되면 일찍 중지합니다.</target>
        </trans-unit>
        <trans-unit id="934ba14e25c2c69432aed545fd6f3960918b1e13" translate="yes" xml:space="preserve">
          <source>The default precision, as established by &lt;code&gt;&lt;a href=&quot;../basic_ios/init&quot;&gt;std::basic_ios::init&lt;/a&gt;&lt;/code&gt;, is 6.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_ios/init&quot;&gt;std::basic_ios::init&lt;/a&gt;&lt;/code&gt; 의해 설정된 기본 정밀도 는 6입니다.</target>
        </trans-unit>
        <trans-unit id="5f21b7a8c1842336105782e7b228650bb7d62be6" translate="yes" xml:space="preserve">
          <source>The default template argument is implicitly instantiated when the value of that default argument is needed, except if the template is used to name a function:</source>
          <target state="translated">기본 템플릿 인수는 템플릿을 사용하여 함수 이름을 지정하는 경우를 제외하고 해당 기본 인수의 값이 필요할 때 암시 적으로 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="6f94b9099a67a8b7153f8eb5fa084e3e3d0d2916" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;Align&lt;/code&gt; is the most stringent (the largest) alignment requirement for any object whose size is at most &lt;code&gt;Len&lt;/code&gt;. If the default value is not used, &lt;code&gt;Align&lt;/code&gt; must be the value of &lt;code&gt;alignof(T)&lt;/code&gt; for some type &lt;code&gt;T&lt;/code&gt;, or the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;Align&lt;/code&gt; 의 기본값 은 크기가 최대 &lt;code&gt;Len&lt;/code&gt; 인 모든 객체에 대해 가장 엄격한 (최대) 정렬 요구 사항입니다 . 기본값을 사용하지 않는 경우 &lt;code&gt;Align&lt;/code&gt; 은 일부 유형 &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;alignof(T)&lt;/code&gt; 값이어야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32242f67a115d2cb73f7cc2aae6abcb227097b42" translate="yes" xml:space="preserve">
          <source>The default, non-specialized, &lt;code&gt;allocator_traits&lt;/code&gt; contains the following members:</source>
          <target state="translated">특수화되지 않은 기본 &lt;code&gt;allocator_traits&lt;/code&gt; 에는 다음 멤버가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="08db4badb19637e5c90fde67592f886560c377c6" translate="yes" xml:space="preserve">
          <source>The default-constructed &lt;code&gt;std::istream_iterator&lt;/code&gt; is known as the</source>
          <target state="translated">기본 구성 &lt;code&gt;std::istream_iterator&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="a6a84857860a6d8c7cf3bb60aa439a703f3cc543" translate="yes" xml:space="preserve">
          <source>The default-constructed &lt;code&gt;std::istreambuf_iterator&lt;/code&gt; is known as the</source>
          <target state="translated">기본 구성 &lt;code&gt;std::istreambuf_iterator&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="e7c78c2f8446abe7827d7e9f5d4effa429c3448d" translate="yes" xml:space="preserve">
          <source>The default-constructed &lt;code&gt;std::negative_binomial_distribution&lt;/code&gt; is equivalent to the default-constructed &lt;code&gt;&lt;a href=&quot;../geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 구성 &lt;code&gt;std::negative_binomial_distribution&lt;/code&gt; 은 기본 구성 &lt;code&gt;&lt;a href=&quot;../geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0958dd627dea2d882852fe149df4d3a5f23bcd6" translate="yes" xml:space="preserve">
          <source>The default-constructed &lt;code&gt;std::regex_iterator&lt;/code&gt; is the end-of-sequence iterator. When a valid &lt;code&gt;std::regex_iterator&lt;/code&gt; is incremented after reaching the last match (&lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;), it becomes equal to the end-of-sequence iterator. Dereferencing or incrementing it further invokes undefined behavior.</source>
          <target state="translated">기본 구성 &lt;code&gt;std::regex_iterator&lt;/code&gt; 는 시퀀스 종료 반복기입니다. 마지막 일치에 도달 한 후 유효한 &lt;code&gt;std::regex_iterator&lt;/code&gt; 가 증가하면 ( &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 리턴 함 ) 시퀀스 끝 반복자와 같습니다. 이를 참조 해제하거나 늘리면 정의되지 않은 동작이 추가로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a6e5505129068a171635aca553122e602560750a" translate="yes" xml:space="preserve">
          <source>The default-constructed &lt;code&gt;std::regex_token_iterator&lt;/code&gt; is the end-of-sequence iterator. When a valid &lt;code&gt;std::regex_token_iterator&lt;/code&gt; is incremented after reaching the last submatch of the last match, it becomes equal to the end-of-sequence iterator. Dereferencing or incrementing it further invokes undefined behavior.</source>
          <target state="translated">기본 구성 &lt;code&gt;std::regex_token_iterator&lt;/code&gt; 는 시퀀스 종료 반복기입니다. 마지막 일치의 마지막 부분 일치에 도달 한 후 유효한 &lt;code&gt;std::regex_token_iterator&lt;/code&gt; 가 증가하면 시퀀스 끝 반복자와 같습니다. 이를 참조 해제하거나 늘리면 정의되지 않은 동작이 추가로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="af4d20797ae40eebe6bfcf29080bace8b370e336" translate="yes" xml:space="preserve">
          <source>The default-initialized &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; does not contain a &lt;code&gt;T&lt;/code&gt; object, and its only valid uses are destruction and initialization by &lt;code&gt;&lt;a href=&quot;../atomic_init&quot;&gt;std::atomic_init&lt;/a&gt;&lt;/code&gt;, see &lt;a href=&quot;http://wg21.link/lwg2334&quot;&gt;LWG 2334&lt;/a&gt;.</source>
          <target state="translated">기본 초기화 된 &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 에는 &lt;code&gt;T&lt;/code&gt; 객체가 포함되어 있지 않으며 &lt;code&gt;&lt;a href=&quot;../atomic_init&quot;&gt;std::atomic_init&lt;/a&gt;&lt;/code&gt; 의한 소멸 및 초기화 만 유효합니다 ( &lt;a href=&quot;http://wg21.link/lwg2334&quot;&gt;LWG 2334&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="6ddd15f3710b0463f2d6c635ce575542649ee4a4" translate="yes" xml:space="preserve">
          <source>The defaulted operator&amp;lt;=&amp;gt; is implicitly deleted and returns &lt;code&gt;void&lt;/code&gt; if not all base and member subobjects have a compiler-generated or user-declared operator&amp;lt;=&amp;gt; declared in their scope (i.e., as a nonstatic member or as a friend) whose result is one of the std:: comparison category types.</source>
          <target state="translated">기본 연산자 &amp;lt;=&amp;gt;는 암시 적으로 삭제되며 모든 기본 및 멤버 하위 오브젝트에 해당 범위 (예 : 비 정적 멤버 또는 친구)로 선언 된 컴파일러 생성 또는 사용자 선언 연산자 &amp;lt;=&amp;gt;가없는 경우 &lt;code&gt;void&lt;/code&gt; 를 리턴합니다. std :: 비교 카테고리 유형 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="754f96ac6dbea3e27f6af69cc55f56ae1f6bb28c" translate="yes" xml:space="preserve">
          <source>The definition of a concept has the form.</source>
          <target state="translated">개념의 정의는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="b026fa7b764c3afd596b6b85c52798554c6dc752" translate="yes" xml:space="preserve">
          <source>The definition of a pure virtual function may be provided (and must be provided if the pure virtual is the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;): the member functions of the derived class are free to call the abstract base's pure virtual function using qualified function id. This definition must be provided outside of the class body (the syntax of a function declaration doesn't allow both the pure specifier &lt;code&gt;= 0&lt;/code&gt; and a function body).</source>
          <target state="translated">순수 가상 함수의 정의가 제공 될 수 있으며 순수 가상이 &lt;a href=&quot;destructor&quot;&gt;소멸자 인&lt;/a&gt; 경우 제공되어야합니다 . 파생 클래스의 멤버 함수는 정규화 된 함수 ID를 사용하여 추상베이스의 순수 가상 함수를 자유롭게 호출 할 수 있습니다. 이 정의는 클래스 본문 외부에 제공되어야합니다 (함수 선언 구문은 순수 지정자 &lt;code&gt;= 0&lt;/code&gt; 및 함수 본문을 모두 허용하지 않습니다 ).</target>
        </trans-unit>
        <trans-unit id="2639f4da4854a71548a7d1bcd7dfbc226f8a2700" translate="yes" xml:space="preserve">
          <source>The definition of a template must be visible at the point of implicit instantiation, which is why template libraries typically provide all template definitions in the headers (e.g. &lt;a href=&quot;http://www.boost.org/doc/libs/release/more/getting_started/unix-variants.html#header-only-libraries&quot;&gt;most boost libraries are header-only&lt;/a&gt;).</source>
          <target state="translated">템플릿의 정의는 암시 적 인스턴스화 시점에서 볼 수 있어야합니다. 따라서 템플릿 라이브러리는 일반적으로 헤더의 모든 템플릿 정의를 제공합니다 (예 : &lt;a href=&quot;http://www.boost.org/doc/libs/release/more/getting_started/unix-variants.html#header-only-libraries&quot;&gt;대부분의 부스트 라이브러리는 헤더 전용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="627832562bf8dd374b20ff048dfc37aaca313b99" translate="yes" xml:space="preserve">
          <source>The definition of the macro &lt;code&gt;assert&lt;/code&gt; depends on another macro, &lt;code&gt;NDEBUG&lt;/code&gt;, which is not defined by the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e5c381bb2167a3dc5b2cd8a40fc1bcd4a9a8f5" translate="yes" xml:space="preserve">
          <source>The delete expression looks for appropriate deallocation function's name starting from the class scope (array form looks in the scope of the array element class) and proceeds to the global scope if no members are found as usual. Note, that as per &lt;a href=&quot;../../language/lookup&quot;&gt;name lookup rules&lt;/a&gt;, any deallocation functions declared in class scope hides all global deallocation functions.</source>
          <target state="translated">삭제 표현식은 클래스 범위에서 시작하여 적절한 할당 해제 함수의 이름을 찾고 (배열 양식은 배열 요소 클래스의 범위를 찾습니다) 평소와 같이 멤버를 찾지 못하면 전역 범위로 진행합니다. 참고 따라하는 것이 &lt;a href=&quot;../../language/lookup&quot;&gt;이름 조회 규칙&lt;/a&gt; , 어떤 할당 해제 함수는 클래스 범위의 가죽 모든 글로벌 해제 기능에 선언했다.</target>
        </trans-unit>
        <trans-unit id="a6dd83f7a9eb5844a97acba85f2085f664257285" translate="yes" xml:space="preserve">
          <source>The deleted definition of a function must be the first declaration in a translation unit: a previously-declared function cannot be redeclared as deleted:</source>
          <target state="translated">함수의 삭제 된 정의는 변환 단위에서 첫 번째 선언이어야합니다. 이전에 선언 된 함수는 삭제 된 것으로 다시 선언 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="79625de2d4737ec271475c5f2652df74da1cc9e6" translate="yes" xml:space="preserve">
          <source>The deleted implicitly-declared move constructor is ignored by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; (otherwise it would prevent copy-initialization from rvalue).</source>
          <target state="translated">삭제 된 암시 적으로 선언 된 이동 생성자는 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결에&lt;/a&gt; 의해 무시됩니다 (그렇지 않으면 r 값에서 복사 초기화를 방해 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="a4c65324c4875d15514b8e9ecd9c933b7a537755" translate="yes" xml:space="preserve">
          <source>The deprecated stream buffer &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; or the boost.IOStreams device &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array&quot;&gt;&lt;code&gt;boost::basic_array&lt;/code&gt;&lt;/a&gt; may be used to implement I/O buffering over a user-provided char array in portable manner.</source>
          <target state="translated">더 이상 사용되지 않는 스트림 버퍼 &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 또는 boost.IOStreams 장치 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array&quot;&gt; &lt;code&gt;boost::basic_array&lt;/code&gt; &lt;/a&gt; 사용하여 휴대용 방식으로 사용자 제공 char 배열에서 I / O 버퍼링을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d24d6075064d8a50287cbe8ac1382cdf84e9445f" translate="yes" xml:space="preserve">
          <source>The dereference operator &lt;code&gt;&lt;a href=&quot;operator_star_&quot;&gt;operator*()&lt;/a&gt;&lt;/code&gt; does not check if this optional contains a value, which may be more efficient than &lt;code&gt;value()&lt;/code&gt;.</source>
          <target state="translated">역 참조 연산자 &lt;code&gt;&lt;a href=&quot;operator_star_&quot;&gt;operator*()&lt;/a&gt;&lt;/code&gt; 는이 옵션에 &lt;code&gt;value()&lt;/code&gt; 보다 효율적인 값이 포함되어 있는지 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1e8797256c4b2164a537ac90920cb706eff3148b" translate="yes" xml:space="preserve">
          <source>The description above summarizes C++14; the C++11 phrasing required this function to return true for &lt;code&gt;'_'&lt;/code&gt; in all cases (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2018&quot;&gt;LWG issue 2018&lt;/a&gt;).</source>
          <target state="translated">위의 설명은 C ++ 14를 요약합니다. C ++ 11 문구 는 모든 경우 에 &lt;code&gt;'_'&lt;/code&gt; 에 대해 true를 반환하기 위해이 함수가 필요했습니다 ( &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2018&quot;&gt;LWG issue 2018&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="aeb40399c9bd04128464837d331638d1fc355f39" translate="yes" xml:space="preserve">
          <source>The description is formed by concatenating the following components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcd77025b866b3c4c83a4d439bb95c7cee206f7" translate="yes" xml:space="preserve">
          <source>The destination byte string must have enough space for the contents of both &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; plus the terminating null character, except that the size of &lt;code&gt;src&lt;/code&gt; is limited to &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">대상 바이트 문자열은 모두의 내용에 대한 충분한 공간이 있어야 &lt;code&gt;dest&lt;/code&gt; 및 &lt;code&gt;src&lt;/code&gt; 플러스 널 종료 문자의 크기 것을 제외하고 &lt;code&gt;src&lt;/code&gt; 제한됩니다 &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f996269c6c91d048a969204e9f5beea30d4fbab2" translate="yes" xml:space="preserve">
          <source>The destructor for a block-scope static variable &lt;a href=&quot;../utility/program/exit&quot;&gt;is called at program exit&lt;/a&gt;, but only if the initialization took place successfully.</source>
          <target state="translated">블록 범위 정적 변수의 소멸자 &lt;a href=&quot;../utility/program/exit&quot;&gt;는 프로그램 종료시 호출&lt;/a&gt; 되지만 초기화가 완료된 경우에만 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="075f75c9eecc69c36093fa569ae42f26ebb2974f" translate="yes" xml:space="preserve">
          <source>The destructor for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">다음의 모든 것이 사실이라면 클래스 &lt;code&gt;T&lt;/code&gt; 의 소멸자 는 사소한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f86d1d85f514080fcb96ed20ed8238a17c06c287" translate="yes" xml:space="preserve">
          <source>The destructor is called whenever an object's &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; ends, which includes.</source>
          <target state="translated">소멸자는 객체의 &lt;a href=&quot;lifetime&quot;&gt;수명이&lt;/a&gt; 끝날 때마다 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="54eb2596b68b59e708441b4aa090a04eba62c0f7" translate="yes" xml:space="preserve">
          <source>The destructor is implicitly-declared.</source>
          <target state="translated">소멸자는 암시 적으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="c0a4e9e001abc2037d151b9845f28ea4fc930aa5" translate="yes" xml:space="preserve">
          <source>The destructor is not user-provided (meaning, it is either implicitly declared, or explicitly defined as defaulted on its first declaration)</source>
          <target state="translated">소멸자는 사용자가 제공하지 않습니다 (즉, 암시 적으로 선언되거나 첫 번째 선언에서 기본값으로 명시 적으로 정의 됨)</target>
        </trans-unit>
        <trans-unit id="3a8e566468b65a1ebf9ff0b029900480496f2b3f" translate="yes" xml:space="preserve">
          <source>The destructor is not virtual (that is, the base class destructor is not virtual)</source>
          <target state="translated">소멸자는 가상이 아닙니다 (즉, 기본 클래스 소멸자는 가상이 아닙니다)</target>
        </trans-unit>
        <trans-unit id="458261b035739931db108ba91cd4532638391cea" translate="yes" xml:space="preserve">
          <source>The destructor may also be called directly, e.g. to destroy an object that was constructed using &lt;a href=&quot;new&quot;&gt;placement-new&lt;/a&gt; or through an allocator member function such as &lt;a href=&quot;../memory/allocator/destroy&quot;&gt;&lt;code&gt;std::allocator::destroy()&lt;/code&gt;&lt;/a&gt;, to destroy an object that was constructed through the allocator. Note that calling a destructor directly for an ordinary object, such as a local variable, invokes undefined behavior when the destructor is called again, at the end of scope.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;new&quot;&gt;새로운 배치를&lt;/a&gt; 사용하여 생성 된 객체를 삭제 하거나 &lt;a href=&quot;../memory/allocator/destroy&quot;&gt; &lt;code&gt;std::allocator::destroy()&lt;/code&gt; &lt;/a&gt; 와 같은 할당 자 멤버 함수를 통해 구축 자를 소멸하기 위해 소멸자를 직접 호출 할 수도 있습니다 . 로컬 변수와 같은 일반 객체에 대해 소멸자를 직접 호출하면 소멸자가 다시 호출 될 때 범위 끝에서 정의되지 않은 동작이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4502fcacc22944b0b09432612438be8c0275b298" translate="yes" xml:space="preserve">
          <source>The destructor of &lt;code&gt;shared_ptr&lt;/code&gt; decrements the number of shared owners of the control block. If that counter reaches zero, the control block calls the destructor of the managed object. The control block does not deallocate itself until the &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; counter reaches zero as well.</source>
          <target state="translated">&lt;code&gt;shared_ptr&lt;/code&gt; 의 소멸자 는 제어 블록의 공유 소유자 수를 감소시킵니다. 해당 카운터가 0에 도달하면 제어 블록은 관리 대상 객체의 소멸자를 호출합니다. &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 카운터가 0에 도달 할 때까지 제어 블록 자체가 할당 해제되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0917c40d42cac062339108eed6e37cece182eea8" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;&lt;a href=&quot;mem_fun&quot;&gt;std::mem_fun&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;std::mem_fun_ref&lt;/code&gt; is that the former produces an function wrapper that expects a pointer to an object, whereas the latter -- a reference.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mem_fun&quot;&gt;std::mem_fun&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;std::mem_fun_ref&lt;/code&gt; 의 차이점 은 전자가 객체에 대한 포인터를 기대하는 함수 래퍼를 생성하지만 후자는 참조를 생성한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6058d52ad00c0746ec1ad1da1557fe0705689144" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;std::mem_fun&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mem_fun_ref&quot;&gt;std::mem_fun_ref&lt;/a&gt;&lt;/code&gt; is that the former produces an function wrapper that expects a pointer to an object, whereas the latter -- a reference.</source>
          <target state="translated">&lt;code&gt;std::mem_fun&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;mem_fun_ref&quot;&gt;std::mem_fun_ref&lt;/a&gt;&lt;/code&gt; 의 차이점 은 전자가 객체에 대한 포인터를 기대하는 함수 래퍼를 생성하지만 후자는 참조를 생성한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5ba8b4357f540030cba655d1013e93e28d93026b" translate="yes" xml:space="preserve">
          <source>The difference in the end of lifetime rules between non-class objects (end of storage duration) and class objects (reverse order of construction) matters in the following example:</source>
          <target state="translated">비 클래스 객체 (저장소 종료 시간)와 클래스 객체 (역순 순서) 간의 수명 종료 규칙의 차이는 다음 예제에서 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0bf7172e6a4bcef6e12a87186821457084696b5a" translate="yes" xml:space="preserve">
          <source>The direct assignment expressions have the form.</source>
          <target state="translated">직접 할당 식의 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b53b64cd7da1a6979740160933c02e8651b8c0" translate="yes" xml:space="preserve">
          <source>The direct assignment operator expects a modifiable lvalue as its left operand and an rvalue expression or a</source>
          <target state="translated">직접 대입 연산자는 수정 가능한 lvalue를 왼쪽 피연산자와 rvalue 표현식 또는</target>
        </trans-unit>
        <trans-unit id="a55407eeb2aba5e6786966e2fad86845a4f5e832" translate="yes" xml:space="preserve">
          <source>The directory is not a symlink or following symlinks is enabled, i.e., at least one of the following is true:</source>
          <target state="translated">디렉토리가 심볼릭 링크가 아니거나 다음 심볼릭 링크가 활성화되었습니다. 즉, 다음 중 하나 이상에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="011ff0f04cb6429bed2a06b5971e01124d4494fd" translate="yes" xml:space="preserve">
          <source>The discard input function &lt;a href=&quot;../basic_istream/ignore&quot;&gt;&lt;code&gt;basic_istream::ignore&lt;/code&gt;&lt;/a&gt;, when reaching the end of the stream before reaching the specified delimiter character.</source>
          <target state="translated">지정된 분리 문자에 도달하기 전에 스트림 끝에 도달 할 때 삭제 입력 함수 &lt;a href=&quot;../basic_istream/ignore&quot;&gt; &lt;code&gt;basic_istream::ignore&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="521ac03ae5bf197fd5b4f4ddbf6b50c2626b2ab0" translate="yes" xml:space="preserve">
          <source>The discarded statement can &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;odr-use&lt;/a&gt; a variable that is not defined.</source>
          <target state="translated">폐기 된 명령문은 정의되지 않은 변수를 &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;odr-use&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e134b488338708adbe35dc6f4d20bf7cd200123" translate="yes" xml:space="preserve">
          <source>The disjunction of two constraints is formed by using the &lt;code&gt;||&lt;/code&gt; operator in the constraint expression.</source>
          <target state="translated">두 가지 제약 조건의 분리는 &lt;code&gt;||&lt;/code&gt; 제약 조건 식의 연산자.</target>
        </trans-unit>
        <trans-unit id="68f41be33670c3565e52cb96e38022893aa1cdef" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;a href=&quot;relation&quot;&gt;&lt;code&gt;Relation&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;StrictWeakOrder&lt;/code&gt; is purely semantic.</source>
          <target state="translated">구별 &lt;a href=&quot;relation&quot;&gt; &lt;code&gt;Relation&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;StrictWeakOrder&lt;/code&gt; 은 순수한 의미입니다.</target>
        </trans-unit>
        <trans-unit id="6196af8746fbee30da31e07deacfea4e0569daa7" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;code&gt;Invocable&lt;/code&gt; and &lt;code&gt;RegularInvocable&lt;/code&gt; is purely semantic.</source>
          <target state="translated">구별 &lt;code&gt;Invocable&lt;/code&gt; 및 &lt;code&gt;RegularInvocable&lt;/code&gt; 은 순수한 의미입니다.</target>
        </trans-unit>
        <trans-unit id="afbbb8042504013c96b3b97edfed1ef91e7ace3c" translate="yes" xml:space="preserve">
          <source>The distribution parameters:</source>
          <target state="translated">분포 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="81279522f7d541e3070aa500c24fe78eefb6c24f" translate="yes" xml:space="preserve">
          <source>The double version of fmod behaves as if implemented as follows.</source>
          <target state="translated">fmod의 이중 버전은 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2aa9913a5b5973e9bcc32bc90f31f144ec91b2db" translate="yes" xml:space="preserve">
          <source>The duration of the return type is computed from &lt;code&gt;Duration&lt;/code&gt; in an unspecified manner.</source>
          <target state="translated">반환 유형의 지속 기간은 지정되지 않은 방식으로 &lt;code&gt;Duration&lt;/code&gt; 에서 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="224a26be1cb2ca8b761f6b43c3bd250d6ddf7cac" translate="yes" xml:space="preserve">
          <source>The duration type of the clock.</source>
          <target state="translated">시계의 지속 시간 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5cdb764bc7295c1f4d084bc026f3ec18853785af" translate="yes" xml:space="preserve">
          <source>The effect is &lt;code&gt;!(p == np)&lt;/code&gt;.</source>
          <target state="translated">효과는 &lt;code&gt;!(p == np)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b46cc14cb598fc30b7c672fded9952f55c605bae" translate="yes" xml:space="preserve">
          <source>The effect is &lt;code&gt;!(p == q)&lt;/code&gt;.</source>
          <target state="translated">효과는 &lt;code&gt;!(p == q)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28ea249af8424387a5c1cccdc0914e50e0d1b9da" translate="yes" xml:space="preserve">
          <source>The effect is &lt;code&gt;(p == Type())&lt;/code&gt;.</source>
          <target state="translated">효과는 &lt;code&gt;(p == Type())&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4957aeb2112ce48fb45bc468858b3884a27fb1d1" translate="yes" xml:space="preserve">
          <source>The effect of instantiating the template &lt;code&gt;complex&lt;/code&gt; for any other type is unspecified.</source>
          <target state="translated">다른 유형에 대해 템플릿 &lt;code&gt;complex&lt;/code&gt; 를 인스턴스화하는 효과 는 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="623c86df314fad3dc454b46a30107d29e49dbd7f" translate="yes" xml:space="preserve">
          <source>The effect on &lt;code&gt;state&lt;/code&gt; is deliberately unspecified. In standard facets, it is used to maintain shift state like when calling &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt;, and is therefore updated to reflect the conversion state after the last processed external character, but a user-defined facet is free to use it to maintain any other state, e.g. count the number of special characters encountered.</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 에 대한 영향 은 의도적으로 지정되지 않았습니다. 표준 패싯에서는 &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt; 호출 할 때와 같이 시프트 상태를 유지하는 데 사용 되므로 마지막으로 처리 된 외부 문자 이후의 변환 상태를 반영하도록 업데이트되지만 사용자 정의 패싯은 다른 패싯을 유지하기 위해이를 자유롭게 사용할 수 있습니다. 상태, 예를 들어 발생하는 특수 문자 수를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="5d718ad3720c90a52928fc5cdcd648882bb8be80" translate="yes" xml:space="preserve">
          <source>The effect on &lt;code&gt;state&lt;/code&gt; is deliberately unspecified. In standard facets, it is used to maintain shift state like when calling &lt;code&gt;&lt;a href=&quot;../../string/multibyte/wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt;, and is therefore updated to reflect the shift state after the last successfully converted character, but a user-defined facet is free to use it to maintain any other state, e.g. count the number of special characters encountered.</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 에 대한 영향 은 의도적으로 지정되지 않았습니다. 표준 패싯에서는 &lt;code&gt;&lt;a href=&quot;../../string/multibyte/wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt; 호출 할 때와 같이 시프트 상태를 유지하는 데 사용 되므로 마지막으로 변환 된 문자 이후의 시프트 상태를 반영하도록 업데이트되지만 사용자 정의 패싯은이를 사용하여 다른 것을 유지 보수 할 수 있습니다. 상태, 예를 들어 발생하는 특수 문자 수를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="17b2cdc08f47b7a5ed5d20adf3ef19dc26f9c333" translate="yes" xml:space="preserve">
          <source>The effective length of the initializing string is min(&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;str.size() - pos&lt;/code&gt;).</source>
          <target state="translated">초기화 문자열의 유효 길이는 min ( &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;str.size() - pos&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="699e483e2e3f60481d244140e88ca2195f9ab9a1" translate="yes" xml:space="preserve">
          <source>The effective options that affect the directory iteration.</source>
          <target state="translated">디렉토리 반복에 영향을 미치는 효과적인 옵션.</target>
        </trans-unit>
        <trans-unit id="277b731069d198539b3fe68887f4d3154302a386" translate="yes" xml:space="preserve">
          <source>The effects depend on &lt;code&gt;prms&lt;/code&gt; and &lt;code&gt;opts&lt;/code&gt; as follows:</source>
          <target state="translated">효과는에 의존 &lt;code&gt;prms&lt;/code&gt; 및 &lt;code&gt;opts&lt;/code&gt; 다음과 같다 :</target>
        </trans-unit>
        <trans-unit id="8651d51c2038a7579ed581306ab93549a57e3f4f" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;notify_one()&lt;/code&gt;/&lt;code&gt;notify_all()&lt;/code&gt; and each of the three atomic parts of &lt;code&gt;wait()&lt;/code&gt;/&lt;code&gt;wait_for()&lt;/code&gt;/&lt;code&gt;wait_until()&lt;/code&gt; (unlock+wait, wakeup, and lock) take place in a single total order that can be viewed as &lt;a href=&quot;../../atomic/memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of an atomic variable: the order is specific to this individual condition_variable. This makes it impossible for &lt;code&gt;notify_one()&lt;/code&gt; to, for example, be delayed and unblock a thread that started waiting just after the call to &lt;code&gt;notify_one()&lt;/code&gt; was made.</source>
          <target state="translated">의 효과 &lt;code&gt;notify_one()&lt;/code&gt; / &lt;code&gt;notify_all()&lt;/code&gt; 과의 세 원자 각 부분 &lt;code&gt;wait()&lt;/code&gt; / &lt;code&gt;wait_for()&lt;/code&gt; / &lt;code&gt;wait_until()&lt;/code&gt; (해제 + 대기, 기상 및 잠금) 하나의 전체 순서에서 일어날 볼 수 로 &lt;a href=&quot;../../atomic/memory_order#Modification_order&quot;&gt;변경 순서&lt;/a&gt; 원자 변수 : 주문이 개별 condition_variable 다릅니다. 이를 통해 &lt;code&gt;notify_one()&lt;/code&gt; 을 지연시킬 수 &lt;code&gt;notify_one()&lt;/code&gt; 호출 한 직후 대기를 시작한 스레드를 차단 해제 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cea82bd2c1a6a4cca1c94310f4ea304a94ebd7ff" translate="yes" xml:space="preserve">
          <source>The effects of aggregate initialization are:</source>
          <target state="translated">집계 초기화의 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc76e5e9dce364815385c8038fa8f3aefe16ecdf" translate="yes" xml:space="preserve">
          <source>The effects of calling &lt;code&gt;&lt;a href=&quot;what&quot;&gt;what()&lt;/a&gt;&lt;/code&gt; after assignment are implementation-defined.</source>
          <target state="translated">할당 후 &lt;code&gt;&lt;a href=&quot;what&quot;&gt;what()&lt;/a&gt;&lt;/code&gt; 호출의 효과 는 구현 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="acd2e1f2f8f283f58add15a5b6c96ad1a4bcb99f" translate="yes" xml:space="preserve">
          <source>The effects of constant initialization are the same as the effects of the corresponding initialization, except that it's guaranteed that it is complete before any other initialization of a static or thread-local object begins, and it may be performed at compile time.</source>
          <target state="translated">상수 초기화의 효과는 정적 또는 스레드 로컬 객체의 다른 초기화가 시작되기 전에 완료되고 컴파일 타임에 수행 될 수 있다는 점을 제외하면 해당 초기화의 효과와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fd953e7070aa0f66ff080c912887c4f952047292" translate="yes" xml:space="preserve">
          <source>The effects of copy initialization are:</source>
          <target state="translated">복사 초기화의 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8cfd1ee4ebd1bc33a0bf9c72eb9dc0e4d68febcc" translate="yes" xml:space="preserve">
          <source>The effects of default initialization are:</source>
          <target state="translated">기본 초기화의 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="300fd423eca4b27e42f83cdb8460a3c248ebfebe" translate="yes" xml:space="preserve">
          <source>The effects of direct initialization are:</source>
          <target state="translated">직접 초기화의 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e5f022b0bc5e850d42cbc2251aad303b760f429" translate="yes" xml:space="preserve">
          <source>The effects of list initialization of an object of type &lt;code&gt;T&lt;/code&gt; are:</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 오브젝트의 목록 초기화 효과는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2eaca7ff0b6d0f7e2ebdd251f120ac2cb16cff4c" translate="yes" xml:space="preserve">
          <source>The effects of reference initialization are:</source>
          <target state="translated">참조 초기화의 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ef623c3b922339a0463a696882fce40deb3b9ed" translate="yes" xml:space="preserve">
          <source>The effects of value initialization are:</source>
          <target state="translated">값 초기화의 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94b39a5092913a72e71cf3cf80c6764db966ebde" translate="yes" xml:space="preserve">
          <source>The effects of zero initialization are:</source>
          <target state="translated">제로 초기화의 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b777ed6b6b0f7899c139e22dde69591cc29e1364" translate="yes" xml:space="preserve">
          <source>The element erased and &lt;code&gt;&lt;a href=&quot;vector/end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">요소가 지워지고 &lt;code&gt;&lt;a href=&quot;vector/end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="504403fec65bb2b27f30b2f09751e05f4b0a4e02" translate="yes" xml:space="preserve">
          <source>The element pointed at by &lt;code&gt;nth&lt;/code&gt; is changed to whatever element would occur in that position if &lt;code&gt;[first, last)&lt;/code&gt; were sorted.</source>
          <target state="translated">&lt;code&gt;nth&lt;/code&gt; 로 가리키는 요소는 &lt;code&gt;[first, last)&lt;/code&gt; 이 정렬 된 경우 해당 위치에서 발생할 수있는 요소로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a7750b37bfc65c5e0dc0c0f0394afa5d519ab06" translate="yes" xml:space="preserve">
          <source>The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a vector may be passed to any function that expects a pointer to an element of an array.</source>
          <target state="translated">요소는 연속적으로 저장되므로 반복자를 통해 요소에 액세스 할 수있을뿐만 아니라 요소에 대한 일반 포인터에 대한 오프셋을 사용하여 요소에 액세스 할 수 있습니다. 이것은 벡터의 요소에 대한 포인터가 배열의 요소에 대한 포인터를 기대하는 모든 함수에 전달 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d1207730233ddeaf76dad20caba05dddb264714c" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;u&lt;/code&gt; are the same or copies of those of &lt;code&gt;rv&lt;/code&gt; and &lt;code&gt;u.get_allocator() == m&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 의 요소는 &lt;code&gt;rv&lt;/code&gt; 및 &lt;code&gt;u.get_allocator() == m&lt;/code&gt; 의 요소 와 동일하거나 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="df8c067b5e64d3ba4b18a9f63de6869977f7971d" translate="yes" xml:space="preserve">
          <source>The elements of a &lt;code&gt;basic_string&lt;/code&gt; are stored contiguously, that is, for a basic_string &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;&amp;amp;*(s.begin() + n) == &amp;amp;*s.begin() + n&lt;/code&gt; for any n in &lt;code&gt;[0, s.size())&lt;/code&gt;, or, equivalently, a pointer to &lt;code&gt;s[0]&lt;/code&gt; can be passed to functions that expect a pointer to the first element of a &lt;code&gt;CharT[]&lt;/code&gt; array.</source>
          <target state="translated">&lt;code&gt;basic_string&lt;/code&gt; 의 요소는 연속적으로 저장됩니다. 즉, basic_string &lt;code&gt;s&lt;/code&gt; 의 경우 &lt;code&gt;&amp;amp;*(s.begin() + n) == &amp;amp;*s.begin() + n&lt;/code&gt; n은 &lt;code&gt;[0, s.size())&lt;/code&gt; 또는 &lt;code&gt;s[0]&lt;/code&gt; 대한 포인터는 &lt;code&gt;CharT[]&lt;/code&gt; 배열 의 첫 번째 요소에 대한 포인터를 예상하는 함수에 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac289e119568e88c907585f65cab5b2cc4a5e484" translate="yes" xml:space="preserve">
          <source>The ellipsis is not a parameter, and so can follow a parameter with a default argument.</source>
          <target state="translated">생략 부호는 매개 변수가 아니므로 기본 인수가있는 매개 변수 뒤에 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf4a253a4692830a136c72cdc4bb9d21f26c186" translate="yes" xml:space="preserve">
          <source>The ellipsis that indicates &lt;a href=&quot;variadic_arguments&quot;&gt;variadic arguments&lt;/a&gt; need not be preceded by a comma, even if it follows the ellipsis that indicates a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; expansion, so the following function templates are exactly the same:</source>
          <target state="translated">&lt;a href=&quot;parameter_pack&quot;&gt;변수 팩&lt;/a&gt; 확장 을 나타내는 줄임표 뒤에 오는 경우에도 &lt;a href=&quot;variadic_arguments&quot;&gt;가변 변수 인수&lt;/a&gt; 를 나타내는 줄임표 앞에 쉼표를 사용할 필요가 없으므로 다음 함수 템플릿이 정확히 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa2446394f875d97130f6ebb30e3ce4bdc1750f8" translate="yes" xml:space="preserve">
          <source>The empty member subobjects are permitted to be optimized out just like the empty bases if they use the attribute &lt;code&gt;[[&lt;a href=&quot;attributes/no_unique_address&quot;&gt;no_unique_address&lt;/a&gt;]]&lt;/code&gt;. Taking the address of such member results in an address that may equal the address of some other member of the same object.</source>
          <target state="translated">빈 멤버 서브 오브젝트는 &lt;code&gt;[[&lt;a href=&quot;attributes/no_unique_address&quot;&gt;no_unique_address&lt;/a&gt;]]&lt;/code&gt; 속성을 사용하는 경우 빈베이스와 마찬가지로 최적화 할 수 있습니다 . 그러한 구성원의 주소를 가져 오면 동일한 오브젝트의 다른 구성원의 주소와 동일한 주소가됩니다.</target>
        </trans-unit>
        <trans-unit id="0805662b123722b3c340392f4fa64cbab3149ec8" translate="yes" xml:space="preserve">
          <source>The encoding of calendar time in &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; is unspecified, but most systems conform to &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html&quot;&gt;POSIX specification&lt;/a&gt; and return a value of integral type holding the number of seconds since &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15&quot;&gt;the Epoch&lt;/a&gt;. Implementations in which &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; is a 32-bit signed integer (many historical implementations) fail in the year &lt;a href=&quot;https://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2038&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; 의 달력 시간 인코딩 은 지정되지 않았지만 대부분의 시스템은 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html&quot;&gt;POSIX 사양을&lt;/a&gt; 준수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15&quot;&gt;하며 Epoch&lt;/a&gt; 이후 초 수를 보유한 정수 유형의 값을 리턴합니다 . 구현하는 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; 32 비트 정수 (많은 역사적 구현) 년에 실패하다 &lt;a href=&quot;https://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2038&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d69a36e6f924ee7e47c55de6af52a07646156a5f" translate="yes" xml:space="preserve">
          <source>The encoding of narrow multibyte string literals (1) and wide string literals (2) is implementation-defined. For example, gcc selects them with the &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Invocation.html&quot;&gt;commandline options&lt;/a&gt;&lt;code&gt;-fexec-charset&lt;/code&gt; and &lt;code&gt;-fwide-exec-charset&lt;/code&gt;.</source>
          <target state="translated">좁은 멀티 바이트 문자열 리터럴 (1) 및 넓은 문자열 리터럴 (2)의 인코딩은 구현 정의됩니다. 예를 들어, gcc는 &lt;code&gt;-fexec-charset&lt;/code&gt; 및 &lt;code&gt;-fwide-exec-charset&lt;/code&gt; &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Invocation.html&quot;&gt;명령 행 옵션을&lt;/a&gt; 사용하여 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="2cd9b9debf1ab95431b525333881e105361a6688" translate="yes" xml:space="preserve">
          <source>The end of the range of objects (i.e., &lt;code&gt;&lt;a href=&quot;../iterator/next&quot;&gt;std::next&lt;/a&gt;(first, n)&lt;/code&gt;).</source>
          <target state="translated">객체 범위의 끝 (예 : &lt;code&gt;&lt;a href=&quot;../iterator/next&quot;&gt;std::next&lt;/a&gt;(first, n)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2f8f7e87af18baac3cc0b054b1043648021aefcc" translate="yes" xml:space="preserve">
          <source>The end of the range of objects that has been destroyed (i.e., &lt;code&gt;&lt;a href=&quot;../iterator/next&quot;&gt;std::next&lt;/a&gt;(first, n)&lt;/code&gt;).</source>
          <target state="translated">파괴 된 객체 범위의 끝 (예 : &lt;code&gt;&lt;a href=&quot;../iterator/next&quot;&gt;std::next&lt;/a&gt;(first, n)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="52cec00cfb7299f67b1921b3ec8b84d001978a8b" translate="yes" xml:space="preserve">
          <source>The entropy of the Linux kernel device /dev/urandom may be obtained using &lt;a href=&quot;http://man7.org/linux/man-pages/man4/random.4.html&quot;&gt;ioctl RNDGETENTCNT&lt;/a&gt; - that's what &lt;code&gt;std::random_device::entropy()&lt;/code&gt; in &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/master/libstdc%20%20-v3/src/c%20%2011/random.cc#L188&quot;&gt;GNU libstdc++&lt;/a&gt; uses as of version 8.1.</source>
          <target state="translated">리눅스 커널 장치의 엔트로피는 / dev / urandom을 사용하여 얻을 수 있습니다 &lt;a href=&quot;http://man7.org/linux/man-pages/man4/random.4.html&quot;&gt;입출력 제어 RNDGETENTCNT을&lt;/a&gt; - 그의 어떤 &lt;code&gt;std::random_device::entropy()&lt;/code&gt; 에서 &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/master/libstdc%20%20-v3/src/c%20%2011/random.cc#L188&quot;&gt;GNU 된 libstdc ++&lt;/a&gt; 버전 8.1로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b526caf3120cb6234f9fb955ff6f445025db5cc0" translate="yes" xml:space="preserve">
          <source>The eofbit</source>
          <target state="translated">eofbit</target>
        </trans-unit>
        <trans-unit id="ac8151f7dedb19c9e673caee7e6961ae4483df11" translate="yes" xml:space="preserve">
          <source>The eofbit is set by the following standard library functions:</source>
          <target state="translated">eofbit는 다음 표준 라이브러리 기능으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="de46a90499c7bf50e36a789596077d479893b896" translate="yes" xml:space="preserve">
          <source>The epoch of &lt;code&gt;system_clock&lt;/code&gt; is unspecified, but most implementations use Unix Time (i.e., time since 00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970, not counting leap seconds).</source>
          <target state="translated">&lt;code&gt;system_clock&lt;/code&gt; 의 시대 는 지정되지 않았지만 대부분의 구현에서는 Unix Time (즉, 윤초를 세지 않고 1970 년 1 월 1 일 목요일 00:00:00 협정 세계시 (UTC) 이후의 시간)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a8dec4a6976c27fa3b8702243578d25bc0de8846" translate="yes" xml:space="preserve">
          <source>The equals sign, &lt;code&gt;=&lt;/code&gt;, in copy-initialization of a named variable is not related to the assignment operator. Assignment operator overloads have no effect on copy-initialization.</source>
          <target state="translated">명명 된 변수의 복사 초기화에서 등호 ( &lt;code&gt;=&lt;/code&gt; )는 할당 연산자와 관련이 없습니다. 할당 연산자 오버로드는 복사 초기화에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15a184fedc7147e932e8edb9e4f5e96b3f3233d2" translate="yes" xml:space="preserve">
          <source>The error category of the error value.</source>
          <target state="translated">오류 값의 오류 범주입니다.</target>
        </trans-unit>
        <trans-unit id="4bd988f5880ebd48c3253a6fa8738b28e0bda0e2" translate="yes" xml:space="preserve">
          <source>The error condition for the given error code.</source>
          <target state="translated">주어진 오류 코드의 오류 조건입니다.</target>
        </trans-unit>
        <trans-unit id="c81d179fd5ebd08285d4630b0d42bf847c0180df" translate="yes" xml:space="preserve">
          <source>The error message corresponding to the current error value and category.</source>
          <target state="translated">현재 오류 값 및 범주에 해당하는 오류 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="88a06ff6d6b5a3ba4276cee42336251cadd1cd73" translate="yes" xml:space="preserve">
          <source>The exact behavior of this function depends on the implementation, in particular on the mechanics of the OS scheduler in use and the state of the system. For example, a first-in-first-out realtime scheduler (&lt;code&gt;SCHED_FIFO&lt;/code&gt; in Linux) would suspend the current thread and put it on the back of the queue of the same-priority threads that are ready to run (and if there are no other threads at the same priority, &lt;code&gt;yield&lt;/code&gt; has no effect).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f75932905b2632bba207dcff21589878a43b6dd" translate="yes" xml:space="preserve">
          <source>The exact effects this modifier has on the input and output vary between the individual I/O functions and are described at each &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; overload page individually.</source>
          <target state="translated">이 수정자가 입력 및 출력에 미치는 정확한 효과는 개별 I / O 기능마다 다르며 각 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 과부하 페이지에 개별적으로 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="363ac40b1d368630d3800a01855367f3dc4f5212" translate="yes" xml:space="preserve">
          <source>The exact number of &lt;code&gt;externT&lt;/code&gt; characters that correspond to one &lt;code&gt;internT&lt;/code&gt; character, if constant. &lt;code&gt;​0​&lt;/code&gt; if the number varies, &lt;code&gt;-1&lt;/code&gt; if the encoding is state-dependent.</source>
          <target state="translated">의 정확한 수 &lt;code&gt;externT&lt;/code&gt; 의 문자가 대응 한 &lt;code&gt;internT&lt;/code&gt; 의 문자 경우 정수입니다. &lt;code&gt;​0​&lt;/code&gt; 수가 변하면, &lt;code&gt;-1&lt;/code&gt; 부호화 상태 의존적 인 경우.</target>
        </trans-unit>
        <trans-unit id="c0584bcc519f595df1d83656ff4d78467c1471a6" translate="yes" xml:space="preserve">
          <source>The example output corresponds to a system with 64-bit pointers and 32-bit int.</source>
          <target state="translated">예제 출력은 64 비트 포인터 및 32 비트 int가있는 시스템에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="401671dabc741fba713d9a3372e1229c26569984" translate="yes" xml:space="preserve">
          <source>The example showing output using one of the implementations where type_info::name returns full type names; filter through c++filt -t if using gcc or similar.</source>
          <target state="translated">type_info :: name이 전체 유형 이름을 리턴하는 구현 중 하나를 사용하여 출력을 보여주는 예제. gcc 또는 이와 유사한 것을 사용하는 경우 c ++ filt -t를 통해 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="962d766aea512badcd93d36a0bad74875b6df8a3" translate="yes" xml:space="preserve">
          <source>The exception object</source>
          <target state="translated">예외 객체</target>
        </trans-unit>
        <trans-unit id="5c7c457a1a95d00590ff16b4e63c341c098fe660" translate="yes" xml:space="preserve">
          <source>The exception object is a temporary object in unspecified storage that is constructed by the &lt;code&gt;throw&lt;/code&gt; expression.</source>
          <target state="translated">예외 오브젝트는 지정되지 않은 스토리지의 임시 오브젝트이며 &lt;code&gt;throw&lt;/code&gt; 표현식으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5cc701cf4530a2100ddf04f27b306c1857719210" translate="yes" xml:space="preserve">
          <source>The exception object persists until the last catch clause exits other than by rethrowing (if not by rethrowing, it is destroyed immediately after the destruction of the catch clause's parameter), or until the last &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; that references this object is destroyed (in which case the exception object is destroyed just before the destructor of &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; returns.</source>
          <target state="translated">예외 개체는 다시 던지거나 (다시 던지지 않으면 catch 절의 매개 변수가 삭제 된 후 즉시 제거됨) 또는 이 개체를 참조 하는 마지막 &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 이 제거 될 때가 아닌 마지막 catch 절이 종료 될 때까지 지속됩니다 . 이 경우 예외 객체는 &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 의 소멸자가 반환 되기 직전에 파괴 됩니다.</target>
        </trans-unit>
        <trans-unit id="ff78e6b3502b4c2e9d34931f4c9b1d395e28c19a" translate="yes" xml:space="preserve">
          <source>The exception object referenced by an &lt;code&gt;std::exception_ptr&lt;/code&gt; remains valid as long as there remains at least one &lt;code&gt;std::exception_ptr&lt;/code&gt; that is referencing it: &lt;code&gt;std::exception_ptr&lt;/code&gt; is a shared-ownership smart pointer (note; this is in addition to the usual &lt;a href=&quot;../language/throw#The_exception_object&quot;&gt;exception object lifetime rules&lt;/a&gt;).</source>
          <target state="translated">참조하는 예외 객체 &lt;code&gt;std::exception_ptr&lt;/code&gt; 오랫동안 남아만큼 유효 적어도 하나의 &lt;code&gt;std::exception_ptr&lt;/code&gt; 그것을 참조하는 것을 : &lt;code&gt;std::exception_ptr&lt;/code&gt; 공유 소유 스마트 포인터 (주입니다,이 평소에 추가됩니다 &lt;a href=&quot;../language/throw#The_exception_object&quot;&gt;예외 객체 수명 규칙&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3379e35c976ab98276fbc9adebb12a934ec3523e" translate="yes" xml:space="preserve">
          <source>The exception specification of a function template specialization is not instantiated along with the function declaration; it is instantiated only when</source>
          <target state="translated">함수 템플릿 전문화의 예외 사양은 함수 선언과 함께 인스턴스화되지 않습니다. 때만 인스턴스화됩니다</target>
        </trans-unit>
        <trans-unit id="d467a68666ede11b7e2477936d7c13019488c0c3" translate="yes" xml:space="preserve">
          <source>The exception-specification of an implicitly-declared special member function is also evaluated only when needed (in particular, implicit declaration of a member function of a derived class does not require the exception-specification of a base member function to be instantiated).</source>
          <target state="translated">내재적으로 선언 된 특수 멤버 함수의 예외 스펙은 필요할 때만 평가됩니다 (특히 파생 클래스의 멤버 함수에 대한 내재적 선언에는 기본 멤버 함수의 예외 스펙을 인스턴스화 할 필요가 없음).</target>
        </trans-unit>
        <trans-unit id="52bc008473e81b69c43ce4bc76d889cc48c6a5a6" translate="yes" xml:space="preserve">
          <source>The exceptions used for transaction cancellation in &lt;code&gt;atomic_cancel&lt;/code&gt; blocks are &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/new/bad_array_new_length&quot;&gt;std::bad_array_new_length&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/bad_typeid&quot;&gt;std::bad_typeid&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; and all standard library exceptions derived from it, and the special exception type &lt;a href=&quot;../error/tx_exception&quot;&gt;&lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;atomic_cancel&lt;/code&gt; 블록 에서 트랜잭션 취소에 사용 된 예외 는 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../memory/new/bad_array_new_length&quot;&gt;std::bad_array_new_length&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/bad_typeid&quot;&gt;std::bad_typeid&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; 및 여기에서 파생 된 모든 표준 라이브러리 예외 및 특수 예외 유형 &lt;a href=&quot;../error/tx_exception&quot;&gt; &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="021d4e86fa7831da29ef94f71f0da79f3c93fbf7" translate="yes" xml:space="preserve">
          <source>The execution environment is modified such that when the current thread exits, the condition variable &lt;code&gt;cond&lt;/code&gt; is notified as if by:</source>
          <target state="translated">현재 스레드가 종료 될 때 조건 변수 &lt;code&gt;cond&lt;/code&gt; 가 다음과 같이 통지되도록 실행 환경이 수정 됩니다.</target>
        </trans-unit>
        <trans-unit id="db529544bc767c723bb5ca98f064de4db37dda1a" translate="yes" xml:space="preserve">
          <source>The expected way to make a program-defined type swappable is to provide a non-member function swap in the same namespace as the type: see &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; for details.</source>
          <target state="translated">프로그램 정의 유형 스왑을 가능하게하는 예상 방법은 유형과 동일한 네임 스페이스에 비 멤버 함수 스왑을 제공하는 것 입니다. 자세한 내용 은 &lt;a href=&quot;../named_req/swappable&quot;&gt;스왑 가능&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="94a70ade5760a29591766576307fbe5ce110f9d8" translate="yes" xml:space="preserve">
          <source>The explicit specialization &lt;a href=&quot;ctype_byname_char&quot;&gt;&lt;code&gt;std::ctype_byname&amp;lt;char&amp;gt;&lt;/code&gt;&lt;/a&gt; was listed as a separate entry in the header file &lt;code&gt;&amp;lt;locale&amp;gt;&lt;/code&gt; until C++11. it was removed in C++11 as &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1298&quot;&gt;defect #1298&lt;/a&gt;, but it remains a required specialization, just like &lt;code&gt;std::ctype_byname&amp;lt;wchar_t&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">명시적인 특수화 &lt;a href=&quot;ctype_byname_char&quot;&gt; &lt;code&gt;std::ctype_byname&amp;lt;char&amp;gt;&lt;/code&gt; &lt;/a&gt; 은 C ++ 11까지 헤더 파일 &lt;code&gt;&amp;lt;locale&amp;gt;&lt;/code&gt; 에 별도의 항목으로 나열되었습니다 . C ++ 11에서 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1298&quot;&gt;결함 # 1298&lt;/a&gt; 로 제거 되었지만 &lt;code&gt;std::ctype_byname&amp;lt;wchar_t&amp;gt;&lt;/code&gt; 와 같이 필수 전문화 상태로 남아 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4768ebf182c67445a2d9702650a0be943a487f1b" translate="yes" xml:space="preserve">
          <source>The explicit specialization for &lt;code&gt;void&lt;/code&gt; lacks the member typedefs &lt;code&gt;reference&lt;/code&gt;, &lt;code&gt;const_reference&lt;/code&gt;, &lt;code&gt;size_type&lt;/code&gt; and &lt;code&gt;difference_type&lt;/code&gt;. This specialization declares no member functions.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 에 대한 명시적인 전문화 에는 멤버 typedef &lt;code&gt;reference&lt;/code&gt; , &lt;code&gt;const_reference&lt;/code&gt; , &lt;code&gt;size_type&lt;/code&gt; 및 &lt;code&gt;difference_type&lt;/code&gt; 이 부족합니다 . 이 전문화는 멤버 함수를 선언하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75f7b6ca4ed9628e0d043baf2085e3225cacadad" translate="yes" xml:space="preserve">
          <source>The explicit specifier may only appear within the decl-specifier-seq of the declaration of a constructor  or conversion function(since C++11) within its class definition.</source>
          <target state="translated">명시 적 지정자는 클래스 정의 내에서 생성자 또는 변환 함수 (C ++ 11부터) 선언의 decl-specifier-seq 내에 만 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3afa03179e588e1c757bb671479e9343d010308a" translate="yes" xml:space="preserve">
          <source>The exponent contains at least two digits, more digits are used only if necessary. If the value is &lt;code&gt;​0​&lt;/code&gt;, the exponent is also &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbac353ed3f45f6cc4a964a51c439a96d66dd22" translate="yes" xml:space="preserve">
          <source>The exponent has the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04028f66e9c71c2bd75f830dc82f30f80377d676" translate="yes" xml:space="preserve">
          <source>The exponential function is an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b026107f975051acf342b103e1b444c59a6178c7" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(void)*i, *i&lt;/code&gt; is equivalent to &lt;code&gt;*i&lt;/code&gt;.</source>
          <target state="translated">식 &lt;code&gt;(void)*i, *i&lt;/code&gt; 에 상당 &lt;code&gt;*i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f256b2d48cb6167100795f513339752f484b361c" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;::value&lt;/code&gt; must be a well-formed integer constant expression, and the number of identifiers must equal &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;::value&lt;/code&gt;.</source>
          <target state="translated">표정 &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;::value&lt;/code&gt; a는 상수 정수 표현 잘 형성되어야하고, 식별자들의 수가 같아야 &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;::value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83669166fa2ba44ae88683185916f1e865fbe4db" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;E1-&amp;gt;*E2&lt;/code&gt; is exactly equivalent to &lt;code&gt;(*E1).*E2&lt;/code&gt; for built-in types; that is why the following rules address only &lt;code&gt;E1.*E2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;E1-&amp;gt;*E2&lt;/code&gt; 표현식 은 내장 유형의 경우 &lt;code&gt;(*E1).*E2&lt;/code&gt; 와 정확히 같습니다 . 그렇기 때문에 다음 규칙은 &lt;code&gt;E1.*E2&lt;/code&gt; 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1be99cdcd2e8a79ac63dcdfecfbecf43da1ffdc5" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt; is exactly equivalent to &lt;code&gt;(*E1).E2&lt;/code&gt; for built-in types; that is why the following rules address only &lt;code&gt;E1.E2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;E1-&amp;gt;E2&lt;/code&gt; 표현식 은 내장 유형의 경우 &lt;code&gt;(*E1).E2&lt;/code&gt; 와 정확히 같습니다 . 그렇기 때문에 다음 규칙은 &lt;code&gt;E1.E2&lt;/code&gt; 에만 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="8662b895e8848a9d54fb30016c007f413c93e39b" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;E&lt;/code&gt; as well as all expressions &lt;code&gt;A1&lt;/code&gt;, &lt;code&gt;A2&lt;/code&gt;, &lt;code&gt;A3&lt;/code&gt;, etc, provided as arguments are evaluated in arbitrary order, &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt; with respect to each other.</source>
          <target state="translated">발현 &lt;code&gt;E&lt;/code&gt; 뿐만 아니라 모든 식 &lt;code&gt;A1&lt;/code&gt; , &lt;code&gt;A2&lt;/code&gt; , &lt;code&gt;A3&lt;/code&gt; 의 인수로서 제공 등, 임의의 순서로 평가 &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt; 서로에 대하여.</target>
        </trans-unit>
        <trans-unit id="ded81f4b1365cdf6b2376a723a760568d868d21a" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;E&lt;/code&gt; is sequenced before each of the expressions &lt;code&gt;A1&lt;/code&gt;, &lt;code&gt;A2&lt;/code&gt;, &lt;code&gt;A3&lt;/code&gt; as well as default arguments, if any. The argument expressions are evaluated in arbitrary order, &lt;a href=&quot;eval_order&quot;&gt;indeterminately sequenced&lt;/a&gt; with respect to each other.</source>
          <target state="translated">식 &lt;code&gt;E&lt;/code&gt; 는 각각의 식 &lt;code&gt;A1&lt;/code&gt; , &lt;code&gt;A2&lt;/code&gt; , &lt;code&gt;A3&lt;/code&gt; 및 기본 인수 (있는 경우) 보다 먼저 순서화 됩니다. 인수 표현식은 서로에 대해 &lt;a href=&quot;eval_order&quot;&gt;결정되지 않은 순서&lt;/a&gt; 로 임의의 순서로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="539ec12c5f5ccb719489a32d4374a893502f671b" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;assert(E)&lt;/code&gt; is guaranteed to be a &lt;a href=&quot;../language/constant_expression&quot;&gt;constant subexpression&lt;/a&gt;, if either.</source>
          <target state="translated">표현의 &lt;code&gt;assert(E)&lt;/code&gt; 보장되는 &lt;a href=&quot;../language/constant_expression&quot;&gt;일정 하위 표현식&lt;/a&gt; 중 하나 경우.</target>
        </trans-unit>
        <trans-unit id="586336445cf8edc1ea53dc0a3ef96aa12ea46aed" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;is &amp;gt;&amp;gt; manip&lt;/code&gt; is an lvalue of type &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; with the value &lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">표현식 &lt;code&gt;is &amp;gt;&amp;gt; manip&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; 유형의 lvalue이며 값 &lt;code&gt;is&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="82b1761cea5dd130f7d4e710d4bd26b38bbad074" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;m.lock()&lt;/code&gt; has the following properties</source>
          <target state="translated">&lt;code&gt;m.lock()&lt;/code&gt; 표현식 에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7709fdad1bfa0b92b4b386c5e0f181e6a9f690a9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;m.lock_shared()&lt;/code&gt; has the following properties</source>
          <target state="translated">&lt;code&gt;m.lock_shared()&lt;/code&gt; 표현식 에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="240415ee5368f9c965c95afc5cc3939b7c0c29ea" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;m.try_lock()&lt;/code&gt; has the following properties</source>
          <target state="translated">&lt;code&gt;m.try_lock()&lt;/code&gt; 표현식 에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe6f73c5bba66f05a94b9e2020b01d0a71bf84af" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;m.try_lock_for(duration)&lt;/code&gt; has the following properties</source>
          <target state="translated">&lt;code&gt;m.try_lock_for(duration)&lt;/code&gt; 표현식 에는 다음 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af3f262075eaf71da5ad7ff342912b9553daa93f" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;m.try_lock_shared()&lt;/code&gt; has the following properties</source>
          <target state="translated">&lt;code&gt;m.try_lock_shared()&lt;/code&gt; 표현식 에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a44765748c4d628f81874d40f8b3a638d007d340" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;m.try_lock_shared_for(duration)&lt;/code&gt; has the following properties</source>
          <target state="translated">&lt;code&gt;m.try_lock_shared_for(duration)&lt;/code&gt; 표현식 에는 다음 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="124bf2cd9e34ad42e934027eaeae6a4a74ab1f4b" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;m.try_lock_shared_until(time_point)&lt;/code&gt; has the following properties</source>
          <target state="translated">식 &lt;code&gt;m.try_lock_shared_until(time_point)&lt;/code&gt; 에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d57532bbb3aad50e57871e8a34a148c07fd1835b" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;m.try_lock_until(time_point)&lt;/code&gt; has the following properties</source>
          <target state="translated">&lt;code&gt;m.try_lock_until(time_point)&lt;/code&gt; 표현식 에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ccc23f32ac0eccf9b8dd11159afbf1ff8524278" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;m.unlock()&lt;/code&gt; has the following properties</source>
          <target state="translated">&lt;code&gt;m.unlock()&lt;/code&gt; 표현식 에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fc0acaec7b5396f8450b18e802131519692dde8" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;m.unlock_shared()&lt;/code&gt; has the following properties</source>
          <target state="translated">&lt;code&gt;m.unlock_shared()&lt;/code&gt; 표현식 에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="91b7fbd840ec23a67a46bd4f51655418edf1d142" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;offsetof(type, member)&lt;/code&gt; is never &lt;a href=&quot;../language/dependent_name#Dependent_types&quot;&gt;type-dependent&lt;/a&gt; and it is value-dependent if and only if type is dependent.</source>
          <target state="translated">&lt;code&gt;offsetof(type, member)&lt;/code&gt; 표현식 은 &lt;a href=&quot;../language/dependent_name#Dependent_types&quot;&gt;유형에 종속&lt;/a&gt; 되지 않으며 유형 이 종속적 인 경우에만 값에 종속됩니다.</target>
        </trans-unit>
        <trans-unit id="54b4ee5d238ac3437ac1265bf827a66c59c6ad6e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;p(v)&lt;/code&gt; must be convertible to &lt;code&gt;bool&lt;/code&gt; for every argument &lt;code&gt;v&lt;/code&gt; of type (possibly const) &lt;code&gt;T&lt;/code&gt;, regardless of &lt;a href=&quot;../../language/value_category&quot;&gt;value category&lt;/a&gt;, and must not modify &lt;code&gt;v&lt;/code&gt;. Thus, a parameter type of &lt;code&gt;T&amp;amp;&lt;/code&gt;is not allowed, nor is &lt;code&gt;T&lt;/code&gt; unless for &lt;code&gt;T&lt;/code&gt; a move is equivalent to a copy(since C++11). ​</source>
          <target state="translated">&lt;code&gt;p(v)&lt;/code&gt; 표현식 은 &lt;a href=&quot;../../language/value_category&quot;&gt;value category에&lt;/a&gt; 관계없이 유형 &lt;code&gt;T&lt;/code&gt; 의 모든 인수 &lt;code&gt;v&lt;/code&gt; 에 대해 &lt;code&gt;bool&lt;/code&gt; 로 변환 가능 해야하며 &lt;code&gt;v&lt;/code&gt; 를 수정해서는 안됩니다 . 따라서 &lt;code&gt;T&amp;amp;&lt;/code&gt; 의 매개 변수 유형은 허용되지 않으며 &lt;code&gt;T&lt;/code&gt; 에 대한 이동이 사본과 동일 하지 않은 한 &lt;code&gt;T&lt;/code&gt; 도 아닙니다 (C ++ 11 이후).</target>
        </trans-unit>
        <trans-unit id="31766904edca7191420c344c843fc6cc68843556" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;p(v)&lt;/code&gt; must be convertible to &lt;code&gt;bool&lt;/code&gt; for every argument &lt;code&gt;v&lt;/code&gt; of type (possibly const) &lt;code&gt;VT&lt;/code&gt;, where &lt;code&gt;VT&lt;/code&gt; is the value type of &lt;code&gt;BidirIt&lt;/code&gt;, regardless of &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt;, and must not modify &lt;code&gt;v&lt;/code&gt;. Thus, a parameter type of &lt;code&gt;VT&amp;amp;&lt;/code&gt;is not allowed, nor is &lt;code&gt;VT&lt;/code&gt; unless for &lt;code&gt;VT&lt;/code&gt; a move is equivalent to a copy(since C++11). ​</source>
          <target state="translated">&lt;code&gt;p(v)&lt;/code&gt; 표현식 은 &lt;code&gt;VT&lt;/code&gt; 유형의 모든 인수 &lt;code&gt;v&lt;/code&gt; 에 대해 &lt;code&gt;bool&lt;/code&gt; 로 변환 가능해야합니다 . 여기서 &lt;code&gt;VT&lt;/code&gt; 는 &lt;a href=&quot;../language/value_category&quot;&gt;값 범주에&lt;/a&gt; 관계없이 &lt;code&gt;BidirIt&lt;/code&gt; 의 값 유형이며 &lt;code&gt;v&lt;/code&gt; 를 수정해서는 안됩니다 . 따라서, 파라미터의 종류 &lt;code&gt;VT&amp;amp;&lt;/code&gt; 허용되지 않으며, 인 &lt;code&gt;VT&lt;/code&gt; 는 위해 않는 &lt;code&gt;VT&lt;/code&gt; 이동은 (11 ++ C 때문에) 복사와 동등하다.</target>
        </trans-unit>
        <trans-unit id="e393e02be8964600ac69d24291a03db73c323fd4" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;p(v)&lt;/code&gt; must be convertible to &lt;code&gt;bool&lt;/code&gt; for every argument &lt;code&gt;v&lt;/code&gt; of type (possibly const) &lt;code&gt;VT&lt;/code&gt;, where &lt;code&gt;VT&lt;/code&gt; is the value type of &lt;code&gt;ForwardIt&lt;/code&gt;, regardless of &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt;, and must not modify &lt;code&gt;v&lt;/code&gt;. Thus, a parameter type of &lt;code&gt;VT&amp;amp;&lt;/code&gt;is not allowed, nor is &lt;code&gt;VT&lt;/code&gt; unless for &lt;code&gt;VT&lt;/code&gt; a move is equivalent to a copy(since C++11). ​</source>
          <target state="translated">&lt;code&gt;p(v)&lt;/code&gt; 표현식 은 &lt;code&gt;VT&lt;/code&gt; 유형의 모든 인수 &lt;code&gt;v&lt;/code&gt; 에 대해 &lt;code&gt;bool&lt;/code&gt; 로 변환 가능해야합니다 . 여기서 &lt;code&gt;VT&lt;/code&gt; 는 &lt;a href=&quot;../language/value_category&quot;&gt;값 범주에&lt;/a&gt; 관계없이 &lt;code&gt;ForwardIt&lt;/code&gt; 의 값 유형이며 &lt;code&gt;v&lt;/code&gt; 를 수정해서는 안됩니다 . 따라서, 파라미터의 종류 &lt;code&gt;VT&amp;amp;&lt;/code&gt; 허용되지 않으며, 인 &lt;code&gt;VT&lt;/code&gt; 는 위해 않는 &lt;code&gt;VT&lt;/code&gt; 이동은 (11 ++ C 때문에) 복사와 동등하다.</target>
        </trans-unit>
        <trans-unit id="038e567c0ca54f7778dee012a53f5c496d7dec7b" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;p(v)&lt;/code&gt; must be convertible to &lt;code&gt;bool&lt;/code&gt; for every argument &lt;code&gt;v&lt;/code&gt; of type (possibly const) &lt;code&gt;VT&lt;/code&gt;, where &lt;code&gt;VT&lt;/code&gt; is the value type of &lt;code&gt;InputIt&lt;/code&gt;, regardless of &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt;, and must not modify &lt;code&gt;v&lt;/code&gt;. Thus, a parameter type of &lt;code&gt;VT&amp;amp;&lt;/code&gt;is not allowed, nor is &lt;code&gt;VT&lt;/code&gt; unless for &lt;code&gt;VT&lt;/code&gt; a move is equivalent to a copy(since C++11). ​</source>
          <target state="translated">&lt;code&gt;p(v)&lt;/code&gt; 표현식 은 &lt;code&gt;VT&lt;/code&gt; 유형의 모든 인수 &lt;code&gt;v&lt;/code&gt; 에 대해 &lt;code&gt;bool&lt;/code&gt; 로 변환 가능해야합니다 . 여기서 &lt;code&gt;VT&lt;/code&gt; 는 &lt;a href=&quot;../language/value_category&quot;&gt;값 범주에&lt;/a&gt; 관계없이 &lt;code&gt;InputIt&lt;/code&gt; 의 값 유형이며 &lt;code&gt;v&lt;/code&gt; 를 수정해서는 안됩니다 . 따라서, 파라미터의 종류 &lt;code&gt;VT&amp;amp;&lt;/code&gt; 허용되지 않으며, 인 &lt;code&gt;VT&lt;/code&gt; 는 위해 않는 &lt;code&gt;VT&lt;/code&gt; 이동은 (11 ++ C 때문에) 복사와 동등하다.</target>
        </trans-unit>
        <trans-unit id="a33910922f5c49214aa40d9e9c70599d437ee4ab" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;pred(v)&lt;/code&gt; must be convertible to &lt;code&gt;bool&lt;/code&gt; for every argument &lt;code&gt;v&lt;/code&gt; of type (possibly const) &lt;code&gt;CharT&lt;/code&gt;, regardless of &lt;a href=&quot;../../language/value_category&quot;&gt;value category&lt;/a&gt;, and must not modify &lt;code&gt;v&lt;/code&gt;. Thus, a parameter type of &lt;code&gt;CharT&amp;amp;&lt;/code&gt;is not allowed, nor is &lt;code&gt;CharT&lt;/code&gt; unless for &lt;code&gt;CharT&lt;/code&gt; a move is equivalent to a copy(since C++11). ​</source>
          <target state="translated">&lt;code&gt;pred(v)&lt;/code&gt; 표현식 은 &lt;a href=&quot;../../language/value_category&quot;&gt;value category에&lt;/a&gt; 관계없이 &lt;code&gt;CharT&lt;/code&gt; 유형 (가능한 const)의 모든 인수 &lt;code&gt;v&lt;/code&gt; 에 대해 &lt;code&gt;bool&lt;/code&gt; 로 변환 가능 해야하며 &lt;code&gt;v&lt;/code&gt; 를 수정해서는 안됩니다 . 따라서 &lt;code&gt;CharT&amp;amp;&lt;/code&gt; 의 매개 변수 유형은 허용되지 않으며 &lt;code&gt;CharT&lt;/code&gt; 의 이동이 사본과 동일 하지 않으면 &lt;code&gt;CharT&lt;/code&gt; 도 아닙니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="fb551a5e288558f389d83fdd483dcaf1a86f0f36" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;pred(v)&lt;/code&gt; must be convertible to &lt;code&gt;bool&lt;/code&gt; for every argument &lt;code&gt;v&lt;/code&gt; of type (possibly const) &lt;code&gt;T&lt;/code&gt;, regardless of &lt;a href=&quot;../../language/value_category&quot;&gt;value category&lt;/a&gt;, and must not modify &lt;code&gt;v&lt;/code&gt;. Thus, a parameter type of &lt;code&gt;T&amp;amp;&lt;/code&gt;is not allowed, nor is &lt;code&gt;T&lt;/code&gt; unless for &lt;code&gt;T&lt;/code&gt; a move is equivalent to a copy(since C++11). ​</source>
          <target state="translated">&lt;code&gt;pred(v)&lt;/code&gt; 표현식 은 &lt;a href=&quot;../../language/value_category&quot;&gt;value category에&lt;/a&gt; 관계없이 (type const) &lt;code&gt;T&lt;/code&gt; 유형의 모든 인수 &lt;code&gt;v&lt;/code&gt; 에 대해 &lt;code&gt;bool&lt;/code&gt; 로 변환 가능 해야하며 &lt;code&gt;v&lt;/code&gt; 를 수정해서는 안됩니다 . 따라서 &lt;code&gt;T&amp;amp;&lt;/code&gt; 의 매개 변수 유형은 허용되지 않으며 &lt;code&gt;T&lt;/code&gt; 에 대한 이동이 사본과 동일 하지 않은 한 &lt;code&gt;T&lt;/code&gt; 도 아닙니다 (C ++ 11 이후).</target>
        </trans-unit>
        <trans-unit id="1ebb390410881cd226a720f655f581e413a7c60b" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;pred(v)&lt;/code&gt; must be convertible to &lt;code&gt;bool&lt;/code&gt; for every argument &lt;code&gt;v&lt;/code&gt; of type (possibly const) &lt;code&gt;VT&lt;/code&gt;, where &lt;code&gt;VT&lt;/code&gt; is the value type of &lt;code&gt;InputIt&lt;/code&gt;, regardless of &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt;, and must not modify &lt;code&gt;v&lt;/code&gt;. Thus, a parameter type of &lt;code&gt;VT&amp;amp;&lt;/code&gt;is not allowed, nor is &lt;code&gt;VT&lt;/code&gt; unless for &lt;code&gt;VT&lt;/code&gt; a move is equivalent to a copy(since C++11). ​</source>
          <target state="translated">&lt;code&gt;pred(v)&lt;/code&gt; 표현식 은 &lt;code&gt;VT&lt;/code&gt; 유형의 모든 인수 &lt;code&gt;v&lt;/code&gt; 에 대해 &lt;code&gt;bool&lt;/code&gt; 로 변환 가능해야합니다 . 여기서 &lt;code&gt;VT&lt;/code&gt; 는 &lt;a href=&quot;../language/value_category&quot;&gt;value category에&lt;/a&gt; 관계없이 &lt;code&gt;InputIt&lt;/code&gt; 의 값 유형이며 &lt;code&gt;v&lt;/code&gt; 를 수정해서는 안됩니다 . 따라서, 파라미터의 종류 &lt;code&gt;VT&amp;amp;&lt;/code&gt; 허용되지 않으며, 인 &lt;code&gt;VT&lt;/code&gt; 는 위해 않는 &lt;code&gt;VT&lt;/code&gt; 이동은 (11 ++ C 때문에) 복사와 동등하다.</target>
        </trans-unit>
        <trans-unit id="82491c755cffe0cddbb70822fc6e26fa330c289b" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;q(v)&lt;/code&gt; must be convertible to &lt;code&gt;bool&lt;/code&gt; for every argument &lt;code&gt;v&lt;/code&gt; of type (possibly const) &lt;code&gt;VT&lt;/code&gt;, where &lt;code&gt;VT&lt;/code&gt; is the value type of &lt;code&gt;InputIt&lt;/code&gt;, regardless of &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt;, and must not modify &lt;code&gt;v&lt;/code&gt;. Thus, a parameter type of &lt;code&gt;VT&amp;amp;&lt;/code&gt;is not allowed, nor is &lt;code&gt;VT&lt;/code&gt; unless for &lt;code&gt;VT&lt;/code&gt; a move is equivalent to a copy(since C++11). ​</source>
          <target state="translated">식 &lt;code&gt;q(v)&lt;/code&gt; 는 &lt;code&gt;VT&lt;/code&gt; 유형의 모든 인수 &lt;code&gt;v&lt;/code&gt; 에 대해 &lt;code&gt;bool&lt;/code&gt; 로 변환 가능해야합니다 . 여기서 &lt;code&gt;VT&lt;/code&gt; 는 &lt;a href=&quot;../language/value_category&quot;&gt;값 범주에&lt;/a&gt; 관계없이 &lt;code&gt;InputIt&lt;/code&gt; 의 값 유형이며 &lt;code&gt;v&lt;/code&gt; 를 수정해서는 안됩니다 . 따라서, 파라미터의 종류 &lt;code&gt;VT&amp;amp;&lt;/code&gt; 허용되지 않으며, 인 &lt;code&gt;VT&lt;/code&gt; 는 위해 않는 &lt;code&gt;VT&lt;/code&gt; 이동은 (11 ++ C 때문에) 복사와 동등하다.</target>
        </trans-unit>
        <trans-unit id="49bc73e62fcd530ece5b0830e6bbd0253365d4cb" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;std::addressof(E)&lt;/code&gt; is a &lt;a href=&quot;../language/constant_expression&quot;&gt;constant subexpression&lt;/a&gt;, if &lt;code&gt;E&lt;/code&gt; is an lvalue constant subexpression.</source>
          <target state="translated">발현 &lt;code&gt;std::addressof(E)&lt;/code&gt; A는 &lt;a href=&quot;../language/constant_expression&quot;&gt;상수 표현식의&lt;/a&gt; 경우, &lt;code&gt;E&lt;/code&gt; 는 좌변 일정한 하위 표현식이다.</target>
        </trans-unit>
        <trans-unit id="67b8cc9f01423f287b7ad35827c5e57ad0c313d1" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;v.~T()&lt;/code&gt; also must be valid, and, for lvalue &lt;code&gt;v&lt;/code&gt;, the expression &lt;code&gt;&amp;amp;v&lt;/code&gt; must have the type &lt;code&gt;T*&lt;/code&gt; or &lt;code&gt;const T*&lt;/code&gt; and must evaluate to the address of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v.~T()&lt;/code&gt; 표현식 도 유효해야하며 lvalue &lt;code&gt;v&lt;/code&gt; 의 경우 &lt;code&gt;&amp;amp;v&lt;/code&gt; 표현식 은 &lt;code&gt;T*&lt;/code&gt; 또는 &lt;code&gt;const T*&lt;/code&gt; 유형을 가져야하며 &lt;code&gt;v&lt;/code&gt; 주소로 평가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="665d7a4f577c4f3d78f96aba7a62ab512332346a" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;view::all(E)&lt;/code&gt; is expression-equivalent (has the same effect) to:</source>
          <target state="translated">표현식 &lt;code&gt;view::all(E)&lt;/code&gt; 는 다음과 같은 표현식과 동일합니다 (같은 효과가 있음).</target>
        </trans-unit>
        <trans-unit id="904e92ad60024ca361e2c692f767879d8474a6f3" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x - trunc(x/y)*y&lt;/code&gt; may not equal &lt;code&gt;fmod(x,y)&lt;/code&gt; when the rounding of x/y to initialize the argument of trunc loses too much precision (example: x = 30.508474576271183309, y = 6.1016949152542370172).</source>
          <target state="translated">&lt;code&gt;x - trunc(x/y)*y&lt;/code&gt; 인수를 초기화하기위한 x / y 반올림이 정밀도를 너무 많이 잃으면 x-trunc (x / y) * y 표현식 은 &lt;code&gt;fmod(x,y)&lt;/code&gt; 같지 않을 수 있습니다 (예 : x = 30.508474576271183309, y = 6.1016949152542370172).</target>
        </trans-unit>
        <trans-unit id="aa55e431a2c4565661fa1dcb2e324fbc7374b6b2" translate="yes" xml:space="preserve">
          <source>The expression in a contract attribute, contextually converted to &lt;code&gt;bool&lt;/code&gt;, is called its</source>
          <target state="translated">문맥으로 전환 계약 속성의 표현, &lt;code&gt;bool&lt;/code&gt; ,라고 그</target>
        </trans-unit>
        <trans-unit id="fd397bb5ad1c715271d852321a59468dac4bf8e0" translate="yes" xml:space="preserve">
          <source>The expression in the middle of the conditional operator (between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt;) is parsed as if parenthesized: its precedence relative to &lt;code&gt;?:&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885bd0a86f7344aa7addd208200ed06b9ca1b776" translate="yes" xml:space="preserve">
          <source>The expression in the requires-clause of (2) is equivalent to &lt;code&gt;&lt;a href=&quot;../concepts/convertibleto&quot;&gt;ConvertibleTo&lt;/a&gt;&amp;lt;T, R&amp;amp;&amp;gt; &amp;amp;&amp;amp; requires { FUN(declval&amp;lt;T&amp;gt;()); }&lt;/code&gt;, where the exposition-only functions &lt;code&gt;FUN&lt;/code&gt; are declared as &lt;code&gt;void FUN(R&amp;amp;); void FUN(R&amp;amp;&amp;amp;) = delete;&lt;/code&gt;.</source>
          <target state="translated">(2)의 require-clause에있는 표현은 &lt;code&gt;&lt;a href=&quot;../concepts/convertibleto&quot;&gt;ConvertibleTo&lt;/a&gt;&amp;lt;T, R&amp;amp;&amp;gt; &amp;amp;&amp;amp; requires { FUN(declval&amp;lt;T&amp;gt;()); }&lt;/code&gt; , 박람회 전용 함수 &lt;code&gt;FUN&lt;/code&gt; 이 &lt;code&gt;void FUN(R&amp;amp;); void FUN(R&amp;amp;&amp;amp;) = delete;&lt;/code&gt; 로 선언되었습니다 . void FUN (R &amp;amp;&amp;amp;) = 삭제; .</target>
        </trans-unit>
        <trans-unit id="4a21b0ee768bd9b327d1cbd0968cf627a511e659" translate="yes" xml:space="preserve">
          <source>The expression is a constant expression.</source>
          <target state="translated">표현식은 상수 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="f16e21d3bd144a8899aed1761dfc3082f965b05a" translate="yes" xml:space="preserve">
          <source>The expression may contain unary operators in form &lt;code&gt;defined&lt;/code&gt;identifier or &lt;code&gt;defined (&lt;/code&gt;identifier&lt;code&gt;)&lt;/code&gt;. The result is &lt;code&gt;1&lt;/code&gt; if the identifier was &lt;a href=&quot;replace&quot;&gt;defined as a macro name&lt;/a&gt; or the identifier is &lt;a href=&quot;include&quot;&gt;&lt;code&gt;__has_include&lt;/code&gt;&lt;/a&gt;(since C++17), otherwise the result is &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">식은 &lt;code&gt;defined&lt;/code&gt; 식별자 또는 &lt;code&gt;defined (&lt;/code&gt; 식별자 &lt;code&gt;)&lt;/code&gt; 단항 연산자를 포함 할 수 있습니다 . 식별자가 &lt;a href=&quot;replace&quot;&gt;매크로 이름&lt;/a&gt; 으로 정의 된 경우 결과는 &lt;code&gt;1&lt;/code&gt; 입니다. 또는 식별자이다 &lt;a href=&quot;include&quot;&gt; &lt;code&gt;__has_include&lt;/code&gt; &lt;/a&gt; (C ++ 17 때문에), 그렇지 않은 결과가 &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d339ba0adac2cf4ba186cd532857e945e9343eb" translate="yes" xml:space="preserve">
          <source>The expression must have one of the following forms:</source>
          <target state="translated">표현식은 다음 형식 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="231710b26e93a7d7764beca9620416f5a77ff691" translate="yes" xml:space="preserve">
          <source>The expression returns an object such that.</source>
          <target state="translated">표현식은 그런 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea44ea7b24f7bd77e7c8cf33597bd8e37a6afe92" translate="yes" xml:space="preserve">
          <source>The expression that names the function can be.</source>
          <target state="translated">함수의 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab260347bde3009ca03d9d6783a162cf2a08d29" translate="yes" xml:space="preserve">
          <source>The expressions &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))&lt;/code&gt; might seem to have the same effect, but they all will likely result in undefined behavior, attempting to delete the same object twice!</source>
          <target state="translated">표정 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))&lt;/code&gt; 같은 효과가있는 것처럼 보이지만 모두 정의되지 않은 동작이 발생하여 동일한 객체를 두 번 삭제하려고합니다!</target>
        </trans-unit>
        <trans-unit id="cc5889de51b88f428e940c2673c3fc359f09fa6e" translate="yes" xml:space="preserve">
          <source>The expressions &lt;code&gt;T::is_steady&lt;/code&gt; and &lt;code&gt;T::now()&lt;/code&gt; are each well-formed when treated as an unevaluated operand.</source>
          <target state="translated">표현식 &lt;code&gt;T::is_steady&lt;/code&gt; 및 &lt;code&gt;T::now()&lt;/code&gt; 은 평가되지 않은 피연산자로 취급 될 때 각각 잘 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="34901c71cab528a05d379570e30475cde56abe27" translate="yes" xml:space="preserve">
          <source>The expressions &lt;code&gt;a.mf&lt;/code&gt; and &lt;code&gt;p-&amp;gt;mf&lt;/code&gt;, where &lt;code&gt;mf&lt;/code&gt; is a &lt;a href=&quot;member_functions&quot;&gt;non-static member function&lt;/a&gt;, and the expressions &lt;code&gt;a.*pmf&lt;/code&gt; and &lt;code&gt;p-&amp;gt;*pmf&lt;/code&gt;, where &lt;code&gt;pmf&lt;/code&gt; is a &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;pointer to member function&lt;/a&gt;, are classified as prvalue expressions, but they cannot be used to initialize references, as function arguments, or for any purpose at all, except as the left-hand argument of the function call operator, e.g. &lt;code&gt;(p-&amp;gt;*pmf)(args)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a.mf&lt;/code&gt; 및 &lt;code&gt;p-&amp;gt;mf&lt;/code&gt; 표현식 ( 여기서 &lt;code&gt;mf&lt;/code&gt; 는 &lt;a href=&quot;member_functions&quot;&gt;비 정적 멤버 함수 &lt;/a&gt; &lt;code&gt;p-&amp;gt;*pmf&lt;/code&gt; 및 &lt;code&gt;a.*pmf&lt;/code&gt; 및 p-&amp;gt; * pmf 표현식 ( 여기서 &lt;code&gt;pmf&lt;/code&gt; 는 &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;멤버 함수에&lt;/a&gt; 대한 포인터 임)은 prvalue 표현식으로 분류됩니다. 그러나 함수 호출 연산자의 왼쪽 인수 &lt;code&gt;(p-&amp;gt;*pmf)(args)&lt;/code&gt; 예 : (p-&amp;gt; * pmf) (args))를 제외하고는 참조를 함수 인수 또는 초기화하는 데 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9cca2c19bac42464027e1a3c56fa7393e2441fac" translate="yes" xml:space="preserve">
          <source>The expressions that can be moved from are called &quot;rvalue expressions&quot;. Both prvalues and xvalues are rvalue expressions.</source>
          <target state="translated">이동할 수있는 표현식을 &quot;rvalue 표현식&quot;이라고합니다. prvalue와 xvalue는 모두 rvalue 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="b3811de048b8c0719daab80a97fd886fb125015a" translate="yes" xml:space="preserve">
          <source>The expressions that have identity are called &quot;glvalue expressions&quot; (glvalue stands for &quot;generalized lvalue&quot;). Both lvalues and xvalues are glvalue expressions.</source>
          <target state="translated">동일성을 갖는 표현식을 &quot;glvalue 표현식&quot;이라고합니다 (glvalue는 &quot;일반화 된 lvalue&quot;를 나타냄). lvalue와 xvalue는 모두 glvalue 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="55676a08069cb5f513f31726af6380f2a1648ac0" translate="yes" xml:space="preserve">
          <source>The extension as returned by this function includes a period to make it possible to distinguish the file that ends with a period (function returns &lt;code&gt;&quot;.&quot;&lt;/code&gt;) from a file with no extension (function returns &lt;code&gt;&quot;&quot;&lt;/code&gt;).</source>
          <target state="translated">이 함수에 의해 반환 된 확장자는 마침표로 끝나는 파일 (함수는 &lt;code&gt;&quot;.&quot;&lt;/code&gt; )을 확장자가없는 파일 (함수는 &lt;code&gt;&quot;&quot;&lt;/code&gt; ) 로 구별 할 수있는 마침표를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="13bea24b4a4e8e50405556b05a63f04b74e94e6c" translate="yes" xml:space="preserve">
          <source>The extension of the current pathname or an empty path if there's no extension.</source>
          <target state="translated">현재 경로명의 확장자 또는 확장자가없는 경우 빈 경로.</target>
        </trans-unit>
        <trans-unit id="f3ad5e575ce7611c83adc14804313b5885a8f1e2" translate="yes" xml:space="preserve">
          <source>The extent &lt;code&gt;E&lt;/code&gt; of the span returned by (1) is determined as follows:</source>
          <target state="translated">(1)에 의해 반환 된 범위의 범위 &lt;code&gt;E&lt;/code&gt; 는 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="21ef62f13c61e48aa5fc7ae1f2fc5e8fd87da3dd" translate="yes" xml:space="preserve">
          <source>The extraction operation in &lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt; behaves as a &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt; 의 추출 작업 은 &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction으로&lt;/a&gt; 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="8997cdfb4c9592dee5dc60e1be61905e38917e65" translate="yes" xml:space="preserve">
          <source>The extraction operators of all &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistributions&lt;/a&gt;, if bad input is encountered.</source>
          <target state="translated">모든 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistributions&lt;/a&gt; 의 추출 연산자입력이 잘못되면 .</target>
        </trans-unit>
        <trans-unit id="c6f16b18faa3bc7f8569c2fec0b657e8169e9ecf" translate="yes" xml:space="preserve">
          <source>The extraction operators of all &lt;a href=&quot;../../named_req/randomnumberengine&quot;&gt;RandomNumberEngines&lt;/a&gt;, if bad input is encountered.</source>
          <target state="translated">입력이 잘못되면 모든 &lt;a href=&quot;../../named_req/randomnumberengine&quot;&gt;RandomNumberEngines&lt;/a&gt; 의 추출 연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="9d05fc65ffd95b0140790a558b6a89968ddea9e7" translate="yes" xml:space="preserve">
          <source>The facet &lt;code&gt;std::moneypunct&lt;/code&gt; encapsulates monetary value format preferences. Stream I/O manipulators &lt;code&gt;&lt;a href=&quot;../io/manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io/manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt; use &lt;code&gt;std::moneypunct&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; for parsing monetary value input and formatting monetary value output.</source>
          <target state="translated">패싯 &lt;code&gt;std::moneypunct&lt;/code&gt; 는 금전적 가치 형식 환경 설정을 캡슐화합니다. 스트림이 I / O 매니퓰레이터 &lt;code&gt;&lt;a href=&quot;../io/manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../io/manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt; 사용 &lt;code&gt;std::moneypunct&lt;/code&gt; 통해 &lt;code&gt;&lt;a href=&quot;money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; 통화 값 입력을 해석 및 통화 값 출력 포맷에 대한.</target>
        </trans-unit>
        <trans-unit id="ea98fc46164fdd46a66b2e0e45e334aa270845d4" translate="yes" xml:space="preserve">
          <source>The facet &lt;code&gt;std::numpunct&lt;/code&gt; encapsulates numeric punctuation preferences. Stream I/O operations use &lt;code&gt;std::numpunct&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;num_get&quot;&gt;std::num_get&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;num_put&quot;&gt;std::num_put&lt;/a&gt;&lt;/code&gt; for parsing numeric input and formatting numeric output.</source>
          <target state="translated">패싯 &lt;code&gt;std::numpunct&lt;/code&gt; 는 숫자 문장 부호 환경 설정을 캡슐화합니다. 스트림 I / O 작업은 &lt;code&gt;std::numpunct&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;num_get&quot;&gt;std::num_get&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;num_put&quot;&gt;std::num_put&lt;/a&gt;&lt;/code&gt; 하여 숫자 입력을 구문 분석하고 숫자 출력을 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="58b1988e5fdc61555470b365aef2ee1b1f8c685c" translate="yes" xml:space="preserve">
          <source>The facets &lt;code&gt;&lt;a href=&quot;codecvt_utf8&quot;&gt;std::codecvt_utf8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;codecvt_utf16&quot;&gt;std::codecvt_utf16&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;codecvt_utf8_utf16&quot;&gt;std::codecvt_utf8_utf16&lt;/a&gt;&lt;/code&gt; accept an optional value of type &lt;code&gt;std::codecvt_mode&lt;/code&gt; as a template argument, which specifies optional features of the unicode string conversion.</source>
          <target state="translated">패싯 &lt;code&gt;&lt;a href=&quot;codecvt_utf8&quot;&gt;std::codecvt_utf8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;codecvt_utf16&quot;&gt;std::codecvt_utf16&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;codecvt_utf8_utf16&quot;&gt;std::codecvt_utf8_utf16&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;std::codecvt_mode&lt;/code&gt; 유형의 선택적 값을 템플리트 인수로 채택하여 유니 코드 문자열 변환의 선택적 기능을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="21a8e0fce58e2da39234e8680e0b14336ba0b8ac" translate="yes" xml:space="preserve">
          <source>The failbit</source>
          <target state="translated">페일 비트</target>
        </trans-unit>
        <trans-unit id="18566aa84f9e67e30bdc8f0bbe052925c5246031" translate="yes" xml:space="preserve">
          <source>The failbit is set by the following standard library functions:</source>
          <target state="translated">페일 비트는 다음 표준 라이브러리 기능으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f16334c667365ad2f6c42f2b1d2344131a47226b" translate="yes" xml:space="preserve">
          <source>The fictional constructors for the purpose of overload resolution (described above) are explicit if they correspond to an implicitly-generated deduction guide formed from an explicit constructor or to a user-defined deduction guide that uses the keyword &lt;code&gt;explicit&lt;/code&gt;. As always, such constructors are ignored in copy-initialization context:</source>
          <target state="translated">과부하 해결을위한 가상의 생성자 (위에서 설명 함)는 명시 적 생성자에서 생성 된 암시 적으로 생성 된 추론 가이드 또는 &lt;code&gt;explicit&lt;/code&gt; 키워드를 사용하는 사용자 정의 추론 가이드에 해당하는 경우 명시 적입니다. 입니다. 항상 그렇듯이 이러한 생성자는 복사 초기화 컨텍스트에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="eafa07d54f48e5fabf0fb077805403e664068140" translate="yes" xml:space="preserve">
          <source>The field width before the call to the function.</source>
          <target state="translated">함수 호출 전의 필드 너비</target>
        </trans-unit>
        <trans-unit id="2f2ded8c6ec6225067551f261401ae1283fdd943" translate="yes" xml:space="preserve">
          <source>The file is opened as a binary file for update (as by &lt;code&gt;&lt;a href=&quot;fopen&quot;&gt;std::fopen&lt;/a&gt;&lt;/code&gt; with access mode &lt;code&gt;&quot;wb+&quot;&lt;/code&gt;). At least &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;TMP_MAX&lt;/a&gt;&lt;/code&gt; files may be opened during the lifetime of a program (this limit may be shared with &lt;code&gt;&lt;a href=&quot;tmpnam&quot;&gt;std::tmpnam&lt;/a&gt;&lt;/code&gt; and may be further limited by &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;FOPEN_MAX&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">액세스 모드가 &lt;code&gt;&quot;wb+&quot;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;fopen&quot;&gt;std::fopen&lt;/a&gt;&lt;/code&gt; 의해 파일이 업데이트를위한 이진 파일로 열립니다 . 프로그램 수명 동안 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;TMP_MAX&lt;/a&gt;&lt;/code&gt; 파일 이상 이 열릴 수 있습니다 (이 제한은 &lt;code&gt;&lt;a href=&quot;tmpnam&quot;&gt;std::tmpnam&lt;/a&gt;&lt;/code&gt; 과 공유 될 수 있으며 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;FOPEN_MAX&lt;/a&gt;&lt;/code&gt; 에 의해 더 제한 될 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="6ac41de8ef3462b9d25a0be25782c2d9eb8467a9" translate="yes" xml:space="preserve">
          <source>The file is opened as if by calling &lt;code&gt;&lt;a href=&quot;../c/fopen&quot;&gt;std::fopen&lt;/a&gt;&lt;/code&gt; with the second argument (&lt;code&gt;mode&lt;/code&gt;) determined as follows:</source>
          <target state="translated">파일은 &lt;code&gt;&lt;a href=&quot;../c/fopen&quot;&gt;std::fopen&lt;/a&gt;&lt;/code&gt; 을 두 번째 인수 ( &lt;code&gt;mode&lt;/code&gt; 다음과 같이 결정된 ) .</target>
        </trans-unit>
        <trans-unit id="713295cf62f82f602674e62dd30e404b198ed140" translate="yes" xml:space="preserve">
          <source>The file status (a &lt;code&gt;&lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt;&lt;/code&gt; object).</source>
          <target state="translated">파일 상태 ( &lt;code&gt;&lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt;&lt;/code&gt; 객체)</target>
        </trans-unit>
        <trans-unit id="769141f7f9b5a5142e1255a4ab88fe7d4db964a7" translate="yes" xml:space="preserve">
          <source>The file's user group has execute/search permission</source>
          <target state="translated">파일의 사용자 그룹에 실행 / 검색 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="70bc69312668a45ccd09783b9c8fded122da0f78" translate="yes" xml:space="preserve">
          <source>The file's user group has read permission</source>
          <target state="translated">파일의 사용자 그룹에 읽기 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="2b12b2de176ac00b49030d0c10f4d9c793a3623c" translate="yes" xml:space="preserve">
          <source>The file's user group has read, write, and execute/search permissions</source>
          <target state="translated">파일의 사용자 그룹에 읽기, 쓰기 및 실행 / 검색 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="508ebbae7fd4ffdc0936fb88a642dca72e49df4d" translate="yes" xml:space="preserve">
          <source>The file's user group has write permission</source>
          <target state="translated">파일의 사용자 그룹에 쓰기 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="86f9ab3f6b7423cdeedf82917cbf947c4e1cc032" translate="yes" xml:space="preserve">
          <source>The filename identified by the path.</source>
          <target state="translated">경로로 식별되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="733546e14fff65a40e6ce4f6ae3b5c334093f0a7" translate="yes" xml:space="preserve">
          <source>The filesystem information (a &lt;a href=&quot;space_info&quot;&gt;space_info&lt;/a&gt; object).</source>
          <target state="translated">파일 시스템 정보 ( &lt;a href=&quot;space_info&quot;&gt;space_info&lt;/a&gt; 객체)</target>
        </trans-unit>
        <trans-unit id="043742725d326d5a9ca6387b893c4cbc6e5566e1" translate="yes" xml:space="preserve">
          <source>The filesystem library facilities may be unavailable if a hierarchical file system is not accessible to the implementation, or if it does not provide the necessary capabilities. Some features may not be available if they are not supported by the underlying file system (e.g. the FAT filesystem lacks symbolic links and forbids multiple hardlinks). In those cases, errors must be reported.</source>
          <target state="translated">계층 적 파일 시스템이 구현에 액세스 할 수 없거나 필요한 기능을 제공하지 않으면 파일 시스템 라이브러리 기능을 사용하지 못할 수 있습니다. 기본 파일 시스템에서 지원하지 않는 일부 기능은 사용할 수 없습니다 (예 : FAT 파일 시스템에는 심볼릭 링크가없고 여러 개의 하드 링크가 금지됨). 이 경우 오류를보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="25654428d5eeb26f93fee804e58fcb777e86a34e" translate="yes" xml:space="preserve">
          <source>The filesystem library was originally developed as &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystem&lt;/a&gt;, was published as &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/fs&quot;&gt;the technical specification ISO/IEC TS 18822:2015&lt;/a&gt;, and finally merged to ISO C++ as of C++17. The boost implementation is currently available on more compilers and platforms than the C++17 library.</source>
          <target state="translated">파일 시스템 라이브러리는 원래 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystem으로&lt;/a&gt; 개발되었으며 &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/fs&quot;&gt;기술 사양 ISO / IEC TS 18822 : 2015&lt;/a&gt; 로 게시되었으며 C ++ 17 현재 ISO C ++에 병합되었습니다. 부스트 구현은 현재 C ++ 17 라이브러리보다 더 많은 컴파일러와 플랫폼에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eafb9282f9f742fde3db1064d82179ea3b8c2de9" translate="yes" xml:space="preserve">
          <source>The final value of &lt;code&gt;acc&lt;/code&gt; as described above.</source>
          <target state="translated">위에서 설명한 &lt;code&gt;acc&lt;/code&gt; 의 최종 값 .</target>
        </trans-unit>
        <trans-unit id="5e8e4ef756882f2ecb926b4da6aad7ade4184995" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;count&lt;/code&gt; characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4328e7f9e3a9a13684496bc48cded7c2545d55e5" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;sub_match&lt;/code&gt; (index 0) contained in a &lt;code&gt;match_result&lt;/code&gt; always represents the full match within a target sequence made by a regex, and subsequent &lt;code&gt;sub_match&lt;/code&gt;es represent sub-expression matches corresponding in sequence to the left parenthesis delimiting the sub-expression in the regex.</source>
          <target state="translated">&lt;code&gt;match_result&lt;/code&gt; 에 포함 된 첫 번째 &lt;code&gt;sub_match&lt;/code&gt; (인덱스 0)는 항상 정규 표현식에 의해 만들어진 대상 시퀀스 내에서 전체 일치를 나타내며, 이후 &lt;code&gt;sub_match&lt;/code&gt; 는 es는 정규 표현식에서 하위 표현식을 한정하는 왼쪽 괄호에 해당하는 하위 표현식 일치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d51ed3d9e41b13a5f5ede9888191304e6306505d" translate="yes" xml:space="preserve">
          <source>The first bit of the bitset corresponds to the least significant digit of the number and the last bit corresponds to the most significant digit.</source>
          <target state="translated">비트 세트의 첫 번째 비트는 숫자의 최하위 숫자에 해당하고 마지막 비트는 최상위 유효 숫자에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="87900467b85ef3761625a54c72c300b0d56a1c5f" translate="yes" xml:space="preserve">
          <source>The first character in</source>
          <target state="translated">첫 번째 캐릭터</target>
        </trans-unit>
        <trans-unit id="4655a7d7dda81fdaacd44983c104e6b51909f569" translate="yes" xml:space="preserve">
          <source>The first choice that satisfies the requirements of the respective cast operator is selected, even if it cannot be compiled (see example). If the cast can be interpreted in more than one way as &lt;code&gt;static_cast&lt;/code&gt; followed by a &lt;code&gt;const_cast&lt;/code&gt;, it cannot be compiled.</source>
          <target state="translated">컴파일 할 수없는 경우에도 각 캐스트 연산자의 요구 사항을 충족시키는 첫 번째 선택이 선택됩니다 (예 참조). 캐스트가 &lt;code&gt;static_cast&lt;/code&gt; 다음에 &lt;code&gt;const_cast&lt;/code&gt; 로 여러 가지 방법으로 해석 될 수 있으면 컴파일 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f54508384b9cd8ec3f1662178af12ad22007b3fc" translate="yes" xml:space="preserve">
          <source>The first declaration of a function must specify all contract conditions (if any) of the function. Subsequent redeclarations must either specify no contract conditions or the same list of contract conditions; no diagnostic is required if corresponding conditions will always evaluate to the same value. If the same function is declared in two different translation units, the list of contract conditions shall be the same; no diagnostic is required.</source>
          <target state="translated">함수의 첫 번째 선언은 함수의 모든 계약 조건 (있는 경우)을 지정해야합니다. 후속 재 선언은 계약 조건을 지정하지 않거나 동일한 계약 조건 목록을 지정해야합니다. 해당 조건이 항상 동일한 값으로 평가되는 경우 진단이 필요하지 않습니다. 동일한 기능이 두 개의 다른 번역 단위로 선언 된 경우 계약 조건 목록은 동일해야합니다. 진단이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb9460452be12a6ef732fc7e63d7c1246d008e71" translate="yes" xml:space="preserve">
          <source>The first declaration of the function must specify this attribute if any declaration specifies it. If a function is declared with &lt;code&gt;[[&lt;strong&gt;noreturn&lt;/strong&gt;]]&lt;/code&gt; in one translation unit, and the same function is declared without &lt;code&gt;[[&lt;strong&gt;noreturn&lt;/strong&gt;]]&lt;/code&gt; in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">선언이 지정하는 경우 함수의 첫 번째 선언에서이 속성을 지정해야합니다. 함수가 선언되면 &lt;code&gt;[[&lt;strong&gt;noreturn&lt;/strong&gt;]]&lt;/code&gt; 하나의 변환 부와 동일한 기능에 않고 선언 &lt;code&gt;[[&lt;strong&gt;noreturn&lt;/strong&gt;]]&lt;/code&gt; 다른 변환 장치에있어서, 프로그램이 잘못 형성되고; 진단이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55a8fcb384ef46460f279aa40b2cbfd4005f7ca4" translate="yes" xml:space="preserve">
          <source>The first dimension of zero is acceptable, and the allocation function is called.</source>
          <target state="translated">첫 번째 차원 인 0이 허용되며 할당 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b01b52628d903b5a8752c89193d50414f41bb7df" translate="yes" xml:space="preserve">
          <source>The first few Legendre polynomials are:</source>
          <target state="translated">처음 몇 가지 Legendre 다항식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="667b730cf08aa006a135d605773de9d08b22a256" translate="yes" xml:space="preserve">
          <source>The first few are:</source>
          <target state="translated">처음 몇 가지는 :</target>
        </trans-unit>
        <trans-unit id="565d7c02d665f0e34f4688a944d25092dc5069f3" translate="yes" xml:space="preserve">
          <source>The first few associated Legendre polynomials are:</source>
          <target state="translated">처음 몇 개의 관련 Legendre 다항식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59d42cf5c59ef03d9f21e976e9211c12f3707cda" translate="yes" xml:space="preserve">
          <source>The first hexadecimal digit is not &lt;code&gt;0&lt;/code&gt; if the argument is a normalized floating point value. If the value is &lt;code&gt;​0​&lt;/code&gt;, the exponent is also &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5b57b07c6d8c22dee48b2696636cbb5d4d9965f" translate="yes" xml:space="preserve">
          <source>The first mismatching element defines which range is lexicographically</source>
          <target state="translated">첫 번째 불일치 요소는 사전 식으로 범위를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="85aefccf8c9b3c2cd0c976b63196e9f569cb09b9" translate="yes" xml:space="preserve">
          <source>The first of the following that applies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6410b256258044cf5d55a9090da038f2bcd0e444" translate="yes" xml:space="preserve">
          <source>The first operand of both operators is evaluated even if it is not necessary (e.g. when the second operand names a static member).</source>
          <target state="translated">두 연산자의 첫 번째 피연산자는 필요하지 않은 경우에도 평가됩니다 (예 : 두 번째 피연산자의 이름이 정적 멤버 인 경우).</target>
        </trans-unit>
        <trans-unit id="df485b1c8b6435c21120b67dccdfb9636e9183ea" translate="yes" xml:space="preserve">
          <source>The first operand of the conditional operator is evaluated and &lt;a href=&quot;implicit_cast&quot;&gt;contextually converted&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;. After both the value evaluation and all side effects of the first operand are completed, if the result was &lt;code&gt;true&lt;/code&gt;, the second operand is evaluated. If the result was &lt;code&gt;false&lt;/code&gt;, the third operand is evaluated.</source>
          <target state="translated">조건부 연산자의 첫 번째 피연산자는 평가되어 &lt;a href=&quot;implicit_cast&quot;&gt;상황에&lt;/a&gt; 따라 &lt;code&gt;bool&lt;/code&gt; 로 변환 됩니다 . 첫 번째 피연산자의 값 평가 및 모든 부작용이 완료된 후 결과가 &lt;code&gt;true&lt;/code&gt; 이면 두 번째 피연산자가 평가됩니다. 결과가 &lt;code&gt;false&lt;/code&gt; 이면 세 번째 피연산자가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="44633ae931db3c64d32820feb99f04264ea39dd8" translate="yes" xml:space="preserve">
          <source>The first overload is called when only the format string is passed and there is no parameter expansion.</source>
          <target state="translated">형식 문자열 만 전달되고 매개 변수 확장이없는 경우 첫 번째 과부하가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="afa25bc7ebcd1dfe0877a490b5e734c564901f7c" translate="yes" xml:space="preserve">
          <source>The first version initializes new characters to &lt;code&gt;CharT()&lt;/code&gt;, the second version initializes new characters to &lt;code&gt;ch&lt;/code&gt;.</source>
          <target state="translated">첫 번째 버전은 새 문자를 &lt;code&gt;CharT()&lt;/code&gt; 초기화하고 두 번째 버전은 새 문자를 &lt;code&gt;ch&lt;/code&gt; 로 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="95875c290364c0a010e6be578275da15929396a0" translate="yes" xml:space="preserve">
          <source>The first version is an implicit conversion, the second one is explicit.</source>
          <target state="translated">첫 번째 버전은 암시 적 변환이고 두 번째 버전은 명시 적입니다.</target>
        </trans-unit>
        <trans-unit id="4aa20401aee62fc4db9195034b5ac4c80d183a7a" translate="yes" xml:space="preserve">
          <source>The first version is equivalent to &lt;code&gt;getline(s, count, widen('\n'))&lt;/code&gt;.</source>
          <target state="translated">첫 번째 버전은 &lt;code&gt;getline(s, count, widen('\n'))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0a5661e270139bd14512e2492907446f45e122d" translate="yes" xml:space="preserve">
          <source>The first version of the function uses &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the elements, the second uses the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">함수의 첫 번째 버전은 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 를 사용하여 요소를 비교하고 두 번째 버전은 주어진 비교 함수 &lt;code&gt;comp&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ba9ee638dac0b17d1eff10cf111fdc719b994440" translate="yes" xml:space="preserve">
          <source>The first version uses &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the elements, the second version uses the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">첫 번째 버전은 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 를 사용하여 요소를 비교하고 두 번째 버전은 주어진 비교 함수 &lt;code&gt;comp&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b00a2e1db9ea8753c669bcafceebdf4e5001f0a2" translate="yes" xml:space="preserve">
          <source>The first version uses the associated parameter set, the second version uses &lt;code&gt;params&lt;/code&gt;. The associated parameter set is not modified.</source>
          <target state="translated">첫 번째 버전은 연관된 매개 변수 세트를 사용하고 두 번째 버전은 &lt;code&gt;params&lt;/code&gt; 를 사용합니다 . 연관된 매개 변수 세트가 수정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ea51a875efb11ad49d51139f65a4fbab7c5f7404" translate="yes" xml:space="preserve">
          <source>The floating point conversion functions convert infinity to &lt;code&gt;inf&lt;/code&gt; or &lt;code&gt;infinity&lt;/code&gt;. Which one is used is implementation defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b597147660929213aeb7af0d263130200afccc" translate="yes" xml:space="preserve">
          <source>The floating-point environment access and modification is only meaningful when &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is supported and is set to &lt;code&gt;ON&lt;/code&gt;. Otherwise the implementation is free to assume that floating-point control modes are always the default ones and that floating-point status flags are never tested or modified. In practice, few current compilers, such as HP aCC, Oracle Studio, or IBM XL, support the &lt;code&gt;#pragma&lt;/code&gt; explicitly, but most compilers allow meaningful access to the floating-point environment anyway.</source>
          <target state="translated">부동 소수점 환경 액세스 및 수정은 &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt; 가 지원되고 &lt;code&gt;ON&lt;/code&gt; 으로 설정된 경우에만 의미가 있습니다. 그렇지 않으면 구현시 부동 소수점 제어 모드가 항상 기본 모드이고 부동 소수점 상태 플래그는 테스트 또는 수정되지 않는다고 가정 할 수 있습니다. 실제로 HP aCC, Oracle Studio 또는 IBM XL과 같은 현재 컴파일러는 &lt;code&gt;#pragma&lt;/code&gt; 를 명시 적으로 지원 하지만 대부분의 컴파일러는 부동 소수점 환경에 대한 의미있는 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d88a487f9a81a8c43facb1ab36c14a9792a2394f" translate="yes" xml:space="preserve">
          <source>The floating-point environment is the set of floating-point status flags and control modes supported by the implementation. It is thread-local, each thread inherits the initial state of its floating-point environment from the parent thread. Floating-point operations modify the floating-point status flags to indicate abnormal results or auxiliary information. The state of floating-point control modes affects the outcomes of some floating-point operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5512f3fb37483c2ac0de738d3e042411a6ef7a1" translate="yes" xml:space="preserve">
          <source>The floating-point exceptions are not related to the C++ exceptions. When a floating-point operation raises a floating-point exception, the status of the floating-point environment changes, which can be tested with &lt;code&gt;&lt;a href=&quot;fenv/fetestexcept&quot;&gt;std::fetestexcept&lt;/a&gt;&lt;/code&gt;, but the execution of a C++ program on most implementations continues uninterrupted.</source>
          <target state="translated">부동 소수점 예외는 C ++ 예외와 관련이 없습니다. 부동 소수점 연산에서 부동 소수점 예외가 발생하면 부동 소수점 환경의 상태가 변경되어 &lt;code&gt;&lt;a href=&quot;fenv/fetestexcept&quot;&gt;std::fetestexcept&lt;/a&gt;&lt;/code&gt; 로 테스트 할 수 있지만 대부분의 구현에서 C ++ 프로그램 실행은 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f30dcca8094f65496cbe7b9cb343a1867b9353f" translate="yes" xml:space="preserve">
          <source>The floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt; calculated by this function is exactly the value &lt;code&gt;x - n*y&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;x/y&lt;/code&gt; with its fractional part truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3cc83866f6c3e25d14af7dc8655c91815c1a49" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../types#Type_properties&quot;&gt;type properties&lt;/a&gt; all satisfy &lt;strong&gt;UnaryTypeTrait&lt;/strong&gt;.</source>
          <target state="translated">다음 &lt;a href=&quot;../types#Type_properties&quot;&gt;유형 속성은&lt;/a&gt; 모두 &lt;strong&gt;UnaryTypeTrait를&lt;/strong&gt; 충족 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c6933bfa65ffad8899ab7c8d9bdf9518aad67471" translate="yes" xml:space="preserve">
          <source>The following Unicode character ranges are allowed in identifiers:</source>
          <target state="translated">식별자에는 다음과 같은 유니 코드 문자 범위가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce299bcc84d68ff1aba24c28b4e197eaad883716" translate="yes" xml:space="preserve">
          <source>The following Unicode character ranges are not allowed to begin an identifier:</source>
          <target state="translated">다음 유니 코드 문자 범위는 식별자를 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="715611d9963a8924bbf3fe5d5a3d4258306a6df4" translate="yes" xml:space="preserve">
          <source>The following additional macro names may be predefined by the implementations.</source>
          <target state="translated">다음의 추가 매크로 이름은 구현에 의해 사전 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e24798a70fec6c195e663fa63cc0f808e58ff2b3" translate="yes" xml:space="preserve">
          <source>The following algorithm is used (adapted from the initialization sequence of the Mersenne Twister generator by &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html&quot;&gt;Makoto Matsumoto and Takuji Nishimura&lt;/a&gt;, incorporating the improvements made by &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/M062821.pdf&quot;&gt;Mutsuo Saito in 2007&lt;/a&gt;).</source>
          <target state="translated">다음 알고리즘이 사용됩니다 ( &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html&quot;&gt;Matsumoto Makatsu와 Nishimura Takuji&lt;/a&gt; 의 Mersenne Twister 생성기의 초기화 순서에 따라 &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/M062821.pdf&quot;&gt;2007 년 Saitsu Mutsuo&lt;/a&gt; 의 개선 사항을 통합 함 ).</target>
        </trans-unit>
        <trans-unit id="2314e69040372621d3d5adf2b163840d6d43e0d3" translate="yes" xml:space="preserve">
          <source>The following aspects of the preprocessor can be controlled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74706a2fb1fc7153905dea134481e83cf2e40ad9" translate="yes" xml:space="preserve">
          <source>The following auxiliary types are defined:</source>
          <target state="translated">다음과 같은 보조 유형이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d1942c772e8a48f22736696ffec9a1f67d5b278c" translate="yes" xml:space="preserve">
          <source>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</source>
          <target state="translated">다음 동작 변경 결함 보고서는 이전에 게시 된 C ++ 표준에 소급 적용되었습니다.</target>
        </trans-unit>
        <trans-unit id="d05b783a3d925110f2634b9ba6635b8a281741d7" translate="yes" xml:space="preserve">
          <source>The following character classes are always recognized, in both narrow and wide character forms, and the classifications returned (with &lt;code&gt;icase == false&lt;/code&gt;) correspond to the matching classifications obtained by the &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet of the imbued locale, as follows:</source>
          <target state="translated">다음 문자 클래스는 좁은 문자 형식과 넓은 문자 형식으로 항상 인식되며 반환 된 분류 ( &lt;code&gt;icase == false&lt;/code&gt; ) 는 다음과 같이 임베딩 된 로캘 의 &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에서 얻은 일치하는 분류에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="bf5ea285c72c7d87a0b9f0ab566e300cf0d96f2e" translate="yes" xml:space="preserve">
          <source>The following chart contains all 128 ASCII decimal &lt;b&gt;(dec)&lt;/b&gt;, octal &lt;b&gt;(oct)&lt;/b&gt;, hexadecimal &lt;b&gt;(hex)&lt;/b&gt; and character &lt;b&gt;(ch)&lt;/b&gt; codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c747583390a9820664d5aa67d943444234016ea2" translate="yes" xml:space="preserve">
          <source>The following class of the standard library is an error condition enum: &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리의 다음 클래스는 오류 조건 enum입니다 : &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8364204eadf48b5388b1f4de9301dfb37e2a396" translate="yes" xml:space="preserve">
          <source>The following classes of the standard library are an error code enum:</source>
          <target state="translated">표준 라이브러리의 다음 클래스는 오류 코드 열거 형입니다.</target>
        </trans-unit>
        <trans-unit id="8732ed855c5d920731ff99c5c10a7b6ebb60e4fe" translate="yes" xml:space="preserve">
          <source>The following code at first replaces all occurrences of &lt;code&gt;8&lt;/code&gt; with &lt;code&gt;88&lt;/code&gt; in a vector of integers. Then it replaces all values less than &lt;code&gt;5&lt;/code&gt; with 55.</source>
          <target state="translated">다음 코드는 처음 에 정수 벡터에서 &lt;code&gt;8&lt;/code&gt; 을 &lt;code&gt;88&lt;/code&gt; 로 바꿉니다 . 그런 다음 &lt;code&gt;5&lt;/code&gt; 미만의 모든 값 을 55로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="82f830d3ac2fe040b835d20a0c75f5f9921a6510" translate="yes" xml:space="preserve">
          <source>The following code is an implementation of merge sort.</source>
          <target state="translated">다음 코드는 병합 정렬을 구현 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f2984910c4f4c900817f0230094b1cf9623f27d6" translate="yes" xml:space="preserve">
          <source>The following code moves thread objects (which themselves are not copyable) from one container to another.</source>
          <target state="translated">다음 코드는 스레드 객체 (자체를 복사 할 수 없음)를 한 컨테이너에서 다른 컨테이너로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="3d1d996516f45090f4b4bb31b8fbcff81de4e254" translate="yes" xml:space="preserve">
          <source>The following code outputs a string while erasing the spaces on the fly.</source>
          <target state="translated">다음 코드는 공백을 지우는 동안 문자열을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="6681c260a962e645895e071bac822e36d3efd9cf" translate="yes" xml:space="preserve">
          <source>The following code prints all six permutations of the string &quot;abc&quot; in reverse order.</source>
          <target state="translated">다음 코드는 문자열 &quot;abc&quot;의 6 개의 순열을 모두 역순으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1e98cb5078430d68744bd2c66d23b0ba09341ee5" translate="yes" xml:space="preserve">
          <source>The following code prints all three permutations of the string &quot;aba&quot;</source>
          <target state="translated">다음 코드는 문자열 &quot;aba&quot;의 세 가지 순열을 모두 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="7d753163245e6f077f885c57e9d563d585a1f2a3" translate="yes" xml:space="preserve">
          <source>The following code randomly shuffles the integers 1..10:</source>
          <target state="translated">다음 코드는 정수 1..10을 무작위로 섞습니다.</target>
        </trans-unit>
        <trans-unit id="96fdf8bcc92fd6fc1514e41f0d3d41b7c151059a" translate="yes" xml:space="preserve">
          <source>The following code redirects &lt;code&gt;stdout&lt;/code&gt; to a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf8e44086be369b39f43315df08ec560ee7a479" translate="yes" xml:space="preserve">
          <source>The following code removes all spaces from a string by shifting all non-space characters to the left and then erasing the extra. This is an example of &lt;a href=&quot;https://en.wikipedia.org/wiki/Erase-remove_idiom&quot;&gt;erase-remove idiom&lt;/a&gt;.</source>
          <target state="translated">다음 코드는 공백이 아닌 모든 문자를 왼쪽으로 이동 한 다음 추가 문자를 삭제하여 문자열에서 모든 공백을 제거합니다. 이것은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Erase-remove_idiom&quot;&gt;지우개 제거 관용구&lt;/a&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="9be8c7e04c9b3934c9c5ede040503539ce05a2fe" translate="yes" xml:space="preserve">
          <source>The following code searches for any of specified integers in a vector of integers:</source>
          <target state="translated">다음 코드는 정수 벡터에서 지정된 정수를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="00e613fa44e8f8f364e737178e8c427efa44a732" translate="yes" xml:space="preserve">
          <source>The following code shows how to specialize the &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; template for a custom class.</source>
          <target state="translated">다음 코드는 사용자 정의 클래스에 대한 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 템플리트 를 특수화하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="23ddc096f3f59b5526632dcad35827175dfd931c" translate="yes" xml:space="preserve">
          <source>The following code shows one possible output of a hash function used on a string:</source>
          <target state="translated">다음 코드는 문자열에 사용되는 해시 함수의 가능한 출력을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2bae909517e9a54627909804e4056eeb94460b31" translate="yes" xml:space="preserve">
          <source>The following code shows one possible output of a hash function used on several bitsets:</source>
          <target state="translated">다음 코드는 여러 비트 세트에서 사용되는 해시 함수의 가능한 출력을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="61f8a465316f532cbe57d8d9926e5d98dcebc6f3" translate="yes" xml:space="preserve">
          <source>The following code shows several examples (both valid and invalid) of how to construct durations:</source>
          <target state="translated">다음 코드는 기간을 구성하는 방법에 대한 몇 가지 예 (유효 및 무효)를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="658a27868658d811802dfd09763d67bfdebbe052" translate="yes" xml:space="preserve">
          <source>The following code shows several usage cases of the</source>
          <target state="translated">다음 코드는 몇 가지 사용 사례를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="75667b2fdd4a0d1d95649b65bd0a58cfcd96e3fd" translate="yes" xml:space="preserve">
          <source>The following code shows the creation of function objects with a placeholder argument.</source>
          <target state="translated">다음 코드는 자리 표시 자 인수를 사용하여 함수 객체를 만드는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b44e4d7ca655051be7c514be24da563a5ff68434" translate="yes" xml:space="preserve">
          <source>The following code sorts a vector of integers and copies them into a smaller and a larger vector.</source>
          <target state="translated">다음 코드는 정수 벡터를 정렬하여 더 작고 큰 벡터로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="daf4007146a4b83bcf3ac266d29e581ec3798877" translate="yes" xml:space="preserve">
          <source>The following code sorts an array of integers using &lt;code&gt;qsort()&lt;/code&gt;.</source>
          <target state="translated">다음 코드는 &lt;code&gt;qsort()&lt;/code&gt; 사용하여 정수 배열을 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="8207a8457c0eb26818d87ab569977e36158d049b" translate="yes" xml:space="preserve">
          <source>The following code uses  to assign one &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 를 다른 std :: deque 에 할당하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c1863f15396f1a247bc85cbf9db816e62ce9021f" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;assign&lt;/code&gt; to add several characters to a &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;assign&lt;/code&gt; 을 사용 하여 &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 에 여러 문자를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="95d74893928f5f4c485a639c2902038749eb9c54" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;assign&lt;/code&gt; to add several characters to a &lt;code&gt;&lt;a href=&quot;../forward_list&quot;&gt;std::forward_list&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;assign&lt;/code&gt; 을 사용 하여 &lt;code&gt;&lt;a href=&quot;../forward_list&quot;&gt;std::forward_list&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 에 여러 문자를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="aab485e9100b3af1ee0f47fb24b070b518f62792" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;assign&lt;/code&gt; to add several characters to a &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;assign&lt;/code&gt; 을 사용 하여 &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 에 여러 문자를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="ab47a7e2c6f0556c41e8da5e3e196e2efc53d9ef" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;assign&lt;/code&gt; to add several characters to a &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;assign&lt;/code&gt; 을 사용 하여 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 에 여러 문자를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f62b42a1746d9980942772d9163dc2de66ef406c" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;back&lt;/code&gt; to display the last element of a &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; &amp;lt;char&amp;gt; 의 마지막 요소를 &lt;code&gt;back&lt;/code&gt; 표시하는 데 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cccf7b603d69142f3f75f0954199fe1de7e3ac2" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;back&lt;/code&gt; to display the last element of a &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; &amp;lt;char&amp;gt; 의 마지막 요소를 &lt;code&gt;back&lt;/code&gt; 표시하는 데 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="f205cab6f9ab5cee8032e77137686863714505e7" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;back&lt;/code&gt; to display the last element of a &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;back&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 의 마지막 요소를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="6845338e9d3aecd8c4ee707b50d5f94ca1fb1f7c" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;back&lt;/code&gt; to display the last element of a &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; &amp;lt;char&amp;gt; 의 마지막 요소를 &lt;code&gt;back&lt;/code&gt; 표시하는 데 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="181361b9a1f17c4f72ca736bc8ef522c9e95ed79" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;emplace_back&lt;/code&gt; to append an object of type &lt;code&gt;President&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;. It demonstrates how &lt;code&gt;emplace_back&lt;/code&gt; forwards parameters to the &lt;code&gt;President&lt;/code&gt; constructor and shows how using &lt;code&gt;emplace_back&lt;/code&gt; avoids the extra copy or move operation required when using &lt;code&gt;push_back&lt;/code&gt;.</source>
          <target state="translated">다음 코드 사용은 &lt;code&gt;emplace_back&lt;/code&gt; 형식의 개체 추가하는 &lt;code&gt;President&lt;/code&gt; A와 &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; . 어떻게 &lt;code&gt;emplace_back&lt;/code&gt; 을 보여줍니다 전달을받는 매개 변수 &lt;code&gt;President&lt;/code&gt; 사용 방법 생성자와 쇼 &lt;code&gt;emplace_back&lt;/code&gt; 하여 사용하는 경우 여분의 복사 또는 이동 작업을 피할 필요 &lt;code&gt;push_back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="560056d34fecac1f14913fb6ef39172e1f3a8404" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;emplace_back&lt;/code&gt; to append an object of type &lt;code&gt;President&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;. It demonstrates how &lt;code&gt;emplace_back&lt;/code&gt; forwards parameters to the &lt;code&gt;President&lt;/code&gt; constructor and shows how using &lt;code&gt;emplace_back&lt;/code&gt; avoids the extra copy or move operation required when using &lt;code&gt;push_back&lt;/code&gt;.</source>
          <target state="translated">다음 코드 사용은 &lt;code&gt;emplace_back&lt;/code&gt; 형식의 개체 추가하는 &lt;code&gt;President&lt;/code&gt; A와 &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; . 이 방법을 보여줍니다 &lt;code&gt;emplace_back&lt;/code&gt; 의 전달을받는 매개 변수 &lt;code&gt;President&lt;/code&gt; 사용 방법 생성자와 쇼 &lt;code&gt;emplace_back&lt;/code&gt; 하여 사용하는 경우 여분의 복사 또는 이동 작업을 피할 필요 &lt;code&gt;push_back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4425e3c307c08594ad5519abfe04eb3fb4befe7" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;emplace_back&lt;/code&gt; to append an object of type &lt;code&gt;President&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;. It demonstrates how &lt;code&gt;emplace_back&lt;/code&gt; forwards parameters to the &lt;code&gt;President&lt;/code&gt; constructor and shows how using &lt;code&gt;emplace_back&lt;/code&gt; avoids the extra copy or move operation required when using &lt;code&gt;push_back&lt;/code&gt;.</source>
          <target state="translated">다음 코드 사용은 &lt;code&gt;emplace_back&lt;/code&gt; 형식의 개체 추가하는 &lt;code&gt;President&lt;/code&gt; A와 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; . 이 방법을 보여줍니다 &lt;code&gt;emplace_back&lt;/code&gt; 의 전달을받는 매개 변수 &lt;code&gt;President&lt;/code&gt; 사용 방법 생성자와 쇼 &lt;code&gt;emplace_back&lt;/code&gt; 하여 사용하는 경우 여분의 복사 또는 이동 작업을 피할 필요 &lt;code&gt;push_back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42ffd2d1ac0d4cdbb96f92d96f0af6eceac098a6" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; 에 요소가 포함되어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="78b999536bab5616600c00c9f174f27cb2f50623" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 에 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="59facc6b748c2accf7feefc7cae0fe5350c31737" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../forward_list&quot;&gt;std::forward_list&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../forward_list&quot;&gt;std::forward_list&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 에 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="294f922f24787de54a6841b0efc9bdf721c127dd" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 에 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="9834b56eb9cb58a559e764fc7ffc0967e672148e" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../map&quot;&gt;std::map&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../map&quot;&gt;std::map&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; 에 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="32e8f5c6c4b354a661cc73535a2faecf185c9a07" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../multimap&quot;&gt;std::multimap&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../multimap&quot;&gt;std::multimap&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; 인지 확인합니다. &amp;lt;int, int&amp;gt; 에 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d66087b7ce968da2dce5b4a9be6a4e7989f061d4" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../multiset&quot;&gt;std::multiset&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../multiset&quot;&gt;std::multiset&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 인지 확인합니다. &amp;lt;int&amp;gt; 에 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e5970161de20c21ad18db82f592f9531ae65f88f" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../set&quot;&gt;std::set&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../set&quot;&gt;std::set&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 인지 확인합니다. &amp;lt;int&amp;gt; 에 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ead28da2630b4b786759d7d27b9535ed0faee763" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&amp;lt;int,int&amp;gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&amp;lt;int,int&amp;gt;&lt;/code&gt; 에 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4bb497a58f9b0aa09af57ea73a4d4104f4c40c62" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&amp;lt;int,int&amp;gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&amp;lt;int,int&amp;gt;&lt;/code&gt; 에 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4c701030fc833aaa761e308e0a3b2858930654aa" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 에 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b5b62fd05d0981de0d7ddc30e16bfe35ea915307" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;empty&lt;/code&gt; to check if a &lt;code&gt;&lt;a href=&quot;../unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; contains any elements:</source>
          <target state="translated">다음 코드는 &lt;code&gt;empty&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 에 요소가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7f2775ed77c855a7770c1ec51b1677400d10b019" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;equal()&lt;/code&gt; to test if a string is a palindrome.</source>
          <target state="translated">다음 코드는 &lt;code&gt;equal()&lt;/code&gt; 을 사용 하여 문자열이 회문인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="fea7ab922e2504722617e162b2f67cfa179108d6" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;fill()&lt;/code&gt; to set all of the elements of a vector of integers to -1:</source>
          <target state="translated">다음 코드는 &lt;code&gt;fill()&lt;/code&gt; 을 사용 하여 정수 벡터의 모든 요소를 ​​-1로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c6a0b1c51a1296d332287bfef1bfd6aada8a81aa" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;fill_n()&lt;/code&gt; to assign -1 to the first half of a vector of integers:</source>
          <target state="translated">다음 코드는 &lt;code&gt;fill_n()&lt;/code&gt; 을 사용 하여 정수 벡터의 첫 번째 절반에 -1을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="ba3ba8d8b2c1786295ffc6e4eb81877ea4072154" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;find_end()&lt;/code&gt; to search for two different sequences of numbers.</source>
          <target state="translated">다음 코드는 &lt;code&gt;find_end()&lt;/code&gt; 를 사용 하여 두 개의 서로 다른 숫자 시퀀스를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="3f4de8e6160f6bc5ca86d1c19be35c2833a64af5" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;front&lt;/code&gt; to display the first element of a &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&amp;lt;char, 6&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;front&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&amp;lt;char, 6&amp;gt;&lt;/code&gt; 의 첫 번째 요소를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="82e4c5cd2f628e39e7cb8f9caf2d4b2dace79288" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;front&lt;/code&gt; to display the first element of a &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;front&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 의 첫 번째 요소를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="3bd292b4d7a1c8b57da39f8790a4ed7a5cf20de6" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;front&lt;/code&gt; to display the first element of a &lt;code&gt;&lt;a href=&quot;../forward_list&quot;&gt;std::forward_list&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;front&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../forward_list&quot;&gt;std::forward_list&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 의 첫 번째 요소를 표시합니다. : forward_list &amp;lt;char&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="a3c90736d0346e9d8a75c6171b1a5fe1b4f51a2f" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;front&lt;/code&gt; to display the first element of a &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;front&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 의 첫 번째 요소를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="a09b7805d327d7fc1ba23779c627f69766f10185" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;front&lt;/code&gt; to display the first element of a &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;front&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 의 첫 번째 요소를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="5961fd51065a540e74bed600b8b1a3dcf70175ce" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator=&lt;/code&gt; to assign one &lt;code&gt;&lt;a href=&quot;../forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator=&lt;/code&gt; 를 사용 하여 하나의 &lt;code&gt;&lt;a href=&quot;../forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; 를 다른 std :: forward_list 에 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="53bde90bfe9c57282e5b87b39fc52aecdfb30b41" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator=&lt;/code&gt; to assign one &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator=&lt;/code&gt; 를 사용 하여 하나의 &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 를 다른 std :: list 에 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="6ecfed2f177677006eecac7d76dc0ccfb909392d" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator=&lt;/code&gt; to assign one &lt;code&gt;&lt;a href=&quot;../map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator=&lt;/code&gt; 를 사용 하여 하나의 &lt;code&gt;&lt;a href=&quot;../map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 을 다른 std :: map 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="67523d3393b7310a0aa9cf3cffcd550ccc4b84b4" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator=&lt;/code&gt; to assign one &lt;code&gt;&lt;a href=&quot;../multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator=&lt;/code&gt; 를 사용 하여 하나의 &lt;code&gt;&lt;a href=&quot;../multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt; 을 할당합니다. 을 다른 에 .</target>
        </trans-unit>
        <trans-unit id="902214c8855d223d0e77f4fe9591426f8944e7d1" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator=&lt;/code&gt; to assign one &lt;code&gt;&lt;a href=&quot;../multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator=&lt;/code&gt; 를 사용 하여 하나의 &lt;code&gt;&lt;a href=&quot;../multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt; 을 다른 std :: multiset 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="6f51f792b41f543ab45cee3397a81737d84a525a" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator=&lt;/code&gt; to assign one &lt;code&gt;&lt;a href=&quot;../set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator=&lt;/code&gt; 를 사용 하여 하나의 &lt;code&gt;&lt;a href=&quot;../set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; 을 다른 std :: set 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="385dce21a913489614b538e5e7c84c1f9be175a3" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator=&lt;/code&gt; to assign one &lt;code&gt;&lt;a href=&quot;../unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator=&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 을 다른 것에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="99cdd8e5c063b51f08dfcfd0a38ebfab272716c1" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator=&lt;/code&gt; to assign one &lt;code&gt;&lt;a href=&quot;../unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator=&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 을 다른 것에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="0149eb1d951922170f2c79dabe74381632a6cee0" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator=&lt;/code&gt; to assign one &lt;code&gt;&lt;a href=&quot;../unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator=&lt;/code&gt; 를 사용 하여 하나의 &lt;code&gt;&lt;a href=&quot;../unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; 을 다른 std :: unordered_multiset 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="15fc8c2fb14c7949092eae56b799189af05c13de" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator=&lt;/code&gt; to assign one &lt;code&gt;&lt;a href=&quot;../unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator=&lt;/code&gt; 를 사용 하여 한 &lt;code&gt;&lt;a href=&quot;../unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; 을 다른 std :: unordered_set 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="a40867c60315bc089e9e83e842ecb1acbe656608" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator=&lt;/code&gt; to assign one &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; to another:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator=&lt;/code&gt; 를 사용 하여 하나의 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 를 다른 std :: vector 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="66dd3415186bd6ecc44b88aeada97fe8a4f6f307" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator[]&lt;/code&gt; to read from and write to a &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator[]&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 에서 읽고 씁니다 .</target>
        </trans-unit>
        <trans-unit id="2790a3c9be04ca78b6550876913d5ef5ccbde5ef" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator[]&lt;/code&gt; to read from and write to a &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator[]&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 에서 읽고 씁니다 .</target>
        </trans-unit>
        <trans-unit id="639c4fe277604645d83fc40a5acf3052f4f02544" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;operator[]&lt;/code&gt; to read from and write to a &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;operator[]&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 에서 읽고 씁니다 .</target>
        </trans-unit>
        <trans-unit id="f48eaa9496b991bd3d0eb50c0836a412f6fe8933" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; 의 요소 수를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="5558ee4a0bde449bbea05f3ff4c4921ae478d58d" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 의 요소 수를 표시합니다. : deque .</target>
        </trans-unit>
        <trans-unit id="ab3123f588ec261d38605e05eb8a58184a794dc2" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 의 요소 수를 표시 합니다 .</target>
        </trans-unit>
        <trans-unit id="9c9cd102e7dd740e049c929043487fbf656d9927" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 의 요소 수를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="4923520809b85ccd4900db40956492eb829ff259" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt; 의 요소 수를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="367093cd12e46fd60d907dd8481b0dff622fb306" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt; 의 요소 수를 표시합니다. .</target>
        </trans-unit>
        <trans-unit id="9fdc7fc1496d0cd337e08b671bd8ed8e02598dd4" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../set&quot;&gt;std::set&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../set&quot;&gt;std::set&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 의 요소 수를 표시합니다. : set &amp;lt;int&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="4f74be33ecfdae4375ef0773c434b5c706ea378e" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 의 요소 수를 표시합니다. .</target>
        </trans-unit>
        <trans-unit id="fb705db53382014a2ea445c532a9ebee11475d22" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 의 요소 수를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="0d65c5a16544be53346eefb8fd2d37698a127969" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 의 요소 수를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="548853a7a6bceff6cb33b2b7379b7d3917031bee" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 의 요소 수를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="4104db0b3e3262de82ab7e2b4688216bdb5503fa" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;code&gt;size&lt;/code&gt; to display the number of elements in a &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 &lt;code&gt;size&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 의 요소 수를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="1cc0cc8f9e7d02f4ffe69f8908f54fbe730ba21f" translate="yes" xml:space="preserve">
          <source>The following code uses copy to both copy the contents of one vector to another and to display the resulting vector:</source>
          <target state="translated">다음 코드는 copy를 사용하여 한 벡터의 내용을 다른 벡터에 복사하고 결과 벡터를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="68bb58bde9d239bfa5b3f88d2d2c7df862b599f9" translate="yes" xml:space="preserve">
          <source>The following code uses transform to convert a string in place to uppercase using the toupper function and then transforms each char to its ordinal value:</source>
          <target state="translated">다음 코드는 변환을 사용하여 toupper 함수를 사용하여 문자열을 대문자로 변환 한 다음 각 문자를 서수 값으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a3c25657b5cd7f5592c99855d3ec7267e6fe484c" translate="yes" xml:space="preserve">
          <source>The following constants are also defined:</source>
          <target state="translated">다음 상수도 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c4925dbfe1aa827f2041e1033ebe0a6005a26692" translate="yes" xml:space="preserve">
          <source>The following constants denoting individual bits are defined by the standard library:</source>
          <target state="translated">개별 비트를 나타내는 다음 상수는 표준 라이브러리에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="10bb2a7b9ba858f9e871c57ccba765a9f92f8560" translate="yes" xml:space="preserve">
          <source>The following contexts require a</source>
          <target state="translated">다음과 같은 상황에는</target>
        </trans-unit>
        <trans-unit id="009d4588e5ae326cecee174c71b20e5192d349ff" translate="yes" xml:space="preserve">
          <source>The following contexts require an</source>
          <target state="translated">다음과 같은 상황에는</target>
        </trans-unit>
        <trans-unit id="a8be823b41f88b6bb5fe26fd40c903501eb8b33d" translate="yes" xml:space="preserve">
          <source>The following conversion specifiers are available:</source>
          <target state="translated">다음과 같은 변환 지정자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c003d2f36ae5692bd45f365d1d7025783a9c1c9" translate="yes" xml:space="preserve">
          <source>The following copy prints a vector, replacing all values over 5 with 99 on the fly.</source>
          <target state="translated">다음 사본은 벡터를 인쇄하여 5 이상의 모든 값을 99로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="7ac588dfc54923ad58981e4ced20fbb675e510c8" translate="yes" xml:space="preserve">
          <source>The following declarations also declare exactly the same function.</source>
          <target state="translated">다음 선언도 정확히 동일한 기능을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="0e1e782882f70b3f7f134569ed77e2b2acd81be7" translate="yes" xml:space="preserve">
          <source>The following entities are not objects: value, reference, function, enumerator, type, non-static class member, bit-field, template, class or function template specialization, namespace, parameter pack, and &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">값, 참고 특성, 기능, 열거 입력 비 정적 반원, 템플릿, 클래스 또는 함수 서식 전문화, 공간 파라미터 팩 필드 비트와 다음 엔티티없는 오브젝트이다 &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e39d176344c3e85e78002c68d7e8e5b51e271c28" translate="yes" xml:space="preserve">
          <source>The following enumerators are also defined:</source>
          <target state="translated">다음 열거 자도 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="9d7f6bc390ae3470d1ec7b1d1db9a94c08fbbca3" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available (extra escape sequences may be provided with implementation-defined semantics):</source>
          <target state="translated">다음과 같은 이스케이프 시퀀스를 사용할 수 있습니다 (추가 이스케이프 시퀀스에는 구현 정의 시맨틱이 제공 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="a3edf11648f50f67dc38400fbf749312a8a6023f" translate="yes" xml:space="preserve">
          <source>The following example applies &lt;code&gt;&lt;a href=&quot;random_shuffle&quot;&gt;std::shuffle&lt;/a&gt;&lt;/code&gt; to a vector of &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; iterators since &lt;code&gt;&lt;a href=&quot;random_shuffle&quot;&gt;std::shuffle&lt;/a&gt;&lt;/code&gt; cannot be applied to a &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; directly. &lt;code&gt;std::iota&lt;/code&gt; is used to populate both containers.</source>
          <target state="translated">다음 예제는 &lt;code&gt;&lt;a href=&quot;random_shuffle&quot;&gt;std::shuffle&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 직접 적용 할 수 없으므로 &lt;code&gt;&lt;a href=&quot;random_shuffle&quot;&gt;std::shuffle&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 반복자 벡터에 적용합니다 . &lt;code&gt;std::iota&lt;/code&gt; 는 두 컨테이너를 모두 채우는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="98227c78e55a55bae11e8faaf05e67543f156c99" translate="yes" xml:space="preserve">
          <source>The following example calculates the probability that a normal variate is on the interval (x1, x2).</source>
          <target state="translated">다음 예는 정규 변이가 구간 (x1, x2)에있을 확률을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="666096a94f3ce76da429785aaa9438c9e1071127" translate="yes" xml:space="preserve">
          <source>The following example changes the string representations of &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 문자열 표현을 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="50c6037577b844c05a202750d8ccfe295c1ce7a2" translate="yes" xml:space="preserve">
          <source>The following example demonstrated retrieval of messages: on a typical GNU/Linux system it reads from &lt;code&gt;/usr/share/locale/de/LC_MESSAGES/sed.mo&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 메시지 검색을 보여줍니다. 일반적인 GNU / Linux 시스템에서는 &lt;code&gt;/usr/share/locale/de/LC_MESSAGES/sed.mo&lt;/code&gt; 에서 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="ff5128c9a45dbdfe7028be5b5809eefa99fbcd68" translate="yes" xml:space="preserve">
          <source>The following example demonstrates consuming the UTF-8 BOM.</source>
          <target state="translated">다음 예는 UTF-8 BOM 소비를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e84fe7b382f35acf36a0571545a93eb16f150929" translate="yes" xml:space="preserve">
          <source>The following example demonstrates decoding of UTF-16le file on a system with 32-bit &lt;code&gt;wchar_t&lt;/code&gt;. On a system with 16-bit &lt;code&gt;wchar_t&lt;/code&gt;, decoding of the third character will fail because &lt;code&gt;std::codecvt_utf16&amp;lt;char16_t&amp;gt;&lt;/code&gt; produces UCS2, not UTF-16.</source>
          <target state="translated">다음 예제는 32 비트 &lt;code&gt;wchar_t&lt;/code&gt; 가 있는 시스템에서 UTF-16le 파일의 디코딩을 보여줍니다 . 16 비트 &lt;code&gt;wchar_t&lt;/code&gt; 가 있는 시스템에서는 &lt;code&gt;std::codecvt_utf16&amp;lt;char16_t&amp;gt;&lt;/code&gt; 이 UTF-16이 아닌 UCS2를 생성 하므로 세 번째 문자의 디코딩이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="4e02d0927ca40ac3f20330707ae5d9dc6a060343" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how to use &lt;code&gt;destroy&lt;/code&gt; to destroy a contiguous sequence of elements.</source>
          <target state="translated">다음 예제는 &lt;code&gt;destroy&lt;/code&gt; 를 사용 하여 연속 된 요소 시퀀스를 제거하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a18cbf051d93d448e8ae3290a9d188e70f5dbde2" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how to use &lt;code&gt;destroy_at&lt;/code&gt; to destroy a contiguous sequence of elements.</source>
          <target state="translated">다음 예제는 &lt;code&gt;destroy_at&lt;/code&gt; 를 사용 하여 연속적인 요소 시퀀스를 제거하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="6b7aaae085caf053cea47938c13ce2e0d54c864d" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how to use &lt;code&gt;destroy_n&lt;/code&gt; to destroy a contiguous sequence of elements.</source>
          <target state="translated">다음 예제는 &lt;code&gt;destroy_n&lt;/code&gt; 을 사용 하여 연속적인 요소 시퀀스를 제거하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9c3768a533bb5638c1a2aba447121ead46ba7e0c" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how to use &lt;code&gt;getline&lt;/code&gt; function to read user's input and how to process file line by line.</source>
          <target state="translated">다음 예제는 &lt;code&gt;getline&lt;/code&gt; 함수 를 사용 하여 사용자 입력을 읽는 방법과 파일을 한 줄씩 처리하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="4ca2bda89b867388cbda9ab2651ddb4a53f60b3b" translate="yes" xml:space="preserve">
          <source>The following example demonstrates katakana to hiragana character mapping.</source>
          <target state="translated">다음 예제는 가타카나에서 히라가나로의 문자 매핑을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b4511608a2770fc85ea2f394bd1d3db73c33a057" translate="yes" xml:space="preserve">
          <source>The following example demonstrates modification of a ctype other than ctype&amp;lt;char&amp;gt; to tokenize a CSV file.</source>
          <target state="translated">다음 예는 ctype &amp;lt;char&amp;gt; 이외의 ctype을 수정하여 CSV 파일을 토큰 화하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="078c0b9a910cb8db45f22ea2c4a03201e8aa21ba" translate="yes" xml:space="preserve">
          <source>The following example demonstrates modification of ctype&amp;lt;char&amp;gt; to tokenize comma-separated values.</source>
          <target state="translated">다음 예는 쉼표로 구분 된 값을 토큰 화하기 위해 ctype &amp;lt;char&amp;gt;의 수정을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8b17a6f2b425709208fee4f7a7f2a985fd938dea" translate="yes" xml:space="preserve">
          <source>The following example demonstrates several usage cases of the &lt;code&gt;try-catch&lt;/code&gt; block.</source>
          <target state="translated">다음 예제는 &lt;code&gt;try-catch&lt;/code&gt; 블록 의 여러 사용 사례를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="141f9a87f972b72d51d5a0ba28295a6e60590f32" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the difference between UCS2/UTF-8 and UTF-16/UTF-8 conversions: the third character in the string is not a valid UCS2 character.</source>
          <target state="translated">다음 예는 UCS2 / UTF-8과 UTF-16 / UTF-8 변환의 차이점을 보여줍니다. 문자열의 세 번째 문자는 유효한 UCS2 문자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0e740ba5761f5d0fc3a5448029e3ada9277de668" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of several alternative tokens.</source>
          <target state="translated">다음 예는 여러 대체 토큰을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="525e8da92611859f7cb6e873db8315e5c79ce00d" translate="yes" xml:space="preserve">
          <source>The following example demonstrates transitive release-acquire ordering across three threads.</source>
          <target state="translated">다음 예제는 3 개의 스레드에서 전 이적 릴리스 획득 순서를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="27a99f499965d3b5b1abd95cc23d4ad4577e382c" translate="yes" xml:space="preserve">
          <source>The following example finds an integer in a vector of integers.</source>
          <target state="translated">다음 예제는 정수 벡터에서 정수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="c6952fc0a4da511b0019b46a13739b85c1e7dc7a" translate="yes" xml:space="preserve">
          <source>The following example iterates over a vector (which has random-access iterators) in reverse.</source>
          <target state="translated">다음 예제에서는 벡터 (임의 액세스 반복자가있는)를 반대로 반복합니다.</target>
        </trans-unit>
        <trans-unit id="c0d39d8f73419ea04197a0669261855783ae02e7" translate="yes" xml:space="preserve">
          <source>The following example shows a general-purpose &lt;code&gt;reverse()&lt;/code&gt; implementation for bidirectional iterators.</source>
          <target state="translated">다음 예제는 양방향 반복기에 대한 범용 &lt;code&gt;reverse()&lt;/code&gt; 구현을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="4ac23324e2b3e1f0d4e6b0af6616bc5580fd14c5" translate="yes" xml:space="preserve">
          <source>The following example shows how &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; can passed to other functions by value. Also, it shows how &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; can store lambdas.</source>
          <target state="translated">다음 예제는 &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; function이 값으로 다른 함수에 전달되는 방법을 보여줍니다 . 또한 &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 이 람다를 저장 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="4b3f122aad33f6a6f2d52154068219af931dc3b5" translate="yes" xml:space="preserve">
          <source>The following example shows how to construct a minimal custom facet.</source>
          <target state="translated">다음 예는 최소 사용자 정의 패싯을 구성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c489729f6cc12480a1e704d11ab55d5a5e4ff36c" translate="yes" xml:space="preserve">
          <source>The following example shows how to implement a &lt;a href=&quot;../named_req/inputiterator&quot;&gt;input iterator&lt;/a&gt; by inheriting from std::iterator.</source>
          <target state="translated">다음 예제는 std :: iterator에서 상속 하여 &lt;a href=&quot;../named_req/inputiterator&quot;&gt;입력 반복기&lt;/a&gt; 를 구현하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="00fbc8b63043ae05ad9ff507b2e2e1e05b1fb9f8" translate="yes" xml:space="preserve">
          <source>The following example shows several different ways to print the same result.</source>
          <target state="translated">다음 예는 동일한 결과를 인쇄하는 여러 가지 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="db4258721a69c60754a36e4c48d778d9b956ad0e" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;code&gt;ignore&lt;/code&gt; to skip over non-numeric input:</source>
          <target state="translated">다음 예제는 &lt;code&gt;ignore&lt;/code&gt; 를 사용 하여 숫자가 아닌 입력을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="48f63f57617ec5b257434de8bf0aa890cfb1d5c0" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;code&gt;lock&lt;/code&gt; to re-acquire a mutex that was unlocked.</source>
          <target state="translated">다음 예제는 &lt;code&gt;lock&lt;/code&gt; 을 사용하여 잠금 해제 된 뮤텍스를 다시 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6df31ab75eb69c1e85b8009a04ecbf6f2d0fe62d" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;code&gt;std::lock&lt;/code&gt; to lock pairs of mutexes without deadlock.</source>
          <target state="translated">다음 예제는 &lt;code&gt;std::lock&lt;/code&gt; 을 사용하여 교착 상태없이 뮤텍스 쌍을 잠급니다.</target>
        </trans-unit>
        <trans-unit id="802383492a3e9cbc679f149ac14f49c1c655dba8" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;code&gt;std::scoped_lock&lt;/code&gt; to lock pairs of mutexes without deadlock and is RAII-style.</source>
          <target state="translated">다음 예제는 &lt;code&gt;std::scoped_lock&lt;/code&gt; 을 사용하여 교착 상태없이 뮤텍스 쌍을 잠그고 RAII 스타일입니다.</target>
        </trans-unit>
        <trans-unit id="f0f63a8f264e006ef2327ae019fc8c811058c3ed" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;code&gt;std::try_lock&lt;/code&gt; to periodically tally and reset counters running in separate threads.</source>
          <target state="translated">다음 예제는 &lt;code&gt;std::try_lock&lt;/code&gt; 을 사용 하여 별도의 스레드에서 실행되는 카운터를 주기적으로 집계 및 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="eff076fbccafc4a939e632f3fce93d003c8fe78d" translate="yes" xml:space="preserve">
          <source>The following example uses a &lt;a href=&quot;../language/lambda&quot;&gt;lambda function&lt;/a&gt; to increment all of the elements of a vector and then uses an overloaded &lt;code&gt;operator()&lt;/code&gt; in a functor to compute their sum. Note that to compute the sum, it is recommended to use the dedicated algorithm &lt;code&gt;&lt;a href=&quot;accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;../language/lambda&quot;&gt;람다 함수&lt;/a&gt; 를 사용하여 벡터의 모든 요소를 ​​증가시킨 다음 functor에서 오버로드 된 &lt;code&gt;operator()&lt;/code&gt; 를 사용하여 합계를 계산합니다. 합계를 계산하려면 전용 알고리즘 &lt;code&gt;&lt;a href=&quot;accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c75ec5cddf22740a53ef00331402bec8899fda7a" translate="yes" xml:space="preserve">
          <source>The following examples reads a UTF-8 file using a locale which implements UTF-8 conversion in codecvt&amp;lt;wchar_t, char, mbstate_t&amp;gt; and converts a UTF-8 string to UTF-16 using one of the standard specializations of std::codecvt.</source>
          <target state="translated">다음 예는 codecvt &amp;lt;wchar_t, char, mbstate_t&amp;gt;에서 UTF-8 변환을 구현하고 std :: codecvt의 표준 전문화 중 하나를 사용하여 UTF-8 문자열을 UTF-16으로 변환하는 로케일을 사용하여 UTF-8 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c9f2c0d0c86490d721317d3b74a3d0462b3f18c0" translate="yes" xml:space="preserve">
          <source>The following expression errors are SFINAE errors.</source>
          <target state="translated">다음 식 오류는 SFINAE 오류입니다.</target>
        </trans-unit>
        <trans-unit id="debd1fa4309eddd6e405115f2b5cff736db118cc" translate="yes" xml:space="preserve">
          <source>The following expressions (including conversions to the destination type) are</source>
          <target state="translated">다음 표현식 (대상 유형으로의 변환 포함)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b29cd54e8090d2fef4b2a1c4b62fa012ef80e95" translate="yes" xml:space="preserve">
          <source>The following expressions are</source>
          <target state="translated">다음 식은</target>
        </trans-unit>
        <trans-unit id="e8528d23bc1b32037866d01f10a31c7d73bc36bb" translate="yes" xml:space="preserve">
          <source>The following expressions are type-dependent.</source>
          <target state="translated">다음 표현식은 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="db57d5666845e6ff4a0f3b55b955fc5079d79e08" translate="yes" xml:space="preserve">
          <source>The following expressions are well-formed and have the following meaning for any BitmaskType:</source>
          <target state="translated">다음 표현식은 올바른 형식이며 모든 BitmaskType에 대해 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="22d4ffd3d50c3b5b2098cbfee0ae837d04064a61" translate="yes" xml:space="preserve">
          <source>The following expressions must be valid and have their specified effects for all sequence containers except &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음 표현식은 유효해야하며 &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; 제외한 모든 시퀀스 컨테이너에 대해 지정된 효과를 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="d5e8ec34037bfee2a2de96690accfd13ec9641c0" translate="yes" xml:space="preserve">
          <source>The following expressions must be valid and have their specified effects for the sequence containers named:</source>
          <target state="translated">다음 표현식은 유효해야하며 명명 된 시퀀스 컨테이너에 대해 지정된 효과를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="c10e7ec520abefe3e72402cd7464b805bd2ced61" translate="yes" xml:space="preserve">
          <source>The following expressions must be valid and have their specified effects.</source>
          <target state="translated">다음 표현식은 유효해야하며 지정된 효과가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="49a148a069facd683ffc1bc478747dac3ca7105d" translate="yes" xml:space="preserve">
          <source>The following expressions must be valid and have their specified effects:</source>
          <target state="translated">다음 표현식은 유효해야하며 지정된 효과가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2720aede3cc4a9514ba4f52fbf8bdb672820ebe6" translate="yes" xml:space="preserve">
          <source>The following expressions must be valid:</source>
          <target state="translated">다음 표현식이 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="2cfaf8e14e19bf31aee96ca79b4b825e2d169ca6" translate="yes" xml:space="preserve">
          <source>The following floating-point error conditions are recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4f90abfd9c4aaea62c390400d56b7eb617f8af" translate="yes" xml:space="preserve">
          <source>The following format specifiers are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f42b11d97e9492ead1c1556f379edfec7ce6efa2" translate="yes" xml:space="preserve">
          <source>The following four requirements are guaranteed for all atomic operations:</source>
          <target state="translated">모든 원자 작업에 대해 다음 네 가지 요구 사항이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="a92b77d52f08f57ee17ef460d2687879e298a2ce" translate="yes" xml:space="preserve">
          <source>The following functions are required to be thread-safe:</source>
          <target state="translated">스레드 안전을 위해서는 다음 기능이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f2eb935e6113cc619832488518231a86dfe2f850" translate="yes" xml:space="preserve">
          <source>The following functions clear &lt;code&gt;eofbit&lt;/code&gt; as a side-effect:</source>
          <target state="translated">다음 기능은 &lt;code&gt;eofbit&lt;/code&gt; 를 부작용으로 제거 합니다 .</target>
        </trans-unit>
        <trans-unit id="c5a591d9fa5638aac9fa2b83e82338a91618a78a" translate="yes" xml:space="preserve">
          <source>The following functions manage program termination and resource cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e986edc251497f629cc52507f22f7c5c5651a39" translate="yes" xml:space="preserve">
          <source>The following functions set &lt;code&gt;gcount()&lt;/code&gt; to zero:</source>
          <target state="translated">다음 함수는 &lt;code&gt;gcount()&lt;/code&gt; 를 0으로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="7e751c77b395f08a05df0faafe34cc44b0980610" translate="yes" xml:space="preserve">
          <source>The following functions should not be called from multiple threads without synchronization with the &lt;code&gt;std::mbstate_t*&lt;/code&gt; argument of &lt;code&gt;NULL&lt;/code&gt; due to possible data races: &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;std::mbrlen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;std::wcrtomb&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;std::wctomb&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가능한 데이터 경쟁으로 인해 &lt;code&gt;NULL&lt;/code&gt; 의 &lt;code&gt;std::mbstate_t*&lt;/code&gt; 인수 와 동기화하지 않고 여러 스레드에서 다음 함수를 호출하면 안됩니다 . &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;std::mbrlen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;std::wcrtomb&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;std::wctomb&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e06fb004ab640fd2985e53f52dd0e0eaabd0f761" translate="yes" xml:space="preserve">
          <source>The following implicit conversions are classified as integral promotions:</source>
          <target state="translated">다음 암시 적 전환은 통합 프로모션으로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="9e4bf6b07ece0b87ef0e771b79b6cc4bd8a6bfce" translate="yes" xml:space="preserve">
          <source>The following is an implementation of selection sort in C++</source>
          <target state="translated">다음은 C ++에서 선택 정렬 구현입니다.</target>
        </trans-unit>
        <trans-unit id="dfac99e333eaa05ebfa778080027d41f55d75c0f" translate="yes" xml:space="preserve">
          <source>The following limitations apply when instantiating templates that have non-type template parameters:</source>
          <target state="translated">유형이 아닌 템플릿 매개 변수가있는 템플릿을 인스턴스화 할 때는 다음 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="52747f8b268619d42bfc41249c2443bf02dfb375" translate="yes" xml:space="preserve">
          <source>The following limitations are imposed on the user-defined function that is installed as a signal handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da00c82b7d244792f2030f45189b70e1b1b1f2b3" translate="yes" xml:space="preserve">
          <source>The following linkages are recognized:</source>
          <target state="translated">다음과 같은 연계가 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="fb4eace7ff5070309972db02437a21ee5af036eb" translate="yes" xml:space="preserve">
          <source>The following literal operators are defined in the standard library.</source>
          <target state="translated">다음 리터럴 연산자는 표준 라이브러리에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3723b425362ea4e4ce5828175ffab15f68e3131b" translate="yes" xml:space="preserve">
          <source>The following macro names are predefined in every translation unit.</source>
          <target state="translated">다음 매크로 이름은 모든 번역 단위에 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7566f7a8132ec521da8d18bb6126376034375f24" translate="yes" xml:space="preserve">
          <source>The following macros are defined if the header &lt;a href=&quot;header/version&quot;&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/a&gt; or any of the corresponding headers in the table below is included. Each macro expands to an integer literal corresponding to the year and month when the corresponding feature has been included in the working draft.</source>
          <target state="translated">헤더 &lt;a href=&quot;header/version&quot;&gt; &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 아래 표의 해당 헤더가 포함 된 경우 다음 매크로가 정의됩니다 . 각 매크로는 해당 기능이 작업 초안에 포함 된 연도 및 월에 해당하는 정수 리터럴로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="f28817cf6a958f651285ad92987ad551f3b3afb7" translate="yes" xml:space="preserve">
          <source>The following macros are predefined in every translation unit.</source>
          <target state="translated">다음 매크로는 모든 번역 단위에 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="73f1c16628c0db204aa1806bf2fd9e91da1c732d" translate="yes" xml:space="preserve">
          <source>The following macros are predefined in every translation unit. Each macro expands to an integer literal corresponding to the year and month when the corresponding feature has been included in the working draft.</source>
          <target state="translated">다음 매크로는 모든 번역 단위에 미리 정의되어 있습니다. 각 매크로는 해당 기능이 작업 초안에 포함 된 연도 및 월에 해당하는 정수 리터럴로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="f9955df6599697e69b7429b076ab09c2a61cf784" translate="yes" xml:space="preserve">
          <source>The following member functions of &lt;code&gt;basic_istream&lt;/code&gt; change the value of subsequent &lt;code&gt;gcount()&lt;/code&gt; calls:</source>
          <target state="translated">&lt;code&gt;basic_istream&lt;/code&gt; 의 다음 멤버 함수는 후속 &lt;code&gt;gcount()&lt;/code&gt; 호출 의 값을 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="8a52166fa732f6828cff4533ced933f75480e1dc" translate="yes" xml:space="preserve">
          <source>The following operators are rarely overloaded:</source>
          <target state="translated">다음 연산자는 거의 오버로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48a3fa74fdd466282026b295d2a93a127b87ec93" translate="yes" xml:space="preserve">
          <source>The following overloads are already provided by the standard library:</source>
          <target state="translated">표준 라이브러리에서 이미 다음과 같은 과부하가 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="eba554740f58545a1e58d6b4c2dd64ed7fb45704" translate="yes" xml:space="preserve">
          <source>The following program demonstrates usage of a custom deleter.</source>
          <target state="translated">다음 프로그램은 사용자 정의 삭제 기 사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="062d4ad02d97a54508cb3a86208e3c3ee3d3ffdf" translate="yes" xml:space="preserve">
          <source>The following program is an example of an efficient type-value mapping without using &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 프로그램은 &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; 를 사용하지 않는 효율적인 유형 값 매핑의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="8220c0fdbfef735a987a41da0ffe4823652db8b9" translate="yes" xml:space="preserve">
          <source>The following program is an example of an efficient type-value mapping.</source>
          <target state="translated">다음 프로그램은 효율적인 유형 값 매핑의 예입니다.</target>
        </trans-unit>
        <trans-unit id="9ff275c825fa1a87d99185f365a34ebec03469ef" translate="yes" xml:space="preserve">
          <source>The following properties of bit fields are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af27c3abc588bea4e2ff429143c89f2d428493c5" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to the argument-list of a partial template specialization:</source>
          <target state="translated">부분 템플릿 전문화의 인수 목록에는 다음과 같은 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f68aa4529e49ad56663b01e62f1f4c387b78a88c" translate="yes" xml:space="preserve">
          <source>The following rules apply to container construction.</source>
          <target state="translated">컨테이너 건설에는 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="718963b68f3a3480ccecd7e291d7071c83c72a08" translate="yes" xml:space="preserve">
          <source>The following specializations are already provided by the standard library:</source>
          <target state="translated">표준 라이브러리는 이미 다음과 같은 전문화 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0031259c1c38cc60cd2a07e684b6afb30571b854" translate="yes" xml:space="preserve">
          <source>The following specializations of &lt;code&gt;&lt;a href=&quot;io/fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; are provided:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;io/fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; 의 다음 전문화 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2d2dff1f1d7ffe563611f49b118f00cc7cde933f" translate="yes" xml:space="preserve">
          <source>The following specializations of &lt;code&gt;std::fpos&lt;/code&gt; are provided:</source>
          <target state="translated">&lt;code&gt;std::fpos&lt;/code&gt; 의 다음 전문화 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a8ac2376ba64e555f426367b2c168767a8b9fd8a" translate="yes" xml:space="preserve">
          <source>The following specifiers are recognized, but will cause &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; to be set in &lt;code&gt;os&lt;/code&gt;:</source>
          <target state="translated">다음 지정자가 인식되지만 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;os&lt;/code&gt; 에 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b43c06e0b038d4f78fc60acbdf6be989d5c2205c" translate="yes" xml:space="preserve">
          <source>The following standalone (locale-independent) specializations are provided by the standard library:</source>
          <target state="translated">표준 라이브러리는 다음과 같은 독립형 (로케일 독립적) 전문화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="87098482f1ab90910e6cdda0d45338fd298ac8e6" translate="yes" xml:space="preserve">
          <source>The following standard functions are declared with &lt;code&gt;nodiscard&lt;/code&gt; attribute:</source>
          <target state="translated">다음 표준 함수는 &lt;code&gt;nodiscard&lt;/code&gt; 속성 으로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="9dcab3d2651c2d4be25e4e3aa77f3fa98e464574" translate="yes" xml:space="preserve">
          <source>The following standard functions are declared with &lt;code&gt;noreturn&lt;/code&gt; attribute:</source>
          <target state="translated">다음 표준 함수는 &lt;code&gt;noreturn&lt;/code&gt; 속성 으로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="32a68a66d872c6f3299adc5cd097f3da4b4588ff" translate="yes" xml:space="preserve">
          <source>The following standard library class templates also satisfy &lt;strong&gt;TransformationTrait&lt;/strong&gt;.</source>
          <target state="translated">다음 표준 라이브러리 클래스 템플릿도 &lt;strong&gt;TransformationTrait&lt;/strong&gt; 를 충족 합니다.</target>
        </trans-unit>
        <trans-unit id="1e1e8e6153d4fa33a939b2ff78c2e8172ebd314a" translate="yes" xml:space="preserve">
          <source>The following standard library class templates also satisfy &lt;strong&gt;UnaryTypeTrait&lt;/strong&gt;.</source>
          <target state="translated">다음 표준 라이브러리 클래스 템플릿은 &lt;strong&gt;UnaryTypeTrait&lt;/strong&gt; 도 충족 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8ae071fe8c66c1cf7bd341b1a4ee6d758adbce1a" translate="yes" xml:space="preserve">
          <source>The following standard library class templates satisfy &lt;strong&gt;BinaryTypeTrait&lt;/strong&gt;.</source>
          <target state="translated">다음 표준 라이브러리 클래스 템플릿은 &lt;strong&gt;BinaryTypeTrait를&lt;/strong&gt; 충족 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="007099bda9fb475467acdd87b9f40e88aa090101" translate="yes" xml:space="preserve">
          <source>The following standard library components satisfy RandomNumberDistribution.</source>
          <target state="translated">다음 표준 라이브러리 구성 요소는 RandomNumberDistribution을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="efaebbc35931a2d154d67a161bd61f11506f8352" translate="yes" xml:space="preserve">
          <source>The following standard library components satisfy the Allocator requirements:</source>
          <target state="translated">다음 표준 라이브러리 구성 요소는 할당 자 요구 사항을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="eb594915ced822ef9c987893a74e5ec96ad031fe" translate="yes" xml:space="preserve">
          <source>The following standard library facilities expect a BinaryPredicate which isn't a &lt;a href=&quot;compare&quot;&gt;Compare&lt;/a&gt; type.</source>
          <target state="translated">다음 표준 라이브러리 기능은 &lt;a href=&quot;compare&quot;&gt;비교&lt;/a&gt; 유형 이 아닌 BinaryPredicate를 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="d463c552ce3946c66f46834829e62a11e51b3305" translate="yes" xml:space="preserve">
          <source>The following standard library facilities expect a Compare type.</source>
          <target state="translated">다음 표준 라이브러리 기능에는 비교 유형이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c52f727d02e5c3f4bd6ca4b1192af1099ef5f182" translate="yes" xml:space="preserve">
          <source>The following standard library facilities expect a UniformRandomBitGenerator type.</source>
          <target state="translated">다음 표준 라이브러리 기능에는 UniformRandomBitGenerator 유형이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="eaa1be259b57b9bea0023a6acb3d8b45f5225eae" translate="yes" xml:space="preserve">
          <source>The following standard library facilities satisfy &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; but not RandomNumberEngine:</source>
          <target state="translated">다음 표준 라이브러리 기능은 &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator를&lt;/a&gt; 만족 하지만 RandomNumberEngine은 만족 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e54e88fbec814c021ca405eb128168a763988d48" translate="yes" xml:space="preserve">
          <source>The following standard library facilities satisfy &lt;strong&gt;RandomNumberEngineAdaptor&lt;/strong&gt;:</source>
          <target state="translated">다음 표준 라이브러리 기능은 &lt;strong&gt;RandomNumberEngineAdaptor를&lt;/strong&gt; 충족 &lt;strong&gt;시킵니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bbcaf65a4722d7dc301ad7f848b0a0e5b87a75cd" translate="yes" xml:space="preserve">
          <source>The following standard library facilities satisfy RandomNumberEngine:</source>
          <target state="translated">다음 표준 라이브러리 기능은 RandomNumberEngine을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="8197cbcbf90d11a014c985a28b2629f3b2e0d799" translate="yes" xml:space="preserve">
          <source>The following standard library facilities satisfy UniformRandomBitGenerator without additionally satisfying &lt;a href=&quot;randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt;:</source>
          <target state="translated">다음 표준 라이브러리 기능은 RandomNumberEngine을 추가로 만족시키지 않고 UniformRandomBitGenerator를 충족 &lt;a href=&quot;randomnumberengine&quot;&gt;시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52a9199352069fc95f2faa18ac7f0b0ffb0b610e" translate="yes" xml:space="preserve">
          <source>The following standard library functions are &lt;strong&gt;FormattedInputFunctions&lt;/strong&gt;.</source>
          <target state="translated">다음의 표준 라이브러리 함수는 &lt;strong&gt;FormattedInputFunctions&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="110375b0fdd2a6ce27bc319d8fa22f578ddce865" translate="yes" xml:space="preserve">
          <source>The following standard library functions are &lt;strong&gt;FormattedOutputFunctions&lt;/strong&gt;.</source>
          <target state="translated">다음과 같은 표준 라이브러리 함수는 &lt;strong&gt;FormattedOutputFunctions&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="90e3e6b7b01ca606fc88d527e8457cddf02887d1" translate="yes" xml:space="preserve">
          <source>The following standard library functions are &lt;strong&gt;UnformattedInputFunctions&lt;/strong&gt;.</source>
          <target state="translated">다음의 표준 라이브러리 함수는 &lt;strong&gt;UnformattedInputFunctions&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5b69d90b769dd1b2f532dc9339b7db1e70233cd" translate="yes" xml:space="preserve">
          <source>The following standard library functions are &lt;strong&gt;UnformattedOutputFunctions&lt;/strong&gt;.</source>
          <target state="translated">다음의 표준 라이브러리 함수는 &lt;strong&gt;UnformattedOutputFunctions&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d13f7fc713bbd7fbb501cfb262722eda5bd2609" translate="yes" xml:space="preserve">
          <source>The following standard library iterators are output iterators that are not forward iterators:</source>
          <target state="translated">다음 표준 라이브러리 반복기는 순방향 반복자가 아닌 출력 반복기입니다.</target>
        </trans-unit>
        <trans-unit id="798f4cbd9dba6c81e1c0811a4318bb2610b1288b" translate="yes" xml:space="preserve">
          <source>The following standard library types are &lt;strong&gt;ConstexprIterators&lt;/strong&gt;.</source>
          <target state="translated">다음 표준 라이브러리 유형은 &lt;strong&gt;ConstexprIterators&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e1774bde3d09ff1b66341e950d51e21a1688d8fd" translate="yes" xml:space="preserve">
          <source>The following standard library types are &lt;strong&gt;LegacyContiguousIterators&lt;/strong&gt;.</source>
          <target state="translated">다음 표준 라이브러리 유형은 &lt;strong&gt;LegacyContiguousIterators&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9822d186557d4ec43def3a5bb298d63e3e55ca3a" translate="yes" xml:space="preserve">
          <source>The following standard library types satisfy &lt;strong&gt;Mutex&lt;/strong&gt;:</source>
          <target state="translated">다음 표준 라이브러리 유형은 &lt;strong&gt;Mutex를&lt;/strong&gt; 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="3839c6b1e2941f810663e37c07c9bd57f5137bf2" translate="yes" xml:space="preserve">
          <source>The following standard library types satisfy &lt;strong&gt;SharedMutex&lt;/strong&gt;:</source>
          <target state="translated">다음 표준 라이브러리 유형은 &lt;strong&gt;SharedMutex를&lt;/strong&gt; 충족 &lt;strong&gt;시킵니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4af656071a5eee92d3b738c09cb8b1788943c228" translate="yes" xml:space="preserve">
          <source>The following standard library types satisfy &lt;strong&gt;SharedTimedMutex&lt;/strong&gt;:</source>
          <target state="translated">다음 표준 라이브러리 유형은 &lt;strong&gt;SharedTimedMutex를&lt;/strong&gt; 충족 &lt;strong&gt;시킵니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e75c35170e3fc67641a033c6b52eb7c81d48b3ee" translate="yes" xml:space="preserve">
          <source>The following standard library types satisfy &lt;strong&gt;TimedMutex&lt;/strong&gt;:</source>
          <target state="translated">다음 표준 라이브러리 유형은 &lt;strong&gt;TimedMutex를&lt;/strong&gt; 충족 &lt;strong&gt;시킵니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1377bfafdad89d2d5786eb764cf76e00e525017f" translate="yes" xml:space="preserve">
          <source>The following standard library types satisfy BitmaskType:</source>
          <target state="translated">다음 표준 라이브러리 유형은 BitmaskType을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="f47359b7f5be953e5e8316b3b16c4cfd96c74539" translate="yes" xml:space="preserve">
          <source>The following table lists the precedence and associativity of C++ operators. Operators are listed top to bottom, in descending precedence.</source>
          <target state="translated">다음 표는 C ++ 연산자의 우선 순위 및 연관성을 나열합니다. 연산자는 내림차순으로 위에서 아래로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="869cf0a93a08ae4a865cdd25ae31955da4b9045e" translate="yes" xml:space="preserve">
          <source>The following table provides a reference for the limits of common numeric representations.</source>
          <target state="translated">다음 표는 일반적인 숫자 표현의 한계에 대한 참조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="075cede2e87300a32b00122d0c950fe1bd6c8667" translate="yes" xml:space="preserve">
          <source>The following table shows the value of &lt;code&gt;basic_ios&lt;/code&gt; accessors (&lt;a href=&quot;../basic_ios/good&quot;&gt;&lt;code&gt;good()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_ios/fail&quot;&gt;&lt;code&gt;fail()&lt;/code&gt;&lt;/a&gt;, etc.) for all possible combinations of &lt;strong&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/strong&gt; flags:</source>
          <target state="translated">다음 표는 가능한 모든 &lt;strong&gt; &lt;code&gt;ios_base::iostate&lt;/code&gt; &lt;/strong&gt; 플래그 조합에 대한 &lt;code&gt;basic_ios&lt;/code&gt; 접근 자 ( &lt;a href=&quot;../basic_ios/good&quot;&gt; &lt;code&gt;good()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../basic_ios/fail&quot;&gt; &lt;code&gt;fail()&lt;/code&gt; &lt;/a&gt; 등) 의 값을 보여줍니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99ea509caafeb125e6fd07be315f0d67081751c9" translate="yes" xml:space="preserve">
          <source>The following table shows the value of &lt;code&gt;basic_ios&lt;/code&gt; accessors (&lt;a href=&quot;good&quot;&gt;&lt;code&gt;good()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;fail&quot;&gt;&lt;code&gt;fail()&lt;/code&gt;&lt;/a&gt;, etc.) for all possible combinations of &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/a&gt; flags:</source>
          <target state="translated">다음 표는 가능한 모든 &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;ios_base::iostate&lt;/code&gt; &lt;/a&gt; 플래그 조합에 대한 &lt;code&gt;basic_ios&lt;/code&gt; 접근 자 ( &lt;a href=&quot;good&quot;&gt; &lt;code&gt;good()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;fail&quot;&gt; &lt;code&gt;fail()&lt;/code&gt; &lt;/a&gt; 등) 의 값을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="745f79dd59ed6342386b7151436e3f17242c02d9" translate="yes" xml:space="preserve">
          <source>The following table shows the value of &lt;code&gt;basic_ios&lt;/code&gt; accessors (&lt;a href=&quot;good&quot;&gt;&lt;code&gt;good()&lt;/code&gt;&lt;/a&gt;, &lt;strong&gt;&lt;code&gt;fail()&lt;/code&gt;&lt;/strong&gt;, etc.) for all possible combinations of &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/a&gt; flags:</source>
          <target state="translated">다음 표는 가능한 모든 &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;ios_base::iostate&lt;/code&gt; &lt;/a&gt; 플래그 조합에 대한 &lt;code&gt;basic_ios&lt;/code&gt; 접근 자 ( &lt;a href=&quot;good&quot;&gt; &lt;code&gt;good()&lt;/code&gt; &lt;/a&gt; , &lt;strong&gt; &lt;code&gt;fail()&lt;/code&gt; &lt;/strong&gt; 등) 의 값을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="baa16009a2a3e8d14cfb3decd4d046c7405e0c14" translate="yes" xml:space="preserve">
          <source>The following table shows the value of &lt;code&gt;basic_ios&lt;/code&gt; accessors (&lt;strong&gt;&lt;code&gt;good()&lt;/code&gt;&lt;/strong&gt;, &lt;a href=&quot;fail&quot;&gt;&lt;code&gt;fail()&lt;/code&gt;&lt;/a&gt;, etc.) for all possible combinations of &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/a&gt; flags:</source>
          <target state="translated">다음 표는 가능한 모든 &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;ios_base::iostate&lt;/code&gt; &lt;/a&gt; 플래그 조합에 대한 &lt;code&gt;basic_ios&lt;/code&gt; 접근 자 ( &lt;strong&gt; &lt;code&gt;good()&lt;/code&gt; &lt;/strong&gt; , &lt;a href=&quot;fail&quot;&gt; &lt;code&gt;fail()&lt;/code&gt; &lt;/a&gt; 등) 의 값을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a901e9b7792340a20dc3a26c920d9911c931da64" translate="yes" xml:space="preserve">
          <source>The following table summarizes all available integer types and their properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc57bf9778baf29a073665323a0c5976c6a1f23" translate="yes" xml:space="preserve">
          <source>The following three-character groups (trigraphs) are &lt;a href=&quot;translation_phases&quot;&gt;parsed before comments and string literals are recognized&lt;/a&gt;, and each appearance of a trigraph is replaced by the corresponding primary character:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2dbbb940f65a4c22cd1d407d67021cc73fac74" translate="yes" xml:space="preserve">
          <source>The following tokens are recognized by the &lt;a href=&quot;preprocessor&quot;&gt;preprocessor&lt;/a&gt;</source>
          <target state="translated">다음 토큰은 &lt;a href=&quot;preprocessor&quot;&gt;전처리기에&lt;/a&gt; 의해 인식됩니다</target>
        </trans-unit>
        <trans-unit id="08cdd10ea2ca9c43a4ad2477073dc522db53c06e" translate="yes" xml:space="preserve">
          <source>The following tokens are recognized by the &lt;a href=&quot;preprocessor&quot;&gt;preprocessor&lt;/a&gt; when in context of a preprocessor directive:</source>
          <target state="translated">다음의 토큰이 인식하는 &lt;a href=&quot;preprocessor&quot;&gt;전처리&lt;/a&gt; 때 처리기 지시문의 맥락에서 :</target>
        </trans-unit>
        <trans-unit id="15f4805e7fc03f03ec8693800bb74acd46b9bd71" translate="yes" xml:space="preserve">
          <source>The following type aliases define the random number engine with two commonly used parameter sets:</source>
          <target state="translated">다음 유형 별명은 일반적으로 사용되는 두 개의 매개 변수 세트로 난수 엔진을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d2a02b2530d19cf2a9fd0c63e8f36bcf3e4d4b7d" translate="yes" xml:space="preserve">
          <source>The following type errors are SFINAE errors:</source>
          <target state="translated">다음 유형 오류는 SFINAE 오류입니다.</target>
        </trans-unit>
        <trans-unit id="08cef6066b25127cfb360b58024871a2ef93ea56" translate="yes" xml:space="preserve">
          <source>The following typedef defines the random number engine with one commonly used parameter set:</source>
          <target state="translated">다음 typedef는 일반적으로 사용되는 하나의 매개 변수 세트로 난수 엔진을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0628e731210af7f1451f479c8ea0eaea15b93ed0" translate="yes" xml:space="preserve">
          <source>The following typedefs define the random number engine with two commonly used parameter sets:</source>
          <target state="translated">다음 typedef는 일반적으로 사용되는 두 개의 매개 변수 세트로 난수 엔진을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1f6a99951a06b5fd8ea85e437236c5467963a19e" translate="yes" xml:space="preserve">
          <source>The following typedefs for common character types are provided:</source>
          <target state="translated">공통 문자 유형에 대한 다음 typedef가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="67202458185ead27be9490dca90a497de75d4077" translate="yes" xml:space="preserve">
          <source>The following types are</source>
          <target state="translated">다음과 같은 유형이 있습니다</target>
        </trans-unit>
        <trans-unit id="8767b4d8ec3caedfe52318cc0d33202d47bee690" translate="yes" xml:space="preserve">
          <source>The following types are dependent types:</source>
          <target state="translated">다음 유형은 종속 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9f298f8c48595121567682959a89caa583d0e719" translate="yes" xml:space="preserve">
          <source>The following types in the standard library satisfy these requirements:</source>
          <target state="translated">표준 라이브러리의 다음 유형은 이러한 요구 사항을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="d86187cf064bf2fed80acd4d6548d022ed06c4ab" translate="yes" xml:space="preserve">
          <source>The following types must satisfy NullablePointer:</source>
          <target state="translated">다음 유형은 NullablePointer를 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="05263cedaa87adae4404e0d5d0d5c6012425b488" translate="yes" xml:space="preserve">
          <source>The following values of &lt;code&gt;str&lt;/code&gt; are supported in all C locales:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8deaac6bb5ac34b75ff8d33e606b718c268c59" translate="yes" xml:space="preserve">
          <source>The following variables are also initialized to the same value:</source>
          <target state="translated">다음 변수도 같은 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="5c29167a05bd707a804eef66e8a46280899a02a0" translate="yes" xml:space="preserve">
          <source>The following variables are initialized to the same value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c115c3bcc9fbadc3a57b3f9c0400462a69bdd2ad" translate="yes" xml:space="preserve">
          <source>The formal definition ensures that:</source>
          <target state="translated">공식적인 정의는 다음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="fc058be4fe81eec42326824dea95a8995ba79311" translate="yes" xml:space="preserve">
          <source>The formal parameter of the catch clause (type-specifier-seq and declarator or type-specifier-seq and abstract-declarator) determines which types of exceptions cause this catch clause to be entered. It cannot be an &lt;a href=&quot;reference&quot;&gt;rvalue reference type&lt;/a&gt;, &lt;a href=&quot;abstract_class&quot;&gt;abstract class&lt;/a&gt;, &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, or pointer to incomplete type (except that pointers to (possibly &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;-qualified) &lt;code&gt;void&lt;/code&gt; are allowed). If the type of the formal parameter is array type or function type, it is treated as the corresponding pointer type (similar to a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;).</source>
          <target state="translated">catch 절의 형식 매개 변수 (type-specifier-seq 및 선언자 또는 type-specifier-seq 및 abstract-declarator)는이 catch 절을 입력하게하는 예외 유형을 결정합니다. 그것은 될 수 없습니다 &lt;a href=&quot;reference&quot;&gt;를 rvalue 참조 형&lt;/a&gt; , &lt;a href=&quot;abstract_class&quot;&gt;추상 클래스&lt;/a&gt; , &lt;a href=&quot;incomplete_type&quot;&gt;불완전 형&lt;/a&gt; ((아마도 해당 포인터를 제외하고 불완전한 형태, 또는 포인터 &lt;a href=&quot;cv&quot;&gt;이력서가&lt;/a&gt; ) restrict로 &lt;code&gt;void&lt;/code&gt; 허용됩니다). 형식 매개 변수의 유형이 배열 유형 또는 함수 유형 인 경우 해당 포인터 유형 ( &lt;a href=&quot;function&quot;&gt;함수 선언&lt;/a&gt; 과 유사)으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c84fba53b093effe5342ab55502a277a5ffaba5" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;filename&lt;/code&gt; is implementation-defined, and does not necessarily refer to a file (e.g. it may be the console or another device accessible through filesystem API). On platforms that support them, &lt;code&gt;filename&lt;/code&gt; may include absolute or relative filesystem path.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 의 형식 은 구현에 따라 정의되며 반드시 파일을 참조 할 필요는 없습니다 (예 : 파일 시스템 API를 통해 액세스 할 수있는 콘솔 또는 다른 장치 일 수 있음). 이를 지원하는 플랫폼에서 &lt;code&gt;filename&lt;/code&gt; 은 절대 또는 상대 파일 시스템 경로를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19e13fb520e9b9f29460d58a00f41c09337dc08f" translate="yes" xml:space="preserve">
          <source>The format of floating-point values is as follows:</source>
          <target state="translated">부동 소수점 값의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0add987dacb96215da068df8fc467e3a8d4b58c" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtof&quot;&gt;&lt;code&gt;strtof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../../string/byte/strtof&quot;&gt; &lt;code&gt;strtof()&lt;/code&gt; &lt;/a&gt; 예상 한 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c7a581065d0c8c103e51ec546cb2d29946e0e282" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 &lt;code&gt;base&lt;/code&gt; 인수에 대해 값 &lt;code&gt;10&lt;/code&gt; 을 갖는 &lt;a href=&quot;../../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt; 에서 예상 한 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="de50d9c89fd0c551d172e90d35e19763d28aebed" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">숫자의 형식은 예상과 동일하다 &lt;a href=&quot;../../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt; 값과 &lt;code&gt;​0​&lt;/code&gt; 위한 &lt;code&gt;base&lt;/code&gt; (베이스 파싱 첫 문자에 의해 결정된다) 인수.</target>
        </trans-unit>
        <trans-unit id="f009580f6110aee4f2a9398c68d1bf94787198b5" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 예상과 동일하다 &lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; 값으로 &lt;code&gt;10&lt;/code&gt; 위한 &lt;code&gt;base&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="48ec45a6a03f7559d556421a2a44ac148d321b20" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 예상과 동일하다 &lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; 값으로 &lt;code&gt;16&lt;/code&gt; 위한 &lt;code&gt;base&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="bb05ad1877111e85c5dfa1d9f5bf199cff8a0c43" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 예상과 동일하다 &lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; 값으로 &lt;code&gt;8&lt;/code&gt; 위한 &lt;code&gt;base&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="f5976eb1d0b6e29b5c32d55d187559f6ff886126" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstof&quot;&gt;&lt;code&gt;wcstof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../../string/wide/wcstof&quot;&gt; &lt;code&gt;wcstof()&lt;/code&gt; &lt;/a&gt; 예상 한 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fecd04092122729704233da78da7584029c1baf0" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt; 에서 예상 한 것과 &lt;code&gt;base&lt;/code&gt; 인수 의 값이 &lt;code&gt;10&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="5bb104d61d7e8e7ed04a16c3daae6cd68cca3601" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">숫자의 형식은 예상과 동일하다 &lt;a href=&quot;../../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt; 값과 &lt;code&gt;​0​&lt;/code&gt; 위한 &lt;code&gt;base&lt;/code&gt; (베이스 파싱 첫 문자에 의해 결정된다) 인수.</target>
        </trans-unit>
        <trans-unit id="90f5746e8bc2a7796c8836cbdbee3ca457ca3f47" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; 에서 예상 한 것과 &lt;code&gt;base&lt;/code&gt; 인수에 대한 값 &lt;code&gt;10&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="c174dea8f8ac6d3123fee439903c3ea47dd4f027" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;base&lt;/code&gt; 인수 의 값이 &lt;code&gt;16&lt;/code&gt; 인 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f5eb1aae953e6c6c5362653e5973307871541db0" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">숫자의 형식은 &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;base&lt;/code&gt; 인수에 대해 값 &lt;code&gt;8&lt;/code&gt; 을 갖는 것으로 예상 한 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="3d9e18bdb76f0cfc72cfc7220ca845cba830ae2b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary multibyte characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978f5198d804b9a4148d59f23d49bd19f235af7b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary wide characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ae2a1ebbf9dfc51f6f5d5f89c9ab7a18fe650c" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ac326d01048c042fad765ae54487eb3b38a164" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters. All ordinary characters, excluding the terminating null character, are written into the output stream without modification. Each unmodified conversion specifier begins with a &lt;code&gt;%&lt;/code&gt; character followed by a character that determines the behavior of the specifier. Some conversion specifiers have a modified form in which an &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier character is inserted after the &lt;code&gt;%&lt;/code&gt; character. Each conversion specifier is replaced by appropriate characters in the output as described below.</source>
          <target state="translated">형식 문자열은 0 개 이상의 변환 지정자와 일반 문자로 구성됩니다. 종료 널 문자를 제외한 모든 일반 문자는 수정없이 출력 스트림에 기록됩니다. 수정되지 않은 각 변환 지정자는 &lt;code&gt;%&lt;/code&gt; 문자로 시작하고 그 뒤에 지정자의 동작을 결정하는 문자가옵니다. 일부 변환 지정 자는 &lt;code&gt;%&lt;/code&gt; 문자 다음에 &lt;code&gt;E&lt;/code&gt; 또는 &lt;code&gt;O&lt;/code&gt; 수정 자 문자가 삽입 되는 수정 된 형식을 갖습니다 . 각 변환 지정자는 아래 설명 된대로 출력에서 ​​적절한 문자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3945cb192e1c3a5530627de4981979e1dedb2322" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters. Each ordinary character, excluding whitespace characters and the terminating null character, matches one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</source>
          <target state="translated">형식 문자열은 0 개 이상의 변환 지정자와 일반 문자로 구성됩니다. 공백 문자와 종료 널 문자를 제외한 각 일반 문자는 입력 스트림에서 동일한 문자 하나를 일치 시키거나 스트림의 다음 문자가 동일하게 비교되지 않으면 함수가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ae378d353693d1c7d74c4fd94775d83dcaefd506" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers, whitespace characters, and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). Each ordinary character is expected to match one character in the input stream in case-insensitive comparison. Each whitespace character matches arbitrary whitespace in the input string. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The format specifiers match the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime()&lt;/a&gt;:</source>
          <target state="translated">형식 문자열은 0 개 이상의 변환 지정자, 공백 문자 및 일반 문자 ( &lt;code&gt;%&lt;/code&gt; 제외 )로 구성됩니다. 각 일반 문자는 대소 문자를 구분하지 않고 입력 스트림의 한 문자와 일치해야합니다. 각 공백 문자는 입력 문자열에서 임의의 공백과 일치합니다. 각 변환 스펙은 &lt;code&gt;%&lt;/code&gt; 문자로 시작하고 선택적으로 &lt;code&gt;E&lt;/code&gt; 또는 &lt;code&gt;O&lt;/code&gt; 수정 자 (로케일이 지원하지 않는 경우 무시 됨)가오고 그 뒤에 지정자의 동작을 결정하는 문자가옵니다. 형식 지정자는 POSIX 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime ()&lt;/a&gt; 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="5d35574333561b6d7197206a894209f7b4dca21b" translate="yes" xml:space="preserve">
          <source>The format string consists of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f557203d9607d6c00cf9156c3eb7b68888a42acd" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; used by this function is always &lt;code&gt;mp.neg_format()&lt;/code&gt;.</source>
          <target state="translated">이 함수에서 사용하는 서식 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; 은 항상 &lt;code&gt;mp.neg_format()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="36de08c85d1411e27803f51f67e99c60bb0859a9" translate="yes" xml:space="preserve">
          <source>The friend declaration appears in a &lt;a href=&quot;class&quot;&gt;class body&lt;/a&gt; and grants a function or another class access to private and protected members of the class where the friend declaration appears.</source>
          <target state="translated">친구 선언은 &lt;a href=&quot;class&quot;&gt;클래스 본문에&lt;/a&gt; 나타나고 친구 선언이 나타나는 클래스의 비공개 및 보호 된 멤버에게 함수 또는 다른 클래스 액세스 권한을 부여합니다.</target>
        </trans-unit>
        <trans-unit id="f1e777bed230647173e4ad51c340e8839794d4c2" translate="yes" xml:space="preserve">
          <source>The full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in &lt;code&gt;flagp&lt;/code&gt; in implementation-defined format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3faeb997d1ed337e80e4abb047a6ba3e3e7ebc" translate="yes" xml:space="preserve">
          <source>The full path the directory entry refers to.</source>
          <target state="translated">디렉토리 항목이 참조하는 전체 경로</target>
        </trans-unit>
        <trans-unit id="3d6b6fb5d314fe36dd9f31283cfc562903b69b1f" translate="yes" xml:space="preserve">
          <source>The function (or member) name specified by &lt;code&gt;E&lt;/code&gt; can be overloaded, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; rules used to decide which overload is to be called.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; 로 지정된 함수 (또는 멤버) 이름은 오버로드 될 수 있으며 오버 &lt;a href=&quot;overload_resolution&quot;&gt;로드 해결&lt;/a&gt; 규칙은 호출 할 오버로드를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e82b0b07e6f429ee9f9368f05dad9fa0ba43d37a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;TC::now()&lt;/code&gt; does not throw exceptions.</source>
          <target state="translated">&lt;code&gt;TC::now()&lt;/code&gt; 함수 는 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e4cb90e10ef6ef7003e78c1e00b67a01ecdf0f5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;canonical()&lt;/code&gt; is modeled after the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;realpath&lt;/a&gt;.</source>
          <target state="translated">함수 &lt;code&gt;canonical()&lt;/code&gt; 은 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;realpath&lt;/a&gt; 이후에 모델링 됩니다.</target>
        </trans-unit>
        <trans-unit id="83d5158312c85ad69a25e7f6c7b3eb92ed2aac66" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;std::frexp&lt;/code&gt;, together with its dual, &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;std::ldexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">&lt;code&gt;std::frexp&lt;/code&gt; 함수 는 듀얼 &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;std::ldexp&lt;/a&gt;&lt;/code&gt; 와 함께 직접 비트 조작없이 부동 소수점 숫자의 표현을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a6d7907ee719b354792f98bec95c1316c2a0690" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;std::ldexp&lt;/code&gt; (&quot;load exponent&quot;), together with its dual, &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">함수 &lt;code&gt;std::ldexp&lt;/code&gt; ( &quot;부하 지수&quot;) 함께 듀얼과 &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; 직접 조작하지 않고 비트 부동 소수점 숫자의 표시를 조작하는 데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="57c5dfaac85f79a223adb7359ed5cef42e000f8a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;weakly_canonical()&lt;/code&gt; was introduced to simplify operational semantics of &lt;a href=&quot;relative&quot;&gt;&lt;code&gt;relative()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;relative&quot;&gt; &lt;code&gt;relative()&lt;/code&gt; &lt;/a&gt; 의 운영 의미론을 단순화하기 위해 &lt;code&gt;weakly_canonical()&lt;/code&gt; 함수 가 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="65499eb81228ba91e476f471dc5abca02679437e" translate="yes" xml:space="preserve">
          <source>The function accepts (and does nothing with) the null pointer to reduce the amount of special-casing. Whether allocation succeeds or not, the pointer returned by an allocation function can be passed to &lt;code&gt;std::free&lt;/code&gt;.</source>
          <target state="translated">이 함수는 널 케이싱을 받아들이고 특수 케이스의 양을 줄입니다. 할당 성공 여부에 관계없이 할당 함수에 의해 리턴 된 포인터는 &lt;code&gt;std::free&lt;/code&gt; 로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2446536a1064ed7b3941beeb277b791515eaa68b" translate="yes" xml:space="preserve">
          <source>The function body is a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; (sequence of zero or more statements surrounded by a pair of curly braces), which is executed when the function call is made.</source>
          <target state="translated">함수 본문은 &lt;a href=&quot;statements#Compound_statements&quot;&gt;복합 명령문&lt;/a&gt; (한 쌍의 중괄호로 묶인 0 개 이상의 명령문 시퀀스)이며 함수 호출이 실행될 때 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c3d08aba422a7497ce575560818de2b5e3664ee2" translate="yes" xml:space="preserve">
          <source>The function call expressions have the form.</source>
          <target state="translated">함수 호출 표현식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef5f5323e424bfd7a1f80cd467bc80719cc4bc17" translate="yes" xml:space="preserve">
          <source>The function called by a user-defined literal is known as</source>
          <target state="translated">사용자 정의 리터럴에 의해 호출 된 함수는</target>
        </trans-unit>
        <trans-unit id="21d35ce53dec97b605e35fbf4bfeaf3e6b25267e" translate="yes" xml:space="preserve">
          <source>The function calls &lt;code&gt;&lt;a href=&quot;sbumpc&quot;&gt;sbumpc()&lt;/a&gt;&lt;/code&gt; to advance the input sequence. If that function returns &lt;code&gt;Traits::eof()&lt;/code&gt; meaning that input sequence has been exhausted and &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; could not retrieve more data, &lt;code&gt;Traits::eof()&lt;/code&gt; is returned. Otherwise &lt;code&gt;&lt;a href=&quot;sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt; is called in order to read the character.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;sbumpc&quot;&gt;sbumpc()&lt;/a&gt;&lt;/code&gt; 를 호출 하여 입력 시퀀스를 진행시킵니다. 그 함수가 반환의 경우 &lt;code&gt;Traits::eof()&lt;/code&gt; 이 입력 순서를 의미 소진되어 왔으며 &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; , 더 많은 데이터를 검색 할 수 없습니다 &lt;code&gt;Traits::eof()&lt;/code&gt; 반환됩니다. 그렇지 않으면 문자를 읽기 위해 &lt;code&gt;&lt;a href=&quot;sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e8f1319f9d6ef5782692a77b9fd4057196ea681b" translate="yes" xml:space="preserve">
          <source>The function can be implemented with the return type different from &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;. In this case, the replacement type has the following properties:</source>
          <target state="translated">함수는 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 와 다른 리턴 유형으로 구현할 수 있습니다 . 이 경우 교체 유형에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c822a40a4534bfa3e5439e5ab35928c6a3a344b3" translate="yes" xml:space="preserve">
          <source>The function can be used only if &lt;code&gt;operator&amp;lt;&lt;/code&gt; is defined for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형에 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 가 정의 된 경우에만이 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="882d329b93dcad39ff502adfce6844369dd33e8b" translate="yes" xml:space="preserve">
          <source>The function can be used only if &lt;code&gt;operator+=&lt;/code&gt; is defined for type &lt;code&gt;T&lt;/code&gt;. If the &lt;code&gt;std::valarray&lt;/code&gt; is empty, the behavior is undefined. The order in which the elements are processed by this function is unspecified.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형에 &lt;code&gt;operator+=&lt;/code&gt; 가 정의 된 경우에만 함수를 사용할 수 있습니다 . 경우 &lt;code&gt;std::valarray&lt;/code&gt; 비어 동작은 정의되지 않는다. 이 함수가 요소를 처리하는 순서는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91f7fe88eabe258e81ae01d0f690791e30dabd0d" translate="yes" xml:space="preserve">
          <source>The function does not participate in overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ToDuration&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 의 인스턴스가 아니면 함수는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b0d7738f85da6ab4917bf056d0bb5e776378bfa8" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;Rep&amp;gt;::is_signed&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;Rep&amp;gt;::is_signed&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 가 아니면 함수는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3f53989ed7fe6b85b91be67846d454e5a5091efc" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ToDuration&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우가 아니면 함수 는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2bf9d721422f351f851c897408c2ce6f0621c92c" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ToDuration&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 의 인스턴스가 아니면 함수 는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="38127f74fcf3c7345c5f5fdb8dc95f19e70fd613" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an specialization of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ToDuration&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우를 제외 하고 는 함수가 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4dd86d349303d51526c774f537efd9b40b552f98" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an specialization of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ToDuration&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 의 전문화가 아니면 함수 는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="126f425397cb45dc94e0836b07e8eefad9995278" translate="yes" xml:space="preserve">
          <source>The function does not support localization, and the newline character cannot be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072cec0bee6f6155df5b228611698b2538fe2d6d" translate="yes" xml:space="preserve">
          <source>The function does not support localization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ca2d431e6b4c994632d537c675b64adb91091c" translate="yes" xml:space="preserve">
          <source>The function drops any effects from previous calls to &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;ungetc&lt;/code&gt; 에 대한 이전 호출에서 모든 효과를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="23ccd8cd43cb3d597e337e15d54fe5c87828b3ec" translate="yes" xml:space="preserve">
          <source>The function has mathematical poles at &amp;pi;(1/2 + n); however no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af880fe541df16b2fd4a74d41e9903882d62887d" translate="yes" xml:space="preserve">
          <source>The function is continuous onto the branch cut taking into account the sign of imaginary part</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064517df7162e7c80b05f70d0c1d72dcf596b5e9" translate="yes" xml:space="preserve">
          <source>The function is equivalent to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt;, except that end-of-file and error indicators are cleared.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt; 을 제외하고 파일 끝 및 오류 표시기가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="75e35cecac837fab428a324853818b53ded0ac11" translate="yes" xml:space="preserve">
          <source>The function is named after the integer function ⍳ from the programming language APL. It was one of the &lt;a href=&quot;http://www.sgi.com/tech/stl/iota.html&quot;&gt;STL components&lt;/a&gt; that were not included in C++98, but eventually made it into the standard library in C++11.</source>
          <target state="translated">이 함수의 이름은 프로그래밍 언어 APL의 정수 함수 after로 명명됩니다. C ++ 98에 포함되지 않은 &lt;a href=&quot;http://www.sgi.com/tech/stl/iota.html&quot;&gt;STL 구성 요소&lt;/a&gt; 중 하나 였지만 결국 C ++ 11의 표준 라이브러리로 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="e9eb4c7699e43ce8f08f56257eff79ffdcf27b49" translate="yes" xml:space="preserve">
          <source>The function is not required to be defined for |x|&amp;gt;1</source>
          <target state="translated">| x |&amp;gt; 1에 대해 기능을 정의하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="b0d406efcda5923258fa6e7ba435edf7afdbb66b" translate="yes" xml:space="preserve">
          <source>The function is only required to be defined where both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are greater than zero, and is allowed to report a domain error otherwise.</source>
          <target state="translated">이 함수는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 0보다 큰 경우 에만 정의해야하며 그렇지 않으면 도메인 오류를보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6034c35371ebcc562e4d00c27057a576e4fdd7db" translate="yes" xml:space="preserve">
          <source>The function may update &lt;code&gt;gptr&lt;/code&gt;, &lt;code&gt;egptr&lt;/code&gt; and &lt;code&gt;eback&lt;/code&gt; pointers to define the location of newly loaded data (if any). On failure, the function ensures that either &lt;code&gt;gptr() == nullptr&lt;/code&gt; or &lt;code&gt;gptr() == egptr&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;gptr&lt;/code&gt; , &lt;code&gt;egptr&lt;/code&gt; 및 &lt;code&gt;eback&lt;/code&gt; 포인터를 업데이트 하여 새로로드 된 데이터 (있는 경우)의 위치를 ​​정의 할 수 있습니다. 실패시, 함수는 &lt;code&gt;gptr() == nullptr&lt;/code&gt; 또는 &lt;code&gt;gptr() == egptr&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e7a7a46183956d552300dee684d15128ebe48ebf" translate="yes" xml:space="preserve">
          <source>The function may update &lt;code&gt;pptr&lt;/code&gt;, &lt;code&gt;epptr&lt;/code&gt; and &lt;code&gt;pbase&lt;/code&gt; pointers to define the location to write more data. On failure, the function ensures that either &lt;code&gt;pptr() == nullptr&lt;/code&gt; or &lt;code&gt;pptr() == epptr&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;pptr&lt;/code&gt; , &lt;code&gt;epptr&lt;/code&gt; 및 &lt;code&gt;pbase&lt;/code&gt; 포인터를 업데이트 하여 더 많은 데이터를 쓸 위치를 정의 할 수 있습니다. 실패시, 함수는 &lt;code&gt;pptr() == nullptr&lt;/code&gt; 또는 &lt;code&gt;pptr() == epptr&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="15af0ce237ff3b3144c6a868b8ee125006a14e71" translate="yes" xml:space="preserve">
          <source>The function modifies static storage and is not thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3db171e79e2989a832c6ee9c99d6df12884a1d" translate="yes" xml:space="preserve">
          <source>The function modifies the pointer only if it would be possible to fit the wanted number of bytes aligned by the given alignment into the buffer. If the buffer is too small, the function does nothing and returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">함수는 주어진 정렬에 의해 정렬 된 원하는 바이트 수를 버퍼에 맞출 수있는 경우에만 포인터를 수정합니다. 버퍼가 너무 작은 경우, 함수는 아무것도하지 않고 &lt;code&gt;nullptr&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bc27df1dece75c7950d8306c4124d7ab25b1a17f" translate="yes" xml:space="preserve">
          <source>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f186c1fa81fe391780ded04d401cc94118bdba5" translate="yes" xml:space="preserve">
          <source>The function name stands for &quot;complementary span&quot;</source>
          <target state="translated">함수 이름은 &quot;상보 적 스팬&quot;을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="db20681f76479d1a2df4829db6ccf4a0a080e0ef" translate="yes" xml:space="preserve">
          <source>The function name stands for &quot;new scalb&quot;, where &lt;code&gt;scalb&lt;/code&gt; was an older non-standard function whose second argument had floating-point type.</source>
          <target state="translated">함수 이름은 &quot;new scalb&quot;를 나타냅니다. 여기서 &lt;code&gt;scalb&lt;/code&gt; 는 두 번째 인수에 부동 소수점 유형이있는 오래된 비표준 함수입니다.</target>
        </trans-unit>
        <trans-unit id="c9dcfedf49fa204154f0431b2673a0daebcd06a5" translate="yes" xml:space="preserve">
          <source>The function object &lt;code&gt;pred&lt;/code&gt; shall not apply any non-constant function through the dereferenced iterator. This function object may be a pointer to function or an object of a type with an appropriate function call operator.</source>
          <target state="translated">함수 객체 &lt;code&gt;pred&lt;/code&gt; 는 역 참조 된 반복자를 통해 일정하지 않은 함수를 적용해서는 안됩니다. 이 함수 객체는 함수에 대한 포인터이거나 적절한 함수 호출 연산자를 가진 유형의 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fec4de0270a6f3097d68f50b43e7edfb64e10dc9" translate="yes" xml:space="preserve">
          <source>The function parameters that do not participate in template argument deduction (e.g. if the corresponding template arguments are explicitly specified) are subject to implicit conversions to the type of the corresponding function parameter (as in the usual &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;).</source>
          <target state="translated">템플릿 인수 공제에 참여하지 않는 함수 매개 변수 (예 : 해당 템플릿 인수가 명시 적으로 지정된 경우)는 해당 함수 매개 변수 유형 (일반적인 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결&lt;/a&gt; 에서와 같이 ) 으로 암시 적으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7eeb93d2b7dca68685dc425373a6764fb01e3729" translate="yes" xml:space="preserve">
          <source>The function provides no means to prevent buffer overflow of the destination array, given sufficiently long input string. &lt;code&gt;std::gets&lt;/code&gt; was deprecated in C++11 and removed from C++14.</source>
          <target state="translated">이 함수는 입력 문자열이 충분히 길면 대상 배열의 버퍼 오버플로를 방지 할 수단을 제공하지 않습니다. &lt;code&gt;std::gets&lt;/code&gt; 는 C ++ 11에서 더 이상 사용되지 않으며 C ++ 14에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa9dad8347dfb2e0d670a4af83e853b0527c897a" translate="yes" xml:space="preserve">
          <source>The function template &lt;code&gt;bind&lt;/code&gt; generates a forwarding call wrapper for &lt;code&gt;f&lt;/code&gt;. Calling this wrapper is equivalent to invoking &lt;code&gt;f&lt;/code&gt; with some of its arguments bound to &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">함수 템플리트 &lt;code&gt;bind&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 에 대한 전달 호출 랩퍼를 생성합니다 . 이 랩퍼를 호출하는 것은 인수의 일부가 &lt;code&gt;args&lt;/code&gt; 에 바인드되어 &lt;code&gt;f&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1b74686fedbb22b834206589460eadd916d0aa6c" translate="yes" xml:space="preserve">
          <source>The function template &lt;code&gt;bind_front&lt;/code&gt; generates a forwarding call wrapper for &lt;code&gt;f&lt;/code&gt;. Calling this wrapper is equivalent to invoking &lt;code&gt;f&lt;/code&gt; with its first &lt;code&gt;sizeof...(Args)&lt;/code&gt; parameters bound to &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">함수 템플리트 &lt;code&gt;bind_front&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 에 대한 전달 호출 랩퍼를 생성합니다 . 이 래퍼를 호출하는 것은 &lt;code&gt;args&lt;/code&gt; 에 바인딩 된 첫 번째 &lt;code&gt;sizeof...(Args)&lt;/code&gt; 매개 변수를 사용하여 &lt;code&gt;f&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a42b57be9690e30b4d127d5c56b2e136867973a2" translate="yes" xml:space="preserve">
          <source>The function templates #1 and #3 have different signatures and are distinct templates. Nonetheless, #2 and #4, despite being instantiations of different function templates, have the same mangled name &lt;a href=&quot;https://github.com/itanium-cxx-abi/cxx-abi/issues/20&quot;&gt;in the Itanium C++ ABI&lt;/a&gt; (&lt;code&gt;_Z4funcI1XLi0EEvv&lt;/code&gt;), meaning that the linker will erroneously consider them to be the same entity.</source>
          <target state="translated">기능 템플릿 # 1과 # 3은 서로 다른 서명을 가지며 고유 한 템플릿입니다. 그럼에도 불구하고, # 2와 # 4는 서로 다른 함수 템플릿의 인스턴스화에도 불구하고 &lt;a href=&quot;https://github.com/itanium-cxx-abi/cxx-abi/issues/20&quot;&gt;Itanium C ++ ABI&lt;/a&gt; ( &lt;code&gt;_Z4funcI1XLi0EEvv&lt;/code&gt; ) 에서 맹 글링 된 이름이 동일 하므로 링커에서이를 동일한 엔티티로 잘못 간주합니다.</target>
        </trans-unit>
        <trans-unit id="1661ab084a02d0a0b4022e49867df5380e8a9ad8" translate="yes" xml:space="preserve">
          <source>The function templates are then ranked as if for &lt;a href=&quot;function_template#Function_template_overloading&quot;&gt;function template overloading&lt;/a&gt;.</source>
          <target state="translated">그런 다음 함수 템플릿은 &lt;a href=&quot;function_template#Function_template_overloading&quot;&gt;함수 템플릿 오버로드&lt;/a&gt; 와 같이 순위가 매겨집니다 .</target>
        </trans-unit>
        <trans-unit id="7c3559ff21a7ec0a87fd87249ee0c6ee1ced4a14" translate="yes" xml:space="preserve">
          <source>The function then returns the pointer to the beginning of the token</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4126da2324b4eb270d68c514e43af8301f52dd63" translate="yes" xml:space="preserve">
          <source>The function to calculate the result has not been started yet</source>
          <target state="translated">결과를 계산하는 기능이 아직 시작되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="eb957ebe7149eefbfbfc9fa1905a6cdb297d02f9" translate="yes" xml:space="preserve">
          <source>The function type of the function template is &lt;code&gt;P&lt;/code&gt;. The &lt;a href=&quot;overloaded_address&quot;&gt;target type&lt;/a&gt; is the type of &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">함수 템플릿의 함수 유형은 &lt;code&gt;P&lt;/code&gt; 입니다. &lt;a href=&quot;overloaded_address&quot;&gt;타겟 유형&lt;/a&gt; 의 유형 : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d62041d0f93824e7e4927764fa5aa1df2523bc0c" translate="yes" xml:space="preserve">
          <source>The function-call operator is always &lt;code&gt;constexpr&lt;/code&gt; if it satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr function&lt;/a&gt;. It is also constexpr if the keyword constexpr was used in the lambda declaration.</source>
          <target state="translated">함수 호출 연산자는 &lt;a href=&quot;constexpr&quot;&gt;constexpr 함수&lt;/a&gt; 의 요구 사항을 충족시키는 경우 항상 &lt;code&gt;constexpr&lt;/code&gt; 입니다. 키워드 constexpr이 람다 선언에 사용 된 경우에도 constexpr입니다.</target>
        </trans-unit>
        <trans-unit id="90237372df253176f7201dadf305ca2efdb82ba0" translate="yes" xml:space="preserve">
          <source>The function-call operator is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the keyword &lt;code&gt;consteval&lt;/code&gt; was used in the lambda expression.</source>
          <target state="translated">키워드 &lt;code&gt;consteval&lt;/code&gt; 이 람다 식에 사용 된 경우 &lt;a href=&quot;consteval&quot;&gt;함수&lt;/a&gt; 호출 연산자는 즉시 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="18222cb267ac69f3312ca400b95bb5960956fbce" translate="yes" xml:space="preserve">
          <source>The function-call operators of T are obtained by ordinary &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt; of the name &lt;code&gt;operator()&lt;/code&gt; in the context of the expression &lt;code&gt;(E).operator()&lt;/code&gt;, and every declaration found is added to the set of candidate functions.</source>
          <target state="translated">T의 함수 호출 연산자 는 표현식 &lt;code&gt;(E).operator()&lt;/code&gt; 의 컨텍스트에서 이름 &lt;code&gt;operator()&lt;/code&gt; 를 일반 &lt;a href=&quot;lookup&quot;&gt;조회&lt;/a&gt; 하여 얻습니다. 발견 된 모든 선언은 후보 함수 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5f03f8854c3dadb42ebc1a2f13e6f98271799bab" translate="yes" xml:space="preserve">
          <source>The function-like entities described on this page are</source>
          <target state="translated">이 페이지에 설명 된 기능적인 엔티티는</target>
        </trans-unit>
        <trans-unit id="c90c3720bc6cd842ff45d50c455cbeb05ef64826" translate="yes" xml:space="preserve">
          <source>The function-try-block is one of the alternative syntax forms for function-body, which is a part of &lt;a href=&quot;function&quot;&gt;function definition&lt;/a&gt;.</source>
          <target state="translated">function-try-block은 &lt;a href=&quot;function&quot;&gt;함수 정의&lt;/a&gt; 의 일부인 function-body에 대한 대체 구문 형식 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="7d70566d5bc405ba10ba5bb68262596374bff760" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;std::expm1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;std::log1p&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;std::expm1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;std::log1p&lt;/code&gt; 함수 는 작은 일일 이자율 계산과 같이 재무 계산에 유용합니다. (1 + x) n</target>
        </trans-unit>
        <trans-unit id="ce063565abd09222888790e9a9d67e9d39a935ae" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;std::expm1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;std::log1p&lt;/a&gt;&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">&lt;code&gt;std::expm1&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;std::log1p&lt;/a&gt;&lt;/code&gt; 함수 는 작은 일일 이자율 계산과 같이 재무 계산에 유용합니다. (1 + x) n</target>
        </trans-unit>
        <trans-unit id="7d057934f5d91a8d0d5efe334eb2fd28c09a314a" translate="yes" xml:space="preserve">
          <source>The functions may be called concurrently with the destruction of the objects with static storage duration and with each other, maintaining the guarantee that if registration of A was sequenced-before the registration of B, then the call to B is sequenced-before the call to A, same applies to the sequencing between static object constructors and calls to &lt;code&gt;atexit&lt;/code&gt;: see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정적 저장 기간을 갖는 객체의 소멸과 동시에 함수가 호출 될 수 있으며, B의 등록 이전에 A의 등록이 시퀀스 된 경우 B에 대한 호출이 호출되기 전에 시퀀스된다는 보장을 유지 A, 정적 객체 생성자와 &lt;code&gt;atexit&lt;/code&gt; 호출 간의 시퀀싱에도 동일하게 적용됩니다 ( &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="3db16cc57db5dbc928e64b1b6ac3975c579a8b6a" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e95f56658767e1e470d9215d4b6600bf8174e3" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ad6824d6f8c048fddeb1809adb4e0dadf9dc71" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7ec7a3aab98e1d97256af5eb3cd5dd8ac9ef4b" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f29db516e7cae858024d84b5b0bd244f31b9db50" translate="yes" xml:space="preserve">
          <source>The functions that accept rvalue reference parameters (including &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt;, &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt;, and regular member functions such as &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt;) are selected, by &lt;a href=&quot;../language/overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, when called with &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; arguments (either &lt;a href=&quot;../language/value_category&quot;&gt;prvalues&lt;/a&gt; such as a temporary objects or &lt;a href=&quot;../language/value_category&quot;&gt;xvalues&lt;/a&gt; such as the one produced by &lt;code&gt;std::move&lt;/code&gt;). If the argument identifies a resource-owning object, these overloads have the option, but aren't required, to</source>
          <target state="translated">&lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; 인수 ( 임시 객체와 같은 &lt;a href=&quot;../language/value_category&quot;&gt;prvalue)&lt;/a&gt; 와 함께 호출 될 때 rvalue 참조 매개 변수 ( &lt;a href=&quot;../language/move_constructor&quot;&gt;move 생성자&lt;/a&gt; , &lt;a href=&quot;../language/move_operator&quot;&gt;이동 할당 연산자&lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt; 과 같은 일반 멤버 함수 포함)를 허용하는 함수는 &lt;a href=&quot;../language/overload_resolution&quot;&gt;과부하 분석에&lt;/a&gt; 의해 선택 됩니다. 또는 &lt;code&gt;std::move&lt;/code&gt; 의해 생성 된 것과 같은 &lt;a href=&quot;../language/value_category&quot;&gt;xvalue&lt;/a&gt; ). 인수가 리소스 소유 객체를 식별하는 경우 이러한 오버로드에는 다음과 같은 옵션이 있지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e09608bd7873c020fdfa17e45a1cb9324cfb8735" translate="yes" xml:space="preserve">
          <source>The functions underflow() and overflow()/sync() perform the actual I/O between the file and the get and put areas of the buffer. When &lt;code&gt;CharT&lt;/code&gt; is not &lt;code&gt;char&lt;/code&gt;, most implementations store multibyte characters in the file and a &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet is used to perform wide/multibyte character conversion.</source>
          <target state="translated">underflow () 및 overflow () / sync () 함수는 파일과 버퍼의 get 및 put 영역간에 실제 I / O를 수행합니다. 때 &lt;code&gt;CharT&lt;/code&gt; 아닌 &lt;code&gt;char&lt;/code&gt; , 대부분의 구현 파일에 멀티 바이트 문자를 저장하고 &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 면은 / 다양한 멀티 바이트 문자 변환을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bffe0d58cdd89a2176e51e07265897958db537f6" translate="yes" xml:space="preserve">
          <source>The functions will be called during the destruction of the static objects, in reverse order: if A was registered before B, then the call to B is made before the call to A. Same applies to the ordering between static object constructors and the calls to &lt;code&gt;atexit&lt;/code&gt;: see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정적 객체를 소멸하는 동안 함수가 역순으로 호출됩니다. A가 B보다 먼저 등록 된 경우 A를 호출하기 전에 B를 호출합니다. 정적 오브젝트 생성자와 호출에 대한 호출에 동일하게 적용됩니다. &lt;code&gt;atexit&lt;/code&gt; : &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aed96e855f7e3173d3f85e69b959cd5f429e28d2" translate="yes" xml:space="preserve">
          <source>The generated random number.</source>
          <target state="translated">생성 된 난수입니다.</target>
        </trans-unit>
        <trans-unit id="7e36dee47d5123274fbbdd384f8394bc9448d978" translate="yes" xml:space="preserve">
          <source>The generation of the implicitly-defined copy assignment operator is deprecated(since C++11) if &lt;code&gt;T&lt;/code&gt; has a user-declared destructor or user-declared copy constructor.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에 사용자 선언 소멸자 또는 사용자 선언 사본 생성자가 있으면 C ++ 11부터 암시 적으로 정의 된 사본 할당 연산자의 생성이 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9e1eed93866aa0d0e35d2a62d35e689f1a41f754" translate="yes" xml:space="preserve">
          <source>The generation of the implicitly-defined copy constructor is deprecated if &lt;code&gt;T&lt;/code&gt; has a user-defined destructor or user-defined copy assignment operator.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에 사용자 정의 소멸자 또는 사용자 정의 사본 할당 연산자가 있으면 암시 적으로 정의 된 복사 생성자의 생성이 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4f4aa88d036bf2efbab8a357c041b989e684ecb4" translate="yes" xml:space="preserve">
          <source>The generic template and two template specializations each contain a single version of &lt;code&gt;get&lt;/code&gt;. The three versions of &lt;code&gt;get&lt;/code&gt; differ only in the return type.</source>
          <target state="translated">일반 템플리트와 두 가지 템플리트 특수화에는 각각 단일 버전의 &lt;code&gt;get&lt;/code&gt; 이 포함되어 있습니다 . &lt;code&gt;get&lt;/code&gt; 의 세 가지 버전은 리턴 유형에서만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7aac1cf4d4dcf6d2df58133c2a7081efc8452b18" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cerr&lt;/code&gt; and &lt;code&gt;std::wcerr&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::wstreambuf&lt;/a&gt;&lt;/code&gt;, respectively), associated with the standard C error output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전역 객체 &lt;code&gt;std::cerr&lt;/code&gt; 및 &lt;code&gt;std::wcerr&lt;/code&gt; 는 표준 C 오류 출력 스트림 &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 과 연관된 구현 정의 유형 ( 각각 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::wstreambuf&lt;/a&gt;&lt;/code&gt; 에서 파생 됨)의 스트림 버퍼로 출력을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="4cdce0c44ee46c553e1a9e5502ff67dca5ca8589" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cin&lt;/code&gt; and &lt;code&gt;std::wcin&lt;/code&gt; control input from a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C input stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전역 객체 &lt;code&gt;std::cin&lt;/code&gt; 및 &lt;code&gt;std::wcin&lt;/code&gt; 은 표준 C 입력 스트림 &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 과 연관된 구현 정의 유형 ( &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 에서 파생 된)의 스트림 버퍼에서 입력을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="461aa84897b843038a6471036df9b6bfd2e5db28" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::clog&lt;/code&gt; and &lt;code&gt;std::wclog&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;, but, unlike &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt;, these streams are not automatically flushed and not automatically tie()'d with cout.</source>
          <target state="translated">전역 객체 &lt;code&gt;std::clog&lt;/code&gt; 및 &lt;code&gt;std::wclog&lt;/code&gt; 는 표준 C 출력 스트림 &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 과 연관된 구현 정의 유형 ( &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 에서 파생 됨)의 스트림 버퍼로 출력을 제어 하지만 &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; 와는 달리 :: wcerr , 이러한 스트림은 자동으로 플러시되지 않으며 cout과 자동으로 tie ()되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5f98bba6559b17ed7e6d131e3611a81638ab812" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cout&lt;/code&gt; and &lt;code&gt;std::wcout&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전역 객체 &lt;code&gt;std::cout&lt;/code&gt; 및 &lt;code&gt;std::wcout&lt;/code&gt; 은 표준 C 출력 스트림 &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 과 연관된 구현 정의 유형 ( &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 에서 파생 된)의 스트림 버퍼로 출력을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="70f50373a3f6e5f0380c536e396a13926eb96f45" translate="yes" xml:space="preserve">
          <source>The goto statement transfers control to the location specified by &lt;a href=&quot;statements#Labels&quot;&gt;label&lt;/a&gt;. The goto statement must be in the same function as the label it is referring, it may appear before or after the label.</source>
          <target state="translated">goto 문은 제어를 &lt;a href=&quot;statements#Labels&quot;&gt;label로&lt;/a&gt; 지정된 위치로 전송합니다 . goto 문은 참조하는 레이블과 동일한 기능이어야하며 레이블 앞뒤에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9203ba2e1b9acd8459fc296135b185d6bdec6014" translate="yes" xml:space="preserve">
          <source>The groups are stored as binary values: three-digit group is &lt;code&gt;'\3'&lt;/code&gt;, and 51-digit group is &lt;code&gt;'3'&lt;/code&gt;. The character at index zero of the returned string holds the number of digits in the rightmost group. The character at index 1 holds the number of digits in the second group from the right, etc. The grouping indicated by the last character in the returned string is reused to group all remaining digits in the (left part of) the number.</source>
          <target state="translated">그룹은 이진수 값으로 저장됩니다. 3 자리 그룹은 &lt;code&gt;'\3'&lt;/code&gt; 이고 51 자리 그룹은 &lt;code&gt;'3'&lt;/code&gt; 입니다. 반환 된 문자열의 인덱스 0에있는 문자는 가장 오른쪽 그룹의 자릿수를 보유합니다. 인덱스 1의 문자는 오른쪽 등에서 두 번째 그룹의 자릿수를 보유합니다. 반환 된 문자열의 마지막 문자가 나타내는 그룹화는 숫자의 왼쪽 부분에 남아있는 모든 자릿수를 그룹화하기 위해 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="377e30e67488234928e5265aef21fdf60f228f58" translate="yes" xml:space="preserve">
          <source>The guarantee that &lt;code&gt;std::from_chars&lt;/code&gt; can recover every floating-point value formatted by &lt;a href=&quot;to_chars&quot;&gt;&lt;code&gt;std::to_chars&lt;/code&gt;&lt;/a&gt; exactly is only provided if both functions are from the same implementation.</source>
          <target state="translated">있다는 보증 &lt;code&gt;std::from_chars&lt;/code&gt; 로 포맷 모든 부동 소수점 값을 복구 할 수 있습니다 &lt;a href=&quot;to_chars&quot;&gt; &lt;code&gt;std::to_chars&lt;/code&gt; &lt;/a&gt; 두 기능은 동일한 구현에서 경우 정확히에만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6a78268c72fa332949b19e97ea94c6bd065b9550" translate="yes" xml:space="preserve">
          <source>The guarantee that &lt;code&gt;std::from_chars&lt;/code&gt; can recover every floating-point value formatted by &lt;code&gt;to_chars&lt;/code&gt; exactly is only provided if both functions are from the same implementation.</source>
          <target state="translated">보증은 &lt;code&gt;std::from_chars&lt;/code&gt; 로 포맷 모든 부동 소수점 값을 복구 할 수 있습니다 &lt;code&gt;to_chars&lt;/code&gt; 두 기능은 동일한 구현에서 경우 정확히에만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bb6a61b9c44ca51fc2d67b8e734fd60e0f744ad5" translate="yes" xml:space="preserve">
          <source>The hash code of the associated &lt;code&gt;type_info&lt;/code&gt; object.</source>
          <target state="translated">연결된 &lt;code&gt;type_info&lt;/code&gt; 객체 의 해시 코드입니다 .</target>
        </trans-unit>
        <trans-unit id="b862a5e504b0376ea8c84c346ba305c970071424" translate="yes" xml:space="preserve">
          <source>The hash function.</source>
          <target state="translated">해시 함수.</target>
        </trans-unit>
        <trans-unit id="3937832fedbe42cd580633aa32952bacd6b0b437" translate="yes" xml:space="preserve">
          <source>The hash value that respects collation order.</source>
          <target state="translated">데이터 정렬 순서를 존중하는 해시 값입니다.</target>
        </trans-unit>
        <trans-unit id="e822b844b21e9499cc3d98cbf3f05f1abdf07e6d" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;../header/iterator&quot;&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;&lt;/a&gt; provides a set of concepts and related utility templates designed to ease constraining common algorithm operations.</source>
          <target state="translated">헤더 &lt;a href=&quot;../header/iterator&quot;&gt; &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 일반적인 알고리즘 작업을 쉽게 제한하도록 설계된 일련의 개념 및 관련 유틸리티 템플릿을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="32774d695cdea646f90e7d021305a854ad71bc9b" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;../header/typeinfo&quot;&gt;&amp;lt;typeinfo&amp;gt;&lt;/a&gt; must be included before using &lt;code&gt;typeid&lt;/code&gt; (if the header is not included, every use of the keyword &lt;code&gt;typeid&lt;/code&gt; makes the program ill-formed.).</source>
          <target state="translated">&lt;code&gt;typeid&lt;/code&gt; 를 사용하기 전에 &lt;a href=&quot;../header/typeinfo&quot;&gt;&amp;lt;typeinfo&amp;gt;&lt;/a&gt; 헤더를 포함해야합니다 (헤더가 포함되지 않은 경우 키워드 &lt;code&gt;typeid&lt;/code&gt; 를 사용할 때마다 프로그램이 잘못 작성됩니다).</target>
        </trans-unit>
        <trans-unit id="39e45883b37cb57381dea376201d7779a8f05664" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/bit&quot;&gt;&lt;code&gt;&amp;lt;bit&amp;gt;&lt;/code&gt;&lt;/a&gt; provides several function templates to access, manipulate, and process individual bits and bit sequences.</source>
          <target state="translated">헤더 &lt;a href=&quot;header/bit&quot;&gt; &lt;code&gt;&amp;lt;bit&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 개별 비트 및 비트 시퀀스를 액세스, 조작 및 처리하기위한 여러 기능 템플릿을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c204ad70977b9fc2b727eaecd4f753ba2d1dc617" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cfenv&quot;&gt;&lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt;&lt;/a&gt; defines &lt;a href=&quot;numeric/fenv&quot;&gt;flags and functions related to exceptional floating-point state&lt;/a&gt;, such as overflow and division by zero.</source>
          <target state="translated">&lt;a href=&quot;header/cfenv&quot;&gt; &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; &lt;/a&gt; 헤더 는 오버플로 및 0으로 나누기와 같은 &lt;a href=&quot;numeric/fenv&quot;&gt;예외적 인 부동 소수점 상태와 관련된 플래그 및 함수를&lt;/a&gt; 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="0cbc07e97f0d93b88b9c5ece9e00510e37bf2c6a" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cmath&quot;&gt;&lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt;&lt;/a&gt; also provides several mathematical special functions such as &lt;code&gt;&lt;a href=&quot;numeric/special_math/beta&quot;&gt;std::beta&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric/special_math/hermite&quot;&gt;std::hermite&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/special_math/cyl_bessel_i&quot;&gt;std::cyl_bessel_i&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">헤더 &lt;a href=&quot;header/cmath&quot;&gt; &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;&lt;a href=&quot;numeric/special_math/beta&quot;&gt;std::beta&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;numeric/special_math/hermite&quot;&gt;std::hermite&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;numeric/special_math/cyl_bessel_i&quot;&gt;std::cyl_bessel_i&lt;/a&gt;&lt;/code&gt; 와 같은 여러 수학 특수 함수도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5f4dd67444c139abdd3f7b0de3e2b42f5e337403" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cmath&quot;&gt;&lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt;&lt;/a&gt; provides &lt;a href=&quot;numeric/math&quot;&gt;standard C library mathematical functions&lt;/a&gt; such as &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;std::fabs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;header/cmath&quot;&gt; &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt; &lt;/a&gt; 헤더 는 &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;std::fabs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; 과 같은 &lt;a href=&quot;numeric/math&quot;&gt;표준 C 라이브러리 수학 함수를&lt;/a&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="743b06117d162324a98c31415f3c294f57b66ed9" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/iterator&quot;&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;&lt;/a&gt; provides a set of concepts and related utilities designed to ease constraining common algorithm operations.</source>
          <target state="translated">헤더 &lt;a href=&quot;header/iterator&quot;&gt; &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 일반적인 알고리즘 작업을 쉽게 제한하도록 설계된 일련의 개념 및 관련 유틸리티를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="508d20b6cea54c392d295d11726346c65aa4b0b3" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/numeric&quot;&gt;&lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt;&lt;/a&gt; provides numeric algorithms below:</source>
          <target state="translated">헤더 &lt;a href=&quot;header/numeric&quot;&gt; &lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 아래에 숫자 알고리즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ba440bf8e1f8c37da5221f67c871d6fb13769ff0" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/random&quot;&gt;&lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt;&lt;/a&gt; defines &lt;a href=&quot;numeric/random&quot;&gt;pseudo-random number generators and numerical distributions&lt;/a&gt;. The header &lt;a href=&quot;header/cstdlib&quot;&gt;&lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt;&lt;/a&gt; also includes C-style random number generation via &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;std::srand&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;header/random&quot;&gt; &lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt; &lt;/a&gt; 헤더 는 &lt;a href=&quot;numeric/random&quot;&gt;의사 난수 생성기와 숫자 분포를&lt;/a&gt; 정의합니다 . &lt;a href=&quot;header/cstdlib&quot;&gt; &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; &lt;/a&gt; 헤더 에는 &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;std::srand&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; 를 통한 C 스타일 난수 생성도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd8e217a3115bdf6060d0de317017567a06a41d7" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/ratio&quot;&gt;&lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt;&lt;/a&gt; provides &lt;a href=&quot;numeric/ratio&quot;&gt;types and functions for manipulating and storing compile-time ratios&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;header/ratio&quot;&gt; &lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt; &lt;/a&gt; 헤더 는 &lt;a href=&quot;numeric/ratio&quot;&gt;컴파일 타임 비율을 조작하고 저장하기위한 유형과 기능을&lt;/a&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="218920ec6c8d077db4c2f0630d45c58c68f68e0c" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/version&quot;&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/a&gt; supplies implementation-dependent information about the C++ standard library (such as the version number and release date. It also defines the &lt;a href=&quot;utility/feature_test&quot;&gt;library feature-test macros&lt;/a&gt;.</source>
          <target state="translated">헤더 &lt;a href=&quot;header/version&quot;&gt; &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; &lt;/a&gt; 은 C ++ 표준 라이브러리에 대한 구현 종속 정보 (예 : 버전 번호 및 릴리스 날짜)를 제공하며 &lt;a href=&quot;utility/feature_test&quot;&gt;라이브러리 기능 테스트 매크로&lt;/a&gt; 도 정의 합니다 .</target>
        </trans-unit>
        <trans-unit id="bf5126087a87a6889e7920c9e1157d0b23d15572" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;exception&amp;gt;&lt;/code&gt; provides several classes and functions related to exception handling in C++ programs.</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;exception&amp;gt;&lt;/code&gt; 은 C ++ 프로그램의 예외 처리와 관련된 여러 클래스와 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bc6caf28cb4847d14f957dc4f821e46a30b84457" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; behaves as if it defines (directly or indirectly) an instance of &lt;code&gt;std::ios_base::Init&lt;/code&gt; with static storage duration: this makes it safe to access the standard I/O streams in the constructors and destructors of static objects with &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;ordered initialization&lt;/a&gt; (as long as &lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt; is included in the translation unit before these objects were defined).</source>
          <target state="translated">&lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; 헤더 는 정적 저장 시간 으로 &lt;code&gt;std::ios_base::Init&lt;/code&gt; 인스턴스를 정의하는 것처럼 (직접 또는 간접적으로) 동작합니다 . 이렇게하면 정적 객체의 생성자와 소멸자에서 표준 I / O 스트림에 안전하게 액세스 할 수 있습니다 함께 &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;정렬 초기화&lt;/a&gt; (만큼 &lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt; 이러한 개체가 정의되기 전에 변환 부에 포함된다).</target>
        </trans-unit>
        <trans-unit id="fd4ecbc573accaaae87826b6f734bf136d186983" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt; defines types and functions used to report error conditions originating from the operating system, streams I/O, &lt;code&gt;&lt;a href=&quot;thread/future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, or other low-level APIs.</source>
          <target state="translated">&lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt; 헤더 는 운영 체제, 스트림 I / O, &lt;code&gt;&lt;a href=&quot;thread/future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 또는 기타 저수준 API 에서 발생하는 오류 조건을보고하는 데 사용되는 유형과 함수를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="57e8428ad704374a45b4d8a73edeba81162f1a2e" translate="yes" xml:space="preserve">
          <source>The headers &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt; are meaningless in C++ because the macros they provide in C are language keywords in C++.</source>
          <target state="translated">C에서 제공하는 매크로는 C ++의 언어 키워드이기 때문에 헤더 &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt; 은 C ++에서 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e08bc9e99ec8f39019e1085b8cf1191154179ba" translate="yes" xml:space="preserve">
          <source>The headers &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt; do not contain any content from the C standard library and instead merely include other headers from the C++ standard library. The use of all these headers is deprecated in C++.</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; , 그리고 &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt; 은 C 표준 라이브러리의 모든 콘텐츠를 포함하는 대신 단지 C ++ 표준 라이브러리에서 다른 헤더를 포함하지 않는다. 이 모든 헤더의 사용은 C ++에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d743155eef03d9de2f708dc85802d31a16ee771" translate="yes" xml:space="preserve">
          <source>The hexadecimal floating-point literals were not part of C++ until C++17, although they can be parsed and printed by the I/O functions since C++11: both C++ I/O streams when &lt;code&gt;&lt;a href=&quot;../io/manip/fixed&quot;&gt;std::hexfloat&lt;/a&gt;&lt;/code&gt; is enabled and the C I/O streams: &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/c/fscanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt;, etc. See &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; for the format description.</source>
          <target state="translated">16 진 부동 소수점 리터럴은 C ++ 11 이후 I / O 함수에 의해 구문 분석되고 인쇄 될 수 있지만 C ++ 17까지는 C ++의 일부가 아닙니다. &lt;code&gt;&lt;a href=&quot;../io/manip/fixed&quot;&gt;std::hexfloat&lt;/a&gt;&lt;/code&gt; 가 활성화 된 경우 C ++ I / O 스트림 모두 CI / O 스트림 : &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/c/fscanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; 등 . 형식 설명 은 &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2bcfe16e4a34071ba0fe16d4ac0cbe3af5aafda3" translate="yes" xml:space="preserve">
          <source>The hinted insert (3,4) does not return a boolean in order to be signature-compatible with positional insert on sequential containers, such as &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;. This makes it possible to create generic inserters such as &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt;. One way to check success of a hinted insert is to compare &lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt; before and after.</source>
          <target state="translated">힌트 삽입 (3,4)은 &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; 와 같은 순차적 컨테이너의 위치 삽입과 서명 호환 가능하도록 부울을 반환하지 않습니다 . 이를 통해 &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt; 와 같은 일반 삽입기를 작성할 수 있습니다 . 힌트 인서트의 성공 여부를 확인하는 한 가지 방법은 전후에 &lt;a href=&quot;size&quot;&gt;size ()&lt;/a&gt; 를 비교하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="25af4f74a579fcba3c500fb626cf10f9c5227e2b" translate="yes" xml:space="preserve">
          <source>The hinted insert (4-6) does not return a boolean in order to be signature-compatible with positional insert on sequential containers, such as &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;. This makes it possible to create generic inserters such as &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt;. One way to check success of a hinted insert is to compare &lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt; before and after.</source>
          <target state="translated">힌트 삽입 (4-6)은 &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; 와 같은 순차 컨테이너의 위치 삽입과 서명 호환 가능하도록 부울을 리턴하지 않습니다 . 이를 통해 &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt; 와 같은 일반 삽입기를 작성할 수 있습니다 . 힌트 인서트의 성공 여부를 확인하는 한 가지 방법은 전후에 &lt;a href=&quot;size&quot;&gt;size ()&lt;/a&gt; 를 비교하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="60466cfba360b12a497fdcbd2421cdfcee028890" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;override&lt;/code&gt;, if used, appears immediately after the &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; in the syntax of a member function declaration or a member function definition inside a class definition.</source>
          <target state="translated">식별자 &lt;code&gt;override&lt;/code&gt; 는 사용되는 경우 멤버 함수 선언의 구문 또는 클래스 정의 내의 멤버 함수 정의 에서 &lt;a href=&quot;function&quot;&gt;선언자&lt;/a&gt; 바로 뒤에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="855cd3f29b0c4d0647de6b78163ac3dde4862c47" translate="yes" xml:space="preserve">
          <source>The identifier in any capture without an initializer (other than the &lt;code&gt;this&lt;/code&gt;-capture) is looked up using usual &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt; in the</source>
          <target state="translated">이니셜 라이저가없는 캡처 ( &lt;code&gt;this&lt;/code&gt; -capture 이외) 의 식별자는 일반적인 &lt;a href=&quot;lookup&quot;&gt;정규화되지 않은 이름 조회&lt;/a&gt; 를 사용하여 조회 됩니다.</target>
        </trans-unit>
        <trans-unit id="e9e7a102d6df5884074f2499d6bb5f69817edee5" translate="yes" xml:space="preserve">
          <source>The identifier then becomes the name of an lvalue that refers to the object bound to said variable.</source>
          <target state="translated">그러면 식별자는 변수에 바인딩 된 객체를 나타내는 lvalue의 이름이됩니다.</target>
        </trans-unit>
        <trans-unit id="822a7edda6406f5fc42188900a3b551e64031aa7" translate="yes" xml:space="preserve">
          <source>The immediate input function &lt;a href=&quot;../basic_istream/readsome&quot;&gt;&lt;code&gt;basic_istream::readsome&lt;/code&gt;&lt;/a&gt;, if &lt;a href=&quot;../basic_streambuf/in_avail&quot;&gt;&lt;code&gt;basic_streambuf::in_avail&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;-1&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;../basic_streambuf/in_avail&quot;&gt; &lt;code&gt;basic_streambuf::in_avail&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;-1&lt;/code&gt; 을 리턴하는 경우 즉시 입력 함수 &lt;a href=&quot;../basic_istream/readsome&quot;&gt; &lt;code&gt;basic_istream::readsome&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc1a01ff9f1f5abac042b758d317c3db71ae72ed" translate="yes" xml:space="preserve">
          <source>The implementation is guaranteed to support the registration of at least &lt;code&gt;32&lt;/code&gt; functions. The exact limit is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d765572265bbb1c2ba3ca90d43753fb5f543201a" translate="yes" xml:space="preserve">
          <source>The implementation is required to ensure that the</source>
          <target state="translated">구현은</target>
        </trans-unit>
        <trans-unit id="f14c981912c9ec5ad33b5a6c478bfe2e9cbdf180" translate="yes" xml:space="preserve">
          <source>The implementation may define additional macro constants in &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; to identify additional floating-point exceptions. All such constants begin with &lt;code&gt;FE_&lt;/code&gt; followed by at least one uppercase letter.</source>
          <target state="translated">구현은 추가 부동 소수점 예외를 식별하기 위해 &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; 에서 추가 매크로 상수를 정의 할 수 있습니다 . 이러한 모든 상수는 &lt;code&gt;FE_&lt;/code&gt; 로 시작하고 그 뒤에 하나 이상의 대문자가옵니다.</target>
        </trans-unit>
        <trans-unit id="22e5ff471a91c192911b7ddaa27337e54bd023f9" translate="yes" xml:space="preserve">
          <source>The implementation may extend the behavior of the first overload of &lt;code&gt;std::async&lt;/code&gt; by enabling additional (implementation-defined) bits in the default launch policy.</source>
          <target state="translated">구현 시 기본 시작 정책에서 추가 (구현 정의) 비트를 활성화하여 &lt;code&gt;std::async&lt;/code&gt; 의 첫 번째 과부하 동작을 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66f2e43503845c9ed791a5293976886ce8971522" translate="yes" xml:space="preserve">
          <source>The implementation may meet the requirements without creating a temporary &lt;code&gt;shared_ptr&lt;/code&gt; object.</source>
          <target state="translated">구현은 임시 &lt;code&gt;shared_ptr&lt;/code&gt; 객체를 만들지 않고도 요구 사항을 충족 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64697b003de59849a6866340318f593ae74fc065" translate="yes" xml:space="preserve">
          <source>The implementation may meet the requirements without creating a temporary &lt;code&gt;weak_ptr&lt;/code&gt; object.</source>
          <target state="translated">구현은 임시 &lt;code&gt;weak_ptr&lt;/code&gt; 객체를 만들지 않고도 요구 사항을 충족 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b237d3793f32597e507f67af416d68948b4ad9d" translate="yes" xml:space="preserve">
          <source>The implementation may support other date formats besides the ones required by the standard.</source>
          <target state="translated">구현은 표준에 필요한 것 이외의 다른 날짜 형식을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12a35a278ea92405afc482e169257edd666c8c44" translate="yes" xml:space="preserve">
          <source>The implementation shall provide sufficient additional &lt;code&gt;constexpr&lt;/code&gt; and &lt;code&gt;noexcept&lt;/code&gt; overloads of these functions so that a &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; object &lt;code&gt;sv&lt;/code&gt; may be compared to another object &lt;code&gt;t&lt;/code&gt; with an implicit conversion to &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt;, with semantics identical to comparing &lt;code&gt;sv&lt;/code&gt; and &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;(t)&lt;/code&gt;.</source>
          <target state="translated">구현은 충분한 추가 제공한다 &lt;code&gt;constexpr&lt;/code&gt; 및 &lt;code&gt;noexcept&lt;/code&gt; 있도록 이러한 함수의 과부하를 &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; 객체 &lt;code&gt;sv&lt;/code&gt; 다른 객체와 비교할 수있다 &lt;code&gt;t&lt;/code&gt; 까지 암시 적 변환에 &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; , 비교 동일한 의미와 &lt;code&gt;sv&lt;/code&gt; 과 &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;(t)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8fa4c86d6d639e7f910fb3c11363bc126fb0186" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; before the call and throw a &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; with an error condition of &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구현은 호출 전에 &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 일 경우를 감지하고 오류 조건 &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; 와 함께 std :: future_error 를 throw하는 것이 &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ef09408705d9954ea1018c6860f6e1b66768503" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;valid == false&lt;/code&gt; before the call and throw a &lt;a href=&quot;../future_error&quot;&gt;&lt;code&gt;future_error&lt;/code&gt;&lt;/a&gt; with an error condition of &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_errc::no_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현은 호출 전에 &lt;code&gt;valid == false&lt;/code&gt; 때 케이스를 감지하고 &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_errc::no_state&lt;/code&gt; &lt;/a&gt; 오류 조건으로 future_error를 발생 시키는 &lt;a href=&quot;../future_error&quot;&gt; &lt;code&gt;future_error&lt;/code&gt; &lt;/a&gt;좋습니다 .</target>
        </trans-unit>
        <trans-unit id="46992c68e68dfb44f3f1d1f0f1a081b8b330576b" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;valid == false&lt;/code&gt; before the call and throw a &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; with an error condition of &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구현은 호출 전에 &lt;code&gt;valid == false&lt;/code&gt; 때 사례를 감지하고 &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; 오류 조건으로 &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt; 발생 시키는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="30a185593e3d55839d1d436fbf8fa472dc5d96a9" translate="yes" xml:space="preserve">
          <source>The implementations in &lt;a href=&quot;http://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;libc++&lt;/a&gt; and &lt;a href=&quot;http://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;libstdc++&lt;/a&gt; expect &lt;code&gt;token&lt;/code&gt; to be the name of a character device that produces random numbers when read from, with the default value &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt;, although where the CPU instruction RDRND is available, libstdc++ uses that as the default.</source>
          <target state="translated">&lt;a href=&quot;http://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;libc ++&lt;/a&gt; 및 &lt;a href=&quot;http://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;libstdc ++&lt;/a&gt; 의 구현에서는 &lt;code&gt;token&lt;/code&gt; 을 읽을 때 기본값이 &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt; 인 임의의 숫자를 생성하는 문자 장치의 이름이 될 것으로 예상 하지만 CPU 명령어 RDRND가 사용 가능한 경우 libstdc ++는이를 기본값으로 사용합니다. .</target>
        </trans-unit>
        <trans-unit id="1e1bd066a7f11748e7bb0264fc2e8c480f468bd7" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) copy assignment operator has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">암시 적으로 선언 된 (또는 첫 번째 선언에서 기본값으로 지정된) 복사 할당 연산자에는 &lt;a href=&quot;except_spec&quot;&gt;동적 예외 사양&lt;/a&gt; (C ++ 17까지) &lt;a href=&quot;noexcept_spec&quot;&gt;예외 사양&lt;/a&gt; (C ++ 17부터 )에 설명 된대로 예외 사양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="94f03f3d0e083d8f05c0d3d27ca9e6043e7f1447" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) copy constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">암시 적으로 선언 된 (또는 첫 번째 선언에서 기본값으로 지정된) 복사 생성자는 &lt;a href=&quot;except_spec&quot;&gt;동적 예외 사양&lt;/a&gt; (C ++ 17까지) &lt;a href=&quot;noexcept_spec&quot;&gt;예외 사양&lt;/a&gt; (C ++ 17부터 )에 설명 된대로 예외 사양을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="c3a2dc4c3c835b9d7e3746bb1d579e66f0b3d256" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) default constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">암시 적으로 선언 된 (또는 첫 번째 선언에서 기본값으로 지정된) 기본 생성자는 &lt;a href=&quot;except_spec&quot;&gt;동적 예외 사양&lt;/a&gt; (C ++ 17까지) &lt;a href=&quot;noexcept_spec&quot;&gt;예외 사양&lt;/a&gt; (C ++ 17부터 )에 설명 된대로 예외 사양을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="ad35568398ddbdf1c5594f6799a40acc879779b5" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) move assignment operator has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">암시 적으로 선언 된 (또는 첫 번째 선언에서 기본값으로 설정 됨) 이동 할당 연산자에는 &lt;a href=&quot;except_spec&quot;&gt;동적 예외 사양&lt;/a&gt; (C ++ 17까지) &lt;a href=&quot;noexcept_spec&quot;&gt;예외 사양&lt;/a&gt; (C ++ 17부터 )에 설명 된대로 예외 사양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3deae4df87e12fce8a01835c91a2ac9242a339b1" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) move constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">암시 적으로 선언 된 (또는 첫 번째 선언에서 기본값으로 설정 됨) 이동 생성자는 &lt;a href=&quot;except_spec&quot;&gt;동적 예외 사양&lt;/a&gt; (C ++ 17까지) &lt;a href=&quot;noexcept_spec&quot;&gt;예외 사양&lt;/a&gt; (C ++ 17부터 )에 설명 된대로 예외 사양을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="3213a8544ac4c22b0682928a2ce16724be0fb301" translate="yes" xml:space="preserve">
          <source>The implicitly-declared copy constructor for class &lt;code&gt;T&lt;/code&gt; is undefined if any of the following conditions are true:</source>
          <target state="translated">다음 조건 중 하나라도 해당되면 클래스 &lt;code&gt;T&lt;/code&gt; 에 대한 암시 적으로 선언 된 복사 생성자 가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6fae264774979621faa26711431abb58dbca09db" translate="yes" xml:space="preserve">
          <source>The implicitly-declared destructor is virtual (because the base class has a virtual destructor) and the lookup for the deallocation function (&lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;()&lt;/code&gt; results in a call to ambiguous, deleted, or inaccessible function.</source>
          <target state="translated">암시 적으로 선언 된 소멸자는 가상 (기본 클래스에는 가상 소멸자가 있기 때문에)이며 할당 해제 기능 ( &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;()&lt;/code&gt; 하면 모호하거나 삭제되거나 액세스 할 수없는 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="50ffc691488ff90f9bb81089da927863779b099a" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted copy constructor for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08afe67b1a14690a725702d4c692f1dc10c64e2f" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted default constructor for class &lt;code&gt;T&lt;/code&gt; is  undefined (until C++11)defined as deleted(since C++11) if any of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cafdb084858cf182d0ce28289e802bf9e83822" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted destructor for class &lt;code&gt;T&lt;/code&gt; is  undefined (until C++11)defined as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b5ed6dfa8b272f8c00f443dfeac236e2515204" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted move assignment operator for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce2934ef2171aeb2c0ad6a343b987738915dab2" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted move constructor for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad92a1e56a9451101a860f2143c244760ecd26c4" translate="yes" xml:space="preserve">
          <source>The implicitly-defined special member functions are typically incorrect if the class is managing a resource whose handle is an object of non-class type (raw pointer, POSIX file descriptor, etc), whose destructor does nothing and copy constructor/assignment operator performs a &quot;shallow copy&quot; (copy the value of the handle, without duplicating the underlying resource).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192f6f2391fc950f581ebc15e6c0166986a4e41a" translate="yes" xml:space="preserve">
          <source>The implicitly-generated member functions and any member function declared as defaulted on its first declaration are inline just like any other function defined inside a class definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43d2eaebfe91ea20d3c9ee4934fb21de74d02b4" translate="yes" xml:space="preserve">
          <source>The implied &lt;code&gt;lk.unlock&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34929ac211f53c3511c4b293c3b116cd7ed0a254" translate="yes" xml:space="preserve">
          <source>The index stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
