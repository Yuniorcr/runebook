<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="8b3f01687d89feac7cfe2128cd7fb4336c3f52ee" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;(y*&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(x))&lt;/code&gt;.</source>
          <target state="translated">작업이 &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;(y*&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(x))&lt;/code&gt; 의해 구현 된 것처럼 오류 및 특수 사례가 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="d8eceb47949f152b23fef3272be167f4940d38aa" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;cosh&quot;&gt;std::cosh&lt;/a&gt;(i*z)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the imaginary unit.</source>
          <target state="translated">오류와 특수한 경우는 &lt;code&gt;&lt;a href=&quot;cosh&quot;&gt;std::cosh&lt;/a&gt;(i*z)&lt;/code&gt; 의해 작업이 구현되는 것처럼 처리됩니다 . 여기서 &lt;code&gt;i&lt;/code&gt; 는 허수 단위입니다.</target>
        </trans-unit>
        <trans-unit id="2ab0e556309413233a2f6554e50dca392be2f614" translate="yes" xml:space="preserve">
          <source>Errors are reported as specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 에 지정된대로 오류가보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="7331ffbc406cc972b5f70c046e3dc2cb4171b6f9" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0e29a499e18c343b1b41bf866f5a04007120ed" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 과 일치하는 오류가보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="5864985afc7c53fae220dc47110ea05595ec5f47" translate="yes" xml:space="preserve">
          <source>Errors may be reported as specified in &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling에&lt;/a&gt; 지정된대로 오류가보고 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee99754a522541dd514fb00437ecaa5173a3680b" translate="yes" xml:space="preserve">
          <source>Errors that arise during exception handling are handled by &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;(until C++17).</source>
          <target state="translated">예외 처리 중 발생하는 오류는 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; (C ++ 17까지)에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd56cff3676fe902e346c447da9fdfeeaa8307a3" translate="yes" xml:space="preserve">
          <source>Escape sequences are used to represent certain special characters within &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; and &lt;a href=&quot;character_literal&quot;&gt;character literals&lt;/a&gt;.</source>
          <target state="translated">이스케이프 시퀀스는 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 및 &lt;a href=&quot;character_literal&quot;&gt;문자 리터럴&lt;/a&gt; 내의 특정 특수 문자를 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f742a88872219830426d31bbcd98064272e610fb" translate="yes" xml:space="preserve">
          <source>Essentially, &lt;code&gt;E1&lt;/code&gt; is evaluated and discarded in both cases; 2) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;data_members&quot;&gt;non-static data member&lt;/a&gt;:</source>
          <target state="translated">본질적으로 &lt;code&gt;E1&lt;/code&gt; 은 두 경우 모두 평가되고 폐기됩니다. 2) &lt;code&gt;E2&lt;/code&gt; 가 &lt;a href=&quot;data_members&quot;&gt;비 정적 데이터 멤버 인 경우&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cff4774a9f4e9cd8077ee08295f533dd38074331" translate="yes" xml:space="preserve">
          <source>Establishes &lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_weak_ordering&quot;&gt;strict weak ordering&lt;/a&gt; relation with the following properties</source>
          <target state="translated">설립 &lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_weak_ordering&quot;&gt;엄격한 약한 주문&lt;/a&gt; 다음과 같은 특성을 가진 관계를</target>
        </trans-unit>
        <trans-unit id="852a89d52bfbfe13219c2f99e5bebf530d7e1264" translate="yes" xml:space="preserve">
          <source>Establishes &lt;a href=&quot;memory_order&quot;&gt;memory synchronization ordering&lt;/a&gt; of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, without an associated atomic operation.</source>
          <target state="translated">원자 단위 조작없이 &lt;code&gt;order&lt;/code&gt; 에 의해 지시 된 대로 원자 적이 지 않고 완화 된 원자 액세스의 &lt;a href=&quot;memory_order&quot;&gt;메모리 동기화 순서&lt;/a&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="f3f364090d806d3b0cee66b4e00edd9582f9bb6b" translate="yes" xml:space="preserve">
          <source>Establishes an &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;, that is, it satisfies the following properties:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;동등성 관계를&lt;/a&gt; 설정합니다 . 즉, 다음 특성을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="8d058e497d38c36626918d3f0a58443807999d35" translate="yes" xml:space="preserve">
          <source>Establishes an equivalence relation. Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x.param() == y.param()&lt;/code&gt; and future infinite sequences of values that would be generated by repeated invocations of &lt;code&gt;x(g1)&lt;/code&gt; and &lt;code&gt;y(g2)&lt;/code&gt; would be equal as long as &lt;code&gt;g1 == g2&lt;/code&gt;.</source>
          <target state="translated">동등성 관계를 설정합니다. 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;x.param() == y.param()&lt;/code&gt; 와 반복적으로 호출함으로써 생성 될 값들의 미래 무한 시퀀스 &lt;code&gt;x(g1)&lt;/code&gt; 와 &lt;code&gt;y(g2)&lt;/code&gt; 동일한 것으로 한 것 &lt;code&gt;g1 == g2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="224e99f2262d85ee9bdcb40ff75322e28286d665" translate="yes" xml:space="preserve">
          <source>Establishes an exception handler around the body of a function.</source>
          <target state="translated">함수 본문 주위에 예외 처리기를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2c8128bfda4d0efc1187706eb75c4af98c699f3e" translate="yes" xml:space="preserve">
          <source>Establishes equivalence relationship with the following properties</source>
          <target state="translated">다음과 같은 속성과 동등한 관계를 설정합니다</target>
        </trans-unit>
        <trans-unit id="a0a813deb9e43ef1c13a8996290d00b720e38940" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, between a thread and a signal handler executed on the same thread. This is equivalent to &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt;, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as &lt;code&gt;order&lt;/code&gt; instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.</source>
          <target state="translated">스레드와 동일한 스레드에서 실행되는 신호 처리기 사이 에 &lt;code&gt;order&lt;/code&gt; 에 지시 된 대로 원자 적이 지 않고 완화 된 원자 액세스의 메모리 동기화 순서를 설정합니다. 이것은 메모리 순서에 대한 CPU 명령어가 발행되지 않는다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; 와 같습니다 . 만 컴파일러에 의해 지시의 재정렬이 억제되는 &lt;code&gt;order&lt;/code&gt; 에 지시합니다. 예를 들어 릴리스 의미 체계가있는 펜스는 읽기 또는 쓰기가 후속 쓰기를 지나서 이동하는 것을 방지하고 획득 의미 체계가있는 펜스는 읽기 또는 쓰기가 이전 읽기보다 먼저 이동하는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="557e271e8a3a0cf9ee786e9ab59e8bf077dde9c7" translate="yes" xml:space="preserve">
          <source>Estimates the number of characters available for input in the associated character sequence. &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; is guaranteed not to return &lt;code&gt;Traits::eof()&lt;/code&gt; or throw an exception until at least that many characters are extracted.</source>
          <target state="translated">연관된 문자 순서로 입력 할 수있는 문자 수를 추정합니다. &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 는 최소한 많은 문자가 추출 될 때까지 &lt;code&gt;Traits::eof()&lt;/code&gt; 를 반환하지 않거나 예외를 발생 시키지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5ad645d0b6cf4e8f2f0f5a5463bf7ca6f9950d22" translate="yes" xml:space="preserve">
          <source>Euclidean norm</source>
          <target state="translated">유클리드 표준</target>
        </trans-unit>
        <trans-unit id="da7594d31984baf99a077013f0aee618827920d2" translate="yes" xml:space="preserve">
          <source>Evaluation order and sequencing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b2d28039057e6a76561c58410eb4f016c0728f" translate="yes" xml:space="preserve">
          <source>Even before allocator support was removed from &lt;code&gt;std::function&lt;/code&gt; in C++17, these assignment operators use the default allocator rather than the allocator of &lt;code&gt;*this&lt;/code&gt; or the allocator of &lt;code&gt;other&lt;/code&gt; (see &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-closed.html#2386&quot;&gt;LWG #2386&lt;/a&gt;).</source>
          <target state="translated">C ++ 17 에서 할당 자 지원이 &lt;code&gt;std::function&lt;/code&gt; 에서 제거되기 전에도 이러한 할당 연산자는 &lt;code&gt;*this&lt;/code&gt; 의 할당 자 또는 &lt;code&gt;other&lt;/code&gt; 할당 자 ( &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-closed.html#2386&quot;&gt;LWG # 2386&lt;/a&gt; 참조) 대신 기본 할당자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5bf28a5cb25e295e74fa193c881e4823ae53ebb2" translate="yes" xml:space="preserve">
          <source>Even if &lt;code&gt;ymd.ok()&lt;/code&gt; is true, the resulting &lt;code&gt;year_month_day&lt;/code&gt; may not represent a valid date if &lt;code&gt;ymd.day()&lt;/code&gt; is 29, 30, or 31.</source>
          <target state="translated">하더라도 &lt;code&gt;ymd.ok()&lt;/code&gt; true 인, 얻어진 &lt;code&gt;year_month_day&lt;/code&gt; 이 경우 유효한 날짜를 표현하지 않을 수도 &lt;code&gt;ymd.day()&lt;/code&gt; 29, 30 또는 31이다.</target>
        </trans-unit>
        <trans-unit id="13f714ec21c59f4555ffdd439f65ba1de4339a70" translate="yes" xml:space="preserve">
          <source>Even if &lt;code&gt;ymwd.ok()&lt;/code&gt; is true, the resulting &lt;code&gt;year_month_weekday&lt;/code&gt; may not represent a valid date if &lt;code&gt;ymwd.index()&lt;/code&gt; is 5.</source>
          <target state="translated">하더라도 &lt;code&gt;ymwd.ok()&lt;/code&gt; 사실, 결과 &lt;code&gt;year_month_weekday&lt;/code&gt; 이 경우 유효한 날짜를 표현하지 않을 수 있습니다 &lt;code&gt;ymwd.index()&lt;/code&gt; 5입니다.</target>
        </trans-unit>
        <trans-unit id="d9c13458a40bd815f989f602ad0395796fb458d9" translate="yes" xml:space="preserve">
          <source>Even if notified under lock, overload (1) makes no guarantees about the state of the associated predicate when returning due to timeout.</source>
          <target state="translated">잠금 상태에서 통지 되더라도 과부하 (1)는 시간 종료로 인해 리턴 할 때 연관된 술어의 상태에 대해 보증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8a756d7fa529afd7aeb13d1511bd134a3d2cc0c" translate="yes" xml:space="preserve">
          <source>Even if the clock in use is &lt;code&gt;&lt;a href=&quot;../../chrono/steady_clock&quot;&gt;std::chrono::steady_clock&lt;/a&gt;&lt;/code&gt; or another monotonic clock, a system clock adjustment may induce a spurious wakeup.</source>
          <target state="translated">사용중인 클럭이 &lt;code&gt;&lt;a href=&quot;../../chrono/steady_clock&quot;&gt;std::chrono::steady_clock&lt;/a&gt;&lt;/code&gt; 또는 다른 단조로운 클럭 인 경우에도 시스템 클럭 조정으로 인해 가짜 웨이크 업이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30fbd007da85ebd7312535e0cc529833d2a4d4fe" translate="yes" xml:space="preserve">
          <source>Even if the name to the left of &lt;code&gt;::&lt;/code&gt; refers to a namespace, the template disambiguator is allowed:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 왼쪽의 이름 이 네임 스페이스를 참조하더라도 템플릿 명확화 프로그램이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="82ac5cb6cfab85d924b4733697e77158a0419204" translate="yes" xml:space="preserve">
          <source>Even if the shared variable is atomic, it must be modified under the mutex in order to correctly publish the modification to the waiting thread.</source>
          <target state="translated">공유 변수가 원자적인 경우에도 수정을 대기 스레드에 올바르게 게시하려면 뮤텍스 아래에서 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d9633b8291e518788e5b04c3307f8044e23b7cb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;%c&lt;/code&gt; expects &lt;code&gt;int&lt;/code&gt; argument, it is safe to pass a &lt;code&gt;char&lt;/code&gt; because of the integer promotion that takes place when a variadic function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef899288103457cb2c6536cbb280b5cca3eb991" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;if&lt;/code&gt; is a &lt;a href=&quot;../../keywords/if&quot;&gt;keyword&lt;/a&gt; in C++, it is a ud-suffix of the &lt;a href=&quot;../../language/user_literal&quot;&gt;literal operator&lt;/a&gt; of the form &lt;code&gt;operator &quot;&quot;if&lt;/code&gt; and in the literal expressions such as &lt;code&gt;1if&lt;/code&gt; or &lt;code&gt;1.0if&lt;/code&gt; because it is not separated by whitespace and is not a standalone token.</source>
          <target state="translated">비록 &lt;code&gt;if&lt;/code&gt; A는 &lt;a href=&quot;../../keywords/if&quot;&gt;키워드&lt;/a&gt; C ++에서, 상기의 UD-접미사 &lt;a href=&quot;../../language/user_literal&quot;&gt;문자 연산자&lt;/a&gt; 형식의 &lt;code&gt;operator &quot;&quot;if&lt;/code&gt; 와 같은 문자 표현에 &lt;code&gt;1if&lt;/code&gt; 또는 &lt;code&gt;1.0if&lt;/code&gt; 가 공백으로 분리되지 않기 때문에 그리고 독립형 토큰 아니다 .</target>
        </trans-unit>
        <trans-unit id="205833ef6be0b707c638302ab3b276a23d851ced" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;try&lt;/code&gt; blocks are allowed in constexpr functions, throwing exceptions is still disallowed in a constant expression.</source>
          <target state="translated">constexpr 함수에서 &lt;code&gt;try&lt;/code&gt; 블록을 사용할 수 있지만 상수 표현식에서는 예외를 던지는 것이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="beca8aa735200901df75e963c1c548f38fd8410f" translate="yes" xml:space="preserve">
          <source>Even though destructors are not inherited, if a base class declares its destructor &lt;code&gt;virtual&lt;/code&gt;, the derived destructor always overrides it. This makes it possible to delete dynamically allocated objects of polymorphic type through pointers to base.</source>
          <target state="translated">소멸자가 상속되지 않더라도 기본 클래스가 소멸자를 &lt;code&gt;virtual&lt;/code&gt; 으로 선언 하면 파생 소멸자가 항상이를 소멸합니다. 이를 통해 base에 대한 포인터를 통해 다형성 유형의 동적으로 할당 된 객체를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd583cbe0ab59fe4a28f57f7cb504c86fd58cbce" translate="yes" xml:space="preserve">
          <source>Even though names in an unnamed namespace may be declared with external linkage, they are never accessible from other translation units because their namespace name is unique.</source>
          <target state="translated">명명되지 않은 네임 스페이스의 이름은 외부 연결로 선언 될 수 있지만 네임 스페이스 이름이 고유하기 때문에 다른 번역 단위에서 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="89f989b918b3efa1509410878202d64feeaad6c7" translate="yes" xml:space="preserve">
          <source>Even though the non-allocating placement new (9,10) cannot be replaced, a function with the same signature may be defined at class scope as described above. In addition, global overloads that look like placement new but take a non-void pointer type as the second argument are allowed, so the code that wants to ensure that the true placement new is called (e.g. &lt;code&gt;&lt;a href=&quot;../allocator/construct&quot;&gt;std::allocator::construct&lt;/a&gt;&lt;/code&gt;), must use &lt;code&gt;::new&lt;/code&gt; and also cast the pointer to &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">비 할당 배치 새 (9,10)를 대체 할 수 없더라도 동일한 서명을 가진 함수는 위에서 설명한 클래스 범위에서 정의 될 수 있습니다. 또한 새로운 게재 위치처럼 보이지만 두 번째 인수로 무효가 아닌 포인터 유형을 사용하는 전역 과부하가 발생하므로 실제 새로운 게재 위치가 호출되도록하는 코드 (예 : &lt;code&gt;&lt;a href=&quot;../allocator/construct&quot;&gt;std::allocator::construct&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;::new&lt;/code&gt; 를 사용해야 하며 포인터를 &lt;code&gt;void*&lt;/code&gt; 캐스팅 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f76a45b89412fbbe4ac41ff04a11f89153e89cd3" translate="yes" xml:space="preserve">
          <source>Even though top-level &lt;a href=&quot;cv&quot;&gt;cv-qualifiers&lt;/a&gt; on the parameters are discarded in function declarations, they modify the type of the parameter as visible in the body of a function:</source>
          <target state="translated">매개 변수의 최상위 &lt;a href=&quot;cv&quot;&gt;cv 한정자&lt;/a&gt; 는 함수 선언에서 삭제되지만 함수 본문에 표시되는 매개 변수 유형을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="a45dfe469d18cb059aef8c5b79aaf3c568df5677" translate="yes" xml:space="preserve">
          <source>Even when the destructor is called directly (e.g. &lt;code&gt;obj.~Foo();&lt;/code&gt;), the return statement in &lt;code&gt;~Foo()&lt;/code&gt; does not return control to the caller immediately: it calls all those member and base destructors first.</source>
          <target state="translated">(예를 들어 소멸자가 직접 호출하는 경우에도 &lt;code&gt;obj.~Foo();&lt;/code&gt; )에서 return 문 &lt;code&gt;~Foo()&lt;/code&gt; 즉시 호출자에게 컨트롤을 반환하지 않습니다 먼저 모든 멤버와 기본 소멸자를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c457cc0cca53f5efaec11bdae6464c7a8f3d1683" translate="yes" xml:space="preserve">
          <source>Even with relaxed memory model, out-of-thin-air values are not allowed to circularly depend on their own computations, for example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="translated">완화 된 메모리 모델을 사용하더라도 얇은 외공 (out-of-thin-air) 값은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 처음에 0 인 경우와 같이 자체 계산에 순환 적으로 의존하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0d294028b66fc033fb8f8b33345165f1b149cdc7" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;objects&quot;&gt;object&lt;/a&gt; and &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; has a</source>
          <target state="translated">모든 &lt;a href=&quot;objects&quot;&gt;객체&lt;/a&gt; 와 &lt;a href=&quot;reference&quot;&gt;참조&lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="1e3d5eff0d465c69879e0e0871021f12c2fae6c2" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; is parametrized by one or more template parameters, indicated in the parameter-list of the template declaration syntax:</source>
          <target state="translated">모든 &lt;a href=&quot;templates&quot;&gt;템플릿&lt;/a&gt; 은 템플릿 선언 구문의 파라미터 목록에 표시된 하나 이상의 템플릿 파라미터로 매개 변수화됩니다.</target>
        </trans-unit>
        <trans-unit id="9a47d9aa16911998ba8cb56b9196661886621057" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt; has the property called</source>
          <target state="translated">모든 &lt;a href=&quot;type-id&quot;&gt;객체 유형&lt;/a&gt; 에는</target>
        </trans-unit>
        <trans-unit id="d4c1d197b0b4ce5bf0d47347c3c212d7928dae9a" translate="yes" xml:space="preserve">
          <source>Every call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; freezes the stream to preserve the validity of the pointer it returns. To allow the destructor to deallocate the buffer, &lt;code&gt;freeze(false)&lt;/code&gt; needs to be called explicitly.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 호출 할 때마다 스트림이 정지되어 리턴하는 포인터의 유효성이 유지됩니다. 소멸자가 버퍼를 할당 해제하려면 &lt;code&gt;freeze(false)&lt;/code&gt; 를 명시 적으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="267f5eca029a0473ad86866143a283d6e67dc0cd" translate="yes" xml:space="preserve">
          <source>Every catch-clause in the function-try-block for a constructor must terminate by throwing an exception. If the control reaches the end of such handler, the current exception is automatically rethrown as if by &lt;code&gt;throw;&lt;/code&gt;. The return statement is not allowed in any catch clause of a constructor's function-try-block.</source>
          <target state="translated">생성자에 대한 function-try-block의 모든 catch-clause는 예외를 발생시켜 종료해야합니다. 컨트롤이 이러한 처리기의 끝에 도달하면 throw와 마찬가지로 현재 예외가 자동으로 다시 발생합니다 &lt;code&gt;throw;&lt;/code&gt; . 생성자의 function-try-block의 catch 절에는 return 문이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40c918ca9b8fb74eddbf2e3635eb193312898d9a" translate="yes" xml:space="preserve">
          <source>Every character &lt;code&gt;c&lt;/code&gt; obtained in Stage 1, other than the decimal point &lt;code&gt;'.'&lt;/code&gt;, is converted to &lt;code&gt;CharT&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).widen(c)&lt;/code&gt;.</source>
          <target state="translated">소수점 &lt;code&gt;'.'&lt;/code&gt; 을 제외한 1 단계에서 얻은 모든 문자 &lt;code&gt;c&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).widen(c)&lt;/code&gt; &amp;lt; &lt;a href=&quot;../ctype&quot;&gt;std :: ctype&lt;/a&gt; &amp;lt;CharT &amp;gt;&amp;gt; (str.getloc ()). widen (c) 를 호출 하여 &lt;code&gt;CharT&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="55240b46d1b2c778147a32f69f02140623223676" translate="yes" xml:space="preserve">
          <source>Every copy assignment operator is &lt;a href=&quot;../language/as_operator#Trivial_copy_assignment_operator&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">모든 사본 할당 연산자는 &lt;a href=&quot;../language/as_operator#Trivial_copy_assignment_operator&quot;&gt;간단&lt;/a&gt; 하거나 삭제되었습니다</target>
        </trans-unit>
        <trans-unit id="44ece2209b7a05d39c75b1dcbb965646849a11d9" translate="yes" xml:space="preserve">
          <source>Every copy constructor is &lt;a href=&quot;../language/copy_constructor#Trivial_copy_constructor&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">모든 복사 생성자는 &lt;a href=&quot;../language/copy_constructor#Trivial_copy_constructor&quot;&gt;사소&lt;/a&gt; 하거나 삭제됩니다</target>
        </trans-unit>
        <trans-unit id="ddca33bae1f5063131bf99b04d54385eb0d2361a" translate="yes" xml:space="preserve">
          <source>Every coroutine must have a return type that satisfies a number of requirements, noted below.</source>
          <target state="translated">모든 코 루틴에는 아래와 같이 여러 가지 요구 사항을 충족시키는 반환 유형이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6f0b1e2abf2c7b435c80221dcc61afd569006cf6" translate="yes" xml:space="preserve">
          <source>Every direct base of &lt;code&gt;T&lt;/code&gt; has a trivial default constructor</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 모든 직접 기반 에는 간단한 기본 생성자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4f4a9e39d552d4d3b8434b290840e0cb2a72f79" translate="yes" xml:space="preserve">
          <source>Every expression required to be equality preserving is further required to be</source>
          <target state="translated">평등 보존에 필요한 모든 표현은</target>
        </trans-unit>
        <trans-unit id="596cadab563dc077013bb82171b4d411422fe26e" translate="yes" xml:space="preserve">
          <source>Every function in C++ is either</source>
          <target state="translated">C ++의 모든 함수는</target>
        </trans-unit>
        <trans-unit id="2e5a037bddcba35d74d8f0e90f7f426c42f8bbb7" translate="yes" xml:space="preserve">
          <source>Every function type, every function name with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, and every variable name with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, has a property called</source>
          <target state="translated">모든 기능 유형을 가진 모든 함수 이름 &lt;a href=&quot;storage_duration&quot;&gt;외부 링크&lt;/a&gt; 및과 모든 변수 이름 &lt;a href=&quot;storage_duration&quot;&gt;외부 링크는&lt;/a&gt; ,라는 속성이 있습니다</target>
        </trans-unit>
        <trans-unit id="9220204e7dd00c7e1b3f8ea123e9b7a6432dc43a" translate="yes" xml:space="preserve">
          <source>Every initializer clause is &lt;a href=&quot;eval_order&quot;&gt;sequenced before&lt;/a&gt; any initializer clause that follows it in the braced-init-list. This is in contrast with the arguments of a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;, which are &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt;.</source>
          <target state="translated">모든 이니셜 라이저 절은 braced-init-list에서 뒤에 나오는 이니셜 라이저 절 &lt;a href=&quot;eval_order&quot;&gt;보다 먼저 시퀀싱&lt;/a&gt; 됩니다. 이것은의 인수와 대조적이다 &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;함수 호출 식&lt;/a&gt; 이다 &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6ec13c0519794ea073e3092993cf4c79e0a531c" translate="yes" xml:space="preserve">
          <source>Every move assignment operator is &lt;a href=&quot;../language/move_operator#Trivial_move_assignment_operator&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">모든 이동 할당 연산자가 &lt;a href=&quot;../language/move_operator#Trivial_move_assignment_operator&quot;&gt;간단&lt;/a&gt; 하거나 삭제되었습니다</target>
        </trans-unit>
        <trans-unit id="be04d7a82c5aad5c68ef07fc699cbbb387d1c3f3" translate="yes" xml:space="preserve">
          <source>Every move constructor is &lt;a href=&quot;../language/move_constructor#Trivial_move_constructor&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">모든 이동 생성자가 &lt;a href=&quot;../language/move_constructor#Trivial_move_constructor&quot;&gt;사소&lt;/a&gt; 하거나 삭제되었습니다</target>
        </trans-unit>
        <trans-unit id="cec5230f04de71fff49fd937f9a018fd570d7a46" translate="yes" xml:space="preserve">
          <source>Every name that denotes an entity is introduced into the program by a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;. Every name that denotes a label is introduced into the program either by a &lt;a href=&quot;goto&quot;&gt;goto statement&lt;/a&gt; or by a &lt;a href=&quot;statements#Labels&quot;&gt;labeled statement&lt;/a&gt;. A name used in more than one translation unit may refer to the same or different entities, depending on &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt;.</source>
          <target state="translated">엔터티를 나타내는 모든 이름은 &lt;a href=&quot;declarations&quot;&gt;선언에&lt;/a&gt; 의해 프로그램에 도입됩니다 . 레이블을 나타내는 모든 이름은 &lt;a href=&quot;goto&quot;&gt;goto 문&lt;/a&gt; 또는 &lt;a href=&quot;statements#Labels&quot;&gt;레이블 된 명령문으로&lt;/a&gt; 프로그램에 도입됩니다 . 둘 이상의 번역 단위에 사용 된 이름은 &lt;a href=&quot;storage_duration#Linkage&quot;&gt;연결&lt;/a&gt; 에 따라 동일하거나 다른 엔티티를 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b69a8648e61c5f2cb090d5c8ee69368fecb775bd" translate="yes" xml:space="preserve">
          <source>Every non-static data member of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; must be a direct member of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; or the same base class of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;, and must be well-formed in the context of the structured binding when named as &lt;code&gt;&lt;i&gt;&lt;b&gt;e&lt;/b&gt;&lt;/i&gt;.&lt;i&gt;name&lt;/i&gt;&lt;/code&gt;. &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; may not have an anonymous union member. The number of identifiers must equal the number of non-static data members.</source>
          <target state="translated">의 모든 비 - 정적 데이터 멤버 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 는 직접적인 멤버 여야 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 또는 동일한 기본 클래스 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 및 컨텍스트에서 잘 형성되어야 구조적으로 명명 할 때 결합 &lt;code&gt;&lt;i&gt;&lt;b&gt;e&lt;/b&gt;&lt;/i&gt;.&lt;i&gt;name&lt;/i&gt;&lt;/code&gt; . &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 는 익명의 노조원이 없을 수 있습니다. 식별자 수는 비 정적 데이터 멤버 수와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b87d3e4870484b5764d76023f3269d280331e5c7" translate="yes" xml:space="preserve">
          <source>Every non-static member of class type has a trivial default constructor</source>
          <target state="translated">정적이 아닌 클래스 유형의 모든 멤버에는 간단한 기본 생성자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ce1bf1bc0be1980d77a06eeb4de4b342c337db3" translate="yes" xml:space="preserve">
          <source>Every standard library component that may need to allocate or release storage, from &lt;code&gt;std::string&lt;/code&gt;, &lt;code&gt;std::vector&lt;/code&gt;, and every container except &lt;code&gt;std::array&lt;/code&gt;, to &lt;code&gt;std::shared_ptr&lt;/code&gt; and &lt;code&gt;std::function&lt;/code&gt;, does so through an &lt;strong&gt;Allocator&lt;/strong&gt;: an object of a class type that satisfies the following requirements.</source>
          <target state="translated">&lt;code&gt;std::string&lt;/code&gt; , &lt;code&gt;std::vector&lt;/code&gt; 및 &lt;code&gt;std::array&lt;/code&gt; 제외한 모든 컨테이너 에서 &lt;code&gt;std::shared_ptr&lt;/code&gt; 및 &lt;code&gt;std::function&lt;/code&gt; 이르기까지 스토리지를 할당하거나 해제해야 할 수있는 모든 표준 라이브러리 구성 요소 는 &lt;strong&gt;Allocator를&lt;/strong&gt; 통해 수행합니다 . 다음 요구 사항을 충족하는 클래스 유형의 개체</target>
        </trans-unit>
        <trans-unit id="2cf1b35b018fe1d430f2ed7ed9345dcf2146ab69" translate="yes" xml:space="preserve">
          <source>Every stream I/O function if an exception is thrown by any member function of the associated stream buffer (e.g. sbumpc(), xsputn(), sgetc(), overflow(), etc)</source>
          <target state="translated">관련 스트림 버퍼의 멤버 함수에 의해 예외가 발생하면 모든 스트림 I / O 함수 (예 : sbumpc (), xsputn (), sgetc (), overflow () 등)</target>
        </trans-unit>
        <trans-unit id="b09575dd9bf238348e1eb74acc65642a4f28513f" translate="yes" xml:space="preserve">
          <source>Every successive character &lt;code&gt;c&lt;/code&gt; from the sequence of CharT's from Stage 3 is output as if by &lt;code&gt;*out++ = c&lt;/code&gt;.</source>
          <target state="translated">Stage 3의 CharT 시퀀스에서 나오는 모든 연속 문자 &lt;code&gt;c&lt;/code&gt; 는 마치 &lt;code&gt;*out++ = c&lt;/code&gt; 처럼 출력됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa77f47a69b4e10cfca826c1e3a0f4dc9c68af3b" translate="yes" xml:space="preserve">
          <source>Every value of pointer type is one of the following:</source>
          <target state="translated">포인터 유형의 모든 값은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="2711daf557af7651a60993264c29beb1d7e39e00" translate="yes" xml:space="preserve">
          <source>Everything about the actual allocation details of bit fields within the class object</source>
          <target state="translated">클래스 객체 내 비트 필드의 실제 할당 세부 사항에 대한 모든 것</target>
        </trans-unit>
        <trans-unit id="17a1a39f3910e68bd1f80c1b610bdc32df68bf11" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, equivalence is determined by using the equivalence relation as described on &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리가 &lt;a href=&quot;../named_req/compare&quot;&gt;비교&lt;/a&gt; 요구 사항을 사용하는 모든 곳에서 동등성은 &lt;a href=&quot;../named_req/compare&quot;&gt;비교에&lt;/a&gt; 설명 된 동등성 관계를 사용하여 결정됩니다 . 부정확 한 용어로, 두 개의 객체 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 둘 다 다른 것보다 덜 비교하면 동일하다고 간주됩니다 : &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b75c2f9b6cdfbe488daafdef876670cbfaba7ec" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent (not unique) if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리가 &lt;a href=&quot;../named_req/compare&quot;&gt;비교&lt;/a&gt; 요구 사항을 사용하는 모든 곳에서 고유성은 동등성 관계를 사용하여 결정됩니다. 부정확 한 용어로, 두 개의 객체 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 둘 중 하나가 다른 것보다 작 으면 동등하지 않은 것으로 간주됩니다 : &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b615d029d5b8025e266ba5a37f8108df4dbd2078" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리가 &lt;a href=&quot;../named_req/compare&quot;&gt;비교&lt;/a&gt; 요구 사항을 사용하는 모든 곳에서 고유성은 동등성 관계를 사용하여 결정됩니다. 부정확 한 용어로, 두 개의 객체 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 둘 다 다른 것보다 덜 비교하면 동일하다고 간주됩니다 : &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cae74747ce921ce4dc2761826efeaa22990fc6f" translate="yes" xml:space="preserve">
          <source>Exact</source>
          <target state="translated">Exact</target>
        </trans-unit>
        <trans-unit id="b73dce3ae50ecab687b47c8e8958379cbaf57ff0" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;(last - first) - 1&lt;/code&gt; applications of the binary operation.</source>
          <target state="translated">정확하게 &lt;code&gt;(last - first) - 1&lt;/code&gt; 이진 연산의 1 개의 응용 프로그램.</target>
        </trans-unit>
        <trans-unit id="4db39051f1f33d287e9bf44fd101eccfd97335d2" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;(last - first)/2&lt;/code&gt; swaps.</source>
          <target state="translated">정확히 &lt;code&gt;(last - first)/2&lt;/code&gt; 스왑.</target>
        </trans-unit>
        <trans-unit id="999c7ba21fe6cfdf477efe576e8b30044ac5b242" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">술어의 정확한 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 응용 프로그램.</target>
        </trans-unit>
        <trans-unit id="1fc8a6d486ec5aab15a1c1be51264f79f56fc49b" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; invocations of &lt;code&gt;g()&lt;/code&gt; and assignments.</source>
          <target state="translated">정확히 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 의 호출 &lt;code&gt;g()&lt;/code&gt; 및 할당.</target>
        </trans-unit>
        <trans-unit id="35529081f2f26b1b90fd973935838e5852bc467d" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; assignments, for &lt;code&gt;count &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count &amp;gt; 0&lt;/code&gt; 대한 할당을 정확하게 &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a8809cf33804ae021cd515fa06675d07f185d82" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; assignments, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&amp;gt;0&lt;/code&gt; 인 경우 할당을 정확하게 &lt;code&gt;count&lt;/code&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="f0e851801f10602f0a4225377722df5cf5583ba1" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; invocations of &lt;code&gt;g()&lt;/code&gt; and assignments, for &lt;code&gt;count&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&amp;gt;0&lt;/code&gt; 에 대한 &lt;code&gt;g()&lt;/code&gt; 및 할당의 호출을 정확하게 &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e8a97940b9961f72ad69126c982a5fb916192e8" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;distance(first, last)&lt;/code&gt; applications of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 의 정확한 &lt;code&gt;distance(first, last)&lt;/code&gt; 응용 .</target>
        </trans-unit>
        <trans-unit id="664be72d77dd1a490f0db6001689b115d6a6b71a" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">정확히 &lt;code&gt;last - first&lt;/code&gt; 술어의 응용 프로그램.</target>
        </trans-unit>
        <trans-unit id="7e7f4d09b4ff46a04df0991518050618d9d2f7b5" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; assignments.</source>
          <target state="translated">정확히 &lt;code&gt;last - first&lt;/code&gt; 과제.</target>
        </trans-unit>
        <trans-unit id="b25aeebe72d8f421614fa0ad0873495e44259427" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; increments and assignments.</source>
          <target state="translated">정확히 &lt;code&gt;last - first&lt;/code&gt; 증분 및 할당.</target>
        </trans-unit>
        <trans-unit id="dd0f4944e44dc9fa8a6fa7891d44439f219ac35c" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; move assignments.</source>
          <target state="translated">정확히 &lt;code&gt;last - first&lt;/code&gt; 이동 과제.</target>
        </trans-unit>
        <trans-unit id="64786764c6cc4f57b36277db2d8d6df02d730d57" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; applications of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">정확히 &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; 의 응용 프로그램 &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fd8d57c8139bdfd24f5d36db13c1c858637e062" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;n&lt;/code&gt; applications of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 의 정확히 &lt;code&gt;n&lt;/code&gt; 개의 어플리케이션 .</target>
        </trans-unit>
        <trans-unit id="aabf3a891f0ec18e0d36466fa6f0c9ce5485153e" translate="yes" xml:space="preserve">
          <source>Exactly max(N-1,0) comparisons, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">정확히 max (N-1,0) 비교. 여기서 &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99195733fda66fedc7bf44e9446fa1cb19801072" translate="yes" xml:space="preserve">
          <source>Exactly one of &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt;, &lt;code&gt;bool(a &amp;gt; b)&lt;/code&gt; and &lt;code&gt;bool(a == b)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">정확히 하나 &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; , &lt;code&gt;bool(a &amp;gt; b)&lt;/code&gt; 및 &lt;code&gt;bool(a == b)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="c0a2d0e4e192dcffd92f7c5fc920779a3a46eca3" translate="yes" xml:space="preserve">
          <source>Examines the filesystem object referred to by this directory entry and stores its attributes for retrieval with &lt;a href=&quot;status&quot;&gt;&lt;code&gt;status()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;is_regular_file&quot;&gt;&lt;code&gt;is_regular_file()&lt;/code&gt;&lt;/a&gt;, and other status accessors.</source>
          <target state="translated">시험 일정은 파일 시스템 객체로 검색을 위해이 디렉토리 엔트리 저장에 의해 그 속성을 참조 &lt;a href=&quot;status&quot;&gt; &lt;code&gt;status()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exists&quot;&gt; &lt;code&gt;exists()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;is_regular_file&quot;&gt; &lt;code&gt;is_regular_file()&lt;/code&gt; &lt;/a&gt; 및 기타 상태 접근을.</target>
        </trans-unit>
        <trans-unit id="d9b9f013ab46e72d63d24bb4f00288b2d9847138" translate="yes" xml:space="preserve">
          <source>Examines the partitioned (as if by &lt;code&gt;&lt;a href=&quot;partition&quot;&gt;std::partition&lt;/a&gt;&lt;/code&gt;) range &lt;code&gt;[first, last)&lt;/code&gt; and locates the end of the first partition, that is, the first element that does not satisfy &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; if all elements satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">파티션 된 ( &lt;code&gt;&lt;a href=&quot;partition&quot;&gt;std::partition&lt;/a&gt;&lt;/code&gt; 의한 것처럼 ) 범위 &lt;code&gt;[first, last)&lt;/code&gt; 를 검사하고 첫 번째 파티션의 끝, 즉 &lt;code&gt;p&lt;/code&gt; 를 만족하지 않는 첫 번째 요소 또는 모든 요소가 &lt;code&gt;p&lt;/code&gt; 를 만족하는 경우 &lt;code&gt;last&lt;/code&gt; 요소를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="bcb284168678a0919d196ddf44691afe02c5f4b3" translate="yes" xml:space="preserve">
          <source>Examines the range &lt;code&gt;[first, last)&lt;/code&gt; and finds the largest range beginning at &lt;code&gt;first&lt;/code&gt; in which the elements are sorted in ascending order.</source>
          <target state="translated">시험 일정 범위 &lt;code&gt;[first, last)&lt;/code&gt; 과의 큰 범위의 처음 발견 &lt;code&gt;first&lt;/code&gt; 요소가 오름차순으로 정렬되어있는이.</target>
        </trans-unit>
        <trans-unit id="0a9b4d7926393a3c0dd8eb8f3c42a7ab58af6b22" translate="yes" xml:space="preserve">
          <source>Examines the range &lt;code&gt;[first, last)&lt;/code&gt; and finds the largest range beginning at &lt;code&gt;first&lt;/code&gt; which is a</source>
          <target state="translated">시험 일정 범위 &lt;code&gt;[first, last)&lt;/code&gt; 및 발견은 큰 범위에서 시작하여 &lt;code&gt;first&lt;/code&gt; 을 인</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="bd9e11c33e704e33e3cee607c8252cdbbcd8a124" translate="yes" xml:space="preserve">
          <source>Example With Custom Comparator</source>
          <target state="translated">맞춤 비교기를 사용한 예</target>
        </trans-unit>
        <trans-unit id="ab4f744b89a1cf5abcd9dceb291ddd3e9f741894" translate="yes" xml:space="preserve">
          <source>Example from &lt;a href=&quot;http://www.gotw.ca/gotw/030.htm&quot;&gt;http://www.gotw.ca/gotw/030.htm&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.gotw.ca/gotw/030.htm&quot;&gt;http://www.gotw.ca/gotw/030.htm의&lt;/a&gt; 예 .</target>
        </trans-unit>
        <trans-unit id="e251b366d1e0802c0331ec415628df8aa911103c" translate="yes" xml:space="preserve">
          <source>Example output on one of the implementations.</source>
          <target state="translated">구현 중 하나에 대한 예제 출력.</target>
        </trans-unit>
        <trans-unit id="ea1fb9b04a44f008daf87c7d9f9e133ac9bce209" translate="yes" xml:space="preserve">
          <source>Example using a custom comparison function</source>
          <target state="translated">맞춤 비교 함수를 사용하는 예</target>
        </trans-unit>
        <trans-unit id="db0a68cbf7c526f2a972b13383c59c76ca98c33e" translate="yes" xml:space="preserve">
          <source>Example with vectors :</source>
          <target state="translated">벡터를 사용한 예 :</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="8221a0d43625eba2795f842d5c24c7c9f59b0337" translate="yes" xml:space="preserve">
          <source>Examples of &lt;code&gt;Boolean&lt;/code&gt; types include &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;::reference&lt;/code&gt;. Pointers are not &lt;code&gt;Boolean&lt;/code&gt; types.</source>
          <target state="translated">&lt;code&gt;Boolean&lt;/code&gt; 형식의 예 에는 &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;::reference&lt;/code&gt; 됩니다. 포인터는 &lt;code&gt;Boolean&lt;/code&gt; 형식 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="d1eddcef956b054e171719c037485ba482a76be3" translate="yes" xml:space="preserve">
          <source>Examples of erasure methods are &lt;code&gt;&lt;a href=&quot;container/set/erase&quot;&gt;std::set::erase&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/vector/pop_back&quot;&gt;std::vector::pop_back&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/deque/pop_front&quot;&gt;std::deque::pop_front&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;container/map/clear&quot;&gt;std::map::clear&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">삭제 방법의 예는 &lt;code&gt;&lt;a href=&quot;container/set/erase&quot;&gt;std::set::erase&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/vector/pop_back&quot;&gt;std::vector::pop_back&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/deque/pop_front&quot;&gt;std::deque::pop_front&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;container/map/clear&quot;&gt;std::map::clear&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1fe47fa951fcb6357223febc9d44197fbb268fda" translate="yes" xml:space="preserve">
          <source>Examples of implementation-defined launch policies are the sync policy (execute immediately, within the async call) and the task policy (similar to async, but thread-locals are not cleared).</source>
          <target state="translated">구현 정의 실행 정책의 예로는 동기화 정책 (비동기 호출 내에서 즉시 실행) 및 작업 정책 (비 동기화와 유사하지만 스레드 로컬은 지워지지 않음)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e910df0f6bb9dfed95f71ce88f75479176c518cf" translate="yes" xml:space="preserve">
          <source>Examples of insertion methods are &lt;code&gt;&lt;a href=&quot;container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/map/emplace&quot;&gt;std::map::emplace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;container/deque/push_front&quot;&gt;std::deque::push_front&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">삽입 방법의 예는 &lt;code&gt;&lt;a href=&quot;container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/map/emplace&quot;&gt;std::map::emplace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;container/deque/push_front&quot;&gt;std::deque::push_front&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69702eefdd99747ec1287d6c73c6d3f8f05c1292" translate="yes" xml:space="preserve">
          <source>Examples of partial specializations in the standard library include &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, which has a partial specialization for array types.</source>
          <target state="translated">표준 라이브러리의 부분 특수화의 예에는 &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 포함 되는데, 이는 배열 유형에 대한 부분 특수화가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a00ca19e4db47060f538e8b506c6503ac18be3b7" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;value_type&lt;/code&gt;, all the member types of &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; are complete types.</source>
          <target state="translated">&lt;code&gt;value_type&lt;/code&gt; 을 제외하고 &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; 의 모든 멤버 유형 은 완전한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8acd64a7d513ffba5fa93f11be47de7c9fc5c1db" translate="yes" xml:space="preserve">
          <source>Except for default argument, aligned_storage is expressible in terms of alignas:</source>
          <target state="translated">기본 인수를 제외하고, alignment_storage는 다음과 같이 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f51732ca4ed72fa4525ab38c97db1146e4d04378" translate="yes" xml:space="preserve">
          <source>Except in the constructors of &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;, negative values of &lt;code&gt;std::streamsize&lt;/code&gt; are never used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 생성자를 제외하고 &lt;code&gt;std::streamsize&lt;/code&gt; 의 음수 값은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d587eb69ad8f0449298a08da77269d9ca0f24406" translate="yes" xml:space="preserve">
          <source>Except that if no exception specification is explicitly provided, the exception specification is considered to be one that would be used by the implicitly-declared destructor (see below). In most cases, this is &lt;code&gt;noexcept(true)&lt;/code&gt;. Thus a throwing destructor must be explicitly declared &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="translated">예외 사양이 명시 적으로 제공되지 않으면 예외 사양은 암시 적으로 선언 된 소멸자가 사용하는 것으로 간주됩니다 (아래 참조). 대부분의 경우 이것은 &lt;code&gt;noexcept(true)&lt;/code&gt; 입니다. 따라서 던지는 소멸자는 명시 적으로 &lt;code&gt;noexcept(false)&lt;/code&gt; 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0d95da02e76b8dae287531e540c02e16d08b2978" translate="yes" xml:space="preserve">
          <source>Except that names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope, which is also the scope of both statements.</source>
          <target state="translated">init-statement에 의해 선언 된 이름 (init-statement이 선언 인 경우)과 condition에 의해 선언 된 이름 (condition이 선언 인 경우)은 동일한 범위에 있으며 두 명령문의 범위이기도합니다.</target>
        </trans-unit>
        <trans-unit id="29967c007b524bf4d82e67020addcf8209e607a6" translate="yes" xml:space="preserve">
          <source>Except that names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope, which is also the scope of statement.</source>
          <target state="translated">init-statement에 의해 선언 된 이름 (init-statement이 선언 인 경우)과 condition에 의해 선언 된 이름 (condition이 선언 인 경우)이 동일한 범위에 있으며, 이는 명령문의 범위이기도합니다.</target>
        </trans-unit>
        <trans-unit id="e357f711ee87c54bd0e9332d642407c850fea7c4" translate="yes" xml:space="preserve">
          <source>Except that the calls to &lt;code&gt;decay_copy&lt;/code&gt; are evaluated in the context of the caller, so that any exceptions thrown during evaluation and copying/moving of the arguments are thrown in the current thread, without starting the new thread.</source>
          <target state="translated">에 대한 호출하는 것을 제외하고 &lt;code&gt;decay_copy&lt;/code&gt; 는 예외 평가 및 복사시 발생 그래서, 발신자의 맥락에서 평가 / 인수의 이동 새 스레드를 시작하지 않고, 현재의 thread로 던져진다.</target>
        </trans-unit>
        <trans-unit id="1eeb0a1df8df205ed68a524cbaa8c0fab4fe1d23" translate="yes" xml:space="preserve">
          <source>Except that.</source>
          <target state="translated">그거 빼고</target>
        </trans-unit>
        <trans-unit id="f96eec6bcb0eb29fc403d27737c989d54305c3d2" translate="yes" xml:space="preserve">
          <source>Exception categories</source>
          <target state="translated">예외 카테고리</target>
        </trans-unit>
        <trans-unit id="b4b0dfe7027c1d349ba13a7e79558e44ec341bd8" translate="yes" xml:space="preserve">
          <source>Exception handling</source>
          <target state="translated">예외 처리</target>
        </trans-unit>
        <trans-unit id="2c1ebcb87ed425e2ea948b9057321bf79663c920" translate="yes" xml:space="preserve">
          <source>Exception handling provides a way of transferring control and information from some point in the execution of a program to a handler associated with a point previously passed by the execution (in other words, exception handling transfers control up the call stack).</source>
          <target state="translated">예외 처리는 프로그램 실행의 특정 지점에서 이전에 실행에 의해 전달 된 지점과 관련된 처리기로 제어 및 정보를 전송하는 방법을 제공합니다 (즉, 예외 처리 전송은 호출 스택을 제어합니다).</target>
        </trans-unit>
        <trans-unit id="484018b13af3fa5985246c3cf1cb9a80f78a4b2e" translate="yes" xml:space="preserve">
          <source>Exception handling utilities</source>
          <target state="translated">예외 처리 유틸리티</target>
        </trans-unit>
        <trans-unit id="f20b401bcfd0d6316854bd1c5be2e83c76d1de4f" translate="yes" xml:space="preserve">
          <source>Exception objects</source>
          <target state="translated">예외 객체</target>
        </trans-unit>
        <trans-unit id="c178e2e0328be43fb7ba635e2d8a88fc566b2eb0" translate="yes" xml:space="preserve">
          <source>Exception of type &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; may be thrown on errors, with the following error codes:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 유형의 예외는 다음 오류 코드와 함께 오류에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d5280e70d86ad891f2b40c8ed78d7da520c6d7" translate="yes" xml:space="preserve">
          <source>Exception safety</source>
          <target state="translated">예외 안전</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="860a1ec6dde884258f991928e357d615dac44a1f" translate="yes" xml:space="preserve">
          <source>Exceptions (e.g. &lt;code&gt;&lt;a href=&quot;error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;), assertions (e.g. &lt;code&gt;&lt;a href=&quot;error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">예외 (예 : &lt;code&gt;&lt;a href=&quot;error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; ), 어설 션 (예 : &lt;code&gt;&lt;a href=&quot;error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c85cdf1b242c92824cb3422445a6b69100c6e06" translate="yes" xml:space="preserve">
          <source>Exceptions of type &lt;code&gt;std::runtime_error&lt;/code&gt; are thrown by the following standard library components: &lt;code&gt;&lt;a href=&quot;../../locale/locale/locale&quot;&gt;std::locale::locale&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../locale/locale/combine&quot;&gt;std::locale::combine&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::runtime_error&lt;/code&gt; 유형의 예외는 &lt;code&gt;&lt;a href=&quot;../../locale/locale/locale&quot;&gt;std::locale::locale&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../locale/locale/combine&quot;&gt;std::locale::combine&lt;/a&gt;&lt;/code&gt; 표준 라이브러리 구성 요소에 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="3655d713d676393ce50c4dfe2c15b248f391aaef" translate="yes" xml:space="preserve">
          <source>Exceptions that are thrown from member initializers may be handled by &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;.</source>
          <target state="translated">멤버 이니셜 라이저에서 발생하는 예외는 &lt;a href=&quot;function-try-block&quot;&gt;function-try-block에&lt;/a&gt; 의해 처리 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3ccb3655838c7cc0f05342ca4d518865db28c05" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;r&lt;/code&gt; 의 내용을 교환합니다 .</target>
        </trans-unit>
        <trans-unit id="cf0531db840de334e816e5c677f3bd63fcd3dd1a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 내용을 교환</target>
        </trans-unit>
        <trans-unit id="10d46d6be13fed97bcfc06d63285187114a038e8" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container adaptor with those of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c); swap(comp, other.comp);&lt;/code&gt;</source>
          <target state="translated">컨테이너 어댑터의 내용을 &lt;code&gt;other&lt;/code&gt; 내용과 교환합니다 . &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c); swap(comp, other.comp);&lt;/code&gt; 사용하여 효과적으로 호출 ; 스왑 (c, other.c); 스왑 (comp, other.comp);</target>
        </trans-unit>
        <trans-unit id="3e6e9555c788d205a45c120fea2405b48de6ce8a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container adaptor with those of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c);&lt;/code&gt;</source>
          <target state="translated">컨테이너 어댑터의 내용을 &lt;code&gt;other&lt;/code&gt; 내용과 교환합니다 . &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c);&lt;/code&gt; 사용하여 효과적으로 호출 ; 스왑 (c, other.c);</target>
        </trans-unit>
        <trans-unit id="49de04ba32b7f84cb9cd03e37185b56ecd9e1b91" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container with those of &lt;code&gt;other&lt;/code&gt;. Does not cause iterators and references to associate with the other container.</source>
          <target state="translated">컨테이너의 내용을 &lt;code&gt;other&lt;/code&gt; 내용과 교환합니다 . 반복자와 참조가 다른 컨테이너와 연관되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="cca5e7e3ee4209e3931f1f34eaaecf8cf0a0bc6a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container with those of &lt;code&gt;other&lt;/code&gt;. Does not invoke any move, copy, or swap operations on individual elements.</source>
          <target state="translated">컨테이너의 내용을 &lt;code&gt;other&lt;/code&gt; 내용과 교환합니다 . 개별 요소에 대한 이동, 복사 또는 교체 작업을 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62bfbc4c539262880741976e01c4f02e7c1e4a00" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the stream buffer with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">스트림 버퍼의 내용을 &lt;code&gt;other&lt;/code&gt; 내용과 교환합니다 .</target>
        </trans-unit>
        <trans-unit id="3a6e431a73a626620ce066c3e9d4f31fda3acf08" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the string with those of &lt;code&gt;other&lt;/code&gt;. All iterators and references may be invalidated.</source>
          <target state="translated">문자열의 내용을 &lt;code&gt;other&lt;/code&gt; 내용과 교환합니다 . 모든 반복자와 참조가 무효화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a091ec29303367010ecc75278a112bbcdf30230b" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the sync stream buffer with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">동기화 스트림 버퍼의 내용을 &lt;code&gt;other&lt;/code&gt; 내용과 교환합니다 .</target>
        </trans-unit>
        <trans-unit id="6582eb59d4c7d4d4f55d78fce8cfcf8c22bc4bb7" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of two regular expressions.</source>
          <target state="translated">두 정규식의 내용을 교환합니다.</target>
        </trans-unit>
        <trans-unit id="67e3c44b994c5e59c6fd36a93ede7ec7c8983289" translate="yes" xml:space="preserve">
          <source>Exchanges the given values.</source>
          <target state="translated">주어진 값을 교환합니다.</target>
        </trans-unit>
        <trans-unit id="a2b38d8b13b6bc9e51339c32d2d13644d36846b9" translate="yes" xml:space="preserve">
          <source>Exchanges the internal states of the lock objects.</source>
          <target state="translated">잠금 개체의 내부 상태를 교환합니다.</target>
        </trans-unit>
        <trans-unit id="7c072815ce7ddc6a4942335ae6ce9574b39ca082" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states and stored tasks of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 의 공유 상태 및 저장된 태스크를 교환합니다 .</target>
        </trans-unit>
        <trans-unit id="8b12f471554dcab6c425a7585115003928398434" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states of two &lt;code&gt;match_results&lt;/code&gt; objects.</source>
          <target state="translated">두 개의 &lt;code&gt;match_results&lt;/code&gt; 객체 의 공유 상태를 교환 합니다.</target>
        </trans-unit>
        <trans-unit id="59d42fecea425bb592e078023cd032e5a993fe31" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states of two promise objects.</source>
          <target state="translated">두 약속 개체의 공유 상태를 교환합니다.</target>
        </trans-unit>
        <trans-unit id="18b676510da12b57d475482111403500d0eaec7b" translate="yes" xml:space="preserve">
          <source>Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 상태 를 &lt;code&gt;rhs&lt;/code&gt; 상태와 교환합니다 . 효과적으로 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b9970f1ef14caaf33f01eabd758b36bb1eff60" translate="yes" xml:space="preserve">
          <source>Exchanges the state of the stream with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">스트림 상태를 &lt;code&gt;other&lt;/code&gt; 상태와 교환합니다 .</target>
        </trans-unit>
        <trans-unit id="31ddf92acf4cafa84669771e5848a6787348f3e4" translate="yes" xml:space="preserve">
          <source>Exchanges the state with another input/output stream object. Effectively calls &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;::swap(other)&lt;/code&gt;.</source>
          <target state="translated">다른 입력 / 출력 스트림 객체와 상태를 교환합니다. 효과적으로 &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;::swap(other)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d4b57df173bf97bd6ea27f8a30b30cea7df455a9" translate="yes" xml:space="preserve">
          <source>Exchanges the states of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, except for the associated &lt;code&gt;rdbuf&lt;/code&gt; objects. &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;other.rdbuf()&lt;/code&gt; returns the same values as before the call.</source>
          <target state="translated">연관된 &lt;code&gt;rdbuf&lt;/code&gt; 오브젝트를 제외하고 &lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 의 상태를 교환 합니다. &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;other.rdbuf()&lt;/code&gt; 는 호출 전과 동일한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7057d033a604041b5eda100f7d1ff124d6f8a8db" translate="yes" xml:space="preserve">
          <source>Exchanges the stored callable objects of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 의 저장된 호출 가능 객체를 교환합니다 .</target>
        </trans-unit>
        <trans-unit id="d4dce99c5d1d30eb407da92e2d161ddb796ea801" translate="yes" xml:space="preserve">
          <source>Exchanges the underlying handles of two thread objects.</source>
          <target state="translated">두 스레드 객체의 기본 핸들을 교환합니다.</target>
        </trans-unit>
        <trans-unit id="4bec71ee58c3ce1a623ca2ef092eecb76d6de116" translate="yes" xml:space="preserve">
          <source>Exchanges the values referenced by &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 와 &lt;code&gt;u&lt;/code&gt; 로 참조되는 값을 교환합니다 .</target>
        </trans-unit>
        <trans-unit id="9a51b1fd2363fd0ca07531efcb4dd24feaa75b80" translate="yes" xml:space="preserve">
          <source>Exchanges the view with that of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 와 뷰를 교환합니다 .</target>
        </trans-unit>
        <trans-unit id="be6d66875d5906f7cae3a9398d5dbf1c7968e188" translate="yes" xml:space="preserve">
          <source>Exclusive locking</source>
          <target state="translated">독점 잠금</target>
        </trans-unit>
        <trans-unit id="7f9696585c07b96ae418afaf36f528ec350cef50" translate="yes" xml:space="preserve">
          <source>Executable file format error</source>
          <target state="translated">실행 파일 형식 오류</target>
        </trans-unit>
        <trans-unit id="9c973cb9f93e36abf91a1e9c23f91399e854d72a" translate="yes" xml:space="preserve">
          <source>Executes a for loop over a range.</source>
          <target state="translated">범위에 대해 for 루프를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="613b116d4f4f58b27e039a622ea9cf3d90eab7e4" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of condition becomes &lt;code&gt;false&lt;/code&gt;. The test takes place before each iteration.</source>
          <target state="translated">condition 값이 &lt;code&gt;false&lt;/code&gt; 가 될 때까지 명령문을 반복적으로 실행합니다 . 테스트는 각 반복 전에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fb5a19ea5e56f8a6995eea08fd4658f19b1ba739" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of expression becomes false. The test takes place after each iteration.</source>
          <target state="translated">expression 값이 false가 될 때까지 명령문을 반복적으로 실행합니다. 테스트는 각 반복 후에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0c64270896df6b47ed0ab90cdaa2526a36293282" translate="yes" xml:space="preserve">
          <source>Executes init-statement once, then executes statement and iteration_expression repeatedly, until the value of condition becomes false. The test takes place before each iteration.</source>
          <target state="translated">init-statement를 한 번 실행 한 다음 condition 값이 false가 될 때까지 명령문과 iteration_expression을 반복적으로 실행합니다. 테스트는 각 반복 전에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="64b4397dfd824f8172c44d1c4f9e248b16268c1c" translate="yes" xml:space="preserve">
          <source>Executes the &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; object &lt;code&gt;f&lt;/code&gt; exactly once, even if called concurrently, from several threads.</source>
          <target state="translated">여러 스레드에서 동시에 호출하더라도 &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; 객체 &lt;code&gt;f&lt;/code&gt; 를 정확히 한 번 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="5241bfbf176faa293d6e52adf2a2d31791dc7d39" translate="yes" xml:space="preserve">
          <source>Executes the &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; as if under a global lock: all outermost synchronized blocks in the program execute in a single total order. The end of each synchronized block synchronizes with the beginning of the next synchronized block in that order. Synchronized blocks that are nested within other synchronized blocks have no special semantics.</source>
          <target state="translated">전역 잠금에서 마치 &lt;a href=&quot;statements#Compound_statements&quot;&gt;복합 명령문&lt;/a&gt; 을 실행합니다 . 프로그램에서 가장 바깥쪽으로 동기화 된 모든 블록은 단일 총 순서로 실행됩니다. 각 동기화 블록의 끝은 다음 동기화 블록의 시작과 그 순서대로 동기화됩니다. 다른 동기화 된 블록 내에 중첩 된 동기화 된 블록에는 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb88910ec6e8f148a726def306751bb61d10e009" translate="yes" xml:space="preserve">
          <source>Executes the body of the lambda-expression, when invoked. When accessing a variable, accesses its captured copy (for the entities captured by copy), or the original object (for the entities captured by reference). Unless the keyword &lt;code&gt;mutable&lt;/code&gt; was used in the lambda-expression, the function-call operator is const-qualified and the objects that were captured by copy are non-modifiable from inside this &lt;code&gt;operator()&lt;/code&gt;. The function-call operator is never volatile-qualified and never virtual.</source>
          <target state="translated">호출 될 때 람다 표현의 본문을 실행합니다. 변수에 액세스 할 때 캡처 된 사본 (복사로 캡처 된 엔티티의 경우) 또는 원래 오브젝트 (참조로 캡처 된 엔티티의 경우)에 액세스합니다. lambda-expression에서 키워드 &lt;code&gt;mutable&lt;/code&gt; 을 사용 하지 않는 한 함수 호출 연산자는 const로 한정되며 copy로 캡처 된 객체는이 &lt;code&gt;operator()&lt;/code&gt; 내부에서 수정할 수 없습니다 . 함수 호출 연산자는 결코 휘발성이 적고 결코 가상적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="de7349273ae9d07fc03da50e188f4f34b7d2aa3e" translate="yes" xml:space="preserve">
          <source>Execution policies</source>
          <target state="translated">실행 정책</target>
        </trans-unit>
        <trans-unit id="881673b7fc0425b71c75a900e8dd961e60da16d7" translate="yes" xml:space="preserve">
          <source>Exhausting memory in the pool causes the next allocation request for that pool to allocate an additional chunk of memory from the</source>
          <target state="translated">풀에서 메모리가 소진되면 해당 풀에 대한 다음 할당 요청으로 인해 해당 풀에 대한 추가 메모리 청크가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="4d3a207c682e51fd0f76ac46376bd504dd04bb4b" translate="yes" xml:space="preserve">
          <source>Existing elements of &lt;code&gt;a&lt;/code&gt; are destroyed or assigned to</source>
          <target state="translated">기존의 소자 &lt;code&gt;a&lt;/code&gt; 파괴되거나 할당된다</target>
        </trans-unit>
        <trans-unit id="28c764ed1d6222630406c5783a2aaab97f66bd88" translate="yes" xml:space="preserve">
          <source>Expanded value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a28add9450f041df1694bda9dbd7fe1ffe87170" translate="yes" xml:space="preserve">
          <source>Expands to an expression (not necessarily a compile-time constant) of type &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; equal to the number of clock ticks per second, as returned by &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;std::clock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;clock&quot;&gt;std::clock()&lt;/a&gt;&lt;/code&gt; 의해 리턴 된 초 당 클럭 틱 수와 동일한 &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; 유형의 표현식 (컴파일 타임 상수는 아님)으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="a94ceb9709072dbc8a9721a63225f49eded59877" translate="yes" xml:space="preserve">
          <source>Expands to an expression which can be used to initialize an &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; object that can be initialized from &lt;code&gt;value&lt;/code&gt;. If the atomic object has static storage duration, this initialization is &lt;a href=&quot;../language/constant_initialization&quot;&gt;constant initialization&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 에서 초기화 할 수 있는 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 객체 를 초기화하는 데 사용할 수있는 표현식으로 확장됩니다 . 원자 오브젝트에 정적 저장 기간이있는 경우이 초기화는 &lt;a href=&quot;../language/constant_initialization&quot;&gt;지속적인 초기화&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="de6a2f8e65def43ce5a852e140e79c980dade60d" translate="yes" xml:space="preserve">
          <source>Expands to an integer constant expression equal to the maximum value returned by the function &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt;. This value is implementation dependent. It's guaranteed that this value is at least &lt;code&gt;32767&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; 함수가 리턴 한 최대 값과 동일한 정수 상수 표현식으로 확장됩니다 . 이 값은 구현에 따라 다릅니다. 이 값이 &lt;code&gt;32767&lt;/code&gt; 이상임을 보증합니다 .</target>
        </trans-unit>
        <trans-unit id="b74a3f6f88cbf8779ab38cebe0c4e5a1aa35bcc5" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ccabdc1716ee0f1f6ba421bfe7a3cb18e19e27" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;float&lt;/code&gt; expression that indicates overflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1517f254032c8417e8afa57de1c3cc258d11f6c4" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;long double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc198697dbf6af57511ca5dfb75efa170fb6388d" translate="yes" xml:space="preserve">
          <source>Expansion loci</source>
          <target state="translated">확장 위치</target>
        </trans-unit>
        <trans-unit id="d9e0a488e53cfe7c390afb8b463eb5bb25a7cfba" translate="yes" xml:space="preserve">
          <source>Experimental libraries</source>
          <target state="translated">실험 라이브러리</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="52641b8a40589b37d9770ba9ee57a29be108ded9" translate="yes" xml:space="preserve">
          <source>Explicit (full) specialization of a member of a partial specialization is declared the same way as an explicit specialization of the primary template.</source>
          <target state="translated">부분 전문화의 멤버에 대한 명시 적 (전체) 전문화는 기본 템플릿의 명시 적 전문화와 같은 방식으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="dd412ab552031cf5dc3a067286b0057cfec3dfe8" translate="yes" xml:space="preserve">
          <source>Explicit conversion from (possibly const) &lt;code&gt;fpos&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;. The result is the stored offset.</source>
          <target state="translated">(아마도 CONST)에서 명시 적 변환 &lt;code&gt;fpos&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; . 결과는 저장된 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="1c63bca80feb759ba98d57e981b658fef25d5cce" translate="yes" xml:space="preserve">
          <source>Explicit instantiation</source>
          <target state="translated">명시 적 인스턴스화</target>
        </trans-unit>
        <trans-unit id="4b142316d64b45cb4860439c17ed8cd8981f0aa9" translate="yes" xml:space="preserve">
          <source>Explicit instantiation can only appear in the enclosing namespace of the template, unless it uses qualified-id:</source>
          <target state="translated">Qualified-id를 사용하지 않는 경우 명시 적 인스턴스화는 템플리트의 둘러싸는 네임 스페이스에만 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee1fc799be568941add0e5c7edd28b1bd51ae960" translate="yes" xml:space="preserve">
          <source>Explicit instantiation declarations do not suppress the implicit instantiation of &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; functions, &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt;-declarations, references, and class template specializations. (thus, when the inline function that is a subject of explicit instantiation declaration is ODR-used, it is implicitly instantiated for inlining, but its out-of-line copy is not generated in this TU).</source>
          <target state="translated">명시 적 인스턴스화 선언은 &lt;a href=&quot;inline&quot;&gt;인라인&lt;/a&gt; 함수, &lt;a href=&quot;auto&quot;&gt;자동&lt;/a&gt; 선언, 참조 및 클래스 템플릿 특수화 의 암시 적 인스턴스화를 억제하지 않습니다 . (따라서 명시 적 인스턴스화 선언의 대상인 인라인 함수가 ODR을 사용하는 경우 인라인을 위해 암시 적으로 인스턴스화되지만 라인 외부 사본은이 TU에서 생성되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="572c84d2570e91de98df5fd413b0bd1a4670b56d" translate="yes" xml:space="preserve">
          <source>Explicit instantiation definition of a function template with &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; is not a use of the arguments, and does not attempt to initialize them:</source>
          <target state="translated">&lt;a href=&quot;default_arguments&quot;&gt;기본 인수가&lt;/a&gt; 있는 함수 템플리트의 명시 적 인스턴스화 정의는 인수 를 사용하지 않으며이를 초기화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0dcc010f6137a4796c623c315a5959bc45a20109" translate="yes" xml:space="preserve">
          <source>Explicit instantiation definitions ignore member access specifiers: parameter types and return types may be private.</source>
          <target state="translated">명시 적 인스턴스화 정의는 멤버 액세스 지정자를 무시합니다. 매개 변수 유형 및 리턴 유형은 개인용 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65478c257174b4e3c09ba657cd00b83b6bf1640b" translate="yes" xml:space="preserve">
          <source>Explicit instantiation has no effect if an &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt; appeared before for the same set of template arguments.</source>
          <target state="translated">동일한 템플릿 인수 집합에 대해 &lt;a href=&quot;template_specialization&quot;&gt;명시 적 전문화가&lt;/a&gt; 나타난 경우 명시 적 인스턴스화는 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d36a0cc2732df089c694dc98284a6d85796f30ad" translate="yes" xml:space="preserve">
          <source>Explicit instantiation of a function template or of a member function of a class template cannot use &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;constexpr&lt;/code&gt;. If the declaration of the explicit instantiation names an implicitly-declared special member function, the program is ill-formed.</source>
          <target state="translated">함수 템플릿 또는 클래스 템플릿의 멤버 함수를 명시 적으로 인스턴스화하면 &lt;code&gt;inline&lt;/code&gt; 또는 &lt;code&gt;constexpr&lt;/code&gt; 을 사용할 수 없습니다 . 명시 적 인스턴스화 선언에 내재적으로 선언 된 특수 멤버 함수의 이름이 지정된 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="30c811d49cc758004cfc53fc79ee65d4652de860" translate="yes" xml:space="preserve">
          <source>Explicit instantiations, explicit specializations, or partial specializations of concepts are not allowed (the meaning of the original definition of a constraint cannot be changed).</source>
          <target state="translated">명시 적 인스턴스화, 명시 적 특수화 또는 개념의 부분 특수화는 허용되지 않습니다 (제약 조건의 원래 정의의 의미는 변경 될 수 없음).</target>
        </trans-unit>
        <trans-unit id="2e55319f81d1a852746aa5972684208a80ae6770" translate="yes" xml:space="preserve">
          <source>Explicit specialization</source>
          <target state="translated">명시 적 전문화</target>
        </trans-unit>
        <trans-unit id="593deb78caf931f5a8926f7968637e3804e9bc2d" translate="yes" xml:space="preserve">
          <source>Explicit specialization may be declared in any scope where its primary template may be defined (which may be different from the scope where the primary template is defined; such as with out-of-class specialization of a &lt;a href=&quot;member_template&quot;&gt;member template&lt;/a&gt;) . Explicit specialization has to appear after the non-specialized template declaration.</source>
          <target state="translated">명시 적 특수화는 기본 템플리트가 정의 될 수있는 모든 범위에서 선언 될 수 있습니다 (예 : 기본 템플리트가 정의 된 범위와 다를 수 있습니다 (예 : &lt;a href=&quot;member_template&quot;&gt;구성원 템플리트&lt;/a&gt; 의 클래스 외부 특수화 )). 전문화되지 않은 템플릿 선언 후에 명시 적 전문화가 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="8870f1f0b78d6b643054caef6f197e66cbb50dc0" translate="yes" xml:space="preserve">
          <source>Explicit specializations of function templates</source>
          <target state="translated">함수 템플릿의 명시 적 전문화</target>
        </trans-unit>
        <trans-unit id="d9b457bfa7e9dfdb8f202a1cfd0b13910b32a1d1" translate="yes" xml:space="preserve">
          <source>Explicit template argument lists may not be specified when calling any of them.</source>
          <target state="translated">호출 할 때 명시 적 템플리트 인수 목록을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="901409defb65997b43ccf96e53d877ad8c4540d5" translate="yes" xml:space="preserve">
          <source>Explicit template arguments</source>
          <target state="translated">명시 적 템플릿 인수</target>
        </trans-unit>
        <trans-unit id="4431a5f6720c93927b4ab9fdd98f9a2ec4e9c49f" translate="yes" xml:space="preserve">
          <source>Explicit template instantiation</source>
          <target state="translated">명시 적 템플릿 인스턴스화</target>
        </trans-unit>
        <trans-unit id="0fab44e233e42157cd5dea76fd8cf3c8b9d7adc5" translate="yes" xml:space="preserve">
          <source>Explicit template specialization</source>
          <target state="translated">명시 적 템플릿 전문화</target>
        </trans-unit>
        <trans-unit id="efc7df6ee447c5edc7f6c07135ad3f5023dea6a8" translate="yes" xml:space="preserve">
          <source>Explicit type conversion</source>
          <target state="translated">명시 적 타입 변환</target>
        </trans-unit>
        <trans-unit id="dd8bfe3fdab8ac97b580b2a4aef0404f178b5ac1" translate="yes" xml:space="preserve">
          <source>Exponential functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af9874c4957d8cd8c01ba533edd025cf4c27e381" translate="yes" xml:space="preserve">
          <source>Exposes class &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; as a method of accessing individual bits. In particular, objects of this class are returned by &lt;a href=&quot;vector/operator_at&quot;&gt;&lt;code&gt;operator[]&lt;/code&gt;&lt;/a&gt; by value.</source>
          <target state="translated">개별 비트에 액세스하는 방법으로 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; 클래스를 노출 합니다. 특히이 클래스의 객체는 &lt;a href=&quot;vector/operator_at&quot;&gt; &lt;code&gt;operator[]&lt;/code&gt; &lt;/a&gt; 의해 값으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="386b8e5c19a5d25975c5d960c8d6889b5c0e7456" translate="yes" xml:space="preserve">
          <source>Exposes the type named &lt;code&gt;type&lt;/code&gt;, which is the common type of two &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">유형 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 의 공통 유형 인 type이라는 &lt;code&gt;type&lt;/code&gt; 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="81c630945113fb74890dbe59b04840a67c663c1b" translate="yes" xml:space="preserve">
          <source>Exposes the type named &lt;code&gt;type&lt;/code&gt;, which is the common type of two &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">유형 &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; 의 공통 유형 인 type이라는 &lt;code&gt;type&lt;/code&gt; 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="dde7602ac0e3b525fda01f2a33c67f49539ca405" translate="yes" xml:space="preserve">
          <source>Exposition-only data member holding the sentinel (typically either a number, for a bounded iota view, or an instance of &lt;code&gt;std::unreachable_sentinel_t&lt;/code&gt; for an unbounded iota view.</source>
          <target state="translated">한정된 IOTA보기 또는 인스턴스에 대해, 어느 번호를 일반적 센티넬 (들고 박람회 전용 데이터 부재 &lt;code&gt;std::unreachable_sentinel_t&lt;/code&gt; 안 바운드 IOTA 뷰.</target>
        </trans-unit>
        <trans-unit id="cf2a2572c2908ed7f54343df2e7969e31bec570b" translate="yes" xml:space="preserve">
          <source>Exposition-only data member holding the sentinel of the underlying &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 의 센티넬을 보유하는 노출 전용 데이터 멤버 입니다.</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="41e32832dbe3b76f5e8fc2a5f15b3848cf05e235" translate="yes" xml:space="preserve">
          <source>Expression SFINAE</source>
          <target state="translated">식 SFINAE</target>
        </trans-unit>
        <trans-unit id="833207cd0a28197ca9f0d233e80f2413b069f412" translate="yes" xml:space="preserve">
          <source>Expression evaluation may produce a result (e.g., evaluation of &lt;code&gt;2+2&lt;/code&gt; produces the result &lt;code&gt;4&lt;/code&gt;) and may generate side-effects (e.g. evaluation of &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; prints the character &lt;code&gt;'4'&lt;/code&gt; on the standard output).</source>
          <target state="translated">발현 평가는 결과를 생성 할 수 있고 (예를 들어, &lt;code&gt;2+2&lt;/code&gt; 의 평가 는 결과 &lt;code&gt;4&lt;/code&gt; 를 생성하고 ) 부작용을 생성 할 수있다 (예를 들어, &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; 평가 ( &quot;% d&quot;, 4) 는 표준에 문자 &lt;code&gt;'4'&lt;/code&gt; 를 인쇄한다 산출).</target>
        </trans-unit>
        <trans-unit id="0a7a6ba0d7d2af3106edf9d912c2fc5a47512f54" translate="yes" xml:space="preserve">
          <source>Expression statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="bd7f69f355486bcb0814ab9e5cf3b7318931dffa" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;static_assert&lt;/code&gt;</source>
          <target state="translated">확장 된 &lt;code&gt;static_assert&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85f5fa538ad73dc2c1cf60d6bcfc4288cb6d221b" translate="yes" xml:space="preserve">
          <source>Extending memory management tools</source>
          <target state="translated">메모리 관리 도구 확장</target>
        </trans-unit>
        <trans-unit id="446e27d8fc1178607fbaea2ba6117c2bee0e3166" translate="yes" xml:space="preserve">
          <source>Extending the namespace std</source>
          <target state="translated">네임 스페이스 std 확장</target>
        </trans-unit>
        <trans-unit id="e73f93d7fc042bb05945a0bc48fe3f9f81efe46b" translate="yes" xml:space="preserve">
          <source>Extension to &lt;a href=&quot;language/aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;language/aggregate_initialization&quot;&gt;초기화 집계를위한&lt;/a&gt; 확장</target>
        </trans-unit>
        <trans-unit id="9d6e9863adde877292363ab102515ca7b6ccafb6" translate="yes" xml:space="preserve">
          <source>Extensions for &lt;code&gt;std::future&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::future&lt;/code&gt; 확장</target>
        </trans-unit>
        <trans-unit id="71a1260f76544c68e3425a1c076e5499b0002fbb" translate="yes" xml:space="preserve">
          <source>Extent</source>
          <target state="translated">Extent</target>
        </trans-unit>
        <trans-unit id="f92e601eb8d663033dca3851ad6f1616d1966aa7" translate="yes" xml:space="preserve">
          <source>External links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1aea7fedb01b55857a374fd355fdb3f3d76821e" translate="yes" xml:space="preserve">
          <source>Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container.</source>
          <target state="translated">노드를 추출하면 추출 된 요소에 대한 반복자 만 무효화되고 지워지지 않은 요소의 상대적 순서가 유지됩니다. 추출 된 요소에 대한 포인터 및 참조는 유효하지만 노드 핸들이 요소를 소유하는 동안에는 사용할 수 없습니다. 요소가 컨테이너에 삽입되면 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5485507a535a08d29060699bc1ba26e5fbec017" translate="yes" xml:space="preserve">
          <source>Extracting a node invalidates the iterators to the extracted element. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container.</source>
          <target state="translated">노드를 추출하면 반복자가 추출 된 요소에 대해 무효화됩니다. 추출 된 요소에 대한 포인터 및 참조는 유효하지만 노드 핸들이 요소를 소유하는 동안에는 사용할 수 없습니다. 요소가 컨테이너에 삽입되면 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15d94524be33e2064c90d0f8c997adad64d1ab7" translate="yes" xml:space="preserve">
          <source>Extracting a single character that is the last character of the stream does not set &lt;code&gt;eofbit&lt;/code&gt;: this is different from other formatted input functions, such as extracting the last integer with &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, but this behavior matches the behavior of &lt;code&gt;&lt;a href=&quot;../c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&quot;%c&quot;&lt;/code&gt; format specifier.</source>
          <target state="translated">스트림의 마지막 문자 인 단일 문자를 추출하면 &lt;code&gt;eofbit&lt;/code&gt; 가 설정되지 않습니다 . 이것은 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 하여 마지막 정수를 추출하는 것과 같은 다른 형식의 입력 함수와 다르지만이 동작은 &lt;code&gt;&lt;a href=&quot;../c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; 의 동작 과 &lt;code&gt;&quot;%c&quot;&lt;/code&gt; 형식 지정자</target>
        </trans-unit>
        <trans-unit id="77a2197986a0f5813101a331f598cfcb85a220fb" translate="yes" xml:space="preserve">
          <source>Extracts an element from the pair using tuple-like interface.</source>
          <target state="translated">튜플과 같은 인터페이스를 사용하여 쌍에서 요소를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="ef0ddc3034770dba9709a96861d6340f80bd0470" translate="yes" xml:space="preserve">
          <source>Extracts and discards characters from the input stream until and including &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delim&lt;/code&gt; 을 포함 할 때까지 입력 스트림에서 문자를 추출하여 버립니다 .</target>
        </trans-unit>
        <trans-unit id="c16944c77e932413c2253839ec882702fb001de1" translate="yes" xml:space="preserve">
          <source>Extracts character or characters from stream.</source>
          <target state="translated">스트림에서 문자를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a68c11784d768fd75f5143a08580523eaca81d6d" translate="yes" xml:space="preserve">
          <source>Extracts characters from stream until end of line or the specified delimiter &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">줄 끝 또는 지정된 구분 기호 &lt;code&gt;delim&lt;/code&gt; 까지 스트림에서 문자를 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="b0ac0f2a82fe93a443fa08ceb0fe622f9ece3c06" translate="yes" xml:space="preserve">
          <source>Extracts characters from stream.</source>
          <target state="translated">스트림에서 문자를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="7649df41de72e363648c6e8cac8be1f6dc3a552f" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;Ith&lt;/code&gt; element element from the array.</source>
          <target state="translated">배열에서 &lt;code&gt;Ith&lt;/code&gt; 요소를 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="44b2e430b2cfaf879035a796088aa41b5223f736" translate="yes" xml:space="preserve">
          <source>Extracts the current &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;regex_iterator&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;regex_iterator&lt;/code&gt; 에서 현재 &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; 를 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="b56e81381fa5a47e6b3ea3eb1d488fda4cab62e7" translate="yes" xml:space="preserve">
          <source>Extracts up to &lt;code&gt;count&lt;/code&gt; immediately available characters from the input stream. The extracted characters are stored into the character array pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">최대 추출 &lt;code&gt;count&lt;/code&gt; 입력 스트림에서 즉시 사용 가능한 문자를. 추출 된 문자는 &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자 배열에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="e72ac13e9cd4d6af9eb70d5cf0e07a1000b3c95a" translate="yes" xml:space="preserve">
          <source>F is sequenced-before X in thread A</source>
          <target state="translated">스레드 A에서 X보다 먼저 F가 순서화 됨</target>
        </trans-unit>
        <trans-unit id="7baf4c10d15dfb9c6bb605f66aef033fa6c6e2a5" translate="yes" xml:space="preserve">
          <source>FA is sequenced-before X in thread A</source>
          <target state="translated">스레드 A에서 X보다 먼저 FA가 시퀀싱 됨</target>
        </trans-unit>
        <trans-unit id="ee8392aac4b3ee280362ef5273dcbf0dce3c5592" translate="yes" xml:space="preserve">
          <source>FEMININE ORDINAL INDICATOR</source>
          <target state="translated">여성 오리진 지표</target>
        </trans-unit>
        <trans-unit id="c061bc777cddf822c848be8c51b3f6a8a14f19f4" translate="yes" xml:space="preserve">
          <source>FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</source>
          <target state="translated">FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="b1c364462df93e13ffc864f5e34d434d3e0896f1" translate="yes" xml:space="preserve">
          <source>FE_DFL_ENV</source>
          <target state="translated">FE_DFL_ENV</target>
        </trans-unit>
        <trans-unit id="afc46bada59e52921ca04acfa3e557f4d34949db" translate="yes" xml:space="preserve">
          <source>FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</source>
          <target state="translated">FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</target>
        </trans-unit>
        <trans-unit id="f17f59f8bb1aa4aa1c2a8be48c8b3cc395132a95" translate="yes" xml:space="preserve">
          <source>FE_UNDERFLOW</source>
          <target state="translated">FE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="5fc0e01507a5cabdda26a6538ed27cbe059c94c7" translate="yes" xml:space="preserve">
          <source>FE_UPWARD</source>
          <target state="translated">FE_UPWARD</target>
        </trans-unit>
        <trans-unit id="6c8821a037c125e39dc3cb69a201a2174bd7c0f8" translate="yes" xml:space="preserve">
          <source>FILENAME_MAX</source>
          <target state="translated">FILENAME_MAX</target>
        </trans-unit>
        <trans-unit id="ec0e6a828868888b35d7b88c45bc8ec8ded65b4c" translate="yes" xml:space="preserve">
          <source>FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</source>
          <target state="translated">FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="7afcf0013539d05e408bc6855b9ff9c33961ba4a" translate="yes" xml:space="preserve">
          <source>FLT_DIGDBL_DIGLDBL_DIG</source>
          <target state="translated">FLT_DIGDBL_DIGLDBL_DIG</target>
        </trans-unit>
        <trans-unit id="fb4b82dd7a09ae0e4cd4ec26fae3ace2a1f492b3" translate="yes" xml:space="preserve">
          <source>FLT_EPSILONDBL_EPSILONLDBL_EPSILON</source>
          <target state="translated">FLT_EPSILONDBL_EPSILONLDBL_EPSILON</target>
        </trans-unit>
        <trans-unit id="19a80ddd685588eb2c01ceaa6c67ca15a9d3cd90" translate="yes" xml:space="preserve">
          <source>FLT_EVAL_METHOD</source>
          <target state="translated">FLT_EVAL_METHOD</target>
        </trans-unit>
        <trans-unit id="27b085fe54adba08fa4a2911aa54c2928531a994" translate="yes" xml:space="preserve">
          <source>FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</source>
          <target state="translated">FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</target>
        </trans-unit>
        <trans-unit id="d23e1d93b48a70a6b3008660a10922fc69e91714" translate="yes" xml:space="preserve">
          <source>FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</source>
          <target state="translated">FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</target>
        </trans-unit>
        <trans-unit id="14a1a55c6769f2d618f216dd4e1926c937963a81" translate="yes" xml:space="preserve">
          <source>FLT_MAXDBL_MAXLDBL_MAX</source>
          <target state="translated">FLT_MAXDBL_MAXLDBL_MAX</target>
        </trans-unit>
        <trans-unit id="1a43181bc7c68633c0d3a314ceb823229a88ee19" translate="yes" xml:space="preserve">
          <source>FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</source>
          <target state="translated">FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</target>
        </trans-unit>
        <trans-unit id="ed2d991f061e360c893c5a713ef996b38ebffdc9" translate="yes" xml:space="preserve">
          <source>FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</source>
          <target state="translated">FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</target>
        </trans-unit>
        <trans-unit id="24b8072d7962d75d2c508ff42b7b1b1555e6bb66" translate="yes" xml:space="preserve">
          <source>FLT_MINDBL_MINLDBL_MIN</source>
          <target state="translated">FLT_MINDBL_MINLDBL_MIN</target>
        </trans-unit>
        <trans-unit id="6869500f7b0f9c2b39432ab1b4dcf3e3690ba2a4" translate="yes" xml:space="preserve">
          <source>FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</source>
          <target state="translated">FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</target>
        </trans-unit>
        <trans-unit id="d64b48614536e2d9f3fd84e0b2d0f3339ef6dae1" translate="yes" xml:space="preserve">
          <source>FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</source>
          <target state="translated">FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</target>
        </trans-unit>
        <trans-unit id="3d8d38284d7c48984126ae4544c8465c506ee097" translate="yes" xml:space="preserve">
          <source>FLT_RADIX</source>
          <target state="translated">FLT_RADIX</target>
        </trans-unit>
        <trans-unit id="234dca4e2a0e92e5608ec0464e330e76723ea1d3" translate="yes" xml:space="preserve">
          <source>FLT_ROUNDS</source>
          <target state="translated">FLT_ROUNDS</target>
        </trans-unit>
        <trans-unit id="7e6cd06ba47da57a942743f790919ca173fb6d20" translate="yes" xml:space="preserve">
          <source>FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</source>
          <target state="translated">FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</target>
        </trans-unit>
        <trans-unit id="60945a4b9de8b69d4d5468fc065e520c99d43f40" translate="yes" xml:space="preserve">
          <source>FOPEN_MAX</source>
          <target state="translated">FOPEN_MAX</target>
        </trans-unit>
        <trans-unit id="052dbc6bd1e79a500f50639c055da0a0bddfcda6" translate="yes" xml:space="preserve">
          <source>FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b390f17b3415cc66503253a8e943ae6869cbbbb" translate="yes" xml:space="preserve">
          <source>FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</source>
          <target state="translated">FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</target>
        </trans-unit>
        <trans-unit id="13ad13aaa89439dd8522b85f083a14ec539c93e9" translate="yes" xml:space="preserve">
          <source>FP_ZERO</source>
          <target state="translated">FP_ZERO</target>
        </trans-unit>
        <trans-unit id="8c6c7c8ebbe0f69f73a317ea017f66dfe215ff4a" translate="yes" xml:space="preserve">
          <source>Facet categories</source>
          <target state="translated">패싯 카테고리</target>
        </trans-unit>
        <trans-unit id="041a83e17c0f537ae2ed62d3b2cdf6826e396193" translate="yes" xml:space="preserve">
          <source>Facet category base classes</source>
          <target state="translated">패싯 카테고리 기본 클래스</target>
        </trans-unit>
        <trans-unit id="b533c7fea0c500ba4ef293884991083e32ec4a68" translate="yes" xml:space="preserve">
          <source>Facets with the same &lt;code&gt;id&lt;/code&gt; belong to the same facet category and replace each other when added to a locale object.</source>
          <target state="translated">동일한 &lt;code&gt;id&lt;/code&gt; 가진 패싯 은 동일한 패싯 카테고리에 속하며 로케일 오브젝트에 추가 될 때 서로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="66908b176ccb4f40a6f1a10938d28a50727305a6" translate="yes" xml:space="preserve">
          <source>Factor operations</source>
          <target state="translated">요인 연산</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="ce6c5bc258e8bef5e3ae59b1338a20c4748ea8d2" translate="yes" xml:space="preserve">
          <source>Failure to open</source>
          <target state="translated">열지 못함</target>
        </trans-unit>
        <trans-unit id="d3051aec047cdd51e6d43d2664a5df396a9877fb" translate="yes" xml:space="preserve">
          <source>Failures to meet the postconditions, such as failing to produce a valid return value object</source>
          <target state="translated">유효한 반환 값 개체를 생성하지 못하는 등의 사후 조건을 충족하지 못하는 경우</target>
        </trans-unit>
        <trans-unit id="3914bd46dc4687d6b7087f5c008acc618475cc00" translate="yes" xml:space="preserve">
          <source>Failures to meet the preconditions of another function that must be called</source>
          <target state="translated">호출해야하는 다른 함수의 전제 조건을 충족하지 못하는 경우</target>
        </trans-unit>
        <trans-unit id="c29752c93447e11b1a890d7ac78a70435ca5bdb4" translate="yes" xml:space="preserve">
          <source>Fancy pointers</source>
          <target state="translated">멋진 포인터</target>
        </trans-unit>
        <trans-unit id="b494fef582ccfffefb54575ea4e577f7dbaf26c1" translate="yes" xml:space="preserve">
          <source>Fast access but fixed number of elements</source>
          <target state="translated">빠른 액세스이지만 고정 된 수의 요소</target>
        </trans-unit>
        <trans-unit id="24dd69ccc43e1ae6d5f5a742d02f0da0f6b32305" translate="yes" xml:space="preserve">
          <source>Fast access but mostly inefficient insertions/deletions</source>
          <target state="translated">빠른 액세스이지만 대부분 비효율적 인 삽입 / 삭제</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="0775fb360f01bab977ed5ec997840be1f65f3719" translate="yes" xml:space="preserve">
          <source>Feature testing</source>
          <target state="translated">기능 테스트</target>
        </trans-unit>
        <trans-unit id="9fe9f4b9291746b85204d55ff6be73414f9570ac" translate="yes" xml:space="preserve">
          <source>Feature testing (C++20)</source>
          <target state="translated">기능 테스트 (C ++ 20)</target>
        </trans-unit>
        <trans-unit id="bc0228c9de8004fdac6db7743fdd23e61859a392" translate="yes" xml:space="preserve">
          <source>Fence-atomic synchronization</source>
          <target state="translated">울타리-원자 동기화</target>
        </trans-unit>
        <trans-unit id="c0f00371ddb6eac35be65eb720b3cab89de6182d" translate="yes" xml:space="preserve">
          <source>Fence-fence synchronization</source>
          <target state="translated">울타리 울타리 동기화</target>
        </trans-unit>
        <trans-unit id="e79120c3392d8a2111f0e85788e61d24a2973100" translate="yes" xml:space="preserve">
          <source>Fence-fence synchronization can be used to add synchronization to a sequence of several relaxed atomic operations, for example.</source>
          <target state="translated">예를 들어, 펜스-펜스 동기화를 사용하여 여러 완화 된 원자 연산 시퀀스에 동기화를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d413b1e7e21f8acf4d5ba31c56b61a1a190cf03" translate="yes" xml:space="preserve">
          <source>File I/O implementation</source>
          <target state="translated">파일 I / O 구현</target>
        </trans-unit>
        <trans-unit id="a1369155ac8ee1937c5466bde76ab0bbbcbba45c" translate="yes" xml:space="preserve">
          <source>File access</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbca940d8a1676fb3cfcf517eb3d1e3e48574ec" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;b&quot;&lt;/code&gt; can optionally be specified to open a file &lt;a href=&quot;../c#Binary_and_text_modes&quot;&gt;in binary mode&lt;/a&gt;. This flag has no effect on POSIX systems, but on Windows, for example, it disables special handling of &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\x1A'&lt;/code&gt;.</source>
          <target state="translated">파일 액세스 모드 플래그 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 를 선택적으로 지정하여 파일 &lt;a href=&quot;../c#Binary_and_text_modes&quot;&gt;을 이진 모드&lt;/a&gt; 로 열 수 있습니다 . 이 플래그는 POSIX 시스템에는 영향을 미치지 않지만 Windows에서는 예를 들어 &lt;code&gt;'\n'&lt;/code&gt; 및 &lt;code&gt;'\x1A'&lt;/code&gt; 의 특수 처리를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="9675879f138420dc849c3b02c7a08a45f1764ce0" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;x&quot;&lt;/code&gt; can optionally be appended to &quot;w&quot; or &quot;w+&quot; specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C++17)</source>
          <target state="translated">파일 액세스 모드 플래그 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 는 선택적으로 &quot;w&quot;또는 &quot;w +&quot;지정자에 추가 될 수 있습니다. 이 플래그는 파일을 덮어 쓰는 대신 파일이 존재하면 함수가 실패하도록합니다. (C ++ 17)</target>
        </trans-unit>
        <trans-unit id="848538ee54491f003e342600d6426cc1665c1d90" translate="yes" xml:space="preserve">
          <source>File descriptor value too large</source>
          <target state="translated">파일 디스크립터 값이 너무 큼</target>
        </trans-unit>
        <trans-unit id="e4abf36a5ea54ec41cce22ec0fe706639aba0b93" translate="yes" xml:space="preserve">
          <source>File exists</source>
          <target state="translated">파일이 존재</target>
        </trans-unit>
        <trans-unit id="64fd779c46cf2d931941b36cb1e56f079e1d6e2c" translate="yes" xml:space="preserve">
          <source>File operations</source>
          <target state="translated">파일 작업</target>
        </trans-unit>
        <trans-unit id="0b24f6042e86aadda1815101f042d04954349481" translate="yes" xml:space="preserve">
          <source>File owner has execute/search permission</source>
          <target state="translated">파일 소유자에게 실행 / 검색 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="1a3e84e64dd01307f0ee39195f923bfa54b5c0c6" translate="yes" xml:space="preserve">
          <source>File owner has read permission</source>
          <target state="translated">파일 소유자에게 읽기 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="00a45fcb3c463f25a9813f51c216665d3293d7ab" translate="yes" xml:space="preserve">
          <source>File owner has read, write, and execute/search permissions</source>
          <target state="translated">파일 소유자가 읽기, 쓰기 및 실행 / 검색 권한을 가지고 있습니다</target>
        </trans-unit>
        <trans-unit id="01358bbedd5677b98189c5d53b33f357f182c488" translate="yes" xml:space="preserve">
          <source>File owner has write permission</source>
          <target state="translated">파일 소유자에게 쓰기 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="1a996ddad7a713856017f5f90fe0498db20bdbda" translate="yes" xml:space="preserve">
          <source>File position indicator on success or &lt;code&gt;-1L&lt;/code&gt; if failure occurs. Also sets &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">성공시 파일 위치 표시기 또는 실패가 발생하면 &lt;code&gt;-1L&lt;/code&gt; 또한 실패시 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a494399ad447f56f41d7522c5db08562d3c24708" translate="yes" xml:space="preserve">
          <source>File positioning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cd96e05c782cee5791cf21bde1893978c5c077" translate="yes" xml:space="preserve">
          <source>File scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0704a4eaa055ab08e3766911e446737f4f2a445" translate="yes" xml:space="preserve">
          <source>File too large</source>
          <target state="translated">파일이 너무 큽니다</target>
        </trans-unit>
        <trans-unit id="0205534386e03d869079430b7c0117e9af5229d7" translate="yes" xml:space="preserve">
          <source>File types</source>
          <target state="translated">파일 형식</target>
        </trans-unit>
        <trans-unit id="fae255f2995d1f907f01cf7594e8462316da5be7" translate="yes" xml:space="preserve">
          <source>Filename and line information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba8d30ffba45db4e2f3f220829fe902e2fd990f" translate="yes" xml:space="preserve">
          <source>Filename too long</source>
          <target state="translated">파일 이름이 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="092fe85f5c2e62269fa44ec1fcbf190e92f16564" translate="yes" xml:space="preserve">
          <source>Filesystem</source>
          <target state="translated">Filesystem</target>
        </trans-unit>
        <trans-unit id="bbc4c49f164b158dbe825399e8316a41a98039c5" translate="yes" xml:space="preserve">
          <source>Filesystem TS</source>
          <target state="translated">파일 시스템 TS</target>
        </trans-unit>
        <trans-unit id="f6adde9d94ef3f9818beca92c4fb5775d3d08a90" translate="yes" xml:space="preserve">
          <source>Filesystem library</source>
          <target state="translated">파일 시스템 라이브러리</target>
        </trans-unit>
        <trans-unit id="d6016e126bb1261237244c868e871626e1164a78" translate="yes" xml:space="preserve">
          <source>Fills [&lt;code&gt;rb&lt;/code&gt;,&lt;code&gt;re&lt;/code&gt;) with 32-bit quantities depending on the initial supplied values and potential previous calls to &lt;code&gt;generate&lt;/code&gt;. If &lt;code&gt;rb == re&lt;/code&gt;, it does nothing.</source>
          <target state="translated">초기 제공된 값과 &lt;code&gt;generate&lt;/code&gt; 할 잠재적 인 이전 호출에 따라 32 비트 수량으로 [ &lt;code&gt;rb&lt;/code&gt; , &lt;code&gt;re&lt;/code&gt; ]를 채 웁니다 . 경우 &lt;code&gt;rb == re&lt;/code&gt; , 그것은 아무것도하지 않는다.</target>
        </trans-unit>
        <trans-unit id="0477adab8010ca288bf22b1b3deddefba747b42d" translate="yes" xml:space="preserve">
          <source>Fills the range &lt;code&gt;[begin, end)&lt;/code&gt; with unsigned integer values &lt;code&gt;i&lt;/code&gt;, 0 &amp;le; i &amp;lt; 232</source>
          <target state="translated">범위 &lt;code&gt;[begin, end)&lt;/code&gt; 를 부호없는 정수 값 &lt;code&gt;i&lt;/code&gt; , 0 &amp;le; i &amp;lt;232로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="da2860ae65231144c9442af16b999bbb60810f8b" translate="yes" xml:space="preserve">
          <source>Fills the range &lt;code&gt;[first, last)&lt;/code&gt; with sequentially increasing values, starting with &lt;code&gt;value&lt;/code&gt; and repetitively evaluating &lt;code&gt;++value&lt;/code&gt;.</source>
          <target state="translated">값으로 시작하고 &lt;code&gt;++value&lt;/code&gt; 반복적으로 평가 하면서 &lt;code&gt;value&lt;/code&gt; 을 순차적으로 증가시켜 &lt;code&gt;[first, last)&lt;/code&gt; 범위를 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="ae117132b523ad7bbcabf063e4512b94303ad825" translate="yes" xml:space="preserve">
          <source>Final classes cannot be used as base classes.</source>
          <target state="translated">최종 수업은 기본 수업으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f71bda78a1e6997b4c579d61039ab383458a0b93" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;awaiter.await_resume()&lt;/code&gt; is called, and its result is the result of the whole &lt;code&gt;co_await expr&lt;/code&gt; expression.</source>
          <target state="translated">마지막으로 &lt;code&gt;awaiter.await_resume()&lt;/code&gt; 이 호출되고 결과는 전체 &lt;code&gt;co_await expr&lt;/code&gt; 표현식 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="4db4903bd597b61dd8a328899682e291be0a76a1" translate="yes" xml:space="preserve">
          <source>Finally, calls &lt;code&gt;is.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">마지막으로 &lt;code&gt;is.width(0)&lt;/code&gt; 을 호출 하여 &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 의 영향을 취소합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="9e4015259c16ae5de63c7894d2c7b391c4ca0b80" translate="yes" xml:space="preserve">
          <source>Finally, calls &lt;code&gt;os.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">마지막으로 &lt;code&gt;os.width(0)&lt;/code&gt; 을 호출 하여 &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 의 영향을 취소합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="177dc3f32e13dff30c58fffec60fe61e244cc93e" translate="yes" xml:space="preserve">
          <source>Finally, outputs each character from the resulting sequence as if by calling &lt;code&gt;out.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(out.width(), seq.size())&lt;/code&gt; and &lt;code&gt;out.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">마지막으로 &lt;code&gt;out.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; 을 호출하여 결과 시퀀스에서 각 문자를 출력합니다 . 여기서 &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(out.width(), seq.size())&lt;/code&gt; 및 &lt;code&gt;out.width(0)&lt;/code&gt; 의 효과를 취소하려면 &lt;code&gt;&lt;a href=&quot;setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 있는 경우.</target>
        </trans-unit>
        <trans-unit id="00d858cc8e88f691053b3dcc6137ac4cde6d6ced" translate="yes" xml:space="preserve">
          <source>Finds an element equal to element pointed to by &lt;code&gt;key&lt;/code&gt; in an array pointed to by &lt;code&gt;ptr&lt;/code&gt;. The array contains &lt;code&gt;count&lt;/code&gt; elements of &lt;code&gt;size&lt;/code&gt; bytes each and must be partitioned with respect to the object pointed to by &lt;code&gt;key&lt;/code&gt;, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 가리키는 배열에서 &lt;code&gt;key&lt;/code&gt; 가 가리키는 요소와 동일한 요소를 찾습니다 . 배열은 각각 &lt;code&gt;size&lt;/code&gt; 바이트 의 &lt;code&gt;count&lt;/code&gt; 요소를 포함 하며 &lt;code&gt;key&lt;/code&gt; 로 가리키는 객체 , 즉 비교하는 모든 요소보다 같지 않은 모든 요소 앞에 나타나야하며, 모든 요소 앞에 나타나야합니다. 키 객체보다 큰 요소 완전히 정렬 된 어레이는 이러한 요구 사항을 충족시킵니다. &lt;code&gt;comp&lt;/code&gt; 가 가리키는 함수를 사용하여 요소를 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="e9927a1e661f4bfd80aaf31b22f6f41e30e9b227" translate="yes" xml:space="preserve">
          <source>Finds real roots of multiple quadratic equations.</source>
          <target state="translated">여러 이차 방정식의 실제 근을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="30bcbdf5d9a1fe0bd647e009803f909f56efc575" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to any of the characters in the given character sequence.</source>
          <target state="translated">주어진 문자 시퀀스의 문자와 동일한 첫 번째 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="5cdb4e092b97109f8b2048be07ca72c3bde0609f" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to none of the characters in the given character sequence. The search considers only the interval [&lt;code&gt;pos&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;). If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">주어진 문자 순서에서 문자가없는 첫 번째 문자를 찾습니다. 검색에서는 간격 [ &lt;code&gt;pos&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; ) 만 고려합니다 . 간격에 문자가 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="24f9fbec876cfd13c75d96d81a6a74110daac9d5" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to one of the characters in the given character sequence. The search considers only the interval [&lt;code&gt;pos&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;). If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">주어진 문자 순서에서 문자 중 하나와 동일한 첫 번째 문자를 찾습니다. 검색에서는 간격 [ &lt;code&gt;pos&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; ) 만 고려합니다 . 간격에 문자가 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a02ae1c73392d3f6a41d7039bf6f66883821f319" translate="yes" xml:space="preserve">
          <source>Finds the first character in wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that is also in wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981d0030e7019507414199bd0e078d7265cd8673" translate="yes" xml:space="preserve">
          <source>Finds the first character not equal to any of the characters in the given character sequence.</source>
          <target state="translated">주어진 문자 순서에서 문자와 같지 않은 첫 번째 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="c744c8fe55a01d138ec8c24e1528aec65ec2023a" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the byte string &lt;code&gt;target&lt;/code&gt; in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 바이트 문자열에서 바이트 문자열 &lt;code&gt;target&lt;/code&gt; 의 첫 항목을 찾습니다 . 종료 널 문자는 비교되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="822e0508dd7e5034ad40e0d29a486e2402585a0d" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the character &lt;code&gt;static_cast&amp;lt;char&amp;gt;(ch)&lt;/code&gt; in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 바이트 문자열에서 문자 &lt;code&gt;static_cast&amp;lt;char&amp;gt;(ch)&lt;/code&gt; 가 처음 나타나는 것을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="9388d73210fb9a6adcc18de249cc87e2da6d4106" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60954d9dde97ea95b47805de626af5f9bb89a11c" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide string &lt;code&gt;src&lt;/code&gt; in the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc71329dcb9337103dd5851e9eb7dfa903cd2767" translate="yes" xml:space="preserve">
          <source>Finds the first substring equal to the given character sequence.</source>
          <target state="translated">주어진 문자 순서와 동일한 첫 번째 부분 문자열을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="73d8f05c9748bf0bddfc6937b1e51af871f089f0" translate="yes" xml:space="preserve">
          <source>Finds the first substring equal to the given character sequence. Search begins at &lt;code&gt;pos&lt;/code&gt;, i.e. the found substring must not begin in a position preceding &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">주어진 문자 순서와 동일한 첫 번째 부분 문자열을 찾습니다. 검색은 &lt;code&gt;pos&lt;/code&gt; 에서 시작합니다. 즉, 찾은 하위 문자열은 &lt;code&gt;pos&lt;/code&gt; 이전 위치 에서 시작하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="d519b8e547c2fea611a706cf0f567de8c481f047" translate="yes" xml:space="preserve">
          <source>Finds the greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위에서 가장 큰 요소를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="2a0eba935882bc5c40f3eb57edca9ffaa6207e17" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to none of the characters in the given character sequence. The search considers only the interval [0, pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">주어진 문자 순서에서 문자가없는 마지막 문자를 찾습니다. 검색에서는 간격 [0, pos] 만 고려합니다. 간격에 문자가 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="031b5bc7f5b52d9b68f531ec16e07add0732f8a9" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to one of characters in the given character sequence. Exact search algorithm is not specified. The search considers only the interval [0; pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">주어진 문자 순서에서 문자 중 하나와 동일한 마지막 문자를 찾습니다. 정확한 검색 알고리즘이 지정되지 않았습니다. 검색은 구간 [0; 위치]. 간격에 문자가 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="262672fc83487a5e2f2a3a72605026935426490e" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the interval [0, pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">주어진 문자 순서에서 문자 중 하나와 동일한 마지막 문자를 찾습니다. 정확한 검색 알고리즘이 지정되지 않았습니다. 검색에서는 간격 [0, pos] 만 고려합니다. 간격에 문자가 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c2eeb42fd9c4368ca6e261a7eaf0eb9173c9ca19" translate="yes" xml:space="preserve">
          <source>Finds the last character not equal to any of the characters in the given character sequence.</source>
          <target state="translated">주어진 문자 순서에서 문자와 같지 않은 마지막 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="c9e927921904e1bd8a7847a95ec12dfc3ed90fd5" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;char&lt;/code&gt;) in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 바이트 문자열에서 마지막으로 나타나는 &lt;code&gt;ch&lt;/code&gt; ( &lt;code&gt;char&lt;/code&gt; 로 변환 한 후)를 찾습니다 . 종료 널 문자는 문자열의 일부로 간주되며 &lt;code&gt;'\0'&lt;/code&gt; 검색하면 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abb2c2feff5f0426d0ef85cddeeca9860311e3e9" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba2a0477e061745abafbf2e570698649cfbd049" translate="yes" xml:space="preserve">
          <source>Finds the last substring equal to the given character sequence.</source>
          <target state="translated">주어진 문자 순서와 같은 마지막 부분 문자열을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="85ecfa172af6c676f0f2b7ede4563bdf54dbd13d" translate="yes" xml:space="preserve">
          <source>Finds the last substring equal to the given character sequence. Search begins at &lt;code&gt;pos&lt;/code&gt;, i.e. the found substring must not begin in a position following &lt;code&gt;pos&lt;/code&gt;. If &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; or any value not smaller than &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;-1 is passed as &lt;code&gt;pos&lt;/code&gt;, whole string will be searched.</source>
          <target state="translated">주어진 문자 순서와 같은 마지막 부분 문자열을 찾습니다. 검색은 &lt;code&gt;pos&lt;/code&gt; 에서 시작합니다. 즉, 찾은 하위 문자열은 &lt;code&gt;pos&lt;/code&gt; 다음 위치 에서 시작하면 안됩니다 . 경우 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 또는보다 작은 값 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; -1로 전달되는 &lt;code&gt;pos&lt;/code&gt; , 전체 문자열이 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="4e96707b2590ca4719626a87f0675c2693cd9371" translate="yes" xml:space="preserve">
          <source>Finds the next token in a null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated byte string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 로 가리키는 null로 끝나는 바이트 문자열에서 다음 토큰을 찾습니다 . 구분 기호 문자는 &lt;code&gt;delim&lt;/code&gt; 이 가리키는 null로 끝나는 바이트 문자열로 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="380ef08d0f8e6c7597e5b529abb1fb2b2ba51aa4" translate="yes" xml:space="preserve">
          <source>Finds the next token in a null-terminated wide string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated wide string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 로 가리키는 널 종료 와이드 문자열에서 다음 토큰을 찾습니다 . 구분 기호 문자는 널로 끝나는 넓은 문자열 ( &lt;code&gt;delim&lt;/code&gt; 이 가리키는)로 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="59f9527a2060df058f520ec4facfb5d116cfb5ab" translate="yes" xml:space="preserve">
          <source>Finds the smallest and greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위에서 가장 작고 큰 요소를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="73f7ebc728f72e9244fbcb71e4bebffbcaa8c095" translate="yes" xml:space="preserve">
          <source>Finds the smallest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위에서 가장 작은 요소를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="fb4718767cbeb7ec2a4050ea8b0704c79bba10d8" translate="yes" xml:space="preserve">
          <source>First clears &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;eofbit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">먼저 &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;eofbit&lt;/code&gt; 를&lt;/a&gt; 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="c779ca82cc21b768cc6c4bcc4f1d87107bdb7d29" translate="yes" xml:space="preserve">
          <source>First clears &lt;code&gt;eofbit&lt;/code&gt;, then behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, if &lt;code&gt;rdbuf()&lt;/code&gt; is not null, calls &lt;code&gt;rdbuf()-&amp;gt;sputbackc(ch)&lt;/code&gt;, which calls &lt;code&gt;rdbuf()-&amp;gt;pbackfail(ch)&lt;/code&gt; if &lt;code&gt;ch&lt;/code&gt; does not equal the most recently extracted character.</source>
          <target state="translated">먼저 &lt;code&gt;eofbit&lt;/code&gt; 를 지우고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 동작 합니다 . 건설 및 경우 보초 개체를 확인 후 &lt;code&gt;rdbuf()&lt;/code&gt; null가 아닌, 호출 &lt;code&gt;rdbuf()-&amp;gt;sputbackc(ch)&lt;/code&gt; 호출하는, &lt;code&gt;rdbuf()-&amp;gt;pbackfail(ch)&lt;/code&gt; 경우 &lt;code&gt;ch&lt;/code&gt; 가장 최근에 추출 된 문자를 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13f51e93c18a65140da3cb2cb1dfab78c49243a0" translate="yes" xml:space="preserve">
          <source>First destroys the current contained object (if any) by &lt;code&gt;&lt;a href=&quot;reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt;, then:</source>
          <target state="translated">먼저 &lt;code&gt;&lt;a href=&quot;reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; 현재 포함 된 객체 (있는 경우 ) 를 삭제 한 후 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="401e859548baba3ec799317e533e96d7551f1830" translate="yes" xml:space="preserve">
          <source>First version</source>
          <target state="translated">첫 번째 버전</target>
        </trans-unit>
        <trans-unit id="1654933a6fa4f43716580ffeb045cae1b208fe38" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;implicit_cast&quot;&gt;Pointer conversions&lt;/a&gt; (pointer to member conversions if the arguments are pointers to members), function pointer conversions,(since C++17) and &lt;a href=&quot;implicit_cast&quot;&gt;qualification conversions&lt;/a&gt; are applied to both operands to obtain the</source>
          <target state="translated">먼저, &lt;a href=&quot;implicit_cast&quot;&gt;포인터 변환&lt;/a&gt; (인수가 멤버에 대한 포인터 인 경우 포인터에서 멤버로의 변환), 함수 포인터 변환 (C ++ 17부터) 및 &lt;a href=&quot;implicit_cast&quot;&gt;자격 변환&lt;/a&gt; 이 두 피연산자에 적용되어</target>
        </trans-unit>
        <trans-unit id="30c242bb4e4e1c97688da86303f8e70ebf723f0f" translate="yes" xml:space="preserve">
          <source>First, allocates or resizes the private storage (dynamic array of &lt;code&gt;long&lt;/code&gt; or another indexable data structure) sufficiently to make &lt;code&gt;index&lt;/code&gt; a valid index, then returns a reference to the &lt;code&gt;long&lt;/code&gt; element of the private storage with the index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">우선, 할당 또는 전용 스토리지 (동적 배열 크기를 조절 &lt;code&gt;long&lt;/code&gt; 또는 다른 교환 형 데이터 구조)를 충분히 만들 &lt;code&gt;index&lt;/code&gt; 다음의 참조를 반환 유효한 인덱스 &lt;code&gt;long&lt;/code&gt; 인덱스와 전용 스토리지 엘리먼트 &lt;code&gt;index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c741d459f4a943d6ccb7e91f1d19877e2b46cf15" translate="yes" xml:space="preserve">
          <source>First, allocates or resizes the private storage (dynamic array of &lt;code&gt;void*&lt;/code&gt; or another indexable data structure) sufficiently to make &lt;code&gt;index&lt;/code&gt; a valid index, then returns a reference to the &lt;code&gt;void*&lt;/code&gt; element of the private storage with the index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">먼저 &lt;code&gt;index&lt;/code&gt; 를 유효한 인덱스 로 만들기에 충분할 정도로 개인용 스토리지 ( &lt;code&gt;void*&lt;/code&gt; 또는 다른 색인 가능한 데이터 구조 의 동적 배열)를 할당하거나 크기를 조정 한 다음 index &lt;code&gt;index&lt;/code&gt; 로 개인용 스토리지 의 &lt;code&gt;void*&lt;/code&gt; 요소에 대한 참조를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f1a406a5e11adcba583e47ceded69c0a59895e04" translate="yes" xml:space="preserve">
          <source>First, attempts to close the file associated with &lt;code&gt;stream&lt;/code&gt;, ignoring any errors. Then, if &lt;code&gt;filename&lt;/code&gt; is not null, attempts to open the file specified by &lt;code&gt;filename&lt;/code&gt; using &lt;code&gt;mode&lt;/code&gt; as if by &lt;code&gt;fopen&lt;/code&gt;, and associates that file with the file stream pointed to by &lt;code&gt;stream&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is a null pointer, then the function attempts to reopen the file that is already associated with &lt;code&gt;stream&lt;/code&gt; (it is implementation defined which mode changes are allowed in this case).</source>
          <target state="translated">먼저, &lt;code&gt;stream&lt;/code&gt; 과 관련된 파일을 닫고 오류를 무시합니다. 경우, &lt;code&gt;filename&lt;/code&gt; null이 아닌, 시도에 의해 지정된 파일 열려면 &lt;code&gt;filename&lt;/code&gt; 사용하여 &lt;code&gt;mode&lt;/code&gt; 마치로 &lt;code&gt;fopen&lt;/code&gt; 을 하고, 동료 파일 스트림과 파일이 가리키는 것을 &lt;code&gt;stream&lt;/code&gt; . 경우 &lt;code&gt;filename&lt;/code&gt; NULL 포인터이고, 그 기능이 이미 시도와 연관되는 파일 재개 &lt;code&gt;stream&lt;/code&gt; (는 모드 변경이 경우 허용 정의 구현).</target>
        </trans-unit>
        <trans-unit id="5badc51c36e2585292a914e3f1823ec376257caf" translate="yes" xml:space="preserve">
          <source>First, before doing anything else, obtains type and permissions of &lt;code&gt;from&lt;/code&gt; by no more than a single call to</source>
          <target state="translated">첫째, 다른 작업을 수행하기 전에, 유형 및 사용 권한을 취득하지 &lt;code&gt;from&lt;/code&gt; 한 번 호출보다 더에 의해</target>
        </trans-unit>
        <trans-unit id="bd0a7f661657d89c37e4c1215e80d0191bb4862d" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt; to transmit all pending output (and delayed flush, if any) to the wrapped stream.</source>
          <target state="translated">먼저 &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 보류중인 모든 출력 (및 지연된 플러시가있는 경우)을 래핑 된 스트림으로 전송합니다.</target>
        </trans-unit>
        <trans-unit id="eab9bd2628b9d318b166ebaf056d0f32c1ae9059" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;. If an exception is thrown by the call to &lt;code&gt;emit()&lt;/code&gt;, it is caught and ignored.</source>
          <target state="translated">먼저 &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; 호출합니다 . &lt;code&gt;emit()&lt;/code&gt; 호출로 예외가 발생하면 포착되고 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="daac23b0d5c1b3ef73330f0f556ea905967387b5" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;. If an exception is thrown by the call to &lt;code&gt;emit()&lt;/code&gt;, it is caught and ignored. Then, destroys the member &lt;code&gt;std::basic_syncbuf&lt;/code&gt; and the base &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; as usual.</source>
          <target state="translated">먼저 &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; 호출합니다 . &lt;code&gt;emit()&lt;/code&gt; 호출로 예외가 발생하면 포착되고 무시됩니다. 그런 다음 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 와 같이 std :: basic_syncbuf 멤버 와 기본 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="99f9e198aa798816c58da32cfc0095d286931e68" translate="yes" xml:space="preserve">
          <source>First, clears the error bits in &lt;code&gt;err&lt;/code&gt; by executing &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt;. Then reads characters from the input sequence &lt;code&gt;[beg, end)&lt;/code&gt; that are expected by the &lt;code&gt;&lt;a href=&quot;../time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; format specifier formed by combining &lt;code&gt;'%'&lt;/code&gt;, &lt;code&gt;modifier&lt;/code&gt; (if not &lt;code&gt;'\0'&lt;/code&gt;), and &lt;code&gt;format&lt;/code&gt;. If the characters do not combine to form a valid conversion specifier, sets &lt;code&gt;failbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If the end of the input stream is reached after reading a character, sets &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If the input string was parsed successfully, updates the corresponding fields of &lt;code&gt;*t&lt;/code&gt;.   For complex conversion specifiers, such as &lt;code&gt;'%x'&lt;/code&gt; or &lt;code&gt;'%c'&lt;/code&gt;, or the directives that use the modifiers &lt;code&gt;'E'&lt;/code&gt; and &lt;code&gt;'O'&lt;/code&gt;, the function may fail to determine some of the values to store in &lt;code&gt;*t&lt;/code&gt;. In such case, it sets &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt; and leaves these fields in unspecified state.</source>
          <target state="translated">먼저의 에러 비트 클리어 &lt;code&gt;err&lt;/code&gt; 실행함으로써 &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; . 그런 다음 &lt;code&gt;'%'&lt;/code&gt; , &lt;code&gt;modifier&lt;/code&gt; ( &lt;code&gt;'\0'&lt;/code&gt; 아닌 경우 ) 및 &lt;code&gt;format&lt;/code&gt; 을 결합하여 형성된 &lt;code&gt;&lt;a href=&quot;../time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; 형식 지정 자가 예상 하는 입력 시퀀스 &lt;code&gt;[beg, end)&lt;/code&gt; 에서 문자를 읽습니다 . 문자가 결합하여 유효한 변환 지정자를 형성하지 않으면 &lt;code&gt;err&lt;/code&gt; 에 &lt;code&gt;failbit&lt;/code&gt; 를 설정 하십시오 . 문자를 읽은 후 입력 스트림의 끝에 도달하면 &lt;code&gt;eofbit&lt;/code&gt; 를 &lt;code&gt;err&lt;/code&gt; 로 설정하십시오 . 입력 문자열이 성공적으로 구문 분석 된 경우 해당 필드를 업데이트합니다. &lt;code&gt;*t&lt;/code&gt; . &lt;code&gt;'%x'&lt;/code&gt; 또는 &lt;code&gt;'%c'&lt;/code&gt; 와 같은 복잡한 변환 지정자 또는 수정 자 &lt;code&gt;'E'&lt;/code&gt; 및 &lt;code&gt;'O'&lt;/code&gt; 를 사용하는 지시문의 경우 함수는 &lt;code&gt;*t&lt;/code&gt; 에 저장할 일부 값을 결정하지 못할 수 있습니다 . 이 경우 &lt;code&gt;eofbit&lt;/code&gt; 를 &lt;code&gt;err&lt;/code&gt; 로 설정 하고이 필드를 지정되지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="761e411f45989f18b8cdc09dfae5d408bc3760bb" translate="yes" xml:space="preserve">
          <source>First, expr is converted to an awaitable as follows:</source>
          <target state="translated">먼저 expr은 다음과 같이 대기 가능한 것으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="49e86d447ef30f5d8ac55d11082a293ce491a304" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, performs the ISO/IEC/IEEE 60559</source>
          <target state="translated">먼저 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 ISO / IEC / IEEE 60559를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="714bfffed5c4d1159d21c2074b0dd5ebd28587dd" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;T&lt;/code&gt; is a class type and the initializer is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; expression whose cv-unqualified type is the same class as &lt;code&gt;T&lt;/code&gt;, the initializer expression itself, rather than a temporary materialized from it, is used to initialize the destination object: see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;</source>
          <target state="translated">첫째, 경우 &lt;code&gt;T&lt;/code&gt; 는 클래스 타입과 초기화가있다 &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; 그의 이력서 - 자격이 형 같은 클래스 인 표현 &lt;code&gt;T&lt;/code&gt; 임시 그것에서 구체화하기보다는, 이니셜 표현 자체가 대상 개체를 초기화하는 데 사용됩니다 참조 &lt;a href=&quot;copy_elision&quot;&gt;사본을 생략&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a19b536bb9ed4bb6c617709d11bbfa515bb05a0" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;root_name() != base.root_name() || is_absolute() != base.is_absolute() || (!has_root_directory() &amp;amp;&amp;amp; base.has_root_directory())&lt;/code&gt;, returns a default-constructed path.</source>
          <target state="translated">먼저 &lt;code&gt;root_name() != base.root_name() || is_absolute() != base.is_absolute() || (!has_root_directory() &amp;amp;&amp;amp; base.has_root_directory())&lt;/code&gt; 는 기본 구성 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0af0623ac822520c62720be6f5b81d9ab7f82065" translate="yes" xml:space="preserve">
          <source>First, records that a flush is pending, by updating the appropriate private flag.</source>
          <target state="translated">먼저 적절한 개인 플래그를 업데이트하여 플러시가 보류 중임을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="a3dedc18a8aa37448d34180fda53b30fdca03e04" translate="yes" xml:space="preserve">
          <source>First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt;), then raises the floating-point exceptions that were saved.</source>
          <target state="translated">먼저 현재 발생한 부동 소수점 예외를 기억 한 다음 &lt;code&gt;envp&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt; 와 유사)가 가리키는 객체에서 부동 소수점 환경을 복원 한 다음 저장된 부동 소수점 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f26f81a265113be2257dfeddeb17e46ef91bc7df" translate="yes" xml:space="preserve">
          <source>First, retrieve the outermost allocator &lt;code&gt;OUTERMOST&lt;/code&gt; by calling &lt;code&gt;this-&amp;gt;outer_allocator()&lt;/code&gt;, and then calling the &lt;code&gt;outer_allocator()&lt;/code&gt; member function recursively on the result of this call until reaching an allocator that has no such member function.</source>
          <target state="translated">먼저 &lt;code&gt;this-&amp;gt;outer_allocator()&lt;/code&gt; 를 호출 한 다음 해당 멤버 함수가없는 할당 자에 도달 할 때까지이 호출 결과 에서 &lt;code&gt;outer_allocator()&lt;/code&gt; 멤버 함수를 재귀 적으로 호출 하여 가장 바깥 쪽 할당 자 &lt;code&gt;OUTERMOST&lt;/code&gt; 를 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="b22ed5216bdf7ab4edb25ec8436348da2427fb87" translate="yes" xml:space="preserve">
          <source>First, saves the current floating-point environment to the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fegetenv&lt;/a&gt;&lt;/code&gt;), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">먼저, 현재 부동 소수점 환경을 &lt;code&gt;envp&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fegetenv&lt;/a&gt;&lt;/code&gt; 와 유사)가 가리키는 객체에 저장 한 다음 모든 부동 소수점 상태 플래그를 지우고 논스톱 모드를 설치합니다. 향후 부동 소수점 예외는 발생하지 않습니다. 부동 소수점 환경에 의해 복구 될 때까지 인터럽트 실행 (트랩 않음) &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19ae2c760d73ee6a549348974c9ddff8cc5fef2c" translate="yes" xml:space="preserve">
          <source>First, set each element of the output range to the value &lt;code&gt;0x8b8b8b8b&lt;/code&gt;</source>
          <target state="translated">먼저 출력 범위의 각 요소를 &lt;code&gt;0x8b8b8b8b&lt;/code&gt; 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="37c02899047a91960018379b0f4a7201e2a7714f" translate="yes" xml:space="preserve">
          <source>First, the argument-dependent lookup is not considered if the lookup set produced by usual &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; contains any of the following:</source>
          <target state="translated">먼저, &lt;a href=&quot;lookup&quot;&gt;정규화되지 않은 조회에서&lt;/a&gt; 생성 된 조회 세트 에 다음 중 하나가 포함되어 있으면 인수 종속 조회가 고려되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="71da67e0b30adfe6e4f96fe9e13991f6f8a033f3" translate="yes" xml:space="preserve">
          <source>Firstly, if this path has an &lt;a href=&quot;extension&quot;&gt;&lt;code&gt;extension()&lt;/code&gt;&lt;/a&gt;, it is removed from the generic-format view of the pathname.</source>
          <target state="translated">먼저,이 경로에 &lt;a href=&quot;extension&quot;&gt; &lt;code&gt;extension()&lt;/code&gt; &lt;/a&gt; 이 있으면 경로 이름의 일반 형식보기에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d24ff9bf0ed02a5411428beac3e4bd1d30fe9f46" translate="yes" xml:space="preserve">
          <source>Five &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;span&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;span&lt;/code&gt; 위해 5 개의 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="27e98ae5f197207336755cc33861b5d103faad58" translate="yes" xml:space="preserve">
          <source>Fixed width integer types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96f6d996f06dc7144585656dcc077cf300a6377" translate="yes" xml:space="preserve">
          <source>Fixed width integer types (since C++11)</source>
          <target state="translated">고정 너비 정수 유형 (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="0a6c931f357cf026414e375b77b04d8235b7334d" translate="yes" xml:space="preserve">
          <source>Flag type and operations</source>
          <target state="translated">플래그 유형 및 작업</target>
        </trans-unit>
        <trans-unit id="27cbb35a9b1b271932f7636ca4faaede088277a2" translate="yes" xml:space="preserve">
          <source>Flips bits, i.e. changes &lt;code&gt;true&lt;/code&gt; values to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; values to &lt;code&gt;true&lt;/code&gt;. Equivalent to a logical NOT operation on part or all of the bitset.</source>
          <target state="translated">비트를 뒤집습니다. 즉, &lt;code&gt;true&lt;/code&gt; 값을 &lt;code&gt;false&lt;/code&gt; 로 , &lt;code&gt;false&lt;/code&gt; 값을 &lt;code&gt;true&lt;/code&gt; 로 변경 합니다 . 일부 또는 모든 비트 세트의 논리적 NOT 연산과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5dfec7a1df7a1c20eb6ca15e9bee0c75b291919" translate="yes" xml:space="preserve">
          <source>Floating point literal defines a compile-time constant whose value is specified in the source file.</source>
          <target state="translated">부동 소수점 리터럴은 소스 파일에 값이 지정된 컴파일 타임 상수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="530b771e0a4d9da8f37e390916e11d1da9b65536" translate="yes" xml:space="preserve">
          <source>Floating point manipulation functions</source>
          <target state="translated">부동 소수점 조작 기능</target>
        </trans-unit>
        <trans-unit id="4cdfaff55d21c2eb1c0a0dbeace3c9c4e378eda8" translate="yes" xml:space="preserve">
          <source>Floating point types</source>
          <target state="translated">부동 소수점 유형</target>
        </trans-unit>
        <trans-unit id="931a4d33f9a7670df77e53c7e39d2883c52b8c58" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned and *str_end is set to str.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 부동 소수점 값 . 변환 된 값이 해당 반환 유형의 범위를 벗어나면 범위 오류가 발생하고 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; 이 반환됩니다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환되고 * str_end이 STR로 설정된다.</target>
        </trans-unit>
        <trans-unit id="5679c54758fee21d770fd6c545d0c43032628157" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f57b6272c09794ad846fa25baa135845cf2031" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the &amp;mu; distribution parameter.</source>
          <target state="translated">&amp;mu; 분포 모수를 식별하는 부동 소수점 값.</target>
        </trans-unit>
        <trans-unit id="9a1cf11d8c926cc9f1bbac062621307bdc11199f" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the degrees of freedom of the distribution.</source>
          <target state="translated">분포의 자유도를 식별하는 부동 소수점 값.</target>
        </trans-unit>
        <trans-unit id="a725365fc9cc7788cab748ff13281e3d748d0017" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the p distribution parameter.</source>
          <target state="translated">p 분포 모수를 식별하는 부동 소수점 값.</target>
        </trans-unit>
        <trans-unit id="3bfd050a822b215062fc674739b968774ba30a01" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the rate of events per unit.</source>
          <target state="translated">단위당 이벤트 비율을 식별하는 부동 소수점 값.</target>
        </trans-unit>
        <trans-unit id="5c65e500905d168962e036e5e1c8cfd585b5a35a" translate="yes" xml:space="preserve">
          <source>Floating point value in range [0, 1).</source>
          <target state="translated">[0, 1) 범위의 부동 소수점 값.</target>
        </trans-unit>
        <trans-unit id="a4edd9f5da9c5bff6fa7351be1698e5f17713a8e" translate="yes" xml:space="preserve">
          <source>Floating&amp;ndash;integral conversions</source>
          <target state="translated">부동-적분 변환</target>
        </trans-unit>
        <trans-unit id="fe4d2e99025a6ead51e9b2e632c32efaa3c94a25" translate="yes" xml:space="preserve">
          <source>Floating-point contraction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a694704378ed350bc958fb519c8315b5d52a02b7" translate="yes" xml:space="preserve">
          <source>Floating-point conversions</source>
          <target state="translated">부동 소수점 변환</target>
        </trans-unit>
        <trans-unit id="037c72279324a50181c71503f07e7e0083f1c23d" translate="yes" xml:space="preserve">
          <source>Floating-point environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc13961bdda58d06692a8ad8f8156b2841512415" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may have greater range and precision than indicated by their types, see &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;. Floating-point expressions may also be</source>
          <target state="translated">부동 소수점 표현식은 유형으로 표시된 것보다 더 큰 범위와 정밀도를 가질 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 참조) . 부동 소수점 표현식도</target>
        </trans-unit>
        <trans-unit id="0e05b4ea4725d83345dcb31354835a769615b781" translate="yes" xml:space="preserve">
          <source>Floating-point promotion</source>
          <target state="translated">부동 소수점 프로모션</target>
        </trans-unit>
        <trans-unit id="f74d231baa71e2a641e3234ad91f55a94e0aa7a0" translate="yes" xml:space="preserve">
          <source>Floating-point types may support &lt;a href=&quot;../types/numeric_limits&quot;&gt;special values&lt;/a&gt;:</source>
          <target state="translated">부동 소수점 유형은 &lt;a href=&quot;../types/numeric_limits&quot;&gt;특수 값을&lt;/a&gt; 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a26e00b84e77b40bea4bb511f8f60ed076daa97b" translate="yes" xml:space="preserve">
          <source>Flowing off the end of a value-returning function (except &lt;code&gt;main&lt;/code&gt;) without a return statement is undefined behavior.</source>
          <target state="translated">return 문없이 value-returning 함수 ( &lt;code&gt;main&lt;/code&gt; 제외 ) 의 끝에서 벗어나는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="6666b9fcba2b772c274346c92162b6c1a3611ada" translate="yes" xml:space="preserve">
          <source>Flushes the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.flush()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os.flush()&lt;/code&gt; 를 호출 하여 출력 시퀀스 &lt;code&gt;os&lt;/code&gt; 를 플러시합니다 .</target>
        </trans-unit>
        <trans-unit id="9cdb990f130f6549318c7c3b84780625f76de3f4" translate="yes" xml:space="preserve">
          <source>Flushes the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.flush()&lt;/code&gt;. Then, if &lt;code&gt;os.rdbuf()&lt;/code&gt; actually points to a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt;&lt;code&gt;buf&lt;/code&gt;, calls &lt;code&gt;buf.emit()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os.flush()&lt;/code&gt; 를 호출 하여 출력 시퀀스 &lt;code&gt;os&lt;/code&gt; 를 플러시합니다 . 그런 다음 &lt;code&gt;os.rdbuf()&lt;/code&gt; 실제로 &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt; &amp;lt;CharT, Traits, Allocator&amp;gt; &lt;code&gt;buf&lt;/code&gt; 를 &lt;code&gt;buf.emit()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d4727f15c3dadc6abc3267b67039a85b366a9aeb" translate="yes" xml:space="preserve">
          <source>Flushing is performed in the destructor of the &lt;code&gt;&lt;a href=&quot;../basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; object, which calls &lt;code&gt;str.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; if &lt;code&gt;str.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt; == true&lt;/code&gt;.</source>
          <target state="translated">플러싱은 &lt;code&gt;&lt;a href=&quot;../basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; 객체 의 소멸자에서 수행되며 &lt;code&gt;str.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt; == true&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: unitbuf&lt;/a&gt; == true 인 경우 str.rdbuf () &lt;code&gt;str.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="dd2e024a054d8c1876c1f1a73eab175647867cec" translate="yes" xml:space="preserve">
          <source>Fold expressions</source>
          <target state="translated">배 표현</target>
        </trans-unit>
        <trans-unit id="820f688950b36fa22a06159885b2b0b589f17953" translate="yes" xml:space="preserve">
          <source>Fold-expressions</source>
          <target state="translated">Fold-expressions</target>
        </trans-unit>
        <trans-unit id="73ea87451f9d5e42c6d3450b515bcb3f98250b83" translate="yes" xml:space="preserve">
          <source>Follow rather than skip directory symlinks.</source>
          <target state="translated">디렉토리 심볼릭 링크를 건너 뛰지 말고 따르십시오.</target>
        </trans-unit>
        <trans-unit id="c9eac869d3c658b081e1a95ca062116b32f0aaa4" translate="yes" xml:space="preserve">
          <source>Follow symlinks (default behavior)</source>
          <target state="translated">심볼릭 링크 따르기 (기본 동작)</target>
        </trans-unit>
        <trans-unit id="9d728e94fbab96a42d3b4d9a6cb222f5e938822e" translate="yes" xml:space="preserve">
          <source>Following exposition-only concepts are used for several types, but they are not parts of the interface of standard library.</source>
          <target state="translated">다음 박람회 전용 개념은 여러 유형에 사용되지만 표준 라이브러리 인터페이스의 일부는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6f40e40d82fd8846da49808b0b708490ce0379e1" translate="yes" xml:space="preserve">
          <source>Following member functions are conditionally different from corresponding member functions of &lt;code&gt;&lt;a href=&quot;../utility/optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 멤버 함수는 &lt;code&gt;&lt;a href=&quot;../utility/optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; 의 해당 멤버 함수와 조건 적으로 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="2eedcffa258b92b2d623f330307d6610480c73b1" translate="yes" xml:space="preserve">
          <source>For (1), &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">(1)의 경우 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; 는 &lt;code&gt;Types&lt;/code&gt; 의 모든 &lt;code&gt;T_i&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="27e932e63be3980babb2b5c3e1834eb9ece2f5cb" translate="yes" xml:space="preserve">
          <source>For (1),&lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">(1)의 경우 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; 는 모두 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cce1fc39ab817dad0417c749a97b121fa9da8698" translate="yes" xml:space="preserve">
          <source>For (1-3), if the result would be outside the range [0, 255], the actual stored value is unspecified.</source>
          <target state="translated">(1-3)의 경우 결과가 [0, 255] 범위를 벗어나면 실제 저장된 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80750dcb6fca71c81371e8509ae0e5a32ea184f9" translate="yes" xml:space="preserve">
          <source>For (2), &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">(2)의 경우 &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; 는 &lt;code&gt;Types&lt;/code&gt; 의 모든 &lt;code&gt;T_i&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="cf60873df305a2582da8245d9a95bc5dabb1f1c1" translate="yes" xml:space="preserve">
          <source>For (2),&lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">(2)의 경우 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; 는 모두 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e266ee47c94d97b82af99ef255fd0f260a99d2c" translate="yes" xml:space="preserve">
          <source>For (3), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, const U_i&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all corresponding pairs of types &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt; and &lt;code&gt;U_i&lt;/code&gt; in &lt;code&gt;UTypes&lt;/code&gt;.</source>
          <target state="translated">(3) &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, const U_i&amp;amp;&amp;gt;::value&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 모든 종류의 대응 쌍 &lt;code&gt;T_i&lt;/code&gt; 의 &lt;code&gt;Types&lt;/code&gt; 및 &lt;code&gt;U_i&lt;/code&gt; 에 &lt;code&gt;UTypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="235c0ae5251a55b5cc4853b6e31b390a6d489d01" translate="yes" xml:space="preserve">
          <source>For (3),&lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">(3)의 경우 &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; 는 모두 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c23beb9ab1e1686d723073f239e4dd5ad833ba8" translate="yes" xml:space="preserve">
          <source>For (4), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, U_i&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all corresponding pairs of types &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt; and &lt;code&gt;U_i&lt;/code&gt; in &lt;code&gt;UTypes&lt;/code&gt;.</source>
          <target state="translated">(4) 용 &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, U_i&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 모든 유형의 대응 쌍 &lt;code&gt;T_i&lt;/code&gt; 의 &lt;code&gt;Types&lt;/code&gt; 및 &lt;code&gt;U_i&lt;/code&gt; 에 &lt;code&gt;UTypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d612fce9fe1d1b17e3a906128095373ba91170e6" translate="yes" xml:space="preserve">
          <source>For (4),&lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">(4)의 경우 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 는 모두 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6dc7376755e98b71c2080e8a531379170a9f0d46" translate="yes" xml:space="preserve">
          <source>For (5), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, where &lt;code&gt;T_0&lt;/code&gt; and &lt;code&gt;T_1&lt;/code&gt; are the two types constituting &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">(5)의 경우 &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; 는 모두 &lt;code&gt;true&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;T_0&lt;/code&gt; 및 &lt;code&gt;T_1&lt;/code&gt; 은 Type을 구성하는 두 가지 &lt;code&gt;Types&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="94214e5075f274a6f5fa7b33c9435afe45df0332" translate="yes" xml:space="preserve">
          <source>For (6), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, where &lt;code&gt;T_0&lt;/code&gt; and &lt;code&gt;T_1&lt;/code&gt; are the two types constituting &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">(6)의 경우 &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 는 모두 &lt;code&gt;true&lt;/code&gt; 이며 여기서 &lt;code&gt;T_0&lt;/code&gt; 및 &lt;code&gt;T_1&lt;/code&gt; 은 두 가지 유형이 구성 &lt;code&gt;Types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83856baa7fbad81b10e160970bde088c89421d40" translate="yes" xml:space="preserve">
          <source>For 0&amp;le;arg&amp;le;1,</source>
          <target state="translated">0&amp;le;arg&amp;le;1의 경우</target>
        </trans-unit>
        <trans-unit id="3bd6dc6d78016b2a3f1c8c074db727a1bd8e2c50" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types, value representation is a part of the object representation, which means that copying the bytes occupied by the object in the storage is sufficient to produce another object with the same value (except if the value is a</source>
          <target state="translated">들면 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 값이 인 경우를 제외 유형 값의 표현은 바이트를 복사하여 기억 수단에 물체가 차지하는 (동일한 값이 다른 목적을 생산하기에 충분하다는 것을 의미 객체 표현의 일부이며</target>
        </trans-unit>
        <trans-unit id="a6d068410c3d5d5e1e66f214a4705f1da0744b99" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop, it acts as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192dfceddbf339e300daed630beff6523e185814" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; and &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">들면 &lt;a href=&quot;for&quot;&gt;대&lt;/a&gt; 와 &lt;a href=&quot;range-for&quot;&gt;레인지 용&lt;/a&gt; 루프는 역할 :</target>
        </trans-unit>
        <trans-unit id="25d4ebe9fb8814a98da8afb721d4a6bdeed00a0f" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; &amp;gt; and &amp;ge; respectively</source>
          <target state="translated">대한 &lt;a href=&quot;operator_comparison&quot;&gt;관계 연산자&lt;/a&gt; &amp;gt;와 &amp;ge; 각각</target>
        </trans-unit>
        <trans-unit id="c82d883f6eaf9d2b9ddb7fd8e6adaa4e2930e681" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; &amp;lt; and &amp;le; respectively</source>
          <target state="translated">대한 &lt;a href=&quot;operator_comparison&quot;&gt;관계 연산자&lt;/a&gt; 각각 &amp;lt;및 &amp;le;</target>
        </trans-unit>
        <trans-unit id="80184e736b13dd44e9e03f7f4a2465c93e2f10ce" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; = and &amp;ne; respectively</source>
          <target state="translated">대한 &lt;a href=&quot;operator_comparison&quot;&gt;관계 연산자&lt;/a&gt; =와 &amp;ne; 각각</target>
        </trans-unit>
        <trans-unit id="67db5ac16c817d0aad978db1daa9912c166fac6a" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, it acts as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ceb12570320e8236ce37933edca4d8d71e4edce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio&quot;&gt;std::micro&lt;/a&gt;&lt;/code&gt;, if the character &amp;micro; (U+00B5) cannot be represented in the encoding used for &lt;code&gt;CharT&lt;/code&gt;, the suffix &quot;&lt;code&gt;us&lt;/code&gt;&quot; is used instead.</source>
          <target state="translated">들어 &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio&quot;&gt;std::micro&lt;/a&gt;&lt;/code&gt; 문자 &amp;mu; (U + 00B5)가 사용 된 인코딩으로 표현 될 수없는 경우, &lt;code&gt;CharT&lt;/code&gt; , 접미사는 &quot; &lt;code&gt;us&lt;/code&gt; &quot;대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="decd50a2a6c24904b14b0159d4b4ee28edc12dd8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, the elements are bytes (objects of type char), which are not the same as characters if a multibyte encoding such as UTF-8 is used.</source>
          <target state="translated">들면 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 의 요소가 멀티 바이트 UTF-8을 사용하는 등의 경우 문자 인코딩과 동일하지 않은 바이트 (char 형 객체)이다.</target>
        </trans-unit>
        <trans-unit id="4fc81475176c004bf7dd4b13445be6b3d996668a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; the value type is the same as the key type and both &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; are constant iterators. For &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; the value type is &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">용 &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; 값 형 키 종류 모두 동일하다 &lt;code&gt;iterator&lt;/code&gt; 와 &lt;code&gt;const_iterator&lt;/code&gt; 를 상수 반복자이다. 들어 &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 값 유형이있다 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d3533c7dfac4c0a2f11001f27ce7038422be45e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;T*&lt;/code&gt; types, the result may be an undefined address, but the operation otherwise has no undefined behavior. The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is not an object type.</source>
          <target state="translated">들면 &lt;code&gt;T*&lt;/code&gt; 형태의 결과는 정의되지 않은 어드레스 일 수도 있지만, 어떤 작업은 달리 정의되지 않은 동작이 없다. &lt;code&gt;T&lt;/code&gt; 가 객체 유형이 아닌 경우 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d8b259c841d7fe56fd4cbc44dbede3d4a2f5d45" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;T*&lt;/code&gt; types, the result may be an undefined address, but the operations otherwise have no undefined behavior. The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is not an object type.</source>
          <target state="translated">들어 &lt;code&gt;T*&lt;/code&gt; 유형, 결과는 정의되지 않은 주소가 될 수 있지만, 작업은 그렇지 않으면 정의되지 않은 동작이 없습니다. &lt;code&gt;T&lt;/code&gt; 가 객체 유형이 아닌 경우 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="fdab33fa5bc42221e341bfb5aa446019046bda10" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;allocate_shared&lt;/code&gt;, the object (or the individual array elements for (2-5))(since C++20) are destroyed via the expression &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::destroy(a, p)&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;a&lt;/code&gt; is a copy of the allocator passed to &lt;code&gt;allocate_shared&lt;/code&gt;, rebound to the type of the object being destroyed.</source>
          <target state="translated">들면 &lt;code&gt;allocate_shared&lt;/code&gt; 객체 (또는 대한 각 어레이 소자 (2-5))을 통해 식 파괴 (20 ++ C) 이후 &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::destroy(a, p)&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; A는 &lt;code&gt;a&lt;/code&gt; 는 오브젝트에 대한 포인터이며 a 는 assign_shared에 전달 &lt;code&gt;allocate_shared&lt;/code&gt; 자의 사본으로, 파괴되는 오브젝트의 유형으로 리바운드됩니다.</target>
        </trans-unit>
        <trans-unit id="ffeded1df965bfced36bed8a9a11d97603f70744" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;allocate_shared_default_init&lt;/code&gt;, the object (or individual elements if &lt;code&gt;T&lt;/code&gt; is an array type) will be destroyed by &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;X&lt;/code&gt; is its type.</source>
          <target state="translated">들면 &lt;code&gt;allocate_shared_default_init&lt;/code&gt; 객체 (또는 개별 요소 경우 &lt;code&gt;T&lt;/code&gt; 는 어레이 형이다)이 파괴 될 것이다 &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt; , 여기서, &lt;code&gt;p&lt;/code&gt; 는 객체에 대한 포인터이며, &lt;code&gt;X&lt;/code&gt; 는 그 유형이다.</target>
        </trans-unit>
        <trans-unit id="eaf9872d7fc84f0c3657f05544061163d1795a7f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;k = 0,..., m-1&lt;/code&gt;</source>
          <target state="translated">들면 &lt;code&gt;k = 0,..., m-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a84133a6d81bd30988c564a8a6cf37a9783a4cf" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;k = m,..., m+n-1&lt;/code&gt;,</source>
          <target state="translated">들면 &lt;code&gt;k = m,..., m+n-1&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="3702c14d2d2a72e5ae19407c373383886d03512a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;operator,&lt;/code&gt;, the unary &lt;code&gt;operator&amp;amp;&lt;/code&gt;, and &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, if there are no viable functions (see below) in the set of candidate functions, then the operator is reinterpreted as a built-in.</source>
          <target state="translated">들면 &lt;code&gt;operator,&lt;/code&gt; 는 단항 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 및 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 에는 가능한 기능이없는 경우, 후보 함수 세트 (아래 참조), 그 다음 작업자는 내장으로 재 해석한다.</target>
        </trans-unit>
        <trans-unit id="0d394b44570e5e62b408fa0499880cd8eb0cf013" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::binary_search&lt;/code&gt; to succeed, the range &lt;code&gt;[first, last)&lt;/code&gt; must be at least partially ordered with respect to &lt;code&gt;value&lt;/code&gt;, i.e. it must satisfy all of the following requirements:</source>
          <target state="translated">들어 &lt;code&gt;std::binary_search&lt;/code&gt; , 범위를 성공 &lt;code&gt;[first, last)&lt;/code&gt; 부분에 대한 주문 이상이어야 &lt;code&gt;value&lt;/code&gt; , 즉, 그것은 다음과 같은 요구 사항을 모두 충족해야합니다 :</target>
        </trans-unit>
        <trans-unit id="82aaf8ae9515fcaa10aa37778070bfaa5e42e07b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::lrint&lt;/code&gt; and &lt;code&gt;std::llrint&lt;/code&gt; functions:</source>
          <target state="translated">에 대한 &lt;code&gt;std::lrint&lt;/code&gt; 및 &lt;code&gt;std::llrint&lt;/code&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="386ec7b95ea37fdce144fa4084a418bcda9d46f7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::lround&lt;/code&gt; and &lt;code&gt;std::llround&lt;/code&gt; functions:</source>
          <target state="translated">에 대한 &lt;code&gt;std::lround&lt;/code&gt; 및 &lt;code&gt;std::llround&lt;/code&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="93056bf6dac8be93c20bc17806b06200f88a2398" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined move assignment operator copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">에 대한 &lt;code&gt;union&lt;/code&gt; 유형, 암시 적으로 정의 이동 할당 연산자 사본 (기준으로 객체 표현 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ab727ef011ac32b32b71004213c9062e03c40ca6" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow happens if &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; or if &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308485408ad23c9a6a581efd5af8112d70a5819e" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg, and underflow is guaranteed if arg &amp;lt; -708.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ebd607b970e88332eac8b1adf8c8066c0dd8e42" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abd0d73ae7ceb8182e2cfda7bc62d8a3837d067" translate="yes" xml:space="preserve">
          <source>For POSIX-based operating systems, &lt;code&gt;std::filesystem::absolute(p)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;current_path&quot;&gt;std::filesystem::current_path&lt;/a&gt;() / p&lt;/code&gt;.</source>
          <target state="translated">POSIX 기반 운영 체제의 경우 &lt;code&gt;std::filesystem::absolute(p)&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;current_path&quot;&gt;std::filesystem::current_path&lt;/a&gt;() / p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="119d7cdec7ea51fa50da00d5d9417b5384f14791" translate="yes" xml:space="preserve">
          <source>For Windows, &lt;code&gt;absolute&lt;/code&gt; may be implemented as a call to &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364963(v=vs.85).aspx&quot;&gt;GetFullPathNameW&lt;/a&gt;.</source>
          <target state="translated">Windows의 경우 &lt;code&gt;absolute&lt;/code&gt; 은 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364963(v=vs.85).aspx&quot;&gt;GetFullPathNameW에&lt;/a&gt; 대한 호출로 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4e888a145f1992272e7918f8fc284c6a7e06ad4" translate="yes" xml:space="preserve">
          <source>For a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca411b7633697d58c29db0495dbecc36219406c0" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;dependent_name&quot;&gt;non-dependent name&lt;/a&gt; used in a template definition, unqualified name lookup takes place when the template definition is examined. The binding to the declarations made at that point is not affected by declarations visible at the point of instantiation. For a &lt;a href=&quot;dependent_name&quot;&gt;dependent name&lt;/a&gt; used in a template definition, the lookup is postponed until the template arguments are known, at which time &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt; examines function declarations with external linkage(until C++11) that are visible from the template definition context as well as in the template instantiation context, while non-ADL lookup only examines function declarations with external linkage(until C++11) that are visible from the template definition context (in other words, adding a new function declaration after template definition does not make it visible except via ADL). The behavior is undefined if there is a better match with external linkage in the namespaces examined by the ADL lookup, declared in some other translation unit, or if the lookup would have been ambiguous if those translation units were examined. In any case, if a base class depends on a template parameter, its scope is not examined by unqualified name lookup (neither at the point of definition nor at the point of instantiation).</source>
          <target state="translated">A에 대한 &lt;a href=&quot;dependent_name&quot;&gt;비 의존적 이름&lt;/a&gt; 템플릿 정의를 조사 할 경우 템플릿 정의에 사용 비정규 이름 조회가 이루어진다. 해당 시점에서 작성된 선언에 대한 바인딩은 인스턴스화 시점에서 볼 수있는 선언의 영향을받지 않습니다. A에 대한 &lt;a href=&quot;dependent_name&quot;&gt;의존 이름&lt;/a&gt; 템플릿 인수가 알려진 때까지 템플릿 정의에 사용, 조회가 연기되는 시점에서 &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt;템플릿 정의 컨텍스트와 템플릿 인스턴스화 컨텍스트에서 볼 수있는 외부 연결 (C ++ 11까지)을 사용하여 함수 선언을 검사하는 반면, ADL이 아닌 조회는 외부 연결 (C ++ 11까지)을 가진 함수 선언 만 검사합니다. 템플릿 정의 컨텍스트에서 볼 수 있습니다 (즉, 템플릿 정의 뒤에 새 함수 선언을 추가해도 ADL을 제외하고는 보이지 않습니다). 다른 변환 단위로 선언 된 ADL 조회에 의해 검사 된 네임 스페이스에서 외부 연결과 더 잘 일치하는 경우 또는 해당 변환 단위가 검사 된 경우 조회가 모호한 경우 동작이 정의되지 않습니다. 어쨌든 기본 클래스가 템플릿 매개 변수에 의존하는 경우범위는 규정되지 않은 이름 조회 (정의 시점이나 인스턴스화 시점 모두)에 의해 검사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="883759e78914d4b04a2fe3535a894bcffbf8a177" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; of a non-template class, the default arguments are allowed on the out-of-class definition, and are combined with the default arguments provided by the declaration inside the class body. If these out-of-class defaults would turn a member function into a default, copy, or move constructor the program is ill-formed. For member functions of class templates, all defaults must be provided in the initial declaration of the member function.</source>
          <target state="translated">템플릿이 아닌 클래스 의 &lt;a href=&quot;member_functions&quot;&gt;멤버 함수&lt;/a&gt; 의 경우 기본 인수는 클래스 외부 정의에서 허용되며 클래스 본문 내의 선언에서 제공 한 기본 인수와 결합됩니다. 이러한 클래스 외 기본값이 멤버 함수를 기본값, 복사 또는 이동 생성자로 바꾸면 프로그램이 잘못 구성됩니다. 클래스 템플릿의 멤버 함수의 경우 멤버 함수의 초기 선언에서 모든 기본값을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="02ea56864a8e8c007867dec05809cd5a9f98b81f" translate="yes" xml:space="preserve">
          <source>For a container &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.front()&lt;/code&gt; is equivalent to &lt;code&gt;*c.begin()&lt;/code&gt;.</source>
          <target state="translated">컨테이너 &lt;code&gt;c&lt;/code&gt; 의 경우 &lt;code&gt;c.front()&lt;/code&gt; 표현식 은 &lt;code&gt;*c.begin()&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c061e2be7835c9d94a21ab627e460ae3f5da4b8d" translate="yes" xml:space="preserve">
          <source>For a container &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;return c.back();&lt;/code&gt; is equivalent to &lt;code&gt;{ auto tmp = c.end(); --tmp; return *tmp; }&lt;/code&gt;</source>
          <target state="translated">컨테이너 &lt;code&gt;c&lt;/code&gt; 의 경우 표현식은 &lt;code&gt;return c.back();&lt;/code&gt; &lt;code&gt;{ auto tmp = c.end(); --tmp; return *tmp; }&lt;/code&gt; 와 같습니다 . --tmp; return * tmp; }</target>
        </trans-unit>
        <trans-unit id="a12f2ebb81a91e44d54c155d3b7a470c7c32d87a" translate="yes" xml:space="preserve">
          <source>For a given &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt; p&lt;/code&gt;, this specialization ensures that.</source>
          <target state="translated">주어진 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt; p&lt;/code&gt; ,이 특수화는이를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="61761986c4556882eacd9227f774252dea0c81ea" translate="yes" xml:space="preserve">
          <source>For a name used anywhere in &lt;a href=&quot;class&quot;&gt;class definition&lt;/a&gt;, except inside a member function body, a default argument of a member function, exception specification of a member function, default member initializer, &lt;a href=&quot;attributes/contract&quot;&gt;contract condition&lt;/a&gt;(since C++20), or inside a nested class definition (including names of the bases from which the nested class is derived), the following scopes are searched:</source>
          <target state="translated">멤버 함수 본문, 멤버 함수의 기본 인수, 멤버 함수의 예외 사양, 기본 멤버 이니셜 라이저, &lt;a href=&quot;attributes/contract&quot;&gt;계약 조건&lt;/a&gt; (C ++ 20 이후) 또는 중첩 클래스 내부를 제외하고 &lt;a href=&quot;class&quot;&gt;클래스 정의의&lt;/a&gt; 어느 곳에서나 사용되는 이름 정의 (중첩 클래스가 파생 된 기본 이름 포함)를 사용하여 다음 범위를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a684765457eef405a769182256e4ade4f401bc30" translate="yes" xml:space="preserve">
          <source>For a name used in a &lt;a href=&quot;default_arguments&quot;&gt;default argument&lt;/a&gt; in a function declaration, or name used in the expression part of a &lt;a href=&quot;constructor&quot;&gt;member-initializer&lt;/a&gt; of a constructor, the function parameter names are found first, before the enclosing block, class, or namespace scopes are examined:</source>
          <target state="translated">함수 선언 의 &lt;a href=&quot;default_arguments&quot;&gt;기본 인수&lt;/a&gt; 에 사용 된 이름 또는 생성자 의 &lt;a href=&quot;constructor&quot;&gt;멤버 이니셜 라이저&lt;/a&gt; 의 표현식 부분에 사용 된 이름의 경우, 둘러싸는 블록, 클래스 또는 네임 스페이스 범위를 검사하기 전에 함수 매개 변수 이름을 먼저 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6ae66449c2d64e5e5aa0c8dcee38ad7d218d4918" translate="yes" xml:space="preserve">
          <source>For a name used in a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function definition inside the body of the class that is granting friendship, unqualified name lookup proceeds the same way as for a member function. For a name used in a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function which is defined outside the body of a class, unqualified name lookup proceeds the same way as for a function in a namespace.</source>
          <target state="translated">우정을 부여하는 클래스 본문 내에서 &lt;a href=&quot;friend&quot;&gt;친구&lt;/a&gt; 함수 정의에 사용 된 이름 의 경우 규정되지 않은 이름 조회는 멤버 함수와 동일한 방식으로 진행됩니다. 클래스 본문 외부에 정의 된 &lt;a href=&quot;friend&quot;&gt;친구&lt;/a&gt; 함수에 사용 된 이름의 경우 규정되지 않은 이름 조회는 네임 스페이스의 함수와 동일한 방식으로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="f880effac86bc82db2f16b2948bd47f4311ada8a" translate="yes" xml:space="preserve">
          <source>For a name used in a user-declared namespace outside of any function or class, this namespace is searched before the use of the name, then the namespace enclosing this namespace before the declaration of this namespace, etc until the global namespace is reached.</source>
          <target state="translated">함수 또는 클래스 외부에서 사용자가 선언 한 네임 스페이스에 사용 된 이름의 경우이 네임 스페이스는 이름을 사용하기 전에 검색된 다음 글로벌 네임 스페이스에 도달 할 때까지이 네임 스페이스를 선언하기 전에이 네임 스페이스를 둘러싸는 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="d01e0277c975bcb293141e811447dfa3ec140823" translate="yes" xml:space="preserve">
          <source>For a name used in global (top-level namespace) scope, outside of any function, class, or user-declared namespace, the global scope before the use of the name is examined:</source>
          <target state="translated">함수, 클래스 또는 사용자 선언 네임 스페이스 외부의 전역 (최상위 네임 스페이스) 범위에서 사용되는 이름의 경우 이름을 사용하기 전에 전역 범위를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="6751cf91d41edea8f420573f4bb5cfa36ba1c19a" translate="yes" xml:space="preserve">
          <source>For a name used in the catch-clause of a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;, lookup proceeds as if for a name used in the very beginning of the outermost block of the function body (in particular, function parameters are visible, but names declared in that outermost block are not).</source>
          <target state="translated">&lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; 의 catch-clause에 사용 된 이름의 경우, 검색은 함수 본문의 가장 바깥 쪽 블록의 맨 처음에 사용 된 이름에 대한 것처럼 진행됩니다 (특히 함수 매개 변수는 표시되지만 이름은 가장 바깥 쪽 블록은 아닙니다).</target>
        </trans-unit>
        <trans-unit id="0ecffe6eebcdaa6e0a2a4a2d57d191d6b1fc5d6c" translate="yes" xml:space="preserve">
          <source>For a name used in the declarator of a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function declaration that friends a member function from another class, if the name isn't a part of any template argument, the unqualified lookup first examines the entire scope of the member function's class. If not found in that scope (or if the name is a part of a template argument), the lookup continues as if for a member function of the class that is granting friendship.</source>
          <target state="translated">다른 클래스의 멤버 함수와 친구 가되는 &lt;a href=&quot;friend&quot;&gt;프렌드&lt;/a&gt; 함수 선언 의 선언자에 사용 된 이름의 경우, 이름이 템플리트 인수의 일부가 아닌 경우, 규정되지 않은 검색은 먼저 멤버 함수 클래스의 전체 범위를 검사합니다. 해당 범위에서 찾을 수없는 경우 (또는 이름이 템플릿 인수의 일부인 경우) 우정을 부여하는 클래스의 멤버 함수에 대한 것처럼 조회가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="d95608e8a2ef528dbac2bab8b35c1d8f3a28d62b" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a &lt;a href=&quot;static&quot;&gt;static data member&lt;/a&gt;, lookup proceeds the same way as for a name used in the definition of a member function.</source>
          <target state="translated">(A)의 정의에 사용 된 이름은 &lt;a href=&quot;static&quot;&gt;정적 데이터 부재&lt;/a&gt; 룩업 멤버 함수의 정의에 사용 된 이름과 동일한 방식으로 진행한다.</target>
        </trans-unit>
        <trans-unit id="f034307944cf4601fdfc2f8a86c32703ec89cf55" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a function, either in its body or as part of default argument, where the function is a member of user-declared or global namespace, the block in which the name is used is searched before the use of the name, then the enclosing block is searched before the start of that block, etc, until reaching the block that is the function body. Then the namespace in which the function is declared is searched until the definition (not necessarily the declaration) of the function that uses the name, then the enclosing namespaces, etc.</source>
          <target state="translated">함수 정의에 사용 된 이름 (본문 또는 기본 인수의 일부)에서 함수가 사용자 선언 또는 글로벌 네임 스페이스의 멤버 인 경우, 이름이 사용 된 블록은 사용하기 전에 검색됩니다. 함수 본문 인 블록에 도달 할 때까지 이름을 입력 한 다음 블록을 시작하기 전에 둘러싸는 블록을 검색합니다. 그런 다음 함수가 선언 된 네임 스페이스는 이름을 사용하는 함수의 정의 (반드시 선언이 아님), 그 다음에 둘러싸인 네임 스페이스 등이 검색 될 때까지 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="e69fc9e6436e85bd5e71b5f6fffe00b9251f55e4" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a namespace-member variable outside the namespace, lookup proceeds the same way as for a name used inside the namespace:</source>
          <target state="translated">네임 스페이스 외부의 네임 스페이스 멤버 변수 정의에 사용 된 이름의 경우 네임 스페이스 내부에서 사용 된 이름과 동일한 방식으로 조회가 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="8362e87a521c085b7be1055bd62a4345efa29ea0" translate="yes" xml:space="preserve">
          <source>For a name used in the initializer part of the &lt;a href=&quot;enum&quot;&gt;enumerator declaration&lt;/a&gt;, previously declared enumerators in the same enumeration are found first, before the unqualified name lookup proceeds to examine the enclosing block, class, or namespace scope.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt;열거 자 선언&lt;/a&gt; 의 이니셜 라이저 부분에서 사용되는 이름의 경우 , 규정되지 않은 이름 조회가 엔 클로징 블록, 클래스 또는 네임 스페이스 범위를 검사하기 전에 동일한 열거에서 이전에 선언 된 열거자를 먼저 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6979bced06285133967c5c4b103d3e0247545465" translate="yes" xml:space="preserve">
          <source>For a name used inside a member function body, a default argument of a member function, an exception specification of a member function, a default member initializer, a &lt;a href=&quot;attributes/contract&quot;&gt;contract condition&lt;/a&gt; of a member function(since C++20), or a nested class definition (including names of the bases from which the nested class is derived), the scopes searched are the same as in &lt;a href=&quot;unqualified_lookup#Class_definition&quot;&gt;class definition&lt;/a&gt;, except that the entire scope of the class is considered, not just the part prior to the declaration that uses the name. For nested classes the entire body of the enclosing class is searched.</source>
          <target state="translated">멤버 함수 본문 내에서 사용되는 이름, 멤버 함수의 기본 인수, 멤버 함수의 예외 사양, 기본 멤버 이니셜 라이저, 멤버 함수 의 &lt;a href=&quot;attributes/contract&quot;&gt;계약 조건&lt;/a&gt; (C ++ 20 이후) 또는 중첩 클래스 정의 (중첩 클래스가 파생 된 기본의 이름 포함)의 경우, 검색된 범위는 이름을 사용하는 선언 이전의 부분 만이 아니라 클래스의 전체 범위가 고려된다는 점을 제외하고 &lt;a href=&quot;unqualified_lookup#Class_definition&quot;&gt;클래스 정의에서&lt;/a&gt; 와 동일합니다. . 중첩 클래스의 경우 엔 클로징 클래스의 전체 본문이 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="5f9f456dc65dd5916b44e6d8b6b804f14836dd56" translate="yes" xml:space="preserve">
          <source>For a non-union aggregate, element for which a designated initializer is not provided are initialized the same as described above for when the number of initializer clauses is less than the number of members (default member initializers where provided, empty list-initialization otherwise):</source>
          <target state="translated">비 유니온 집계의 경우 지정된 초 기자 (initializer)가 제공되지 않은 요소는 초기화 자 절 수가 멤버 수보다 적은 경우에 대해 위에서 설명한 것과 동일하게 초기화됩니다 (제공된 경우 기본 멤버 초기화 자, 그렇지 않으면 비어있는 목록 초기화) :</target>
        </trans-unit>
        <trans-unit id="5961fe12a3117fa1b2454e762062290b637aa259" translate="yes" xml:space="preserve">
          <source>For a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a88dd4d98c693a356d74c5b2bd02963d1cfab7" translate="yes" xml:space="preserve">
          <source>For a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt;s X and Y, and if A is</source>
          <target state="translated">&lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; s X와 Y 가 두 개 있고 A가 B 인 경우 A와 B라는 M에 대한 한 쌍의 원자 연산의 경우 A가 쓰고 B가 M의 값을 읽는</target>
        </trans-unit>
        <trans-unit id="e8a036efd00fe52d195f38f7af9f452d212a3c7c" translate="yes" xml:space="preserve">
          <source>For a regular file &lt;code&gt;p&lt;/code&gt;, returns the size determined as if by reading the &lt;code&gt;st_size&lt;/code&gt; member of the structure obtained by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed).</source>
          <target state="translated">일반 파일 &lt;code&gt;p&lt;/code&gt; 의 경우 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat에&lt;/a&gt; 의해 얻은 구조 의 &lt;code&gt;st_size&lt;/code&gt; 멤버를 읽어서 결정된 크기를 리턴합니다 (기호 링크가 이어짐).</target>
        </trans-unit>
        <trans-unit id="1a9910e8a0a912c3015de0a3b33c5c17808e192d" translate="yes" xml:space="preserve">
          <source>For a reverse iterator &lt;code&gt;r&lt;/code&gt; constructed from an iterator &lt;code&gt;i&lt;/code&gt;, the relationship &lt;code&gt;&amp;amp;*r == &amp;amp;*(i-1)&lt;/code&gt; is always true (as long as &lt;code&gt;r&lt;/code&gt; is dereferenceable); thus a reverse iterator constructed from a one-past-the-end iterator dereferences to the last element in a sequence.</source>
          <target state="translated">반복자 &lt;code&gt;i&lt;/code&gt; 로 구성된 역 반복자 &lt;code&gt;r&lt;/code&gt; 의 경우 , &lt;code&gt;&amp;amp;*r == &amp;amp;*(i-1)&lt;/code&gt; 는 항상 참입니다 ( &lt;code&gt;r&lt;/code&gt; 이 역 참조 가능한 한). 따라서 일회성 엔드 이터레이터로 구성된 리버스 이터레이터는 시퀀스의 마지막 요소를 역 참조합니다.</target>
        </trans-unit>
        <trans-unit id="ad06b47edb0bcc2d8539e75487122b7c88338360" translate="yes" xml:space="preserve">
          <source>For a span &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.back()&lt;/code&gt; is equivalent to &lt;code&gt;*(c.end()-1)&lt;/code&gt;.</source>
          <target state="translated">범위 &lt;code&gt;c&lt;/code&gt; 의 경우 &lt;code&gt;c.back()&lt;/code&gt; 표현식 은 &lt;code&gt;*(c.end()-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1fa034a73d65c807607dcc81680fbdbbcb66bcc" translate="yes" xml:space="preserve">
          <source>For a span &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.front()&lt;/code&gt; is equivalent to &lt;code&gt;*c.begin()&lt;/code&gt;.</source>
          <target state="translated">범위 &lt;code&gt;c&lt;/code&gt; 의 경우 &lt;code&gt;c.front()&lt;/code&gt; 표현식 은 &lt;code&gt;*c.begin()&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5c154bb2c5d060e3bc21cda45246264cc660e3cf" translate="yes" xml:space="preserve">
          <source>For a standard stream &lt;code&gt;str&lt;/code&gt;, synchronized with the C stream &lt;code&gt;f&lt;/code&gt;, the following pairs of functions have identical effect:</source>
          <target state="translated">C 스트림 &lt;code&gt;f&lt;/code&gt; 와 동기화 된 표준 스트림 &lt;code&gt;str&lt;/code&gt; 의 경우 다음 함수 쌍이 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="de5683ef87cd469dd98d4cc4a0aed5b17f0dbfb7" translate="yes" xml:space="preserve">
          <source>For a type &lt;code&gt;T&lt;/code&gt;, the default value of &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is:</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 경우 &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; 의 기본값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a003d5a71c47171b8ec220d6469cdc87d155fcf6" translate="yes" xml:space="preserve">
          <source>For a type &lt;code&gt;TC&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;TC&lt;/code&gt; 유형의 경우 :</target>
        </trans-unit>
        <trans-unit id="28eb0e4e99d6754c04540069cc9b86b6e86b0026" translate="yes" xml:space="preserve">
          <source>For a unary operator &lt;code&gt;@&lt;/code&gt; whose argument has type &lt;code&gt;T1&lt;/code&gt; (after removing cv-qualifications), or binary operator &lt;code&gt;@&lt;/code&gt; whose left operand has type &lt;code&gt;T1&lt;/code&gt; and right operand of type &lt;code&gt;T2&lt;/code&gt; (after removing cv-qualifications), the following sets of candidate functions are prepared:</source>
          <target state="translated">인수에 유형이 &lt;code&gt;T1&lt;/code&gt; (cv-qualifications를 제거한 후) 이 있는 단항 연산자 &lt;code&gt;@&lt;/code&gt; 또는 왼쪽 피연산자가 유형이 &lt;code&gt;T1&lt;/code&gt; 이고 유형이 &lt;code&gt;T2&lt;/code&gt; 의 오른쪽 피연산자 (cv-qualifications를 제거한 후 ) 인 이항 연산자 &lt;code&gt;@&lt;/code&gt; 의 경우 다음 후보 함수 세트가 준비됩니다. :</target>
        </trans-unit>
        <trans-unit id="a0f6b7e105043260b05aaf0d46100e8d47e56be4" translate="yes" xml:space="preserve">
          <source>For a union with bits that participate in the value representations of some members but not the others, compare-and-exchange might always fail because such padding bits have indeterminate values when they do not participate in the value representation of the active member.</source>
          <target state="translated">일부 멤버의 값 표현에는 참여하지만 다른 멤버의 값 표현에는 참여하지 않는 비트와의 합집합의 경우, 패딩 비트는 활성 멤버의 값 표현에 참여하지 않을 때 결정되지 않은 값을 가지므로 비교 및 ​​교환이 항상 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1edec90a35f1485dfd1de3cb8edee29c85050704" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;!(a &amp;lt; a)&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;a&lt;/code&gt; 에 대해 &lt;code&gt;!(a &amp;lt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be2f118aaee33f35b4a4d55d4b1363d900dc2269" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;comp(a,a)==false&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;a&lt;/code&gt; 에 대해 &lt;code&gt;comp(a,a)==false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="232a0e7be31828ff9c9e76ce04deca11781e6a26" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;equiv(a,a)==true&lt;/code&gt;</source>
          <target state="translated">모든 , &lt;code&gt;equiv(a,a)==true&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcda67f6f48d3eaf152c442223488264fae5046f" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; is equal to &lt;code&gt;X​::​eq_int_type(X​::​to_int_type(c), X​::​to_int_type(d))&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;d&lt;/code&gt; 에 대해 &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; 는 &lt;code&gt;X​::​eq_int_type(X​::​to_int_type(c), X​::​to_int_type(d))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2032585f99e27bc2ad7b8385f77f212571492869" translate="yes" xml:space="preserve">
          <source>For all other functions, reaching the end of a catch clause is equivalent to &lt;code&gt;return;&lt;/code&gt; if the function's return type is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">다른 모든 함수의 경우 catch 절 끝에 도달하는 것은 &lt;code&gt;return;&lt;/code&gt; 과 같습니다 . 함수의 반환 유형이 (cv-qualified) &lt;code&gt;void&lt;/code&gt; 인 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da7d72e89e6f7a108ff843546e67ee1b3d8bf96b" translate="yes" xml:space="preserve">
          <source>For all other names (variables, namespaces, classes, etc), name lookup must produce a single declaration in order for the program to compile. Lookup for a name in a scope finds all declarations of that name, with one exception, known as the &quot;struct hack&quot; or &quot;type/non-type hiding&quot;: Within the same scope, some occurrences of a name may refer to a declaration of a class/struct/union/enum that is not a typedef, while all other occurrences of the same name either all refer to the same variable, non-static data member (since C++14), or enumerator, or they all refer to possibly overloaded function or function template names. In this case, there is no error, but the type name is hidden from lookup (the code must use &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; to access it).</source>
          <target state="translated">다른 모든 이름 (변수, 네임 스페이스, 클래스 등)의 경우 프로그램을 컴파일하려면 이름 조회에서 단일 선언을 생성해야합니다. 스코프에서 이름을 검색하면 &quot;struct hack&quot;또는 &quot;type / non-type hiding&quot;이라는 한 가지 예외를 제외하고 해당 이름의 모든 선언을 찾습니다. 동일한 범위 내에서 이름의 일부 발생은 선언을 참조 할 수 있습니다 typedef가 아닌 클래스 / struct / union / enum의 이름이며, 같은 이름의 다른 모든 항목은 모두 동일한 변수, 정적이 아닌 데이터 멤버 (C ++ 14부터) 또는 열거 자 또는 모두를 나타냅니다. 오버로드 된 함수 또는 함수 템플릿 이름을 참조하십시오. 이 경우 오류는 없지만 유형 이름은 조회에서 숨겨집니다 (코드는 &lt;a href=&quot;elaborated_type_specifier&quot;&gt;정교한 유형 지정자&lt;/a&gt; 를 사용 하여 액세스해야합니다).</target>
        </trans-unit>
        <trans-unit id="10db488ddc48847974dabc392b2f321428b2ad60" translate="yes" xml:space="preserve">
          <source>For all other objects (class objects initialized by a trivial default constructor, non-class objects, arrays of those, etc.), lifetime begins when the properly-aligned storage for the object is allocated and ends when the storage is deallocated or reused by another object.</source>
          <target state="translated">다른 모든 객체 (사소한 기본 생성자, 비 클래스 객체, 해당 객체의 배열 등으로 초기화 된 클래스 객체)의 경우 수명은 객체에 올바르게 정렬 된 스토리지가 할당 될 때 시작되고 스토리지가 할당 해제되거나 재사용 될 때 종료됩니다. 다른 물건.</target>
        </trans-unit>
        <trans-unit id="760abd8226337c152c576ef554b6c75c15801476" translate="yes" xml:space="preserve">
          <source>For all three operators, the usual arithmetic conversions are performed on both operands and determine the type of the result.</source>
          <target state="translated">세 연산자 모두에 대해 일반적인 산술 변환은 두 피연산자 모두에서 수행되며 결과 유형을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8d67a35b43e5bf5606d1d36920c0574ac4035475" translate="yes" xml:space="preserve">
          <source>For all values of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a == a&lt;/code&gt; yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">모든 값을 , &lt;code&gt;a == a&lt;/code&gt; 수율 &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd7a423e3b93ec1547e0b8fd506cf138031deb4a" translate="yes" xml:space="preserve">
          <source>For an</source>
          <target state="translated">대한</target>
        </trans-unit>
        <trans-unit id="abab0bc9e7d335f8452e190fdf3bbe8302cb65a4" translate="yes" xml:space="preserve">
          <source>For an &lt;a href=&quot;expressions#Operators&quot;&gt;operator&lt;/a&gt; used in expression (e.g., &lt;code&gt;operator+&lt;/code&gt; used in &lt;code&gt;a+b&lt;/code&gt;), the lookup rules are slightly different from the operator used in an explicit function-call expression such as &lt;code&gt;operator+(a,b)&lt;/code&gt;: when parsing an expression, two separate lookups are performed: for the non-member operator overloads and for the member operator overloads (for the operators where both forms are permitted). Those sets are then merged with the built-in operator overloads on equal grounds as described in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;. If explicit function call syntax is used, regular unqualified name lookup is performed:</source>
          <target state="translated">들어 &lt;a href=&quot;expressions#Operators&quot;&gt;오퍼레이터&lt;/a&gt; 식에 사용 (예를 들면, &lt;code&gt;operator+&lt;/code&gt; 에 사용되는 &lt;code&gt;a+b&lt;/code&gt; ) 룩업 규칙은 같은 명시적인 함수 호출의 발현에 사용되는 연산자 약간 다른 &lt;code&gt;operator+(a,b)&lt;/code&gt; 식을 해석 할 때, 두 개의 별도 : 비 멤버 연산자 오버로드 및 멤버 연산자 오버로드 (두 형식이 모두 허용되는 연산자)에 대해 조회가 수행됩니다. 그런 다음 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결에&lt;/a&gt; 설명 된대로 이러한 세트는 동일한 접지에서 내장 된 작업자 과부하와 병합됩니다 . 명시적인 함수 호출 구문이 사용되면 정규적인 정규화되지 않은 이름 조회가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="cfdde08423e6892ce026f332e4722775a6fd0ec4" translate="yes" xml:space="preserve">
          <source>For an inline function or inline variable(since C++17), a definition is required in every translation unit where it is</source>
          <target state="translated">인라인 함수 또는 인라인 변수 (C ++ 17부터)의 경우 모든 번역 단위에 정의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b13c06c8df9fdd2618a4c37f530dfc9ec64faee7" translate="yes" xml:space="preserve">
          <source>For an object &lt;code&gt;m&lt;/code&gt; of Mutex type:</source>
          <target state="translated">Mutex 유형 의 객체 &lt;code&gt;m&lt;/code&gt; 의 경우 :</target>
        </trans-unit>
        <trans-unit id="10c618faebd2cba6e4ed1d78498e9c737887c436" translate="yes" xml:space="preserve">
          <source>For an object of type &lt;code&gt;T&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 객체의 경우</target>
        </trans-unit>
        <trans-unit id="9cbc15bac40798667e2c28ef32d8acd0bfca6527" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;year_month_day&lt;/code&gt; object &lt;code&gt;ymd&lt;/code&gt; representing a valid date (&lt;code&gt;ymd.ok() == true&lt;/code&gt;), converting &lt;code&gt;ymd&lt;/code&gt; to &lt;code&gt;sys_days&lt;/code&gt; and back yields the same value.</source>
          <target state="translated">어떤 내용 &lt;code&gt;year_month_day&lt;/code&gt; 의 객체 &lt;code&gt;ymd&lt;/code&gt; 유효한 날짜를 나타내는 ( &lt;code&gt;ymd.ok() == true&lt;/code&gt; ), 변환 &lt;code&gt;ymd&lt;/code&gt; 에 &lt;code&gt;sys_days&lt;/code&gt; 뒤로하면 동일한 값을 산출한다.</target>
        </trans-unit>
        <trans-unit id="f2a393f7232125085f4da3eb01cb2d41b026b8c4" translate="yes" xml:space="preserve">
          <source>For any object &lt;code&gt;z&lt;/code&gt; of type &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[0]&lt;/code&gt; is the real part of z and &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[1]&lt;/code&gt; is the imaginary part of z.</source>
          <target state="translated">모든 오브젝트를 들어 &lt;code&gt;z&lt;/code&gt; 형의 &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[0]&lt;/code&gt; Z 및의 실수 부 &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[1]&lt;/code&gt; z의 가상 부분입니다.</target>
        </trans-unit>
        <trans-unit id="aa002637ab58deab74ffaca3cf03066bd188d114" translate="yes" xml:space="preserve">
          <source>For any object of class or aggregate types if it, or any of its subobjects, is initialized by anything other than the &lt;a href=&quot;default_constructor#Trivial_default_constructor&quot;&gt;trivial default constructor&lt;/a&gt;, lifetime begins when initialization ends.</source>
          <target state="translated">클래스 또는 집계 유형의 오브젝트 또는 해당 서브 오브젝트가 &lt;a href=&quot;default_constructor#Trivial_default_constructor&quot;&gt;간단한 기본 생성자&lt;/a&gt; 이외의 다른 것으로 초기화 된 경우 초기화가 끝나면 수명이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="cdd8992024517b51f7efb1e98465ebff61447714" translate="yes" xml:space="preserve">
          <source>For any object of class types whose &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;destructor&lt;/a&gt; is not trivial, lifetime ends when the execution of the destructor begins.</source>
          <target state="translated">&lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;소멸자&lt;/a&gt; 가 사소하지 않은 클래스 유형의 객체 의 경우 소멸자의 실행이 시작되면 수명이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fa44da499e47fc6fac2860172008adb9c1ff9a16" translate="yes" xml:space="preserve">
          <source>For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cefa90cb2c929a28be455e9f8fda7d414ab3948b" translate="yes" xml:space="preserve">
          <source>For any pointer to an element of an array of &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; named &lt;code&gt;p&lt;/code&gt; and any valid array index &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i]&lt;/code&gt; is the real part of the complex number &lt;code&gt;p[i]&lt;/code&gt;, and &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i + 1]&lt;/code&gt; is the imaginary part of the complex number &lt;code&gt;p[i]&lt;/code&gt;</source>
          <target state="translated">임의의 배열의 요소 포인터 &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; 라는 &lt;code&gt;p&lt;/code&gt; 및 유효한 배열 인덱스 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i]&lt;/code&gt; 복소수의 실수 부 &lt;code&gt;p[i]&lt;/code&gt; , 및 &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i + 1]&lt;/code&gt; 은 복소수 &lt;code&gt;p[i]&lt;/code&gt; 의 허수 부입니다 .</target>
        </trans-unit>
        <trans-unit id="33bcdf350e21fefb2826ca912ee3190d4a971dc5" translate="yes" xml:space="preserve">
          <source>For any two values &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; of the type &lt;code&gt;&lt;a href=&quot;../../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt1&amp;gt;::value_type&lt;/code&gt;, if &lt;code&gt;pred(A, B) == true&lt;/code&gt;, then &lt;code&gt;hf(A) == hf(B)&lt;/code&gt; shall be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">두 값 및 &lt;code&gt;B&lt;/code&gt; 유형의 &lt;code&gt;&lt;a href=&quot;../../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt1&amp;gt;::value_type&lt;/code&gt; &amp;lt;RandomIt1&amp;gt; :: VALUE_TYPE 경우 &lt;code&gt;pred(A, B) == true&lt;/code&gt; 다음 &lt;code&gt;hf(A) == hf(B)&lt;/code&gt; 있어야한다 &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b450ffc7f721529dcdc6d1be9e46c5d50a2a925" translate="yes" xml:space="preserve">
          <source>For any type &lt;code&gt;T&lt;/code&gt; (including incomplete types), other than &lt;a href=&quot;functions&quot;&gt;function type&lt;/a&gt; or &lt;a href=&quot;reference&quot;&gt;reference type&lt;/a&gt;, there are three more distinct types in the C++ type system: const-qualified&lt;code&gt;T&lt;/code&gt;, volatile-qualified&lt;code&gt;T&lt;/code&gt;, and const-volatile-qualified&lt;code&gt;T&lt;/code&gt;.  Note: &lt;a href=&quot;array&quot;&gt;array types&lt;/a&gt; are considered to have the same cv-qualification as their element types.</source>
          <target state="translated">&lt;a href=&quot;functions&quot;&gt;함수 유형&lt;/a&gt; 또는 &lt;a href=&quot;reference&quot;&gt;참조 유형&lt;/a&gt; 이외의 유형 &lt;code&gt;T&lt;/code&gt; (불완전한 유형 포함)의 경우 C ++ 유형 시스템에는 const-qualified &lt;code&gt;T&lt;/code&gt; , volatile-qualified &lt;code&gt;T&lt;/code&gt; 및 const-volatile-qualified &lt;code&gt;T&lt;/code&gt; 세 가지 유형이 있습니다 . 참고 : &lt;a href=&quot;array&quot;&gt;배열 유형&lt;/a&gt; 은 요소 유형과 동일한 cv 규정을 가진 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="587d19dece0a5e657eee4b9c6dab7110d60627cf" translate="yes" xml:space="preserve">
          <source>For any z, acos(z) = &amp;pi; - acos(-z).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21aee1213fe266997611327508955de0364192e9" translate="yes" xml:space="preserve">
          <source>For any z, atanh(z) =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e254b6622c2f4cf79e478657cc199aa0c2eea2e9" translate="yes" xml:space="preserve">
          <source>For append streams (&lt;code&gt;mode &amp;amp; ios_base::ate == true&lt;/code&gt;), &lt;code&gt;pptr() == pbase() + s.size()&lt;/code&gt;, so that subsequent output will be appended to the last character copied from &lt;code&gt;s&lt;/code&gt;(since C++11)</source>
          <target state="translated">스트림 추가 ( &lt;code&gt;mode &amp;amp; ios_base::ate == true&lt;/code&gt; )의 경우 &lt;code&gt;pptr() == pbase() + s.size()&lt;/code&gt; 이므로 후속 출력은 &lt;code&gt;s&lt;/code&gt; 에서 복사 한 마지막 문자에 추가됩니다 (C ++ 11부터). )</target>
        </trans-unit>
        <trans-unit id="c24da57cc18573525a82a6c2c1fa0a27b061d0da" translate="yes" xml:space="preserve">
          <source>For arg&amp;gt;1, &amp;Sigma;&amp;infin;</source>
          <target state="translated">arg&amp;gt; 1의 경우 &amp;Sigma;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="7046cc5d9597c58aa7e54080523a910de0e052c1" translate="yes" xml:space="preserve">
          <source>For arg&amp;lt;0, 2arg</source>
          <target state="translated">arg &amp;lt;0, 2arg의 경우</target>
        </trans-unit>
        <trans-unit id="188be9f862ad64a9a657bafc75642d5f5c9f6a4f" translate="yes" xml:space="preserve">
          <source>For arithmetic types not subject to promotion, the common type may be viewed as the type of the (possibly mixed-mode) arithmetic expression such as &lt;code&gt;T0() + T1() + ... + Tn()&lt;/code&gt;.</source>
          <target state="translated">승격 대상이 아닌 산술 유형의 경우 공통 유형은 &lt;code&gt;T0() + T1() + ... + Tn()&lt;/code&gt; 과 같은 (혼합 모드) 산술 표현식의 유형으로 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79dccf2c6a91881692253227b281b3f534531201" translate="yes" xml:space="preserve">
          <source>For arithmetic types, the thousands separator character, obtained from &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt;, is inserted into the sequence according to the grouping rules provided by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;</source>
          <target state="translated">산술 유형의 경우 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt; 에서 얻은 천 단위 구분 기호 문자는 std 에서 제공하는 그룹화 규칙에 따라 시퀀스에 삽입됩니다 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c01eb08fd12dd04934e4ddc13d646e9cc256574b" translate="yes" xml:space="preserve">
          <source>For auto-returning functions, the parameter &lt;code&gt;P&lt;/code&gt; is obtained as follows: in &lt;code&gt;T&lt;/code&gt;, the declared return type of the function that includes &lt;code&gt;auto&lt;/code&gt;, every occurrence of &lt;code&gt;auto&lt;/code&gt; is replaced with an imaginary type template parameter &lt;code&gt;U&lt;/code&gt;. The argument &lt;code&gt;A&lt;/code&gt; is the expression of the &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; statement, and if the return statement has no operand, &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;void()&lt;/code&gt;. After deduction of &lt;code&gt;U&lt;/code&gt; from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; following the rules described above, the deduced &lt;code&gt;U&lt;/code&gt; is substituted into &lt;code&gt;T&lt;/code&gt; to get the actual return type:</source>
          <target state="translated">자동 복귀 기능을 위해, 파라미터 &lt;code&gt;P&lt;/code&gt; 는 에서 다음과 같이 얻어진다 &lt;code&gt;T&lt;/code&gt; 포함 함수의 선언 반환형 &lt;code&gt;auto&lt;/code&gt; , 발생할 때마다 &lt;code&gt;auto&lt;/code&gt; 파라미터 허수 형식 템플릿으로 대체된다 &lt;code&gt;U&lt;/code&gt; . 인수 &lt;code&gt;A&lt;/code&gt; 는 &lt;a href=&quot;return&quot;&gt;리턴&lt;/a&gt; 명령문 의 표현식이며 리턴 명령문에 피연산자가없는 경우 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;void()&lt;/code&gt; 입니다. 위에서 설명한 규칙에 따라 &lt;code&gt;P&lt;/code&gt; 및 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;U&lt;/code&gt; 를 공제 한 후 , 추론 된 &lt;code&gt;U&lt;/code&gt; 는 실제 반환 유형을 얻기 위해 &lt;code&gt;T&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="21745cae4e72428f50d08dc188de6ed08f485b25" translate="yes" xml:space="preserve">
          <source>For both integer and floating-point types, if &lt;code&gt;showpos&lt;/code&gt; is set, the modifier &lt;code&gt;+&lt;/code&gt; is prepended</source>
          <target state="translated">정수 및 부동 소수점 유형 모두 &lt;code&gt;showpos&lt;/code&gt; 가 설정되면 수정 자 &lt;code&gt;+&lt;/code&gt; 가 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6e00438cc48aea953c237222b040f934d513cc5a" translate="yes" xml:space="preserve">
          <source>For both overloads, if the iterator type is mutable, &lt;code&gt;f&lt;/code&gt; may modify the elements of the range through the dereferenced iterator. If &lt;code&gt;f&lt;/code&gt; returns a result, the result is ignored.</source>
          <target state="translated">두 과부하 모두 반복자 유형이 변경 가능한 경우 &lt;code&gt;f&lt;/code&gt; 는 역 참조 된 반복자를 통해 범위의 요소를 수정할 수 있습니다. 경우 &lt;code&gt;f&lt;/code&gt; 는 결과를 반환, 결과는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d4b87d39492f3a203318f3eec5a45d21ed020f35" translate="yes" xml:space="preserve">
          <source>For both overloads, if the iterator type is mutable, &lt;code&gt;f&lt;/code&gt; may modify the elements of the range through the dereferenced iterator. If &lt;code&gt;f&lt;/code&gt; returns a result, the result is ignored. If &lt;code&gt;n&lt;/code&gt; is less than zero, the behavior is undefined.</source>
          <target state="translated">두 과부하 모두 반복자 유형이 변경 가능한 경우 &lt;code&gt;f&lt;/code&gt; 는 역 참조 된 반복자를 통해 범위의 요소를 수정할 수 있습니다. 경우 &lt;code&gt;f&lt;/code&gt; 는 결과를 반환, 결과는 무시됩니다. 경우 &lt;code&gt;n&lt;/code&gt; 이 0보다 작은, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="2cbfdeffec6dd0f35e1227e8a499f4b7385ae247" translate="yes" xml:space="preserve">
          <source>For both user-defined or implicitly-defined destructors, after the body of the destructor is executed, the compiler calls the destructors for all non-static non-variant members of the class, in reverse order of declaration, then it calls the destructors of all direct non-virtual base classes in &lt;a href=&quot;constructor#Initialization_order&quot;&gt;reverse order of construction&lt;/a&gt; (which in turn call the destructors of their members and their base classes, etc), and then, if this object is of most-derived class, it calls the destructors of all virtual bases.</source>
          <target state="translated">사용자 정의 또는 암시 적으로 정의 된 소멸자의 경우 소멸자의 본문이 실행 된 후 컴파일러는 클래스의 모든 비 정적 비 변형 멤버에 대한 소멸자를 선언의 역순으로 호출 한 다음 소멸자를 호출합니다. 모든 비가 상 기본 클래스 &lt;a href=&quot;constructor#Initialization_order&quot;&gt;는 구성 순서의 역순으로&lt;/a&gt; (이후 멤버의 소멸자와 기본 클래스 등을 호출 함)이 오브젝트가 가장 파생 된 클래스 인 경우 모든 가상의 소멸자를 호출합니다. 기지.</target>
        </trans-unit>
        <trans-unit id="db34171dc6d92c22aa5da5d7cd5e78cc97249f77" translate="yes" xml:space="preserve">
          <source>For char arrays shorter than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ptrdiff_t&lt;/code&gt; acts as the signed counterpart of &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;: it can store the size of the array of any type and is, on most platforms, synonymous with &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::intptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; 보다 짧은 char 배열의 경우 &lt;code&gt;std::ptrdiff_t&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 의 부호있는 대응 물로 작동합니다 . 모든 유형의 배열 크기를 저장할 수 있으며 대부분의 플랫폼에서 &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::intptr_t&lt;/a&gt;&lt;/code&gt; 와 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="6f3c75e611a43557be37674fd1cb00bb164eeebf" translate="yes" xml:space="preserve">
          <source>For compatibility with C89, an optional comma may appear before the ellipsis if the parameter list contains at least one parameter:</source>
          <target state="translated">C89와의 호환성을 위해 매개 변수 목록에 하나 이상의 매개 변수가 포함 된 경우 생략 앞에 선택적 쉼표가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94880bd109360b34fd05f9d76510d26eb3dee88a" translate="yes" xml:space="preserve">
          <source>For constexpr function templates and constexpr member functions of class templates, at least one specialization must satisfy the abovementioned requirements. Other specializations are still considered as constexpr, even though a call to such a function cannot appear in a constant expression.</source>
          <target state="translated">클래스 템플릿의 constexpr 함수 템플릿 및 constexpr 멤버 함수의 경우 하나 이상의 전문화 영역이 위에서 언급 한 요구 사항을 충족해야합니다. 그러한 함수에 대한 호출이 상수 표현식에 나타날 수는 없지만 다른 특수화는 여전히 constexpr로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9efcdd76c0a92319514fd74592e33806161ca5b0" translate="yes" xml:space="preserve">
          <source>For control over formatting, use &lt;code&gt;std::chrono::format&lt;/code&gt;.</source>
          <target state="translated">형식을 제어하려면 &lt;code&gt;std::chrono::format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce61db7d14bb600483458137835d50aed271a6ed" translate="yes" xml:space="preserve">
          <source>For creation of a full date, any of the following three orders are accepted:</source>
          <target state="translated">전체 날짜를 만들려면 다음 세 가지 주문 중 하나가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e51f626291c443aca3537b45aaca51887d63f76" translate="yes" xml:space="preserve">
          <source>For detailed rules on overload resolution, see &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="translated">오버로드 확인에 대한 자세한 규칙을 참조 &lt;a href=&quot;overload_resolution&quot;&gt;오버로드 확인을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ccd8ef2913234c8ce975d9ef8bd2b1cb54addbe" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;Ti&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;, the corresponding type &lt;code&gt;Vi&lt;/code&gt; in &lt;code&gt;VTypes...&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Ti&amp;gt;::type&lt;/code&gt; unless application of &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; results in &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; for some type &lt;code&gt;X&lt;/code&gt;, in which case the deduced type is &lt;code&gt;X&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">각각 &lt;code&gt;Ti&lt;/code&gt; 의 &lt;code&gt;Types...&lt;/code&gt; , 대응 형 &lt;code&gt;Vi&lt;/code&gt; 에 &lt;code&gt;VTypes...&lt;/code&gt; 이다 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Ti&amp;gt;::type&lt;/code&gt; 인가하지 않는 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; 결과 &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; 어떤 타입에 대한 &lt;code&gt;X&lt;/code&gt; , 이 경우 추론 된 유형은 &lt;code&gt;X&amp;amp;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ebdcf0767cd45dcef0e5f166fda3ae1b99a89262" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,j)&lt;/code&gt;, &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; is true</source>
          <target state="translated">각 &lt;code&gt;i&lt;/code&gt; 의 &lt;code&gt;[0,j)&lt;/code&gt; 를 , &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; 참</target>
        </trans-unit>
        <trans-unit id="a48fe3fe8c043eed63afe7b1696e912edb4e26e0" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, performs &lt;code&gt;X​::​assign(s[i], c)&lt;/code&gt;.</source>
          <target state="translated">각 &lt;code&gt;i&lt;/code&gt; 의 &lt;code&gt;[0,n)&lt;/code&gt; 을 수행 &lt;code&gt;X​::​assign(s[i], c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7673ab38c4ed279e12cc192b7a57b5fd910e9b3" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, performs &lt;code&gt;X​::​assign(s[i], p[i])&lt;/code&gt;</source>
          <target state="translated">각 &lt;code&gt;i&lt;/code&gt; 의 &lt;code&gt;[0,n)&lt;/code&gt; 을 수행 &lt;code&gt;X​::​assign(s[i], p[i])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a6ddee35ee106c63cce63cef04db68150835b00" translate="yes" xml:space="preserve">
          <source>For each declarator, the initializer may be one of the following:</source>
          <target state="translated">각 선언자에 대해 이니셜 라이저는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71cdc882df31450c88808b61a9ff32adee6518cf" translate="yes" xml:space="preserve">
          <source>For each distinct base class that is specified &lt;code&gt;virtual&lt;/code&gt;, the most derived object contains only one base class subobject of that type, even if the class appears many times in the inheritance hierarchy (as long as it is inherited &lt;code&gt;virtual&lt;/code&gt; every time).</source>
          <target state="translated">&lt;code&gt;virtual&lt;/code&gt; 으로 지정된 각각의 고유 한 기본 클래스에 대해, 클래스가 상속 계층 구조에 여러 번 나타날 때마다 (매번 &lt;code&gt;virtual&lt;/code&gt; 으로 상속되는 한) 가장 파생 된 오브젝트에는 해당 유형의 하나의 기본 클래스 서브 오브젝트 만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="5bfb358921b4b02768fb8323b116ca9ed3bbe11d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes</source>
          <target state="translated">각 요소 &lt;code&gt;va&lt;/code&gt; 계산해</target>
        </trans-unit>
        <trans-unit id="483eec964f0d73c99af70508de57de3007259d4d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc cosine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 요소에 대해 요소 값의 아크 코사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="adb75759a95a8aeb64e9736b66397da9bd1d4446" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc sine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 요소에 대해 요소 값의 아크 사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ca88cd5ed53414ce6dc3bf89279bd5da6137ef0b" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc tangent of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 요소에 대해 요소 값의 아크 탄젠트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f7b456dfebcb725eca2a813704a2d061981a4d5d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes common (base 10) logarithm of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 요소에 대해 요소 값의 공통 (기본 10) 로그를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="604bbd841643b027a383acee66008e7977d1d958" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes cosine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 요소에 대해 요소 값의 코사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6f10323acc53f3b6e728d81bacf3f244188492b8" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic cosine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 원소에 대해 원소 값의 쌍곡 코사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d1e0c67a77c4c9f3880463f9d8f3aa99bf732d31" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic sine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 요소에 대해 요소 값의 쌍곡 사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fea32eb8ad9df99ec39e088fce28cbee17276c80" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic tangent of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 요소에 대해 요소 값의 쌍곡 탄젠트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="cd3565d6513a55d7d6d649e63d9ef8dc096c132d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes natural logarithm of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 요소에 대해 요소 값의 자연 로그를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8613519bb915be734bdb83ddf1139c1436d679c7" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes sine of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 요소에 대해 요소 값의 사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="16f2ed1e42028d25247c7e709cdd5ffa277bdfdc" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes tangent of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 요소에 대해 요소 값의 탄젠트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2e8b5a06d41da5547ea77c34dce52624edf4f443" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes the square root of the value of the element.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 각 요소에 대해 요소 값의 제곱근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="de5098d9b31cace81235396b1ac2a117bb05f2f0" translate="yes" xml:space="preserve">
          <source>For each identifier, a variable whose type is &quot;reference to &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&amp;lt;i, E&amp;gt;::type&lt;/code&gt;&quot; is introduced: lvalue reference if its corresponding initializer is an lvalue, rvalue reference otherwise. The initializer for the i-th variable is.</source>
          <target state="translated">각 식별자에 대해 유형이 &quot; &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&amp;lt;i, E&amp;gt;::type&lt;/code&gt; &quot;에 대한 참조 인 변수 가 도입됩니다. 해당하는 이니셜 라이저가 lvalue이면 lvalue 참조, 그렇지 않으면 rvalue 참조. i 번째 변수의 이니셜 라이저는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5405c9dfb873a374ff065f865a38e9ad5451317" translate="yes" xml:space="preserve">
          <source>For each non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; in &lt;code&gt;T&lt;/code&gt; or in a base of &lt;code&gt;T&lt;/code&gt; (unless hidden), whose cv-qualifiers is same or greater than &lt;code&gt;T&lt;/code&gt;'s cv-qualifiers, and where the conversion function converts to:</source>
          <target state="translated">각각의 비 - 명시 들어 &lt;a href=&quot;cast_operator&quot;&gt;사용자 정의 된 변환 함수&lt;/a&gt; 에서 &lt;code&gt;T&lt;/code&gt; 또는 염기의 &lt;code&gt;T&lt;/code&gt; CV-한정자 동일하거나보다 크다 (숨김 제외), &lt;code&gt;T&lt;/code&gt; 의 CV-규정 한 변환 함수로 변환 :</target>
        </trans-unit>
        <trans-unit id="96919b66c472b53a5ced1aa599bee24bc87358ce" translate="yes" xml:space="preserve">
          <source>For each pair of viable function &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt;, the implicit conversion sequences from the &lt;code&gt;i&lt;/code&gt;-th argument to &lt;code&gt;i&lt;/code&gt;-th parameter are ranked to determine which one is better (except the first argument, the</source>
          <target state="translated">실행 가능한 함수 &lt;code&gt;F1&lt;/code&gt; 및 &lt;code&gt;F2&lt;/code&gt; 의 각 쌍에 대해 &lt;code&gt;i&lt;/code&gt; 번째 인수에서 &lt;code&gt;i&lt;/code&gt; 번째 매개 변수로 의 암시 적 변환 시퀀스 가 순위가 매겨져 어느 것이 더 나은지 결정합니다 (첫 번째 인수를 제외하고</target>
        </trans-unit>
        <trans-unit id="077e83335df9a76882a31f009c6cc740f8436fb9" translate="yes" xml:space="preserve">
          <source>For each such match &lt;code&gt;m&lt;/code&gt;, copies the non-matched subsequence (&lt;a href=&quot;match_results/prefix&quot;&gt;&lt;code&gt;m.prefix()&lt;/code&gt;&lt;/a&gt;) into &lt;code&gt;out&lt;/code&gt; as if by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(m.prefix().first, m.prefix().second, out)&lt;/code&gt; and then replaces the matched subsequence with the formatted replacement string as if by calling &lt;a href=&quot;match_results/format&quot;&gt;&lt;code&gt;out = m.format(out, fmt, flags)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 각 일치 &lt;code&gt;m&lt;/code&gt; 에 대해 &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(m.prefix().first, m.prefix().second, out)&lt;/code&gt; &lt;a href=&quot;../algorithm/copy&quot;&gt;std :: copy&lt;/a&gt; (m.prefix (). first, m.prefix (). second, out) 과 같이 일치하지 않는 하위 시퀀스 ( &lt;a href=&quot;match_results/prefix&quot;&gt; &lt;code&gt;m.prefix()&lt;/code&gt; &lt;/a&gt; )를 &lt;code&gt;out&lt;/code&gt; 으로 복사 합니다. 그런 다음 &lt;a href=&quot;match_results/format&quot;&gt; &lt;code&gt;out = m.format(out, fmt, flags)&lt;/code&gt; &lt;/a&gt; 를 호출하여 일치하는 하위 시퀀스를 형식이 지정된 대체 문자열로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="35a02408e3ec343aa382ddb9f4539b81b6f6a912" translate="yes" xml:space="preserve">
          <source>For each type, non-type, and template parameter, including parameter packs, a unique fictitious type, value, or template is generated and substituted into function type of the template</source>
          <target state="translated">매개 변수 팩을 포함한 각 유형, 비 유형 및 템플릿 매개 변수에 대해 고유 한 가상 유형, 값 또는 템플리트가 생성되어 템플리트의 함수 유형으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="952fe468d5ee316980e589da22eb6018ea32e1cd" translate="yes" xml:space="preserve">
          <source>For equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).</source>
          <target state="translated">원래 두 범위의 동등한 요소의 경우 첫 번째 범위의 요소 (원래 순서 유지)가 두 번째 범위의 요소 (원래 순서 유지)보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f8bf46aa49e5e80eadcaac2f31ab62ee0b13bf20" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;std::atomic&amp;lt;X&amp;gt;&lt;/code&gt; (whether or not specialized), &lt;code&gt;std::atomic&amp;lt;X&amp;gt;::value_type&lt;/code&gt; is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">모든 &lt;code&gt;std::atomic&amp;lt;X&amp;gt;&lt;/code&gt; (특별 화 여부에 관계없이)에 대해 &lt;code&gt;std::atomic&amp;lt;X&amp;gt;::value_type&lt;/code&gt; 은 &lt;code&gt;X&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="57dd021d134106ddd0d180af4fadda643026b891" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;&lt;/code&gt; (whether or not specialized), &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;::value_type&lt;/code&gt; is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">모든 &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;&lt;/code&gt; (특별 화 여부에 관계없이)에 대해 &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;::value_type&lt;/code&gt; 은 &lt;code&gt;X&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e51dc104fca63d5103f9e0cf646aa86197a6c341" translate="yes" xml:space="preserve">
          <source>For every T that is a pointer-to-member type or the type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, the following function signature participates in overload resolution:</source>
          <target state="translated">포인터 대 멤버 유형 또는 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 유형 인 모든 T 에 대해 다음 함수 시그니처가 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="d6a1bb30012f8a1244f1eb8a6420656d9d6e09c6" translate="yes" xml:space="preserve">
          <source>For every conversion specifier other than &lt;code&gt;n&lt;/code&gt;, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c2546abb31c7caf07bad20c6eabba4b2fe603e" translate="yes" xml:space="preserve">
          <source>For every enumeration or pointer to member type &lt;code&gt;T&lt;/code&gt;, optionally volatile-qualified, the following function signature participates in overload resolution:</source>
          <target state="translated">선택적으로 휘발성으로 한정된 멤버 유형 &lt;code&gt;T&lt;/code&gt; 에 대한 모든 열거 또는 포인터에 대해 다음 함수 시그니처가 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="88970b9a9ff96606e8a48b4759fd878eb0266d29" translate="yes" xml:space="preserve">
          <source>For every iterator type &lt;code&gt;It&lt;/code&gt;, a typedef &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_category&lt;/code&gt; is available, which is an alias to one of these five(until C++20)six(since C++20) tag types.</source>
          <target state="translated">모든 iterator 유형 &lt;code&gt;It&lt;/code&gt; 에 대해 typedef &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_category&lt;/code&gt; 를 사용할 수 있으며 이는 C ++ 20 이후 6 개 (C ++ 20 이후) 태그 유형 중 하나의 별명입니다.</target>
        </trans-unit>
        <trans-unit id="e71c9303eec62288eff7b54439f77781e36bc155" translate="yes" xml:space="preserve">
          <source>For every optionally cv-qualified object type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">선택적으로 cv-qualified 객체 유형 &lt;code&gt;T&lt;/code&gt; 에 대해 다음 함수 시그니처가 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="96c0842f465784a49ab8d68561798db17053d280" translate="yes" xml:space="preserve">
          <source>For every pair A1 and A2, where A1 is an arithmetic type (optionally volatile-qualified) and A2 is a promoted arithmetic type, the following function signature participates in overload resolution:</source>
          <target state="translated">모든 쌍 A1 및 A2에 대해 A1은 산술 유형 (선택적으로 휘발성으로 규정 됨)이고 A2는 승격 된 산술 유형으로 다음 함수 시그니처가 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="20e473aa5e7c31193000e4e17752d2e9b84efea5" translate="yes" xml:space="preserve">
          <source>For every pair I1 and I2, where I1 is an integral type (optionally volatile-qualified) and I2 is a promoted integral type, the following function signatures participate in overload resolution:</source>
          <target state="translated">모든 쌍 I1과 I2에서 I1이 정수형 (선택적으로 휘발성 정규화)이고 I2가 승격 정수형 인 경우 다음 함수 시그니처가 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="fef8c5eb5bd67258e2ec4544fa11f3c0a8bfa352" translate="yes" xml:space="preserve">
          <source>For every pair of promoted arithmetic types L and R and for every type P, where P is a pointer, pointer-to-member, or scoped enumeration type, the following function signatures participate in the overload resolution performed in step 5 of the rules above:</source>
          <target state="translated">승격 된 산술 유형 L과 R의 모든 쌍과 P가 포인터, 포인터 대 구성원 또는 범위 열거 유형 인 모든 유형 P에 대해 다음 함수 시그니처는 위 규칙의 5 단계에서 수행 된 과부하 해결에 참여합니다. :</target>
        </trans-unit>
        <trans-unit id="d638c80e090b37ee12468ee54f0147dce03100fb" translate="yes" xml:space="preserve">
          <source>For every parameter in params whose type is specified as &lt;code&gt;auto&lt;/code&gt;, an invented template parameter is added to template-params, in order of appearance. The invented template parameter may be a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; if the corresponding function member of params is a function parameter pack.</source>
          <target state="translated">유형이 &lt;code&gt;auto&lt;/code&gt; 로 지정된 매개 변수의 모든 매개 변수에 대해 발명 된 템플릿 매개 변수가 모양 순서대로 템플릿 매개 변수에 추가됩니다. 발명의 템플릿 파라미터는 &lt;a href=&quot;parameter_pack&quot;&gt;파라미터&lt;/a&gt; 의 대응하는 함수 멤버가 함수 파라미터 팩인 경우 파라미터 팩일 수있다 .</target>
        </trans-unit>
        <trans-unit id="859f56c75df09c6419c76fcbdbe8ae8dbb4f8aed" translate="yes" xml:space="preserve">
          <source>For every type &lt;code&gt;MP&lt;/code&gt; that is a pointer to member object or pointer to member function or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">멤버 객체 또는 멤버 함수 또는 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 대한 포인터 인 모든 &lt;code&gt;MP&lt;/code&gt; 유형 에 대해 다음 함수 시그니처가 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="5ba25517699790e207bae588adda9d67eb82eb32" translate="yes" xml:space="preserve">
          <source>For every type &lt;code&gt;P&lt;/code&gt; which is either pointer to object or pointer to function or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;(until C++14), the following function signatures participate in overload resolution:</source>
          <target state="translated">객체에 대한 포인터 또는 함수 또는 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; (C ++ 14까지)에 대한 포인터 인 모든 유형 &lt;code&gt;P&lt;/code&gt; 에 대해 다음 함수 시그니처가 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="ee4a3f0b05542f01bd799b3b751f77169b8294dd" translate="yes" xml:space="preserve">
          <source>For every type other than reference and function, the type system supports three additional &lt;a href=&quot;cv&quot;&gt;cv-qualified versions&lt;/a&gt; of that type (&lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, and &lt;code&gt;const volatile&lt;/code&gt;).</source>
          <target state="translated">참조 및 함수 이외의 모든 유형에 대해 유형 시스템은 해당 유형의 3 가지 추가 &lt;a href=&quot;cv&quot;&gt;cv 규정 버전&lt;/a&gt; ( &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; 및 &lt;code&gt;const volatile&lt;/code&gt; )을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ba768967270bb243200289babda957e1dccea676" translate="yes" xml:space="preserve">
          <source>For every valid value of &lt;code&gt;char_type&lt;/code&gt;, there must be a unique value of &lt;code&gt;int_type&lt;/code&gt; distinct from &lt;code&gt;eof()&lt;/code&gt;. For example, a common implementation of &lt;code&gt;char_traits&amp;lt;char&amp;gt;::eof()&lt;/code&gt; is &lt;code&gt;return -1&lt;/code&gt;, and a corresponding valid implementation of &lt;code&gt;char_traits&amp;lt;char&amp;gt;::to_int_type(c)&lt;/code&gt; is &lt;code&gt;return (unsigned char)c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char_type&lt;/code&gt; 의 모든 유효한 값에 대해 &lt;code&gt;eof()&lt;/code&gt; 와는 다른 고유 한 &lt;code&gt;int_type&lt;/code&gt; 값이 있어야합니다 . 예를 들어, &lt;code&gt;char_traits&amp;lt;char&amp;gt;::eof()&lt;/code&gt; 의 일반적인 구현 은 &lt;code&gt;return -1&lt;/code&gt; 이고, &lt;code&gt;char_traits&amp;lt;char&amp;gt;::to_int_type(c)&lt;/code&gt; 의 해당하는 유효한 구현 은 &lt;code&gt;return (unsigned char)c&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="220aba5bf092ed62052a3a23de11e863b192c055" translate="yes" xml:space="preserve">
          <source>For every virtual function, there is the</source>
          <target state="translated">모든 가상 기능에는</target>
        </trans-unit>
        <trans-unit id="96405e325a2957f41ae4e0cb514953a5e216ba60" translate="yes" xml:space="preserve">
          <source>For example when the regex flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; is set, then the sequence &lt;code&gt;[a-b]&lt;/code&gt; would match some character &lt;code&gt;c1&lt;/code&gt; if &lt;code&gt;traits.transform(&quot;a&quot;) &amp;lt;= traits.transform(c1) &amp;lt;= traits.transform(&quot;b&quot;)&lt;/code&gt;. Note that this function takes a character sequence as the argument to accomodate to the ranges defined like &lt;code&gt;[&lt;/code&gt;&lt;code&gt;[.ae.]-d]&lt;/code&gt;.</source>
          <target state="translated">정규식 플래그 예를 들어 &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; 설정되고, 그 다음 순서 &lt;code&gt;[a-b]&lt;/code&gt; 몇 문자 일치 할 &lt;code&gt;c1&lt;/code&gt; 경우 &lt;code&gt;traits.transform(&quot;a&quot;) &amp;lt;= traits.transform(c1) &amp;lt;= traits.transform(&quot;b&quot;)&lt;/code&gt; . 이 함수는 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;[.ae.]-d]&lt;/code&gt; 와 같이 정의 된 범위에 맞게 인수로 문자 시퀀스를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="21afdf58d530130e0cd1ecfb369c10eeeccc97f9" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;int b:3;&lt;/code&gt; may have the range of values &lt;code&gt;0..7&lt;/code&gt; or &lt;code&gt;-4..3&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;int b:3;&lt;/code&gt; 값의 범위는 &lt;code&gt;0..7&lt;/code&gt; 또는 &lt;code&gt;-4..3&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7d231fa0de4c53b5a41ff143b9ff0bc463fe738" translate="yes" xml:space="preserve">
          <source>For example, a gslice with starting index &lt;code&gt;3&lt;/code&gt;, strides &lt;code&gt;{19,4,1&lt;/code&gt;} and lengths &lt;code&gt;{2,4,3} &lt;/code&gt; generates the following set of indices:</source>
          <target state="translated">예를 들어, 시작 색인이 &lt;code&gt;3&lt;/code&gt; 이고 보폭이 &lt;code&gt;{19,4,1&lt;/code&gt; }이고 길이가 &lt;code&gt;{2,4,3} &lt;/code&gt; 인 gslice 는 다음 색인 세트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b98b27a6a16bb9a7bf0282ec3a82d51ac5557fa2" translate="yes" xml:space="preserve">
          <source>For example, given &lt;code&gt;const auto&amp;amp; i = expr;&lt;/code&gt;, the type of &lt;code&gt;i&lt;/code&gt; is exactly the type of the argument &lt;code&gt;u&lt;/code&gt; in an imaginary template &lt;code&gt;template&amp;lt;class U&amp;gt; void f(const U&amp;amp; u)&lt;/code&gt; if the function call &lt;code&gt;f(expr)&lt;/code&gt; was compiled. Therefore, &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; may be deduced either as an lvalue reference or rvalue reference according to the initializer, which is used in range-based for loop.</source>
          <target state="translated">예를 들어 &lt;code&gt;const auto&amp;amp; i = expr;&lt;/code&gt; 의 종류 &lt;code&gt;i&lt;/code&gt; 정확하게 인수의 타입 &lt;code&gt;u&lt;/code&gt; 허수 템플릿에 &lt;code&gt;template&amp;lt;class U&amp;gt; void f(const U&amp;amp; u)&lt;/code&gt; 함수 호출의 경우, &lt;code&gt;f(expr)&lt;/code&gt; 컴파일되었다. 따라서 &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; 는 범위 기반 for 루프에서 사용되는 이니셜 라이저에 따라 lvalue 참조 또는 rvalue 참조로 추론 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b64fbd2e8414cb52362895b9416d02f046ec2ac9" translate="yes" xml:space="preserve">
          <source>For example, if a wrapper does not just forward its argument, but calls a member function on the argument, and forwards its result:</source>
          <target state="translated">예를 들어, 랩퍼가 인수를 전달하는 것이 아니라 인수에서 멤버 함수를 호출하고 결과를 전달하는 경우 :</target>
        </trans-unit>
        <trans-unit id="3ad08d76cd3366adf2e4002a2a86eba860f92547" translate="yes" xml:space="preserve">
          <source>For example, if used in wrapper such as the following, the template behaves as described below:</source>
          <target state="translated">예를 들어, 다음과 같은 랩퍼에서 사용되는 경우 템플리트는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="17f92461460ba9421050f5a120102adab4bd7d16" translate="yes" xml:space="preserve">
          <source>For example, in:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f787b27b81522ff7994a2b1d11b99ed11a43f0f" translate="yes" xml:space="preserve">
          <source>For example, on Windows, where &lt;code&gt;\&lt;/code&gt; is the preferred separator, the path &lt;code&gt;foo/bar&lt;/code&gt; will be converted to &lt;code&gt;foo\bar&lt;/code&gt;.</source>
          <target state="translated">예를 들어, Windows에서 &lt;code&gt;\&lt;/code&gt; 가 기본 구분 기호 인 경우 &lt;code&gt;foo/bar&lt;/code&gt; 경로 는 &lt;code&gt;foo\bar&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c80798c74b99761f9f8d6a1d7f496bb6f7e553ba" translate="yes" xml:space="preserve">
          <source>For example, on some platforms, bit fields don't straddle bytes, on others they do</source>
          <target state="translated">예를 들어, 일부 플랫폼에서 비트 필드는 바이트를 차지하지 않고 다른 플랫폼에서는 바이트를 차지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2df7d9cb75dfece63f96a9945f6d4796b35277d" translate="yes" xml:space="preserve">
          <source>For example, the composite pointer type of &lt;code&gt;void*&lt;/code&gt; and &lt;code&gt;const int*&lt;/code&gt; is &lt;code&gt;const void*&lt;/code&gt;. The composite pointer type of &lt;code&gt;int**&lt;/code&gt; and &lt;code&gt;const int**&lt;/code&gt; is &lt;code&gt;const int* const*&lt;/code&gt;. Note that until C++14, &lt;code&gt;int**&lt;/code&gt; and &lt;code&gt;const int**&lt;/code&gt; could not be compared.</source>
          <target state="translated">예를 들어, &lt;code&gt;void*&lt;/code&gt; 와 &lt;code&gt;const int*&lt;/code&gt; 의 복합 포인터 유형 은 &lt;code&gt;const void*&lt;/code&gt; 입니다. &lt;code&gt;int**&lt;/code&gt; 및 &lt;code&gt;const int**&lt;/code&gt; 의 복합 포인터 유형 은 &lt;code&gt;const int* const*&lt;/code&gt; 입니다. C ++ 14까지는 &lt;code&gt;int**&lt;/code&gt; 와 &lt;code&gt;const int**&lt;/code&gt; 비교할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="62bb742426a794f8be0f5a25a2d2f7632ae88b7a" translate="yes" xml:space="preserve">
          <source>For example, the following class template does not use the type T in its private members or in the body of push_back.</source>
          <target state="translated">예를 들어 다음 클래스 템플릿은 전용 멤버 또는 push_back 본문에서 T 유형을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c6f9185eeed0381f9dd1d89f296fbc5ee5be5b1" translate="yes" xml:space="preserve">
          <source>For example, to compile &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;;&lt;/code&gt;, the compiler performs:</source>
          <target state="translated">예를 들어, &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;;&lt;/code&gt; 컴파일러는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9d4b3358e1df9f2bea37a27eaa5e14ffa2bc6778" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2cbbd695a1dfd1a4a615d31b844bf65755121de" translate="yes" xml:space="preserve">
          <source>For floating-point &amp;alpha;, the value obtained is the sum of &amp;alpha; independent exponentially distributed random variables, each of which has a mean of &amp;beta;</source>
          <target state="translated">부동 소수점 &amp;alpha;의 경우, 획득 한 값은 &amp;alpha; 독립 지수 분포 랜덤 변수의 합으로, 각각의 평균은 &amp;beta;입니다.</target>
        </trans-unit>
        <trans-unit id="37bba3e4eccd73e2ef72c749ab8c25e15efc6e60" translate="yes" xml:space="preserve">
          <source>For floating-point types with denormalization, &lt;code&gt;min&lt;/code&gt; returns the minimum positive normalized value.</source>
          <target state="translated">비정규 화를 사용하는 부동 소수점 유형의 경우 &lt;code&gt;min&lt;/code&gt; 은 양의 정규화 된 최소값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b593b953b77c2c511c9c9e8acca67b444d03c30c" translate="yes" xml:space="preserve">
          <source>For floating-point types, if &lt;code&gt;showpoint&lt;/code&gt; is set, the modifier &lt;code&gt;#&lt;/code&gt; is prepended.</source>
          <target state="translated">부동 소수점 유형의 경우 &lt;code&gt;showpoint&lt;/code&gt; 점이 설정되면 수정 자 &lt;code&gt;#&lt;/code&gt; 가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="52fff2d809b2cb152e5b4a1ad6291720dc27d5c1" translate="yes" xml:space="preserve">
          <source>For floating-point types, the &lt;a href=&quot;../../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; in effect may be different from the calling thread's floating-point environment. The operation need not be conform to the corresponding &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; traits but is encouraged to do so. If the result is not a representable value for its type, the result is unspecified but the operation otherwise has no undefined behavior.</source>
          <target state="translated">부동 소수점 유형의 경우 실제로 &lt;a href=&quot;../../numeric/fenv&quot;&gt;부동 소수점 환경&lt;/a&gt; 은 호출 스레드의 부동 소수점 환경과 다를 수 있습니다. 작업은 해당 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; 특성을 준수 할 필요 는 없지만 그렇게하는 것이 좋습니다. 결과가 해당 유형의 표현 가능한 값이 아닌 경우 결과는 지정되지 않지만 조작에는 정의되지 않은 동작이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ab94c8e0b590e7f556887eaae16aec44908d571" translate="yes" xml:space="preserve">
          <source>For function and function template names, name lookup can associate multiple declarations with the same name, and may obtain additional declarations from &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;. &lt;a href=&quot;function_template&quot;&gt;Template argument deduction&lt;/a&gt; may also apply, and the set of declarations is passed to &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, which selects the declaration that will be used. &lt;a href=&quot;access&quot;&gt;Member access&lt;/a&gt; rules, if applicable, are considered only after name lookup and overload resolution.</source>
          <target state="translated">함수 및 함수 템플릿 이름의 경우 이름 조회는 여러 선언을 동일한 이름과 연관시킬 수 있으며 &lt;a href=&quot;adl&quot;&gt;인수 종속 조회&lt;/a&gt; 에서 추가 선언을 얻을 수 있습니다 . &lt;a href=&quot;function_template&quot;&gt;템플릿 인수 공제&lt;/a&gt; 도 적용될 수 있으며 선언 세트는 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결&lt;/a&gt; 로 전달되어 사용될 선언을 선택합니다. 해당되는 경우 &lt;a href=&quot;access&quot;&gt;회원 액세스&lt;/a&gt; 규칙은 이름 조회 및 과부하 해결 후에 만 ​​고려됩니다.</target>
        </trans-unit>
        <trans-unit id="36d9c94cd9c3cc36a9b671f755d250722c29f111" translate="yes" xml:space="preserve">
          <source>For functions, specifies that the return type will be deduced from its return statements.</source>
          <target state="translated">함수의 경우 리턴 유형에서 리턴 유형을 추론하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f9d92b090fe79a87f7ef3997de21c665c200fc40" translate="yes" xml:space="preserve">
          <source>For initialization of locals (that is, block scope) static and thread-local variables, see &lt;a href=&quot;storage_duration#Static_local_variables&quot;&gt;static local variables&lt;/a&gt;.</source>
          <target state="translated">로컬 (즉, 블록 범위) 정적 및 스레드 로컬 변수의 초기화에 대해서는 &lt;a href=&quot;storage_duration#Static_local_variables&quot;&gt;정적 로컬 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac4327b8179e23975065e9af7bd05ec6be15b5bc" translate="yes" xml:space="preserve">
          <source>For input streams (&lt;code&gt;mode &amp;amp; ios_base::in == true&lt;/code&gt;), &lt;code&gt;eback()&lt;/code&gt; points at the first character, &lt;code&gt;gptr() == eback()&lt;/code&gt;, and &lt;code&gt;egptr() == eback() + s.size()&lt;/code&gt;: the subsequent input will read the first character copied from &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">입력 스트림 ( &lt;code&gt;mode &amp;amp; ios_base::in == true&lt;/code&gt; )의 경우, &lt;code&gt;eback()&lt;/code&gt; 은 첫 번째 문자, &lt;code&gt;gptr() == eback()&lt;/code&gt; 및 &lt;code&gt;egptr() == eback() + s.size()&lt;/code&gt; . 후속 입력은 &lt;code&gt;s&lt;/code&gt; 에서 복사 된 첫 번째 문자를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="ec3905377a1c94d495d985035e68f7411ea9980d" translate="yes" xml:space="preserve">
          <source>For input streams (and for update streams on which the last operation was input), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3263d60841f8b602b9cc58bd2747c0e72fde62e4" translate="yes" xml:space="preserve">
          <source>For integer &lt;code&gt;arg&lt;/code&gt;, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5f0c55df7482886d0bbb61dde66b50525bc79d" translate="yes" xml:space="preserve">
          <source>For integer types, if &lt;code&gt;showbase&lt;/code&gt; is set, the modifier &lt;code&gt;#&lt;/code&gt; is prepended.</source>
          <target state="translated">정수 유형의 경우 &lt;code&gt;showbase&lt;/code&gt; 가 설정된 경우 수정 자 &lt;code&gt;#&lt;/code&gt; 이 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="cf8479d95c472194fb01daf6a842e55ed66b89af" translate="yes" xml:space="preserve">
          <source>For integer types, length modifier is added to the conversion specification if necessary: &lt;code&gt;h&lt;/code&gt; for &lt;code&gt;short&lt;/code&gt; and &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; for &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;ll&lt;/code&gt; for &lt;code&gt;long long&lt;/code&gt; and &lt;code&gt;unsigned long long&lt;/code&gt;</source>
          <target state="translated">: 필요한 경우 정수 유형의 길이 수정은 변환 명세서에 추가 &lt;code&gt;h&lt;/code&gt; 에 대한 &lt;code&gt;short&lt;/code&gt; 와 &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; 에 대한 &lt;code&gt;long&lt;/code&gt; 및 &lt;code&gt;unsigned long&lt;/code&gt; 을 , &lt;code&gt;ll&lt;/code&gt; 위한 &lt;code&gt;long long&lt;/code&gt; 와 &lt;code&gt;unsigned long long&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6101d794e56d2d1f4f0a50cfba90d4442ea8210d" translate="yes" xml:space="preserve">
          <source>For integer types, length modifier is added to the conversion specification if necessary: &lt;code&gt;l&lt;/code&gt; for &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;ll&lt;/code&gt; for &lt;code&gt;long long&lt;/code&gt; and &lt;code&gt;unsigned long long&lt;/code&gt;(since C++11).</source>
          <target state="translated">: 필요한 경우 정수 유형의 길이 수정은 변환 명세에 추가된다 &lt;code&gt;l&lt;/code&gt; 위한 &lt;code&gt;long&lt;/code&gt; 와 &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;ll&lt;/code&gt; 위한 &lt;code&gt;long long&lt;/code&gt; 와 &lt;code&gt;unsigned long long&lt;/code&gt; (C ++은 11부터).</target>
        </trans-unit>
        <trans-unit id="9635f0a469e86775a961c9f4f06c2d75d2ad2838" translate="yes" xml:space="preserve">
          <source>For integral and arithmetic types, the template argument provided during instantiation must be a &lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of the template parameter's type (so certain implicit conversion applies).</source>
          <target state="translated">정수 및 산술 유형의 경우 인스턴스화 중에 제공된 템플릿 인수 는 템플릿 매개 변수 유형의 &lt;a href=&quot;constant_expression&quot;&gt;변환 된 상수 표현식&lt;/a&gt; 이어야합니다 (따라서 특정 암시 적 변환이 적용됨).</target>
        </trans-unit>
        <trans-unit id="888e66ad3cd1de9e2997f82859b81050f3f98936" translate="yes" xml:space="preserve">
          <source>For integral arguments, &lt;a href=&quot;abs&quot;&gt;the integral overloads of &lt;code&gt;std::abs&lt;/code&gt;&lt;/a&gt; are likely better matches. If &lt;code&gt;std::abs&lt;/code&gt; is called with an argument of type &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; cannot be converted to &lt;code&gt;int&lt;/code&gt; by &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">적분 인수 &lt;a href=&quot;abs&quot;&gt;의 경우 &lt;code&gt;std::abs&lt;/code&gt; &lt;/a&gt; 의 적분 과부하가 더 잘 일치합니다. 경우 &lt;code&gt;std::abs&lt;/code&gt; 유형의 인수로 호출 &lt;code&gt;X&lt;/code&gt; 등이 &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;X&lt;/code&gt; 는 변환 할 수 없습니다 &lt;code&gt;int&lt;/code&gt; 에 의해 &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;통합 홍보&lt;/a&gt; , 프로그램이 잘못 형성된다.</target>
        </trans-unit>
        <trans-unit id="1060ee889330db82947214695c2314922ae38003" translate="yes" xml:space="preserve">
          <source>For integral operands, it yields the algebraic quotient.</source>
          <target state="translated">정수 피연산자의 경우 대수 몫이 산출됩니다.</target>
        </trans-unit>
        <trans-unit id="88259ad2a8442b91aaef00f672b4f16ecba02e17" translate="yes" xml:space="preserve">
          <source>For lvalue reference parameters, the argument provided at instantiation cannot be a temporary, an unnamed lvalue, or a named lvalue with no linkage (in other words, the argument must have linkage).</source>
          <target state="translated">lvalue 참조 매개 변수의 경우 인스턴스화시 제공되는 인수는 임시, 이름이없는 lvalue 또는 연계가없는 명명 된 lvalue 일 수 없습니다 (즉, 인수에 연계가 있어야 함).</target>
        </trans-unit>
        <trans-unit id="07ec985082848563aa89c0c13f4926e059b3c9cc" translate="yes" xml:space="preserve">
          <source>For member functions of class &lt;code&gt;X&lt;/code&gt;, the type of the implicit object parameter is affected by cv-qualifications and ref-qualifications of the member function as described in &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;.</source>
          <target state="translated">클래스의 멤버 함수 &lt;code&gt;X&lt;/code&gt; 에서 기술 된 바와 같이, 내재 된 오브젝트 파라미터의 종류는 CV-자격 멤버 함수의 REF-자격에 의해 영향을 &lt;a href=&quot;member_functions&quot;&gt;멤버 함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19791e90c11ccaf6d487d6bb230d6565f3784cc4" translate="yes" xml:space="preserve">
          <source>For most &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;std::proj(z)==z&lt;/code&gt;, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, 0)&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, -0)&lt;/code&gt;. The sign of the imaginary (zero) component is the sign of &lt;code&gt;&lt;a href=&quot;imag2&quot;&gt;std::imag&lt;/a&gt;(z)&lt;/code&gt;.</source>
          <target state="translated">대부분의 &lt;code&gt;z&lt;/code&gt; 의 경우 &lt;code&gt;std::proj(z)==z&lt;/code&gt; 이지만 한 구성 요소가 무한하고 다른 구성 요소가 NaN 인 숫자까지도 모든 복잡한 무한대는 양의 실수로 무한대가됩니다 &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, 0)&lt;/code&gt; 또는 &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, -0)&lt;/code&gt; . 허수 (제로) 성분의 부호는 &lt;code&gt;&lt;a href=&quot;imag2&quot;&gt;std::imag&lt;/a&gt;(z)&lt;/code&gt; 의 부호입니다 .</target>
        </trans-unit>
        <trans-unit id="dedc12147e0e26b892c9c3c4c65e52f5512feb4a" translate="yes" xml:space="preserve">
          <source>For multi-level pointers, the following restrictions apply: a multilevel pointer &lt;code&gt;P1&lt;/code&gt; which is cv1</source>
          <target state="translated">다중 레벨 포인터의 경우 다음 제한 사항이 적용됩니다. cv1 인 다중 레벨 포인터 &lt;code&gt;P1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="376ecc03409163c2995d77d8d27738cf7cb39e45" translate="yes" xml:space="preserve">
          <source>For negative &lt;code&gt;a&lt;/code&gt;, the behavior of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is undefined.</source>
          <target state="translated">음수 &lt;code&gt;a&lt;/code&gt; 의 경우 &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 의 동작 은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1494de8919bb1c4ea96591e8c652173df74c133c" translate="yes" xml:space="preserve">
          <source>For negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is implementation-defined (in most implementations, this performs arithmetic right shift, so that the result remains negative).</source>
          <target state="translated">음수 &lt;code&gt;a&lt;/code&gt; 의 경우 &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; 값 은 구현에 따라 정의됩니다 (대부분의 구현에서 산술 오른쪽 이동을 수행하므로 결과는 음수로 유지됨).</target>
        </trans-unit>
        <trans-unit id="8d245548c2af614dd2b79e9d581bbfee18630af5" translate="yes" xml:space="preserve">
          <source>For non-&lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; class types, members with the same &lt;a href=&quot;access&quot;&gt;member access&lt;/a&gt; are always allocated so that the members declared later have higher addresses within a class object. Members with different access control are allocated in unspecified order (the compiler may group them together). Alignment requirements may necessitate padding between members, or after the last member of a class.</source>
          <target state="translated">비 &lt;a href=&quot;union&quot;&gt;유니언&lt;/a&gt; 클래스 유형의 경우, 동일한 &lt;a href=&quot;access&quot;&gt;멤버 액세스 권한을&lt;/a&gt; 가진 멤버 는 항상 할당되므로 나중에 선언 된 멤버는 클래스 오브젝트 내에서 더 높은 주소를 갖습니다. 액세스 제어가 다른 멤버는 지정되지 않은 순서로 할당됩니다 (컴파일러는 그룹화 할 수 있음). 정렬 요구 사항은 멤버 간 패딩이 필요하거나 클래스의 마지막 멤버 이후에 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b6b58d70b3d593d4d88872f97e32d333db88729" translate="yes" xml:space="preserve">
          <source>For non-appending output streams, &lt;code&gt;pptr() == pbase()&lt;/code&gt;, so that subsequent output will overwrite the characters copied from &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">추가되지 않는 출력 스트림의 경우 &lt;code&gt;pptr() == pbase()&lt;/code&gt; 이므로 후속 출력은 &lt;code&gt;s&lt;/code&gt; 에서 복사 된 문자를 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="606fb425d7d848cb68effbf7891839f3901900f6" translate="yes" xml:space="preserve">
          <source>For non-array &lt;code&gt;type&lt;/code&gt;, the single object is constructed in the acquired memory area.</source>
          <target state="translated">배열이 아닌 &lt;code&gt;type&lt;/code&gt; 의 경우 단일 객체가 획득 된 메모리 영역에 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e50302a0b35323ade517a1a99cf0e861fd9f2ad" translate="yes" xml:space="preserve">
          <source>For non-class types, copy and move assignment are indistinguishable and are referred to as</source>
          <target state="translated">비 클래스 유형의 경우 복사 및 이동 지정은 구별 할 수 없으며</target>
        </trans-unit>
        <trans-unit id="961645d5c1ea45b10c1dab6cd681b33d3b3e7623" translate="yes" xml:space="preserve">
          <source>For non-class types, the right operand is first &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to the cv-unqualified type of the left operand, and then its value is copied into the object identified by left operand.</source>
          <target state="translated">비 클래스 유형의 경우 오른쪽 피연산자는 먼저 왼쪽 피연산자의 cv 규정되지 않은 유형으로 &lt;a href=&quot;implicit_cast&quot;&gt;내재적으로 변환 된&lt;/a&gt; 다음 해당 값이 왼쪽 피연산자로 식별 된 오브젝트에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="763322c7964e589eee6959c4585b224d003bfdec" translate="yes" xml:space="preserve">
          <source>For non-polymorphic objects, the interpretation of the value is determined from the expression in which the object is used, and is decided at compile time.</source>
          <target state="translated">비다 형성 객체의 경우 값 해석은 객체가 사용 된 표현식에서 결정되며 컴파일 타임에 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="abfd29ae0e4b12baa41dd1f2957ee892d3a0b889" translate="yes" xml:space="preserve">
          <source>For non-template functions, default arguments can be added to a function that was already declared if the function is redeclared in the same scope. At the point of a function call, the defaults are a union of the defaults provided in all visible declarations for the function. A redeclaration cannot introduce a default for an argument for which a default is already visible (even if the value is the same). A re-declaration in an inner scope does not acquire the default arguments from outer scopes.</source>
          <target state="translated">템플릿이 아닌 함수의 경우 함수가 동일한 범위에서 다시 선언 된 경우 이미 선언 된 함수에 기본 인수를 추가 할 수 있습니다. 함수 호출 시점에서 기본값은 함수에 대해 보이는 모든 선언에서 제공되는 기본값의 합집합입니다. 재 선언은 기본값이 이미 보이는 인수에 대해 기본값을 도입 할 수 없습니다 (값이 같은 경우에도). 내부 범위에서 선언은 외부 범위에서 기본 인수를 얻지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0991570f4540f46325a93449ba04cca879b380b0" translate="yes" xml:space="preserve">
          <source>For non-type template parameter packs whose type uses a placeholder type, the type is independently deduced for each template argument and need not match:</source>
          <target state="translated">형식이 자리 표시 자 형식을 사용하는 형식이 아닌 템플릿 매개 변수 팩의 경우 형식은 각 템플릿 인수에 대해 독립적으로 추론되며 일치하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="bd5aba2924605ce9fcbd81eb53c058fae5c7dea4" translate="yes" xml:space="preserve">
          <source>For non-type template parameters, specifies that the type will be deduced from the argument.</source>
          <target state="translated">유형이 아닌 템플릿 매개 변수의 경우 유형이 인수에서 추론되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7514bfabe1453bf3e4fa04b102092e65768ddd6d" translate="yes" xml:space="preserve">
          <source>For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the move assignment operator performs full member-wise move assignment of the object's direct bases and immediate non-static members, in their declaration order, using built-in assignment for the scalars, memberwise move-assignment for arrays, and move assignment operator for class types (called non-virtually).</source>
          <target state="translated">비 유니언 클래스 유형 ( &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;struct&lt;/code&gt; )의 경우 이동 지정 연산자는 스칼라에 대한 기본 제공 지정 (멤버 별)을 사용하여 선언 순서대로 오브젝트의 직접 기본 및 즉시 비 정적 멤버의 전체 멤버 측 이동 지정을 수행합니다. 배열에 대한 이동 할당 및 클래스 유형에 대한 이동 할당 연산자 (가상적으로 불림).</target>
        </trans-unit>
        <trans-unit id="268fe4cbc20a4aa0215c7d01242785136c98fb6e" translate="yes" xml:space="preserve">
          <source>For nonempty ranges, exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - 1&lt;/code&gt; applications of the corresponding predicate.</source>
          <target state="translated">비어 있지 않은 범위의 경우 정확히 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - 1&lt;/code&gt; 해당 술어의 1 개의 응용 프로그램.</target>
        </trans-unit>
        <trans-unit id="f6180b71feea7358927f872628400b8246c94135" translate="yes" xml:space="preserve">
          <source>For nonempty ranges, exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last) -1&lt;/code&gt; applications of the corresponding predicate.</source>
          <target state="translated">비어 있지 않은 범위 의 경우, 해당 술어의 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last) -1&lt;/code&gt; 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="6147555f2527654078938dabd88a3dffc2574f9a" translate="yes" xml:space="preserve">
          <source>For objects of non-aggregate class type, a public &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructor&lt;/a&gt; must be defined (either user-defined or implicitly defined) to satisfy DefaultConstructible.</source>
          <target state="translated">집계되지 않은 클래스 유형의 오브젝트의 경우 DefaultConstructible을 충족시키기 위해 공용 &lt;a href=&quot;../language/default_constructor&quot;&gt;기본 생성자&lt;/a&gt; 를 정의해야합니다 (사용자 정의 또는 암시 적으로 정의).</target>
        </trans-unit>
        <trans-unit id="5e455249348a9249c3d467d0641b99a240d6d8c9" translate="yes" xml:space="preserve">
          <source>For other contexts where overloaded function names can appear, see &lt;a href=&quot;overloaded_address&quot;&gt;taking the address of an overloaded function&lt;/a&gt;.</source>
          <target state="translated">오버로드 된 함수 이름이 나타날 수있는 다른 컨텍스트는 오버로드 된 함수 &lt;a href=&quot;overloaded_address&quot;&gt;의 주소를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2bc8579aeb917ea35ac1bcbad18eb05fd4bdc45" translate="yes" xml:space="preserve">
          <source>For output streams (&lt;code&gt;mode &amp;amp; ios_base::out == true&lt;/code&gt;), &lt;code&gt;pbase()&lt;/code&gt; points at the first character and &lt;code&gt;epptr() &amp;gt;= pbase() + s.size()&lt;/code&gt; (epptr is allowed to point farther so that the following &lt;code&gt;sputc()&lt;/code&gt; wouldn't immediately call &lt;code&gt;overflow()&lt;/code&gt;)</source>
          <target state="translated">출력 스트림 ( &lt;code&gt;mode &amp;amp; ios_base::out == true&lt;/code&gt; )의 경우 &lt;code&gt;pbase()&lt;/code&gt; 는 첫 번째 문자를 &lt;code&gt;epptr() &amp;gt;= pbase() + s.size()&lt;/code&gt; (epptr은 더 멀리 가리켜 서 다음 &lt;code&gt;sputc()&lt;/code&gt; 를 호출 즉시 않을 것이다 &lt;code&gt;overflow()&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8f63d9afe770e3006ba3c31bb680ec6934c94657" translate="yes" xml:space="preserve">
          <source>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the &lt;code&gt;stream&lt;/code&gt;'s buffer to the associated output device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481575f6bdf13b67deef2e241c2a9a6d1c8d891f" translate="yes" xml:space="preserve">
          <source>For output streams, this typically results in writing the contents of the put area into the associated sequence, i.e. flushing of the output buffer. For input streams, this typically empties the get area and forces a re-read from the associated sequence to pick up recent changes. The default behavior (found, for example, in &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;), is to do nothing.</source>
          <target state="translated">출력 스트림의 경우, 이는 일반적으로 풋 영역의 내용을 연관된 시퀀스에 기록, 즉 출력 버퍼의 플러싱을 초래한다. 입력 스트림의 경우 일반적으로 가져 오기 영역을 비우고 관련 시퀀스에서 다시 읽도록하여 최근 변경 사항을 가져옵니다. 기본 동작 (예 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; )은 아무 것도하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a6ae1e52a83b6ade1ae039896874969c5f21c0bf" translate="yes" xml:space="preserve">
          <source>For overload (5), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, const U&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">과부하 (5)의 경우 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, const U&amp;amp;&amp;gt;&lt;/code&gt; 는 모두 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75a2c90c2bfc30a317a46c88b8a56739d5f6fa1d" translate="yes" xml:space="preserve">
          <source>For overload (6), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">과부하 (6)의 경우 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; 는 모두 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2780c151ef71bd4320af5b5a8131bcdca9bcbb78" translate="yes" xml:space="preserve">
          <source>For overloads (1,2), if one of the parameters is an rvalue, the reference returned becomes a dangling reference at the end of the full expression that contains the call to &lt;code&gt;minmax&lt;/code&gt;:</source>
          <target state="translated">과부하 (1,2)의 경우, 매개 변수 중 하나가 rvalue 인 경우 반환 된 참조는 &lt;code&gt;minmax&lt;/code&gt; 에 대한 호출을 포함하는 전체 식 끝에 댕글 링 참조가됩니다 .</target>
        </trans-unit>
        <trans-unit id="8382a9060c467fcc4ada14b4b211aabe3aa6d683" translate="yes" xml:space="preserve">
          <source>For overloads (3,5,7,9), The function can be implemented with the return type different from &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;. In this case, the replacement type has the following properties:</source>
          <target state="translated">과부하 (3,5,7,9)의 경우 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 와 다른 반환 유형으로 함수를 구현할 수 있습니다 . 이 경우 교체 유형에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e863547ad76debf1e954b0555a0ab321eb1a4d01" translate="yes" xml:space="preserve">
          <source>For pointers to functions, the valid arguments are pointers to functions with linkage (or constant expressions that evaluate to null pointer values).</source>
          <target state="translated">함수에 대한 포인터의 경우 유효한 인수는 연결 기능이있는 함수 (또는 null 포인터 값으로 평가되는 상수 식)에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="0c14d4f91a6fd67c34187b14315456bf4871a9d3" translate="yes" xml:space="preserve">
          <source>For pointers to member functions and pointers to data members, &lt;code&gt;t1&lt;/code&gt; may be a regular pointer or an object of class type that overloads &lt;code&gt;operator*&lt;/code&gt;, such as &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">멤버 함수에 대한 포인터 및 데이터 멤버에 대한 포인터의 경우 &lt;code&gt;t1&lt;/code&gt; 은 일반 포인터 또는 &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 과 같이 &lt;code&gt;operator*&lt;/code&gt; 를 오버로드하는 클래스 유형의 객체 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a71d4a336a0c5624e650b25202bdefde98d600fd" translate="yes" xml:space="preserve">
          <source>For pointers to members, the argument has to be a pointer to member expressed as &lt;code&gt;&amp;amp;Class::Member&lt;/code&gt; or a constant expression that evaluates to null pointer or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">멤버에 대한 포인터의 경우 인수는 &lt;code&gt;&amp;amp;Class::Member&lt;/code&gt; 로 표시되는 멤버에 대한 포인터이거나 널 포인터 또는 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 값으로 평가되는 상수 표현식 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="a1d3d2317fc6b323549d75e48efcd87a6d6fa4bd" translate="yes" xml:space="preserve">
          <source>For pointers to objects, the template arguments have to designate the address of a complete object with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; and a &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt; (either internal or external), or a constant expression that evaluates to the appropriate null pointer or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">객체에 대한 포인터의 경우 템플릿 인수는 정적 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간&lt;/a&gt; 과 &lt;a href=&quot;storage_duration#Linkage&quot;&gt;연결&lt;/a&gt; (내부 또는 외부) 또는 적절한 null 포인터 또는 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 값으로 평가되는 상수식이 있는 완전한 객체의 주소를 지정 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="62b3bed6c74847c88d09ff91b5a9eb3064f5365b" translate="yes" xml:space="preserve">
          <source>For portable directory and file naming, see &lt;a href=&quot;../../filesystem&quot;&gt;C++ filesystem library&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/1_56_0/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystem&lt;/a&gt;.</source>
          <target state="translated">이식 가능한 디렉토리 및 파일 이름은 &lt;a href=&quot;../../filesystem&quot;&gt;C ++ 파일 시스템 라이브러리&lt;/a&gt; 또는 &lt;a href=&quot;http://www.boost.org/doc/libs/1_56_0/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystem을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb935bbe4c86edf17255328af95f195fe665edf1" translate="yes" xml:space="preserve">
          <source>For portable pathname generation from Unicode strings, see &lt;a href=&quot;u8path&quot;&gt;u8path&lt;/a&gt;.</source>
          <target state="translated">유니 코드 문자열에서 이식 가능한 경로 이름 생성에 대해서는 &lt;a href=&quot;u8path&quot;&gt;u8path를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dfb375daadbb3e77fbf4f5775a23c9dc598be6b" translate="yes" xml:space="preserve">
          <source>For proper values of &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, the following properties are true:</source>
          <target state="translated">적절한 &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;j&lt;/code&gt; 값의 경우 다음 특성이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="530c267bd41398cdf37d989d6c0ff07e1066ef3d" translate="yes" xml:space="preserve">
          <source>For prvalue expressions, the dynamic type is always the same as the static type.</source>
          <target state="translated">prvalue 표현식의 경우 동적 유형은 항상 정적 유형과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="adfb2dec7da66f103fd2b9cd71521128041db54d" translate="yes" xml:space="preserve">
          <source>For signed &lt;code&gt;Integral&lt;/code&gt; types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results.</source>
          <target state="translated">부호있는 &lt;code&gt;Integral&lt;/code&gt; 유형의 경우 2의 보수 표시를 사용하도록 산술이 정의됩니다. 정의되지 않은 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed5e530786bebc7b272d33fe3e9f636b75dcece4" translate="yes" xml:space="preserve">
          <source>For signed and non-negative &lt;code&gt;a&lt;/code&gt;, if a * 2b</source>
          <target state="translated">부호가 있고 음 &lt;code&gt;a&lt;/code&gt; 아닌 a 의 경우 a * 2b</target>
        </trans-unit>
        <trans-unit id="3af751b6ecf63d4481061bc54946dd23bc4bd1ff" translate="yes" xml:space="preserve">
          <source>For signed and non-negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is a * 2b</source>
          <target state="translated">부호가 있고 음 &lt;code&gt;a&lt;/code&gt; 아닌 &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 의 경우 a &amp;lt;&amp;lt; b 의 값 은 a * 2b</target>
        </trans-unit>
        <trans-unit id="8d1075cea1a2a6de71e067eda636b7104a7e1c7b" translate="yes" xml:space="preserve">
          <source>For signed integral types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results.</source>
          <target state="translated">부호있는 정수 유형의 경우 산술은 2의 보수 표현을 사용하도록 정의됩니다. 정의되지 않은 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7df120d1e9011ddd1ce77a96f4b12ae1b34f6af9" translate="yes" xml:space="preserve">
          <source>For some &lt;code&gt;j&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, &lt;code&gt;X​::​lt(p[j], q[j])&lt;/code&gt; is true and</source>
          <target state="translated">일부 &lt;code&gt;j&lt;/code&gt; 의 &lt;code&gt;[0,n)&lt;/code&gt; , &lt;code&gt;X​::​lt(p[j], q[j])&lt;/code&gt; 에 해당하며</target>
        </trans-unit>
        <trans-unit id="81ca343fa42d2babb2e6749bedea9b053e460258" translate="yes" xml:space="preserve">
          <source>For some engines, &quot;fast jump&quot; algorithms are known, which advance the state by many steps (order of millions) without calculating intermediate state transitions, although not necessarily in constant time.</source>
          <target state="translated">일부 엔진의 경우, &quot;고속 점프 (fast jump)&quot;알고리즘이 알려져 있는데, 이는 일정한 시간이 아니더라도 중간 상태 전이를 계산하지 않고 상태를 여러 단계 (수백만 단위) 씩 전진시킨다.</target>
        </trans-unit>
        <trans-unit id="fd4abd3a725738e4ad1d6b4cf76b4fe8cb02df5a" translate="yes" xml:space="preserve">
          <source>For some of the C standard library headers of the form &lt;code&gt;xxx.h&lt;/code&gt;, the C++ standard library both includes an identically-named header and another header of the form &lt;code&gt;cxxx&lt;/code&gt; (all meaningful &lt;code&gt;cxxx&lt;/code&gt; headers are listed above).</source>
          <target state="translated">&lt;code&gt;xxx.h&lt;/code&gt; 형식의 일부 C 표준 라이브러리 헤더의 경우 C ++ 표준 라이브러리에는 모두 동일한 이름의 헤더와 &lt;code&gt;cxxx&lt;/code&gt; 형식의 다른 헤더가 포함됩니다 (모든 의미있는 &lt;code&gt;cxxx&lt;/code&gt; 헤더는 위에 나열 됨).</target>
        </trans-unit>
        <trans-unit id="cf567f1a3c60615e84656e20417b1a1de74545ac" translate="yes" xml:space="preserve">
          <source>For some of the signals, the implementation may call &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_IGN&lt;/a&gt;)&lt;/code&gt; at the startup of the program. For the rest, the implementation must call &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일부 신호의 경우 구현 시 프로그램 시작시 &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_IGN&lt;/a&gt;)&lt;/code&gt; 을 호출 할 수 있습니다 . 나머지는 구현시 &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f03372ec69aa391f826e43bea001123512eb679" translate="yes" xml:space="preserve">
          <source>For standard attributes, it will expand to the year and month in which the attribute was added to the working draft (see table below), the presence of vendor-specific attributes is determined by a non-zero value.</source>
          <target state="translated">표준 속성의 경우 속성이 작업 초안에 추가 된 연도와 월로 확장됩니다 (아래 표 참조). 공급 업체별 속성의 존재 여부는 0이 아닌 값으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="b56d8ebf643b96a82d52768c03f8db9aa07210bd" translate="yes" xml:space="preserve">
          <source>For templated functions with deduced return types, the return value may be named in a postcondition without additional restrictions (except that the name of the return value is treated as having a &lt;a href=&quot;../dependent_name#Type-dependent_expressions&quot;&gt;dependent type&lt;/a&gt;). For the non-templated functions with deduced return types, naming the return value is prohibited in declarations (but allowed in the definitions):</source>
          <target state="translated">추론 된 추론 유형이있는 템플릿 함수의 경우 추가 제한없이 사후 조건에서 반환 값의 이름을 지정할 수 있습니다 (반환 값의 이름이 &lt;a href=&quot;../dependent_name#Type-dependent_expressions&quot;&gt;종속 유형&lt;/a&gt; 을 갖는 것으로 간주되는 경우 제외 ). 추론 된 반환 유형이있는 템플릿이 아닌 함수의 경우 선언에서 반환 값의 이름을 지정할 수 없습니다 (그러나 정의에서는 허용됨).</target>
        </trans-unit>
        <trans-unit id="6c8bc61f784489c1be269b98b2a834b94911c08f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;A&lt;/code&gt; conversion style</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ae91f5c3692945d40532e2d71ac0a4386bf89f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;E&lt;/code&gt; conversion style</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb3f8b2a8fff5b3415e1098f326b2c10a1d27f2" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;G&lt;/code&gt; conversion style conversion with style &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt; will be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1ff43b4f3925bee54ad2942ba18ef8a4606c5a" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;X&lt;/code&gt; conversion letters &lt;code&gt;ABCDEF&lt;/code&gt; are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57890cceddb7efc24f01d52d8cf7f7dcc8bbc9c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;a&lt;/code&gt; conversion style</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2ab4c944a5b84fe46520d57012d6c750be1de1" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;char&lt;/code&gt; specialization, &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;lt&lt;/code&gt; are defined identically to the built-in operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; for type &lt;code&gt;unsigned char&lt;/code&gt; (</source>
          <target state="translated">들어 &lt;code&gt;char&lt;/code&gt; 전문화 &lt;code&gt;eq&lt;/code&gt; 및 &lt;code&gt;lt&lt;/code&gt; 동일하게 정의되는 기본 연산자 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;/code&gt; 유형 &lt;code&gt;unsigned char&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="41f7d301edd4649ecc9cc5e4ae27295bc06e8657" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;e&lt;/code&gt; conversion style</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a793f4315aaf80e04799e8d39a2f905e34a3d0ea" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;g&lt;/code&gt; conversion style conversion with style &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt; will be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807d09a568c3d3ab555b52969a3cc98de7806c36" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;x&lt;/code&gt; conversion letters &lt;code&gt;abcdef&lt;/code&gt; are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="964c75b68c3b67fa44944f427366e59ff71c8628" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, if |arg| &amp;gt; 710.5, then &lt;code&gt;cosh(arg)&lt;/code&gt; overflows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc98bc92461ef84f63213928d7e0dd4bec2a4ac3" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, underflow is guaranteed if &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5139171c7dc4bf39c00774f4969ee9ed5cb06814" translate="yes" xml:space="preserve">
          <source>For the alphabetic components of the default date format (if any), this function is usually case-insensitive.</source>
          <target state="translated">기본 날짜 형식 (있는 경우)의 알파벳 구성 요소의 경우이 기능은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca85fb6216b889960979e71b66f45292ecb6fff0" translate="yes" xml:space="preserve">
          <source>For the alphabetic components of the default time format (if any), this function is usually case-insensitive.</source>
          <target state="translated">기본 시간 형식 (있는 경우)의 알파벳 구성 요소의 경우이 기능은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3387ca380771e46f30ac460b364c23f3a50ac485" translate="yes" xml:space="preserve">
          <source>For the binary operators (except shifts), if the promoted operands have different types, additional set of implicit conversions is applied, known as</source>
          <target state="translated">이항 연산자 (시프트 제외)의 경우 승격 된 피연산자가 다른 유형을 갖는 경우 추가 암시 적 변환 세트가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5834b75a1d37489895cb80d1b1901ebbb10cdea5" translate="yes" xml:space="preserve">
          <source>For the built-in logical AND operator, the result is &lt;code&gt;true&lt;/code&gt; if both operands are &lt;code&gt;true&lt;/code&gt;. Otherwise, the result is &lt;code&gt;false&lt;/code&gt;. This operator is &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;short-circuiting&lt;/a&gt;: if the first operand is &lt;code&gt;false&lt;/code&gt;, the second operand is not evaluated.</source>
          <target state="translated">내장 논리 AND 연산자의 경우 두 피연산자가 모두 &lt;code&gt;true&lt;/code&gt; 인 경우 결과는 true &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 결과는 &lt;code&gt;false&lt;/code&gt; 입니다. 이 연산자는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;단락입니다&lt;/a&gt; : 첫 번째 피연산자가 &lt;code&gt;false&lt;/code&gt; 인 경우 두 번째 피연산자는 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f868d872215ad926f03072ef85906893d1cbc9f" translate="yes" xml:space="preserve">
          <source>For the built-in logical NOT operator, the result is &lt;code&gt;true&lt;/code&gt; if the operand is &lt;code&gt;false&lt;/code&gt;. Otherwise, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">내장 논리 NOT 연산자의 경우 피연산자가 &lt;code&gt;false&lt;/code&gt; 인 경우 결과는 &lt;code&gt;true&lt;/code&gt; 입니다. 그렇지 않으면 결과는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="98a7f937369cdbc13ece1f4624b3c0deaca24c09" translate="yes" xml:space="preserve">
          <source>For the built-in logical OR operator, the result is &lt;code&gt;true&lt;/code&gt; if either the first or the second operand (or both) is &lt;code&gt;true&lt;/code&gt;. This operator is short-circuiting: if the first operand is &lt;code&gt;true&lt;/code&gt;, the second operand is not evaluated.</source>
          <target state="translated">내장 논리 OR 연산자의 경우 첫 번째 또는 두 번째 피연산자 (또는 둘 다)가 &lt;code&gt;true&lt;/code&gt; 인 경우 결과는 &lt;code&gt;true&lt;/code&gt; 입니다 . 이 연산자는 단락입니다. 첫 번째 피연산자가 &lt;code&gt;true&lt;/code&gt; 이면 두 번째 피연산자가 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1db3901d3c9b8e71a137ee3fd4f6e31711c8ecd" translate="yes" xml:space="preserve">
          <source>For the built-in operator, expression must have arithmetic or unscoped enumeration type. Integral promotion is performed on the operand and determines the type of the result.</source>
          <target state="translated">내장 연산자의 경우 표현식에는 산술 또는 범위가 지정되지 않은 열거 유형이 있어야합니다. 피연산자에서 적분 승격이 수행되고 결과 유형이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed7967925e3d9a903dc61fad15c26826b80985cc" translate="yes" xml:space="preserve">
          <source>For the built-in operator, expression must have arithmetic, unscoped enumeration, or pointer type. Integral promotion is performed on the operand if it has integral or unscoped enumeration type and determines the type of the result.</source>
          <target state="translated">내장 연산자의 경우 표현식에는 산술, 범위가 지정되지 않은 열거 또는 포인터 유형이 있어야합니다. 피연산자에 정수 또는 범위가없는 열거 유형이 있고 결과 유형을 판별하는 경우 피연산자에 대해 전체 승격이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1f4b14dfb9171534a115c48cff5a996c8739f0c3" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must be one of the following:</source>
          <target state="translated">내장 연산자의 경우 lhs 및 rhs는 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c2fd6c69985c326b9c90b5457d6125aba9680de4" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must both have arithmetic or unscoped enumeration type.</source>
          <target state="translated">내장 연산자의 경우 lhs 및 rhs는 모두 산술 또는 범위가 지정되지 않은 열거 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="21aefc527d6a29a300de35c2b1a6e0de364db29e" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must both have integral or unscoped enumeration type</source>
          <target state="translated">내장 연산자의 경우 lhs 및 rhs는 정수 또는 범위가 지정되지 않은 열거 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="0e1c1ef458021530f026a00ce0e6a1cdf579bce8" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs may have any non-const scalar type and rhs must be implicitly convertible to the type of lhs.</source>
          <target state="translated">내장 연산자의 경우, lhs는 비 const 스칼라 유형을 가질 수 있으며 rhs는 lhs 유형으로 내재적으로 변환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="0fc6e93f0b5ccc41116e96e66ba6cc181fbeaf32" translate="yes" xml:space="preserve">
          <source>For the built-in operators, lhs and rhs must both have integral or unscoped enumeration type. Integral promotions are performed on both operands.</source>
          <target state="translated">내장 연산자의 경우 lhs 및 rhs는 정수 또는 범위가 지정되지 않은 열거 유형을 가져야합니다. 통합 프로모션은 두 피연산자 모두에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8b5909dfd25b823a91c25e0c6ebfb4fe115565d4" translate="yes" xml:space="preserve">
          <source>For the built-in operators, lhs and rhs must both have integral or unscoped enumeration type. Usual arithmetic conversions are performed on both operands and determine the type of the result.</source>
          <target state="translated">내장 연산자의 경우 lhs 및 rhs는 정수 또는 범위가 지정되지 않은 열거 유형을 가져야합니다. 일반적인 산술 변환은 두 피연산자 모두에서 수행되며 결과 유형을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="631e90fa71e23701d70b68b196fb2c8886d4ce41" translate="yes" xml:space="preserve">
          <source>For the character sequence &lt;code&gt;[first, last)&lt;/code&gt;, obtains the primary sort key in the imbued locale's collating order, that is, the sort key that is based on the positions of the letters and collation units in the national alphabet, ignoring case, diacritics, variants, etc. If a primary sort key compares less than another primary sort key with &lt;code&gt;operator&amp;lt;&lt;/code&gt;, then the character sequence that produced the first sort key comes before the character sequence that produced the second sort key, in the currently imbued locale's primary collation order.</source>
          <target state="translated">문자 순서 &lt;code&gt;[first, last)&lt;/code&gt; , 삽입 된 로케일의 조합 순서에서 기본 정렬 키, 즉 대소 문자를 구분하지 않고 국가 알파벳의 문자 및 조합 단위의 위치를 ​​기반으로하는 정렬 키를 얻습니다. 기본 정렬 키가 다른 기본 정렬 키보다 작 으면 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 와 비교할 경우 첫 번째 정렬 키를 생성 한 문자 시퀀스는 현재 마킹 된 로케일의 기본 데이터 정렬 순서에서 두 번째 정렬 키를 생성 한 문자 시퀀스 앞에옵니다. .</target>
        </trans-unit>
        <trans-unit id="e113ddf9e42810bbcd7d53a7fd8437e10332cdc3" translate="yes" xml:space="preserve">
          <source>For the definition of &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&lt;/code&gt;, the following exposition-only concept is defined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&lt;/code&gt; 의 정의를 위해 다음 박람회 전용 개념이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d1225d08c6a217571442e3f149849eb65e94bce7" translate="yes" xml:space="preserve">
          <source>For the entities that are captured by reference (with the default capture &lt;code&gt;[&amp;amp;]&lt;/code&gt; or when using the character &amp;amp;, e.g. &lt;code&gt;[&amp;amp;a, &amp;amp;b, &amp;amp;c]&lt;/code&gt;), it is unspecified if additional data members are declared in the closure type , but any such additional members must satisfy &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;(since C++17).</source>
          <target state="translated">참조로 캡처 된 엔티티 (기본 캡처 &lt;code&gt;[&amp;amp;]&lt;/code&gt; 로 또는 문자 &amp;amp;를 사용하는 경우 (예 : &lt;code&gt;[&amp;amp;a, &amp;amp;b, &amp;amp;c]&lt;/code&gt; ))의 경우 추가 데이터 멤버가 클로저 유형으로 선언되면 지정되지 않습니다. 추가 멤버는 &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; (C ++ 17부터)을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1a22058978c1262938bcaa97c3c6020766a5ad4e" translate="yes" xml:space="preserve">
          <source>For the first (non-array) form, expression must be a pointer to an object type or a class type &lt;a href=&quot;implicit_cast&quot;&gt;contextually implicitly convertible&lt;/a&gt; to such pointer, and its value must be either</source>
          <target state="translated">첫 번째 (배열이 아닌) 형식의 경우 expression은 객체 유형에 대한 포인터이거나 &lt;a href=&quot;implicit_cast&quot;&gt;컨텍스트에서 암시 적&lt;/a&gt; 으로 이러한 포인터 로 변환 가능한 클래스 유형 이어야하며 그 값은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="299adf2377e7d703f91fcfc6dc32f0216b89eb0d" translate="yes" xml:space="preserve">
          <source>For the first (non-const) version, the behavior is undefined if this character is modified to any value other than &lt;code&gt;CharT()&lt;/code&gt; .</source>
          <target state="translated">첫 번째 (비 콘스탄트) 버전의 경우이 문자가 &lt;code&gt;CharT()&lt;/code&gt; 이외의 다른 값으로 수정되면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="90655817fab85d8ac14c5bbb029cd02bf793db95" translate="yes" xml:space="preserve">
          <source>For the last two rows of the table, &lt;code&gt;&lt;i&gt;num&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;den&lt;/i&gt;&lt;/code&gt; in the suffix are &lt;code&gt;Period::type::num&lt;/code&gt; and &lt;code&gt;Period::type::den&lt;/code&gt; formatted as a decimal number with no leading zeroes, respectively.</source>
          <target state="translated">테이블의 마지막 두 행 에 대해 접미어의 &lt;code&gt;&lt;i&gt;num&lt;/i&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;i&gt;den&lt;/i&gt;&lt;/code&gt; 은 각각 앞에 0이없는 10 진수로 형식화 된 &lt;code&gt;Period::type::num&lt;/code&gt; 및 &lt;code&gt;Period::type::den&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbb5833c26a713296ad8005d9e28d5fc0bbfe8a6" translate="yes" xml:space="preserve">
          <source>For the name of a class or class template used within the definition of that class or template or derived from one, unqualified name lookup finds the class that's being defined as if the name was introduced by a member declaration (with public member access). For more detail, see &lt;a href=&quot;injected-class-name&quot;&gt;injected-class-name&lt;/a&gt;.</source>
          <target state="translated">해당 클래스 또는 템플릿의 정의 내에서 사용되거나 클래스에서 파생 된 클래스 또는 클래스 템플릿 이름의 경우 정규화되지 않은 이름 조회는 이름이 멤버 선언 (공개 멤버 액세스 권한)에 의해 소개 된 것처럼 정의되고있는 클래스를 찾습니다. 자세한 내용은 &lt;a href=&quot;injected-class-name&quot;&gt;injection-class-name을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43ac5c7c822f021589a3f0df6c74ca1128531b73" translate="yes" xml:space="preserve">
          <source>For the number of elements in the range &lt;code&gt;[first, last)&lt;/code&gt; without any additional criteria, see &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추가 기준이없는 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소 수는 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3eb35ae41318a2300948bfa04a8b59aa4c523fcb" translate="yes" xml:space="preserve">
          <source>For the objects of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt; (unless they are oversize &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;), every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; 및 &lt;code&gt;unsigned char&lt;/code&gt; 유형의 객체 (크기가 큰 &lt;a href=&quot;bit_field&quot;&gt;비트 필드&lt;/a&gt; 가 아닌 경우 )의 경우 객체 표현의 모든 비트는 값 표현에 참여해야하며 가능한 모든 비트 패턴은 고유 한 값을 나타냅니다 (패딩, 트랩 없음) 비트 또는 다중 표현 허용).</target>
        </trans-unit>
        <trans-unit id="eda418fc0d7e0da6163efe2b320b70eff6e157ef" translate="yes" xml:space="preserve">
          <source>For the overload with an ExecutionPolicy, there may be a performance cost if ForwardIt's value type is not &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">ExecutionPolicy를 사용한 과부하의 경우 ForwardIt의 값 유형이 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 이 아닌 경우 성능 비용이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5b59a3fe5c4c6ada03047f0bc055b7cec5863b8" translate="yes" xml:space="preserve">
          <source>For the overloads with an ExecutionPolicy, there may be a performance cost if &lt;code&gt;ForwardIt1&lt;/code&gt;'s value_type is not &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">ExecutionPolicy를 사용한 과부하의 경우 &lt;code&gt;ForwardIt1&lt;/code&gt; 의 value_type이 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 이 아닌 경우 성능 비용이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca027ab75b905772f5d961e5c587aca010bc2ac6" translate="yes" xml:space="preserve">
          <source>For the overloads with an ExecutionPolicy, there may be a performance cost if the value type of &lt;code&gt;ForwardIterator1&lt;/code&gt; is not both &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">ExecutionPolicy가있는 과부하의 경우 &lt;code&gt;ForwardIterator1&lt;/code&gt; 값 유형이 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 및 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 이 아닌 경우 성능 비용이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecf8e99bee770bd19c532d009a039c1a135e9bb1" translate="yes" xml:space="preserve">
          <source>For the purpose of &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, determining the type and value of the &lt;a href=&quot;this&quot;&gt;this pointer&lt;/a&gt; and for accessing non-static class members, the body of the closure type's function call operator is considered in the context of the lambda-expression.</source>
          <target state="translated">&lt;a href=&quot;lookup&quot;&gt;이름 조회&lt;/a&gt; 의 목적으로 &lt;a href=&quot;this&quot;&gt;this 포인터&lt;/a&gt; 의 유형과 값을 결정하고 비 정적 클래스 멤버에 액세스하기 위해 클로저 유형의 함수 호출 연산자 본문이 lambda-expression의 컨텍스트에서 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="65aeedb9e92b2d4cea74d76c9050bb672b686f5f" translate="yes" xml:space="preserve">
          <source>For the purpose of &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt;, if the next inner allocator is &lt;code&gt;A&lt;/code&gt;, any class &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T,A&amp;gt;::value == true&lt;/code&gt; participates in the recursion as if it was a container. Additionally, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; is treated as such a container by specific overloads of &lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;&lt;code&gt;scoped_allocator_adaptor::construct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 목적 &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt; 다음 내측 할당 인 경우 모든 클래스 &lt;code&gt;T&lt;/code&gt; 되는 &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T,A&amp;gt;::value == true&lt;/code&gt; &amp;lt;T, A&amp;gt; :: 값 == 진정한 재귀 참여가 용기 것처럼. 또한 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 는 &lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt; &lt;code&gt;scoped_allocator_adaptor::construct&lt;/code&gt; &lt;/a&gt; 의 특정 과부하에 의해 컨테이너로 처리됩니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4cae47b4767abaac03c592dbea46b05ec44cfc59" translate="yes" xml:space="preserve">
          <source>For the purpose of this trait, the extent to which an implementation determines that a type cannot meet the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements is unspecified, except that a minimum &lt;code&gt;T&lt;/code&gt; shall not qualify as a &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; unless it meets all of the following conditions:</source>
          <target state="translated">이 특성의 목적을 위해 구현에서 유형이 &lt;a href=&quot;../named_req/clock&quot;&gt;클럭&lt;/a&gt; 요구 사항을 충족 할 수 없다고 결정하는 범위 는 지정되지 않습니다. 단, 최소 &lt;code&gt;T&lt;/code&gt; 가 다음 조건을 모두 충족하지 않으면 &lt;a href=&quot;../named_req/clock&quot;&gt;클럭으로 적합&lt;/a&gt; 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbf72513b1cc6b7e687b6187fddcae47438a5f71" translate="yes" xml:space="preserve">
          <source>For the purpose of this trait, two arrays have the same value if their elements have the same values, two non-union classes have the same value if their direct subobjects have the same value, and two unions have the same value if they have the same active member and the value of that member are the same.</source>
          <target state="translated">이 특성의 목적을 위해 요소의 값이 동일한 경우 두 배열의 값이 동일하고 직계 하위 오브젝트의 값이 동일한 경우 두 개의 비 유니언 클래스의 값이 동일하며 두 개의 공용체의 경우 동일한 활성 멤버와 해당 멤버의 값이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="73e5a63a0091c86f2d780d4bd7205bd859be1626" translate="yes" xml:space="preserve">
          <source>For the purpose of unqualified name lookup, all declarations from a namespace nominated by a &lt;a href=&quot;namespace&quot;&gt;using directive&lt;/a&gt; appear as if declared in the nearest enclosing namespace which contains, directly or indirectly, both the using-directive and the nominated namespace.</source>
          <target state="translated">정규화되지 않은 이름 조회를 위해 &lt;a href=&quot;namespace&quot;&gt;using 지시문으로&lt;/a&gt; 지정된 네임 스페이스의 모든 선언 은 using-directive 및 명명 된 네임 스페이스를 직접 또는 간접적으로 포함하는 가장 가까운 둘러싸는 네임 스페이스에 선언 된 것처럼 나타납니다.</target>
        </trans-unit>
        <trans-unit id="be7ff9400561e79a38fa934ba94eb51a08e444ed" translate="yes" xml:space="preserve">
          <source>For the purposes of the description below, a pointer type &lt;code&gt;Y*&lt;/code&gt; is said to be</source>
          <target state="translated">아래 설명을 위해 포인터 유형 &lt;code&gt;Y*&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8841a4885b112152b14a19649fc94d610b058fa" translate="yes" xml:space="preserve">
          <source>For the purposes of this check, the variable definition is never interpreted as a function declaration, and the use of &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; is not considered an &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to &lt;code&gt;T&lt;/code&gt; and any of the types in &lt;code&gt;Args&lt;/code&gt;. Only the validity of the immediate context of the variable definition is considered.</source>
          <target state="translated">이 점검의 목적으로 변수 정의는 함수 선언으로 해석 되지 않으며 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../language/definition#ODR-use&quot;&gt; 사용&lt;/a&gt; 은 odr-use로 간주되지 않습니다 . &lt;a href=&quot;../language/access&quot;&gt;액세스 검사&lt;/a&gt; 는 &lt;code&gt;T&lt;/code&gt; 와 관련이없는 컨텍스트와 &lt;code&gt;Args&lt;/code&gt; 의 모든 유형 에서처럼 수행됩니다 . 변수 정의의 즉각적인 컨텍스트의 유효성 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="0b9a3ac76356afb7c5f4a3ea00f4b7fb14d9e7d4" translate="yes" xml:space="preserve">
          <source>For the rest of overload resolution, the</source>
          <target state="translated">나머지 과부하 분해능의 경우</target>
        </trans-unit>
        <trans-unit id="a71380803d7225c2397b15d7056c647fe014ba63" translate="yes" xml:space="preserve">
          <source>For the sake of exposition, assume that &lt;code&gt;regex_iterator&lt;/code&gt; contains the following members:</source>
          <target state="translated">설명을 위해 &lt;code&gt;regex_iterator&lt;/code&gt; 에 다음 멤버가 포함되어 있다고 가정 하십시오.</target>
        </trans-unit>
        <trans-unit id="67321d4e15267f4eda7f0452bd90ebdb6e086831" translate="yes" xml:space="preserve">
          <source>For the second (array) form, expression must be a null pointer value or a pointer value previously obtained by an array form of &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;. If expression is anything else, including if it's a pointer obtained by the non-array form of &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;.</source>
          <target state="translated">두 번째 (배열) 형식의 경우 expression은 null 포인터 값이거나 &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; 의 배열 형식으로 이전에 얻은 포인터 값이어야합니다 . 배열이 아닌 형식의 &lt;a href=&quot;new&quot;&gt;new-expression에&lt;/a&gt; 의해 얻은 포인터 인 경우를 포함하여 expression이 다른 경우 에는 동작이 &lt;a href=&quot;ub&quot;&gt;정의되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9c4273040bcad4221585f3c35b8ea39b7d5d39a" translate="yes" xml:space="preserve">
          <source>For the situations when three-way comparison is not required, &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; provides the usual &lt;a href=&quot;operator_cmp&quot;&gt;relational operators&lt;/a&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc).</source>
          <target state="translated">3 방향 비교가 필요하지 않은 경우 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 은 일반적인 &lt;a href=&quot;operator_cmp&quot;&gt;관계 연산자&lt;/a&gt; ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 등)를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6f0ec42ffc782d2dbbdc18b148a303310b9bc1a6" translate="yes" xml:space="preserve">
          <source>For the specializations of &lt;code&gt;&lt;a href=&quot;../fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; that are used in the standard library, &lt;code&gt;State&lt;/code&gt; is always &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리에서 사용되는 &lt;code&gt;&lt;a href=&quot;../fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; 의 전문화를 위해 &lt;code&gt;State&lt;/code&gt; 는 항상 &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="144964c0df3039e3c71b1f52434a1f307b2a75a0" translate="yes" xml:space="preserve">
          <source>For the static member functions, the</source>
          <target state="translated">정적 멤버 함수의 경우</target>
        </trans-unit>
        <trans-unit id="eb5c7ff9cfa9a962ebc4d24b7e58d44592b6e8bd" translate="yes" xml:space="preserve">
          <source>For the types that are both &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; and &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, the C++ standard library makes a distinction between</source>
          <target state="translated">&lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; 및 &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; 유형의 경우 C ++ 표준 라이브러리는 다음을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="731f2b2536187de6fbaec0afbeb784f1678b4260" translate="yes" xml:space="preserve">
          <source>For the types that are both &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; and LessThanComparable, the C++ standard library makes a distinction between</source>
          <target state="translated">&lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; 및 LessThanComparable 인 유형의 경우 C ++ 표준 라이브러리는 다음을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="a44f5a2bb8a05cc20c72fea8758fde71db78f3d3" translate="yes" xml:space="preserve">
          <source>For the types that are both EqualityComparable and &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, the C++ standard library makes a distinction between</source>
          <target state="translated">EqualityComparable 및 &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; 유형의 경우 C ++ 표준 라이브러리는 다음을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="ea9de19131b3606684b0baafb3d2151f5a32dd40" translate="yes" xml:space="preserve">
          <source>For the use in derived class definitions, see &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;.</source>
          <target state="translated">파생 클래스 정의에서 &lt;a href=&quot;using_declaration&quot;&gt;사용하려면 선언 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48183fff740905d93ae3026fe871d3be4a4d9ec5" translate="yes" xml:space="preserve">
          <source>For two different parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are not equal, the probability that &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; should be very small, approaching &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_t&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">같지 않은 두 개의 다른 매개 변수 &lt;code&gt;k1&lt;/code&gt; 및 &lt;code&gt;k2&lt;/code&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; 의 확률은 &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_t&amp;gt;::max()&lt;/code&gt; 근접해야합니다. :: numeric_limits &amp;lt;size_t&amp;gt; :: max () .</target>
        </trans-unit>
        <trans-unit id="cc4402b538e707e656178152f7bd8d1b40d16256" translate="yes" xml:space="preserve">
          <source>For two parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are equal, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt;.</source>
          <target state="translated">동일한 두 개의 매개 변수 &lt;code&gt;k1&lt;/code&gt; 및 &lt;code&gt;k2&lt;/code&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="94a3ad0257f1ac1480c81596b592db0d4b3511aa" translate="yes" xml:space="preserve">
          <source>For two-digit input values, many implementations use the same parsing rules as the conversion specifier &lt;code&gt;'%y'&lt;/code&gt; as used by &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;get&quot;&gt;std::time_get::get()&lt;/a&gt;&lt;/code&gt;, and the POSIX function &lt;code&gt;strptime()&lt;/code&gt;: two-digit integer is expected, the values in the range [69,99] results in values 1969 to 1999, range [00,68] results in 2000-2068. Four-digit inputs are typically accepted as-is.</source>
          <target state="translated">두 자리 입력 값의 경우 많은 구현 에서 &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;get&quot;&gt;std::time_get::get()&lt;/a&gt;&lt;/code&gt; 및 POSIX 함수 &lt;code&gt;strptime()&lt;/code&gt; 사용 하는 변환 지정자 &lt;code&gt;'%y'&lt;/code&gt; 와 동일한 구문 분석 규칙을 사용합니다 . 숫자 정수가 예상되며 [69,99] 범위의 값은 1969에서 1999 사이의 값을, 2000-2068의 범위 [00,68]으로 나타납니다. 4 자리 입력은 일반적으로 그대로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="642cd801d14b4a66f154da3cc51856b49e293f28" translate="yes" xml:space="preserve">
          <source>For two-way comparisons, &lt;a href=&quot;operator_cmp&quot;&gt;binary operators&lt;/a&gt; may be more suitable.</source>
          <target state="translated">양방향 비교의 경우 &lt;a href=&quot;operator_cmp&quot;&gt;이진 연산자&lt;/a&gt; 가 더 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe584cd3d04227e8ee6e63e57235b2b1a239458e" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be BasicLockable, the following conditions have to be satisfied for an object &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;L&lt;/code&gt;:</source>
          <target state="translated">타입 들어 &lt;code&gt;L&lt;/code&gt; 이 BasicLockable을 다음의 조건은 개체에 대해 만족되어야하는 &lt;code&gt;m&lt;/code&gt; 형의 &lt;code&gt;L&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a492045a60cf54bb3785e73eca1da2d9437cc013" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be Lockable, it must meet the above condition as well as the following:</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; 형 을 잠금 가능하게하려면 다음 조건뿐만 아니라 위의 조건을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="3192f26467193016e7a310e7cb38a3fb281f3879" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be TimedLockable, the following conditions have to be satisfied for an object &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;L&lt;/code&gt;:</source>
          <target state="translated">타입 들어 &lt;code&gt;L&lt;/code&gt; 이 TimedLockable을 다음의 조건은 개체에 대해 만족되어야하는 &lt;code&gt;m&lt;/code&gt; 형의 &lt;code&gt;L&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e5e7522e5abd30c0f3d5e5a223c5721c59cbeef9" translate="yes" xml:space="preserve">
          <source>For unsigned &lt;code&gt;a&lt;/code&gt; and for signed and non-negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is the integer part of a/2b</source>
          <target state="translated">부호없는 &lt;code&gt;a&lt;/code&gt; 및 부호 있는 및 음 &lt;code&gt;a&lt;/code&gt; 아닌 &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; 의 경우 a &amp;gt;&amp;gt; b 값 은 a / 2b의 정수 부분입니다.</target>
        </trans-unit>
        <trans-unit id="aebdb0e43e858256601ff6d8a7d5738865f2a1f9" translate="yes" xml:space="preserve">
          <source>For unsigned &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is the value of a * 2b</source>
          <target state="translated">부호없는 &lt;code&gt;a&lt;/code&gt; 의 경우 &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 의 값은 a * 2b의 값입니다</target>
        </trans-unit>
        <trans-unit id="d49c3968569060d907f70256e73011fe41b82ee7" translate="yes" xml:space="preserve">
          <source>For variables and other names introduced by simple declarations, the point of declaration is immediately after that name's &lt;a href=&quot;declarations#Declarators&quot;&gt;declarator&lt;/a&gt; and before its initializer, if any:</source>
          <target state="translated">간단한 선언으로 도입 된 변수 및 기타 이름의 경우 선언 지점은 해당 이름의 &lt;a href=&quot;declarations#Declarators&quot;&gt;선언자&lt;/a&gt; 바로 다음 과 이니셜 라이저 이전에 있습니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="4406791fdc0c802a309313fed6968b3cbed9aba4" translate="yes" xml:space="preserve">
          <source>For variables, specifies that the type of the variable that is being declared will be automatically deduced from its initializer.</source>
          <target state="translated">변수의 경우 선언되는 변수의 유형이 초기화 프로그램에서 자동으로 추론되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5c276069327cb6d9e2ff643e9fb634c6f1cb43de" translate="yes" xml:space="preserve">
          <source>For version (2), the number of arguments must be the same as the number of parameters in macro definition. For versions (3,4), the number of arguments must be more than(until C++20)at least as many as(since C++20) the number of parameters (not counting &lt;code&gt;...&lt;/code&gt;). Otherwise the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.</source>
          <target state="translated">버전 (2)의 경우 인수 수는 매크로 정의의 매개 변수 수와 같아야합니다. 버전 (3,4)의 경우, 인수의 수는 (C ++ 20 이후) 매개 변수의 수 (카운팅하지 않음 &lt;code&gt;...&lt;/code&gt; ) 보다 많거나 같아야합니다 (C ++ 20까지 ). 그렇지 않으면 프로그램이 잘못 구성됩니다. 식별자가 기능적 표기법으로되어 있지 않은 경우, 즉 그 뒤에 괄호가 없으면 전혀 대체되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1eb818e764a2afb52d153586d87b0ff7106e9cc9" translate="yes" xml:space="preserve">
          <source>For versions (3,4), replacement-list may contain the token sequence &lt;code&gt;__VA_OPT__ (&lt;/code&gt;content&lt;code&gt;)&lt;/code&gt;, which is replaced by content if &lt;code&gt;__VA_ARGS__&lt;/code&gt; is non-empty, and expands to nothing otherwise.</source>
          <target state="translated">버전 (3,4)의 경우 replacement-list는 토큰 시퀀스 &lt;code&gt;__VA_OPT__ (&lt;/code&gt; content &lt;code&gt;)&lt;/code&gt; 를 포함 할 수 있으며 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 가 비어 있지 않은 경우 내용으로 대체되고 다른 것으로 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="689abf1f4ab72838db75e84748d7996dea17600f" translate="yes" xml:space="preserve">
          <source>For virtual calls (if the bases are initialized), the same rules apply as the rules for the virtual calls from constructors and destructors: virtual member functions behave as if the dynamic type of &lt;code&gt;*this&lt;/code&gt; is the class that's being constructed (dynamic dispatch does not propagate down the inheritance hierarchy) and virtual calls (but not static calls) to &lt;a href=&quot;abstract_class&quot;&gt;pure virtual&lt;/a&gt; member functions are undefined behavior.</source>
          <target state="translated">가상 호출의 경우 (베이스가 초기화 된 경우) 생성자와 소멸자의 가상 호출에 대한 규칙과 동일한 규칙이 적용됩니다. 가상 구성원 함수는 동적 유형 &lt;code&gt;*this&lt;/code&gt; 구성중인 클래스 인 것처럼 작동합니다 (동적 디스패치가 수행되지 않음) 상속 계층 구조로 전파) 및 가상 호출 (정적 호출은 아님)을 &lt;a href=&quot;abstract_class&quot;&gt;순수 가상&lt;/a&gt; 구성원 함수로 정의하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c5f085443078183be6555b610a3066515f2b25f" translate="yes" xml:space="preserve">
          <source>For zero-sized arrays,</source>
          <target state="translated">크기가 0 인 배열의 경우</target>
        </trans-unit>
        <trans-unit id="0a460a0808dc0afa3b1cab6d45b0c32f450b8082" translate="yes" xml:space="preserve">
          <source>Forcing a copy assignment operator to be generated by the compiler.</source>
          <target state="translated">컴파일러가 복사 할당 연산자를 생성하도록합니다.</target>
        </trans-unit>
        <trans-unit id="11ad1e8557a20546e9537fc0a5b3a329b83d8d13" translate="yes" xml:space="preserve">
          <source>Forcing a copy constructor to be generated by the compiler.</source>
          <target state="translated">컴파일러에서 복사 생성자를 강제로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dd180500aac427aa2facdbe0b7cd406cce37ac98" translate="yes" xml:space="preserve">
          <source>Forcing a move assignment operator to be generated by the compiler.</source>
          <target state="translated">컴파일러가 이동 할당 연산자를 생성하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b5ea5bcf5fc337ca9689a82c3a3c7580484f1408" translate="yes" xml:space="preserve">
          <source>Forcing a move constructor to be generated by the compiler.</source>
          <target state="translated">컴파일러에서 이동 생성자를 강제로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="72ef49edf9ca8e31454f8e3e5987fc43ac16422c" translate="yes" xml:space="preserve">
          <source>Form (3) is a special case of elaborated type specifier, usually referred to as</source>
          <target state="translated">양식 (3)은 정교한 유형 지정자의 특별한 경우이며 일반적으로</target>
        </trans-unit>
        <trans-unit id="3851c6a3b646b09f934a18b67d308cc11979b8c6" translate="yes" xml:space="preserve">
          <source>Formal definition of</source>
          <target state="translated">공식적인 정의</target>
        </trans-unit>
        <trans-unit id="617d00cd751356da85b2e1f1f2eca6aa12a756a0" translate="yes" xml:space="preserve">
          <source>Formal description</source>
          <target state="translated">공식적인 설명</target>
        </trans-unit>
        <trans-unit id="3bfb55cdc85542de2eeac7c01ac22e44b5143662" translate="yes" xml:space="preserve">
          <source>Formally,</source>
          <target state="translated">Formally,</target>
        </trans-unit>
        <trans-unit id="be2c3615928f7aa5bc5a7d980eb4d06a17642a73" translate="yes" xml:space="preserve">
          <source>Formally, &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; is satisfied only if, given any lvalue &lt;code&gt;t&lt;/code&gt; of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and any lvalue &lt;code&gt;u&lt;/code&gt; of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;, and let &lt;code&gt;C&lt;/code&gt; be &lt;code&gt;&lt;a href=&quot;../types/common_reference&quot;&gt;std::common_reference_t&lt;/a&gt;&amp;lt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;amp;, const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;&amp;gt;&lt;/code&gt; :</source>
          <target state="translated">공식적으로, &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; 어떤 좌변 주어진 경우에만 만족 &lt;code&gt;t&lt;/code&gt; 타입의 &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 및 좌변 &lt;code&gt;u&lt;/code&gt; 타입의 &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; 및하자 &lt;code&gt;C&lt;/code&gt; 될 &lt;code&gt;&lt;a href=&quot;../types/common_reference&quot;&gt;std::common_reference_t&lt;/a&gt;&amp;lt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;amp;, const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ac3a456d751219d7a66e0d0371e02798d8d5d3ea" translate="yes" xml:space="preserve">
          <source>Formally, a substring &lt;code&gt;str&lt;/code&gt; is said to be</source>
          <target state="translated">공식적으로, 부분 문자열 &lt;code&gt;str&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="8819ae53d6eeeb966d61dd310165099d50cdc3e7" translate="yes" xml:space="preserve">
          <source>Formally, a template template-parameter &lt;code&gt;P&lt;/code&gt; is at least as specialized as a template template argument &lt;code&gt;A&lt;/code&gt; if, given the following rewrite to two function templates, the function template corresponding to &lt;code&gt;P&lt;/code&gt; is at least as specialized as the function template corresponding to &lt;code&gt;A&lt;/code&gt; according to the partial ordering rules for &lt;a href=&quot;function_template&quot;&gt;function templates&lt;/a&gt;. Given an invented class template &lt;code&gt;X &lt;/code&gt; with the template parameter list of &lt;code&gt;A&lt;/code&gt; (including default arguments):</source>
          <target state="translated">공식적으로 템플릿 템플릿 매개 변수 &lt;code&gt;P&lt;/code&gt; 는 다음 두 함수 템플릿을 다시 쓰면 &lt;code&gt;P&lt;/code&gt; 에 해당 하는 함수 템플릿이 &lt;code&gt;A&lt;/code&gt; 에 해당하는 함수 템플릿만큼 전문화 된 경우 적어도 템플릿 템플릿 인수 &lt;code&gt;A&lt;/code&gt; 만큼 전문화됩니다. &lt;a href=&quot;function_template&quot;&gt;함수 템플릿에&lt;/a&gt; 대한 부분 순서 규칙 . 템플릿 매개 변수 목록이 &lt;code&gt;A&lt;/code&gt; (기본 인수 포함) 인 발명 된 클래스 템플릿 &lt;code&gt;X &lt;/code&gt; 가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="117e56a1f0fa17b3f88e2093765a4fbfc78944a1" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of &lt;code&gt;init, *j...&lt;/code&gt; for every &lt;code&gt;j&lt;/code&gt; in [first, first + (i - d_first)) over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">공식적으로, [d_first, d_first + (last-first))의 각 반복자 &lt;code&gt;i&lt;/code&gt; 를 통해 [first, first + (i-d_first))의 모든 &lt;code&gt;j&lt;/code&gt; 에 대해 일반화 된 비 계산적 &lt;code&gt;init, *j...&lt;/code&gt; 합계 * j ... 의 값을 할당합니다. &lt;code&gt;binary_op&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="67dce949f95f6583a76648b394095c1ec1ca39c5" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of &lt;code&gt;init, unary_op(*j)...&lt;/code&gt; for every &lt;code&gt;j&lt;/code&gt; in [first, first + (i - d_first)) over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">공식적으로, [d_first, d_first + (last-first))의 각 반복자 &lt;code&gt;i&lt;/code&gt; 를 통해 [first, first + (i-d_first)의 모든 &lt;code&gt;j&lt;/code&gt; 에 대해 일반화 된 비 &lt;code&gt;init, unary_op(*j)...&lt;/code&gt; 을 할당합니다. ))를 통해 &lt;code&gt;binary_op&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="95a3ed38da232217c4f6f08f54e48cb7d257ddec" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of.</source>
          <target state="translated">공식적으로 [d_first, d_first + (last-first))의 각 반복자 &lt;code&gt;i&lt;/code&gt; 를 통해 값을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="42355d6a7c2d7676346a2158f0e06426adf8925e" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of:</source>
          <target state="translated">공식적으로 [d_first, d_first + (last-first))의 각 반복자 &lt;code&gt;i&lt;/code&gt; 를 통해 다음 값을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="aa803427d4e1d44c6149f49a34143aabb8a952e0" translate="yes" xml:space="preserve">
          <source>Formally, for each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, count)&lt;/code&gt;, performs &lt;code&gt;assign(src[i], dest[i])&lt;/code&gt;.</source>
          <target state="translated">정식으로, 각각의 &lt;code&gt;i&lt;/code&gt; 에서 &lt;code&gt;[0, count)&lt;/code&gt; 수행이 &lt;code&gt;assign(src[i], dest[i])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="554c2426b4e5c1f78a13a29231a721f516bd1cbf" translate="yes" xml:space="preserve">
          <source>Formally, given an expression &lt;code&gt;E&lt;/code&gt; such that &lt;code&gt;decltype((E))&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; and an lvalue &lt;code&gt;t&lt;/code&gt; that denotes the same object as &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; models &lt;code&gt;__ForwardingRange&lt;/code&gt; only if.</source>
          <target state="translated">공식적 발현 주어진 &lt;code&gt;E&lt;/code&gt; 되도록 &lt;code&gt;decltype((E))&lt;/code&gt; 인 &lt;code&gt;T&lt;/code&gt; 및 좌변 &lt;code&gt;t&lt;/code&gt; 같은 객체이고 &lt;code&gt;E&lt;/code&gt; 가 , &lt;code&gt;T&lt;/code&gt; 의 모델 &lt;code&gt;__ForwardingRange&lt;/code&gt; 경우에만한다.</target>
        </trans-unit>
        <trans-unit id="f43c3db9c814c3ddff2a854cf059e58f985b2721" translate="yes" xml:space="preserve">
          <source>Formally, given an expression &lt;code&gt;E&lt;/code&gt; such that &lt;code&gt;decltype((E))&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; models &lt;code&gt;&lt;a href=&quot;../range/range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; only if.</source>
          <target state="translated">공식적으로, 표현의 주어진 &lt;code&gt;E&lt;/code&gt; 등이 있음을 &lt;code&gt;decltype((E))&lt;/code&gt; 이다 &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; 의 모델 &lt;code&gt;&lt;a href=&quot;../range/range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; 경우에만합니다.</target>
        </trans-unit>
        <trans-unit id="067b1a2613c21e1fd48648c5caa1394000d7f227" translate="yes" xml:space="preserve">
          <source>Formally, given.</source>
          <target state="translated">공식적으로 주어진.</target>
        </trans-unit>
        <trans-unit id="b90f213e247d65d8f658b379e51068d2511abb68" translate="yes" xml:space="preserve">
          <source>Formally, if &lt;code&gt;E&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are expressions, and &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype((E))&amp;gt;&lt;/code&gt;, then.</source>
          <target state="translated">공식적으로 &lt;code&gt;E&lt;/code&gt; 와 &lt;code&gt;F&lt;/code&gt; 가 표현식이고 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype((E))&amp;gt;&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="67f89cac3a2bdd1a32a9d4e925980ecdcd1ff780" translate="yes" xml:space="preserve">
          <source>Formally, returns a value &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;X::eq_int_type(e, X::to_int_type(c))&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">공식적으로, 값 반환 &lt;code&gt;e&lt;/code&gt; 등을 그 &lt;code&gt;X::eq_int_type(e, X::to_int_type(c))&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; 모든 값에 대한 &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba8bfc3113f8f3e8c405a965d6f37d86be2d7991" translate="yes" xml:space="preserve">
          <source>Formally, returns the value &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;X::eq_int_type(c, X::to_int_type(x))&lt;/code&gt; is true, and an unspecified value if no such &lt;code&gt;x&lt;/code&gt; exists.</source>
          <target state="translated">공식적으로, 값 반환 &lt;code&gt;x&lt;/code&gt; 같은 그 &lt;code&gt;X::eq_int_type(c, X::to_int_type(x))&lt;/code&gt; 사실이며, 지정되지 않은 값이 그러한 경우 &lt;code&gt;x&lt;/code&gt; 가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52d033134dacb8018588f4302d9453d80ec19597" translate="yes" xml:space="preserve">
          <source>Formally, the</source>
          <target state="translated">공식적으로</target>
        </trans-unit>
        <trans-unit id="52e0a6f1e0d63a4dd3bc991539c544e18482cfab" translate="yes" xml:space="preserve">
          <source>Formally, the C++ standard makes no guarantee on the accuracy of floating-point operations.</source>
          <target state="translated">공식적으로 C ++ 표준은 부동 소수점 연산의 정확성을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95a4b2acf26b1c49aea8abebe466f09b5002e38b" translate="yes" xml:space="preserve">
          <source>Formally, the syntax is.</source>
          <target state="translated">공식적으로 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e6350defe07d4e2839cc6eb5191b1da5190bee4" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the integral part of log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91dd56eddc735a099ddc37f2c2b8d705630baadf" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the signed integral part of log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8179a0c7fe36d2a8a17e5adad38978ddb099049d" translate="yes" xml:space="preserve">
          <source>Formally, to determine which of any two function templates is more specialized, the partial ordering process first transforms one of the two templates as follows:</source>
          <target state="translated">공식적으로 두 함수 템플릿 중 어느 것이 더 특화된 것인지 결정하기 위해 부분 순서 지정 프로세스는 먼저 두 템플릿 중 하나를 다음과 같이 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3636bbcd81222a968d5588186dbdf6c4b0b042e0" translate="yes" xml:space="preserve">
          <source>Formally, to establish more-specialized-than relationship between partial specializations, each is first converted to a fictitious function template as follows:</source>
          <target state="translated">공식적으로, 부분 전문화 간의보다 전문화 된 관계를 설정하기 위해 각각 다음과 같이 가상 함수 템플리트로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f2967eb9e0cfcedd6a189b6a8d3866a634ebbc35" translate="yes" xml:space="preserve">
          <source>Formally.</source>
          <target state="translated">Formally.</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="9d6e5b21d4a23bd5ccd62830a8a750d8fe1ca459" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; 함수 계열의 형식 상수</target>
        </trans-unit>
        <trans-unit id="2baad9ad4884ebddda05c6c67af479131ae29e6b" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; 계열의 형식 상수</target>
        </trans-unit>
        <trans-unit id="6b8afd05c64332502d3616cc67779e98de2c7168" translate="yes" xml:space="preserve">
          <source>Format conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7175d023e27abe317865a491022a09c5f080a380" translate="yes" xml:space="preserve">
          <source>Format macro constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9316b4e7eba6949a72f828ee21024df921672e3c" translate="yes" xml:space="preserve">
          <source>Format observers</source>
          <target state="translated">형식 관찰자</target>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">형식 문자열</target>
        </trans-unit>
        <trans-unit id="c4bb81b6ba2e3eacfc477a97d7def7d80d2c55be" translate="yes" xml:space="preserve">
          <source>Formats monetary value and writes the result to output stream.</source>
          <target state="translated">통화 값을 형식화하고 결과를 출력 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="7c20d6ad01a878bb9e8639e10169a49131276aca" translate="yes" xml:space="preserve">
          <source>Formats the streamable object &lt;code&gt;s&lt;/code&gt; using the format string &lt;code&gt;fmt&lt;/code&gt; and the locale &lt;code&gt;loc&lt;/code&gt; (if provided).</source>
          <target state="translated">스트리밍 오브젝트 포맷 &lt;code&gt;s&lt;/code&gt; 포맷 스트링 사용 &lt;code&gt;fmt&lt;/code&gt; 및 로케일 &lt;code&gt;loc&lt;/code&gt; (제공되는 경우)를.</target>
        </trans-unit>
        <trans-unit id="8bf1052f7f8c855373309b9742ea3d34a8c56846" translate="yes" xml:space="preserve">
          <source>Formatted input</source>
          <target state="translated">형식화 된 입력</target>
        </trans-unit>
        <trans-unit id="ee59b03a5ff5c727bd5ce0a27fd2bc91e970bc1f" translate="yes" xml:space="preserve">
          <source>Formatted input/output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7cf7a590d478b0b7b99c49e642af36f47cd56e2" translate="yes" xml:space="preserve">
          <source>Formatted output</source>
          <target state="translated">형식화 된 출력</target>
        </trans-unit>
        <trans-unit id="722101e27f69cbe90326b9ee974bad21c5f7f772" translate="yes" xml:space="preserve">
          <source>Formatted output functions &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../manip/put_time&quot;&gt;std::put_time&lt;/a&gt;&lt;/code&gt;, if they encounter the end of the output stream before completing output.</source>
          <target state="translated">형식화 된 출력 함수 &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;operator &amp;lt;&amp;lt;&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../manip/put_time&quot;&gt;std::put_time&lt;/a&gt;&lt;/code&gt; 출력을 완료하기 전에 출력 스트림의 끝에 도달 하면)</target>
        </trans-unit>
        <trans-unit id="c36735a1b156faf0d8948786e00b3f1ee63bfe64" translate="yes" xml:space="preserve">
          <source>FormattedInputFunction</source>
          <target state="translated">FormattedInputFunction</target>
        </trans-unit>
        <trans-unit id="8ad283919e38bfa7958b6669077f83561656b04b" translate="yes" xml:space="preserve">
          <source>FormattedOutputFunction</source>
          <target state="translated">FormattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="841f832857c780b47f478b4f21d34d8995af64b8" translate="yes" xml:space="preserve">
          <source>Formatting</source>
          <target state="translated">Formatting</target>
        </trans-unit>
        <trans-unit id="4f6565ce2772bffe98b3ba5983af96ce7e5de363" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; literal representing an imaginary number.</source>
          <target state="translated">폼 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; 허수를 나타내는 문자를.</target>
        </trans-unit>
        <trans-unit id="643fc7954cfd8223ed9cf2e31d62065c242ec93d" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing hours.</source>
          <target state="translated">양식은 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 시간을 나타내는 문자.</target>
        </trans-unit>
        <trans-unit id="331255970e3e48a89f2154f44ef024e28fb6bd1c" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing microseconds.</source>
          <target state="translated">양식은 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 마이크로 초를 나타내는 문자.</target>
        </trans-unit>
        <trans-unit id="8c586fe6bccfd167b2ec9b0341a50e0e2e23b2bd" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing milliseconds.</source>
          <target state="translated">양식은 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; (밀리 초)을 나타내는 문자.</target>
        </trans-unit>
        <trans-unit id="aabdc8e30aa11c549d953403622d6b09da7416a8" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing minutes.</source>
          <target state="translated">양식은 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 분을 나타내는 문자.</target>
        </trans-unit>
        <trans-unit id="b2b858860ebb5672d0b628f2489cbedb92290864" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing nanoseconds.</source>
          <target state="translated">양식은 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 나노초를 나타내는 문자.</target>
        </trans-unit>
        <trans-unit id="d804e0c1b4cad0bfbb3de1fe4b5fa00aa0254978" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing seconds.</source>
          <target state="translated">양식은 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; (초)을 나타내는 문자.</target>
        </trans-unit>
        <trans-unit id="1f2764e36e954fe7d39b543d927e58cc08e2ae3b" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the day value stored in &lt;code&gt;d&lt;/code&gt; formatted as a decimal number, with a leading zero if the result would otherwise be a single decimal digit. Inserts that string into &lt;code&gt;os&lt;/code&gt;. Then, if &lt;code&gt;!d.ok()&lt;/code&gt;, inserts the string &lt;code&gt;&quot; is not a valid day&quot;&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">설문지는 &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 의 저장 날짜 값 이루어진 &lt;code&gt;d&lt;/code&gt; 결과는 달리 하나의 소수 자리 될 경우 앞에 0, 십진수로 포맷. 해당 문자열을 &lt;code&gt;os&lt;/code&gt; 에 삽입합니다 . 그런 다음 &lt;code&gt;!d.ok()&lt;/code&gt; 인 경우 문자열 &lt;code&gt;&quot; is not a valid day&quot;&lt;/code&gt; 를 &lt;code&gt;os&lt;/code&gt; 에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="38eae2fb3ad7f9bb81e8d518abb33df758dc07a9" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the year value stored in &lt;code&gt;y&lt;/code&gt; formatted as a decimal number, left-padded with &lt;code&gt;0&lt;/code&gt; to four digits if the result would otherwise be less than four digits. Inserts that string into &lt;code&gt;os&lt;/code&gt;. Then, if &lt;code&gt;!y.ok()&lt;/code&gt;, inserts the string &lt;code&gt;&quot; is not a valid year&quot;&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">이루는 &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 의 저장 연도 값 이루어진 &lt;code&gt;y&lt;/code&gt; , 십진수로 포맷하는 좌 패드로 &lt;code&gt;0&lt;/code&gt; 네 자리 결과 달리 미만 네 자리 할 것인지. 해당 문자열을 &lt;code&gt;os&lt;/code&gt; 에 삽입합니다 . 그런 다음 &lt;code&gt;!y.ok()&lt;/code&gt; 인 경우 문자열 &lt;code&gt;&quot; is not a valid year&quot;&lt;/code&gt; 를 &lt;code&gt;os&lt;/code&gt; 에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="0d5578517ed64bd2435fafaf294658c0cb1801f2" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::chrono::day&lt;/code&gt; literal representing a day of the month in the calendar.</source>
          <target state="translated">양식은 &lt;code&gt;std::chrono::day&lt;/code&gt; 달력에서 월의 일을 나타내는 문자.</target>
        </trans-unit>
        <trans-unit id="07aea1146bfbc451baff20e77016224dc3f5174b" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::chrono::year&lt;/code&gt; literal representing a year in the proleptic Gregorian calendar.</source>
          <target state="translated">양식은 &lt;code&gt;std::chrono::year&lt;/code&gt; 예 기적 그레고리 안 달력 년 나타내는 문자.</target>
        </trans-unit>
        <trans-unit id="820c807c48f38eb8ca42664fa731c03b51c0dc19" translate="yes" xml:space="preserve">
          <source>Forms a string literal of the desired type.</source>
          <target state="translated">원하는 유형의 문자열 리터럴을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="985e41dbd82d997c605a0a512d9497c566128eb1" translate="yes" xml:space="preserve">
          <source>Forms a string view of a character literal.</source>
          <target state="translated">문자 리터럴의 문자열보기를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="70ef5d692d3abeefce2c77380edc61da30bbd98d" translate="yes" xml:space="preserve">
          <source>Forms can be nested and processed recursively: &lt;code&gt;X&amp;lt;int&amp;gt;(*)(char[6])&lt;/code&gt; is an example of &lt;code&gt;type(*)(T)&lt;/code&gt;, where</source>
          <target state="translated">폼은 재귀 적으로 중첩되고 처리 될 수 있습니다 : &lt;code&gt;X&amp;lt;int&amp;gt;(*)(char[6])&lt;/code&gt; 은 &lt;code&gt;type(*)(T)&lt;/code&gt; 의 예입니다 . 여기서</target>
        </trans-unit>
        <trans-unit id="96d68418cb661c4b3699c2e8d5be8b57b843889b" translate="yes" xml:space="preserve">
          <source>Forms the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_conjunction&quot;&gt;logical conjunction&lt;/a&gt; of the type traits &lt;code&gt;B...&lt;/code&gt;, effectively performing a logical AND on the sequence of traits.</source>
          <target state="translated">특성 &lt;code&gt;B...&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_conjunction&quot;&gt;논리 결합&lt;/a&gt; 을 형성하여 특성 시퀀스에서 논리 AND를 효과적으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="abc06d4ed5fe67746f60bf85f949f812a573392b" translate="yes" xml:space="preserve">
          <source>Forms the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_disjunction&quot;&gt;logical disjunction&lt;/a&gt; of the type traits &lt;code&gt;B...&lt;/code&gt;, effectively performing a logical OR on the sequence of traits.</source>
          <target state="translated">유형 특성 &lt;code&gt;B...&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_disjunction&quot;&gt;논리적 분리&lt;/a&gt; 를 형성하여 특성 시퀀스에서 논리적 OR을 효과적으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bb06b9b7e348bda3d1bd2e01e574d860866f1b4f" translate="yes" xml:space="preserve">
          <source>Forms the logical negation of the type trait &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">유형 특성 &lt;code&gt;B&lt;/code&gt; 의 논리적 부정을 형성합니다 .</target>
        </trans-unit>
        <trans-unit id="82ea89ab75987595e45620e5e795108b1b6e0406" translate="yes" xml:space="preserve">
          <source>Forward declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f690f33d986c3349097e854e0eb9e08b5cc4f9" translate="yes" xml:space="preserve">
          <source>Forward declarations</source>
          <target state="translated">전달 선언</target>
        </trans-unit>
        <trans-unit id="a0a5ca500e9440c8915b30c97f259cacfbb1a922" translate="yes" xml:space="preserve">
          <source>Forward iterator to the new end of the range.</source>
          <target state="translated">반복자를 범위의 새로운 끝으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="55728db9a1113137c393ce6ac1e01d0996797010" translate="yes" xml:space="preserve">
          <source>Forward progress</source>
          <target state="translated">앞으로 진행</target>
        </trans-unit>
        <trans-unit id="ad2924cf16dd4b5c687b5dd4c3d38f7f20d99988" translate="yes" xml:space="preserve">
          <source>ForwardIterator</source>
          <target state="translated">ForwardIterator</target>
        </trans-unit>
        <trans-unit id="967415c810ff974308b7e163c5a8b2ee4963dfdf" translate="yes" xml:space="preserve">
          <source>ForwardRange</source>
          <target state="translated">ForwardRange</target>
        </trans-unit>
        <trans-unit id="02f29ee395fe54e14061ef2943f36bed0af18091" translate="yes" xml:space="preserve">
          <source>Forwarding references</source>
          <target state="translated">전달 참조</target>
        </trans-unit>
        <trans-unit id="9cc6112b2b655f82745fcb59748e093ab1fe8817" translate="yes" xml:space="preserve">
          <source>Forwarding references are a special kind of references that preserve the value category of a function argument, making it possible to</source>
          <target state="translated">전달 참조는 함수 인수의 값 범주를 유지하는 특별한 종류의 참조입니다.</target>
        </trans-unit>
        <trans-unit id="2d1b43ed1d5df75c8cdb7fbed98fd0e15496fb8b" translate="yes" xml:space="preserve">
          <source>Four specializations are provided by the standard library.</source>
          <target state="translated">표준 라이브러리는 4 가지 전문 분야를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="646942bdd43335fac5c5cb8c90a98c4a1571691d" translate="yes" xml:space="preserve">
          <source>Four standalone (locale-independent) specializations are provided by the standard library:</source>
          <target state="translated">표준 라이브러리는 4 개의 독립형 (로케일 독립적) 전문화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6eb9522d427a2669dd67835d7011efde7feafc8c" translate="yes" xml:space="preserve">
          <source>Fourth version</source>
          <target state="translated">네 번째 버전</target>
        </trans-unit>
        <trans-unit id="67c664a3c5100ef6f1199beaf5c8ee1e3784d4ea" translate="yes" xml:space="preserve">
          <source>Free raw memory obtained from allocate_bytes</source>
          <target state="translated">assign_bytes에서 얻은 사용 가능한 원시 메모리</target>
        </trans-unit>
        <trans-unit id="66c8be8d1a5492d1eb9655f15bf0380194107efe" translate="yes" xml:space="preserve">
          <source>Frees raw memory obtained by allocate_object</source>
          <target state="translated">assign_object로 얻은 원시 메모리를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="2715bc5b3d7345dfa8bf763d473dced4c5997198" translate="yes" xml:space="preserve">
          <source>Freestanding and hosted implementations</source>
          <target state="translated">독립형 및 호스팅 구현</target>
        </trans-unit>
        <trans-unit id="755e9516e294b0231da60ee53dcb1cf6956a6f7f" translate="yes" xml:space="preserve">
          <source>Friend declarations cannot refer to partial specializations, but can refer to full specializations:</source>
          <target state="translated">친구 선언은 부분 전문화를 지칭 할 수 없지만 전체 전문화를 지칭 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78f907cdd8f4e2ead952047583a3ce2951b50c9e" translate="yes" xml:space="preserve">
          <source>Friend function declaration</source>
          <target state="translated">친구 기능 선언</target>
        </trans-unit>
        <trans-unit id="74ed844100eed25ad0c1bd3b12ca6cc5919b4157" translate="yes" xml:space="preserve">
          <source>Friend function definition</source>
          <target state="translated">친구 기능 정의</target>
        </trans-unit>
        <trans-unit id="cc53f78835350ac24156d967e62ee0b5c8a5687b" translate="yes" xml:space="preserve">
          <source>Friendship is not inherited (your friend's children are not your friends).</source>
          <target state="translated">우정은 물려받지 않습니다 (친구의 자녀는 친구가 아닙니다).</target>
        </trans-unit>
        <trans-unit id="8c8cea4fdc1598ec00b1de75a422605f0af14cee" translate="yes" xml:space="preserve">
          <source>Friendship is not transitive (a friend of your friend is not your friend).</source>
          <target state="translated">우정은 전 이적이지 않습니다 (친구의 친구는 친구가 아닙니다).</target>
        </trans-unit>
        <trans-unit id="e8b58840737fe83d2eef7b8580aadc5bae0ab4f5" translate="yes" xml:space="preserve">
          <source>Full names</source>
          <target state="translated">성명</target>
        </trans-unit>
        <trans-unit id="0ca544d7457648c14cce40272868cda27ebf4451" translate="yes" xml:space="preserve">
          <source>Function Objects</source>
          <target state="translated">함수 객체</target>
        </trans-unit>
        <trans-unit id="f7f0e1bdfa2f3add115b52939d15e6fd3460937e" translate="yes" xml:space="preserve">
          <source>Function adaptors</source>
          <target state="translated">기능 어댑터</target>
        </trans-unit>
        <trans-unit id="8231e66ed9c1c9e042523416e1ad72237c2d2874" translate="yes" xml:space="preserve">
          <source>Function argument lists</source>
          <target state="translated">함수 인수 목록</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">기능 바디</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="61f764306c5b4c873805f4d7503e407f01f0da37" translate="yes" xml:space="preserve">
          <source>Function call expression is similar in syntax to value initialization &lt;code&gt;T()&lt;/code&gt;, to &lt;a href=&quot;explicit_cast&quot;&gt;function-style cast&lt;/a&gt; expression &lt;code&gt;T(A1)&lt;/code&gt;, and to direct initialization of a temporary &lt;code&gt;T(A1, A2, A3, ...)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the name of a type.</source>
          <target state="translated">함수 호출 표현식은 구문에서 값 초기화 &lt;code&gt;T()&lt;/code&gt; , &lt;a href=&quot;explicit_cast&quot;&gt;함수 스타일 캐스트&lt;/a&gt; 표현식 &lt;code&gt;T(A1)&lt;/code&gt; 및 임시 &lt;code&gt;T(A1, A2, A3, ...)&lt;/code&gt; 초기화와 유사합니다 . 여기서 &lt;code&gt;T&lt;/code&gt; 는 이름입니다 유형의.</target>
        </trans-unit>
        <trans-unit id="55cb199824723ac48f856b32fde1674eff49a87b" translate="yes" xml:space="preserve">
          <source>Function call expressions returning &lt;code&gt;void&lt;/code&gt;, cast expressions to &lt;code&gt;void&lt;/code&gt;, and &lt;a href=&quot;throw&quot;&gt;throw-expressions&lt;/a&gt; are classified as prvalue expressions, but they cannot be used to initialize references or as function arguments. They can be used in discarded-value contexts (e.g. on a line of its own, as the left-hand operand of the comma operator, etc.) and in the &lt;code&gt;return&lt;/code&gt; statement in a function returning &lt;code&gt;void&lt;/code&gt;. In addition, throw-expressions may be used as the second and the third operands of the &lt;a href=&quot;operator_other&quot;&gt;conditional operator ?:&lt;/a&gt;.</source>
          <target state="translated">반환 함수 호출 식을 &lt;code&gt;void&lt;/code&gt; 로, 캐스트 식을 &lt;code&gt;void&lt;/code&gt; 하고, &lt;a href=&quot;throw&quot;&gt;드로 인 표현은&lt;/a&gt; prvalue 식으로 분류되어 있지만 참조 또는 함수 인수로 초기화 할 수 없습니다. 버려진 값 컨텍스트 (예 : 쉼표 연산자의 왼쪽 피연산자 등의 고유 한 행) 및 &lt;code&gt;void&lt;/code&gt; 를 반환하는 함수 의 &lt;code&gt;return&lt;/code&gt; 문에서 사용할 수 있습니다 . 또한 &lt;a href=&quot;operator_other&quot;&gt;조건 연산자? :&lt;/a&gt; 의 두 번째 및 세 번째 피연산자로 throw-expression을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25056cd4f19ab3cf2ddbe426ca4f88659c9ecb1f" translate="yes" xml:space="preserve">
          <source>Function call operator</source>
          <target state="translated">함수 호출 연산자</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d84dffd70068ddd1111084e3623daad3386117d" translate="yes" xml:space="preserve">
          <source>Function declarations may appear in any scope. A function declaration at class scope introduces a class member function (unless the friend specifier is used), see &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt; and &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt; for details.</source>
          <target state="translated">함수 선언은 모든 범위에서 나타날 수 있습니다. 클래스 범위에서 함수 선언은 클래스 멤버 함수를 도입합니다 (친구 지정자가 사용되지 않는 한). 자세한 내용은 &lt;a href=&quot;member_functions&quot;&gt;멤버 함수&lt;/a&gt; 및 &lt;a href=&quot;friend&quot;&gt;친구 함수&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="01a7dcd826dbbad15679402aaa257c1e8bee4fd2" translate="yes" xml:space="preserve">
          <source>Function declarators can be mixed with other declarators, where decl-specifier-seq allows:</source>
          <target state="translated">함수 선언자는 decl-specifier-seq가 허용하는 다른 선언자와 혼합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5f8af75bc5ad30466ed317152a310aba07e877e" translate="yes" xml:space="preserve">
          <source>Function definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a31e049889b12e1b53d0e991bba8a50561e7a03" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;&lt;a href=&quot;iswspace&quot;&gt;std::iswspace&lt;/a&gt;()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">함수는 공백이 아닌 첫 번째 문자가 발견 될 때까지 공백 문자 ( &lt;code&gt;&lt;a href=&quot;iswspace&quot;&gt;std::iswspace&lt;/a&gt;()&lt;/code&gt; 의해 결정됨)를 버립니다 . 그런 다음 유효한 부동 소수점 표현을 형성하기 위해 가능한 한 많은 문자를 사용하여 부동 소수점 값으로 변환합니다. 유효한 부동 소수점 값은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="268b166a91a60d5f1a938de3418f1d3678105197" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;std::isspace()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">함수는 공백이 아닌 첫 번째 문자가 발견 될 때까지 공백 문자 ( &lt;code&gt;std::isspace()&lt;/code&gt; 의해 결정됨)를 버립니다 . 그런 다음 유효한 부동 소수점 표현을 형성하기 위해 가능한 한 많은 문자를 사용하여 부동 소수점 값으로 변환합니다. 유효한 부동 소수점 값은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d376c8d143e7051f331c1aba9bc9e6fccbf798" translate="yes" xml:space="preserve">
          <source>Function invocation</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="ec031b84374532b3dd5e02a9109e50cae284b830" translate="yes" xml:space="preserve">
          <source>Function macros for integer constants</source>
          <target state="translated">정수 상수에 대한 함수 매크로</target>
        </trans-unit>
        <trans-unit id="60be48a55b3f6bfe81f126777640e7116a702836" translate="yes" xml:space="preserve">
          <source>Function macros for minimum-width integer constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8a59f44f5ba9847650733c0cafd473c4eed11f" translate="yes" xml:space="preserve">
          <source>Function not supported</source>
          <target state="translated">지원되지 않는 기능</target>
        </trans-unit>
        <trans-unit id="b248eacc8c468b679bd61ad8cb82d22de759fe43" translate="yes" xml:space="preserve">
          <source>Function object for computing remainders of divisions. Implements &lt;code&gt;operator%&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">나눗셈의 나머지를 계산하기위한 함수 객체. 유형 &lt;code&gt;T&lt;/code&gt; 에 대한 &lt;code&gt;operator%&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a4633ecd37c7996641d9e6e60f41f4acaad220fb" translate="yes" xml:space="preserve">
          <source>Function object for performing addition. Effectively calls &lt;code&gt;operator+&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">덧셈을 수행하기위한 함수 객체. &lt;code&gt;T&lt;/code&gt; 유형의 두 인스턴스에서 &lt;code&gt;operator+&lt;/code&gt; 를 효과적으로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d149129b3c23a795999a21bc625bd934320c5a89" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise AND. Effectively calls &lt;code&gt;operator&amp;amp;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">비트 AND를 수행하기위한 함수 객체입니다. 유형 &lt;code&gt;T&lt;/code&gt; 에서 효과적으로 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b599fdda8a6eff8b08fa4dda5e4633fab0dbe0ce" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise NOT. Effectively calls &lt;code&gt;operator~&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">비트 NOT을 수행하기위한 함수 객체. 유형 &lt;code&gt;T&lt;/code&gt; 에서 효과적으로 &lt;code&gt;operator~&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="313209366a119d00dc320937bfc0bbb8786800ec" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise OR. Effectively calls &lt;code&gt;operator|&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">비트 단위 OR을 수행하기위한 함수 객체입니다. 효과적으로 &lt;code&gt;operator|&lt;/code&gt; 호출합니다 | 유형 &lt;code&gt;T&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="c5887d43f2e0df69b82fff43b54f846c4704fa46" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise XOR. Effectively calls &lt;code&gt;operator^&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">비트 XOR을 수행하기위한 함수 객체입니다. 유형 &lt;code&gt;T&lt;/code&gt; 에서 효과적으로 &lt;code&gt;operator^&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e180b41511a71768ffe2c960f01fb1039a41108e" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Deduces the parameter types of the function call operator from the arguments (but not the return type).</source>
          <target state="translated">비교를 수행하기위한 함수 객체입니다. 함수 호출 연산자의 매개 변수 유형을 인수에서 추론합니다 (반환 유형은 아님).</target>
        </trans-unit>
        <trans-unit id="56f077a1110154764933177a4a8a45a67a0e117f" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialised, invokes &lt;code&gt;operator!=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">비교를 수행하기위한 함수 객체입니다. 특수하게 지정하지 않으면 &lt;code&gt;T&lt;/code&gt; 유형에서 &lt;code&gt;operator!=&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3d8efff6ca90765aa3a8bc08e4dd6c03c3e58a69" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialised, invokes &lt;code&gt;operator==&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">비교를 수행하기위한 함수 객체입니다. 특수화되지 않은 한 &lt;code&gt;T&lt;/code&gt; 유형에서 &lt;code&gt;operator==&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="60aea8fb12e1c43b673c06d961c8619b0f1469c4" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;gt;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">비교를 수행하기위한 함수 객체입니다. 특수화되지 않으면 &lt;code&gt;T&lt;/code&gt; 유형에서 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="738acefb6a4d9540bfe0b153875600600ca1005f" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;gt;=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">비교를 수행하기위한 함수 객체입니다. 특수화되지 않은 경우 &lt;code&gt;T&lt;/code&gt; 유형에서 &lt;code&gt;operator&amp;gt;=&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2ed4fd907e2e5e744c2b2efa9d9bc109fe8439c7" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;lt;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">비교를 수행하기위한 함수 객체입니다. 특수화되지 않은 한 유형 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="86238797ec5cdcf632292c3e4d25c647b5a4693a" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;lt;=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">비교를 수행하기위한 함수 객체입니다. 특수화되지 않은 한 유형 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;operator&amp;lt;=&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="0fe5410430a56ab0ae8cbfda0c39393d3efaefd1" translate="yes" xml:space="preserve">
          <source>Function object for performing division. Effectively calls &lt;code&gt;operator/&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">나누기를 수행하기위한 함수 객체입니다. &lt;code&gt;T&lt;/code&gt; 유형의 두 인스턴스에서 &lt;code&gt;operator/&lt;/code&gt; 를 효과적으로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="12de586434654aa1a14b6b2d8a259de90a34392f" translate="yes" xml:space="preserve">
          <source>Function object for performing logical AND (logical conjunction). Effectively calls &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">논리 AND를 수행하기위한 함수 개체 (논리적 연결). 유형 &lt;code&gt;T&lt;/code&gt; 에서 효과적으로 &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1490a0997baca27d81b16387b04a8b28fa19d7e6" translate="yes" xml:space="preserve">
          <source>Function object for performing logical NOT (logical negation). Effectively calls &lt;code&gt;operator!&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">논리 NOT (논리 부정)을 수행하기위한 함수 객체. 효과적으로 &lt;code&gt;operator!&lt;/code&gt; 호출합니다 ! &lt;code&gt;T&lt;/code&gt; 타입의 경우 .</target>
        </trans-unit>
        <trans-unit id="26fc81b06029a179ee570f03e59c7d8106976333" translate="yes" xml:space="preserve">
          <source>Function object for performing logical OR (logical disjunction). Effectively calls &lt;code&gt;operator||&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">논리적 OR (논리 분리)을 수행하기위한 함수 객체입니다. 효과적으로 &lt;code&gt;operator||&lt;/code&gt; 호출합니다 유형 &lt;code&gt;T&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="863b97dec6e3bad00c70886e69a7afbb1c4e16fb" translate="yes" xml:space="preserve">
          <source>Function object for performing multiplication. Effectively calls &lt;code&gt;operator*&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">곱셈을 수행하기위한 함수 객체입니다. &lt;code&gt;T&lt;/code&gt; 유형의 두 인스턴스에서 &lt;code&gt;operator*&lt;/code&gt; 를 효과적으로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a134daaeb15195627f59ee24f26ecba80c6eb4fc" translate="yes" xml:space="preserve">
          <source>Function object for performing negation. Effectively calls &lt;code&gt;operator-&lt;/code&gt; on an instance of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">부정을 수행하기위한 함수 객체. 유형 &lt;code&gt;T&lt;/code&gt; 의 인스턴스에서 효과적으로 &lt;code&gt;operator-&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6be85bc0166110c97cce13deef82fe7cce65ca9c" translate="yes" xml:space="preserve">
          <source>Function object for performing subtraction. Effectively calls &lt;code&gt;operator-&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">빼기를 수행하기위한 함수 객체입니다. &lt;code&gt;T&lt;/code&gt; 유형의 두 인스턴스에서 &lt;code&gt;operator-&lt;/code&gt; 를 효과적으로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="05785bcc60d939df6f0a0f7578eb56a67e1b185f" translate="yes" xml:space="preserve">
          <source>Function objects</source>
          <target state="translated">함수 객체</target>
        </trans-unit>
        <trans-unit id="b8f9cce63cec2dc22abc32a4cbf9907e736f87ee" translate="yes" xml:space="preserve">
          <source>Function objects, Function invocations, Bind operations and Reference wrappers</source>
          <target state="translated">함수 오브젝트, 함수 호출, 바인드 조작 및 참조 랩퍼</target>
        </trans-unit>
        <trans-unit id="474b3e14aec889f00fbd7fffa4899aaf67c18da3" translate="yes" xml:space="preserve">
          <source>Function overloads vs function specializations</source>
          <target state="translated">기능 과부하 및 기능 전문화</target>
        </trans-unit>
        <trans-unit id="05c625ce62f1567c6464e68f3d0c5ca596683e7c" translate="yes" xml:space="preserve">
          <source>Function parameter list</source>
          <target state="translated">기능 파라미터 목록</target>
        </trans-unit>
        <trans-unit id="cacf242390ee182c0b5703d0e286b16458b2d6ac" translate="yes" xml:space="preserve">
          <source>Function parameter pack (a form of &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, appears in a function parameter list of a variadic function template).</source>
          <target state="translated">함수 매개 변수 팩 ( &lt;a href=&quot;declarations&quot;&gt;선언자&lt;/a&gt; 형식)은 가변 함수 템플릿의 함수 매개 변수 목록에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ee2ed22b6c316767fa0eee64138df658812f8372" translate="yes" xml:space="preserve">
          <source>Function parameter scope</source>
          <target state="translated">기능 파라미터 범위</target>
        </trans-unit>
        <trans-unit id="16a39e4b6666353c50f59b56d3cce3eb5dbeca02" translate="yes" xml:space="preserve">
          <source>Function parameters are not allowed in default arguments (even if they are not evaluated)(until C++14) except if they are unevaluated(since C++14). Note that parameters that appear earlier in the parameter list are in &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;:</source>
          <target state="translated">함수 매개 변수는 평가되지 않은 경우 (C ++ 14 이후)를 제외하고 기본 인수 (C ++ 14까지)에서 허용되지 않습니다. 에 이전 매개 변수 목록에 나타나는 매개 변수 참고 &lt;a href=&quot;scope&quot;&gt;범위를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c545df3352143fe60a307ebf941a3169f4b04ba9" translate="yes" xml:space="preserve">
          <source>Function pointer conversions</source>
          <target state="translated">함수 포인터 변환</target>
        </trans-unit>
        <trans-unit id="14644346bcc70a878c3eb265226005a7304bec16" translate="yes" xml:space="preserve">
          <source>Function scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d879bbf1375b073db057a0370df0b5d2aaf75d77" translate="yes" xml:space="preserve">
          <source>Function template</source>
          <target state="translated">기능 템플릿</target>
        </trans-unit>
        <trans-unit id="e8ac637a6e8fb2f46175ee490eb2eb83645238b8" translate="yes" xml:space="preserve">
          <source>Function template &lt;code&gt;std::mem_fn&lt;/code&gt; generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member. Both references and pointers (including smart pointers) to an object can be used when invoking a &lt;code&gt;std::mem_fn&lt;/code&gt;.</source>
          <target state="translated">함수 템플릿 &lt;code&gt;std::mem_fn&lt;/code&gt; 은 멤버에 대한 포인터를 저장하고 복사하고 호출 할 수있는 멤버에 대한 래퍼 객체를 생성합니다. &lt;code&gt;std::mem_fn&lt;/code&gt; 호출 할 때 객체에 대한 참조 및 포인터 (스마트 포인터 포함)를 모두 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba1b466469de4bedf72f07dd5b3b51bc92ecf5e1" translate="yes" xml:space="preserve">
          <source>Function template instantiation</source>
          <target state="translated">함수 템플릿 인스턴스화</target>
        </trans-unit>
        <trans-unit id="a76d53230697569d7c028ff1451f97505d469db4" translate="yes" xml:space="preserve">
          <source>Function template overloading</source>
          <target state="translated">함수 템플릿 오버로딩</target>
        </trans-unit>
        <trans-unit id="86dd3fddcc75cfa4e063a703f32c8ede28f4c30d" translate="yes" xml:space="preserve">
          <source>Function template parameters are substituted (replaced by template arguments) twice:</source>
          <target state="translated">함수 템플릿 매개 변수는 두 번 대체됩니다 (템플릿 인수로 대체 됨).</target>
        </trans-unit>
        <trans-unit id="6027571a098596d5e87183ff7d586ec483f03343" translate="yes" xml:space="preserve">
          <source>Function template specialization</source>
          <target state="translated">기능 템플릿 전문화</target>
        </trans-unit>
        <trans-unit id="c03fc20cda6df9ef92fd64413e95464c0412a4fc" translate="yes" xml:space="preserve">
          <source>Function templates &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;cref&lt;/code&gt; are helper functions that generate an object of type &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, using &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; to determine the template argument of the result.</source>
          <target state="translated">함수 템플릿은 &lt;code&gt;ref&lt;/code&gt; 과 &lt;code&gt;cref&lt;/code&gt; 타입의 객체 생성 도우미 함수입니다 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; 사용하여 &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;템플릿 인수 공제&lt;/a&gt; 결과의 템플릿 인수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="d90c99af4d1617c8e3520279788821d8d6072cea" translate="yes" xml:space="preserve">
          <source>Function templates and non-template functions may be overloaded.</source>
          <target state="translated">함수 템플릿 및 템플릿이 아닌 함수가 오버로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="527a4bc836096e4223cdeb54a2dc838640d3aaaa" translate="yes" xml:space="preserve">
          <source>Function to pointer</source>
          <target state="translated">포인터 기능</target>
        </trans-unit>
        <trans-unit id="ccff159bf6b5506e0e1b9835119cc9060c666c2b" translate="yes" xml:space="preserve">
          <source>Function wrappers</source>
          <target state="translated">함수 래퍼</target>
        </trans-unit>
        <trans-unit id="2e3030f5a7f048cef8382d50828336e71bb753d2" translate="yes" xml:space="preserve">
          <source>Function-like macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a542b043e775e7bb5b171b48eca68e3eaf37af10" translate="yes" xml:space="preserve">
          <source>Function-like macros replace each occurrence of defined identifier with replacement-list, additionally taking a number of arguments, which then replace corresponding occurrences of any of the parameters in the replacement-list.</source>
          <target state="translated">함수와 유사한 매크로는 정의 된 식별자의 각 항목을 교체 목록으로 대체하고, 추가로 여러 인수를 취한 다음 대체 목록에서 매개 변수의 해당 항목을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="1bc7ec84b7f54258ed54c7cecbe2e69587cb60b9" translate="yes" xml:space="preserve">
          <source>Function-local static objects in all definitions of the same &lt;a href=&quot;inline&quot;&gt;inline function&lt;/a&gt; (which may be implicitly inline) all refer to the same object defined in one translation unit.</source>
          <target state="translated">동일한 &lt;a href=&quot;inline&quot;&gt;인라인 함수&lt;/a&gt; (암시 적으로 인라인 일 수 있음) 의 모든 정의에서 함수 로컬 정적 객체는 모두 하나의 변환 단위에 정의 된 동일한 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fbeb9de485717bfd55eb5b969f4aef0b216aa354" translate="yes" xml:space="preserve">
          <source>Function-local static objects in all function definitions are shared across all translation units (they all refer to the same object defined in one translation unit)</source>
          <target state="translated">모든 함수 정의의 함수 로컬 정적 개체는 모든 변환 단위에서 공유됩니다 (모두 하나의 변환 단위에 정의 된 동일한 개체를 참조 함)</target>
        </trans-unit>
        <trans-unit id="22b482f447a1cfcb8f938c680757e7b627882a11" translate="yes" xml:space="preserve">
          <source>Function-try-block</source>
          <target state="translated">Function-try-block</target>
        </trans-unit>
        <trans-unit id="36dbe687f7a701ccda0c0ab3d3368fc1726070a3" translate="yes" xml:space="preserve">
          <source>Function-try-block does not catch the exceptions thrown by the copy/move constructors and the destructors of the function parameters passed by value: those exceptions are thrown in context of the caller.</source>
          <target state="translated">function-try-block은 copy / move 생성자 및 값에 의해 전달 된 함수 매개 변수의 소멸자에 의해 발생 된 예외를 포착하지 않습니다. 이러한 예외는 호출자의 컨텍스트에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62fa030d8057f6948ce260fe787ed5a6b93441e6" translate="yes" xml:space="preserve">
          <source>Function-try-block of the top-level function of a thread does not catch the exceptions thrown from the constructors and destructors of &lt;a href=&quot;storage_duration&quot;&gt;thread-local&lt;/a&gt; objects (except for the constructors of function-scoped thread-locals).</source>
          <target state="translated">스레드 최상위 함수의 함수 시도 블록은 &lt;a href=&quot;storage_duration&quot;&gt;스레드 로컬&lt;/a&gt; 객체 의 생성자와 소멸자에서 발생한 예외를 포착하지 않습니다 (함수 범위의 스레드 로컬 생성자를 제외).</target>
        </trans-unit>
        <trans-unit id="e6221f912553a22b3b906841565a95ac6fe744e4" translate="yes" xml:space="preserve">
          <source>FunctionObject</source>
          <target state="translated">FunctionObject</target>
        </trans-unit>
        <trans-unit id="c504a5185db1d5f75bfd32087e1e44501fcf47f1" translate="yes" xml:space="preserve">
          <source>Functional cast</source>
          <target state="translated">기능성 캐스트</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="b4889f5791eb376ad73674ef2d3c06e94b724603" translate="yes" xml:space="preserve">
          <source>Functions and macro constants for signal management</source>
          <target state="translated">신호 관리를위한 함수 및 매크로 상수</target>
        </trans-unit>
        <trans-unit id="a1141ae7da62060d933a86668311750ac59f208e" translate="yes" xml:space="preserve">
          <source>Functions and references to functions are not function object types, but can be used where function object types are expected due to function-to-pointer &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicit conversion&lt;/a&gt;.</source>
          <target state="translated">함수에 대한 함수 및 참조는 함수 객체 유형이 아니지만 함수에서 포인터로의 &lt;a href=&quot;../language/implicit_cast&quot;&gt;암시 적 변환&lt;/a&gt; 으로 인해 함수 객체 유형이 필요한 경우 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab7bbe95387b8d4e9017d700d4c60ae66f3da45c" translate="yes" xml:space="preserve">
          <source>Functions are C++ entities that associate a sequence of &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt; (a</source>
          <target state="translated">함수는 일련의 &lt;a href=&quot;statements&quot;&gt;문장&lt;/a&gt; 을 연결하는 C ++ 엔터티입니다 .</target>
        </trans-unit>
        <trans-unit id="9a1ebfefe2d4935a5dd163de13ea3976c504e0ea" translate="yes" xml:space="preserve">
          <source>Functions are not objects: there are no arrays of functions and functions cannot be passed by value or returned from other functions. Pointers and references to functions are allowed, and may be used where functions themselves cannot.</source>
          <target state="translated">함수는 객체가 아닙니다. 함수의 배열이 없으며 함수는 값으로 전달되거나 다른 함수에서 반환 될 수 없습니다. 함수에 대한 포인터와 참조는 허용되며 함수 자체가 할 수없는 경우에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4cd68a9abe69d2fc916398ed73a57ddaba5e3ac" translate="yes" xml:space="preserve">
          <source>Functions differing only in their exception specification cannot be overloaded (just like the return type, exception specification is part of function type, but not part of the function signature)(since C++17).</source>
          <target state="translated">예외 사양에서만 다른 함수는 오버로드 할 수 없습니다 (반환 유형과 마찬가지로 예외 사양은 함수 유형의 일부이지만 함수 서명의 일부는 아닙니다) (C ++ 17 이후).</target>
        </trans-unit>
        <trans-unit id="d805e16a2e1dab2e9501d00d8aa06488d3d1141d" translate="yes" xml:space="preserve">
          <source>Functions in input/output classes returning this type use &lt;code&gt;X::pos_type(X::off_type(-1))&lt;/code&gt; is an invalid value to signal an error</source>
          <target state="translated">이 유형을 반환하는 입 / 출력 클래스의 함수는 &lt;code&gt;X::pos_type(X::off_type(-1))&lt;/code&gt; 을 사용하여 오류를 나타내는 유효하지 않은 값입니다.</target>
        </trans-unit>
        <trans-unit id="f4f28c856ebb451338613595e08fe5dd22c841b5" translate="yes" xml:space="preserve">
          <source>Functions managing the current thread</source>
          <target state="translated">현재 스레드를 관리하는 기능</target>
        </trans-unit>
        <trans-unit id="d3e493f42a02a1130d7650420222293b27d1128f" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; are called in reverse order of their registration. If an exception tries to propagate out of any of the functions, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. After calling the registered functions, calls &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;std::_Exit&lt;/a&gt;(exit_code)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; 전달 된 함수는 등록 순서와 반대로 호출됩니다. 예외가 함수에서 전파하려고하면 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. 등록 된 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;std::_Exit&lt;/a&gt;(exit_code)&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="2271b1375ac754084b518ec111ad83a20a6f3bb3" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are not called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 전달 된 함수는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4c76c24658f2c936074eb17b534063810ef4a85" translate="yes" xml:space="preserve">
          <source>Functions templates cannot be declared &lt;code&gt;virtual&lt;/code&gt;. This applies only to functions that are themselves templates - a regular member function of a class template can be declared virtual.</source>
          <target state="translated">함수 템플릿은 &lt;code&gt;virtual&lt;/code&gt; 으로 선언 될 수 없습니다 . 이것은 템플릿 자체 인 함수에만 적용됩니다. 클래스 템플릿의 일반 멤버 함수는 가상으로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="987a9735f7910a78415404d390c2c2321b297df5" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in character data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56333d40b9d13a5dd6765448f63eb5888129f41c" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in wide character data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268aa8a9dc8a94eb9552c1bc422fd7d569604150" translate="yes" xml:space="preserve">
          <source>Fundamental library concepts</source>
          <target state="translated">기본 라이브러리 개념</target>
        </trans-unit>
        <trans-unit id="9415eca058dab008a0c257d5b5372a414020f727" translate="yes" xml:space="preserve">
          <source>Fundamental types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="f9ccc0fa4eefc3fc4fbd603adf877686e0fcb107" translate="yes" xml:space="preserve">
          <source>Fundamental types defined by the language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="90203b2e01951bcae33561da4c2fe607351b5912" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;auto&lt;/code&gt;and type-constraint&lt;code&gt;auto&lt;/code&gt;(since C++20) can appear in:</source>
          <target state="translated">또한 &lt;code&gt;auto&lt;/code&gt; 및 type-constraint &lt;code&gt;auto&lt;/code&gt; (C ++ 20부터)는 다음과 같이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dc21edb8c36c3f6d406c872d0cb241b792a813e" translate="yes" xml:space="preserve">
          <source>Furthermore.</source>
          <target state="translated">Furthermore.</target>
        </trans-unit>
        <trans-unit id="ef3bf279dd511b3249e9a0fa2ada2e63ca452156" translate="yes" xml:space="preserve">
          <source>Future errors</source>
          <target state="translated">미래의 오류</target>
        </trans-unit>
        <trans-unit id="965db80f650641f51dead99c13720e4035c9ef70" translate="yes" xml:space="preserve">
          <source>Futures</source>
          <target state="translated">Futures</target>
        </trans-unit>
        <trans-unit id="4c00eeb89fd7b78411cbeb5ccec11fa4c97f179d" translate="yes" xml:space="preserve">
          <source>GCC 4.6 libstdc++</source>
          <target state="translated">GCC 4.6 libstdc ++</target>
        </trans-unit>
        <trans-unit id="8678ed721c5d5bc588ebb7a34742eafcc58d8a66" translate="yes" xml:space="preserve">
          <source>GCC Inline Assembly HOWTO</source>
          <target state="translated">GCC 인라인 어셈블리 하우투</target>
        </trans-unit>
        <trans-unit id="e28f7b13c864b2544bcffb8944485f05b95aa03f" translate="yes" xml:space="preserve">
          <source>GCC assembly with the attribute:</source>
          <target state="translated">속성이있는 GCC 어셈블리 :</target>
        </trans-unit>
        <trans-unit id="29dc240b146eb494ed0bbceef77ad1534442b61b" translate="yes" xml:space="preserve">
          <source>GCC assembly without the attribute: the entire function is serialized.</source>
          <target state="translated">속성이없는 GCC 어셈블리 : 전체 기능이 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="607e8f7d61ea73ecc2a3928fe014d54ac981f615" translate="yes" xml:space="preserve">
          <source>GLAGOLITIC CAPITAL LETTER AZU - COMBINING CYRILLIC LETTER IOTIFIED BIG YUS</source>
          <target state="translated">형광성 대문자 문자 AZU-순환 순환 문자로 구성된 IOTIFIED BIG YUS</target>
        </trans-unit>
        <trans-unit id="770bd3164fd3f78b840dd2606eee557790bae82f" translate="yes" xml:space="preserve">
          <source>GNU libc function &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/s/hello/manual/libc/Control-Functions.html&quot;&gt;feenableexcept()&lt;/a&gt;&lt;/code&gt; enables trapping of the floating-point exceptions, which generates the signal &lt;code&gt;SIGFPE&lt;/code&gt;. If the compiler option &lt;code&gt;-fnon-call-exceptions&lt;/code&gt; was used, the handler for that signal may throw a user-defined C++ exception.</source>
          <target state="translated">GNU libc 함수 &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/s/hello/manual/libc/Control-Functions.html&quot;&gt;feenableexcept()&lt;/a&gt;&lt;/code&gt; 사용하면 &lt;code&gt;SIGFPE&lt;/code&gt; 신호를 생성하는 부동 소수점 예외를 트래핑 할 수 있습니다 . 컴파일러 옵션 &lt;code&gt;-fnon-call-exceptions&lt;/code&gt; 가 사용 된 경우 해당 신호의 핸들러가 사용자 정의 C ++ 예외를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e7d86fda01350dd97d7deed580504fa4ea12720" translate="yes" xml:space="preserve">
          <source>GNU libstdc++ stores 4 additional members: three cached facets and a flag to indicate that fill was initialized.</source>
          <target state="translated">GNU libstdc ++는 4 개의 추가 멤버, 즉 3 개의 캐시 된 패싯과 채우기가 초기화되었음을 나타내는 플래그를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="262e4b5ffc0564ab9152ecabdaf6c1affcaea1bc" translate="yes" xml:space="preserve">
          <source>GOTW issue 47: Uncaught Exceptions</source>
          <target state="translated">GOTW 이슈 47 : 포착되지 않은 예외</target>
        </trans-unit>
        <trans-unit id="143075ce23be9b2dbef6368dc5e0e4219829451a" translate="yes" xml:space="preserve">
          <source>Garbage collector support</source>
          <target state="translated">가비지 콜렉터 지원</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="c807e9f8f0554603e2d07bd5ea3e21f358d0409a" translate="yes" xml:space="preserve">
          <source>General purpose utilities: &lt;a href=&quot;utility/program&quot;&gt; program control&lt;/a&gt;, &lt;a href=&quot;memory/c&quot;&gt; dynamic memory allocation&lt;/a&gt;, &lt;a href=&quot;numeric/random&quot;&gt; random numbers&lt;/a&gt;, &lt;a href=&quot;algorithm&quot;&gt; sort and search&lt;/a&gt;</source>
          <target state="translated">범용 유틸리티 : &lt;a href=&quot;utility/program&quot;&gt;프로그램 제어&lt;/a&gt; , &lt;a href=&quot;memory/c&quot;&gt;동적 메모리 할당&lt;/a&gt; , &lt;a href=&quot;numeric/random&quot;&gt;난수&lt;/a&gt; , &lt;a href=&quot;algorithm&quot;&gt;정렬 및 검색&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed31062b543a89f89f4324118c873e8e23d6d8a5" translate="yes" xml:space="preserve">
          <source>General-purpose utilities</source>
          <target state="translated">범용 유틸리티</target>
        </trans-unit>
        <trans-unit id="5c6d1d670f7f626ac925f247ce54a21001aced36" translate="yes" xml:space="preserve">
          <source>Generalized lambda-capture</source>
          <target state="translated">일반화 된 람다 캡처</target>
        </trans-unit>
        <trans-unit id="f356c8b2b591cd001b93f307940d89de652b1d90" translate="yes" xml:space="preserve">
          <source>Generalized range-based &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">일반화 된 범위 기반 &lt;code&gt;for&lt;/code&gt; 루프</target>
        </trans-unit>
        <trans-unit id="42544cf1873411d097739bf7d82068c8b915ea3d" translate="yes" xml:space="preserve">
          <source>Generalized sum of &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;*first&lt;/code&gt;, &lt;code&gt;*(first+1)&lt;/code&gt;, ... &lt;code&gt;*(last-1)&lt;/code&gt; over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">일반화의 합 &lt;code&gt;init&lt;/code&gt; 및 &lt;code&gt;*first&lt;/code&gt; , &lt;code&gt;*(first+1)&lt;/code&gt; , ... &lt;code&gt;*(last-1)&lt;/code&gt; 위에 &lt;code&gt;binary_op&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="13dfcc134e2752a1f9a0a0493daeaa583d9e01a7" translate="yes" xml:space="preserve">
          <source>Generally speaking, the pseudo-random number generator should only be seeded once, before any calls to &lt;code&gt;rand()&lt;/code&gt;, at the start of the program. It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.</source>
          <target state="translated">일반적으로 의사 난수 생성기는 프로그램 시작시 &lt;code&gt;rand()&lt;/code&gt; 호출하기 전에 한 번만 시드해야합니다 . 새로운 의사 난수의 새로운 배치를 생성 할 때마다 반복적으로 시드되거나 시드 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ebbc49a3b2f1f41072b44a34d7a54d1bce22da9" translate="yes" xml:space="preserve">
          <source>Generates a non-deterministic uniformly-distributed random value.</source>
          <target state="translated">비 결정적 균일하게 분포 된 난수 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="974bfaa70e23e754b8c317100b6cf3c9baf7cefa" translate="yes" xml:space="preserve">
          <source>Generates a pseudo-random value. The state of the engine is advanced by one position.</source>
          <target state="translated">의사 난수 값을 생성합니다. 엔진 상태는 한 위치 씩 전진합니다.</target>
        </trans-unit>
        <trans-unit id="69477acbfb73a301833c0442c884476d728e54ee" translate="yes" xml:space="preserve">
          <source>Generates a random floating point number in range [0, 1).</source>
          <target state="translated">[0, 1) 범위에서 임의의 부동 소수점 숫자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e11bac75cd58a1ca2fdf3ef16eb35185ecf226b4" translate="yes" xml:space="preserve">
          <source>Generates a random value. The state of the underlying engine is advanced one or more times.</source>
          <target state="translated">임의의 값을 생성합니다. 기본 엔진의 상태가 한 번 이상 진행되었습니다.</target>
        </trans-unit>
        <trans-unit id="045d154a63fd09f9bc95c348dc0baa989ebab1d6" translate="yes" xml:space="preserve">
          <source>Generates random numbers according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;Normal (or Gaussian) random number distribution&lt;/a&gt;. It is defined as:   f(x; &amp;mu;,&amp;sigma;) =</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;정규 (또는 가우시안) 난수 분포&lt;/a&gt; 에 따라 난수를 생성 합니다. f (x; &amp;mu;, &amp;sigma;) =</target>
        </trans-unit>
        <trans-unit id="74b3ade82ac714c1951306b471876167535085c8" translate="yes" xml:space="preserve">
          <source>Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling &lt;code&gt;g.operator()&lt;/code&gt;.</source>
          <target state="translated">관련 확률 함수에 따라 분포 된 난수를 생성합니다. 엔트로피는 &lt;code&gt;g.operator()&lt;/code&gt; 를 호출하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="8d441fb5f62f87aca029a4bb398180b09920a3f5" translate="yes" xml:space="preserve">
          <source>Generation</source>
          <target state="translated">Generation</target>
        </trans-unit>
        <trans-unit id="742daa97a3eea8220673e99a3db1f627bdf6d93c" translate="yes" xml:space="preserve">
          <source>Generic (polymorphic) lambda expressions</source>
          <target state="translated">일반 (다형성) 람다 식</target>
        </trans-unit>
        <trans-unit id="a3b12ef32437e95ff76df32c3bf2e29d863224ec" translate="yes" xml:space="preserve">
          <source>Generic components may, in addition, offer</source>
          <target state="translated">또한 일반적인 구성 요소는</target>
        </trans-unit>
        <trans-unit id="d399f4838f649a1dd72fc3c7d1626e48aca6fcc9" translate="yes" xml:space="preserve">
          <source>Generic locking algorithms</source>
          <target state="translated">일반 잠금 알고리즘</target>
        </trans-unit>
        <trans-unit id="522f4aca708bf0b67f4969ccd2a81f0afbce9777" translate="yes" xml:space="preserve">
          <source>Generic mutex management</source>
          <target state="translated">일반 뮤텍스 관리</target>
        </trans-unit>
        <trans-unit id="bb5f7091dca0b61fa982fa58c2f04caba2c88133" translate="yes" xml:space="preserve">
          <source>Generic pathname format</source>
          <target state="translated">일반 경로 이름 형식</target>
        </trans-unit>
        <trans-unit id="5062b24e22ad40ee77724d279398f1dbf438838e" translate="yes" xml:space="preserve">
          <source>Get area</source>
          <target state="translated">지역을 얻으십시오</target>
        </trans-unit>
        <trans-unit id="f30e54b151b7e1d903f56be15b95cfc3a9e8869c" translate="yes" xml:space="preserve">
          <source>Gets and sets the exception mask of the stream. The exception mask determines the error states on occurrence of which the stream throws exception of type &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스트림의 예외 마스크를 가져오고 설정합니다. 예외 마스크는 스트림이 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;failure&lt;/a&gt;&lt;/code&gt; 유형의 예외를 발생시키는 오류 상태를 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="b970edd37ceef3acb34a7c5e361913bd8492e2aa" translate="yes" xml:space="preserve">
          <source>Gets and sets the underlying string.</source>
          <target state="translated">기본 문자열을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="332452f1980fa4e174e790babca85d5c6e588e9e" translate="yes" xml:space="preserve">
          <source>Gets the default memory resource pointer.</source>
          <target state="translated">기본 메모리 리소스 포인터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="499d742f096a087b00e3a25ac2c61ce6526047bb" translate="yes" xml:space="preserve">
          <source>Getting the result</source>
          <target state="translated">결과 얻기</target>
        </trans-unit>
        <trans-unit id="a31c54bbb19e0e2599a1d0ad74d19479e5b692ac" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;, performs O(log N) applications of the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 주어지면 , 술어 &lt;code&gt;p&lt;/code&gt; 의 O (log N) 적용을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="2de26a11901d553b8a58d6c3ba8e560899db14ac" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;},</source>
          <target state="translated">주어진 &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; },</target>
        </trans-unit>
        <trans-unit id="201a57a136c12310d1acc1180f1b02b9f2f6f001" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = last - first&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;N = last - first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3e5ecd385ba57ca31705c6a420eb24ffafacec4" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, dereferenceable iterators of type &lt;code&gt;It&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 주어지면 &lt;code&gt;It&lt;/code&gt; 유형의 역 참조 가능한 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="bd092018ae73c0887d7dc6c9b1bb5a5adc4b89b7" translate="yes" xml:space="preserve">
          <source>Given N = &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt;,</source>
          <target state="translated">주어진 N = &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a60f6d48405c975ae0935013623bdd24a66ebef7" translate="yes" xml:space="preserve">
          <source>Given a BinaryPredicate &lt;code&gt;bin_pred&lt;/code&gt; and a pair of iterators &lt;code&gt;iter1&lt;/code&gt; and &lt;code&gt;iter2&lt;/code&gt; or an iterator &lt;code&gt;iter&lt;/code&gt; and a value &lt;code&gt;value&lt;/code&gt;, the expression &lt;code&gt;bin_pred(*iter1, *iter2)&lt;/code&gt; or, respectively, &lt;code&gt;bin_pred(*iter, value)&lt;/code&gt;, must be &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually convertible&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">BinaryPredicate 주어진 &lt;code&gt;bin_pred&lt;/code&gt; 반복자 한 쌍 &lt;code&gt;iter1&lt;/code&gt; 및 &lt;code&gt;iter2&lt;/code&gt; 또는 반복자 &lt;code&gt;iter&lt;/code&gt; 및 값 &lt;code&gt;value&lt;/code&gt; 은 식 &lt;code&gt;bin_pred(*iter1, *iter2)&lt;/code&gt; 또는 각각 &lt;code&gt;bin_pred(*iter, value)&lt;/code&gt; 이어야 &lt;a href=&quot;../language/implicit_cast&quot;&gt;문맥 전환&lt;/a&gt; 에 &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa890934e1378f6d141dac2f7867c119b8ad1fa" translate="yes" xml:space="preserve">
          <source>Given a function parameter &lt;code&gt;P&lt;/code&gt; that depends on one or more type template parameters &lt;code&gt;T&lt;/code&gt;i, template template parameters &lt;code&gt;TT&lt;/code&gt;i, or non-type template parameters &lt;code&gt;I&lt;/code&gt;i, and the corresponding argument &lt;code&gt;A&lt;/code&gt;, deduction takes place if &lt;code&gt;P&lt;/code&gt; has one of the following forms:</source>
          <target state="translated">함수 매개 변수를 감안할 때 &lt;code&gt;P&lt;/code&gt; 하나 개 이상의 형 템플릿 매개 변수에 따라 달라 &lt;code&gt;T&lt;/code&gt; 난, 템플릿 템플릿 매개 변수가 &lt;code&gt;TT&lt;/code&gt; 난을, 또는 비 형 템플릿 매개 변수 &lt;code&gt;I&lt;/code&gt; 내가하고는 해당 인수 경우 공제가 발생 &lt;code&gt;P&lt;/code&gt; 는 다음과 같은 형태 중 하나가를 : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="849104a88d07876b31798d027eae5e4b5ac7a9c0" translate="yes" xml:space="preserve">
          <source>Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned.</source>
          <target state="translated">크기 공간의 버퍼에 대한 포인터 ptr이 주어지면, 바이트 수의 크기에 대해 지정된 정렬로 정렬 된 포인터를 리턴하고 정렬에 사용 된 바이트 수만큼 공간 인수를 줄입니다. 정렬 된 첫 번째 주소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1d1642375a13cf9d00a6f14be269e1b8dfaf5497" translate="yes" xml:space="preserve">
          <source>Given a set of types &lt;code&gt;Args...&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...&lt;/code&gt; meet the requirements for arguments to &lt;code&gt;ranges::swap&lt;/code&gt; above, &lt;code&gt;SwapT&lt;/code&gt; will satisfy &lt;code&gt;std::&lt;a href=&quot;../../concepts/invocable&quot;&gt;Invocable&lt;/a&gt;&amp;lt;const SwapT&amp;amp;, Args...&amp;gt;&lt;/code&gt;. Otherwise, no function call operator of &lt;code&gt;SwapT&lt;/code&gt; participates in overload resolution.</source>
          <target state="translated">유형의 집합을 감안할 때 &lt;code&gt;Args...&lt;/code&gt; 경우, &lt;code&gt;&lt;a href=&quot;../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...&lt;/code&gt; 인수에 대한 요구 사항을 충족 &lt;code&gt;ranges::swap&lt;/code&gt; 위를, &lt;code&gt;SwapT&lt;/code&gt; 가 만족 &lt;code&gt;std::&lt;a href=&quot;../../concepts/invocable&quot;&gt;Invocable&lt;/a&gt;&amp;lt;const SwapT&amp;amp;, Args...&amp;gt;&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;SwapT&lt;/code&gt; 의 함수 호출 연산자가 과부하 해결에 참여 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cd88ec801294426ab54d23bc136aca37fe96b8e0" translate="yes" xml:space="preserve">
          <source>Given a user-defined &lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&lt;/code&gt; for objects of type &lt;code&gt;T&lt;/code&gt;, implements the usual semantics of other comparison operators.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 객체에 대해 사용자 정의 &lt;code&gt;operator==&lt;/code&gt; 및 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 주어지면 다른 비교 연산자의 일반적인 의미를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9347968d88bdedbaad63962c44f19bc3e70fd1d7" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;map&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 의 인스턴스 &lt;code&gt;c&lt;/code&gt; 가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="c587de6b8b3e1339541445cfac7615e9dbb23ca9" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;multimap&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;multimap&lt;/code&gt; 의 인스턴스 &lt;code&gt;c&lt;/code&gt; 가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="a14568942f46c8464d02bc68bb11bb1b20d8f671" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;multiset&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;multiset&lt;/code&gt; 의 인스턴스 &lt;code&gt;c&lt;/code&gt; 가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="3e2459dd2b814290389adeffd53910165c623ff3" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;set&lt;/code&gt;:</source>
          <target state="translated">인스턴스 감안할 때 &lt;code&gt;c&lt;/code&gt; 의 &lt;code&gt;set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="881f1c518159f483a92d230aff08438c975cfc40" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_map&lt;/code&gt;:</source>
          <target state="translated">인스턴스 감안할 때 &lt;code&gt;c&lt;/code&gt; 의 &lt;code&gt;unordered_map&lt;/code&gt; 도 :</target>
        </trans-unit>
        <trans-unit id="fa31a301eaa86d94083d76755aeb6d15245d1d46" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_multimap&lt;/code&gt;:</source>
          <target state="translated">인스턴스 감안할 때 &lt;code&gt;c&lt;/code&gt; 의 &lt;code&gt;unordered_multimap&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f6d85ed3e34fe83d62419c16e466b796d53d7bae" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_multiset&lt;/code&gt;:</source>
          <target state="translated">인스턴스 감안할 때 &lt;code&gt;c&lt;/code&gt; 의 &lt;code&gt;unordered_multiset&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a229fa6402280d8d3988d3795c697a501535b4a0" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_set&lt;/code&gt;:</source>
          <target state="translated">인스턴스 감안할 때 &lt;code&gt;c&lt;/code&gt; 의 &lt;code&gt;unordered_set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="585b276223e3efe88a4cec484dd924b01d338788" translate="yes" xml:space="preserve">
          <source>Given an object &lt;code&gt;G&lt;/code&gt; obtained from an earlier call to &lt;code&gt;bind_front(f, args...)&lt;/code&gt;, when a glvalue &lt;code&gt;g&lt;/code&gt; designating &lt;code&gt;G&lt;/code&gt; is invoked in a function call expression &lt;code&gt;g(call_args...)&lt;/code&gt;, an invocation of the stored object takes place, as if by.</source>
          <target state="translated">오브젝트 주어 &lt;code&gt;G&lt;/code&gt; 로 이전 호출로부터 획득 &lt;code&gt;bind_front(f, args...)&lt;/code&gt; , 경우 glvalue &lt;code&gt;g&lt;/code&gt; 지정 단계 &lt;code&gt;G&lt;/code&gt; 되는 함수 호출 식으로 호출 &lt;code&gt;g(call_args...)&lt;/code&gt; , 저장된 객체의 호출이 발생, 마치 마치</target>
        </trans-unit>
        <trans-unit id="a88f34b4e5838dad793cf28d772a20e6a14e6fb1" translate="yes" xml:space="preserve">
          <source>Given an object &lt;code&gt;g&lt;/code&gt; obtained from an earlier call to &lt;code&gt;bind&lt;/code&gt;, when it is invoked in a function call expression &lt;code&gt;g(u1, u2, ... uM)&lt;/code&gt;, an invocation of the stored object takes place, as if by &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V1&amp;gt;(v1), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V2&amp;gt;(v2), ..., &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;VN&amp;gt;(vN))&lt;/code&gt;, where &lt;code&gt;fd&lt;/code&gt; is a value of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; the values and types of the bound arguments &lt;code&gt;v1, v2, ..., vN&lt;/code&gt; are determined as specified below.</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 에 대한 이전 호출에서 얻은 객체 &lt;code&gt;g&lt;/code&gt; 가 주어지면 함수 호출 표현식 &lt;code&gt;g(u1, u2, ... uM)&lt;/code&gt; 에서 호출 될 때 &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V1&amp;gt;(v1), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V2&amp;gt;(v2), ..., &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;VN&amp;gt;(vN))&lt;/code&gt; ()에 의해 저장된 객체가 호출됩니다 ( fd, &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;V1&amp;gt; (v1), &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;V2&amp;gt; (v2), ..., &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;VN&amp;gt; (vN)) 여기서 &lt;code&gt;fd&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; 유형의 값입니다. decay_t &amp;lt;F&amp;gt; 바운드 인수 &lt;code&gt;v1, v2, ..., vN&lt;/code&gt; 의 값과 유형 은 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="a8337adfa8cf3c8e162bcbe5e0229685e6eb60d8" translate="yes" xml:space="preserve">
          <source>Given the character sequence from the previous steps, if the first character equals &lt;code&gt;ct.widen('-')&lt;/code&gt;, calls &lt;code&gt;mp.neg_format()&lt;/code&gt; to obtain the formatting &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt;, otherwise calls &lt;code&gt;mp.pos_format()&lt;/code&gt;, where &lt;code&gt;mp&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; facet imbued in &lt;code&gt;str.getloc()&lt;/code&gt;.</source>
          <target state="translated">이전 단계의 문자 순서에서 첫 번째 문자가 &lt;code&gt;ct.widen('-')&lt;/code&gt; 과 &lt;code&gt;mp.neg_format()&lt;/code&gt; 을 호출 하여 형식 지정 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; 을 얻거나 그렇지 않으면 &lt;code&gt;mp.pos_format()&lt;/code&gt; 호출합니다 . 여기서 &lt;code&gt;mp&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; 패싯이 &lt;code&gt;str.getloc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66236ee54dcad384d354db9941193df8b20deffb" translate="yes" xml:space="preserve">
          <source>Given the set of candidate functions, constructed as described above, the next step of overload resolution is examining arguments and parameters to reduce the set to the set of</source>
          <target state="translated">위에서 설명한대로 구성된 후보 함수 세트를 고려할 때, 과부하 해결의 다음 단계는 인수 세트와 매개 변수를 검사하여 세트를 세트로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="c0aebd42da085f11a7898d7938dcfcf81f34f4ad" translate="yes" xml:space="preserve">
          <source>Given the starting value s, a list of strides i</source>
          <target state="translated">시작 값 s가 주어지면 보폭 목록 i</target>
        </trans-unit>
        <trans-unit id="93321ba8b5317191b60feb65e2cf919f7e2a81f1" translate="yes" xml:space="preserve">
          <source>Given.</source>
          <target state="translated">Given.</target>
        </trans-unit>
        <trans-unit id="c46a97000778eff7a9406aa7dac4bb058a740c4f" translate="yes" xml:space="preserve">
          <source>Gives well-defined results for reference types, void types, array types, and function types.</source>
          <target state="translated">참조 유형, void 유형, 배열 유형 및 함수 유형에 대해 잘 정의 된 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6c1092b384c391c235bf0f03a6b067bc9829d4dd" translate="yes" xml:space="preserve">
          <source>Global objects</source>
          <target state="translated">글로벌 객체</target>
        </trans-unit>
        <trans-unit id="8ecf59cbff938c3c09e7ac755a67fc60c8335206" translate="yes" xml:space="preserve">
          <source>Global replacements</source>
          <target state="translated">글로벌 교체</target>
        </trans-unit>
        <trans-unit id="6f85091c78ab312c0eeab087e50a90d21a6d8a82" translate="yes" xml:space="preserve">
          <source>Guaranteed copy elision through simplified &lt;a href=&quot;language/value_category&quot;&gt;value categories&lt;/a&gt;</source>
          <target state="translated">단순화 된 &lt;a href=&quot;language/value_category&quot;&gt;가치 범주를&lt;/a&gt; 통한 보장 된 복제 제거</target>
        </trans-unit>
        <trans-unit id="daf1a29d21388e553e2e351d8eb2ded2e9be0a7c" translate="yes" xml:space="preserve">
          <source>Guides (2-3) are needed because the &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; constructors for &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;s are made templates to avoid causing ambiguities in existing code, and those templates do not support class template argument deduction.</source>
          <target state="translated">때문에 가이드 (2-3) 필요한 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 에 대한 생성자 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 의 기존 코드에서 모호성을 일으키는 피하기 위해 템플릿을 만들어, 그 템플릿 클래스 템플릿 인수 공제를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab161f039e51e47e91c7fb547b04ada20d53b4a3" translate="yes" xml:space="preserve">
          <source>H. Sutter (1998) &lt;a href=&quot;http://www.gotw.ca/publications/mill02.htm&quot;&gt;&quot;What's In a Class? - The Interface Principle&quot;&lt;/a&gt; in C++ Report, 10(3)</source>
          <target state="translated">H. Sutter (1998) C ++ 보고서의 &lt;a href=&quot;http://www.gotw.ca/publications/mill02.htm&quot;&gt;&quot;클래스에 무엇이 있습니까?-인터페이스 원리&quot;&lt;/a&gt; , 10 (3)</target>
        </trans-unit>
        <trans-unit id="4d2fcf54f70e7b8f49c067c962c20ecc9c2156b7" translate="yes" xml:space="preserve">
          <source>H. Sutter (2000) &quot;Exceptional C++&quot;</source>
          <target state="translated">H. Sutter (2000) &quot;예외 C ++&quot;</target>
        </trans-unit>
        <trans-unit id="4dba1c99fa72599cb430192c2725ee29e7826d41" translate="yes" xml:space="preserve">
          <source>H. Sutter (2004) &lt;a href=&quot;http://www.drdobbs.com/when-and-how-to-use-exceptions/184401836&quot;&gt;&quot;When and How to Use Exceptions&quot;&lt;/a&gt; in Dr. Dobb's</source>
          <target state="translated">H. Sutter (2004) Dobb 박사의 &lt;a href=&quot;http://www.drdobbs.com/when-and-how-to-use-exceptions/184401836&quot;&gt;&quot;예외 사용시기 및 방법&quot;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3726a2cbec5aa86ee541f35ad869f9d462e3d65" translate="yes" xml:space="preserve">
          <source>H.Sutter, A. Alexandrescu (2004) &quot;C++ Coding Standards&quot; Item 73</source>
          <target state="translated">H.Sutter, A. Alexandrescu (2004) &quot;C ++ 코딩 표준&quot;항목 73</target>
        </trans-unit>
        <trans-unit id="3ee760973e367e7fcaab598e6a4779e4ff88cda5" translate="yes" xml:space="preserve">
          <source>H.Sutter, A. Alexandrescu (2004), &quot;C++ Coding Standards&quot;, Item 70</source>
          <target state="translated">H.Sutter, A. Alexandrescu (2004), &quot;C ++ 코딩 표준&quot;, 항목 70</target>
        </trans-unit>
        <trans-unit id="202043e89dc2aeb009dea78fe3ba6aecc90d862d" translate="yes" xml:space="preserve">
          <source>HANGZHOU NUMERAL ONE - HANGUL DOUBLE DOT TONE MARK</source>
          <target state="translated">HANGZHOU NUMERAL ONE-한글 이중 톤 표시</target>
        </trans-unit>
        <trans-unit id="498203d3437361cd8d2965b93c0eb3f8af84971a" translate="yes" xml:space="preserve">
          <source>HUGE_VALF, HUGE_VAL, HUGE_VALL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff054331f849fe26ab715fa596bf0d6c1b9b49c" translate="yes" xml:space="preserve">
          <source>HUGE_VALFHUGE_VALHUGE_VALL</source>
          <target state="translated">HUGE_VALFHUGE_VALHUGE_VALL</target>
        </trans-unit>
        <trans-unit id="b38181b2101d3ec22f60111fb7da75e6dc9d72e8" translate="yes" xml:space="preserve">
          <source>HUGE_VALL</source>
          <target state="translated">HUGE_VALL</target>
        </trans-unit>
        <trans-unit id="71eafe8cf5a2cb341c2f05d96f0f6422891ac1dd" translate="yes" xml:space="preserve">
          <source>Handling of exception specification violations (removed in C++17)</source>
          <target state="translated">예외 사양 위반 처리 (C ++ 17에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="5c4704b5df9665a78c88de802bae877af50465d2" translate="yes" xml:space="preserve">
          <source>Handling of failures in exception handling</source>
          <target state="translated">예외 처리에서 실패 처리</target>
        </trans-unit>
        <trans-unit id="ea1720079c69bfadf4103ddaa2b4cd30fc66377a" translate="yes" xml:space="preserve">
          <source>Handling of variable length argument lists</source>
          <target state="translated">가변 길이 인수 목록 처리</target>
        </trans-unit>
        <trans-unit id="0e8c641cc752e55897602b479a23cc749b022d01" translate="yes" xml:space="preserve">
          <source>Happens-before</source>
          <target state="translated">Happens-before</target>
        </trans-unit>
        <trans-unit id="94332d550f7e901bb03f8bebf16b0fe18a1b3ec5" translate="yes" xml:space="preserve">
          <source>Hard links typically cannot cross filesystem boundaries.</source>
          <target state="translated">하드 링크는 일반적으로 파일 시스템 경계를 넘을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c50832940f07dd15684fc07335b91ae9b50c034" translate="yes" xml:space="preserve">
          <source>Hardlinking to directories is typically restricted to the superuser.</source>
          <target state="translated">디렉토리에 대한 하드 링크는 일반적으로 수퍼 유저로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="b2bd7d3deca1dfde9d0e77745248dd3241e3fb2f" translate="yes" xml:space="preserve">
          <source>Hardware could require that an object to be referenced by an &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; have stricter alignment than other &lt;code&gt;T&lt;/code&gt; objects, and whether operations on an &lt;code&gt;atomic_ref&lt;/code&gt; are lock-free can depend on the alignment of the referenced object.</source>
          <target state="translated">하드웨어는 &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; 가 참조 할 오브젝트 가 다른 &lt;code&gt;T&lt;/code&gt; 오브젝트 보다 더 엄격한 정렬을 &lt;code&gt;atomic_ref&lt;/code&gt; 있으며 atomic_ref의 조작 이 잠금이 없는지 여부 는 참조 된 오브젝트의 정렬에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50278ca49d19fb7161c9b6156704c44ac84f382e" translate="yes" xml:space="preserve">
          <source>Has all non-static data members and bit-fields declared in the same class (either all in the derived or all in some base)</source>
          <target state="translated">정적이 아닌 데이터 멤버와 비트 필드가 모두 같은 클래스에서 선언되었습니다 (모두 파생되었거나 일부 기본에 모두).</target>
        </trans-unit>
        <trans-unit id="132088df73d03b2b991fee16006dc96529cc0d11" translate="yes" xml:space="preserve">
          <source>Has no base classes of the same type as the first non-static data member (see &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;)</source>
          <target state="translated">첫 번째 비 정적 데이터 멤버와 동일한 유형의 기본 클래스가 없습니다 ( &lt;a href=&quot;../language/ebo&quot;&gt;빈 기본 최적화&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3282080bc3a2066760485abf22d4931cd7cf3786" translate="yes" xml:space="preserve">
          <source>Has no non-static data members of reference type</source>
          <target state="translated">참조 유형의 비 정적 데이터 멤버가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4b0a2efb77a438bdd71e13e8a4b27ab2c2ef90e" translate="yes" xml:space="preserve">
          <source>Has no two (possibly indirect) base class subobjects of the same type</source>
          <target state="translated">동일한 유형의 기본 클래스 하위 오브젝트가 두 개 (간접적으로있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="e78a6eedfa1171855e11a7dd558ba1ee29f9b975" translate="yes" xml:space="preserve">
          <source>Has no virtual functions or virtual base classes</source>
          <target state="translated">가상 함수 또는 가상 기본 클래스가 없습니다</target>
        </trans-unit>
        <trans-unit id="07ad7632b84dfe67303c7a8f028a0886800e4870" translate="yes" xml:space="preserve">
          <source>Has one or more &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructors&lt;/a&gt;, all of which are either &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial&lt;/a&gt; or deleted, and at least one of which is not deleted.</source>
          <target state="translated">하나 이상의 &lt;a href=&quot;../language/default_constructor&quot;&gt;기본 생성자가 있습니다.이 생성자&lt;/a&gt; 는 모두 &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;단순&lt;/a&gt; 하거나 삭제되었으며 적어도 하나는 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="cc87e65725671e76b83dd75a39435552efd495a6" translate="yes" xml:space="preserve">
          <source>Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks.</source>
          <target state="translated">해시 함수는 프로그램의 단일 실행 내에서 동일한 입력에 대해 동일한 결과를 생성하는 데만 필요합니다. 이를 통해 충돌 서비스 거부 공격을 방지하는 솔트 해시가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cd57ebbbfb5b1908d66fa1e003e1ce14e29637e" translate="yes" xml:space="preserve">
          <source>Hash functions should not throw exceptions.</source>
          <target state="translated">해시 함수는 예외를 발생시키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7250b05d4111b3b36a49cda927210c8e3d368f6a" translate="yes" xml:space="preserve">
          <source>Hash policy</source>
          <target state="translated">해시 정책</target>
        </trans-unit>
        <trans-unit id="b807d317600ff4b338e846d561ee4e0b84f0360a" translate="yes" xml:space="preserve">
          <source>Hash support</source>
          <target state="translated">해시 지원</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="31341c6f0c7af677ffb8fadcb92038e8ac2b6193" translate="yes" xml:space="preserve">
          <source>Header</source>
          <target state="translated">Header</target>
        </trans-unit>
        <trans-unit id="f123fa3f00736262aa136563dd12c3a430fa1bf8" translate="yes" xml:space="preserve">
          <source>Header name preprocessing tokens are only formed within a &lt;code&gt;#include&lt;/code&gt; directive.</source>
          <target state="translated">헤더 이름 사전 처리 토큰은 &lt;code&gt;#include&lt;/code&gt; 지시문 내에서만 형성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a9eca02fd1369c5ba18c271ae9822e684c6bc3d" translate="yes" xml:space="preserve">
          <source>Headers required for a</source>
          <target state="translated">에 필요한 헤더</target>
        </trans-unit>
        <trans-unit id="8cd5e50ec159eebcf43e109ff007519db94c87f5" translate="yes" xml:space="preserve">
          <source>Heap allocation</source>
          <target state="translated">힙 할당</target>
        </trans-unit>
        <trans-unit id="adcf91c671cec8bebaf87ee37c2421ff5ebb56fd" translate="yes" xml:space="preserve">
          <source>Heap operations</source>
          <target state="translated">힙 작업</target>
        </trans-unit>
        <trans-unit id="43a1b94a7a6895d855248fbccdd91510cfbd3ac0" translate="yes" xml:space="preserve">
          <source>Helper Classes</source>
          <target state="translated">헬퍼 클래스</target>
        </trans-unit>
        <trans-unit id="035f96a8918459049a59bec0947605cd2a64fdef" translate="yes" xml:space="preserve">
          <source>Helper classes</source>
          <target state="translated">도우미 클래스</target>
        </trans-unit>
        <trans-unit id="7612db9ee91cb4487af96f647ff4f3cd2038be3a" translate="yes" xml:space="preserve">
          <source>Helper concepts</source>
          <target state="translated">헬퍼 개념</target>
        </trans-unit>
        <trans-unit id="058d2ea713d8ed40ef598fece850d00d28cef415" translate="yes" xml:space="preserve">
          <source>Helper functions &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; are often used to generate &lt;code&gt;std::reference_wrapper&lt;/code&gt; objects.</source>
          <target state="translated">도우미 함수 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; 는 종종 &lt;code&gt;std::reference_wrapper&lt;/code&gt; 객체 를 생성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9564c40bd71a52a2d2792a274dcd71ecab83247" translate="yes" xml:space="preserve">
          <source>Helper functions to control the format of input and output</source>
          <target state="translated">입력 및 출력 형식을 제어하는 ​​도우미 기능</target>
        </trans-unit>
        <trans-unit id="24355834da4c51ce8fa25dadf7ca038baf516e2f" translate="yes" xml:space="preserve">
          <source>Helper objects</source>
          <target state="translated">헬퍼 객체</target>
        </trans-unit>
        <trans-unit id="bbca939563aab0002ed11e9e60251643d9e2435c" translate="yes" xml:space="preserve">
          <source>Helper template</source>
          <target state="translated">도우미 템플릿</target>
        </trans-unit>
        <trans-unit id="26e4565205fc729962b9119b4035fad3d08ea499" translate="yes" xml:space="preserve">
          <source>Helper template alias</source>
          <target state="translated">헬퍼 템플릿 별명</target>
        </trans-unit>
        <trans-unit id="62f3bc8fedb9c00e4b9d3da1c58627fb9c932c3e" translate="yes" xml:space="preserve">
          <source>Helper templates</source>
          <target state="translated">도우미 템플릿</target>
        </trans-unit>
        <trans-unit id="58208feff4ae33c36603b46c3dceaa24f222cc8d" translate="yes" xml:space="preserve">
          <source>Helper types</source>
          <target state="translated">도우미 유형</target>
        </trans-unit>
        <trans-unit id="0b456005f09a660089e455709c3792d427e45f64" translate="yes" xml:space="preserve">
          <source>Helper variable template</source>
          <target state="translated">헬퍼 변수 템플릿</target>
        </trans-unit>
        <trans-unit id="777d2c2c6fac9bb59d841ec60aa0bce62ce73ffb" translate="yes" xml:space="preserve">
          <source>Helper variable templates</source>
          <target state="translated">도우미 변수 템플릿</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="7023d54552e06b34cfb338ed903ce5341dc89c1a" translate="yes" xml:space="preserve">
          <source>Here &amp;mu; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;mean&lt;/a&gt; and &amp;sigma; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; (</source>
          <target state="translated">여기서 &amp;mu;는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;평균&lt;/a&gt; 이고 &amp;sigma;는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;표준 편차입니다&lt;/a&gt; (</target>
        </trans-unit>
        <trans-unit id="de582de9c63661c059dbbb7442ed40762e356594" translate="yes" xml:space="preserve">
          <source>Here the sequence &lt;code&gt;= 0&lt;/code&gt; is known as pure-specifier, and appears either immediately after the declarator or after the optional virt-specifier (&lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;).</source>
          <target state="translated">여기서 시퀀스 &lt;code&gt;= 0&lt;/code&gt; 은 순수 지정자로 알려져 있으며 선언자 바로 뒤에 또는 선택적 virt 지정자 뒤에 &lt;a href=&quot;override&quot;&gt;있습니다&lt;/a&gt; ( override 또는 &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4d46b65d1ca1962518c48c70d9aa7c8452f90c5" translate="yes" xml:space="preserve">
          <source>Here, &lt;b&gt;insertion&lt;/b&gt; refers to any method which adds one or more elements to the container and &lt;b&gt;erasure&lt;/b&gt; refers to any method which removes one or more elements from the container.</source>
          <target state="translated">여기서, &lt;b&gt;삽입&lt;/b&gt; 은 컨테이너에 하나 이상의 요소를 추가하는 임의의 방법을 말하며 , &lt;b&gt;삭제&lt;/b&gt; 는 컨테이너에서 하나 이상의 요소를 제거하는 임의의 방법을 지칭한다.</target>
        </trans-unit>
        <trans-unit id="b19a132f13926967d1824a2efe39a0ee64381eb2" translate="yes" xml:space="preserve">
          <source>Hermite polynomials</source>
          <target state="translated">은자 다항식</target>
        </trans-unit>
        <trans-unit id="2dc4f9ad06827dbb0f947199ccb4b57ddbc18030" translate="yes" xml:space="preserve">
          <source>Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, or &lt;code&gt;wchar_t&lt;/code&gt;), the result is unspecified.</source>
          <target state="translated">16 진 이스케이프 시퀀스에는 길이 제한이 없으며 유효한 16 진수가 아닌 첫 번째 문자에서 종료됩니다. 단일 16 진 이스케이프 시퀀스로 표시되는 값이이 문자열 리터럴 ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; 또는 &lt;code&gt;wchar_t&lt;/code&gt; )에 사용 된 문자 유형으로 표시되는 값 범위에 맞지 않으면 결과가 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29f4576900e04b4bdfd8b4fe7f982605474c3863" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating literals</source>
          <target state="translated">16 진 부동 리터럴</target>
        </trans-unit>
        <trans-unit id="fcb2d1955da83c672014766fe096b6618bd4cc33" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point formatting ignores the stream precision specification, as required by the specification of &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">16 진 부동 소수점 형식화는 &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt; 스펙에 필요한대로 스트림 정밀도 스펙을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="903711dad7d075316de1f7c8c822711821173306" translate="yes" xml:space="preserve">
          <source>Higher level memory management utilities</source>
          <target state="translated">더 높은 수준의 메모리 관리 유틸리티</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="0201fd3572c6260109888327f99b40b98e8c814b" translate="yes" xml:space="preserve">
          <source>History of C++</source>
          <target state="translated">C ++의 역사</target>
        </trans-unit>
        <trans-unit id="9c025e64c93f51353b31decb167c0c14635a6990" translate="yes" xml:space="preserve">
          <source>Host is unreachable</source>
          <target state="translated">호스트에 연결할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="96e08c08807a48c02c8a25b2e222a3aa87859604" translate="yes" xml:space="preserve">
          <source>Hour, minute, second</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84d5827435e6eaee2628507f60c486924602e72" translate="yes" xml:space="preserve">
          <source>However if &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; no applications of the predicate are made.</source>
          <target state="translated">그러나 &lt;code&gt;ForwardIt1&lt;/code&gt; 및 &lt;code&gt;ForwardIt2&lt;/code&gt; 가 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; 의 요구 사항을 충족하는 경우 술어를 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06e6faa2b0497056bfffbc66aaba9ed450e5ff3a" translate="yes" xml:space="preserve">
          <source>However, all C++ compilers use &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;two's complement&lt;/a&gt; representation, and as of C++20, it is the only representation allowed by the standard, with the guaranteed range from -2N-1</source>
          <target state="translated">그러나 모든 C ++ 컴파일러는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;2의 보수&lt;/a&gt; 표현을 사용 하며 C ++ 20부터는 표준에서 허용되는 유일한 표현이며 -2N-1 범위를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="a5298c4b4732ec5cdb50753f0b7bff99ff4504e8" translate="yes" xml:space="preserve">
          <source>However, base class subobjects are not so constrained, and can be completely optimized out from the object layout:</source>
          <target state="translated">그러나 기본 클래스 하위 오브젝트는 그렇게 제한되지 않으며 오브젝트 레이아웃에서 완전히 최적화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0474028c83ae02e6c1719cbd200f19338eb23c2e" translate="yes" xml:space="preserve">
          <source>However, for non-&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;, the number of iterator increments is O(N).</source>
          <target state="translated">그러나 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt; 가 아닌 경우 반복기 증분 수는 O (N)입니다.</target>
        </trans-unit>
        <trans-unit id="a7074ce423985ae2c548c5817d3af2b722ab809a" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;BidirIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">그러나 &lt;code&gt;BidirIt&lt;/code&gt; 는 별도로 요건 충족 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator를&lt;/a&gt; 복잡성은 일정하다.</target>
        </trans-unit>
        <trans-unit id="c130fc889986236f01e7bd0a7491d9e506116625" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; then no applications of the predicate are made (size mismatch is detected without looking at any elements).</source>
          <target state="translated">그러나 &lt;code&gt;InputIt1&lt;/code&gt; 및 &lt;code&gt;InputIt2&lt;/code&gt; 가 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 및 &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; 의 요구 사항을 충족시키는 경우 술어를 적용하지 않습니다 (요소를 보지 않고 크기 불일치가 감지 됨).</target>
        </trans-unit>
        <trans-unit id="d4de2084e6a7ba7c4a9702f5d91188f9754f96a6" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">그러나 &lt;code&gt;InputIt&lt;/code&gt; 이 추가로 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 의 요구 사항을 충족시키는 경우 복잡성은 일정합니다.</target>
        </trans-unit>
        <trans-unit id="923af777ec78d98d0a47fdd5e9f0c732405eb150" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">그러나 &lt;code&gt;InputIt&lt;/code&gt; 또는 &lt;code&gt;ForwardIt&lt;/code&gt; 이 추가로 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 의 요구 사항을 충족시키는 경우 복잡성은 일정합니다.</target>
        </trans-unit>
        <trans-unit id="789aa7b03048a6d89e55166c2876d111a76287b2" translate="yes" xml:space="preserve">
          <source>However, if deduction succeeds for all parameters that participate in template argument deduction, and all template arguments that aren't deduced are explicitly specified or defaulted, then the remaining function parameters are compared with the corresponding function arguments. For each remaining parameter &lt;code&gt;P&lt;/code&gt; with a type that was non-dependent before substitution of any explicitly-specified template arguments, if the corresponding argument &lt;code&gt;A&lt;/code&gt; cannot be implicitly converted to &lt;code&gt;P&lt;/code&gt;, deduction fails.</source>
          <target state="translated">그러나 템플리트 인수 추론에 참여하는 모든 매개 변수에 대해 추론이 성공하고 추론되지 않은 모든 템플리트 인수가 명시 적으로 지정되거나 기본값 인 경우 나머지 함수 매개 변수는 해당 함수 인수와 비교됩니다. 명시 적으로 지정된 템플리트 인수를 대체하기 전에 종속적이지 않은 유형의 각 나머지 매개 변수 &lt;code&gt;P&lt;/code&gt; 에 대해 해당 인수 &lt;code&gt;A&lt;/code&gt; 를 내재적으로 &lt;code&gt;P&lt;/code&gt; 로 변환 할 수 없으면 공제가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d3ec3f026f2aba3bad033eb828adf9c63839692d" translate="yes" xml:space="preserve">
          <source>However, if the declaration uses &lt;a href=&quot;constexpr&quot;&gt;&lt;code&gt;constexpr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;(since C++17) specifier, the member must be declared to have complete type.</source>
          <target state="translated">그러나 선언에서 &lt;a href=&quot;constexpr&quot;&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt; (C ++ 17 이후) 지정자를 사용하는 경우 멤버는 완전한 유형을 갖도록 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="9217191a146bae3519a7a8c89cf7f10d4b0ff050" translate="yes" xml:space="preserve">
          <source>However, one implementation (libc++) is known to construct the &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; objects via two separate allocator &lt;code&gt;construct()&lt;/code&gt; calls, as arguably required by the standards as published, rather than emplacing a &lt;code&gt;value_type&lt;/code&gt; object.</source>
          <target state="translated">그러나 하나의 구현 (libc ++)은 &lt;code&gt;value_type&lt;/code&gt; 객체를 대체하는 것이 아니라 공개 된 표준에 의해 요구 &lt;code&gt;mapped_type&lt;/code&gt; 두 개의 개별 할당 자 &lt;code&gt;construct()&lt;/code&gt; 호출을 통해 &lt;code&gt;key_type&lt;/code&gt; 및 map_type 객체를 구성하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b2db98636723bfe7992740aadfd807719cd51f4" translate="yes" xml:space="preserve">
          <source>However, the attributes that appear after the declarator (in the syntax above), apply to the type of the function, not to the function itself.</source>
          <target state="translated">그러나 선언자 다음에 나타나는 속성 (위 구문에서)은 함수 자체가 아니라 함수 유형에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dff18122d5fc3679e0217a5ccca9f25c585e46ac" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05dc25b96449633c73f65c5aa0e18f13e31788b" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a249eb7c58320fe1bb3e19e6e61f7ae663bb92" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the imaginary component, with period &amp;pi;i, and has poles of the first order along the imaginary line, at coordinates (0, &amp;pi;(1/2 + n)). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">쌍곡 탄젠트는 복잡한 평원에 대한 분석 함수이며 가지 절단이 없습니다. 그것은 &amp;pi;i의 가상 성분에 대하여 주기적이며, 좌표 (0, &amp;pi; (1/2 + n))에서 가상의 선을 따라 1 차 극을 갖는다. 그러나 일반적인 부동 소수점 표현은 &amp;pi; / 2를 정확하게 표현할 수 없으므로 폴 오류가 발생하는 인수 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="6b58ece8e2eb85355e743b6e1a72cb6eb0c30006" translate="yes" xml:space="preserve">
          <source>I/O Manipulators</source>
          <target state="translated">I / O 조작기</target>
        </trans-unit>
        <trans-unit id="0676b814ab2a9d403059287e94b18b3f3ed5e63c" translate="yes" xml:space="preserve">
          <source>I/O error</source>
          <target state="translated">입출력 오류</target>
        </trans-unit>
        <trans-unit id="3fd6cee6dbc10d47db1d5e293da18cd3279cfd34" translate="yes" xml:space="preserve">
          <source>I/O format flags are obtained, as if by</source>
          <target state="translated">다음과 같이 I / O 형식 플래그를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="00a1147221fe28724b5d852d3cc11debd18ea881" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ Inline Assembly</source>
          <target state="translated">IBM XL C / C ++ 인라인 어셈블리</target>
        </trans-unit>
        <trans-unit id="97e6907b70a51197746c7a59244053494e95092c" translate="yes" xml:space="preserve">
          <source>ICE</source>
          <target state="translated">ICE</target>
        </trans-unit>
        <trans-unit id="2eb6372a578be72d248c4e343e8fc7a5d78b9a77" translate="yes" xml:space="preserve">
          <source>IEC 60559 recommends that &lt;code&gt;from&lt;/code&gt; is returned whenever &lt;code&gt;from==to&lt;/code&gt;. These functions return &lt;code&gt;to&lt;/code&gt; instead, which makes the behavior around zero consistent: &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; returns &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; returns &lt;code&gt;&amp;ndash;0.0&lt;/code&gt;.</source>
          <target state="translated">IEC 60559는 것이 좋습니다 &lt;code&gt;from&lt;/code&gt; 때마다 반환 &lt;code&gt;from==to&lt;/code&gt; . 이러한 함수 &lt;code&gt;to&lt;/code&gt; 대신 0으로 돌아가 동작을 일관되게 만듭니다. &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; 은 &lt;code&gt;+0.0&lt;/code&gt; 을 반환 하고 &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; 은 &lt;code&gt;&amp;ndash;0.0&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7d95a8939f16c4020223847e17e36720cebf2bb9" translate="yes" xml:space="preserve">
          <source>IEEE-754</source>
          <target state="translated">IEEE-754</target>
        </trans-unit>
        <trans-unit id="42d5d0fd7522f477e6c48c8cc234d0d9ab04dea9" translate="yes" xml:space="preserve">
          <source>ILP32</source>
          <target state="translated">ILP32</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="0c47ba7d876463299943e6f3c404bf80428ff851" translate="yes" xml:space="preserve">
          <source>INT8_CINT16_CINT32_CINT64_C</source>
          <target state="translated">INT8_CINT16_CINT32_CINT64_C</target>
        </trans-unit>
        <trans-unit id="9ea288f9428eb0424cc8044a5b63c8eac0420d9a" translate="yes" xml:space="preserve">
          <source>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</source>
          <target state="translated">INT8_MAXINT16_MAXINT32_MAXINT64_MAX</target>
        </trans-unit>
        <trans-unit id="bc5a628cd596773389eaaf98a83bf94ceac150f9" translate="yes" xml:space="preserve">
          <source>INT8_MININT16_MININT32_MININT64_MIN</source>
          <target state="translated">INT8_MININT16_MININT32_MININT64_MIN</target>
        </trans-unit>
        <trans-unit id="f9102afc9b1d8d90bfec23471f9597ad0cf050e9" translate="yes" xml:space="preserve">
          <source>INTMAX_C</source>
          <target state="translated">INTMAX_C</target>
        </trans-unit>
        <trans-unit id="aefed58e7c3b20f7462bf747350723518bd7f3f5" translate="yes" xml:space="preserve">
          <source>INTMAX_MAX</source>
          <target state="translated">INTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="a349d125102eeb5388d505c737ca6ccb840fc470" translate="yes" xml:space="preserve">
          <source>INTMAX_MIN</source>
          <target state="translated">INTMAX_MIN</target>
        </trans-unit>
        <trans-unit id="a8b82d9c693483b9795a47d286279f7fe077830a" translate="yes" xml:space="preserve">
          <source>INTPTR_MAX</source>
          <target state="translated">INTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="ea1e73a8ba1358e9d441c380ac5a64aadd6313f9" translate="yes" xml:space="preserve">
          <source>INTPTR_MIN</source>
          <target state="translated">INTPTR_MIN</target>
        </trans-unit>
        <trans-unit id="cb3002d9d4b8d1bb4ad6b3fb3f8ee0eb1cd9e1b9" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</source>
          <target state="translated">INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="5c002bd42be6d97da6ee9fd6a8de846f49b7760c" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</source>
          <target state="translated">INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</target>
        </trans-unit>
        <trans-unit id="81b4c2799073b036b71feb59eff38c668d0be8e4" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</source>
          <target state="translated">INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="303ab3b780f2f436597e803172a659d338cb695a" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</source>
          <target state="translated">INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</target>
        </trans-unit>
        <trans-unit id="47a57f6b8f5e7dac870d669f2d10489423c2c097" translate="yes" xml:space="preserve">
          <source>INVERTED UNDERTIE</source>
          <target state="translated">거꾸로 한 UNDERTIE</target>
        </trans-unit>
        <trans-unit id="6f332e7bc9fb4c964cc115b4bb4e0c9c81b651a9" translate="yes" xml:space="preserve">
          <source>INVOKE</source>
          <target state="translated">INVOKE</target>
        </trans-unit>
        <trans-unit id="bfa0e3fd8d2d6bf8a03a66ca3906291682906b88" translate="yes" xml:space="preserve">
          <source>INVOKE&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)</source>
          <target state="translated">인보 크 (f, t1, t2, ..., tN)</target>
        </trans-unit>
        <trans-unit id="381dd7d678830c863bcf610275aa82caf553b63a" translate="yes" xml:space="preserve">
          <source>INVOKE(f, t1, t2, ..., tN)</source>
          <target state="translated">인보 케 (f, t1, t2, ..., tN)</target>
        </trans-unit>
        <trans-unit id="b7d04a533ba2785a0158159ad98ad6ef6b754b06" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff375c325eb5a33dd2e39fc8434af17d533adb3" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c8d536c17446dc8d23f11cf08547ab6f0ceaef" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-based year</source>
          <target state="translated">ISO 8601 주별 연도</target>
        </trans-unit>
        <trans-unit id="660c1f28ee4e6a1155a4515d1d3d38f625034fe8" translate="yes" xml:space="preserve">
          <source>ISO C language standard requires that C compilers support the following three pragmas, and some C++ compiler vendors support them, to varying degrees, in their C++ frontends:</source>
          <target state="translated">ISO C 언어 표준에 따라 C 컴파일러는 다음 세 가지 pragma를 지원해야하며 일부 C ++ 컴파일러 공급 업체는 C ++ 프론트 엔드에서 다양한 정도를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f0de3ffcac31393cdc320a257a71c6856ecd9b41" translate="yes" xml:space="preserve">
          <source>Identical to the complexity of &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Container::emplace_back&lt;/code&gt; 의 복잡성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7c1a745105ff9b6c357cf50bdd91090ffef6ae55" translate="yes" xml:space="preserve">
          <source>Identifier removed</source>
          <target state="translated">식별자 제거</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
