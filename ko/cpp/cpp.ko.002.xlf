<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="a4e09b6b6e2a7b3a2ac2a06b04359abecdd52cc3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;Key&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (3-6). The ordering relation must establish total order.</source>
          <target state="translated">- 과부하 (3-6)를 사용하려면 &lt;code&gt;Key&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; 의 요구 사항을 충족해야합니다 . 주문 관계는 총 주문을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9361c83e3b358d5a3956e330cbd7371301b7ad7" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt1, OutputIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt1, OutputIt2&lt;/code&gt; 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="698247f9c442eed3999e5a308ab1fc6756e36992" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../../named_req/outputiterator&quot;&gt;LegacyOutputIterator을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55c36864300a0332162362f1e29021f2ab4046bf" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../named_req/outputiterator&quot;&gt;LegacyOutputIterator을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="deed4a8e960de7cf907cc39e9c0acfd7ac778bf6" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e86ead3f4d883e644468b1c73f514708a02964c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;. both &lt;code&gt;acc&lt;/code&gt; (the accumulated value) and the result of &lt;code&gt;val - acc&lt;/code&gt; or &lt;code&gt;op(val, acc)&lt;/code&gt;(until C++20)&lt;code&gt;val - std::move(acc)&lt;/code&gt; or &lt;code&gt;op(val, std::move(acc))&lt;/code&gt;(since C++20) must be writable to &lt;code&gt;OutputIt&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator을&lt;/a&gt; . 두 &lt;code&gt;acc&lt;/code&gt; (누적 값) 및 결과 &lt;code&gt;val - acc&lt;/code&gt; 또는 &lt;code&gt;op(val, acc)&lt;/code&gt; (20 ++ C까지) &lt;code&gt;val - std::move(acc)&lt;/code&gt; 또는 &lt;code&gt;op(val, std::move(acc))&lt;/code&gt; (C ++ 20부터) &lt;code&gt;OutputIt&lt;/code&gt; 에 쓰기 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="29da965fe354af11657ff5012d6cd7bb66771aa3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;PopulationIterator&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;PopulationIterator&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d962f474ba3dfaef590a955a0518ed4efa12212e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;PopulationIterator&lt;/code&gt;'s value type must be writeable to &lt;code&gt;out&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;PopulationIterator&lt;/code&gt; 의 값 유형에 쓰기 가능해야합니다 &lt;code&gt;out&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71157d30139e1a4b4b81eda084b08fc43eb764e1" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2f607ae40468ef5797894774fc38482f0178173" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98251c9b55e7f4abf11f37378ad898be6c5fadbe" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/valueswappable&quot;&gt;ValueSwappable&lt;/a&gt; and &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/valueswappable&quot;&gt;ValueSwappable&lt;/a&gt; 및 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eaa2c05a56bacd05704242d3bd6df30c4b6e4975" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;SampleIterator&lt;/code&gt; must also meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; if &lt;code&gt;PopulationIterator&lt;/code&gt; doesn't meet &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">- &lt;code&gt;SampleIterator&lt;/code&gt; 는 또한의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator을&lt;/a&gt; 경우 &lt;code&gt;PopulationIterator&lt;/code&gt; 이 맞지 않는 &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5cd603525645d89d81ecb0a97fa5b1104647059" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;SampleIterator&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;SampleIterator&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c4c58a4b3733fe1a63015c88ad95da66afcddc7" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;Searcher&lt;/code&gt; must meet the requirements of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;Searcher&lt;/code&gt; 의 요구 사항을 충족해야합니다 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;수색자를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49b4b6f9f94d3a83ae0da6bac2f0d41b3f5ec92f" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;State&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;State&lt;/code&gt; 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/destructible&quot;&gt;파괴 가능&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; 와 &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a348b317d61568eab4c548d7c228a34e3f64305" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (if init is provided)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T (if init is provided)&lt;/code&gt; 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible을&lt;/a&gt; . 모든 &lt;code&gt;binary_op(init, *first)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; 및 &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; T로 변환해야합니다</target>
        </trans-unit>
        <trans-unit id="c2a5020c510f0262502557c93ed89e0865951c7c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (if init is provided)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T (if init is provided)&lt;/code&gt; 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible을&lt;/a&gt; . 전 &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; 및 &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; T로 변환 가능해야</target>
        </trans-unit>
        <trans-unit id="7810d2997b36f05550f6cb1bf31a4fa633ff590f" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="905e21cacfad5c81bbffce9900de32849620bb35" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5106e515e150117a5ed081858723525bce75264" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="084180c1730ee9ff3511af3a7074aed52956ecd0" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T, Key&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; in order to use overloads (1-2).</source>
          <target state="translated">- 과부하를 사용 하려면 &lt;code&gt;T, Key&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; 의 요구 사항을 충족해야합니다 (1-2).</target>
        </trans-unit>
        <trans-unit id="fa70cdcafe4b0432bf8e4d5ec413cbc51a7d1ce1" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T2&lt;/code&gt; 는 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/swappable&quot;&gt;스왑을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff7f4cc18db9ac03597b82461300318cff643a4e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be a complete object type for overload (2)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 는 (2) 과부하에 대한 완전한 객체 유형이어야합니다</target>
        </trans-unit>
        <trans-unit id="22d8a29c2d428307356a96301dfe48b10dd001df" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be an arithmetic type other than &lt;code&gt;bool&lt;/code&gt; for overload (1)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 가 아닌 다른 연산 유형이어야 &lt;code&gt;bool&lt;/code&gt; (1) 과부하</target>
        </trans-unit>
        <trans-unit id="d4b7bba184604960afabdacbe04cef7c29efc646" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be constructible from &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Args...&lt;/code&gt; for overload (2)</source>
          <target state="translated">- 과부하 는 &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;Args...&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 를 구성 할 수 있어야합니다 (2).</target>
        </trans-unit>
        <trans-unit id="14bba7cc3b7a63c191dec2116f925714b85fb80e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be constructible from &lt;code&gt;Args...&lt;/code&gt; for overload (1)</source>
          <target state="translated">- 과부하 를 위해서는 &lt;code&gt;Args...&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 를 구성 할 수 있어야합니다 (1).</target>
        </trans-unit>
        <trans-unit id="cffb5df90bd109b7434a393187dfa1b30b748828" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- 과부하 (1)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7930781c7243e63a8390ec04eb0aa2c04af85f82" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (3).</source>
          <target state="translated">- 과부하 (3)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="471088387fa31e08d2a02da4c72d9a7a716ef167" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- 과부하 (1)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="73f5abb3110caba0a3cbfda038bb47a33bd701aa" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- 과부하 (1)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e73f59dbfdbaf5c4dcce09ce496037063fb9358b" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- 과부하 (2)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eb108a09e5c7c38be67b06f6c9bffab1dded20be" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- 과부하 (1)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="81a64d3f2c5aed9f2ea58d39ee0dc7d25692b198" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; in order to use overload (4,5).</source>
          <target state="translated">- 과부하 (4,5)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f777ee2027b95d030923b905f9b74c5248eea4b9" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; in order to use overloads (1-2).</source>
          <target state="translated">- 과부하 (1-2)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="96a89708385e36960066ed1cb1ad4a6270b18f9e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 는 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable로를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f655a15216004caebe0d4c1842ff1c7c85e72dc8" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (3-6). The ordering relation must establish total order.</source>
          <target state="translated">- 과부하 (3-6)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; 의 요구 사항을 충족해야합니다 . 주문 관계는 총 주문을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bc0ec3645431f4a729c83f7d0b332dedc67a6c2" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- 과부하 (2)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="83b8abfb3b109f24460367855ff84231d42acd86" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (4). required only if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; but not &lt;a href=&quot;../../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;. (until C++17)</source>
          <target state="translated">- 과부하 (4)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; 의 요구 사항을 충족해야합니다 . 경우에만 필요합니다 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; 하지만 &lt;a href=&quot;../../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; . (C ++ 17까지)</target>
        </trans-unit>
        <trans-unit id="46f5218ad771272834f2938c2efb000b08e092d8" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 는 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a30288177c8d2ae9070305e88321759803254602" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- 과부하 (2)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="df2dc067304b7bdd11cb64bd744da7390dc15e7c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- 과부하 (1)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c75ea7942181849fe154d4fe56f7d5a7e8e077b3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- 과부하 (2)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd12a83a8a21dd2faf8db14c717a62119dacb3df" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 는 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="955e988bcc8c424fa42f194f883da98cda7a48a2" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (4,5). (since C++17)</source>
          <target state="translated">- 과부하 (4,5)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; , &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; 요구 사항을 충족해야합니다 . (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="afbeaf062ea6fd0595970eeb503e2e6f5c5e7744" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 는 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 및 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab460245f5ca1cfa08f3d1ec2722e5c78976ffcb" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; in order to use overloads (3,4).</source>
          <target state="translated">- 과부하 (3,4)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7b670662fdaf16909ed9b4448468795dec02b564" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (1).</source>
          <target state="translated">- 과부하를 사용하려면 &lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; 의 요구 사항을 충족해야합니다 (1).</target>
        </trans-unit>
        <trans-unit id="a320cda4651b152682eb79c8e8e99ea2769e8c5e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (1,3).</source>
          <target state="translated">- 과부하 (1,3)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="48fe196760fc1f1946ea79d3075055f7b6aeaabd" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 는 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 및 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32c23e4f427e0609ed933c05aa132bcda1ee2718" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overloads (2,5). and the result of the expressions &lt;code&gt;binary_op1(init, binary_op2(*first1, *first2))&lt;/code&gt;, &lt;code&gt;binary_op1(binary_op2(*first1, *first2), init)&lt;/code&gt;, &lt;code&gt;binary_op1(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- 과부하 (2,5)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 의 요구 사항을 충족해야합니다 . 그리고 &lt;code&gt;binary_op1(init, binary_op2(*first1, *first2))&lt;/code&gt; , &lt;code&gt;binary_op1(binary_op2(*first1, *first2), init)&lt;/code&gt; , &lt;code&gt;binary_op1(init, init)&lt;/code&gt; 및 &lt;code&gt;binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2))&lt;/code&gt; 는 T로 변환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="b61c2e4c2acdbcf060f22b54d7687f0c61f22811" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overloads (3,6). and the result of the expressions &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(unary_op(*first), init)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- 과부하 (3,6)를 사용하려면 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 의 요구 사항을 충족해야합니다 . 그리고 &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; , &lt;code&gt;binary_op(unary_op(*first), init)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; 및 &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; T로 변환 가능해야합니다</target>
        </trans-unit>
        <trans-unit id="735f48ddde8598786438eb6c8a0e27a9a20e41fa" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 는 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible을&lt;/a&gt; . 모든 &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; 및 &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; 으로 변환 가능해야 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4830e7790cb0a3a97c614ec99dee4fd4f76bde82" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. Also, it must be possible to move-assign objects of type &lt;code&gt;U&lt;/code&gt; to objects of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 는 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible을&lt;/a&gt; . 또한 &lt;code&gt;U&lt;/code&gt; 유형의 오브젝트를 &lt;code&gt;T&lt;/code&gt; 유형의 오브젝트로 이동시킬 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="070995c3e11380f1a759c287d70004246a336f84" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. and &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(*first, init)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 는 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible을&lt;/a&gt; . 및 &lt;code&gt;binary_op(init, *first)&lt;/code&gt; , &lt;code&gt;binary_op(*first, init)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; 및 &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; 로 변환 될 수 있어야 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24ebbe51e0d271ce6d4ccbb7dd18d09cb13e0244" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. and &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 는 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible을&lt;/a&gt; . 및 &lt;code&gt;binary_op(init, *first)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; 및 &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; 로 변환 될 수 있어야 &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="240b36ac63aedc5650c0eebdca5e66141ce3bde5" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;U&amp;amp;&amp;amp;&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;U&amp;amp;&amp;amp;&lt;/code&gt; 로 변환해야합니다 &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b81d5e3c63c353df7206ad9ffec731b9d09453db" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryFunction2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;UnaryFunction2&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6014d7e4016480f38e962647d7142d9618786712" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryFunction&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. Does not have to be &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">- &lt;code&gt;UnaryFunction&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible을&lt;/a&gt; . &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible 일&lt;/a&gt; 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec2173dc69a67195292305ee0f463384bf04a493" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryPredicate&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/predicate&quot;&gt;Predicate&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;UnaryPredicate&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/predicate&quot;&gt;술어를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29292267e10038a5997139362f189f03885b9b0c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;W&lt;/code&gt; must be greater than zero, and no greater than &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;UIntType&amp;gt;::digits&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;W&lt;/code&gt; 는 0보다 커야하지 않으며, 더 이상해야한다 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;UIntType&amp;gt;::digits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f89b6a8131c4a3381b15946e9051f71792126a60" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;key_type&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;key_type&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="129d57481bdef249acefaffbce24cd66b9f3b73a" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;mapped_type&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;mapped_type&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; 와 &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="debd7c798d0035e7d613bf22525a497feb4eac68" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;std::decay_t&amp;lt;ValueType&amp;gt;&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;std::decay_t&amp;lt;ValueType&amp;gt;&lt;/code&gt; 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d5acc57403e947250368f57577287097a8c8cc4" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;std::is_constructible_v&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;, F&amp;gt;&lt;/code&gt; is required to be true</source>
          <target state="translated">- &lt;code&gt;std::is_constructible_v&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;, F&amp;gt;&lt;/code&gt; 필요한 것은 사실로</target>
        </trans-unit>
        <trans-unit id="3a79a46e3b7ff92c381844fb9a39002a4b0fa232" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;value_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt;. When the default allocator is used, this means that &lt;code&gt;key_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;code&gt;mapped_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;value_type&lt;/code&gt; 있어야합니다 &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible을&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; . 기본 할당자를 사용하는 경우 이는 &lt;code&gt;key_type&lt;/code&gt; 이 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 이고 &lt;code&gt;mapped_type&lt;/code&gt; 이 &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; 이어야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d97831a170788f8d67b47b8d93ff132ec0bb8c06" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;value_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(std::move(key)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt;. When the default allocator is used, this means that &lt;code&gt;key_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;code&gt;mapped_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;value_type&lt;/code&gt; 있어야합니다 &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible을&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(std::move(key)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; . 기본 할당자를 사용하는 경우 이는 &lt;code&gt;key_type&lt;/code&gt; 이 &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 이고 &lt;code&gt;mapped_type&lt;/code&gt; 이 &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; 이어야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="ff8015eb2b1855f53bb4336bf8d4411ac6c84c5b" translate="yes" xml:space="preserve">
          <source>-E</source>
          <target state="translated">-E</target>
        </trans-unit>
        <trans-unit id="47c47adf6da44571449c368a24b1dbbce9c4896b" translate="yes" xml:space="preserve">
          <source>-No increment, assignment, comparison, or indirection through valid instances of &lt;code&gt;ForwardIt&lt;/code&gt; may throw exceptions.</source>
          <target state="translated">&lt;code&gt;ForwardIt&lt;/code&gt; 유효한 인스턴스를 통한 증분, 할당, 비교 또는 간접적 인 예외는 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb831d16a34da446211de736f7a976a6da2d183b" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;BidirIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">-역 참조 된 &lt;code&gt;BidirIt&lt;/code&gt; 유형은 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 및 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fea212bdfb63511131a24166d6cf8c37f24a9977" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;ForwardIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">역 참조 된 &lt;code&gt;ForwardIt&lt;/code&gt; 의 유형은 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 및 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9070dc7500842363fa2c05017f765046615dbb95" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;ForwardIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">간접 참조의 -THE 유형 &lt;code&gt;ForwardIt&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6111d8d5184d2a92b766306033c8f746e15ff45" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">간접 참조의 -THE 유형 &lt;code&gt;InputIt&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5377d372d149a9da9efea14ca7295541e3b278" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;. if &lt;code&gt;InputIt&lt;/code&gt; does not satisfy &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">간접 참조의 -THE 유형 &lt;code&gt;InputIt&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable을&lt;/a&gt; . 경우 &lt;code&gt;InputIt&lt;/code&gt; 는 만족하지 않습니다 &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35d8052956297290de757a81ca77db43e329f302" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;. if neither &lt;code&gt;InputIt&lt;/code&gt; nor &lt;code&gt;OutputIt&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, or if &lt;code&gt;InputIt&lt;/code&gt; does not satisfy &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; and the value type of &lt;code&gt;InputIt&lt;/code&gt; differs from that of &lt;code&gt;OutputIt&lt;/code&gt;</source>
          <target state="translated">간접 참조의 -THE 유형 &lt;code&gt;InputIt&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)를&lt;/a&gt; . 어느 경우 &lt;code&gt;InputIt&lt;/code&gt; 도 &lt;code&gt;OutputIt&lt;/code&gt; 만족 &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; 경우 또는 &lt;code&gt;InputIt&lt;/code&gt; 는 만족하지 않는 &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; 및 값 유형 &lt;code&gt;InputIt&lt;/code&gt; 에서 의 상이 &lt;code&gt;OutputIt&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="1033b058712ba4bd32d56b528177040435614bb2" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">역 참조 된 &lt;code&gt;RandomIt&lt;/code&gt; 의 유형은 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 및 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="961a73e39e89cb3f2795f5bbf3cbdb9625270fdd" translate="yes" xml:space="preserve">
          <source>-The types of dereferenced &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;</source>
          <target state="translated">역 참조 된 &lt;code&gt;ForwardIt1&lt;/code&gt; 및 &lt;code&gt;ForwardIt2&lt;/code&gt; 의 유형은 교환 &lt;a href=&quot;../named_req/swappable&quot;&gt;가능&lt;/a&gt; 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee0fc4c6e8c36c2cdf1bf0caedd9cb01843102d7" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be &lt;code&gt;char&lt;/code&gt;</source>
          <target state="translated">의 년 - 값 유형 &lt;code&gt;InputIt&lt;/code&gt; 이 있어야합니다 &lt;code&gt;char&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="943fa25d062c8405568c4ff3a57ad45d9288723a" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be &lt;code&gt;char&lt;/code&gt; to use the overload (7))</source>
          <target state="translated">의 년 - 치형 &lt;code&gt;InputIt&lt;/code&gt; 이 있어야 &lt;code&gt;char&lt;/code&gt; 과부하를 사용하여 (7))</target>
        </trans-unit>
        <trans-unit id="386d13b86abcf4b9bca6e76ef852ed6b2ad732cb" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be one of the character types &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, (since C++20)&lt;code&gt;char16_t&lt;/code&gt; and &lt;code&gt;char32_t&lt;/code&gt; to use the overload (5))</source>
          <target state="translated">의 년 - 치형 &lt;code&gt;InputIt&lt;/code&gt; 은 문자 유형 중 하나 여야 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; 를 , &lt;code&gt;char8_t&lt;/code&gt; (C ++ 20 이후) &lt;code&gt;char16_t&lt;/code&gt; 및 &lt;code&gt;char32_t&lt;/code&gt; 가 과부하를 사용하는 (5))</target>
        </trans-unit>
        <trans-unit id="85af98cd8f2584c8a1bf3193d2a9453c4a0696b3" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be one of the encoded character types (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt; and &lt;code&gt;char32_t&lt;/code&gt;)</source>
          <target state="translated">의 년 - 치형 &lt;code&gt;InputIt&lt;/code&gt; 는 인코딩 된 문자 유형 (들 중 하나 여야 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; 를 , &lt;code&gt;char16_t&lt;/code&gt; 및 &lt;code&gt;char32_t&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="781c92c6f4232004d3a5ca088f526ac147d9db22" translate="yes" xml:space="preserve">
          <source>-a, where &lt;code&gt;b&lt;/code&gt; is the number of bits after promotion.</source>
          <target state="translated">-a, 여기서 &lt;code&gt;b&lt;/code&gt; 는 승격 후의 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="8a9cd7781044a79a622806d2c71e18d259189aab" translate="yes" xml:space="preserve">
          <source>-arg</source>
          <target state="translated">-arg</target>
        </trans-unit>
        <trans-unit id="16372868051b38c9793bfcfb1bab9865824a7cf8" translate="yes" xml:space="preserve">
          <source>-e-arg</source>
          <target state="translated">-e-arg</target>
        </trans-unit>
        <trans-unit id="36105b9bc31e91d70aff56af9dcd73894e1e5181" translate="yes" xml:space="preserve">
          <source>-e-iz</source>
          <target state="translated">-e-iz</target>
        </trans-unit>
        <trans-unit id="c6ea641826a7102b4cb61da3fbe5c8784257cca9" translate="yes" xml:space="preserve">
          <source>-e-z</source>
          <target state="translated">-e-z</target>
        </trans-unit>
        <trans-unit id="af8605005221d6158480c209167abfb0fad20613" translate="yes" xml:space="preserve">
          <source>-eiz</source>
          <target state="translated">-eiz</target>
        </trans-unit>
        <trans-unit id="6d358556e5f27dfee6bf6eb686c8965aebf7a90e" translate="yes" xml:space="preserve">
          <source>-th</source>
          <target state="translated">-th</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="9ab9cbe186911e3306c2471a07f4d73488a998c2" translate="yes" xml:space="preserve">
          <source>. (the value of M, determined by B, will be the value stored by one of these side effects).</source>
          <target state="translated">. (B에 의해 결정된 M의 값은 이러한 부작용 중 하나에 의해 저장된 값일 것이다).</target>
        </trans-unit>
        <trans-unit id="4c867670cfdf2b3d78e9b9332a77e4cae54f2ca7" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;*this&lt;/code&gt; is</source>
          <target state="translated">. &lt;code&gt;*this&lt;/code&gt; 있다</target>
        </trans-unit>
        <trans-unit id="858e49b217359edfde089556fcb3a0afd53dff9d" translate="yes" xml:space="preserve">
          <source>. A program that has two conflicting evaluations has a</source>
          <target state="translated">. 두 개의 상충되는 평가가있는 프로그램에는</target>
        </trans-unit>
        <trans-unit id="40cdcbb4fcaaf112141529b2f4aa097584351c61" translate="yes" xml:space="preserve">
          <source>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least</source>
          <target state="translated">. 일치하는 문자 외에 항상 널 문자를 저장합니다 (따라서 인수 배열에는 최소한 공간이 있어야합니다)</target>
        </trans-unit>
        <trans-unit id="6c8c268081021c567c19d1d620072b0fc7e50c0e" translate="yes" xml:space="preserve">
          <source>. Any use of a deleted function is ill-formed (the program will not compile). This includes calls, both explicit (with a function call operator) and implicit (a call to deleted overloaded operator, special member function, allocation function etc), constructing a pointer or pointer-to-member to a deleted function, and even the use of a deleted function in an unevaluated expression. However, implicit &lt;a href=&quot;definition#ODR-use&quot;&gt;ODR-use&lt;/a&gt; of a non-pure virtual member function that happens to be deleted is allowed.</source>
          <target state="translated">. 삭제 된 함수를 잘못 사용하면 프로그램이 컴파일되지 않습니다. 여기에는 명시 적 (함수 호출 연산자 사용) 및 암시 적 (삭제 된 오버로드 된 연산자 호출, 특수 멤버 함수, 할당 함수 등) 호출, 삭제 된 함수에 대한 포인터 또는 멤버 구성, 심지어 사용 평가되지 않은 표현식에서 삭제 된 함수 그러나 삭제되는 순수하지 않은 가상 멤버 함수의 암시 적 &lt;a href=&quot;definition#ODR-use&quot;&gt;ODR 사용&lt;/a&gt; 은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a1b0da760b32f18ba3fc29ea2034487403e7abfa" translate="yes" xml:space="preserve">
          <source>. Each byte in memory has a unique</source>
          <target state="translated">. 메모리의 각 바이트는 고유합니다</target>
        </trans-unit>
        <trans-unit id="5cddd5dfbecb9801772fe2221afa601ead96b52d" translate="yes" xml:space="preserve">
          <source>. Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint:</source>
          <target state="translated">. 각 개념은 술어이며 컴파일 타임에 평가되며 제약 조건으로 사용되는 템플릿 인터페이스의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="33dec4f9c20f32729da42cd862630e951a31724b" translate="yes" xml:space="preserve">
          <source>. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories:</source>
          <target state="translated">. 각 표현식에는 비 참조 유형이 있으며 각 표현식은 세 가지 기본 값 범주 중 하나에 정확히 속합니다.</target>
        </trans-unit>
        <trans-unit id="b705286f65efb9ff5d067129a4b52aa7b3a64f86" translate="yes" xml:space="preserve">
          <source>. Evaluation of the predicate must not have any side effects other than modification of non-volatile objects whose lifetimes begin and end within that evaluation; otherwise the behavior is undefined. If the evaluation of a predicate exits via an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">. 술어 평가에는 수명이 평가 내에서 시작되고 끝나는 비 휘발성 오브젝트 수정 이외의 부작용이 없어야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 술어 평가가 예외를 통해 종료되면 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bdbadb9492e1aaa923f351b943afd53e801082db" translate="yes" xml:space="preserve">
          <source>. For example, &lt;code&gt;&quot;ch&quot;&lt;/code&gt; in Czech follows &lt;code&gt;&quot;h&quot;&lt;/code&gt; and precedes &lt;code&gt;&quot;i&quot;&lt;/code&gt;, and &lt;code&gt;&quot;dzs&quot;&lt;/code&gt; in Hungarian follows &lt;code&gt;&quot;dz&quot;&lt;/code&gt; and precedes &lt;code&gt;&quot;g&quot;&lt;/code&gt;.</source>
          <target state="translated">. 예를 들어, &lt;code&gt;&quot;ch&quot;&lt;/code&gt; 체코 다음 &lt;code&gt;&quot;h&quot;&lt;/code&gt; 와 선행 &lt;code&gt;&quot;i&quot;&lt;/code&gt; , 및 &lt;code&gt;&quot;dzs&quot;&lt;/code&gt; 헝가리어 다음에 &lt;code&gt;&quot;dz&quot;&lt;/code&gt; 및 선행 &lt;code&gt;&quot;g&quot;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="d82d917e197ae463a094b584241f35f782aec1e5" translate="yes" xml:space="preserve">
          <source>. Four data models found wide acceptance:</source>
          <target state="translated">. 네 가지 데이터 모델이 폭넓게 수용되었습니다.</target>
        </trans-unit>
        <trans-unit id="a33d10a95384cd1ea7eb9f897911c689939d7a04" translate="yes" xml:space="preserve">
          <source>. If &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; the first substring is &lt;code&gt;[pos1, size())&lt;/code&gt;. Likewise, &lt;code&gt;count2 &amp;gt; str.size() - pos2&lt;/code&gt; the second substring is &lt;code&gt;[pos2, str.size())&lt;/code&gt;.</source>
          <target state="translated">. 경우 &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; 첫 번째 문자열이다 &lt;code&gt;[pos1, size())&lt;/code&gt; . 마찬가지로 &lt;code&gt;count2 &amp;gt; str.size() - pos2&lt;/code&gt; 두 번째 하위 문자열은 &lt;code&gt;[pos2, str.size())&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="60d4561c4e6d1d28e7602ab1f96bac585b6ca3dc" translate="yes" xml:space="preserve">
          <source>. If &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; the substring is &lt;code&gt;[pos1, size())&lt;/code&gt;.</source>
          <target state="translated">. 경우 &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; 문자열이다 &lt;code&gt;[pos1, size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b84f7bfde392ca0b0a0eb7c2fd807319d5660eee" translate="yes" xml:space="preserve">
          <source>. If a name has linkage, it refers to the same entity as the same name introduced by a declaration in another scope. If a variable, function, or another entity with the same name is declared in several scopes, but does not have sufficient linkage, then several instances of the entity are generated.</source>
          <target state="translated">. 이름에 연결이있는 경우 다른 범위의 선언에서 도입 한 동일한 이름과 동일한 엔터티를 나타냅니다. 변수, 함수 또는 동일한 이름을 가진 다른 엔티티가 여러 범위에서 선언되었지만 링크가 충분하지 않으면 엔티티의 여러 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="68e5fa4e1855031b0502b2881746502d1ee32b93" translate="yes" xml:space="preserve">
          <source>. If an expression of class type is used where an integral constant expression is expected, the expression is &lt;a href=&quot;implicit_cast&quot;&gt;contextually implicitly converted&lt;/a&gt; to an integral or unscoped enumeration type.</source>
          <target state="translated">. 적분 상수 표현식이 필요한 곳에 클래스 유형의 표현식이 사용되는 경우, 표현식은 &lt;a href=&quot;implicit_cast&quot;&gt;문맥 상 내재적으로&lt;/a&gt; 또는 범위가 지정되지 않은 열거 유형으로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="bf4f7b247734c7ffb151a9d2d9c1116744a29510" translate="yes" xml:space="preserve">
          <source>. If it is missing (and the first element other than the root name is a file name), then the path is</source>
          <target state="translated">. 누락 된 경우 (루트 이름 이외의 첫 번째 요소가 파일 이름 인 경우) 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3cdae61a821a7400c029c87da2e0ad8e4d9f82b6" translate="yes" xml:space="preserve">
          <source>. If new_type is (possibly &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;) &lt;code&gt;void&lt;/code&gt;, the expression is a void prvalue without a result object(since C++17).. This is the only cast expression that can create an &lt;a href=&quot;array#Array_rvalues&quot;&gt;array prvalue&lt;/a&gt;.</source>
          <target state="translated">. new_type이 ( &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt; ) &lt;code&gt;void&lt;/code&gt; 인 경우 표현식은 결과 객체가없는 void prvalue입니다 (C ++ 17 이후). 이것은 &lt;a href=&quot;array#Array_rvalues&quot;&gt;배열 prvalue를&lt;/a&gt; 작성할 수있는 유일한 캐스트 표현식입니다 .</target>
        </trans-unit>
        <trans-unit id="77e403132e08047bd2d3bc12dda0f4a4a2d76de8" translate="yes" xml:space="preserve">
          <source>. If the character specified by a universal character name isn't a member of the execution character set, the result is implementation-defined, but is guaranteed not to be a null (wide) character.</source>
          <target state="translated">. 범용 문자 이름으로 지정된 문자가 실행 문자 세트의 멤버가 아닌 경우 결과는 구현에 따라 정의되지만 널 (와이드) 문자는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2055582e493f90d8029965151d08ca03337c25b6" translate="yes" xml:space="preserve">
          <source>. In other words, class members in each of the three member access modes are positioned in memory in order of declaration.</source>
          <target state="translated">. 즉, 세 가지 멤버 액세스 모드 각각의 클래스 멤버는 선언 순서대로 메모리에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="a005fba78ddbc77b4129b39813eedeab22a6e135" translate="yes" xml:space="preserve">
          <source>. In other words, they results of comparing the pointers is the same as the result of comparing the indexes of the elements they point to.</source>
          <target state="translated">. 즉, 포인터를 비교 한 결과는 가리키는 요소의 인덱스를 비교 한 결과와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="99a683fd566c429de6986c8efcc6c2533955f501" translate="yes" xml:space="preserve">
          <source>. In particular, OS-dependent end-of-line indicators are replaced by newline characters. The</source>
          <target state="translated">. 특히 OS 종속 행 끝 표시기는 줄 바꾸기 문자로 대체됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="2971dbfe9f7c9e49e1f8b10e03b7c5f6dac51f41" translate="yes" xml:space="preserve">
          <source>. Invoking the</source>
          <target state="translated">. 호출</target>
        </trans-unit>
        <trans-unit id="c1128618249b42b2681dcf948859823c7068abc2" translate="yes" xml:space="preserve">
          <source>. It is a form of &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt;(since C++11) or &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt;(since C++20).</source>
          <target state="translated">. 그것의 형태 &lt;a href=&quot;list_initialization&quot;&gt;에서 초기화&lt;/a&gt; (11 ++ C 사람) 또는 &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; (사람은 C ++ 20).</target>
        </trans-unit>
        <trans-unit id="356bc0604f7850722bb7374a264e1089f903613e" translate="yes" xml:space="preserve">
          <source>. It is implementation-defined if &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../memory/allocator/allocate&quot;&gt;std::allocator::allocate&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../memory/get_temporary_buffer&quot;&gt;std::get_temporary_buffer&lt;/a&gt;&lt;/code&gt; support over-aligned types. &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocators&lt;/a&gt; instantiated with over-aligned types are allowed to fail to instantiate at compile time, to throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; at runtime, to silently ignore unsupported alignment requirement, or to handle them correctly.</source>
          <target state="translated">. &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../memory/allocator/allocate&quot;&gt;std::allocator::allocate&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../memory/get_temporary_buffer&quot;&gt;std::get_temporary_buffer&lt;/a&gt;&lt;/code&gt; 과도하게 정렬 된 유형을 지원하는 경우 구현 정의 입니다. 지나치게 정렬 된 유형으로 인스턴스화 된 &lt;a href=&quot;../named_req/allocator&quot;&gt;할당&lt;/a&gt; 자는 컴파일 타임에 인스턴스화하지 못하고 런타임에 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 을 던지 거나 지원되지 않는 정렬 요구 사항을 자동으로 무시하거나 올바르게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ab7e947eb2a49ecc9700edf726245f07e8311cd4" translate="yes" xml:space="preserve">
          <source>. It is often used to provide an empty body to a &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; or &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop. It can also be used to carry a label in the end of a compound statement.</source>
          <target state="translated">. 종종 &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; 또는 &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; 루프에 빈 바디를 제공하는 데 사용됩니다 . 또한 복합 명령문 끝에 레이블을 표시하는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab056dbc0ad8ac12b777fec3697e10f3e1de1b4a" translate="yes" xml:space="preserve">
          <source>. It takes no arguments, returns void, and performs no action other than initial evaluation of &lt;code&gt;E1&lt;/code&gt;. This is the only case where the left-hand operand of &lt;code&gt;operator.&lt;/code&gt; has non-class type. Allowing pseudo destructor call makes it possible to write code without having to know if a destructor exists for a given type.</source>
          <target state="translated">. 인수를 취하지 않고 void를 리턴하며 초기 &lt;code&gt;E1&lt;/code&gt; 평가 이외의 조치를 수행하지 않습니다 . 이것은 &lt;code&gt;operator.&lt;/code&gt; 의 왼쪽 피연산자 인 유일한 경우 입니다. 비 클래스 유형이 있습니다. 의사 소멸자 호출을 허용하면 지정된 유형에 대해 소멸자가 있는지 알 필요없이 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eef30cb415d5d8eda6e82cbfa234d079d7a185fc" translate="yes" xml:space="preserve">
          <source>. Language linkage encapsulates the set of requirements necessary to link with a module written in another programming language: &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;calling convention&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling&quot;&gt;name mangling&lt;/a&gt; algorithm, etc.</source>
          <target state="translated">. 언어 연결은 다른 프로그래밍 언어로 작성된 모듈과 연결하는 데 필요한 요구 사항 세트를 &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;호출&lt;/a&gt; 합니다 : 호출 규칙 , &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling&quot;&gt;이름 조작&lt;/a&gt; 알고리즘 등</target>
        </trans-unit>
        <trans-unit id="5e2ad60e04fa8a32b82dd4ab36a67fe1ce73577f" translate="yes" xml:space="preserve">
          <source>. Literal types are the types of &lt;a href=&quot;../language/constexpr&quot;&gt;constexpr variables&lt;/a&gt; and they can be constructed, manipulated, and returned from &lt;a href=&quot;../language/constexpr&quot;&gt;constexpr functions&lt;/a&gt;.</source>
          <target state="translated">. 리터럴 유형은 &lt;a href=&quot;../language/constexpr&quot;&gt;constexpr 변수&lt;/a&gt; 의 유형이며 &lt;a href=&quot;../language/constexpr&quot;&gt;constexpr 함수&lt;/a&gt; 에서 구성, 조작 및 리턴 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fd05493594e79b94be80621c509c9e737da3b3c" translate="yes" xml:space="preserve">
          <source>. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.</source>
          <target state="translated">. 이 스레드 전후에 현재 스레드에서 메모리 읽기 또는 쓰기를 다시 정렬 할 수 없습니다. 동일한 원자 변수를 해제하는 다른 스레드의 모든 쓰기는 수정 전에 볼 수 있으며 수정은 동일한 원자 변수를 얻는 다른 스레드에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4043f50b8367eb4e26dc8f87a7a82decf69d22dd" translate="yes" xml:space="preserve">
          <source>. Objects of this type are &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic objects&lt;/a&gt; and have runtime type information stored as part of the object representation, which may be queried with &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; and &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;. Virtual member functions participate in dynamic binding.</source>
          <target state="translated">. 이 유형의 &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;객체&lt;/a&gt; 는 다형성 객체 이며 객체 유형의 일부로 저장된 런타임 유형 정보를 가지며, 이는 &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; 및 &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt; 로 쿼리 할 수 ​​있습니다 . 가상 멤버 함수는 동적 바인딩에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="a9a5f93018a465748262f4fd922c0b10831e96e6" translate="yes" xml:space="preserve">
          <source>. Only then &lt;code&gt;std::feof&lt;/code&gt; returns non-zero.</source>
          <target state="translated">. 그런 다음 &lt;code&gt;std::feof&lt;/code&gt; 만 0이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a930ffd122a65a9f25ff1e6d9f9938ba49636a8" translate="yes" xml:space="preserve">
          <source>. Otherwise the pointer value is unchanged. Conversion of any pointer to pointer to void and back to pointer to the original (or more cv-qualified) type preserves its original value.</source>
          <target state="translated">. 그렇지 않으면 포인터 값이 변경되지 않습니다. 포인터를 void로 포인터로 변환하고 포인터를 원래 (또는 더 cv-qualified) 유형으로 다시 변환하면 원래 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f7c05934e49017a55ffd7f8db5e6be448b7c6949" translate="yes" xml:space="preserve">
          <source>. Otherwise, it is a</source>
          <target state="translated">. 그렇지 않으면, 그것은</target>
        </trans-unit>
        <trans-unit id="7d7ba1a37c76c90cfc05299fdb7d66d00cdf8dca" translate="yes" xml:space="preserve">
          <source>. Pointers to single objects are treated as pointers to arrays of one: &lt;code&gt;&amp;amp;obj+1&lt;/code&gt; compares greater than &lt;code&gt;&amp;amp;obj&lt;/code&gt;(since C++17)</source>
          <target state="translated">. 단일 객체에 대한 포인터는 하나의 배열에 대한 포인터로 취급됩니다. &lt;code&gt;&amp;amp;obj+1&lt;/code&gt; 은 &lt;code&gt;&amp;amp;obj&lt;/code&gt; 보다 큽니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="79ab5295086cf1cff1d188640da5082b74e6f20b" translate="yes" xml:space="preserve">
          <source>. Rounding to nearest representable value results in 0x1.999999999999a*2-4</source>
          <target state="translated">. 가장 가까운 표현 가능한 값으로 반올림하면 0x1.999999999999a * 2-4가됩니다.</target>
        </trans-unit>
        <trans-unit id="cbad6d2df5c35e8f921fcaa593ace506841238a7" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;virtual&quot;&gt;virtual functions&lt;/a&gt; and &lt;a href=&quot;abstract_class&quot;&gt;abstract classes&lt;/a&gt; for details.</source>
          <target state="translated">. 자세한 내용은 &lt;a href=&quot;virtual&quot;&gt;가상 함수&lt;/a&gt; 및 &lt;a href=&quot;abstract_class&quot;&gt;추상 클래스&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1ac736feb756a0662765565c1ddf5c54714fbc2b" translate="yes" xml:space="preserve">
          <source>. That is, the last iterator &lt;code&gt;it&lt;/code&gt; for which range &lt;code&gt;[first, it)&lt;/code&gt; is a</source>
          <target state="translated">. 즉, 마지막 반복자 인 &lt;code&gt;it&lt;/code&gt; 되는 범위 &lt;code&gt;[first, it)&lt;/code&gt; A는</target>
        </trans-unit>
        <trans-unit id="3cb17b45da870b7ec9baaca006a81afb0e3f404f" translate="yes" xml:space="preserve">
          <source>. The function then searches from that point on for the first character that</source>
          <target state="translated">. 그런 다음 함수는 그 시점부터 첫 번째 문자를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="2923ece4a0bd3546cfdc4f62787758294b263ad1" translate="yes" xml:space="preserve">
          <source>. The function then searches from that point on for the first wide character that</source>
          <target state="translated">. 그런 다음 함수는 그 시점부터 첫 번째 넓은 문자를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="61b94db5d99f08f0c694055d17375cb798fa4521" translate="yes" xml:space="preserve">
          <source>. The name</source>
          <target state="translated">. 이름</target>
        </trans-unit>
        <trans-unit id="85de12fb456918c6facd124a016788e336a84025" translate="yes" xml:space="preserve">
          <source>. The name can be referred to from all scopes in the current translation unit.</source>
          <target state="translated">. 현재 번역 단위의 모든 범위에서 이름을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f523417ea4918f53f6a9f95baf7712b34a86eae4" translate="yes" xml:space="preserve">
          <source>. The name can be referred to from the scopes in the other translation units. Variables and functions with external linkage also have &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt;, which makes it possible to link translation units written in different programming languages.</source>
          <target state="translated">. 다른 번역 단위의 범위에서 이름을 참조 할 수 있습니다. 외부 연결이있는 변수와 함수에는 &lt;a href=&quot;language_linkage&quot;&gt;언어 연결&lt;/a&gt; 이있어 다른 프로그래밍 언어로 작성된 번역 단위를 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a09d851d0a6928714c77e7574c1b6d959c9da3c" translate="yes" xml:space="preserve">
          <source>. The name can be referred to only from the scope it is in.</source>
          <target state="translated">. 이름은 해당 범위 내에서만 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b998270ca375ea5551f58f59298525f0cd92ff73" translate="yes" xml:space="preserve">
          <source>. The name of such a class only exists within the function scope, and is not accessible outside.</source>
          <target state="translated">. 이러한 클래스의 이름은 함수 범위 내에서만 존재하며 외부에서는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3aca28dc5685eb1627cfa6227295b744c7c32887" translate="yes" xml:space="preserve">
          <source>. The parent directory can be represented by the relative pathname &lt;code&gt;&quot;..&quot;&lt;/code&gt;.</source>
          <target state="translated">. 상위 디렉토리는 상대 경로 이름 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af5191925264a6f1222eec36d0e558d7114acafb" translate="yes" xml:space="preserve">
          <source>. The point of declaration of the name is immediately following the opening brace of the class definition.</source>
          <target state="translated">. 이름의 선언 지점은 클래스 정의의 여는 중괄호 바로 다음에옵니다.</target>
        </trans-unit>
        <trans-unit id="d73ce905c7e8caed5bcf6a0c8b9740ee594fd215" translate="yes" xml:space="preserve">
          <source>. The syntax of the type-id that names type T is exactly the syntax of a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a variable or function of type T, with the identifier omitted, except that</source>
          <target state="translated">. 유형 T를 명명하는 type-id의 구문은 변수를 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 하거나 유형 T의 함수를 선언 하는 구문이며 식별자는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="0cd178f8d5684f66e16a2083635f91143d51a96e" translate="yes" xml:space="preserve">
          <source>. These attributes may be applied to the function type in a function declaration:</source>
          <target state="translated">. 이 속성들은 함수 선언에서 함수 타입에 적용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e0b9b65bd5ab61cf0eba414c562588f6d88e9b46" translate="yes" xml:space="preserve">
          <source>. These include.</source>
          <target state="translated">. 여기에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9b6b8144c37744c4c78e2ca9a7775e22e96ba479" translate="yes" xml:space="preserve">
          <source>. This allows certain errors to be detected at the point of definition, rather than instantiation, and removes the requirement on the &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; disambiguators for dependent names, see below.</source>
          <target state="translated">. 이를 통해 인스턴스화가 아닌 정의 시점에서 특정 오류를 감지 할 수 있으며 종속 이름 에 대한 &lt;code&gt;typename&lt;/code&gt; 및 &lt;code&gt;template&lt;/code&gt; deambiguators에 대한 요구 사항이 제거 됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="844564e7cf1c47f7ea75e5e1bf440e8f19afffd2" translate="yes" xml:space="preserve">
          <source>. This allows more efficient implementation of &lt;code&gt;memory_order_acquire&lt;/code&gt; and &lt;code&gt;memory_order_release&lt;/code&gt; on some CPUs. It can produce surprising results when &lt;code&gt;memory_order_acquire&lt;/code&gt; and &lt;code&gt;memory_order_release&lt;/code&gt; are mixed with &lt;code&gt;memory_order_seq_cst&lt;/code&gt;.</source>
          <target state="translated">. 이를 통해 일부 CPU에서 &lt;code&gt;memory_order_acquire&lt;/code&gt; 및 &lt;code&gt;memory_order_release&lt;/code&gt; 를 보다 효율적으로 구현할 수 있습니다 . 때 놀라운 결과를 생성 할 수 있습니다 &lt;code&gt;memory_order_acquire&lt;/code&gt; 및 &lt;code&gt;memory_order_release&lt;/code&gt; 이 혼합되어 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6ccbd031282697c64122e93a678f06f4c45fff4" translate="yes" xml:space="preserve">
          <source>. This constructor does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. It is a trivial constructor if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">. &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 가 아니면이 생성자는 과부하 해결에 참여하지 않습니다 . &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 사소한 생성자 입니다 .</target>
        </trans-unit>
        <trans-unit id="732d85aea2bce0e040fb4cd1659b35c6d1bc3c4a" translate="yes" xml:space="preserve">
          <source>. This constructor is defined as deleted if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. It is a trivial constructor if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">. &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인경우이 생성자는 삭제 된 것으로 정의됩니다 . &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 사소한 생성자 입니다 .</target>
        </trans-unit>
        <trans-unit id="026c3d7e9a1fe8d5a967d61011a3beec752b15fd" translate="yes" xml:space="preserve">
          <source>. This distribution is used when estimating the</source>
          <target state="translated">. 이 분포는</target>
        </trans-unit>
        <trans-unit id="b316862e19fe4e350514297be86c991beb03e9ba" translate="yes" xml:space="preserve">
          <source>. This downcast is ill-formed if &lt;code&gt;B&lt;/code&gt; is ambiguous, inaccessible, or virtual base (or a base of a virtual base) of &lt;code&gt;D&lt;/code&gt;. Such &lt;code&gt;static_cast&lt;/code&gt; makes no runtime checks to ensure that the object's runtime type is actually &lt;code&gt;D&lt;/code&gt;, and may only be used safely if this precondition is guaranteed by other means, such as when implementing &lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism&quot;&gt;static polymorphism&lt;/a&gt;. Safe downcast may be done with &lt;a href=&quot;dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">. 이 경우 다운 캐스트가 잘못 형성되고 &lt;code&gt;B&lt;/code&gt; 가 의 모호한 액세스 또는 가상베이스 (또는 가상베이스 기재)이고 &lt;code&gt;D&lt;/code&gt; 는 . 이러한 &lt;code&gt;static_cast&lt;/code&gt; 는 객체의 런타임 유형이 실제로 &lt;code&gt;D&lt;/code&gt; 인지 확인하기 위해 런타임 검사를 수행하지 않으며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism&quot;&gt;정적 다형성을&lt;/a&gt; 구현할 때와 같은 다른 방법으로이 사전 조건이 보장되는 경우에만 안전하게 사용할 수 있습니다 . 안전한 다운 캐스트는 &lt;a href=&quot;dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt; 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b398f2ef722f3eef80e8eb8655b49aa4fcb0fcec" translate="yes" xml:space="preserve">
          <source>. This has the effect of removing the first (largest) element from the heap defined by the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">. 이는 &lt;code&gt;[first, last)&lt;/code&gt; 범위로 정의 된 힙에서 첫 번째 (가장 큰) 요소를 제거하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="23e6923e524364fd639ec62ad6d11c97fd7da1cf" translate="yes" xml:space="preserve">
          <source>. Two types are covariant if they satisfy all of the following requirements:</source>
          <target state="translated">. 두 가지 유형이 다음 요구 사항을 모두 충족하는 경우 공변량입니다.</target>
        </trans-unit>
        <trans-unit id="a9b5d1fd23fc7c5b4e6066615fc95994a5d113ca" translate="yes" xml:space="preserve">
          <source>. init-declarator-list is optional when declaring a named class/struct/union or a named enumeration</source>
          <target state="translated">. 명명 된 클래스 / struct / union 또는 명명 된 열거를 선언 할 때 init-declarator-list는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="e996ce306a5268a292c41ab30ab0b1d4f7db02b0" translate="yes" xml:space="preserve">
          <source>. where S is the sum of all weights.</source>
          <target state="translated">. 여기서 S는 모든 가중치의 합입니다.</target>
        </trans-unit>
        <trans-unit id="9786fc35b53afb831a179c1e43a95571ec28165a" translate="yes" xml:space="preserve">
          <source>.(since C++14)</source>
          <target state="translated">. (C ++ 14부터)</target>
        </trans-unit>
        <trans-unit id="6eae3a5b062c6d0d79f070c26e6d62486b40cb46" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>
        </trans-unit>
        <trans-unit id="faffb901ea5e603d448d5c651bc2ce1feb7ab56d" translate="yes" xml:space="preserve">
          <source>...Ints</source>
          <target state="translated">...Ints</target>
        </trans-unit>
        <trans-unit id="f29a917fc93c5cb1d8973220b883033399f48be1" translate="yes" xml:space="preserve">
          <source>...Ts</source>
          <target state="translated">...Ts</target>
        </trans-unit>
        <trans-unit id="e5f0d5fb385bca81078ad2a8707bbb8625cae265" translate="yes" xml:space="preserve">
          <source>...unless the parameter was expanded from a parameter pack</source>
          <target state="translated">... 매개 변수가 매개 변수 팩에서 확장되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="19f7ec135b5a79de79d6e7cc40d22413fe2af23d" translate="yes" xml:space="preserve">
          <source>/* implementation-defined */</source>
          <target state="translated">/ * 구현 정의 * /</target>
        </trans-unit>
        <trans-unit id="1ac5a1a38af02527751fd769c995e2b77199e5bf" translate="yes" xml:space="preserve">
          <source>/* non-specialized */</source>
          <target state="translated">/ * 특수화되지 않은 * /</target>
        </trans-unit>
        <trans-unit id="3555c1ad8bfe63c321204c247721dcd8a380c1e1" translate="yes" xml:space="preserve">
          <source>/* proxy */</source>
          <target state="translated">/ * 프록시 * /</target>
        </trans-unit>
        <trans-unit id="a269eaf502d0961ec13dad33647c50aef6df1f0b" translate="yes" xml:space="preserve">
          <source>/* unspecified */</source>
          <target state="translated">/ * 지정되지 않음 * /</target>
        </trans-unit>
        <trans-unit id="b6589fc6ab0dc82cf12099d1c2d40ab994e8410c" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>
        </trans-unit>
        <trans-unit id="3e51cc904afd7e59e35c80a6ddcf5cd8135109f4" translate="yes" xml:space="preserve">
          <source>0 and the rest are initialized iteratively, for i=1-n,...,-1, each X</source>
          <target state="translated">0과 나머지는 i = 1-n, ...,-1, 각 X에 대해 반복적으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="a234edb1dd1ba7b125c0f9eacd66f79c2ee53496" translate="yes" xml:space="preserve">
          <source>0 are zero, and if all other X</source>
          <target state="translated">0은 0이고 다른 모든 X이면</target>
        </trans-unit>
        <trans-unit id="cbdfc7a60b2a1b991b37673e31df028f7727131b" translate="yes" xml:space="preserve">
          <source>0 if for each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; is true</source>
          <target state="translated">0은 각각의 경우 &lt;code&gt;i&lt;/code&gt; 에서 &lt;code&gt;[0,n)&lt;/code&gt; , &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; 에 해당하는</target>
        </trans-unit>
        <trans-unit id="a385b6d4430ed31871595e71093124d9e635d5b3" translate="yes" xml:space="preserve">
          <source>0 with 2w-1</source>
          <target state="translated">2w-1의 0</target>
        </trans-unit>
        <trans-unit id="a0bd242d4e9823dde121cf81241caa8cb18b052a" translate="yes" xml:space="preserve">
          <source>0&amp;ndash;8</source>
          <target state="translated">0&amp;ndash;8</target>
        </trans-unit>
        <trans-unit id="a8df62a2404776e4a9f650425f66aba3e1c6eafd" translate="yes" xml:space="preserve">
          <source>0&amp;radic;1-k2</source>
          <target state="translated">0&amp;radic;1-k2</target>
        </trans-unit>
        <trans-unit id="b7a2c9b34dc2f4bec112398ca4ad2750f1912a7c" translate="yes" xml:space="preserve">
          <source>0,...,P</source>
          <target state="translated">0,...,P</target>
        </trans-unit>
        <trans-unit id="2bd186dce3970b7834f34e8ecaf95f82ee6270fe" translate="yes" xml:space="preserve">
          <source>0-qualified pointer to cv1</source>
          <target state="translated">cv1에 대한 0 규정 포인터</target>
        </trans-unit>
        <trans-unit id="fe1e007660532039a2e8edd7bcd53a0d3a1d5908" translate="yes" xml:space="preserve">
          <source>0-qualified pointer to cv2</source>
          <target state="translated">cv2에 대한 0 규정 포인터</target>
        </trans-unit>
        <trans-unit id="7abe581e3bbbaa5fdd179596f8a0dc409c4c5006" translate="yes" xml:space="preserve">
          <source>0tx-1</source>
          <target state="translated">0tx-1</target>
        </trans-unit>
        <trans-unit id="356a192b7913b04c54574d18c28d46e6395428ab" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>
        </trans-unit>
        <trans-unit id="6811f7a8f41e917fb0d97233a1567d9f7103a1c6" translate="yes" xml:space="preserve">
          <source>1 &amp;lt; K+1 = M &amp;le; N</source>
          <target state="translated">1 &amp;lt;K + 1 = M &amp;le; N</target>
        </trans-unit>
        <trans-unit id="f785463204330c080875e98ef24f1d1d3a6bddb4" translate="yes" xml:space="preserve">
          <source>1 &amp;minus; p if &lt;code&gt;b == false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b == false&lt;/code&gt; 경우 1-p</target>
        </trans-unit>
        <trans-unit id="1948bd668a05b546ade4e87c5dc1e44b28d6388d" translate="yes" xml:space="preserve">
          <source>1 if the first string is greater than the second (that is, follows the second in the collation order), -1 if the first string is less than the second (precedes the second in the collation order), zero if the two strings are equivalent.</source>
          <target state="translated">첫 번째 문자열이 두 번째 문자열보다 크면 (즉, 데이터 정렬 순서에서 두 번째 문자열을 따르는 경우) 1-첫 번째 문자열이 두 번째 문자열보다 작은 경우 -1 (콜 레이션 순서에서 두 번째보다 큼)-두 문자열이 동등한.</target>
        </trans-unit>
        <trans-unit id="47b4d0a7e4e7a4b47f71461424c2bc278b9cf1bf" translate="yes" xml:space="preserve">
          <source>1 op (... op (E</source>
          <target state="translated">1 op (... op (E</target>
        </trans-unit>
        <trans-unit id="86fb1242522651d4f696d9af9c16480d53bf7888" translate="yes" xml:space="preserve">
          <source>1 op E</source>
          <target state="translated">1 op E</target>
        </trans-unit>
        <trans-unit id="7856021a1dd28ad72b926a915ecc0aad8c99768f" translate="yes" xml:space="preserve">
          <source>1) (deprecated in C++17) If &lt;code&gt;F&lt;/code&gt; is a pointer to function or a pointer to member function, &lt;code&gt;result_type&lt;/code&gt; is the return type of &lt;code&gt;F&lt;/code&gt;. If &lt;code&gt;F&lt;/code&gt; is a class type with nested typedef &lt;code&gt;result_type&lt;/code&gt;, then &lt;code&gt;result_type&lt;/code&gt; is &lt;code&gt;F::result_type&lt;/code&gt;. Otherwise no &lt;code&gt;result_type&lt;/code&gt; is defined.</source>
          <target state="translated">1) (C ++ 17에서 더 이상 사용되지 않음) &lt;code&gt;F&lt;/code&gt; 가 함수에 대한 포인터 또는 멤버 함수에 대한 포인터 인 경우 &lt;code&gt;result_type&lt;/code&gt; 은 &lt;code&gt;F&lt;/code&gt; 의 반환 유형입니다 . 경우 &lt;code&gt;F&lt;/code&gt; 가 중첩 된 형식 정의를 가진 클래스 유형 &lt;code&gt;result_type&lt;/code&gt; 다음 &lt;code&gt;result_type&lt;/code&gt; 이다 &lt;code&gt;F::result_type&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;result_type&lt;/code&gt; 이 정의 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="83ea50c76bc44cdd9e4f766c317db5c2037df0e1" translate="yes" xml:space="preserve">
          <source>1) (none)</source>
          <target state="translated">1) (없음)</target>
        </trans-unit>
        <trans-unit id="86452ff75dcaffc8160d808ad365b65ef26fd4f4" translate="yes" xml:space="preserve">
          <source>1) (none)  2).</source>
          <target state="translated">1) (없음) 2).</target>
        </trans-unit>
        <trans-unit id="34a572a24e5822c38c6b3ac46db113826995572c" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;CT(lhs).count() == CT(rhs).count()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;CT(lhs).count() == CT(rhs).count()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6a38143daa43b50349154fefdef085b81c3ad69" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;U&amp;amp;&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;; &lt;code&gt;T&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; 경우 &lt;code&gt;U&amp;amp;&lt;/code&gt; &amp;lt;U&amp;gt; ; 그렇지 않으면 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="356a0877a891d6c9b60ef01cb7aaa9edeed1d1b1" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c22d94e3201de96926713e0b0f3b78a82a762b89" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other&lt;/code&gt; is a copy of &lt;code&gt;*this&lt;/code&gt; or has an identical name, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;other&lt;/code&gt; 의 복사본 &lt;code&gt;*this&lt;/code&gt; , 또는 동일한 이름이 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="d6622eb011b611aae7e8c72a24755377368ad3a3" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;std::get&amp;lt;i&amp;gt;(lhs) == std::get&amp;lt;i&amp;gt;(rhs)&lt;/code&gt; for all i in &lt;code&gt;[0, sizeof...(Types))&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. For two empty tuples returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;std::get&amp;lt;i&amp;gt;(lhs) == std::get&amp;lt;i&amp;gt;(rhs)&lt;/code&gt; 의 모든 난에 대한을 &lt;code&gt;[0, sizeof...(Types))&lt;/code&gt; , 그렇지 않은 경우 &lt;code&gt;false&lt;/code&gt; . 두 개의 빈 튜플의 &lt;code&gt;true&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="287dd3f95063f279870312b22bda28b87cd0fd6d" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if both &lt;code&gt;lhs.first == rhs.first&lt;/code&gt; and &lt;code&gt;lhs.second == rhs.second&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;lhs.first == rhs.first&lt;/code&gt; 및 &lt;code&gt;lhs.second == rhs.second&lt;/code&gt; 둘 다 &lt;code&gt;true&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="27a520d2b54a1f6646b3759539dd07d9fa75978e" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the distribution objects are equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) 배포 객체가 같으면 &lt;code&gt;true&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1288e43751f25875bb27e07c4078a20e14710ced" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the underlying &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; objects refer to the same type, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 경우 기본 &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 객체가 같은 형식을 참조, &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="104870c8f3088e1326f88bd2c5413aebdc6b362c" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the value of each bit in &lt;code&gt;*this&lt;/code&gt; equals the value of the corresponding bit in &lt;code&gt;rhs&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 각 비트의 값이있는 경우 &lt;code&gt;*this&lt;/code&gt; 에 대응하는 비트의 값과 동일 &lt;code&gt;rhs&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f71bf93702e13dec1d236cb721728da440f6f871" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;x.get() == y.get()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;x.get() == y.get()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d9b8b52ebd3e1a3a024e6ccd57926c21a2e926" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;​0​&lt;/code&gt; on success, non-zero otherwise.</source>
          <target state="translated">1) &lt;code&gt;​0​&lt;/code&gt; 성공 달리 비는 제로.</target>
        </trans-unit>
        <trans-unit id="6a3ae1acf7b6dec0a07ba83e824584db212e3584" translate="yes" xml:space="preserve">
          <source>1) A</source>
          <target state="translated">1) A</target>
        </trans-unit>
        <trans-unit id="20fbef856206918a3d8fb45dbe16ba8dc8b0ab41" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;std::chrono::sys_info&lt;/code&gt; structure &lt;code&gt;i&lt;/code&gt; containing the time zone information in effect for this time zone at the time point &lt;code&gt;tp&lt;/code&gt;. &lt;code&gt;tp&lt;/code&gt; will be in the range &lt;code&gt;[i.begin, i.end)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;std::chrono::sys_info&lt;/code&gt; 구조 &lt;code&gt;i&lt;/code&gt; 는 &lt;code&gt;tp&lt;/code&gt; 시점에서이 시간대에 유효한 시간대 정보를 포함합니다 . &lt;code&gt;tp&lt;/code&gt; 는 &lt;code&gt;[i.begin, i.end)&lt;/code&gt; 범위에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d73fc0de5837fb35ed94e495176a1ab53919bb87" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;sys_time&lt;/code&gt; representing the same point in time as the argument.</source>
          <target state="translated">1) 인수와 동일한 시점을 나타내는 &lt;code&gt;sys_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cabaf2c8fe8bd5c8a1098bdc266583d59f4973d7" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;utc_time&lt;/code&gt; representing the same point in time as the argument.</source>
          <target state="translated">1) 인수와 동일한 시점을 나타내는 &lt;code&gt;utc_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8328f6a84aae122e8939d2fec2a952c6930f619" translate="yes" xml:space="preserve">
          <source>1) A is</source>
          <target state="translated">1) A는</target>
        </trans-unit>
        <trans-unit id="5f587efae23c247ca28924e943089a9746064083" translate="yes" xml:space="preserve">
          <source>1) A is a modification, and B reads the value stored by A 2) A precedes B in the</source>
          <target state="translated">1) A는 수정이며 B는 A에 저장된 값을 읽습니다. 2) A는</target>
        </trans-unit>
        <trans-unit id="2dbafc39b4109d874a6ef2cacd1b60fbe55da610" translate="yes" xml:space="preserve">
          <source>1) A non-type template parameter pack with an optional name</source>
          <target state="translated">1) 선택적인 이름을 가진 유형이 아닌 템플릿 매개 변수 팩</target>
        </trans-unit>
        <trans-unit id="af46537a854cfc07af90d00edb90238c2ee6d6fd" translate="yes" xml:space="preserve">
          <source>1) A non-type template parameter with an optional name.</source>
          <target state="translated">1) 선택적인 이름을 가진 유형이 아닌 템플릿 매개 변수.</target>
        </trans-unit>
        <trans-unit id="4fe90bdfc834565a8e6349626f28a49a60b68cd0" translate="yes" xml:space="preserve">
          <source>1) A performs a</source>
          <target state="translated">1) A는</target>
        </trans-unit>
        <trans-unit id="fbc6fe14c6af3cf8418f033f94d06174d8d80ddb" translate="yes" xml:space="preserve">
          <source>1) A range adaptor that produces a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of no elements of a particular type.</source>
          <target state="translated">1) 특정 유형의 요소가없는 &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 를 생성하는 범위 어댑터 .</target>
        </trans-unit>
        <trans-unit id="0b9ae19f16d299250d9ad0aaf00550a8d1c41fae" translate="yes" xml:space="preserve">
          <source>1) A range adaptor that represents &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of an underlying sequence without the elements that fail to satisfy a predicate.</source>
          <target state="translated">1) 술어를 만족시키지 못하는 요소가없는 기본 순서의 &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 를 나타내는 범위 어댑터 .</target>
        </trans-unit>
        <trans-unit id="b9956ba464175b6f57bff8b5d832269a811d8115" translate="yes" xml:space="preserve">
          <source>1) A range factory that generates a sequence of elements by repeatedly incrementing an initial value. Can be both bounded and unbounded (infinite)</source>
          <target state="translated">1) 초기 값을 반복적으로 증가시켜 일련의 요소를 생성하는 범위 팩토리. 제한 및 제한 없음 (무한)</target>
        </trans-unit>
        <trans-unit id="fe4686de1a7da6422a6cf066a0610a3a80118153" translate="yes" xml:space="preserve">
          <source>1) A reference to the global &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; singleton.</source>
          <target state="translated">1) 글로벌 &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; 싱글 톤에 대한 참조 .</target>
        </trans-unit>
        <trans-unit id="82947af8d2369ef592a5e98e3d4604eb5d6af50d" translate="yes" xml:space="preserve">
          <source>1) A set of</source>
          <target state="translated">1) 세트</target>
        </trans-unit>
        <trans-unit id="a299040649a8f9f824a466b99cd8accb4069fd60" translate="yes" xml:space="preserve">
          <source>1) A span constructed with &lt;code&gt;{reinterpret_cast&amp;lt;const &lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&amp;gt;(s.data()), s.size_bytes()}&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;{reinterpret_cast&amp;lt;const &lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&amp;gt;(s.data()), s.size_bytes()}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="424f7940a81075143bd01c42816d096ec4cc3e70" translate="yes" xml:space="preserve">
          <source>1) A standard conversion sequence is always</source>
          <target state="translated">1) 표준 변환 순서는 항상</target>
        </trans-unit>
        <trans-unit id="a46604118cc45bb8f1fc823ba39ae021f0682a23" translate="yes" xml:space="preserve">
          <source>1) A string object holding a copy of this buffer's underlying character sequence.</source>
          <target state="translated">1)이 버퍼의 기본이되는 문자 순서의 카피를 보관 유지하는 캐릭터 라인 객체</target>
        </trans-unit>
        <trans-unit id="46e69a24f3f32aa99efec236d8f802a03d6df127" translate="yes" xml:space="preserve">
          <source>1) A template template parameter with an optional name.</source>
          <target state="translated">1) 선택적인 이름을 가진 템플릿 템플릿 매개 변수.</target>
        </trans-unit>
        <trans-unit id="bf76071f8f71da36945babb431edddf84fe21626" translate="yes" xml:space="preserve">
          <source>1) A type alias declaration introduces a name which can be used as a synonym for the type denoted by type-id. It does not introduce a new type and it cannot change the meaning of an existing type name. There is no difference between a type alias declaration and &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; declaration. This declaration may appear in block scope, class scope, or namespace scope.</source>
          <target state="translated">1) 타입 별칭 선언은 type-id로 표시된 타입의 동의어로 사용될 수있는 이름을 소개합니다. 새 유형을 도입하지 않으며 기존 유형 이름의 의미를 변경할 수 없습니다. 타입 별칭 선언과 &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 선언 에는 차이가 없습니다 . 이 선언은 블록 범위, 클래스 범위 또는 네임 스페이스 범위에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d39d12e44cd655e37c42c123e3133548497ae9ed" translate="yes" xml:space="preserve">
          <source>1) A type template parameter without a default.</source>
          <target state="translated">1) 기본값이없는 유형 템플리트 매개 변수.</target>
        </trans-unit>
        <trans-unit id="173390dfcc7b8ee2a586fea4454de09b477814e3" translate="yes" xml:space="preserve">
          <source>1) Accesses (reads and writes) to &lt;a href=&quot;cv&quot;&gt;volatile&lt;/a&gt; objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are &lt;a href=&quot;../atomic/memory_order&quot;&gt;not reordered&lt;/a&gt; with respect to other volatile accesses on the same thread.</source>
          <target state="translated">1) &lt;a href=&quot;cv&quot;&gt;휘발성&lt;/a&gt; 객체에 대한 액세스 (읽기 및 쓰기)는 발생하는 표현의 의미에 따라 엄격하게 발생합니다. 특히, 동일한 스레드에서 다른 휘발성 액세스와 관련하여 &lt;a href=&quot;../atomic/memory_order&quot;&gt;순서&lt;/a&gt; 가 변경 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="82db348ccd128d42ca8c97273d60b073e85127a3" translate="yes" xml:space="preserve">
          <source>1) All characters in &lt;a href=&quot;character_literal&quot;&gt;character literals&lt;/a&gt; and &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are converted from the source character set to the</source>
          <target state="translated">1) &lt;a href=&quot;character_literal&quot;&gt;문자 리터럴&lt;/a&gt; 및 &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴의&lt;/a&gt; 모든 문자 는 소스 문자 세트에서</target>
        </trans-unit>
        <trans-unit id="66bfdbf9083c74e9a1866c3e2e464fc8189cefc5" translate="yes" xml:space="preserve">
          <source>1) All memory allocations are performed by &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">1) 모든 메모리 할당이 수행된다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="048a26efa0caafdd751840d3dafcd66eba62dbea" translate="yes" xml:space="preserve">
          <source>1) Amortized constant</source>
          <target state="translated">1) 상각 상수</target>
        </trans-unit>
        <trans-unit id="5981b7305017c9545a89a5a35fe66de383130acf" translate="yes" xml:space="preserve">
          <source>1) An expression of integral, enumeration, pointer, or pointer-to-member type can be converted to its own type. The resulting value is the same as the value of &lt;code&gt;expression&lt;/code&gt;. (since C++11)</source>
          <target state="translated">1) 정수, 열거 형, 포인터 또는 포인터-투-멤버 유형의 표현은 자체 유형으로 변환 될 수 있습니다. 결과 값은 &lt;code&gt;expression&lt;/code&gt; 값과 같습니다 . (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="95cffb88bccbe314e1530157850332433d961b24" translate="yes" xml:space="preserve">
          <source>1) An implementation-defined type that holds a reference to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 에 대한 참조를 보유한 구현 정의 유형</target>
        </trans-unit>
        <trans-unit id="66c9b9f664df38161f10437106d4643e64c7e947" translate="yes" xml:space="preserve">
          <source>1) An object of class &lt;code&gt;any&lt;/code&gt; stores an instance of any type that satisfies the constructor requirements or is empty, and this is referred to as the</source>
          <target state="translated">클래스 1) 개체 &lt;code&gt;any&lt;/code&gt; 점포 임의의 타입의 인스턴스를 만족 생성자 조건 또는 비어 있고 이것은이라</target>
        </trans-unit>
        <trans-unit id="61dc882dd7d34d7d4ad75d6cb735240681e1867e" translate="yes" xml:space="preserve">
          <source>1) Analyzes generic range &lt;code&gt;[first,last)&lt;/code&gt;. Match results are returned in &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1) 일반 범위를 분석합니다 &lt;code&gt;[first,last)&lt;/code&gt; . 일치 결과는 &lt;code&gt;m&lt;/code&gt; 으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="80ba3076eb89d7a3ef079f9e8618c645e77976f7" translate="yes" xml:space="preserve">
          <source>1) Appends &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt;</source>
          <target state="translated">1)에 추가 &lt;code&gt;count&lt;/code&gt; 캐릭터의 복사본 &lt;code&gt;ch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f4fd2232e22aac2b19529e6e3b82510ab23c6ef" translate="yes" xml:space="preserve">
          <source>1) Applies the given function object &lt;code&gt;f&lt;/code&gt; to the result of dereferencing every iterator in the range &lt;code&gt;[first, first + n)&lt;/code&gt;, in order.</source>
          <target state="translated">1) 주어진 함수 객체 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;[first, first + n)&lt;/code&gt; 범위의 모든 반복자를 역 참조한 결과 에 순서대로 적용합니다.</target>
        </trans-unit>
        <trans-unit id="9326d78a127c522e3d8f1f7afedde286e2d81452" translate="yes" xml:space="preserve">
          <source>1) Applies the given function object &lt;code&gt;f&lt;/code&gt; to the result of dereferencing every iterator in the range &lt;code&gt;[first, last)&lt;/code&gt;, in order.</source>
          <target state="translated">1) 지정된 함수 객체 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 모든 반복자를 역 참조한 결과 에 순서대로 적용합니다.</target>
        </trans-unit>
        <trans-unit id="a269e932f278e6dc2ae1bfe911e2855a58c5ae13" translate="yes" xml:space="preserve">
          <source>1) Applies the language specification string-literal to all function types, function names with external linkage and variables with external linkage declared in declaration-seq.</source>
          <target state="translated">1) 언어 사양 문자열 리터럴을 모든 함수 유형, 외부 링크가있는 함수 이름 및 declaration-seq에 선언 된 외부 링크가있는 변수에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="0f9581ab834f137fbae8882fe84416428e32951d" translate="yes" xml:space="preserve">
          <source>1) Applies the offset &lt;code&gt;d&lt;/code&gt; to &lt;code&gt;pt&lt;/code&gt;. Effectively, &lt;code&gt;d&lt;/code&gt; is added to the internally stored duration &lt;code&gt;d_&lt;/code&gt; as &lt;code&gt;d_ += d&lt;/code&gt;.</source>
          <target state="translated">1) 오프셋 &lt;code&gt;d&lt;/code&gt; 를 &lt;code&gt;pt&lt;/code&gt; 에 적용합니다 . 효과적으로 &lt;code&gt;d&lt;/code&gt; 는 내부 저장 기간 &lt;code&gt;d_&lt;/code&gt; 에 &lt;code&gt;d_ += d&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="bd44368f1ec313c9be1e54cec6967210632f57be" translate="yes" xml:space="preserve">
          <source>1) Applies to a statement to allow the compiler to optimize for the case where paths of execution including that statement are more likely than any alternative path of execution that does not include such a statement.</source>
          <target state="translated">1) 해당 명령문을 포함하는 다른 실행 경로보다 해당 명령문을 포함한 실행 경로가 더 가능성이 높은 경우에 컴파일러가 최적화하도록 명령문에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="8f5ccf9c295ab95bc3305d17a3414892b4f79ae1" translate="yes" xml:space="preserve">
          <source>1) As a part of class member access expression, in which the class either has this member or is derived from a class that has this member, including the implicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; member access expressions that appear when a non-static member name is used in any of the contexts where &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; is allowed (inside member function bodies, in member initializer lists, in the in-class default member initializers).</source>
          <target state="translated">1) 클래스 멤버 액세스 표현식의 일부로, 클래스에이 멤버가 있거나이 멤버가있는 클래스에서 파생됩니다 ( 비 정적 멤버 이름이 사용될 때 표시 되는 내재적 &lt;code&gt;this-&amp;gt;&lt;/code&gt; 멤버 액세스 표현식 포함). &lt;a href=&quot;this&quot;&gt;이것이&lt;/a&gt; 허용 되는 모든 컨텍스트에서 (멤버 이니셜 라이저 목록의 클래스 내 기본 멤버 이니셜 라이저의 멤버 함수 본문 내부).</target>
        </trans-unit>
        <trans-unit id="0cc54ba39b78a1ff9452057d5e234e2f1c5cc09c" translate="yes" xml:space="preserve">
          <source>1) As the comma may be used in the current locale as decimal separator, the output may be ambiguous. This can be solved with &lt;code&gt;&lt;a href=&quot;../../io/manip/showpoint&quot;&gt;std::showpoint&lt;/a&gt;&lt;/code&gt; which forces the decimal separator to be visible.</source>
          <target state="translated">1) 현재 로케일에서 쉼표를 소수 구분 기호로 사용할 수 있으므로 출력이 모호 할 수 있습니다. 이것은 &lt;code&gt;&lt;a href=&quot;../../io/manip/showpoint&quot;&gt;std::showpoint&lt;/a&gt;&lt;/code&gt; 로 해결할 수 있으며 , 소수점 구분 기호를 강제로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="bf4f5eebb3756e5992406e2db6b3544a4860b1b1" translate="yes" xml:space="preserve">
          <source>1) Assigns &lt;code&gt;value&lt;/code&gt; to all of the elements.</source>
          <target state="translated">1) 모든 요소에 &lt;code&gt;value&lt;/code&gt; 을 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="0471cc16b46b1f8592b99a5def70ecd023e5db86" translate="yes" xml:space="preserve">
          <source>1) Assigns &lt;code&gt;x&lt;/code&gt; to the real part of the complex number. Imaginary part is set to zero.</source>
          <target state="translated">1) 복소수의 실수 부에 &lt;code&gt;x&lt;/code&gt; 를 대입 합니다. 허수 부는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bd74c1606493d2cb5c5263fcb597f13362ee0e84" translate="yes" xml:space="preserve">
          <source>1) Assigns a copy of</source>
          <target state="translated">1) 사본을 할당</target>
        </trans-unit>
        <trans-unit id="14686248fd4c999e4263d1cbae14e46f33834fac" translate="yes" xml:space="preserve">
          <source>1) Assigns by copying the state of &lt;code&gt;rhs&lt;/code&gt;, as if by &lt;code&gt;any(rhs).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1) 마치 &lt;code&gt;any(rhs).swap(*this)&lt;/code&gt; 처럼 &lt;code&gt;rhs&lt;/code&gt; 상태를 복사하여 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="79f8283f561eb803af10bf64d307d128f5f83943" translate="yes" xml:space="preserve">
          <source>1) Assigns character &lt;code&gt;a&lt;/code&gt; to character &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">1) 문자 &lt;code&gt;a&lt;/code&gt; 를 문자 &lt;code&gt;r&lt;/code&gt; 에 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="b50adfd66ed3872fa645e5d68c15f0490c3528ad" translate="yes" xml:space="preserve">
          <source>1) Assigns each element in range &lt;code&gt;[first, last)&lt;/code&gt; a value generated by the given function object &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">1) 지정된 함수 객체 &lt;code&gt;g&lt;/code&gt; 에 의해 생성 된 값을 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 각 요소에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="27023b4931499f367feb0a7ac32948b060a43b0d" translate="yes" xml:space="preserve">
          <source>1) Assigns the contents of &lt;code&gt;other&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;flags&quot;&gt;flags()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; are equivalent to the values of &lt;code&gt;other.flags()&lt;/code&gt; and &lt;code&gt;other.mark_count()&lt;/code&gt; after the call.</source>
          <target state="translated">1) &lt;code&gt;other&lt;/code&gt; 의 내용을 할당합니다 . &lt;code&gt;&lt;a href=&quot;flags&quot;&gt;flags()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; 는 호출 후 &lt;code&gt;other.flags()&lt;/code&gt; 및 &lt;code&gt;other.mark_count()&lt;/code&gt; 의 값 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3cb923639f2556c1a0b92d6585fc6bae83d4f775" translate="yes" xml:space="preserve">
          <source>1) Assigns the given &lt;code&gt;value&lt;/code&gt; to the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">1) 지정된 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소에 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="cc010e5348cf35fe3386539e2bcb8ef2deb9b2f0" translate="yes" xml:space="preserve">
          <source>1) Assigns the given &lt;code&gt;value&lt;/code&gt; to the first &lt;code&gt;count&lt;/code&gt; elements in the range beginning at &lt;code&gt;first&lt;/code&gt; if &lt;code&gt;count &amp;gt; 0&lt;/code&gt;. Does nothing otherwise.</source>
          <target state="translated">1) 할당 주어진 &lt;code&gt;value&lt;/code&gt; 첫번째 행 &lt;code&gt;count&lt;/code&gt; 에서 시작 범위 요소 &lt;code&gt;first&lt;/code&gt; 경우 &lt;code&gt;count &amp;gt; 0&lt;/code&gt; . 다른 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="44657b2873420948c5a550c8cea126cd3bcf8a02" translate="yes" xml:space="preserve">
          <source>1) Assigns the pathname identified by the detected-format string &lt;code&gt;source&lt;/code&gt;, which is left in valid, but unspecified state.</source>
          <target state="translated">1) 감지 된 형식 문자열 &lt;code&gt;source&lt;/code&gt; 식별되는 경로 이름을 지정하지만 유효하지만 지정되지 않은 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c5a2378f7a4b4f8c3112c22372e803c7c5df859" translate="yes" xml:space="preserve">
          <source>1) Assigns values, generated by given function object &lt;code&gt;g&lt;/code&gt;, to the first &lt;code&gt;count&lt;/code&gt; elements in the range beginning at &lt;code&gt;first&lt;/code&gt;, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;. Does nothing otherwise.</source>
          <target state="translated">1) 소정의 함수에 의해 생성 된 객체를 할당 값 &lt;code&gt;g&lt;/code&gt; 처음에, &lt;code&gt;count&lt;/code&gt; 범위의 요소에서 시작하여 &lt;code&gt;first&lt;/code&gt; 경우, &lt;code&gt;count&amp;gt;0&lt;/code&gt; . 다른 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="1eab96dc5e46fc4e8f1977dffe840d7d81e24fe4" translate="yes" xml:space="preserve">
          <source>1) At every &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;, the values of all &lt;a href=&quot;cv&quot;&gt;volatile&lt;/a&gt; objects are stable (previous evaluations are complete, new evaluations not started)</source>
          <target state="translated">1) 모든 &lt;a href=&quot;eval_order&quot;&gt;시퀀스 포인트&lt;/a&gt; 에서 모든 &lt;a href=&quot;cv&quot;&gt;휘발성&lt;/a&gt; 물체 의 값 이 안정적입니다 (이전 평가가 완료되고 새로운 평가가 시작되지 않음)</target>
        </trans-unit>
        <trans-unit id="2d2df9e87c835521a32a8b38e0df7638b8c0360b" translate="yes" xml:space="preserve">
          <source>1) Atomic types are not copy/move assignable</source>
          <target state="translated">1) 원자 유형은 복사 / 이동할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="1e1dd757f206c6d84410b18d446f5857c8473733" translate="yes" xml:space="preserve">
          <source>1) Atomically assigns a value &lt;code&gt;desired&lt;/code&gt; to the atomic variable. Equivalent to &lt;code&gt;store(desired)&lt;/code&gt;.</source>
          <target state="translated">1) 원자 변수에 &lt;code&gt;desired&lt;/code&gt; 값을 원자 적으로 할당 합니다. &lt;code&gt;store(desired)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="20eba43ce6c7c735f06737453bb9f5d0dcd49f5a" translate="yes" xml:space="preserve">
          <source>1) Atomically assigns a value &lt;code&gt;desired&lt;/code&gt; to the referenced object. Equivalent to &lt;code&gt;store(desired)&lt;/code&gt;.</source>
          <target state="translated">1) 참조 된 객체에 &lt;code&gt;desired&lt;/code&gt; 값을 원자 적으로 할당 합니다. &lt;code&gt;store(desired)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="917158b5056f9fcbc3944d1e3cd72bab0516b4f5" translate="yes" xml:space="preserve">
          <source>1) Atomically obtains the value pointed to by &lt;code&gt;obj&lt;/code&gt; as if by &lt;code&gt;obj-&amp;gt;load()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;obj-&amp;gt;load()&lt;/code&gt; 와 같이 &lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 원자 적으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d17583e702426f0634bea84e519c1633a6c029e1" translate="yes" xml:space="preserve">
          <source>1) Atomically releases &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed, or when the absolute time point &lt;code&gt;timeout_time&lt;/code&gt; is reached. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait_until&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1) 원자 적으로 &lt;code&gt;lock&lt;/code&gt; 을 해제 하고 현재 실행중인 스레드를 차단 한 다음 &lt;code&gt;*this&lt;/code&gt; 에서 대기중인 스레드 목록에 추가합니다 . &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; 이 실행되거나 절대 시점 &lt;code&gt;timeout_time&lt;/code&gt; 에 도달 하면 스레드가 차단 해제됩니다 . 또한 가짜 차단을 해제 할 수도 있습니다. 차단이 해제되면 이유와 상관없이 &lt;code&gt;lock&lt;/code&gt; 이 다시 획득되고 &lt;code&gt;wait_until&lt;/code&gt; 이 종료됩니다. 이 함수가 예외를 통해 종료되면 &lt;code&gt;lock&lt;/code&gt; 도 다시 획득됩니다 (C ++ 14까지).</target>
        </trans-unit>
        <trans-unit id="39228d6c9d016ca7d710e477075b422412a6e3a1" translate="yes" xml:space="preserve">
          <source>1) Atomically releases &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed, or when the relative timeout &lt;code&gt;rel_time&lt;/code&gt; expires. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait_for()&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1) 원자 적으로 &lt;code&gt;lock&lt;/code&gt; 을 해제 하고 현재 실행중인 스레드를 차단 한 다음 &lt;code&gt;*this&lt;/code&gt; 에서 대기중인 스레드 목록에 추가합니다 . &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; 이 실행되거나 상대 시간 종료 &lt;code&gt;rel_time&lt;/code&gt; 이 만료되면 스레드가 차단 해제 됩니다. 또한 가짜 차단을 해제 할 수도 있습니다. 차단이 해제되면 이유와 상관없이 &lt;code&gt;lock&lt;/code&gt; 이 다시 획득되고 &lt;code&gt;wait_for()&lt;/code&gt; 종료됩니다. 이 함수가 예외를 통해 종료되면 &lt;code&gt;lock&lt;/code&gt; 도 다시 획득됩니다 (C ++ 14까지).</target>
        </trans-unit>
        <trans-unit id="2fda25784c4cf15cdc68975c9a93b19127874b2f" translate="yes" xml:space="preserve">
          <source>1) Atomically replaces the value pointed to by &lt;code&gt;obj&lt;/code&gt; with the value of &lt;code&gt;desr&lt;/code&gt; and returns the value &lt;code&gt;obj&lt;/code&gt; held previously, as if by &lt;code&gt;obj-&amp;gt;exchange(desr)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;desr&lt;/code&gt; 의 값으로 원자 적으로 대체하고 &lt;code&gt;obj-&amp;gt;exchange(desr)&lt;/code&gt; 와 같이 이전에 보유한 &lt;code&gt;obj&lt;/code&gt; 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a87743df627f94e6483569a8db0b5f5cafd7d8e" translate="yes" xml:space="preserve">
          <source>1) Atomically replaces the value pointed to by &lt;code&gt;obj&lt;/code&gt; with the value of &lt;code&gt;desr&lt;/code&gt; as if by &lt;code&gt;obj-&amp;gt;store(desr)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;obj-&amp;gt;store(desr)&lt;/code&gt; 처럼 원자 적으로 &lt;code&gt;desr&lt;/code&gt; 의 값으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="407470d00a6b62854b98afb591359164b8cb7889" translate="yes" xml:space="preserve">
          <source>1) Atomically unlocks &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1) 원자 잠금 해제 &lt;code&gt;lock&lt;/code&gt; 블록 현재 실행 스레드 및 기다리는 쓰레드의 목록에 추가 &lt;code&gt;*this&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; 이 실행될 때 스레드가 차단 해제됩니다 . 또한 가짜 차단을 해제 할 수도 있습니다. 차단이 해제되면 이유와 상관없이 &lt;code&gt;lock&lt;/code&gt; 이 다시 획득되고 &lt;code&gt;wait&lt;/code&gt; 종료됩니다. 이 함수가 예외를 통해 종료되면 &lt;code&gt;lock&lt;/code&gt; 도 다시 획득됩니다 (C ++ 14까지).</target>
        </trans-unit>
        <trans-unit id="84cf693490eeb5e15a9f6ac3f4c02c6a3441ac7b" translate="yes" xml:space="preserve">
          <source>1) Attempts to create an object of type, denoted by the &lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt;&lt;code&gt;type&lt;/code&gt;, which may be array type, and may include a &lt;a href=&quot;auto&quot;&gt;placeholder type specifier&lt;/a&gt;(since C++11), or include a class template name whose argument is to be deduced by &lt;a href=&quot;deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;(since C++17).</source>
          <target state="translated">1) &lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id &lt;/a&gt; &lt;code&gt;type&lt;/code&gt; 으로 표시된 유형의 객체를 만들려고 시도합니다.이 유형 은 배열 유형 일 수 있으며 &lt;a href=&quot;auto&quot;&gt;자리 표시 자 유형 지정자&lt;/a&gt; (C ++ 11 이후)를 포함하거나 인수가 다음과 같은 클래스 템플릿 이름을 포함 할 수 있습니다 &lt;a href=&quot;deduction_guide&quot;&gt;클래스 템플릿 인수&lt;/a&gt; 추론에 의해 추론됩니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="f48a394185752e2c4944c4fec900dc772a3b157b" translate="yes" xml:space="preserve">
          <source>1) Attempts to establish the floating-point rounding direction equal to the argument &lt;code&gt;round&lt;/code&gt;, which is expected to be one of the &lt;a href=&quot;fe_round&quot;&gt;floating point rounding macros&lt;/a&gt;.</source>
          <target state="translated">1) 부동 소수점 반올림 방향을 인수 &lt;code&gt;round&lt;/code&gt; 와 동일하게 설정하려고 &lt;a href=&quot;fe_round&quot;&gt;합니다&lt;/a&gt; . 이는 부동 소수점 반올림 매크로 중 하나 일 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e3a5800b099aa0f75fced4ac6f2262d5f08936e" translate="yes" xml:space="preserve">
          <source>1) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">1) 비트 마스크 인수에 나와있는 부동 소수점 예외 플래그의 전체 내용을 얻기 위해 시도 &lt;code&gt;excepts&lt;/code&gt; 비트 단위 OR의이다, &lt;a href=&quot;fe_exceptions&quot;&gt;부동 소수점 예외 매크로&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76935444316711f1ef025f07ccf80865f5a71493" translate="yes" xml:space="preserve">
          <source>1) Attempts to store the status of the floating-point environment in the object pointed to by &lt;code&gt;envp&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;envp&lt;/code&gt; 가 가리키는 객체에 부동 소수점 환경의 상태를 저장하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="c537d0344b241074eb3e0571ce11684b3a4576f9" translate="yes" xml:space="preserve">
          <source>1) Average case: constant, worst case: &lt;code&gt;c.size()&lt;/code&gt;</source>
          <target state="translated">1) 평균 사례 : 상수, 최악의 경우 : &lt;code&gt;c.size()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9b3845de48d795b10c6d53a55eac9b66f856548" translate="yes" xml:space="preserve">
          <source>1) Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;input.gcount()&lt;/code&gt; is not affected. After constructing and checking the sentry object, performs the following:</source>
          <target state="translated">1) &lt;code&gt;input.gcount()&lt;/code&gt; 가 영향을받지 않는 것을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6af5c4964210e22b364a62aef34f203069bc01d3" translate="yes" xml:space="preserve">
          <source>1) Behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, determines the output format padding as follows:</source>
          <target state="translated">1) &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후 다음과 같이 출력 형식 패딩을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="abde054c511c98ef59ea6a6219a0d40067429c5f" translate="yes" xml:space="preserve">
          <source>1) Behaves as an &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, which may skip leading whitespace, extracts a character and stores it to &lt;code&gt;ch&lt;/code&gt;. If no character is available, sets &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;failbit&lt;/code&gt;&lt;/a&gt; (in addition to &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;eofbit&lt;/code&gt;&lt;/a&gt; that is set as required of a &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;).</source>
          <target state="translated">1) &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후 선행 공백을 건너 뛸 수 있으며 문자를 추출하여 &lt;code&gt;ch&lt;/code&gt; 에 저장합니다 . 사용 가능한 문자가없는 경우, &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;failbit&lt;/code&gt; &lt;/a&gt; 설정 하십시오 ( &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction의&lt;/a&gt; 필요에 따라 설정된 &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;eofbit&lt;/code&gt; &lt;/a&gt; 외에 ).</target>
        </trans-unit>
        <trans-unit id="66cf5e2bc278327aafd28d7df89e620a0de46000" translate="yes" xml:space="preserve">
          <source>1) Behaves as an &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, inserts the character &lt;code&gt;ch&lt;/code&gt;. If the type of the character is not &lt;code&gt;CharT&lt;/code&gt;, it is first converted with &lt;code&gt;os.widen(ch)&lt;/code&gt;. Padding is determined as follows: if &lt;code&gt;os.width()&amp;gt;1&lt;/code&gt;, then &lt;code&gt;os.width()-1&lt;/code&gt; copies of &lt;code&gt;os.fill()&lt;/code&gt; are added to the output character to form the output character sequence. If &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, the fill characters are placed after the output character, otherwise before. After insertion, &lt;code&gt;os.width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">1) &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후 &lt;code&gt;ch&lt;/code&gt; 문자를 삽입합니다 . 문자 유형이 &lt;code&gt;CharT&lt;/code&gt; 가 아닌 경우 먼저 &lt;code&gt;os.widen(ch)&lt;/code&gt; 로 변환됩니다 . 패딩은 다음과 같이 결정됩니다. &lt;code&gt;os.width()&amp;gt;1&lt;/code&gt; 이면 &lt;code&gt;os.width()-1&lt;/code&gt; 의 &lt;code&gt;os.fill()&lt;/code&gt; -1 사본이 출력 문자에 추가되어 출력 문자 시퀀스를 형성합니다. 만약 &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; 채우기 문자가 출력 문자 뒤에 배치됩니다, 그렇지 않으면 전에. 삽입 후, &lt;code&gt;os.width(0)&lt;/code&gt; 이 호출되어 &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; (있는 경우).</target>
        </trans-unit>
        <trans-unit id="c4d17ec70cbf5d4f592fc6b2f432bf9f5427d7e3" translate="yes" xml:space="preserve">
          <source>1) Behaves as if (2) is called with &lt;code&gt;policy&lt;/code&gt; being &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt; | &lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt;. In other words, &lt;code&gt;f&lt;/code&gt; may be executed in another thread or it may be run synchronously when the resulting &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; is queried for a value.</source>
          <target state="translated">1) 동작 해 마치 (2) 불려 &lt;code&gt;policy&lt;/code&gt; 되는 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt; | &lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; . 즉, &lt;code&gt;f&lt;/code&gt; 는 다른 스레드에서 실행될 수도 있고 결과 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 가 값을 쿼리 할 때 동 기적으로 실행될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1561ba4be61858948b7fed01763fdb3a6eb95b15" translate="yes" xml:space="preserve">
          <source>1) Behaves as if defined as follows:</source>
          <target state="translated">1) 다음과 같이 정의 된 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="8175e77df8cae0e91832bcbf197a16dc79ef925d" translate="yes" xml:space="preserve">
          <source>1) Behaves in implementation-defined manner</source>
          <target state="translated">1) 구현 정의 방식으로 작동</target>
        </trans-unit>
        <trans-unit id="9b4755491e2aea36644386cd6d0dbcbbe4600c5a" translate="yes" xml:space="preserve">
          <source>1) Binds the first argument of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Effectively calls &lt;code&gt;&lt;a href=&quot;binder12&quot;&gt;std::binder1st&lt;/a&gt;&amp;lt;F&amp;gt;(f, typename F::first_argument_type(x))&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;f&lt;/code&gt; 의 첫 번째 인수 를 &lt;code&gt;x&lt;/code&gt; 에 바인딩합니다 . 효과적으로 &lt;code&gt;&lt;a href=&quot;binder12&quot;&gt;std::binder1st&lt;/a&gt;&amp;lt;F&amp;gt;(f, typename F::first_argument_type(x))&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="984a8150c7ac39a66022118522276911d7cc5f49" translate="yes" xml:space="preserve">
          <source>1) Binds the first parameter to the value &lt;code&gt;value&lt;/code&gt; given at the construction of the object.</source>
          <target state="translated">1) 값의 첫 번째 파라미터 바인딩 &lt;code&gt;value&lt;/code&gt; 객체의 구성에 부여한다.</target>
        </trans-unit>
        <trans-unit id="64831980f81dae6254ff1d82d0c72182c81bbba9" translate="yes" xml:space="preserve">
          <source>1) Both ranges must be sorted with &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">1) 두 범위는 모두 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 로 정렬해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e7001be6592e516d5b51c004a74838c40e04025" translate="yes" xml:space="preserve">
          <source>1) Called by &lt;a href=&quot;../../language/delete&quot;&gt;delete-expressions&lt;/a&gt; to deallocate storage previously allocated for a single object. The behavior of the standard library implementation of this function is undefined unless &lt;code&gt;ptr&lt;/code&gt; is a null pointer or is a pointer previously obtained from the standard library implementation of &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t, &lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) 단일 객체에 대해 이전에 할당 된 스토리지를 할당 해제하기 위해 &lt;a href=&quot;../../language/delete&quot;&gt;delete-expression&lt;/a&gt; 에 의해 호출됩니다 . 이 함수의 표준 라이브러리 구현 동작은 &lt;code&gt;ptr&lt;/code&gt; 이 널 포인터이거나 &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t, &lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;)&lt;/code&gt; 의 표준 라이브러리 구현에서 이전에 얻은 포인터가 아니면 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b29fa0fabda5d69f4442be6c5fdef616a24dd581" translate="yes" xml:space="preserve">
          <source>1) Called by non-array &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate storage required for a single object. The standard library implementation allocates &lt;code&gt;count&lt;/code&gt; bytes from free store. In case of failure, the standard library implementation calls the function pointer returned by &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt; and repeats allocation attempts until new handler does not return or becomes a null pointer, at which time it throws &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;. This function is required to return a pointer suitably aligned to hold an object of any fundamental alignment.</source>
          <target state="translated">1) 단일 객체에 필요한 스토리지를 할당하기 위해 배열이 아닌 &lt;a href=&quot;../../language/new&quot;&gt;새로운 표현식&lt;/a&gt; 에 의해 호출됩니다 . 표준 라이브러리 구현 은 사용 가능한 저장소에서 &lt;code&gt;count&lt;/code&gt; 바이트를 할당 합니다. 실패한 경우 표준 라이브러리 구현은 &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt; 리턴 한 함수 포인터를 호출하고 새 핸들러가 리턴되지 않거나 널 포인터가 될 때까지 할당 시도를 반복하여 &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 던집니다 . 이 함수는 기본 정렬의 객체를 유지하기 위해 적절하게 정렬 된 포인터를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="1201c06b6c4799b1fe55caec61e97450a74c02c7" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;((T*)p)-&amp;gt;~T()&lt;/code&gt;</source>
          <target state="translated">1) 호출 &lt;code&gt;((T*)p)-&amp;gt;~T()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60cf179e7f48d67030a9b02c5b10f02cbd88fc74" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::allocate(outer_allocator(), n)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::allocate(outer_allocator(), n)&lt;/code&gt; &amp;lt;OuterAlloc&amp;gt; :: allocate (outer_allocator (), n) 호출</target>
        </trans-unit>
        <trans-unit id="75d0c1937c63022053420ca73afdc6c6c3f42d8d" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;a.allocate(n)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;a.allocate(n)&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="612ce7599a47183d9e5a7f878c33edddf6b15c5f" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;delete&lt;/code&gt; (primary template) or &lt;code&gt;delete[]&lt;/code&gt; (array specialization) on &lt;code&gt;ptr&lt;/code&gt;2) Defined as deleted</source>
          <target state="translated">1) &lt;code&gt;ptr&lt;/code&gt; 에서 &lt;code&gt;delete&lt;/code&gt; (1 차 템플리트) 또는 &lt;code&gt;delete[]&lt;/code&gt; (배열 특수화 ) 호출 2) 삭제 된 것으로 정의</target>
        </trans-unit>
        <trans-unit id="f9949dd29b950802c3d58375f6e80bddb5aa08d9" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;delete&lt;/code&gt; on &lt;code&gt;ptr&lt;/code&gt;2) Calls &lt;code&gt;delete[]&lt;/code&gt; on &lt;code&gt;ptr&lt;/code&gt;. This function will only participate in overload resolution if &lt;code&gt;U(*)[]&lt;/code&gt; is implicitly convertible to &lt;code&gt;T(*)[]&lt;/code&gt;.</source>
          <target state="translated">1) 통화 &lt;code&gt;delete&lt;/code&gt; 에 &lt;code&gt;ptr&lt;/code&gt; ) 2 통화 &lt;code&gt;delete[]&lt;/code&gt; 에 &lt;code&gt;ptr&lt;/code&gt; . 이 함수는 &lt;code&gt;U(*)[]&lt;/code&gt; 가 암시 적으로 &lt;code&gt;T(*)[]&lt;/code&gt; 로 변환 가능한 경우에만 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="18edfbb5ff4b58d729699ca4db1ff32af0d3018f" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;new((void *)p) T(val)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;new((void *)p) T(val)&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="d55a7910f52d41d1727553c431ed7d3dd8fbe500" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 가장 많이 파생 된 클래스의 &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="1275e8a0c91e8f2137761ada491aefdcab7cbfe3" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;seekpos(pos, which)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 가장 많이 파생 된 클래스의 &lt;code&gt;seekpos(pos, which)&lt;/code&gt; )를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="2ce04d40fb13795e660c624012ebc10673555aff" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;setbuf(s, n)&lt;/code&gt; of the most derived class</source>
          <target state="translated">1) 가장 많이 파생 된 클래스 &lt;code&gt;setbuf(s, n)&lt;/code&gt; ) 호출</target>
        </trans-unit>
        <trans-unit id="189c8c3b03cc9ff928fbd4420e4f08a2f0060d6d" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;str.erase()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;str.erase()&lt;/code&gt; ) 호출</target>
        </trans-unit>
        <trans-unit id="968bf3d903f71b89d9f7ec9294f33c57ce120fc1" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;sync()&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 가장 많이 파생 된 클래스의 &lt;code&gt;sync()&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="730f19f3ac0934ef27532bf7c9384f807d2f9aed" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;xsgetn(s, count)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 가장 많이 파생 된 클래스 &lt;code&gt;xsgetn(s, count)&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="ec64be5663b85a72b50b7ff9f40df45f3c1977e7" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;xsputn(s, count)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 가장 많이 파생 된 클래스 &lt;code&gt;xsputn(s, count)&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="168b614f9f40ac5f9718c1bbf48c0be54f15eee3" translate="yes" xml:space="preserve">
          <source>1) Calls every callback registered by &lt;code&gt;&lt;a href=&quot;../ios_base/register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; passing &lt;a href=&quot;../ios_base/event&quot;&gt;&lt;code&gt;erase_event&lt;/code&gt;&lt;/a&gt; as parameter</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../ios_base/register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; 의해 등록 된 모든 콜백 을 파라미터로 &lt;a href=&quot;../ios_base/event&quot;&gt; &lt;code&gt;erase_event&lt;/code&gt; &lt;/a&gt; 를 전달 하여 호출</target>
        </trans-unit>
        <trans-unit id="9815ff59a707fc80fc245c084207918bbda81cd8" translate="yes" xml:space="preserve">
          <source>1) Catch-clause that declares a named formal parameter</source>
          <target state="translated">1) 명명 된 형식 매개 변수를 선언하는 Catch-clause</target>
        </trans-unit>
        <trans-unit id="a2e6973b14cedb89a76d6c2303ae23c129573389" translate="yes" xml:space="preserve">
          <source>1) Changes the current preprocessor line number to lineno. Expansions of the macro &lt;code&gt;__LINE__&lt;/code&gt; beyond this point will expand to lineno plus the number of actual source code lines encountered since.</source>
          <target state="translated">1) 현재 전 처리기 행 번호를 lineno로 변경합니다. 이 지점을 넘어 매크로 &lt;code&gt;__LINE__&lt;/code&gt; 을 확장하면 lineno와 그 이후에 발생한 실제 소스 코드 라인 수를 더한 값으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="251ac3216df00c46dba0c1fcacce145761ea51d6" translate="yes" xml:space="preserve">
          <source>1) Character width: unset, narrow or wide</source>
          <target state="translated">1) 문자 너비 : 설정되지 않거나 좁거나 넓음</target>
        </trans-unit>
        <trans-unit id="528a3c47bcb0f4bda9d76624cab85acce69f7c8b" translate="yes" xml:space="preserve">
          <source>1) Checks if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="653944661bbab0d4335db30edc3fcd7d09dead4d" translate="yes" xml:space="preserve">
          <source>1) Checks if all bits are set to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1) 모든 비트가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있는지 확인</target>
        </trans-unit>
        <trans-unit id="2c372d3881ed1d3880dc2bcd3c0763ed5a3e843a" translate="yes" xml:space="preserve">
          <source>1) Checks if the character &lt;code&gt;c&lt;/code&gt; is classified by the mask &lt;code&gt;m&lt;/code&gt; according to the classification table returned by the member function &lt;code&gt;table()&lt;/code&gt;. Effectively calculates &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt;</source>
          <target state="translated">1) 멤버 함수 &lt;code&gt;table()&lt;/code&gt; 에서 반환 한 분류 테이블에 따라 문자 &lt;code&gt;c&lt;/code&gt; 가 마스크 &lt;code&gt;m&lt;/code&gt; 으로 분류 되는지 확인합니다 . 효과적으로 &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="055fc3ccc188ca6bb065e219ee940c38e7022dff" translate="yes" xml:space="preserve">
          <source>1) Checks if there is an element with key equivalent to &lt;code&gt;key&lt;/code&gt; in the container.</source>
          <target state="translated">1) 컨테이너에 키와 동일한 &lt;code&gt;key&lt;/code&gt; 를 가진 요소가 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="01ce0d85d642a69a60a7bd7021acaa1e1acddc49" translate="yes" xml:space="preserve">
          <source>1) Checks if unary predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for all elements in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">1) 단항 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 모든 요소에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="807fd23a250c000cd2d3ce89e2e7e20500a459ae" translate="yes" xml:space="preserve">
          <source>1) Checks if unary predicate &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; (after projecting with the projection &lt;code&gt;proj&lt;/code&gt;).</source>
          <target state="translated">1) 단항 술어 &lt;code&gt;pred&lt;/code&gt; 가 ( &lt;code&gt;proj&lt;/code&gt; 투영 한 후 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 모든 요소에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="af5a0d7b95029857fc67f9aec30edea70c5bdbe5" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;a href=&quot;root_path&quot;&gt;&lt;code&gt;root_path()&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">1) &lt;a href=&quot;root_path&quot;&gt; &lt;code&gt;root_path()&lt;/code&gt; &lt;/a&gt; 가 비어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="faa74b887ee96c25a3492d6735e13770ce680b0e" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same object.</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은 객체를 나타내는 지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2dba4b22cc7fa19bfacb9c9df88e70c92a237039" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e8185a1925a4fbfb166981361f79075e2ee33f60" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal. Equivalent to &lt;code&gt;!(lhs &amp;lt; rhs) &amp;amp;&amp;amp; !(rhs &amp;lt; lhs)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은지 확인합니다 . 상당 &lt;code&gt;!(lhs &amp;lt; rhs) &amp;amp;&amp;amp; !(rhs &amp;lt; lhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fcbd95aabb4ff5227cf670c7cd313a716db3f1b" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">1) &lt;code&gt;lhs&lt;/code&gt; 가 있는지 확인</target>
        </trans-unit>
        <trans-unit id="025b85874b3e1d46d1eddf5eb17f542191097060" translate="yes" xml:space="preserve">
          <source>1) Compares &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for equality.</source>
          <target state="translated">1) &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 동일한 지 비교 합니다 .</target>
        </trans-unit>
        <trans-unit id="ba27d1cf06b36c7b4c27679328ea9f73d35759e5" translate="yes" xml:space="preserve">
          <source>1) Compares &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; for equality.</source>
          <target state="translated">1) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 동일한 지 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="379cb0f357c5f6804b447714bf22e588013d0adb" translate="yes" xml:space="preserve">
          <source>1) Compares this string to</source>
          <target state="translated">1)이 문자열을</target>
        </trans-unit>
        <trans-unit id="95bc5c17aaacd83f1d13fbd093132d7300e74abf" translate="yes" xml:space="preserve">
          <source>1) Compares two &lt;code&gt;sub_match&lt;/code&gt; directly by comparing their underlying character sequences. Equivalent to &lt;code&gt;str().compare(m.str())&lt;/code&gt;.</source>
          <target state="translated">1) 기본 문자 순서를 비교하여 두 개의 &lt;code&gt;sub_match&lt;/code&gt; 를 직접 비교합니다. 동등 &lt;code&gt;str().compare(m.str())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="babefe1ac4774ec2ba6d2f9315221ca39913970c" translate="yes" xml:space="preserve">
          <source>1) Compares two distribution objects for equality.</source>
          <target state="translated">1) 두 분포 개체가 동일한 지 비교합니다.</target>
        </trans-unit>
        <trans-unit id="35a9eb1fa11c8a233e6c0a2c9a6bd06330c5cb30" translate="yes" xml:space="preserve">
          <source>1) Computes the</source>
          <target state="translated">1) 계산</target>
        </trans-unit>
        <trans-unit id="29e45200813ec27005f84e8b35b75cfdc6f3c406" translate="yes" xml:space="preserve">
          <source>1) Computes the (physicist's) &lt;a href=&quot;https://en.wikipedia.org/wiki/Hermite_polynomials&quot;&gt;Hermite polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) 학위 &lt;code&gt;n&lt;/code&gt; 과 인수 &lt;code&gt;x&lt;/code&gt; 의 (물리학 자) &lt;a href=&quot;https://en.wikipedia.org/wiki/Hermite_polynomials&quot;&gt;은자 다항식&lt;/a&gt; 을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5cd529178d75829687d759cf3575835519db392b" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Associated_Legendre_polynomials&quot;&gt;associated Legendre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;n&lt;/code&gt; , 차수 &lt;code&gt;m&lt;/code&gt; 및 인수 &lt;code&gt;x&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Associated_Legendre_polynomials&quot;&gt;관련 Legendre 다항식&lt;/a&gt; 을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="11b6095d1bbc46a80dd8c941788ea2de6b4c76aa" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1&quot;&gt;cylindrical Bessel function of the first kind&lt;/a&gt; of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1&quot;&gt;첫 번째 종류&lt;/a&gt; 의 &lt;code&gt;&amp;nu;&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 의 원통형 베셀 함수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="09a1bb2811a36108b87f462b1c39d364fc3d72dc" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_second_kind:_Y.CE.B1&quot;&gt;cylindrical Neumann function&lt;/a&gt; (also known as Bessel function of the second kind or Weber function) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&amp;nu;&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_second_kind:_Y.CE.B1&quot;&gt;원통형 Neumann 함수&lt;/a&gt; (두 번째 종류의 베셀 함수 또는 베버 함수라고도 함 )를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="4c4124d09b398c54819810bb7083904eeb5106df" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;irregular modified cylindrical Bessel function&lt;/a&gt; (also known as modified Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&amp;nu;&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;불규칙 수정 원통형 베셀 함수&lt;/a&gt; (두 번째 종류의 수정 베셀 함수라고도 함 )를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ccf9684995d2a46db4ec7d7201afb8deb62574e0" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;regular modified cylindrical Bessel function&lt;/a&gt; of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&amp;nu;&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;정규 수정 원통형 베셀 함수&lt;/a&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="61a6248b455016d83fb9f4ae46600e92647e97f9" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;spherical Bessel function of the first kind&lt;/a&gt; of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;n&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;의 첫 번째 종류&lt;/a&gt; 의 구형 베셀 함수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="58bd3e8ee95098c0c96f4de4b3b5b3f2da549f3f" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;spherical Bessel function of the second kind&lt;/a&gt;, also known as the spherical Neumann function, of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) 구형 Neumann 함수라고도 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;하는 두 번째 종류&lt;/a&gt; 의 구형 베셀 함수 를 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;x&lt;/code&gt; 로 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="bd5509c7dd414eeed186d9c04f5e19a8ae9447d6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function&quot;&gt;beta function&lt;/a&gt; of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function&quot;&gt;베타 함수&lt;/a&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="20e020a9e1ce8ef730c0d0cab5e6865004161b48" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_conjugate&quot;&gt;complex conjugate&lt;/a&gt; of &lt;code&gt;z&lt;/code&gt; by reversing the sign of the imaginary part.</source>
          <target state="translated">1) 허수 부의 부호를 반대로하여 &lt;code&gt;z&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_conjugate&quot;&gt;복소 공액&lt;/a&gt; 을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="bed7cd35295f9a8460aa9f26a5fd423e0f5632e6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_first_kind&quot;&gt;complete elliptic integral of the first kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;k&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_first_kind&quot;&gt;의 첫 번째 종류&lt;/a&gt; 의 완전한 타원 적분을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="33b1e6d2c533af4241eec10ee1fc6c7a568c2e97" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_second_kind&quot;&gt;complete elliptic integral of the second kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;k&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_second_kind&quot;&gt;의 두 번째 종류&lt;/a&gt; 의 완전한 타원 적분을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d44887ee66b13404fd46bfb48d18761afabeb530" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_third_kind&quot;&gt;complete elliptic integral of the third kind&lt;/a&gt; of the arguments &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;nu;&lt;/code&gt;.</source>
          <target state="translated">1) 인수 &lt;code&gt;k&lt;/code&gt; 와 &lt;code&gt;&amp;nu;&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_third_kind&quot;&gt;의 세 번째 종류&lt;/a&gt; 의 완전한 타원 적분을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="34c90fd51c4b11003b3fbb3c42c725019e1184d5" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Elliptic_integral_of_the_first_kind&quot;&gt;incomplete elliptic integral of the first kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;k&lt;/code&gt; 와 &lt;code&gt;&amp;phi;&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Elliptic_integral_of_the_first_kind&quot;&gt;의 첫 번째 종류&lt;/a&gt; 의 불완전한 타원 적분을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="18c3b8c68fe18231bc4683a4dab18461556c8a6e" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_second_kind&quot;&gt;incomplete elliptic integral of the second kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;k&lt;/code&gt; 와 &lt;code&gt;&amp;phi;&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_second_kind&quot;&gt;의 두 번째 종류&lt;/a&gt; 의 불완전한 타원 적분을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d2a10c9a8d077e7cf3be02757334df49842de441" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_third_kind&quot;&gt;incomplete elliptic integral of the third kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;&amp;nu;&lt;/code&gt;, and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_third_kind&quot;&gt;세 번째 종류&lt;/a&gt; 의 &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;&amp;nu;&lt;/code&gt; 및 &lt;code&gt;&amp;phi;&lt;/code&gt; 의 불완전한 타원 적분을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a057675fa979fcdd978ffe3a864ce85d4f81ad27" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_integral&quot;&gt;exponential integral&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;arg&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_integral&quot;&gt;지수 적분&lt;/a&gt; 을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="194521a0cc3e924de1e24b00830776378f111bf6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials&quot;&gt;associated Laguerre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) 차수 &lt;code&gt;n&lt;/code&gt; , 차수 &lt;code&gt;m&lt;/code&gt; 및 인수 &lt;code&gt;x&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials&quot;&gt;관련 Laguerre 다항식&lt;/a&gt; 을 계산합니다</target>
        </trans-unit>
        <trans-unit id="447c8a8a3695dfb2c0135ecd809d50a81ac60799" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Riemann_zeta_function&quot;&gt;Riemann zeta function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;arg&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Riemann_zeta_function&quot;&gt;Riemann zeta 함수&lt;/a&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ec4c5063d8c1e5217253c6566900149f02eb3ff3" translate="yes" xml:space="preserve">
          <source>1) Computes the inverse tangent of each pair of corresponding values from &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;y&lt;/code&gt; 와 &lt;code&gt;x&lt;/code&gt; 에서 대응하는 각 값 쌍의 역 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="9f69a96b516d331be6b80e58bbf178ccead673fa" translate="yes" xml:space="preserve">
          <source>1) Computes the non-associated &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials&quot;&gt;Laguerre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) 차수 &lt;code&gt;n&lt;/code&gt; 과 인수 &lt;code&gt;x&lt;/code&gt; 의 비 연관 &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials&quot;&gt;Laguerre 다항식&lt;/a&gt; 을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="96823949bd54a22f8ca1311f8a8c38cf707e34c9" translate="yes" xml:space="preserve">
          <source>1) Computes the spherical associated Legendre function of degree &lt;code&gt;l&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and polar angle &lt;code&gt;&amp;theta;&lt;/code&gt;.</source>
          <target state="translated">1) 차수 &lt;code&gt;l&lt;/code&gt; , 차수 &lt;code&gt;m&lt;/code&gt; 및 극각 &lt;code&gt;&amp;theta;&lt;/code&gt; 의 구형 관련 Legendre 함수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="494b5451cb229192203200646404e640730476f1" translate="yes" xml:space="preserve">
          <source>1) Computes the unassociated &lt;a href=&quot;https://en.wikipedia.org/wiki/Legendre_polynomials&quot;&gt;Legendre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) 차수 &lt;code&gt;n&lt;/code&gt; 과 인수 &lt;code&gt;x&lt;/code&gt; 의 연관되지 않은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Legendre_polynomials&quot;&gt;Legendre 다항식&lt;/a&gt; 을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="021f4354ef970a1b656513a9b0be260507748eec" translate="yes" xml:space="preserve">
          <source>1) Computes the values of each element in the numeric array &lt;code&gt;base&lt;/code&gt; raised to the power specified by the corresponding element from the numeric array &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">1) 숫자 형 배열 &lt;code&gt;base&lt;/code&gt; 에서 각 요소의 값을 숫자 형 배열 &lt;code&gt;exp&lt;/code&gt; 에서 해당 요소에 의해 지정된 거듭 제곱으로 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="58d25c5a734cad90917e4f1983b210515311a450" translate="yes" xml:space="preserve">
          <source>1) Const reference to the value stored in the shared state. Accessing the value through this reference is undefined after the shared state has been destroyed.</source>
          <target state="translated">1) 공유 상태에 저장된 값에 대한 Const 참조. 이 참조를 통한 값 액세스는 공유 상태가 소멸 된 후에 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fda2d3df21980fc0c991439c0b017a5cbfcceaa" translate="yes" xml:space="preserve">
          <source>1) Constant</source>
          <target state="translated">1) 상수</target>
        </trans-unit>
        <trans-unit id="883376fb1cd5c259eb6c95ea63e4001892914fb5" translate="yes" xml:space="preserve">
          <source>1) Constant.</source>
          <target state="translated">1) 상수.</target>
        </trans-unit>
        <trans-unit id="8348152efcbbea63fdeddd6840b070be4fb7a774" translate="yes" xml:space="preserve">
          <source>1) Constructs &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage starting at &lt;code&gt;first&lt;/code&gt; by &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) &lt;code&gt;first&lt;/code&gt; 에 &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialization으로&lt;/a&gt; 시작하여 초기화되지 않은 스토리지에서 &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; 유형의 &lt;code&gt;n&lt;/code&gt; 개의 객체를 다음 과 같이 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a76414f38c38467178589672432e927144d5fca1" translate="yes" xml:space="preserve">
          <source>1) Constructs &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage starting at &lt;code&gt;first&lt;/code&gt; by &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; 유형의 &lt;code&gt;n&lt;/code&gt; 개의 객체 를 &lt;code&gt;first&lt;/code&gt; 에 &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialization으로&lt;/a&gt; 시작하여 초기화되지 않은 스토리지 에 구성합니다.</target>
        </trans-unit>
        <trans-unit id="8cfad2bd0fe265d0360e216522ed743e93e164f6" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;polymorphic_allocator&lt;/code&gt; using the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; as the underlying memory resource.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; () 의 반환 값을 기본 메모리 리소스로 사용하여 &lt;code&gt;polymorphic_allocator&lt;/code&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="caf585f0b2cbecc991027b2c5d5ade0ff9fa6a44" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;shared_lock&lt;/code&gt; with no associated mutex.</source>
          <target state="translated">1) 연관된 뮤텍스가없는 &lt;code&gt;shared_lock&lt;/code&gt; 을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="c1691406fb44b80bf86d25e8199ea7826da306af" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::basic_filebuf&lt;/code&gt; object, initializing the base class by calling the default constructor of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;. The created &lt;code&gt;basic_filebuf&lt;/code&gt; is not associated with a file, and &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;std::basic_filebuf&lt;/code&gt; 객체를 구성하고 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 의 기본 생성자를 호출하여 기본 클래스를 초기화합니다 . 작성된 &lt;code&gt;basic_filebuf&lt;/code&gt; 는 파일과 연관되지 않으며 &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0ed2e91b75fa0fbaf5c3602ace32ee3a481e1def" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::default_delete&lt;/code&gt; object.</source>
          <target state="translated">1) &lt;code&gt;std::default_delete&lt;/code&gt; 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d62c4ae5cb1598e1b293081929462849a710f111" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::packaged_task&lt;/code&gt; object with no task and no shared state.</source>
          <target state="translated">1) 태스크가없고 공유 상태가없는 &lt;code&gt;std::packaged_task&lt;/code&gt; 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="28c93deb18867bda8fc7f9df6c0fa46001aabb5a" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::strstreambuf&lt;/code&gt; object: initializes the base class by calling the default constructor of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;, initializes the buffer state to &quot;dynamic&quot; (the buffer will be allocated as needed), initializes allocated size to the provided &lt;code&gt;alsize&lt;/code&gt;, initializes the allocation and the deallocation functions to null (will use &lt;code&gt;new[]&lt;/code&gt; and &lt;code&gt;delete[]&lt;/code&gt;)</source>
          <target state="translated">1) 구축 &lt;code&gt;std::strstreambuf&lt;/code&gt; 의 기본 생성자 호출하여 기본 클래스를 초기화 : 오브젝트 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 제공된의 크기를 할당 초기화 (버퍼)를 필요에 따라 할당된다 &quot;동적&quot;로 버퍼 상태를 초기화 &lt;code&gt;alsize&lt;/code&gt; , 할당 및 할당 해제 기능을 null로 초기화합니다 ( &lt;code&gt;new[]&lt;/code&gt; 및 &lt;code&gt;delete[]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="64cc8935216e3aea1780a77626ea547c25b59b13" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::unique_ptr&lt;/code&gt; that owns nothing. Value-initializes the stored pointer and the stored deleter. Requires that &lt;code&gt;Deleter&lt;/code&gt; is &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; and that construction does not throw an exception.</source>
          <target state="translated">1) 아무것도 소유하지 않는 &lt;code&gt;std::unique_ptr&lt;/code&gt; 합니다. 저장된 포인터와 저장된 삭제기를 값으로 초기화합니다. 해야 &lt;code&gt;Deleter&lt;/code&gt; 가가 이다 &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; 그 구조가 예외를 throw하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d37caf20ed678ee45772f6932c0c59569e653b3" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;unique_lock&lt;/code&gt; with no associated mutex.</source>
          <target state="translated">1) 연관된 뮤텍스가없는 &lt;code&gt;unique_lock&lt;/code&gt; 을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="b90797f613a746c0c6afab39848b6f01ca99d6fc" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;weekday_indexed&lt;/code&gt; from &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt;. The result represents the &lt;code&gt;index&lt;/code&gt;-th weekday in some yet-to-be-specified month. If &lt;code&gt;index&lt;/code&gt; is not in the range [1, 5] or if &lt;code&gt;!ok()&lt;/code&gt; the values held in the result is unspecified.</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;index&lt;/code&gt; 로 &lt;code&gt;weekday_indexed&lt;/code&gt; 를 구성합니다 . 결과는 아직 지정되지 않은 일부 달의 주중 &lt;code&gt;index&lt;/code&gt; 나타냅니다 . 경우 &lt;code&gt;index&lt;/code&gt; 범위 [1,5]에서 또는없는 경우 &lt;code&gt;!ok()&lt;/code&gt; 결과에 유지 된 값이 지정된다.</target>
        </trans-unit>
        <trans-unit id="a877e234ee1a9651490a92e199612268aa6c085f" translate="yes" xml:space="preserve">
          <source>1) Constructs a distribution object with</source>
          <target state="translated">1) 배포 객체를 구성</target>
        </trans-unit>
        <trans-unit id="5839abe97e388fd0beeb46fbe0cbbe23df700f9c" translate="yes" xml:space="preserve">
          <source>1) Constructs a distribution object with n = 1, &amp;rho;0 = 1, b0 = 0, and b1 = 1.</source>
          <target state="translated">1) n = 1, &amp;rho;0 = 1, b0 = 0 및 b1 = 1 인 분포 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="5c36468c5ae16e3151bf49dbb6037065bdee5887" translate="yes" xml:space="preserve">
          <source>1) Constructs a non-array type &lt;code&gt;T&lt;/code&gt;. The arguments &lt;code&gt;args&lt;/code&gt; are passed to the constructor of &lt;code&gt;T&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is not an array type. The function is equivalent to:</source>
          <target state="translated">1) 비 배열 형 &lt;code&gt;T&lt;/code&gt; 를 구축합니다 . 인수 &lt;code&gt;args&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 의 생성자로 전달됩니다 . 이 과부하 는 &lt;code&gt;T&lt;/code&gt; 가 배열 유형이 아닌 경우에만 과부하 해결에 참여 합니다. 이 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5bbbb231a62824534ca087741ebf1ecc513e1ae" translate="yes" xml:space="preserve">
          <source>1) Constructs a value at the location the iterator points to from &lt;code&gt;el&lt;/code&gt;.</source>
          <target state="translated">1) 반복자가 &lt;code&gt;el&lt;/code&gt; 에서 가리키는 위치에 값을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="c1e6b4ba149ed3478a1436d89169e5bb7c611e15" translate="yes" xml:space="preserve">
          <source>1) Constructs an &lt;code&gt;atomic_ref&lt;/code&gt; object referencing the object &lt;code&gt;obj&lt;/code&gt;. The behavior is undefined if &lt;code&gt;obj&lt;/code&gt; is not aligned to &lt;a href=&quot;required_alignment&quot;&gt;&lt;code&gt;required_alignment&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1) 객체 &lt;code&gt;obj&lt;/code&gt; 를 참조 하는 &lt;code&gt;atomic_ref&lt;/code&gt; 객체를 구성합니다 . &lt;code&gt;obj&lt;/code&gt; 가 &lt;a href=&quot;required_alignment&quot;&gt; &lt;code&gt;required_alignment&lt;/code&gt; 에&lt;/a&gt; 정렬 되지 않은 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3f46d867616b349884c0eaec36a04a2b5e2f106e" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty container.</source>
          <target state="translated">1) 빈 컨테이너를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="bb6630efd81f0800437bcdd0637108688772c997" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty object.</source>
          <target state="translated">1) 빈 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="4aba85a0be5aa34c1a435f0e6a4e3db1b5c1bb67" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty path.</source>
          <target state="translated">1) 빈 경로를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="92b1b20a2cb45b6fe0dfa5cf07ed62cbeefa5879" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty span whose &lt;code&gt;data() == nullptr&lt;/code&gt; and &lt;code&gt;size() == 0&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;extent == 0 || extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;data() == nullptr&lt;/code&gt; 및 &lt;code&gt;size() == 0&lt;/code&gt; 인 빈 범위를 구성 합니다 . &lt;code&gt;extent == 0 || extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt; 경우이 과부하는 과부하 해결에만 참여합니다. extent == std :: dynamic_extent .</target>
        </trans-unit>
        <trans-unit id="3c2ed7e86ad1634668a4421e8843d4216d314452" translate="yes" xml:space="preserve">
          <source>1) Constructs an end-of-stream iterator.</source>
          <target state="translated">1) 스트림 끝 반복자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="6a91b7a4528438ec1c732b76f2082be352aaa60b" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;T&lt;/code&gt; and wraps it in a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt; as the parameter list for the constructor of &lt;code&gt;T&lt;/code&gt;. The object is constructed as if by the expression &lt;code&gt;::new (pv) T(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;, where &lt;code&gt;pv&lt;/code&gt; is an internal &lt;code&gt;void*&lt;/code&gt; pointer to storage suitable to hold an object of type &lt;code&gt;T&lt;/code&gt;. The storage is typically larger than &lt;code&gt;sizeof(T)&lt;/code&gt; in order to use one allocation for both the control block of the shared pointer and the &lt;code&gt;T&lt;/code&gt; object. The &lt;code&gt;std::shared_ptr&lt;/code&gt; constructor called by this function enables &lt;code&gt;shared_from_this&lt;/code&gt; with a pointer to the newly constructed object of type &lt;code&gt;T&lt;/code&gt;. This overload only participates in overload resolution if T is not an array type</source>
          <target state="translated">1) 유형의 객체를 구축 &lt;code&gt;T&lt;/code&gt; 를 하고 그것을 감싸는 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 사용 &lt;code&gt;args&lt;/code&gt; 의 생성자 파라미터리스트로서 &lt;code&gt;T&lt;/code&gt; 를 . 객체는 &lt;code&gt;::new (pv) T(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; . 여기서 &lt;code&gt;pv&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 유형의 객체를 보유하기에 적합한 스토리지에 대한 내부 &lt;code&gt;void*&lt;/code&gt; 포인터입니다. . 공유 포인터의 제어 블록과 &lt;code&gt;T&lt;/code&gt; 객체 모두에 대해 하나의 할당을 사용하기 위해 스토리지는 일반적으로 &lt;code&gt;sizeof(T)&lt;/code&gt; 보다 큽니다 . &lt;code&gt;std::shared_ptr&lt;/code&gt; 이 함수를 호출 생성자 수 &lt;code&gt;shared_from_this&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 유형의 새로 구성된 객체에 대한 포인터 입니다. 이 과부하는 T가 배열 유형이 아닌 경우에만 과부하 해결에 참여합니다</target>
        </trans-unit>
        <trans-unit id="c65fce56c4a3fe00bfc3974bed79655a9cad1369" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;T&lt;/code&gt; and wraps it in a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt; as the parameter list for the constructor of &lt;code&gt;T&lt;/code&gt;. The object is constructed as if by the expression &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::construct(a, pv, v)&lt;/code&gt;, where &lt;code&gt;pv&lt;/code&gt; is an internal &lt;code&gt;void*&lt;/code&gt; pointer to storage suitable to hold an object of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is a copy of the allocator rebound to &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. The storage is typically larger than &lt;code&gt;sizeof(T)&lt;/code&gt; in order to use one allocation for both the control block of the shared pointer and the &lt;code&gt;T&lt;/code&gt; object. The &lt;code&gt;std::shared_ptr&lt;/code&gt; constructor called by this function enables &lt;code&gt;shared_from_this&lt;/code&gt; with a pointer to the newly constructed object of type &lt;code&gt;T&lt;/code&gt;. All memory allocation is done using a copy of &lt;code&gt;alloc&lt;/code&gt;, which must satisfy the &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirements. This overload only participates in overload resolution if T is not an array type</source>
          <target state="translated">1) 유형의 객체를 구축 &lt;code&gt;T&lt;/code&gt; 를 하고 그것을 감싸는 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 사용 &lt;code&gt;args&lt;/code&gt; 의 생성자 파라미터리스트로서 &lt;code&gt;T&lt;/code&gt; 를 . 객체는 &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::construct(a, pv, v)&lt;/code&gt; . 여기서 &lt;code&gt;pv&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 유형의 객체를 보유하기에 적합한 스토리지에 대한 내부 &lt;code&gt;void*&lt;/code&gt; 포인터 이며 &lt;code&gt;a&lt;/code&gt; 는 사본입니다. 할당 자의 리바운드는 &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; &amp;lt;T&amp;gt;로 리바운드됩니다 . 스토리지는 공유 포인터의 제어 블록과 &lt;code&gt;T&lt;/code&gt; 모두에 대해 하나의 할당을 사용하기 위해 일반적으로 &lt;code&gt;sizeof(T)&lt;/code&gt; 보다 큽니다.목적. &lt;code&gt;std::shared_ptr&lt;/code&gt; 이 함수를 호출 생성자 수 &lt;code&gt;shared_from_this&lt;/code&gt; 을 형의 새로 건설 된 개체에 대한 포인터와 &lt;code&gt;T&lt;/code&gt; . 모든 메모리 할당은 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; 요구 사항을 충족해야하는 &lt;code&gt;alloc&lt;/code&gt; 사본을 사용하여 수행됩니다 . 이 과부하는 T가 배열 유형이 아닌 경우에만 과부하 해결에 참여합니다</target>
        </trans-unit>
        <trans-unit id="d78eaa4f8c9d96c9388558353abf67888821bd40" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;std::condition_variable&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;std::condition_variable&lt;/code&gt; 유형의 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="c33554f7a405b880b69fcd197b5b45d0faf555d7" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;std::condition_variable_any&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;std::condition_variable_any&lt;/code&gt; 유형의 오브젝트를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="4dca4893623f5a9eb91426447332e43a629e5e08" translate="yes" xml:space="preserve">
          <source>1) Constructs an object that</source>
          <target state="translated">1) 객체를 생성</target>
        </trans-unit>
        <trans-unit id="a42c5463387778d35ce09fb74ca7c06a1d5d3fe5" translate="yes" xml:space="preserve">
          <source>1) Constructs empty container. Sets &lt;code&gt;max_load_factor()&lt;/code&gt; to 1.0. For the default constructor, the number of buckets is implementation-defined.</source>
          <target state="translated">1) 빈 컨테이너를 구성합니다. &lt;code&gt;max_load_factor()&lt;/code&gt; 를 1.0으로 설정합니다 . 기본 생성자의 경우 버킷 수는 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="cc74e3008936c370fbc2e91fcb346c72690c77ec" translate="yes" xml:space="preserve">
          <source>1) Constructs error code with default value. Equivalent to &lt;code&gt;error_code(0, &lt;a href=&quot;../system_category&quot;&gt;std::system_category&lt;/a&gt;())&lt;/code&gt;.</source>
          <target state="translated">1) 에러 코드를 기본값으로 구성합니다. 상당 &lt;code&gt;error_code(0, &lt;a href=&quot;../system_category&quot;&gt;std::system_category&lt;/a&gt;())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f925a3f60c069a032e3937c5003b55a8c2dfe979" translate="yes" xml:space="preserve">
          <source>1) Constructs objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage designated by the range &lt;code&gt;[first, last)&lt;/code&gt; by &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; 타입의 객체를 &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialization에&lt;/a&gt; 의해 &lt;code&gt;[first, last)&lt;/code&gt; 범위로 지정된 초기화되지 않은 스토리지 에</target>
        </trans-unit>
        <trans-unit id="5ca8d62a3455adf4d9e43d7b921708a6d8a9a285" translate="yes" xml:space="preserve">
          <source>1) Constructs objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage designated by the range &lt;code&gt;[first, last)&lt;/code&gt; by &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; 유형의 객체를 다음 과 같이 &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialization에&lt;/a&gt; 의해 &lt;code&gt;[first, last)&lt;/code&gt; 범위로 지정된 초기화되지 않은 스토리지 에 구성합니다.</target>
        </trans-unit>
        <trans-unit id="c7e73e079cc70c58b19eccb9290637293ccbae99" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;auto_ptr&lt;/code&gt; with pointer &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">1) 포인터 &lt;code&gt;p&lt;/code&gt; 로 &lt;code&gt;auto_ptr&lt;/code&gt; 을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="0164e8149e0956c863ac9c36b9359f6da1d2d078" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_istream&lt;/code&gt; object, assigning initial values to the base class by calling &lt;code&gt;basic_ios::init(sb)&lt;/code&gt;. The value of &lt;code&gt;gcount()&lt;/code&gt; is initialized to zero.</source>
          <target state="translated">1) &lt;code&gt;basic_ios::init(sb)&lt;/code&gt; 호출하여 기본 클래스에 초기 값을 할당 하여 &lt;code&gt;basic_istream&lt;/code&gt; 객체를 생성합니다 . &lt;code&gt;gcount()&lt;/code&gt; 의 값은 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="9f59a9d9a66d857f281383b9ee9838b4c7e8b9e9" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_ostream&lt;/code&gt; object, assigning initial values to the base class by calling &lt;code&gt;&lt;a href=&quot;../basic_ios/init&quot;&gt;basic_ios::init(sb)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../basic_ios/init&quot;&gt;basic_ios::init(sb)&lt;/a&gt;&lt;/code&gt; 호출하여 초기 값을 기본 클래스에 할당 하여 &lt;code&gt;basic_ostream&lt;/code&gt; 객체를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e770895769dd6c60169d7f4420f35a940b3c3d4d" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_streambuf&lt;/code&gt; object, initializes the six pointer members (&lt;code&gt;eback()&lt;/code&gt;, &lt;code&gt;gptr()&lt;/code&gt;, &lt;code&gt;egptr()&lt;/code&gt;, &lt;code&gt;pbase()&lt;/code&gt;, &lt;code&gt;pptr()&lt;/code&gt;, and &lt;code&gt;epptr()&lt;/code&gt;) to null pointer values, and the locale member to &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt;, a copy of the global C++ locale at the time of construction.</source>
          <target state="translated">1) &lt;code&gt;basic_streambuf&lt;/code&gt; 객체를 구성하고 6 개의 포인터 멤버 ( &lt;code&gt;eback()&lt;/code&gt; , &lt;code&gt;gptr()&lt;/code&gt; , &lt;code&gt;egptr()&lt;/code&gt; , &lt;code&gt;pbase()&lt;/code&gt; , &lt;code&gt;pptr()&lt;/code&gt; , &lt;code&gt;epptr()&lt;/code&gt; )를 널 포인터 값으로 초기화하고 로케일 멤버를 &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt; 로 초기화합니다 . : locale () 은 생성 당시의 글로벌 C ++ 로캘의 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="5a712e507b705a86029303f1b2e6b91abd34eca3" translate="yes" xml:space="preserve">
          <source>1) Constructs the complex number from real and imaginary parts.</source>
          <target state="translated">1) 실수 부와 허수 부로 복소수를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="4d3565cc629e222a14a77967cd93c38e99b2c25e" translate="yes" xml:space="preserve">
          <source>1) Constructs the end iterator.</source>
          <target state="translated">1) 종료 반복자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="36c43a3b623f36dd562263833f62942dcde59be1" translate="yes" xml:space="preserve">
          <source>1) Constructs the end-of-stream iterator, value-initializes the stored value. This constructor is constexpr if the initializer in the definition &lt;code&gt;auto x = T();&lt;/code&gt; is a constant initializer.</source>
          <target state="translated">1) 스트림 끝 반복자를 구성하고 저장된 값을 초기화합니다. 정의의 초기화가 &lt;code&gt;auto x = T();&lt;/code&gt; 경우이 생성자는 constexpr입니다 . 상수 이니셜 라이저입니다.</target>
        </trans-unit>
        <trans-unit id="567317c97bb9e808725c51c31daff371c53a7183" translate="yes" xml:space="preserve">
          <source>1) Constructs the iterator with &lt;code&gt;stream&lt;/code&gt; as the associated stream and &lt;code&gt;delim&lt;/code&gt; as the delimiter.</source>
          <target state="translated">1) &lt;code&gt;stream&lt;/code&gt; 을 관련 스트림으로, &lt;code&gt;delim&lt;/code&gt; er 를 분리 자로 반복자를 구성 합니다 .</target>
        </trans-unit>
        <trans-unit id="21e8282094e94dff47b05cfa55b86fa929f80bfb" translate="yes" xml:space="preserve">
          <source>1) Constructs the iterator with the private &lt;code&gt;streambuf_type*&lt;/code&gt; member set to &lt;code&gt;buffer&lt;/code&gt; and the failed() bit set to &lt;code&gt;false&lt;/code&gt;. The behavior is undefined if &lt;code&gt;buffer&lt;/code&gt; is a null pointer.</source>
          <target state="translated">1) private &lt;code&gt;streambuf_type*&lt;/code&gt; 멤버를 &lt;code&gt;buffer&lt;/code&gt; 로 설정 하고 failed () 비트를 &lt;code&gt;false&lt;/code&gt; 로 설정 하여 반복자를 구성합니다 . &lt;code&gt;buffer&lt;/code&gt; 가 널 포인터 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c0e385bee1b61c9f84d4023fcbdea59f912b0207" translate="yes" xml:space="preserve">
          <source>1) Constructs the mutex. The mutex is in unlocked state after the call.</source>
          <target state="translated">1) 뮤텍스를 구성합니다. 호출 후 뮤텍스는 잠금 해제 상태입니다.</target>
        </trans-unit>
        <trans-unit id="6facaef49db759622faeb9fa50ba66a91993a2b8" translate="yes" xml:space="preserve">
          <source>1) Constructs the mutex. The mutex is in unlocked state after the constructor completes.</source>
          <target state="translated">1) 뮤텍스를 구성합니다. 생성자가 완료된 후 뮤텍스는 잠금 해제 상태입니다.</target>
        </trans-unit>
        <trans-unit id="29377ade75ac8ee862d1d21eb062d5bb53a5931b" translate="yes" xml:space="preserve">
          <source>1) Constructs with error code &lt;code&gt;ec&lt;/code&gt;</source>
          <target state="translated">1) 에러 코드 &lt;code&gt;ec&lt;/code&gt; 로 구성</target>
        </trans-unit>
        <trans-unit id="0535a299ea56e25c15331c583b9b9f5ad995759c" translate="yes" xml:space="preserve">
          <source>1) Conversion that involves pointer to bool or pointer-to-member to bool is worse than the one that doesn't</source>
          <target state="translated">1) bool에 대한 포인터 또는 bool에 대한 포인터를 포함하는 변환은 그렇지 않은 것보다 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="e16d54f0bf7a4de50ea66eef76a20a090e2f4413" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;byte&lt;/code&gt; as if it was a string of length &lt;code&gt;1&lt;/code&gt; to wide_string.</source>
          <target state="translated">1) &lt;code&gt;byte&lt;/code&gt; 가 길이가 &lt;code&gt;1&lt;/code&gt; 인 문자열 인 것처럼 wide_string으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="197a10e3da9ede6e2bf81aba04bc89f7b2c98603" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;wchar&lt;/code&gt; as if it was a string of length &lt;code&gt;1&lt;/code&gt;, to &lt;code&gt;byte_string&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;wchar&lt;/code&gt; 를 길이가 &lt;code&gt;1&lt;/code&gt; 인 문자열 인 &lt;code&gt;byte_string&lt;/code&gt; 으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="ce60559adca1ecbc763b846b0ebcd3ea0bcd2729" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;T&amp;amp;&lt;/code&gt; as if by &lt;code&gt;T&amp;amp; t = &lt;a href=&quot;../../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(x);&lt;/code&gt;, then stores a reference to &lt;code&gt;t&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;typename &lt;a href=&quot;../../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;U&amp;gt;::type&lt;/code&gt; is not the same type as &lt;code&gt;reference_wrapper&lt;/code&gt; and the expression &lt;code&gt;FUN(&lt;a href=&quot;../../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; is well-formed, where &lt;code&gt;FUN&lt;/code&gt; names the set of imaginary functions</source>
          <target state="translated">1) &lt;code&gt;T&amp;amp; t = &lt;a href=&quot;../../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(x);&lt;/code&gt; &lt;a href=&quot;../../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;U&amp;gt; (x)에 의해 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;T&amp;amp;&lt;/code&gt; 로 변환합니다 . 그런 다음 &lt;code&gt;t&lt;/code&gt; 에 대한 참조를 저장합니다 . 이 과부하는 &lt;code&gt;typename &lt;a href=&quot;../../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;U&amp;gt;::type&lt;/code&gt; &lt;a href=&quot;../../../types/decay&quot;&gt;std :: decay&lt;/a&gt; &amp;lt;U&amp;gt; :: type 이 &lt;code&gt;reference_wrapper&lt;/code&gt; 와 동일한 유형이 아니고 &lt;code&gt;FUN(&lt;a href=&quot;../../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; &lt;a href=&quot;../../declval&quot;&gt;std :: declval&lt;/a&gt; &amp;lt;U&amp;gt; ()) 식이 제대로 구성되어있는 경우에만 과부하 해결에 참여 합니다 . &lt;code&gt;FUN&lt;/code&gt; 이름을 허수 함수 세트</target>
        </trans-unit>
        <trans-unit id="3b2e425231980e3b26025193db6c0158ff8d1aa6" translate="yes" xml:space="preserve">
          <source>1) Converts a signed decimal integer to a string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%d&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">1) 부호있는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%d&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에서 생성하는 내용과 동일한 내용의 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="8e981b67a7ad4cb8a3d3ec53bfb06c19e2cd41df" translate="yes" xml:space="preserve">
          <source>1) Converts a signed decimal integer to a wide string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%d&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">1) 부호있는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%d&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 를 생성 할 내용과 동일한 내용을 가진 넓은 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="4dc8e4275413329fa1e66540999bd4062579b6f2" translate="yes" xml:space="preserve">
          <source>1) Converts the &lt;code&gt;file_time&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to a &lt;code&gt;sys_time&lt;/code&gt; representing the same point in time.</source>
          <target state="translated">1) &lt;code&gt;file_time&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 를 동일한 시점을 나타내는 &lt;code&gt;sys_time&lt;/code&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="bbc6867b0f47d015a04ea763b2e464a464fd6f94" translate="yes" xml:space="preserve">
          <source>1) Converts the &lt;code&gt;file_time&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to a &lt;code&gt;utc_time&lt;/code&gt; representing the same point in time.</source>
          <target state="translated">1) &lt;code&gt;file_time&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 를 동일한 시점을 나타내는 &lt;code&gt;utc_time&lt;/code&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="076c6e693f308ce0f6a0c89dfaa4b7efdd201143" translate="yes" xml:space="preserve">
          <source>1) Converts the two durations to their common type and creates a duration whose tick count is the sum of the tick counts after conversion.</source>
          <target state="translated">1) 두 지속 시간을 공통 유형으로 변환하고 틱 수가 변환 후 틱 수의 합인 지속 시간을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="888ab527c89c913804d1c2c29b389f2611f52687" translate="yes" xml:space="preserve">
          <source>1) Copies &lt;code&gt;count&lt;/code&gt; elements from a range beginning at &lt;code&gt;first&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1) 복사본 &lt;code&gt;count&lt;/code&gt; 에서 시작 범위에서 요소 &lt;code&gt;first&lt;/code&gt; 에서 시작 초기화되지 않은 메모리 영역을 &lt;code&gt;d_first&lt;/code&gt; 같은 경우와</target>
        </trans-unit>
        <trans-unit id="a5b971875873e04ebbd8f3dd90705985a75d4ec9" translate="yes" xml:space="preserve">
          <source>1) Copies all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; starting from first and proceeding to last - 1. The behavior is undefined if &lt;code&gt;d_first&lt;/code&gt; is within the range &lt;code&gt;[first, last)&lt;/code&gt;. In this case, &lt;code&gt;&lt;a href=&quot;copy_backward&quot;&gt;std::copy_backward&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="translated">1) &lt;code&gt;[first, last)&lt;/code&gt; 시작하여 last-1 범위로 [first, last) 범위의 모든 요소를 ​​복사합니다 . &lt;code&gt;d_first&lt;/code&gt; 가 &lt;code&gt;[first, last)&lt;/code&gt; 범위 내에 있으면 동작이 정의되지 않습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;copy_backward&quot;&gt;std::copy_backward&lt;/a&gt;&lt;/code&gt; 가 대신 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06ea4d57b4c85fc6e7bcfe101f3b3fdc533f62f9" translate="yes" xml:space="preserve">
          <source>1) Copies characters in the range &lt;code&gt;[first,last)&lt;/code&gt; to &lt;code&gt;out&lt;/code&gt;, replacing any sequences that match &lt;code&gt;re&lt;/code&gt; with characters formatted by &lt;code&gt;fmt&lt;/code&gt;. In other words:</source>
          <target state="translated">범위 1) 복사 캐릭터 &lt;code&gt;[first,last)&lt;/code&gt; 에 &lt;code&gt;out&lt;/code&gt; 매치 임의 순서 교체 &lt;code&gt;re&lt;/code&gt; 문자 의해 포맷 &lt;code&gt;fmt&lt;/code&gt; . 다시 말해:</target>
        </trans-unit>
        <trans-unit id="3c0e21f1d72032ced3cf99d25a163352df8fb16d" translate="yes" xml:space="preserve">
          <source>1) Copies elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1) 범위에서 복사 소자 &lt;code&gt;[first, last)&lt;/code&gt; 는 초기화되지 않은 메모리 영역에서 시작 &lt;code&gt;d_first&lt;/code&gt; 에서처럼</target>
        </trans-unit>
        <trans-unit id="eaa8b895fbfe22af946e0d1f21d2e21b2ccbf6f4" translate="yes" xml:space="preserve">
          <source>1) Copies exactly &lt;code&gt;count&lt;/code&gt; values from the range beginning at &lt;code&gt;first&lt;/code&gt; to the range beginning at &lt;code&gt;result&lt;/code&gt;. Formally, for each non-negative integer &lt;code&gt;i &amp;lt; n&lt;/code&gt;, performs &lt;code&gt;*(result + i) = *(first + i)&lt;/code&gt;. Overlap of ranges is not permitted.</source>
          <target state="translated">1) 카피는 정확하게 &lt;code&gt;count&lt;/code&gt; 의 범위의 시작 값과 &lt;code&gt;first&lt;/code&gt; 에서 시작하는 범위 &lt;code&gt;result&lt;/code&gt; . 공식적으로, 음이 아닌 각 정수 &lt;code&gt;i &amp;lt; n&lt;/code&gt; 에 대해 &lt;code&gt;*(result + i) = *(first + i)&lt;/code&gt; 합니다. 범위의 중복은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2428bbef7516a0c37d09fb2808331b76c9c46ca3" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to another range beginning at &lt;code&gt;d_first&lt;/code&gt; in such a way that the elements in the new range are in reverse order.</source>
          <target state="translated">1) 새 범위의 요소가 역순이되도록 &lt;code&gt;[first, last)&lt;/code&gt; 범위에서 &lt;code&gt;d_first&lt;/code&gt; 에서 시작하는 다른 범위로 요소를 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="4614ab1a6d2346fd0652f2db85a8f495164eebe2" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to two different ranges depending on the value returned by the predicate &lt;code&gt;p&lt;/code&gt;. The elements that satisfy the predicate &lt;code&gt;p&lt;/code&gt; are copied to the range beginning at &lt;code&gt;d_first_true&lt;/code&gt;. The rest of the elements are copied to the range beginning at &lt;code&gt;d_first_false&lt;/code&gt;.</source>
          <target state="translated">1) 술어 &lt;code&gt;p&lt;/code&gt; 가 반환 한 값에 따라 &lt;code&gt;[first, last)&lt;/code&gt; 범위에서 두 개의 다른 범위로 요소를 복사합니다 . 술어 &lt;code&gt;p&lt;/code&gt; 를 만족시키는 요소 는 &lt;code&gt;d_first_true&lt;/code&gt; 에서 시작하는 범위로 복사됩니다 . 나머지 요소는 &lt;code&gt;d_first_false&lt;/code&gt; 에서 시작하는 범위로 복사됩니다. .</target>
        </trans-unit>
        <trans-unit id="98b63d2d9267bc9998d8406ce508196f6fbe30f0" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt;, to another range beginning at &lt;code&gt;d_first&lt;/code&gt; in such a way, that the element &lt;code&gt;n_first&lt;/code&gt; becomes the first element of the new range and &lt;code&gt;n_first - 1&lt;/code&gt; becomes the last element.</source>
          <target state="translated">1) &lt;code&gt;d_first&lt;/code&gt; 요소가 새 범위의 첫 번째 요소가되고 &lt;code&gt;n_first - 1&lt;/code&gt; 이 마지막 요소가되도록 &lt;code&gt;[first, last)&lt;/code&gt; 범위에서 d_first 에서 시작하는 다른 범위로 요소를 &lt;code&gt;n_first&lt;/code&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="84fa46dde26717bac9ce3f7378e2314898b8e7d1" translate="yes" xml:space="preserve">
          <source>1) Copies the given &lt;code&gt;value&lt;/code&gt; to an uninitialized memory area, defined by the range &lt;code&gt;[first, last)&lt;/code&gt; as if by</source>
          <target state="translated">1) 주어진 &lt;code&gt;value&lt;/code&gt; 을 초기화되지 않은 메모리 영역에 복사하고 , &lt;code&gt;[first, last)&lt;/code&gt; 범위로 정의합니다. 에서처럼</target>
        </trans-unit>
        <trans-unit id="3b6ae258a56e6dc4788e6367a261c4cc04b85921" translate="yes" xml:space="preserve">
          <source>1) Copies the given value &lt;code&gt;value&lt;/code&gt; to the first &lt;code&gt;count&lt;/code&gt; elements in an uninitialized memory area beginning at &lt;code&gt;first&lt;/code&gt; as if by</source>
          <target state="translated">1) 복사 주어진 값의 &lt;code&gt;value&lt;/code&gt; 상기 제에 &lt;code&gt;count&lt;/code&gt; 초기화되지 않은 메모리 영역의 요소에서 시작하여 &lt;code&gt;first&lt;/code&gt; 경우와 같게</target>
        </trans-unit>
        <trans-unit id="09509cf45826977c55e1dec4baf1527dc8caefbb" translate="yes" xml:space="preserve">
          <source>1) Copy assignment is not allowed.</source>
          <target state="translated">1) 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a5410a123be4ffd9084e19a34d5ec5f619c3034" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator is deleted, &lt;code&gt;std::packaged_task&lt;/code&gt; is move-only.</source>
          <target state="translated">1) 복사 지정 연산자가 삭제되고 &lt;code&gt;std::packaged_task&lt;/code&gt; 는 이동 전용입니다.</target>
        </trans-unit>
        <trans-unit id="2aca2d494628bc0ffa5751c1c324f784c030e885" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns each element of &lt;code&gt;other&lt;/code&gt; to the corresponding element of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) 복사 할당 연산자. &lt;code&gt;other&lt;/code&gt; 의 각 요소를 해당하는 &lt;code&gt;*this&lt;/code&gt; 요소에 지정 합니다 .</target>
        </trans-unit>
        <trans-unit id="8cc354b87930ded2400ee0d9fd474ddaa0df3e93" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns the contents of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1) 복사 할당 연산자. &lt;code&gt;other&lt;/code&gt; 의 내용을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="192e116d8a3105a5b39d34793a6599ce2a2b2376" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns the contents of &lt;code&gt;other&lt;/code&gt;. Equivalent to &lt;code&gt;assign(other);&lt;/code&gt;.</source>
          <target state="translated">1) 복사 할당 연산자. &lt;code&gt;other&lt;/code&gt; 의 내용을 할당합니다 . &lt;code&gt;assign(other);&lt;/code&gt; 와 동일 ; .</target>
        </trans-unit>
        <trans-unit id="dc11fa7946da37481c60d78d0a9d3a526f8a12a0" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Each element of &lt;code&gt;*this&lt;/code&gt; is assigned the value of the corresponding element of &lt;code&gt;other&lt;/code&gt;. If the length of &lt;code&gt;other&lt;/code&gt; does not equal the length of &lt;code&gt;*this&lt;/code&gt;,  the behavior is undefined(until C++11) first resizes as if by &lt;code&gt;resize(other.size())&lt;/code&gt;(since C++11).</source>
          <target state="translated">1) 복사 할당 연산자. &lt;code&gt;*this&lt;/code&gt; 의 각 요소 에는 &lt;code&gt;other&lt;/code&gt; 의 해당 요소 값이 할당됩니다 . 길이 경우 &lt;code&gt;other&lt;/code&gt; 길이 같지 않음 &lt;code&gt;*this&lt;/code&gt; , 동작이 정의되는 제 크기 변경 (11 ++ C까지)에 의해 마치 &lt;code&gt;resize(other.size())&lt;/code&gt; (11 ++ C입니다).</target>
        </trans-unit>
        <trans-unit id="36cd900ec1105ec865ef3f158da0f2320e8c8dbc" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;c = other.c; comp = other.comp;&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">1) 복사 할당 연산자. 내용을 &lt;code&gt;other&lt;/code&gt; 의 내용 사본으로 바꿉니다 . 효과적으로 &lt;code&gt;c = other.c; comp = other.comp;&lt;/code&gt; 호출합니다 . comp = other.comp; . (내재적으로 선언)</target>
        </trans-unit>
        <trans-unit id="a351a0527d89498a7bcb02cb3b6924c0e3fbd9ec" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;c = other.c;&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">1) 복사 할당 연산자. 내용을 &lt;code&gt;other&lt;/code&gt; 의 내용 사본으로 바꿉니다 . 효과적으로 &lt;code&gt;c = other.c;&lt;/code&gt; 호출합니다 .. (내재적으로 선언)</target>
        </trans-unit>
        <trans-unit id="0ad06eaa3c6a3a682c837daad2aa45d6956113f6" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;.If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the target allocator is replaced by a copy of the source allocator. If the target and the source allocators do not compare equal, the target (&lt;code&gt;*this&lt;/code&gt;) allocator is used to deallocate the memory, then &lt;code&gt;other&lt;/code&gt;'s allocator is used to allocate it before copying the elements.(since C++11).</source>
          <target state="translated">1) 복사 할당 연산자. 내용의 카피로 대체 컨텐츠를 &lt;code&gt;other&lt;/code&gt; .If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 목표 할당은 소스 할당의 복사본에 의해 대체된다. 대상과 소스 할당자가 동일하게 비교되지 않으면 대상 ( &lt;code&gt;*this&lt;/code&gt; ) 할당자는 메모리 할당을 해제하는 데 사용되고 &lt;code&gt;other&lt;/code&gt; 할당자는 요소를 복사하기 전에이를 할당하는 데 사용됩니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="1e0dbe7fed5c788b8dad718a8b915f89fb6eb4b1" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of other.</source>
          <target state="translated">1) 복사 할당 연산자. 내용을 다른 내용의 사본으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="7ee786d01693b06ebeb3b6d27fc4eca9ecd9d102" translate="yes" xml:space="preserve">
          <source>1) Creates an object of the given type &lt;code&gt;T&lt;/code&gt; by means of &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;uses-allocator construction&lt;/a&gt; at the uninitialized memory location indicated by p, using OUTERMOST as the allocator. After adjustment for uses-allocator convention expected by T's constructor, calls &lt;code&gt;OUTERMOST_ALLOC_TRAITS(*this)::construct&lt;/code&gt;.</source>
          <target state="translated">1) 소정의 유형의 객체 생성 &lt;code&gt;T&lt;/code&gt; 를 통해 &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;사용-할당 구조&lt;/a&gt; 초기화 된 메모리 위치에서의 할당으로 최를 사용하여 (P)에 의해 표시된. T의 생성자가 예상하는 사용 할당 자 규칙을 조정 한 후 &lt;code&gt;OUTERMOST_ALLOC_TRAITS(*this)::construct&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c2a543f321b7366feb622ab638584f7e34068656" translate="yes" xml:space="preserve">
          <source>1) Creates an object of the given type &lt;code&gt;U&lt;/code&gt; by means of &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;uses-allocator construction&lt;/a&gt; at the uninitialized memory location indicated by p, using &lt;code&gt;*this&lt;/code&gt; as the allocator. This overload only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;.(until C++20)</source>
          <target state="translated">1) 소정의 유형의 객체 생성 &lt;code&gt;U&lt;/code&gt; 를 이용하여 &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;사용-할당 구조&lt;/a&gt; 초기화되지 않은 메모리 위치를 사용하여 (P)로 나타낸 &lt;code&gt;*this&lt;/code&gt; 할당 자한다. 이 과부하 는 &lt;code&gt;U&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 의 전문화가 아닌 경우에만 과부하 해결에 참여 합니다 (C ++ 20까지).</target>
        </trans-unit>
        <trans-unit id="a9a98b74dec90269333d869db789c5323e20c4d2" translate="yes" xml:space="preserve">
          <source>1) Creates an optional object from &lt;code&gt;value&lt;/code&gt;. Effectively calls &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value))&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;value&lt;/code&gt; 에서 선택적 객체를 만듭니다 . 효과적으로 &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value))&lt;/code&gt; &amp;lt; &lt;a href=&quot;../../types/decay&quot;&gt;std :: decay_t&lt;/a&gt; &amp;lt;T &amp;gt;&amp;gt; ( &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;T&amp;gt; (value))를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c480710a43a80e8adcfecc3be2f3cd25cb1baa89" translate="yes" xml:space="preserve">
          <source>1) Creates and returns a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; object containing a copy of this &lt;code&gt;std::basic_stringbuf&lt;/code&gt;'s underlying character sequence. For input-only streams, the returned string contains the characters from the range &lt;code&gt;[eback(), egptr())&lt;/code&gt;. For input/output or output-only streams, contains the characters from &lt;code&gt;pbase()&lt;/code&gt; to the last character in the sequence regardless of &lt;code&gt;egptr()&lt;/code&gt; and &lt;code&gt;epptr()&lt;/code&gt;.</source>
          <target state="translated">1) 이 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 의 기본 문자 시퀀스의 사본을 포함 하는 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 객체를 작성 하고 리턴합니다 . 입력 전용 스트림의 경우 반환 된 문자열에는 &lt;code&gt;[eback(), egptr())&lt;/code&gt; 범위의 문자가 포함 됩니다. 입 / 출력 또는 출력 전용 스트림 의 경우 &lt;code&gt;egptr()&lt;/code&gt; 및 &lt;code&gt;epptr()&lt;/code&gt; 관계없이 &lt;code&gt;pbase()&lt;/code&gt; 에서 시퀀스의 마지막 문자 까지의 문자를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="a5389ceb0bc0b5a3365c91e4e5a33417369a0e1f" translate="yes" xml:space="preserve">
          <source>1) Creates new thread object which does not represent a thread.</source>
          <target state="translated">1) 스레드를 나타내지 않는 새 스레드 개체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0327a6fbad3860b481ce60cfaf07be7bf277056c" translate="yes" xml:space="preserve">
          <source>1) Creates the directory &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt; with a second argument of &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::all&lt;/a&gt;)&lt;/code&gt; (the parent directory must already exist). If the function fails because &lt;code&gt;p&lt;/code&gt; resolves to an existing directory, no error is reported. Otherwise on failure an error is reported.</source>
          <target state="translated">1) &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::all&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;perms&quot;&gt;std :: filesystem :: perms :: all&lt;/a&gt; ) 의 두 번째 인수를 사용하여 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html&quot;&gt; &lt;code&gt;mkdir()&lt;/code&gt; &lt;/a&gt; 의해 &lt;code&gt;p&lt;/code&gt; 디렉토리를 작성합니다 (부모 디렉토리가 이미 존재해야 함). &lt;code&gt;p&lt;/code&gt; 때문에 함수가 실패하면 가 기존 디렉토리로 해석되어 오류가보고되지 않습니다. 그렇지 않으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="bdf75898238d98a307ea5bb83b21e825fa5f14e6" translate="yes" xml:space="preserve">
          <source>1) Decimal integer literal (base 10, the first digit is the most significant)</source>
          <target state="translated">1) 10 진 정수 리터럴 (기수 10, 첫 번째 숫자가 가장 중요)</target>
        </trans-unit>
        <trans-unit id="2c073db79516e7eb32cc3d9bb547356532b4dc4d" translate="yes" xml:space="preserve">
          <source>1) Declaration of a default constructor inside of class definition.</source>
          <target state="translated">1) 클래스 정의 내부의 기본 생성자 선언.</target>
        </trans-unit>
        <trans-unit id="b4e1003653c1efe0f901decca5b2245ba63c2f97" translate="yes" xml:space="preserve">
          <source>1) Declares a named (formal) parameter. For the meanings of decl-specifier-seq and declarator, see &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;.</source>
          <target state="translated">1) 명명 된 (공식) 매개 변수를 선언합니다. 자명 한 일 입니 지정자-서열 및 선언자의 의미를 들어, 참조 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c4a1c3ae36aa2a523075a60794a76350d1cbb46" translate="yes" xml:space="preserve">
          <source>1) Declares a static data member.</source>
          <target state="translated">1) 정적 데이터 멤버를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="aef76cc087fec5259881aa2a31282705f7c15ad1" translate="yes" xml:space="preserve">
          <source>1) Declares a user-defined conversion function that participates in all &lt;a href=&quot;implicit_cast&quot;&gt;implicit&lt;/a&gt; and &lt;a href=&quot;explicit_cast&quot;&gt;explicit conversions&lt;/a&gt;</source>
          <target state="translated">1) 모든 &lt;a href=&quot;implicit_cast&quot;&gt;암시 적&lt;/a&gt; 및 참여에 참여하는 사용자 정의 변환 함수를 선언합니다.&lt;a href=&quot;explicit_cast&quot;&gt; 명시 적 변환에&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9bbb455cc0049834ffda69e633f84b7ffdce2f6" translate="yes" xml:space="preserve">
          <source>1) Declares an unscoped enumeration type whose underlying type is not fixed (in this case, the underlying type is an implementation-defined integral type that can represent all enumerator values; this type is not larger than &lt;code&gt;int&lt;/code&gt; unless the value of an enumerator cannot fit in an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt;. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0).</source>
          <target state="translated">1) 기본 유형이 고정되지 않은 범위가 지정되지 않은 열거 유형을 선언합니다 (이 경우 기본 유형은 모든 열거 자 값을 나타낼 수있는 구현 정의 정수 유형입니다.이 유형은 열거 자 값이 적합하지 않으면 &lt;code&gt;int&lt;/code&gt; 보다 크지 않습니다). 에 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;unsigned int&lt;/code&gt; 열거 목록이 비어있는 경우 열거 값 0)을 하나의 열거를 가진 것처럼., 기본 유형입니다.</target>
        </trans-unit>
        <trans-unit id="aad5551fd8cb89e8bb0fe35f15a0c5a90ee8d2c9" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves both the &lt;code&gt;std::chrono::weekday&lt;/code&gt; and the index value uninitialized.</source>
          <target state="translated">1) 기본 생성자는 &lt;code&gt;std::chrono::weekday&lt;/code&gt; 와 색인 값을 초기화하지 않은 상태로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="2428761890c8eee7869837b591a34b4aeb8dae13" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the date uninitialized.</source>
          <target state="translated">1) 기본 생성자는 날짜를 초기화하지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="499e023d2657c02b2972ab6ce587b2b5cf8946cd" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the day value uninitialized.</source>
          <target state="translated">1) 기본 생성자는 일 값을 초기화하지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="d7eaca31c34a6ae5693ef338f73e6bcd8c29ffb4" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the fields uninitialized.</source>
          <target state="translated">1) 기본 생성자는 필드를 초기화하지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="078562fd7069664d06229783df9c7e3002067686" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the month value uninitialized.</source>
          <target state="translated">1) 기본 생성자는 월 값을 초기화하지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="c36a47fb197929eeaca91e2ccaae79725f495a3f" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the object uninitialized.</source>
          <target state="translated">1) 기본 생성자는 객체를 초기화하지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="f177bc21211b9f9814da5723e9d7b52c483ab492" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the stored month and day values uninitialized.</source>
          <target state="translated">1) 기본 생성자는 저장된 월 및 일 값을 초기화하지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="2b51b3017e5534f01a4fcc3714ba6f3fcca53ace" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the weekday value uninitialized.</source>
          <target state="translated">1) 기본 생성자는 평일 값을 초기화하지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="0e624fa6115013ca80f6e91997dffec7202273f9" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the year and month uninitialized.</source>
          <target state="translated">1) 기본 생성자는 년과 월을 초기화되지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="131de4c9bed3f450ed7010d48d5a3fdb80330c32" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the year value uninitialized.</source>
          <target state="translated">1) 기본 생성자는 연도 값을 초기화하지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="9115058f2c43fa98792950ebe40f71f59fbd9aa0" translate="yes" xml:space="preserve">
          <source>1) Default constructor that calls (4) with &lt;code&gt;&lt;a href=&quot;../file_type&quot;&gt;std::filesystem::file_type::none&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../file_type&quot;&gt;std::filesystem::file_type::none&lt;/a&gt;&lt;/code&gt; (4)를 호출하는 기본 생성자 .</target>
        </trans-unit>
        <trans-unit id="e9d0e85becce06778b271a974bf41a26b72cc575" translate="yes" xml:space="preserve">
          <source>1) Default constructor, creates a &lt;code&gt;time_point&lt;/code&gt; representing the &lt;code&gt;Clock&lt;/code&gt;'s epoch (i.e., &lt;code&gt;&lt;a href=&quot;time_since_epoch&quot;&gt;time_since_epoch()&lt;/a&gt;&lt;/code&gt; is zero).</source>
          <target state="translated">1) 기본 생성자 . &lt;code&gt;Clock&lt;/code&gt; 의 신기원을 나타내는 &lt;code&gt;time_point&lt;/code&gt; 를 만듭니다 (즉, &lt;code&gt;&lt;a href=&quot;time_since_epoch&quot;&gt;time_since_epoch()&lt;/a&gt;&lt;/code&gt; 는 0입니다).</target>
        </trans-unit>
        <trans-unit id="ca62ce9ba5ae98ed6cfeefae6805879eef5662f6" translate="yes" xml:space="preserve">
          <source>1) Default constructor.</source>
          <target state="translated">1) 기본 생성자.</target>
        </trans-unit>
        <trans-unit id="4672d91b62baf7495b356cbf3fd2d4ab7185bb97" translate="yes" xml:space="preserve">
          <source>1) Default constructor. &lt;a href=&quot;../../language/value_initialization&quot;&gt;Value-initializes&lt;/a&gt; all elements.</source>
          <target state="translated">1) 기본 생성자. &lt;a href=&quot;../../language/value_initialization&quot;&gt;가치 초기화&lt;/a&gt;모든 요소를 합니다.</target>
        </trans-unit>
        <trans-unit id="2e8a32fa473b151fe2837e9a637eec271c2f495b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. &lt;a href=&quot;what&quot;&gt;&lt;code&gt;what()&lt;/code&gt;&lt;/a&gt; returns an implementation-defined string.</source>
          <target state="translated">1) 기본 생성자. &lt;a href=&quot;what&quot;&gt; &lt;code&gt;what()&lt;/code&gt; &lt;/a&gt; 은 구현 정의 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c75332d6c29abfeb6ab9132695635439c25e48b8" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a &lt;code&gt;std::future&lt;/code&gt; with no shared state. After construction, &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;valid()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;== false&lt;/code&gt;.</source>
          <target state="translated">1) 기본 생성자. 공유 상태가없는 &lt;code&gt;std::future&lt;/code&gt; 를 구성합니다 . 생성 후 &lt;a href=&quot;valid&quot;&gt; &lt;code&gt;valid()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;== false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79261dde24b2758d36f9430c665e3f176df44f39" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a bitset with all bits set to zero.</source>
          <target state="translated">1) 기본 생성자. 모든 비트가 0으로 설정된 비트 세트를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="011ecb3fe17914dffa88456a32eaa298e263e47b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a copy of the global C++ locale, which is the locale most recently used as the argument to &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; or a copy of &lt;code&gt;&lt;a href=&quot;classic&quot;&gt;std::locale::classic&lt;/a&gt;&lt;/code&gt; if no call to &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; has been made.</source>
          <target state="translated">1) 기본 생성자. 가장 최근에 인수로 사용되는 로케일 글로벌 C ++ 로케일의 사본 구축 &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; 또는 사본 &lt;code&gt;&lt;a href=&quot;classic&quot;&gt;std::locale::classic&lt;/a&gt;&lt;/code&gt; 없이 호출 할 경우 &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; 없습니다 만들어졌다.</target>
        </trans-unit>
        <trans-unit id="895580b59835cf3ea8b8e9ef9fcc3a2446be6649" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a variant holding the &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; value of the first alternative (&lt;a href=&quot;index&quot;&gt;&lt;code&gt;index()&lt;/code&gt;&lt;/a&gt; is zero). This constructor is &lt;code&gt;constexpr&lt;/code&gt; if and only if the value initialization of the alternative type T_0 would satisfy the requirements for a &lt;a href=&quot;../../language/constexpr&quot;&gt;constexpr function&lt;/a&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;T_0&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1) 기본 생성자. 첫 번째 대안 의 &lt;a href=&quot;../../language/value_initialization&quot;&gt;값으로 초기화 된&lt;/a&gt; 값을 보유하는 변형을 구성합니다 ( &lt;a href=&quot;index&quot;&gt; &lt;code&gt;index()&lt;/code&gt; &lt;/a&gt; 는 0 임). 대체 생성자 T_0의 값 초기화가 &lt;a href=&quot;../../language/constexpr&quot;&gt;constexpr 함수에&lt;/a&gt; 대한 요구 사항을 충족하는 경우에만 이 생성자는 &lt;code&gt;constexpr&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;T_0&amp;gt;&lt;/code&gt; &amp;lt;T_0&amp;gt; 인 경우이 과부하는 과부하 해결에만 참여합니다. 이 (가) true 인 합니다.</target>
        </trans-unit>
        <trans-unit id="9d0e5fa5fa920ac3791488de3b572932835b95ee" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty &lt;code&gt;basic_string_view&lt;/code&gt;. After construction, &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;nullptr&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">1) 기본 생성자. 빈 &lt;code&gt;basic_string_view&lt;/code&gt; 를 구성 합니다. 건조 후에, &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; 와 동일하다 &lt;code&gt;nullptr&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 와 동일하다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eacc35685d23a4fecd10da59ea5f06868759d796" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty container. If no allocator is supplied, allocator is obtained from a default-constructed instance.</source>
          <target state="translated">1) 기본 생성자. 빈 컨테이너를 구성합니다. 할당자가 제공되지 않으면 할당자는 기본 생성 인스턴스에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6c17b4644d6ac209e7f22c17144138b18c5931e9" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty numeric array.</source>
          <target state="translated">1) 기본 생성자. 빈 숫자 형 배열을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="de0ff732be5a241f66c48250f820f0547487440b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty regular expression which will match nothing.</source>
          <target state="translated">1) 기본 생성자. 아무것도 일치하지 않는 빈 정규식을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="e669d70f06155beb00ecca03586e5c258a586219" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty shared future, that doesn't refer to a shared state, that is &lt;code&gt;valid() == false&lt;/code&gt;.</source>
          <target state="translated">1) 기본 생성자. 공유 상태를 나타내지 않는 빈 공유 미래를 구성합니다. 즉, &lt;code&gt;valid() == false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7565190dee6671c76d3a56a2e2e2a2350105a5f5" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an end iterator.</source>
          <target state="translated">1) 기본 생성자. 엔드 이터레이터를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="cb5ed3cd804429aa2c7dde21da7ca9ead64884cb" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an end-of-sequence iterator.</source>
          <target state="translated">1) 기본 생성자. 시퀀스 종료 반복자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="9cd879bc1abea042190566e8fd2e0be2513b8de1" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs empty &lt;code&gt;weak_ptr&lt;/code&gt;.</source>
          <target state="translated">1) 기본 생성자. 빈 &lt;code&gt;weak_ptr&lt;/code&gt; 을 생성합니다 합니다.</target>
        </trans-unit>
        <trans-unit id="8f5913ec53e778795e8ead732e87ecf9cfcfc151" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs empty string (zero size and unspecified capacity). If no allocator is supplied, allocator is obtained from a default-constructed instance.</source>
          <target state="translated">1) 기본 생성자. 빈 문자열 (제로 크기 및 지정되지 않은 용량)을 구성합니다. 할당자가 제공되지 않으면 할당자는 기본 생성 인스턴스에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fea889f6b10c364b364bead59870fc1ead08d127" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs new underlying string device with the default open mode</source>
          <target state="translated">1) 기본 생성자. 기본 열기 모드로 새로운 기본 문자열 장치를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="47dfb990d09b6cf7741d11d703850522bdd37ac1" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the distribution with a single weight p={1}. This distribution will always generate &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1) 기본 생성자. 단일 가중치 p = {1}로 분포를 구성합니다. 이 배포판은 항상 생성합니다 &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e80f107318c31b0c58e6aeef75360f44ffd05c03" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the end-of-sequence iterator.</source>
          <target state="translated">1) 기본 생성자. 시퀀스 종료 반복자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="5bf185507087fc694124074f527682377e4e4b06" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the promise with an empty shared state.</source>
          <target state="translated">1) 기본 생성자. 빈 공유 상태로 약속을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="25239fa19574ad09c0768600521365122e69a28f" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Equivalent to &lt;code&gt;gslice(0, &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(), &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;())&lt;/code&gt;. This constructor exists only to allow construction of arrays of slices.</source>
          <target state="translated">1) 기본 생성자. 상당 &lt;code&gt;gslice(0, &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(), &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;())&lt;/code&gt; . 이 생성자는 슬라이스 배열을 생성 할 수 있도록하기 위해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="25b86c4ec98dd08e9433550d3d731d786fa40f88" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Equivalent to &lt;code&gt;slice(0, 0, 0)&lt;/code&gt;. This constructor exists only to allow construction of arrays of slices.</source>
          <target state="translated">1) 기본 생성자. 상당 &lt;code&gt;slice(0, 0, 0)&lt;/code&gt; . 이 생성자는 슬라이스 배열을 생성 할 수 있도록하기 위해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="0f2c9964918fbbbec4b2a2f80259c25e38ce89a5" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Initializes the error condition with generic category and error code &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1) 기본 생성자. 일반 범주 및 오류 코드 &lt;code&gt;​0​&lt;/code&gt; 오류 조건을 초기화합니다. .</target>
        </trans-unit>
        <trans-unit id="a16bc65a9c0bb02a38efb33e034e628db8375633" translate="yes" xml:space="preserve">
          <source>1) Default constructor. It is implementation-defined whether the sequence pointers (&lt;code&gt;eback()&lt;/code&gt;, &lt;code&gt;gptr()&lt;/code&gt;, &lt;code&gt;egptr()&lt;/code&gt;, &lt;code&gt;pbase()&lt;/code&gt;, &lt;code&gt;pptr()&lt;/code&gt;, &lt;code&gt;epptr()&lt;/code&gt;) are initialized to null pointers.</source>
          <target state="translated">1) 기본 생성자. 시퀀스 포인터 ( &lt;code&gt;eback()&lt;/code&gt; , &lt;code&gt;gptr()&lt;/code&gt; , &lt;code&gt;egptr()&lt;/code&gt; , &lt;code&gt;pbase()&lt;/code&gt; , &lt;code&gt;pptr()&lt;/code&gt; , &lt;code&gt;epptr()&lt;/code&gt; )가 널 포인터로 초기화 입니다.</target>
        </trans-unit>
        <trans-unit id="18cc22e95dd49ea3310825efa9be211fee3b3c2f" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Seeds the engine with &lt;code&gt;default_seed&lt;/code&gt;.</source>
          <target state="translated">1) 기본 생성자. 엔진 씨앗 &lt;code&gt;default_seed&lt;/code&gt; 로 .</target>
        </trans-unit>
        <trans-unit id="1a1f3b78577783b96afca946ecfdb044a2e2fe03" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Stores an exception object obtained by calling &lt;code&gt;&lt;a href=&quot;../current_exception&quot;&gt;std::current_exception&lt;/a&gt;()&lt;/code&gt; within the new &lt;code&gt;nested_exception&lt;/code&gt; object.</source>
          <target state="translated">1) 기본 생성자. 새 내에 &lt;code&gt;&lt;a href=&quot;../current_exception&quot;&gt;std::current_exception&lt;/a&gt;()&lt;/code&gt; 을 호출하여 얻은 예외 객체를 저장합니다. &lt;code&gt;nested_exception&lt;/code&gt; 객체 합니다.</target>
        </trans-unit>
        <trans-unit id="8a32db41a403e2f63a4fd28475b603a4ec46df42" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The internal state is not initialized. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init()&lt;/a&gt;&lt;/code&gt; must be called before the first use of the object or before destructor, otherwise the behavior is undefined.</source>
          <target state="translated">1) 기본 생성자. 내부 상태가 초기화되지 않았습니다. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init()&lt;/a&gt;&lt;/code&gt; 객체를 처음 사용하기 전에 또는 소멸자 전에 를 호출해야합니다. 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55062aaea6619514669480e39506ff7c999ff520" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The underlying engine is also default-constructed.</source>
          <target state="translated">1) 기본 생성자. 기본 엔진도 기본 구성입니다.</target>
        </trans-unit>
        <trans-unit id="15f4029d373e079f41db83cdd93169d4f5785dcf" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The underlying iterator is value-initialized. Operations on the resulting iterator have defined behavior if and only if the corresponding operations on a value-initialized &lt;code&gt;Iterator&lt;/code&gt; also have defined behavior.</source>
          <target state="translated">1) 기본 생성자. 기본 반복자는 값으로 초기화됩니다. 값으로 초기화 된 &lt;code&gt;Iterator&lt;/code&gt; 에 해당하는 조작에 동작이 정의 된 경우에만 결과 반복자에 대한 조작이 동작을 정의했습니다.</target>
        </trans-unit>
        <trans-unit id="2a9d616bbf3734e2be9b10dbac57548362a533dd" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes both elements of the pair, &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;.</source>
          <target state="translated">1) 기본 생성자. 쌍의 두 요소 ( &lt;code&gt;first&lt;/code&gt; 및 &lt;code&gt;second&lt;/code&gt; )를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="d50a8b3aca03c89f83a8e00c8035cce2b2f943dc" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes the comparator and the underlying container.</source>
          <target state="translated">1) 기본 생성자. 비교기와 기본 컨테이너의 값을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="d57453057acaf238aba5d7c9f55019284642f9be" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes the container.</source>
          <target state="translated">1) 기본 생성자. 컨테이너를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="85aa7b5f36dda27d22e0568ece5d170840dd6df4" translate="yes" xml:space="preserve">
          <source>1) Default constructor: constructs a stream that is not associated with a file: default-constructs the &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; and constructs the base with the pointer to this default-constructed &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; member.</source>
          <target state="translated">1) 기본 생성자 : 파일과 연관되지 않은 스트림을 구성합니다. default는 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 를 구성하고이 기본 구성 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 대한 포인터를 사용하여 기본을 구성합니다. 멤버에 합니다.</target>
        </trans-unit>
        <trans-unit id="3cab7b4fb28e5286d6fa395d1c88c741664448fe" translate="yes" xml:space="preserve">
          <source>1) Default constructor: value-initializes the &lt;code&gt;OuterAlloc&lt;/code&gt; base class and the inner allocator member object, if used by the implementation.</source>
          <target state="translated">1) 기본 생성자 : 구현에서 사용하는 경우 &lt;code&gt;OuterAlloc&lt;/code&gt; 기본 클래스와 내부 할당 자 멤버 개체를 값으로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="f147745323c3c84fec33aec7c8557ca0d3395b0a" translate="yes" xml:space="preserve">
          <source>1) Default constructs a new &lt;code&gt;&lt;a href=&quot;../random_device&quot;&gt;std::random_device&lt;/a&gt;&lt;/code&gt; object with an implementation-defined &lt;code&gt;token&lt;/code&gt;.</source>
          <target state="translated">1) 기본적 으로 구현 정의 &lt;code&gt;token&lt;/code&gt; 으로 새로운 &lt;code&gt;&lt;a href=&quot;../random_device&quot;&gt;std::random_device&lt;/a&gt;&lt;/code&gt; 객체를 생성합니다. .</target>
        </trans-unit>
        <trans-unit id="3d254d4e4e041dda90a59631d7b2960792e803ef" translate="yes" xml:space="preserve">
          <source>1) Default-constructor. Constructs a match result with no established result state (&lt;code&gt;ready() != true&lt;/code&gt;).</source>
          <target state="translated">1) 기본 생성자. 설정된 결과 상태가없는 일치 결과를 생성합니다 ( &lt;code&gt;ready() != true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1af4fb69cdbe20bca957ea5aab4e348af2793199" translate="yes" xml:space="preserve">
          <source>1) Default-constructs the underlying &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;, which creates a dynamically growing buffer, and initializes the base class with the address of the strstreambuf member.</source>
          <target state="translated">1) 기본 &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 기본 구성 를 생성하여 동적으로 증가하는 버퍼를 만들고 strstreambuf 멤버의 주소로 기본 클래스를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="7d13af42ec3f2ddb8462a572d1b26587eccb3d92" translate="yes" xml:space="preserve">
          <source>1) Default-initializes &lt;code&gt;base_&lt;/code&gt; and &lt;code&gt;pred_&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;base_&lt;/code&gt; 와 &lt;code&gt;pred_&lt;/code&gt; 를 기본값으로 초기화합니다</target>
        </trans-unit>
        <trans-unit id="1ac5a4d8f549ae70b68112a4ef17cd868cd57e69" translate="yes" xml:space="preserve">
          <source>1) Default-initializes &lt;code&gt;value_&lt;/code&gt; and &lt;code&gt;bound_&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;value_&lt;/code&gt; 와 &lt;code&gt;bound_&lt;/code&gt; 를 기본값으로 초기화합니다</target>
        </trans-unit>
        <trans-unit id="b1dbaabdc4ff6b70020a151bf2e9abc440948c50" translate="yes" xml:space="preserve">
          <source>1) Defaulted copy assignment operator. Copy-assigns both the stored time point and the stored time zone pointer. &lt;code&gt;zoned_time&lt;/code&gt; has no move assignment operator; a move is a copy.</source>
          <target state="translated">1) 기본 복사 할당 연산자. 저장된 시간대와 저장된 시간대 포인터를 모두 복사 할당합니다. &lt;code&gt;zoned_time&lt;/code&gt; 에는 이동 할당 연산자가 없습니다. 이동은 사본입니다.</target>
        </trans-unit>
        <trans-unit id="78b7cc430f5922607ee43272f394fa79b6ed0bac" translate="yes" xml:space="preserve">
          <source>1) Define a non-member swap in the enclosing namespace, which may forward to a member swap if access to non-public data members is required</source>
          <target state="translated">1) 엔 클로징 네임 스페이스에서 비 멤버 스왑을 정의합니다. 비공개 네임 스페이스에 액세스해야하는 경우 멤버 스왑으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7de1a6f8b3cc0594b28dcfd6a8f7980d955fbbc" translate="yes" xml:space="preserve">
          <source>1) Defines a</source>
          <target state="translated">1) 정의</target>
        </trans-unit>
        <trans-unit id="c6408478c098043618abdb9b577727df78dd08ab" translate="yes" xml:space="preserve">
          <source>1) Definition of an enumeration type.</source>
          <target state="translated">1) 열거 형의 정의.</target>
        </trans-unit>
        <trans-unit id="ebbd2ad38e5fa6237bba264cce1284f0bd1cec2c" translate="yes" xml:space="preserve">
          <source>1) Denormalization loss: the delivered result differs from what would have been computed were exponent range unbounded.</source>
          <target state="translated">1) 비정규 화 손실 : 전달 된 결과는 지수 범위가 제한되지 않은 것으로 계산 된 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4a1bd34fda9394675a66721b9472df8d48990386" translate="yes" xml:space="preserve">
          <source>1) Designates a function or several functions as friends of this class</source>
          <target state="translated">1)이 클래스의 친구로 기능 또는 여러 기능을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="cda85d78ffc7280c614df8e23678c3c173935a15" translate="yes" xml:space="preserve">
          <source>1) Destroys one non-array object created by a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;</source>
          <target state="translated">1) &lt;a href=&quot;new&quot;&gt;새로운 표현식으로&lt;/a&gt; 생성 된 하나의 비 배열 객체를 파괴</target>
        </trans-unit>
        <trans-unit id="2cba7eb8d44c15125cdc52986458ca13f73ba7d1" translate="yes" xml:space="preserve">
          <source>1) Destroys the &lt;code&gt;n&lt;/code&gt; objects in the range starting at &lt;code&gt;first&lt;/code&gt;, as if by</source>
          <target state="translated">1) 마치 &lt;code&gt;first&lt;/code&gt; 부터 시작하는 범위에서 &lt;code&gt;n&lt;/code&gt; 개의 객체를 파기합니다.</target>
        </trans-unit>
        <trans-unit id="f998857faa7d72f442a5b64bb7bd57852afbb2f4" translate="yes" xml:space="preserve">
          <source>1) Destroys the iterator, including the cached value.</source>
          <target state="translated">1) 캐시 된 값을 포함하여 반복자를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a3f6de15f76b6e6f118c50c482f5797660572e61" translate="yes" xml:space="preserve">
          <source>1) Destroys the objects in the range &lt;code&gt;[first, last)&lt;/code&gt;, as if by</source>
          <target state="translated">한) 범위의 객체를 파기 &lt;code&gt;[first, last)&lt;/code&gt; 에 의해 마치</target>
        </trans-unit>
        <trans-unit id="8e3aa580452b25d9999027f1b3cb229e40ec1851" translate="yes" xml:space="preserve">
          <source>1) Detects if the current thread has a live exception object, that is, an exception has been thrown or rethrown and not yet entered a matching catch clause, &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;. In other words, &lt;code&gt;std::uncaught_exception&lt;/code&gt; detects if &lt;a href=&quot;../../language/throw#Stack_unwinding&quot;&gt;stack unwinding&lt;/a&gt; is currently in progress.</source>
          <target state="translated">1) 현재 스레드에 라이브 예외 오브젝트가 있는지, 즉 예외가 발생하거나 다시 발생하여 일치하는 catch 절 ( &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 입력되지 않았는지 감지 합니다. 즉, &lt;code&gt;std::uncaught_exception&lt;/code&gt; 은 &lt;a href=&quot;../../language/throw#Stack_unwinding&quot;&gt;스택 해제&lt;/a&gt; 가 현재 진행 중인지를 감지합니다 .</target>
        </trans-unit>
        <trans-unit id="df7a3ba6b3fba13efda3c048c64afee201d66f99" translate="yes" xml:space="preserve">
          <source>1) Determines if the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt; is implemented lock-free, as if by calling &lt;code&gt;obj-&amp;gt;is_lock_free()&lt;/code&gt;. In any given program execution, the result of the lock-free query is the same for all pointers of the same type.</source>
          <target state="translated">1) &lt;code&gt;obj-&amp;gt;is_lock_free()&lt;/code&gt; 호출하는 것처럼 &lt;code&gt;obj&lt;/code&gt; 가 가리키는 원자 객체 가 잠금이없는 상태로 구현되는지 확인합니다 . 주어진 프로그램 실행에서, 잠금없는 조회의 결과는 동일한 유형의 모든 포인터에 대해 동일합니다.</target>
        </trans-unit>
        <trans-unit id="91e01796abcfa6eddc0b11eb63b158b9aba3771c" translate="yes" xml:space="preserve">
          <source>1) Determines if there is a match between the regular expression &lt;code&gt;e&lt;/code&gt; and the entire target character sequence &lt;code&gt;[first,last)&lt;/code&gt;, taking into account the effect of &lt;code&gt;flags&lt;/code&gt;. When determining if there is a match, only potential matches that match the entire character sequence are considered. Match results are returned in &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;flags&lt;/code&gt; 의 영향을 고려하여 정규 표현식 &lt;code&gt;e&lt;/code&gt; 와 전체 대상 문자 시퀀스 &lt;code&gt;[first,last)&lt;/code&gt; 사이에 일치가 있는지 판별합니다 . 일치하는 것이 있는지 판별 할 때 전체 문자 순서와 일치하는 잠재적 일치 만 고려됩니다. 일치 결과는 &lt;code&gt;m&lt;/code&gt; 으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b58fdc599cf255bac2ae50522ea05922284c1bea" translate="yes" xml:space="preserve">
          <source>1) Determines the type and attributes of the filesystem object identified by &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed to their targets). In the following description, &lt;code&gt;prms&lt;/code&gt; is the result of &lt;code&gt;(m &amp;amp; perms::mask)&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is obtained as if by taking &lt;code&gt;st_mode&lt;/code&gt; from the POSIX &lt;code&gt;struct stat&lt;/code&gt; and converting it to the type &lt;code&gt;&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;p&lt;/code&gt; 에 의해 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat에&lt;/a&gt; 의해 식별 된 것처럼 파일 시스템 오브젝트의 유형 및 속성을 판별합니다 (기호가 대상에 따라). 다음 설명에서 &lt;code&gt;prms&lt;/code&gt; 는 &lt;code&gt;(m &amp;amp; perms::mask)&lt;/code&gt; 의 결과입니다 . 여기서 &lt;code&gt;m&lt;/code&gt; 은 POSIX &lt;code&gt;struct stat&lt;/code&gt; 에서 &lt;code&gt;st_mode&lt;/code&gt; 를 가져 와서 &lt;code&gt;&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms&lt;/a&gt;&lt;/code&gt; 유형으로 변환 하는 것처럼 얻 습니다 .</target>
        </trans-unit>
        <trans-unit id="6a44ae052e348f0eb5abeb579d93acfea11ea715" translate="yes" xml:space="preserve">
          <source>1) Determines whether &lt;code&gt;Fn&lt;/code&gt; can be invoked with the arguments &lt;code&gt;ArgTypes...&lt;/code&gt;. Formally, determines whether &lt;code&gt;INVOKE(declval&amp;lt;Fn&amp;gt;(), declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; is well formed when treated as an unevaluated operand, where &lt;code&gt;INVOKE&lt;/code&gt; is the operation defined in &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;.</source>
          <target state="translated">1) &lt;code&gt;ArgTypes...&lt;/code&gt; 인수로 &lt;code&gt;Fn&lt;/code&gt; 을 호출 할 수 있는지 여부를 결정합니다 . 공식적으로, 평가되지 않은 피연산자로 취급 될 때 &lt;code&gt;INVOKE(declval&amp;lt;Fn&amp;gt;(), declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; 가 제대로 형성 되는지 여부를 판별합니다 . 여기서 &lt;code&gt;INVOKE&lt;/code&gt; 는 &lt;a href=&quot;../named_req/callable&quot;&gt;Callable에&lt;/a&gt; 정의 된 조작 입니다.</target>
        </trans-unit>
        <trans-unit id="ca298188df78ab4f447d54b4bad5cd57815e3fe1" translate="yes" xml:space="preserve">
          <source>1) Determines whether atomic access to the shared pointer pointed-to by &lt;code&gt;p&lt;/code&gt; is lock-free.</source>
          <target state="translated">1) &lt;code&gt;p&lt;/code&gt; 가 가리키는 공유 포인터에 대한 원자 적 액세스 가 잠금이 없는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="65005f1a4f1673e794ca8fd566db8cadc1934b30" translate="yes" xml:space="preserve">
          <source>1) Does not throw</source>
          <target state="translated">1) 던지지 않는다</target>
        </trans-unit>
        <trans-unit id="fab8fda7614e477a6f71346517837d8a3e567c5f" translate="yes" xml:space="preserve">
          <source>1) Each element is assigned value obtained by applying the corresponding operator to the previous value of the element and corresponding element from &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">1) 각 요소에는 해당 연산자를 이전 요소 값과 &lt;code&gt;v&lt;/code&gt; 의 해당 요소에 적용하여 얻은 값이 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a8ff4bbb77a97d615fec33736a3f814af766ce7" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::const_mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1) 효과적으로 &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::const_mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="31e828b09b6dcd4b69af6c0189e9702fd814cda6" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::const_mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::const_mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; )를 효과적으로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="46acfc8106489874b0a683e5cfada60e0e48401e" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;pointer_to_unary_function&quot;&gt;std::pointer_to_unary_function&lt;/a&gt;&amp;lt;Arg,Result&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1) 효과적으로 &lt;code&gt;&lt;a href=&quot;pointer_to_unary_function&quot;&gt;std::pointer_to_unary_function&lt;/a&gt;&amp;lt;Arg,Result&amp;gt;(f)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c7400b67aeeb319d2c89e9f0544cebe1005e1706" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;c.push_back(value); &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std::push_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt;</source>
          <target state="translated">1) 효과적으로 &lt;code&gt;c.push_back(value); &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std::push_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt; 호출합니다 . &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std :: push_heap&lt;/a&gt; (c.begin (), c.end (), comp);</target>
        </trans-unit>
        <trans-unit id="8d470e4c140bedbd34a1126e97e4400dc788fa04" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;c.push_back(value)&lt;/code&gt;</source>
          <target state="translated">1) 효과적으로 &lt;code&gt;c.push_back(value)&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="011d1f5ba60bd9d74dea06b316bbfe4e137bcdaa" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;f(read_symlink(from), to)&lt;/code&gt; where &lt;code&gt;f&lt;/code&gt; is &lt;a href=&quot;create_symlink&quot;&gt;&lt;code&gt;create_symlink&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;create_symlink&quot;&gt;&lt;code&gt;create_directory_symlink&lt;/code&gt;&lt;/a&gt; depending on whether &lt;code&gt;from&lt;/code&gt; resolves to a file or directory.</source>
          <target state="translated">1)를 효과적으로 호출 &lt;code&gt;f(read_symlink(from), to)&lt;/code&gt; 여기서 &lt;code&gt;f&lt;/code&gt; 는 이다 &lt;a href=&quot;create_symlink&quot;&gt; &lt;code&gt;create_symlink&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;create_symlink&quot;&gt; &lt;code&gt;create_directory_symlink&lt;/code&gt; &lt;/a&gt; 여부에 따라 &lt;code&gt;from&lt;/code&gt; 확인되는 파일 또는 디렉토리.</target>
        </trans-unit>
        <trans-unit id="e2c0e9b14b9519968975e29f74ca4f737cc3b463" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;m.lock()&lt;/code&gt;. The behavior is undefined if &lt;code&gt;m&lt;/code&gt; is not a recursive mutex and the current thread already owns &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1) 효과적으로 &lt;code&gt;m.lock()&lt;/code&gt; 호출합니다 . &lt;code&gt;m&lt;/code&gt; 이 재귀 뮤텍스가 아니고 현재 스레드가 이미 &lt;code&gt;m&lt;/code&gt; 을 소유 한 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8fbed931d739878efe2242dc69e3c3ec188c93c6" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;reset(r.release())&lt;/code&gt;.</source>
          <target state="translated">1) 효과적으로 &lt;code&gt;reset(r.release())&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="588791ac3459488ee09ba487973c4664a54285ba" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator&amp;lt;&lt;/code&gt; and the ranges must be sorted with respect to the same.</source>
          <target state="translated">1) &lt;code&gt;operator&amp;lt;&lt;/code&gt; 사용하여 요소를 비교 하고 범위는 동일하게 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cc3c33d923eee557c7b587363c490e22bf00f05" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;operator&amp;lt;&lt;/code&gt; 사용하여 요소를 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="0d09f5debbd2155a625dbd1f35e701b7e3c2ab3b" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator==&lt;/code&gt;.</source>
          <target state="translated">1) 요소는 &lt;code&gt;operator==&lt;/code&gt; 사용하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc915779f9828f296793ebde353de4de9e382deb" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator==&lt;/code&gt;. The behavior is undefined if it is not an &lt;a href=&quot;https://en.wikipedia.org/wiki/equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;.</source>
          <target state="translated">1) 요소는 &lt;code&gt;operator==&lt;/code&gt; 사용하여 비교됩니다 . &lt;a href=&quot;https://en.wikipedia.org/wiki/equivalence_relation&quot;&gt;동치 관계&lt;/a&gt; 가 아닌 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="05030b7bb4349fc087ee762a2cc6879e74372695" translate="yes" xml:space="preserve">
          <source>1) Enables the &lt;code&gt;boolalpha&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::boolalpha&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::boolalpha&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: boolalpha&lt;/a&gt; )를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;boolalpha&lt;/code&gt; 플래그를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="96a972a826ee3fcdba20885c2506d308930acc88" translate="yes" xml:space="preserve">
          <source>1) Equality operator for variants:</source>
          <target state="translated">1) 변형에 대한 평등 연산자 :</target>
        </trans-unit>
        <trans-unit id="82f9550a944d3a8df60f3b265cda2b488c9da5d5" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + d;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;*this = *this + d;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41d083e1f8110bfe1557758d4d4695c37d622fdb" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + dy;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;*this = *this + dy;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ce04fa95ba678e6e255c69e3ebde6576457d731" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + y;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;*this = *this + y;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d9406b90ecb5fc7caa6afd7e187ab3217839eea" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;++d_; return *this;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;++d_; return *this;&lt;/code&gt; 와 같습니다 . return * this;</target>
        </trans-unit>
        <trans-unit id="2f1d88d98b52d4717f7dcfd15653a17e454989f4" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;++rep_; return *this;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;++rep_; return *this;&lt;/code&gt; 와 같습니다 . return * this;</target>
        </trans-unit>
        <trans-unit id="9c52d71237ed4fde0f7863911f0865e168009fdf" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_days&lt;/a&gt;(year()/month()/day())&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_days&lt;/a&gt;(year()/month()/day())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aace9380526b20cb700bec8018bdc6d389438aec" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;Iter tmp = current; return *--tmp;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;Iter tmp = current; return *--tmp;&lt;/code&gt; 와 동일합니다 . tmp = current; return *-tmp;</target>
        </trans-unit>
        <trans-unit id="2aaf37e2ad0a4d3314a70e8a4edea0af77b29fd6" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;bool(*this) ? **this : static_cast&amp;lt;T&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(default_value))&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;bool(*this) ? **this : static_cast&amp;lt;T&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(default_value))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27ca6cdc924e29f6abac7e6f89eb8af6bc1cf7bd" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;default_error_condition(code) == condition&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;default_error_condition(code) == condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaf68a0e9a1753e7c451d7db374905454c1660ab" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;emplace&amp;lt;I&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;, where &lt;code&gt;I&lt;/code&gt; is the zero-based index of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;std::is_constructible_v&amp;lt;T, Args...&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; occurs exactly once in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;emplace&amp;lt;I&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; 와 같습니다. 여기서 &lt;code&gt;I&lt;/code&gt; 은 &lt;code&gt;Types...&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 의 0부터 시작하는 인덱스입니다 . &lt;code&gt;std::is_constructible_v&amp;lt;T, Args...&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Types...&lt;/code&gt; 에서 정확히 한 번만 발생하는 경우이 과부하는 과부하 해결에만 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="0c1e7f7def0b0c1e4bc97e06e0f684adad56ecd5" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;exists(s) &amp;amp;&amp;amp; !is_regular_file(s) &amp;amp;&amp;amp; !is_directory(s) &amp;amp;&amp;amp; !is_symlink(s)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;exists(s) &amp;amp;&amp;amp; !is_regular_file(s) &amp;amp;&amp;amp; !is_directory(s) &amp;amp;&amp;amp; !is_symlink(s)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d3c543a72231a15ed9a65b4120bd54a699a7d90c" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;lhs.equal(rhs)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;lhs.equal(rhs)&lt;/code&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6f78f1b1933f2be104c9b36333cbd8655ec420b2" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;native().c_str()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;native().c_str()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5960311674c16cc0cc1bf3867e9d05c22ddeb540" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;rep_ += d.count(); return *this;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;rep_ += d.count(); return *this;&lt;/code&gt; )와 동일 ; return * this;</target>
        </trans-unit>
        <trans-unit id="9df00ac4a641d9e8760432c2ae7533cb453b1bce" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return !&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;return !&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; 동일합니다 ! &lt;a href=&quot;invoke&quot;&gt;std :: invoke&lt;/a&gt; (fd, &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;Args&amp;gt; (args) ...)</target>
        </trans-unit>
        <trans-unit id="d36ac7d6e30651e85b700452df731bf1029a32f0" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return &lt;a href=&quot;../any&quot;&gt;std::any&lt;/a&gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;return &lt;a href=&quot;../any&quot;&gt;std::any&lt;/a&gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt; ( &lt;a href=&quot;../in_place&quot;&gt;std :: in_place_type&lt;/a&gt; &amp;lt;T&amp;gt;, &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;Args&amp;gt; (args) ...) 를 반환하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="47f69e5f8468517d7589e267f72b1dbbba5c3293" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return D(*this);&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;return D(*this);&lt;/code&gt; 를 반환하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="783946ea6f8a3464885e40163c1c9564f4ceea63" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return r.begin();&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;return r.begin();&lt;/code&gt; 을 반환하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3f4fc870674f5fb012dd975ee57837cfeab7d645" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::block&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;s.type() == file_type::block&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b1ed7de20f555f8534e2a84d964c966bd9d5cde" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::character&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;s.type() == file_type::character&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="897ad8584bbbaddb6b9248b6dea56350ebb88d4c" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::directory&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;s.type() == file_type::directory&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a63e546b555f8572521590a9d2ea549dc2ae2235" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::fifo&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;s.type() == file_type::fifo&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="98720eb9c80b5e9a08ada8eb5db1b51aa2e92d32" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::regular&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;s.type() == file_type::regular&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="05305515a6902b55a79c88270ce56bc514f70239" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::socket&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;s.type() == file_type::socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab8b95a7b2ea4746283ea27160065e146ccff49a" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::symlink&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;s.type() == file_type::symlink&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="179ac5c7fc855225a87152301381a704450b6c4a" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;static_cast&amp;lt;reference&amp;gt;(*base())&lt;/code&gt;;</source>
          <target state="translated">1) &lt;code&gt;static_cast&amp;lt;reference&amp;gt;(*base())&lt;/code&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="538ab1915dd3230391d766df1b4a3748da3f84c1" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;status_known(s) &amp;amp;&amp;amp; s.type() != file_type::not_found&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;status_known(s) &amp;amp;&amp;amp; s.type() != file_type::not_found&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8fb771283367cf610ecf5e023e663a4fe8645b" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;std::move(*base())&lt;/code&gt;;</source>
          <target state="translated">1) &lt;code&gt;std::move(*base())&lt;/code&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8df252cd519d51da4b9b18b92bb448ad32a642e9" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;transform_reduce(first1, last1, first2, init, std::plus&amp;lt;&amp;gt;(), std::multiplies&amp;lt;&amp;gt;());&lt;/code&gt;, effectively parallelized version of the default &lt;code&gt;&lt;a href=&quot;inner_product&quot;&gt;std::inner_product&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;transform_reduce(first1, last1, first2, init, std::plus&amp;lt;&amp;gt;(), std::multiplies&amp;lt;&amp;gt;());&lt;/code&gt; 기본 &lt;code&gt;&lt;a href=&quot;inner_product&quot;&gt;std::inner_product&lt;/a&gt;&lt;/code&gt; 의 효과적으로 병렬화 된 버전</target>
        </trans-unit>
        <trans-unit id="8a1464ca469f44a3064f6e7b09b363ce619c9a97" translate="yes" xml:space="preserve">
          <source>1) Equivalent to:</source>
          <target state="translated">1)</target>
        </trans-unit>
        <trans-unit id="f32c1f81db0f32f22596c137532eaf553b842a7b" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return b = b &amp;lt;&amp;lt; shift;&lt;/code&gt; This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1) 다음과 같습니다 : &lt;code&gt;return b = b &amp;lt;&amp;lt; shift;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; 이 true 인 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="ce50226b3eed2748aea0ee2f4a0f21490b16d346" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return l = l | r;&lt;/code&gt;.</source>
          <target state="translated">1) 다음과 같습니다. &lt;code&gt;return l = l | r;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a824e001a18c6b6d534ce889aabe17e30fbd0108" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(b) &amp;lt;&amp;lt; shift);&lt;/code&gt; This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1) 다음과 같습니다. &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(b) &amp;lt;&amp;lt; shift);&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; 이 true 인 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="50ddbf3ee011e6961ef6494bf423ec3c2c018228" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) | static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt;.</source>
          <target state="translated">1) 다음과 같습니다. &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) | static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b33dd7c481fdd2621d129a0b3503bdf96a3c1775" translate="yes" xml:space="preserve">
          <source>1) Erases all elements that compare equal to &lt;code&gt;value&lt;/code&gt; from the container. Equivalent to &lt;code&gt;c.erase(std::remove(c.begin(), c.end(), value), c.end());&lt;/code&gt;</source>
          <target state="translated">1) 컨테이너의 &lt;code&gt;value&lt;/code&gt; 과 동일한 모든 요소를 ​​지 웁니다 . 상당 &lt;code&gt;c.erase(std::remove(c.begin(), c.end(), value), c.end());&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cb1efcdcc78f435229d9add9af0fde373e753a3" translate="yes" xml:space="preserve">
          <source>1) Erases all elements that compare equal to &lt;code&gt;value&lt;/code&gt; from the container. Equivalent to &lt;code&gt;c.remove_if([&amp;amp;](auto&amp;amp; elem) { return elem == value; });&lt;/code&gt;</source>
          <target state="translated">1) 컨테이너의 &lt;code&gt;value&lt;/code&gt; 과 동일한 모든 요소를 ​​지 웁니다 . 상당 &lt;code&gt;c.remove_if([&amp;amp;](auto&amp;amp; elem) { return elem == value; });&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1797656c42e6ae99b3e7edb8a97b39fe346fd5bd" translate="yes" xml:space="preserve">
          <source>1) Evaluates the expression, terminates the current function and returns the result of the expression to the caller, after &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; to the function return type. The expression is optional in functions whose return type is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, and disallowed in constructors and in destructors.</source>
          <target state="translated">1) 표현식을 평가하고 현재 함수를 종료 한 후 함수 리턴 유형으로 &lt;a href=&quot;implicit_cast&quot;&gt;내재적으로 변환&lt;/a&gt; 한 후 표현식 결과를 호출자 에게 리턴합니다. 반환 유형이 (cv-qualified) &lt;code&gt;void&lt;/code&gt; 인 함수 에서 생성자 는 선택 사항 이며 생성자와 소멸자에서는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a7dddb18cbda7dbc3e902e0510c2c2998153f38" translate="yes" xml:space="preserve">
          <source>1) Exactly &lt;code&gt;N&lt;/code&gt; applications of the predicate and &lt;code&gt;O(N)&lt;/code&gt; swaps if there is enough extra memory. If memory is insufficient, at most &lt;code&gt;N log N&lt;/code&gt; swaps.</source>
          <target state="translated">1) 추가 메모리가 충분하면 술어의 정확히 &lt;code&gt;N&lt;/code&gt; 응용 프로그램과 &lt;code&gt;O(N)&lt;/code&gt; 스왑. 메모리가 부족하면 최대 &lt;code&gt;N log N&lt;/code&gt; 스왑됩니다.</target>
        </trans-unit>
        <trans-unit id="d85c974f9fac4ed00ac82960b3a7f736c51ad8ce" translate="yes" xml:space="preserve">
          <source>1) Exactly N applications of the predicate. At most N/2 swaps if &lt;code&gt;ForwardIt&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, and at most N swaps otherwise.</source>
          <target state="translated">1) 술어의 정확히 N 개의 응용 프로그램. &lt;code&gt;ForwardIt&lt;/code&gt; 이 &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; 의 요구 사항을 충족하는 경우 최대 N / 2 스왑 , 그렇지 않으면 최대 N 스왑</target>
        </trans-unit>
        <trans-unit id="3898a5e907961e19d6f3818b3f6c38e485189ef0" translate="yes" xml:space="preserve">
          <source>1) Exchanges elements between range &lt;code&gt;[first1, last1)&lt;/code&gt; and another range starting at &lt;code&gt;first2&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;[first1, last1)&lt;/code&gt; 범위와 &lt;code&gt;first2&lt;/code&gt; 에서 시작하는 다른 범위 사이에서 요소를 교환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2cd67e4d55cd7feca04c7b3f2ebf39800dd11361" translate="yes" xml:space="preserve">
          <source>1) Explicit instantiation definition</source>
          <target state="translated">1) 명시 적 인스턴스화 정의</target>
        </trans-unit>
        <trans-unit id="06804e68db44d5febdac7eef45d88e3b0a1f984d" translate="yes" xml:space="preserve">
          <source>1) Explicit instantiation definition (without &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; if every non-default template parameter is explicitly specified)</source>
          <target state="translated">1) 명시 적 인스턴스화 정의 ( 기본이 아닌 모든 템플리트 매개 변수가 명시 적으로 지정된 경우 &lt;a href=&quot;template_argument_deduction&quot;&gt;템플리트 인수 공제&lt;/a&gt; 없이 )</target>
        </trans-unit>
        <trans-unit id="e49d0053d14d536a2855f480783e3fc7be7596bc" translate="yes" xml:space="preserve">
          <source>1) Explicitly defaulted copy assignment operator that copy assigns the base class (&lt;code&gt;OuterAlloc&lt;/code&gt;, the outer allocator) and all inner allocators.</source>
          <target state="translated">1) copy가 기본 클래스 ( &lt;code&gt;OuterAlloc&lt;/code&gt; , 외부 할당 자) 및 모든 내부 할당자를 할당하는 명시 적으로 기본 복사 할당 연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="a4749611efc7cb267b48bb41ce78225481d0be01" translate="yes" xml:space="preserve">
          <source>1) Fancy pointer overload: If the expression &lt;code&gt;&lt;a href=&quot;pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&amp;lt;Ptr&amp;gt;::to_address(p)&lt;/code&gt; is well-formed, returns the result of that expression. Otherwise, returns &lt;code&gt;std::to_address(p.operator-&amp;gt;())&lt;/code&gt;.</source>
          <target state="translated">1) 팬시 포인터 과부하 : 표현식 &lt;code&gt;&lt;a href=&quot;pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&amp;lt;Ptr&amp;gt;::to_address(p)&lt;/code&gt; 가 올바르게 구성된 경우 해당 표현식의 결과를 리턴합니다. 그렇지 않으면 &lt;code&gt;std::to_address(p.operator-&amp;gt;())&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7990d512de136056ee815911efb4602f71ddedef" translate="yes" xml:space="preserve">
          <source>1) File permissions information.</source>
          <target state="translated">1) 파일 권한 정보.</target>
        </trans-unit>
        <trans-unit id="27c1e10d4c10af58dfddd5cff99066596a87eea5" translate="yes" xml:space="preserve">
          <source>1) File type information.</source>
          <target state="translated">1) 파일 형식 정보</target>
        </trans-unit>
        <trans-unit id="f4fc5fa63bf321ae1e98780408b5986c98eb7933" translate="yes" xml:space="preserve">
          <source>1) Finds the first character equal to none of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str&lt;/code&gt; 의 문자가없는 첫 번째 문자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="7e79c22b35aadf16bbb2bbdbbd059e4bce47a02e" translate="yes" xml:space="preserve">
          <source>1) Finds the first character equal to one of the characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str&lt;/code&gt; 의 문자 중 하나와 동일한 첫 번째 문자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="442f6a60a472a2e1141c1b6fb37c658af721c0e6" translate="yes" xml:space="preserve">
          <source>1) Finds the first character not equal to any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;pos&lt;/code&gt; 위치에서 시작하여이보기에서 &lt;code&gt;v&lt;/code&gt; 의 문자와 같지 않은 첫 번째 문자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="51cda46cabb3895bd9df4ec43f3daadbc2f64384" translate="yes" xml:space="preserve">
          <source>1) Finds the first occurence of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;pos&lt;/code&gt; 위치에서 시작하여이보기에서 &lt;code&gt;v&lt;/code&gt; 의 첫 번째 발생을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="fd62aaa68509bd9a4fb9fb278bc9c7d8c255380a" translate="yes" xml:space="preserve">
          <source>1) Finds the first occurence of any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;pos&lt;/code&gt; 위치에서 시작하여이보기에서 &lt;code&gt;v&lt;/code&gt; 문자 중 첫 번째 발생을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="991eb68c46670361f174f149c9bbff9453009cbe" translate="yes" xml:space="preserve">
          <source>1) Finds the first substring equal to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str&lt;/code&gt; 과 동일한 첫 번째 하위 문자열을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="6704dbd43b3ce3882e6b0b77ffcd5282c0cd6ca9" translate="yes" xml:space="preserve">
          <source>1) Finds the last character equal to none of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str&lt;/code&gt; 의 문자가없는 마지막 문자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="ce86bceaea369df79d331c69a11951d70d544899" translate="yes" xml:space="preserve">
          <source>1) Finds the last character equal to one of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str&lt;/code&gt; 의 문자 중 하나와 동일한 마지막 문자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="70fd55a6b81aaf507648a0cddd92b8c633cda844" translate="yes" xml:space="preserve">
          <source>1) Finds the last character not equal to any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;pos&lt;/code&gt; 위치에서 시작하여이보기에서 &lt;code&gt;v&lt;/code&gt; 의 문자와 같지 않은 마지막 문자를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="7a117a35d4790c36ea6419c73a7d006ccff236b7" translate="yes" xml:space="preserve">
          <source>1) Finds the last occurence of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;pos&lt;/code&gt; 위치에서 시작하여이보기에서 &lt;code&gt;v&lt;/code&gt; 의 마지막 발생을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="950316330142526c0ea12d1cb0ce500d7d27ceb8" translate="yes" xml:space="preserve">
          <source>1) Finds the last occurence of any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, ending at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;pos&lt;/code&gt; 위치에서 끝나는이보기에서 &lt;code&gt;v&lt;/code&gt; 문자 중 마지막 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="cc6591ef2b8655c84fe527417b8508f21209a752" translate="yes" xml:space="preserve">
          <source>1) Finds the last substring equal to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str&lt;/code&gt; 과 동일한 마지막 부분 문자열을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="bfb87cff99851f1a19a7bc551155598781e3afd7" translate="yes" xml:space="preserve">
          <source>1) First calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; to close the associated file, then moves the contents of &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;: the put and get buffers, the associated file, the locale, the openmode, the is_open flag, and any other state. After the move, &lt;code&gt;rhs&lt;/code&gt; is not associated with a file and &lt;code&gt;rhs.is_open() == false&lt;/code&gt;.</source>
          <target state="translated">1) 먼저 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 를 호출 하여 관련 파일을 닫은 다음 &lt;code&gt;rhs&lt;/code&gt; 의 내용 을 &lt;code&gt;*this&lt;/code&gt; : put 및 get 버퍼, 관련 파일, 로케일, 열기 모드, is_open 플래그 및 기타 상태로 이동합니다. 이동 후 &lt;code&gt;rhs&lt;/code&gt; 는 파일 및 &lt;code&gt;rhs.is_open() == false&lt;/code&gt; 와 연관되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dd18b72a5a285015ba6ec06d12d8ef6d1cba7955" translate="yes" xml:space="preserve">
          <source>1) First converts &lt;code&gt;f&lt;/code&gt; to some temporary value &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../../locale/ctype_base&quot;&gt;std::ctype_base::mask&lt;/a&gt;&lt;/code&gt; in implementation-defined manner</source>
          <target state="translated">1) 먼저 구현 정의 방식으로 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../locale/ctype_base&quot;&gt;std::ctype_base::mask&lt;/a&gt;&lt;/code&gt; 유형의 임시 값 &lt;code&gt;m&lt;/code&gt; 으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="66258cec208a65037d1db76ff3382868c359cbe4" translate="yes" xml:space="preserve">
          <source>1) First, &lt;a href=&quot;copy_initialization&quot;&gt;copy-initializes&lt;/a&gt; the</source>
          <target state="translated">1) 먼저, &lt;a href=&quot;copy_initialization&quot;&gt;복사를 초기화&lt;/a&gt; 합니다</target>
        </trans-unit>
        <trans-unit id="cd33253b53a6763ed072481c1c0f67e8204b5635" translate="yes" xml:space="preserve">
          <source>1) First, decl-specifier-seq and the declarator are combined as in any &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; to determine the type.</source>
          <target state="translated">1) 우선, 않거나 계산 지정자-SEQ와 선언자은 어느 조합 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 유형을 결정한다.</target>
        </trans-unit>
        <trans-unit id="24a19262c4d1f80ce9e0dc9caab9f79a6b0bff5b" translate="yes" xml:space="preserve">
          <source>1) Flips all bits (like &lt;code&gt;&lt;a href=&quot;operator_logic&quot;&gt;operator~&lt;/a&gt;&lt;/code&gt;, but in-place)</source>
          <target state="translated">1) 모든 비트를 뒤집습니다 ( &lt;code&gt;&lt;a href=&quot;operator_logic&quot;&gt;operator~&lt;/a&gt;&lt;/code&gt; 와 같지만 제자리에 있음)</target>
        </trans-unit>
        <trans-unit id="5300a7112838d676f5f66db26a00a4959307ece8" translate="yes" xml:space="preserve">
          <source>1) Floating point value identifying the &amp;alpha; parameter</source>
          <target state="translated">1) &amp;alpha; 파라미터를 식별하는 부동 소수점 값</target>
        </trans-unit>
        <trans-unit id="0e6b85b611c8ca2ab85cbbefdb0db71abdb9bd30" translate="yes" xml:space="preserve">
          <source>1) For an object of type X using the class member access operator</source>
          <target state="translated">1) 클래스 멤버 액세스 연산자를 사용하는 X 유형의 오브젝트</target>
        </trans-unit>
        <trans-unit id="620d62ba1adcb76635cafe39e1be9ff044838905" translate="yes" xml:space="preserve">
          <source>1) For arguments of fundamental type, the associated set of namespaces and classes is empty</source>
          <target state="translated">1) 기본 유형의 인수의 경우 연관된 네임 스페이스 및 클래스 세트가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c378136ab43e1fdcea07a911ec40f85b088db94" translate="yes" xml:space="preserve">
          <source>1) For every named variable with static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;that is not subject to &lt;a href=&quot;constant_initialization&quot;&gt;constant initialization&lt;/a&gt;(since C++14), before any other initialization.</source>
          <target state="translated">1) 다른 초기화 전에 정적 &lt;a href=&quot;constant_initialization&quot;&gt;초기화&lt;/a&gt; 또는 스레드 로컬 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간&lt;/a&gt; 이있는 모든 명명 된 변수 (C ++ 14 이후)가 초기화 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a2228ff5f261316a14c0c628f07410bc975495de" translate="yes" xml:space="preserve">
          <source>1) For the built-in operator, one of the expressions (either expr1 or expr2) must be a glvalue of type &amp;ldquo;array of T&amp;rdquo; or a prvalue of type &amp;ldquo;pointer to T&amp;rdquo;, while the other expression (expr2 or expr1, respectively) must be a prvalue of unscoped enumeration or integral type. The result of this expression has the type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">1) 내장 연산자의 경우, 표현식 중 하나 (expr1 또는 expr2)는 &quot;T의 배열&quot;유형의 glvalue 또는 &quot;pointer to T&quot;유형의 prvalue 여야하며 다른 표현식 (expr2 또는 expr1, 범위가 지정되지 않은 열거 형 또는 정수 유형의 값이어야합니다. 이 표현식의 결과는 &lt;code&gt;T&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="908b6cc5f8feeba46b723cf8345b6e77ca24c647" translate="yes" xml:space="preserve">
          <source>1) For user-defined integer literals</source>
          <target state="translated">1) 사용자 정의 정수 리터럴</target>
        </trans-unit>
        <trans-unit id="8f2bdea671ba63209e8908fa5f60f318cc0d7593" translate="yes" xml:space="preserve">
          <source>1) Forms lvalue reference to const type of &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;t&lt;/code&gt; 의 const 유형에 대한 lvalue 참조 양식</target>
        </trans-unit>
        <trans-unit id="10e52e4189c8c4f69c3b43f760a5733f16a0cecd" translate="yes" xml:space="preserve">
          <source>1) Forwards lvalues as either lvalues or as rvalues, depending on T</source>
          <target state="translated">1) T에 따라 lvalue를 lvalue 또는 rvalue로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="0aa251b9780dd1a068e6af33ad51fdab09a9b853" translate="yes" xml:space="preserve">
          <source>1) Full declaration.</source>
          <target state="translated">1) 완전한 선언.</target>
        </trans-unit>
        <trans-unit id="d52437442bfb9b172705dc9281744b3b9dabeae9" translate="yes" xml:space="preserve">
          <source>1) Given &lt;code&gt;current_ptr&lt;/code&gt;, the pointer that was managed by &lt;code&gt;*this&lt;/code&gt;, performs the following actions, in this order:</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 에 의해 관리되는 포인터 인 &lt;code&gt;current_ptr&lt;/code&gt; 이 주어지면 다음 순서로 다음 조치를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c25bb4537de07ca2e9c955609fc621b56b5c86ae" translate="yes" xml:space="preserve">
          <source>1) Half the sum of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. No overflow occurs. If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have integer type and the sum is odd, the result is rounded towards &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have floating-point type, at most one inexact operation occurs.</source>
          <target state="translated">1) &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 합의 절반 . 오버플로가 발생하지 않습니다. 경우 및 &lt;code&gt;b&lt;/code&gt; 는 정수형을 가지고 합 홀수, 결과적으로 반올림 . &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 에 부동 소수점 유형이 있으면 최대 하나의 부정확 한 연산이 발생합니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="389c5e318417b817814b4e4cfab6dc113e1fc480" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;*this&lt;/code&gt; contains a value before the call, the contained value is destroyed by calling its destructor as if by &lt;code&gt;value().T::~T()&lt;/code&gt;. &lt;code&gt;*this&lt;/code&gt; does not contain a value after this call.</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 에 호출 전의 값 이 포함되어 있으면, &lt;code&gt;value().T::~T()&lt;/code&gt; 처럼 소멸자를 호출하여 포함 된 값이 소멸됩니다 . &lt;code&gt;*this&lt;/code&gt; 호출 후 값은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c29eb73572b5b54b5bde81bc8cece3cd885b3b2" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt; is not satisfied, the copy assignment operator's body is equivalent to &lt;code&gt;if (other) emplace(*other); else reset(); return *this;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt; 가 충족되지 않으면, 복사 할당 운영자의 본문은 &lt;code&gt;if (other) emplace(*other); else reset(); return *this;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d43ce007d320a6fcb3a66694c64b2aa6772b3c7" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; stores a copy of the caught exception and if the copy constructor of the exception object caught by &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; throws an exception, the captured exception is an instance of &lt;code&gt;std::bad_exception&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 이 포착 된 예외의 사본을 저장하고 &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; 의해 포착 된 예외 오브젝트의 복사 생성자가 예외를 throw하면 캡처 된 예외는 &lt;code&gt;std::bad_exception&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="871b74ba2e944632eb24642e2095fcaae5540862" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공 하고 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2558dfd99cfdc502e01a5c094f7431492308ad2e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;P&lt;/code&gt; is a reference type, the deduced &lt;code&gt;A&lt;/code&gt; (i.e., the type referred to by the reference) can be more cv-qualified than the transformed &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">1) &lt;code&gt;P&lt;/code&gt; 가 참조 유형 인 경우 추론 된 &lt;code&gt;A&lt;/code&gt; (즉 참조에 의해 참조되는 유형)는 변환 된 &lt;code&gt;A&lt;/code&gt; 보다 cv-qualified 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6b573b161e778f9527a59ca867befe70e44b598" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;P&lt;/code&gt; is not a reference type,</source>
          <target state="translated">1) &lt;code&gt;P&lt;/code&gt; 가 참조 유형이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="6f224d7d59ccb2a0648c9f79474f4f6215450b64" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; for some type &lt;code&gt;U&lt;/code&gt;, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names &lt;code&gt;U&amp;amp;&lt;/code&gt;; otherwise, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) 경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; 어떤 타입 &lt;code&gt;U&lt;/code&gt; , typedef에 부재를 제공하는 &lt;code&gt;type&lt;/code&gt; 그 이름 &lt;code&gt;U&amp;amp;&lt;/code&gt; ; 그렇지 않으면 이름이 &lt;code&gt;T&lt;/code&gt; 인 멤버 typedef &lt;code&gt;type&lt;/code&gt; 을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="533c4f52ff1cea4318aa8c59d1192a5f19648e8c" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 1) &lt;code&gt;T&lt;/code&gt; 가 참조 형식이고, 부재의 제공 상수 &lt;code&gt;value&lt;/code&gt; 과 동일 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46015a38f56b223eca9255c907b1367791f0fb7e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is an object or reference type and the variable definition &lt;code&gt;T obj(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...);&lt;/code&gt; is well-formed, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. In all other cases, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;T&lt;/code&gt; 가 객체 또는 참조 유형이고 변수 정의 &lt;code&gt;T obj(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...);&lt;/code&gt; 올바른 형식이며 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공 합니다 . 다른 모든 경우에는 &lt;code&gt;value&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3b72851ab3519141cf487432144a3f31b79335b" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is an object type or a function type that has no cv- or ref- qualifier, provides a member typedef &lt;code&gt;type&lt;/code&gt; which is &lt;code&gt;T&amp;amp;&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an rvalue reference to some type &lt;code&gt;U&lt;/code&gt;, then &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;U&amp;amp;&lt;/code&gt;. Otherwise, &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;T&lt;/code&gt; 가 오브젝트 유형이거나 cv- 또는 requalifier가없는 함수 &lt;code&gt;type&lt;/code&gt; 인 경우 &lt;code&gt;T&amp;amp;&lt;/code&gt; 멤버 typedef 유형 을 제공하십시오 . 경우 &lt;code&gt;T&lt;/code&gt; 가 어떤 종류의에를 rvalue 참조입니다 &lt;code&gt;U&lt;/code&gt; 는 다음 &lt;code&gt;type&lt;/code&gt; 이다 &lt;code&gt;U&amp;amp;&lt;/code&gt; . 그렇지 않으면, &lt;code&gt;type&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84341e9136029ad471cfa5b9061bb952f1306ba2" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is not a referenceable type (i.e., possibly cv-qualified &lt;code&gt;void&lt;/code&gt; or a function type with a</source>
          <target state="translated">1) &lt;code&gt;T&lt;/code&gt; 가 참조 가능한 유형이 아닌 경우 (예 : cv-qualified &lt;code&gt;void&lt;/code&gt; 또는</target>
        </trans-unit>
        <trans-unit id="55b2f140ddb9e139d3eddb758d445d70f330d38a" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;bool(lhs) != bool(rhs)&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;bool(lhs) != bool(rhs)&lt;/code&gt; 이면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다</target>
        </trans-unit>
        <trans-unit id="0a4d89d7c12b3e0fdc5475924278afccc9fcb9a0" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;c==EOF&lt;/code&gt;, does nothing</source>
          <target state="translated">1) &lt;code&gt;c==EOF&lt;/code&gt; 이면 아무 것도 수행하지 않습니다</target>
        </trans-unit>
        <trans-unit id="48cff9cec5eee4d48df8a56a52bf392dc360ed81" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;e&lt;/code&gt; is a function call expression, and</source>
          <target state="translated">1) &lt;code&gt;e&lt;/code&gt; 가 함수 호출 표현식 인 경우</target>
        </trans-unit>
        <trans-unit id="8cb38dc250b911397e4c0873f26f0012d9d8ab6e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;ok()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, returns a &lt;code&gt;sys_days&lt;/code&gt; that represents the last &lt;code&gt;weekday()&lt;/code&gt; of the &lt;code&gt;year()&lt;/code&gt; and &lt;code&gt;month()&lt;/code&gt;. Otherwise, the returned value is unspecified.</source>
          <target state="translated">경우 1) &lt;code&gt;ok()&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 하는 반환 &lt;code&gt;sys_days&lt;/code&gt; 마지막 나타내는 &lt;code&gt;weekday()&lt;/code&gt; 의 &lt;code&gt;year()&lt;/code&gt; 와 &lt;code&gt;month()&lt;/code&gt; . 그렇지 않으면 반환 된 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae1ac36ae20a2ced74aaccf2496e723144a48341" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;ok()&lt;/code&gt; is true, the return value holds a count of days from the &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&lt;/code&gt; epoch (1970-01-01) to &lt;code&gt;*this&lt;/code&gt;. The result is negative if &lt;code&gt;*this&lt;/code&gt; represent a date prior to it.</source>
          <target state="translated">1) &lt;code&gt;ok()&lt;/code&gt; 가 true이면 리턴 값은 &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&lt;/code&gt; epoch (1970-01-01)부터 &lt;code&gt;*this&lt;/code&gt; 까지의 일 수를 보유합니다 . &lt;code&gt;*this&lt;/code&gt; 이전 날짜를 나타내는 경우 결과는 음수 입니다.</target>
        </trans-unit>
        <trans-unit id="775e0551aa7721ab9c56d7c9c8e95ac883de5834" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;p.is_absolute() || (p.has_root_name() &amp;amp;&amp;amp; p.root_name() != root_name())&lt;/code&gt;, then replaces the current path with p as if by &lt;code&gt;operator=(p)&lt;/code&gt; and finishes.</source>
          <target state="translated">1) 만약 &lt;code&gt;p.is_absolute() || (p.has_root_name() &amp;amp;&amp;amp; p.root_name() != root_name())&lt;/code&gt; 이면 &lt;code&gt;operator=(p)&lt;/code&gt; 에 의해 현재 경로를 p로 바꾸고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="5df1170b75f3b245eb679518c7086990da875b8a" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;pos == size()&lt;/code&gt;, the behavior is undefined. 2) If &lt;code&gt;pos == size()&lt;/code&gt;, a reference to the character with value &lt;code&gt;CharT()&lt;/code&gt; (the null character) is returned.</source>
          <target state="translated">1) &lt;code&gt;pos == size()&lt;/code&gt; 인 경우 동작이 정의되지 않습니다. 2) &lt;code&gt;pos == size()&lt;/code&gt; 인 경우 &lt;code&gt;CharT()&lt;/code&gt; 값이있는 문자 (널 문자)에 대한 참조가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="23b154b4ece6fb3ebf14c379625abd81a94b12f9" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;root_name().native().compare(p.root_name().native())&lt;/code&gt; is nonzero, returns that value.</source>
          <target state="translated">1) &lt;code&gt;root_name().native().compare(p.root_name().native())&lt;/code&gt; 가 0이 아닌 경우 해당 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8adfe00a74db942dc8cc130967e0f6e088361d3c" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;sizeof...(MutexTypes) == 0&lt;/code&gt;, does nothing. Otherwise, If &lt;code&gt;sizeof...(MutexTypes) == 1&lt;/code&gt;, effectively calls &lt;code&gt;m.lock()&lt;/code&gt;. Otherwise, effectively calls &lt;code&gt;&lt;a href=&quot;../lock&quot;&gt;std::lock&lt;/a&gt;(m...)&lt;/code&gt;. The behavior is undefined if one of &lt;code&gt;MutexTypes&lt;/code&gt; is not a recursive mutex and the current thread already owns the corresponding argument in &lt;code&gt;m...&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;sizeof...(MutexTypes) == 0&lt;/code&gt; 이면 아무 것도 수행하지 않습니다. 그렇지 않으면 &lt;code&gt;sizeof...(MutexTypes) == 1&lt;/code&gt; 경우 효과적으로 &lt;code&gt;m.lock()&lt;/code&gt; 호출합니다 . 그렇지 않으면 효과적으로 &lt;code&gt;&lt;a href=&quot;../lock&quot;&gt;std::lock&lt;/a&gt;(m...)&lt;/code&gt; 호출합니다 . &lt;code&gt;MutexTypes&lt;/code&gt; 중 하나가 재귀 뮤텍스가 아니고 현재 스레드가 이미 &lt;code&gt;m...&lt;/code&gt; 의 해당 인수를 소유 한 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5ce02c5f4f1088b1082aa38dc45c7ca3365e6a7f" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;v&lt;/code&gt; compares less than &lt;code&gt;lo&lt;/code&gt;, returns &lt;code&gt;lo&lt;/code&gt;; otherwise if &lt;code&gt;hi&lt;/code&gt; compares less than &lt;code&gt;v&lt;/code&gt;, returns &lt;code&gt;hi&lt;/code&gt;; otherwise returns &lt;code&gt;v&lt;/code&gt;. Uses &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the values.</source>
          <target state="translated">1) 경우 &lt;code&gt;v&lt;/code&gt; 보다 비교 &lt;code&gt;lo&lt;/code&gt; , 돌아 &lt;code&gt;lo&lt;/code&gt; ; 그렇지 않은 경우 &lt;code&gt;hi&lt;/code&gt; 보다 적은 비교 &lt;code&gt;v&lt;/code&gt; , 반환 &lt;code&gt;hi&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;v&lt;/code&gt; 를 반환합니다 . 용도는 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 값을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="4d06e0518b8e9559ed2e398da1df96960c59c244" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;year().ok() &amp;amp;&amp;amp; month().ok() &amp;amp;&amp;amp; weekday().ok()&lt;/code&gt;:</source>
          <target state="translated">1) &lt;code&gt;year().ok() &amp;amp;&amp;amp; month().ok() &amp;amp;&amp;amp; weekday().ok()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="953c7b17bedfe4cec3a6964917bcb6dd438c090c" translate="yes" xml:space="preserve">
          <source>1) If a key equivalent to &lt;code&gt;k&lt;/code&gt; already exists in the container, does nothing. Otherwise, behaves like &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; except that the element is constructed as &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;k&lt;/code&gt; 에 해당하는 키 가 컨테이너에 이미 존재하면 아무 것도 수행하지 않습니다. 그렇지 같은 행동한다 &lt;a href=&quot;emplace&quot;&gt;설치하다&lt;/a&gt; 소자는 다음과 같이 구성되는 것을 제외 &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27c9cac424cf306f64712cae4c73131e4ecf8efa" translate="yes" xml:space="preserve">
          <source>1) If an exception is thrown, &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; is called</source>
          <target state="translated">1) 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="053707ffbcc5a261ff2e9f6e03a44ce4aa6bea54" translate="yes" xml:space="preserve">
          <source>1) If an imaginary struct containing a member object of type &lt;code&gt;T&lt;/code&gt; has a non-deleted destructor, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">형의 부재 객체 함유 허수 구조체의 경우 1) &lt;code&gt;T&lt;/code&gt; 가 아닌 삭제 소멸자 갖는 상기 부재의 제공 상수 &lt;code&gt;value&lt;/code&gt; 과 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d6c0a2e0ad065651ccf574c46ce2ec1d6a32e799" translate="yes" xml:space="preserve">
          <source>1) If both operands are null pointer constants, the composite pointer type is &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1) 두 피연산자가 모두 널 포인터 상수 인 경우 복합 포인터 유형은 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="001a94641182b36fb39ecd7c6f316dc79e18bf05" translate="yes" xml:space="preserve">
          <source>1) If both pointers to member are null member pointer values, they</source>
          <target state="translated">1) 멤버에 대한 두 포인터가 모두 널 멤버 포인터 값인 경우</target>
        </trans-unit>
        <trans-unit id="d696aa7c360446c7c92bbb49a9fa4b905e4ea6af" translate="yes" xml:space="preserve">
          <source>1) If either &lt;code&gt;E2&lt;/code&gt; or &lt;code&gt;E3&lt;/code&gt; has type &lt;code&gt;void&lt;/code&gt;, then one of the following must be true, or the program is ill-formed:</source>
          <target state="translated">1) &lt;code&gt;E2&lt;/code&gt; 또는 &lt;code&gt;E3&lt;/code&gt; 에 &lt;code&gt;void&lt;/code&gt; 유형이있는 경우 다음 중 하나에 해당하거나 프로그램이 잘못 작성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="619b57caddc542baf25a7d1c5e7745307a747df0" translate="yes" xml:space="preserve">
          <source>1) If only one specialization matches the template arguments, that specialization is used</source>
          <target state="translated">1) 하나의 전문화 만 템플리트 인수와 일치하면 해당 전문화가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ae7d33e86f2455f29507118c461d795dd425ce1" translate="yes" xml:space="preserve">
          <source>1) If permitted, &lt;a href=&quot;constant_initialization&quot;&gt;Constant initialization&lt;/a&gt; takes place first (see &lt;a href=&quot;constant_initialization&quot;&gt;Constant initialization&lt;/a&gt; for the list of those situations). In practice, constant initialization is usually performed at compile time, and pre-calculated object representations are stored as part of the program image. If the compiler doesn't do that, it still has to guarantee that this initialization happens before any dynamic initialization.</source>
          <target state="translated">1) 허용되는 경우 &lt;a href=&quot;constant_initialization&quot;&gt;상수 초기화&lt;/a&gt; 가 먼저 수행됩니다 ( 해당 상황 목록 은 &lt;a href=&quot;constant_initialization&quot;&gt;상수 초기화&lt;/a&gt; 참조 ). 실제로 일정한 초기화는 일반적으로 컴파일 타임에 수행되며 사전 계산 된 객체 표현은 프로그램 이미지의 일부로 저장됩니다. 컴파일러가 그렇게하지 않으면 여전히 동적 초기화 전에이 초기화가 발생하도록 보장해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec76cf635ed5977262cf9ddcc3fb5fe13eaaff7b" translate="yes" xml:space="preserve">
          <source>1) If set to &lt;code&gt;ON&lt;/code&gt;, informs the compiler that the program will access or modify &lt;a href=&quot;../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt;, which means that optimizations that could subvert flag tests and mode changes (e.g., global common subexpression elimination, code motion, and constant folding) are prohibited. The default value is implementation-defined, usually &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;ON&lt;/code&gt; 으로 설정 하면 프로그램이 &lt;a href=&quot;../numeric/fenv&quot;&gt;부동 소수점 환경에&lt;/a&gt; 액세스하거나 수정한다는 것을 컴파일러에 알립니다. 즉 플래그 테스트 및 모드 변경 (예 : 전역 공통 하위 표현식 제거, 코드 모션 및 상수 폴딩)을 방해 할 수있는 최적화는 다음과 같습니다. 금지되어 있습니다. 기본값은 구현 정의이며 일반적으로 &lt;code&gt;OFF&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f906d81a6d06437984e964c4636da5851fdcf58f" translate="yes" xml:space="preserve">
          <source>1) If the argument is an unparenthesized &lt;a href=&quot;name&quot;&gt;id-expression&lt;/a&gt; naming a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt;, then decltype yields the</source>
          <target state="translated">1) 인수가 &lt;a href=&quot;structured_binding&quot;&gt;구조적 바인딩을&lt;/a&gt; 명명 하는 괄호로 묶이지 않은 &lt;a href=&quot;name&quot;&gt;id- 표현식&lt;/a&gt; 인 경우 decltype은</target>
        </trans-unit>
        <trans-unit id="826d68e87870ec49b6a7fffcc26f9ce675d5f52a" translate="yes" xml:space="preserve">
          <source>1) If the constructor is for the most-derived class, virtual base classes are initialized in the order in which they appear in depth-first left-to-right traversal of the base class declarations (left-to-right refers to the appearance in base-specifier lists)</source>
          <target state="translated">1) 생성자가 가장 파생 된 클래스의 생성자 인 경우 가상 기본 클래스는 기본 클래스 선언의 깊이 우선 왼쪽에서 오른쪽 순으로 나타나는 순서대로 초기화됩니다 (왼쪽에서 오른쪽은 모양을 나타냄) 기본 지정자 목록에서)</target>
        </trans-unit>
        <trans-unit id="64bc0d09554e2852fae96f29e67b670b931676e8" translate="yes" xml:space="preserve">
          <source>1) If the current output format is 24-hour, converts to 12-hour time. Otherwise no effects.</source>
          <target state="translated">1) 현재 출력 형식이 24 시간이면 12 시간으로 변환됩니다. 그렇지 않으면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f38fe0a520fad6c56ed541e8d99a4cb99844d3f" translate="yes" xml:space="preserve">
          <source>1) If the declaration of &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;pf&lt;/code&gt;, or &lt;code&gt;pmf&lt;/code&gt; uses &lt;code&gt;throw()&lt;/code&gt;(deprecated) or &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt;, the set is empty. 2) Otherwise, if the declaration of &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;pf&lt;/code&gt;, or &lt;code&gt;pmf&lt;/code&gt; uses a dynamic exception specification(deprecated), the set consists of the types listed in that specification 3) Otherwise, the set is the set of all types</source>
          <target state="translated">1)의 경우 선언 &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;pf&lt;/code&gt; 또는 &lt;code&gt;pmf&lt;/code&gt; 가 사용하는 &lt;code&gt;throw()&lt;/code&gt; (중단됨) 또는 &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt; , 세트는 비어있다. 2) 그렇지 않으면 &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;pf&lt;/code&gt; 또는 &lt;code&gt;pmf&lt;/code&gt; 선언 에서 동적 예외 사양 (더 이상 사용되지 않음)을 사용하는 경우 세트는 해당 사양에 나열된 유형으로 구성됩니다. 3) 그렇지 않으면 세트는 모든 유형의 세트입니다</target>
        </trans-unit>
        <trans-unit id="f9ccd33ddb11cbe7fee8dbccd1e293df7c5318d1" translate="yes" xml:space="preserve">
          <source>1) If the expression &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;() = &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;()&lt;/code&gt; is well-formed in unevaluated context, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to either type.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;() = &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;()&lt;/code&gt; 이 평가되지 않은 컨텍스트에서 올바르게 구성된 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 과 동일한 &lt;code&gt;true&lt;/code&gt; 를 제공하십시오 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;a href=&quot;../language/access&quot;&gt;액세스 검사&lt;/a&gt; 는 두 유형과 관련이없는 컨텍스트 에서처럼 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3daeab1387736a2e7813fdad3d2e852a5f18e577" translate="yes" xml:space="preserve">
          <source>1) If the expressions &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; and &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;())&lt;/code&gt; are both well-formed in unevaluated context after &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;;&lt;/code&gt; (see &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to either type.</source>
          <target state="translated">1) 표현식 &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; 및 &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;())&lt;/code&gt; &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;;&lt;/code&gt; 사용 후 평가되지 않은 컨텍스트에서 잘 구성됩니다 . (참고 &lt;a href=&quot;../named_req/swappable&quot;&gt;스왑을&lt;/a&gt; ) 부재를 제공 상수 &lt;code&gt;value&lt;/code&gt; 과 동일 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;a href=&quot;../language/access&quot;&gt;액세스 검사&lt;/a&gt; 는 두 유형과 관련이없는 컨텍스트 에서처럼 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="45059787b4fa742a740d89cbe94d8b03372e1106" translate="yes" xml:space="preserve">
          <source>1) If the imaginary function definition &lt;code&gt;To test() { return &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;(); }&lt;/code&gt; is well-formed, (that is, either &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;()&lt;/code&gt; can be converted to &lt;code&gt;To&lt;/code&gt; using &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicit conversions&lt;/a&gt;, or both &lt;code&gt;From&lt;/code&gt; and &lt;code&gt;To&lt;/code&gt; are possibly cv-qualified &lt;code&gt;void&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. For the purposes of this check, the use of &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; in the return statement is not considered an &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;.</source>
          <target state="translated">1) 허수 함수 정의 &lt;code&gt;To test() { return &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;(); }&lt;/code&gt; 올바른 형식입니다 (즉, &lt;a href=&quot;../language/implicit_cast&quot;&gt;암시 적 변환 &lt;/a&gt; &lt;code&gt;To&lt;/code&gt; 사용하여 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;()&lt;/code&gt; 를 To로 변환 하거나 &lt;code&gt;From&lt;/code&gt; 및 &lt;code&gt;To&lt;/code&gt; 모두 cv-qualified &lt;code&gt;void&lt;/code&gt; 가능함 ). 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공 합니다. . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다. 이 점검의 목적으로 , return 문에서 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../language/definition#ODR-use&quot;&gt; 사용&lt;/a&gt; 은 odr-use로 간주되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6f0b8672e5f29b8486f7709d207643d87be596d9" translate="yes" xml:space="preserve">
          <source>1) If the input sequence has a read position available (&lt;code&gt;egptr() &amp;gt; gptr()&lt;/code&gt;), returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;</source>
          <target state="translated">1) 입력 시퀀스에 사용 가능한 읽기 위치가 있으면 ( &lt;code&gt;egptr() &amp;gt; gptr()&lt;/code&gt; ) &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c32163286e69234ea02701a99ebdecfd40c8e43" translate="yes" xml:space="preserve">
          <source>1) If the next pointer is null, the operation fails</source>
          <target state="translated">1) 다음 포인터가 널이면 조작이 실패합니다</target>
        </trans-unit>
        <trans-unit id="91c47dc3e02728253e0cce0bb00f6bc9a4d38d28" translate="yes" xml:space="preserve">
          <source>1) If the operand is an lvalue expression of some object or function type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;operator&amp;amp;&lt;/code&gt; creates and returns a prvalue of type &lt;code&gt;T*&lt;/code&gt;, with the same cv qualification, that is pointing to the object or function designated by the operand. If the operand has incomplete type, the pointer can be formed, but if that incomplete type happens to be a class that defines its own &lt;code&gt;operator&amp;amp;&lt;/code&gt;, the behavior is undefined(until C++14)it is unspecified whether the built-in or the overload is used(since C++14). For the operands of type with user-defined &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; may be used to obtain the true pointer.</source>
          <target state="translated">1) 피연산자가 일부 오브젝트 또는 함수 유형 &lt;code&gt;T&lt;/code&gt; 의 lvalue 표현식 인 경우 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 는 동일한 cv 규정을 사용하여 피연산자가 지정한 오브젝트 또는 함수를 가리키는 &lt;code&gt;T*&lt;/code&gt; 유형의 prvalue를 작성하고 리턴합니다 . 피연산자에 불완전한 유형이있는 경우 포인터를 형성 할 수 있지만 불완전한 유형이 자체 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 를 정의하는 클래스 인 경우 동작은 정의되지 않습니다 (C ++ 14까지). 과부하가 사용됩니다 (C ++ 14부터). 사용자 정의 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 가있는 유형의 피연산자의 경우 &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; 를 사용하여 실제 포인터를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1256320cbee9651ed515f01789527567a38d98e" translate="yes" xml:space="preserve">
          <source>1) If the path is empty, stop (normal form of an empty path is an empty path)</source>
          <target state="translated">1) 경로가 비어 있으면 중지하십시오 (빈 경로의 일반 형식은 빈 경로입니다)</target>
        </trans-unit>
        <trans-unit id="582111318ab00f1208e85c21c22bca92315c07e6" translate="yes" xml:space="preserve">
          <source>1) If the pointer to be repositioned is a null pointer and the new offset &lt;code&gt;newoff&lt;/code&gt; would be non-zero, this function fails.</source>
          <target state="translated">1) 재배치 될 포인터가 널 포인터이고 새로운 오프셋 &lt;code&gt;newoff&lt;/code&gt; 가 0이 아니면이 함수는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fe93a7c23cff4516602f15cbb778ed98afe55fb4" translate="yes" xml:space="preserve">
          <source>1) If the pointers are both null pointer values, they</source>
          <target state="translated">1) 포인터가 모두 널 포인터 값인 경우</target>
        </trans-unit>
        <trans-unit id="fc198593bd9ec378434428d9afd2c41063e2a0a5" translate="yes" xml:space="preserve">
          <source>1) If the type of expression is exactly new_type or a less cv-qualified version of new_type, the result is the value of expression, with type new_type. (In other words, &lt;code&gt;dynamic_cast&lt;/code&gt; can be used to add constness. An implicit conversion and &lt;code&gt;static_cast&lt;/code&gt; can perform this conversion as well.)</source>
          <target state="translated">1) 표현식 유형이 정확히 new_type이거나 cv 규정이 적은 new_type 버전 인 경우 결과는 new_type 유형의 expression 값입니다. 즉, &lt;code&gt;dynamic_cast&lt;/code&gt; 를 사용하여 constness를 추가 할 수 있습니다. 암시 적 변환과 &lt;code&gt;static_cast&lt;/code&gt; 도이 변환을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81e1b3a4903489b6c6f5290600d72bbbee763b8f" translate="yes" xml:space="preserve">
          <source>1) If the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; stores the same &lt;code&gt;T*&lt;/code&gt; as &lt;code&gt;expected&lt;/code&gt; and shares ownership with it, or if both underlying and &lt;code&gt;expected&lt;/code&gt; are empty, assigns from &lt;code&gt;desired&lt;/code&gt; to the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;, and orders memory according to &lt;code&gt;success&lt;/code&gt;, otherwise assigns from the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;expected&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;, and orders memory according to &lt;code&gt;failure&lt;/code&gt;. The behavior is undefined if &lt;code&gt;failure&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;. On success, the operation is an atomic read-modify-write operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is not accessed after the atomic update. On failure, the operation is an atomic load operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is updated with the existing value read from the atomic object. This update to &lt;code&gt;expected&lt;/code&gt;'s use_count is part of this atomic operation, although the write itself (and any subsequent deallocation/destruction) is not required to be.</source>
          <target state="translated">1) 기본 경우 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 상점 같은 &lt;code&gt;T*&lt;/code&gt; 로 &lt;code&gt;expected&lt;/code&gt; 하고 그것으로 주식 소유권, 또는 둘 다 기본 및 경우 &lt;code&gt;expected&lt;/code&gt; 에서 양수인, 비어있는 &lt;code&gt;desired&lt;/code&gt; 기본에 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , 반환 &lt;code&gt;true&lt;/code&gt; 에 따라 및 주문 메모리 &lt;code&gt;success&lt;/code&gt; , 기본에서 다른 양수인 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 에 대한 &lt;code&gt;expected&lt;/code&gt; , 수익률 &lt;code&gt;false&lt;/code&gt; 에 따라, 그리고 주문 메모리 &lt;code&gt;failure&lt;/code&gt; . &lt;code&gt;failure&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 경우 동작이 정의되지 않습니다.또는 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; 입니다. 성공시, 동작에 원자 읽기 - 수정 - 쓰기 작업입니다 &lt;code&gt;*this&lt;/code&gt; 과 &lt;code&gt;expected&lt;/code&gt; 원자 업데이트 후에 액세스되지는. 실패시, 조작은 &lt;code&gt;*this&lt;/code&gt; 에 대한 원자로드 조작 이며 원자 오브젝트에서 읽은 기존 값으로 &lt;code&gt;expected&lt;/code&gt; 됩니다. 쓰기 자체 (및 후속 할당 취소 / 파괴)가 필요하지는 않지만 &lt;code&gt;expected&lt;/code&gt; use_count에 대한 이 업데이트 는이 원자 연산의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="debd587f8b5b3f706f78c4d8eb91989d3f630fe5" translate="yes" xml:space="preserve">
          <source>1) If the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; stores the same pointer value as &lt;code&gt;expected&lt;/code&gt; and shares ownership with it, or if both underlying and &lt;code&gt;expected&lt;/code&gt; are empty, assigns from &lt;code&gt;desired&lt;/code&gt; to the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;, and orders memory according to &lt;code&gt;success&lt;/code&gt;, otherwise assigns from the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;expected&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;, and orders memory according to &lt;code&gt;failure&lt;/code&gt;. The behavior is undefined if &lt;code&gt;failure&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;. On success, the operation is an atomic read-modify-write operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is not accessed after the atomic update. On failure, the operation is an atomic load operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is updated with the existing value read from the atomic object. This update to &lt;code&gt;expected&lt;/code&gt;'s use_count is part of this atomic operation, although the write itself (and any subsequent deallocation/destruction) is not required to be.</source>
          <target state="translated">1) 기본 만약 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 저장과 같은 포인터 값 &lt;code&gt;expected&lt;/code&gt; 그것과 주식 소유권, 또는 두 가지 모두 기본 및 경우 &lt;code&gt;expected&lt;/code&gt; 비어있는, 양수인에서 &lt;code&gt;desired&lt;/code&gt; 기본에 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , 반환 &lt;code&gt;true&lt;/code&gt; 에 따라 및 주문 메모리 &lt;code&gt;success&lt;/code&gt; , 기본에서 다른 양수인 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 에 대한 &lt;code&gt;expected&lt;/code&gt; , 수익률 &lt;code&gt;false&lt;/code&gt; 에 따라, 그리고 주문 메모리 &lt;code&gt;failure&lt;/code&gt; . 경우의 동작은 정의되지 않습니다 &lt;code&gt;failure&lt;/code&gt; 되는 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; . 성공시, 동작에 원자 읽기 - 수정 - 쓰기 작업입니다 &lt;code&gt;*this&lt;/code&gt; 과 &lt;code&gt;expected&lt;/code&gt; 원자 업데이트 후에 액세스되지는. 실패시, 조작은 &lt;code&gt;*this&lt;/code&gt; 에 대한 원자로드 조작이며원자 오브젝트에서 읽은 기존 값으로 &lt;code&gt;expected&lt;/code&gt; 됩니다. 쓰기 자체 (및 후속 할당 취소 / 파괴)가 필요하지는 않지만 &lt;code&gt;expected&lt;/code&gt; use_count에 대한이 업데이트는이 원자 연산의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="e34721beb2d7e5dc88963d3e677eec93a6ef94e9" translate="yes" xml:space="preserve">
          <source>1) If there are &lt;code&gt;M&lt;/code&gt; arguments, the candidate function that has exactly &lt;code&gt;M&lt;/code&gt; parameters is viable</source>
          <target state="translated">1) &lt;code&gt;M&lt;/code&gt; 개의 인수가있는 경우 정확히 &lt;code&gt;M&lt;/code&gt; 개의 매개 변수가 있는 후보 함수를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec64a20a9d24c39e596bf41c76e737d99a86058d" translate="yes" xml:space="preserve">
          <source>1) If there is an &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion sequence&lt;/a&gt; from expression to new_type, or if overload resolution for a &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; of an object or reference of type new_type from expression would find at least one viable function, then &lt;code&gt;static_cast&amp;lt;new_type&amp;gt;(expression)&lt;/code&gt; returns the imaginary variable &lt;code&gt;Temp&lt;/code&gt; initialized as if by &lt;code&gt;new_type Temp(expression);&lt;/code&gt;, which may involve &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt;, a call to the &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; of new_type or a call to a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion operator&lt;/a&gt;. For non-reference new_type, the result object of the static_cast prvalue expression is what's direct-initialized(since C++17)</source>
          <target state="translated">1) 표현식에서 new_type으로 의 &lt;a href=&quot;implicit_cast&quot;&gt;암시 적 변환 시퀀스&lt;/a&gt; 가 있거나 오브젝트 의 &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 또는 표현식에서 new_type 유형의 참조에 대한 과부하 해결이 최소한 하나의 실행 가능한 함수를 찾은 경우 &lt;code&gt;static_cast&amp;lt;new_type&amp;gt;(expression)&lt;/code&gt; 은 허수 변수 &lt;code&gt;Temp&lt;/code&gt; 는 &lt;code&gt;new_type Temp(expression);&lt;/code&gt; 의해 마치 초기화됩니다 . Temp (expression); &lt;a href=&quot;implicit_cast&quot;&gt;암시 적 변환&lt;/a&gt; , new_type &lt;a href=&quot;constructor&quot;&gt;생성자&lt;/a&gt; 호출 또는 &lt;a href=&quot;cast_operator&quot;&gt;사용자 정의 변환 연산자&lt;/a&gt; 호출 이 포함될 수 있습니다 . 비 참조 new_type의 경우 static_cast prvalue 표현식의 결과 오브젝트는 직접 초기화 된 것입니다 (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="5e61488d7d7b15353ad536c26150cc3f3d9dfc2a" translate="yes" xml:space="preserve">
          <source>1) If two pointers point to different elements of the same array, or to subobjects within different elements of the same array, the pointer to the element with the higher subscript</source>
          <target state="translated">1) 두 포인터가 같은 배열의 다른 요소를 가리 키거나 같은 배열의 다른 요소 내 하위 객체를 가리키는 경우 더 높은 첨자를 가진 요소를 가리키는 포인터</target>
        </trans-unit>
        <trans-unit id="a1ef97817e3de9be1ea70784e7655c53546a2dc5" translate="yes" xml:space="preserve">
          <source>1) Ignores all elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;value&lt;/code&gt; 와 동일한 모든 요소를 ​​무시합니다 .</target>
        </trans-unit>
        <trans-unit id="e94af7fe131aa943bb89af9451c2c83b03715052" translate="yes" xml:space="preserve">
          <source>1) Implements &lt;code&gt;operator!=&lt;/code&gt; in terms of &lt;code&gt;operator==&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;operator==&lt;/code&gt; &lt;code&gt;operator!=&lt;/code&gt; 를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="dab585f3da6ef91bb449ba583df62136d68e6d58" translate="yes" xml:space="preserve">
          <source>1) Implicitly declared default constructor.</source>
          <target state="translated">1) 암시 적으로 선언 된 기본 생성자.</target>
        </trans-unit>
        <trans-unit id="5c681d4553e954943a32a867bbdf85235d7bbe9b" translate="yes" xml:space="preserve">
          <source>1) In a member function declaration, &lt;code&gt;final&lt;/code&gt; may appear in virt-specifier-seq immediately after the declarator, and before the &lt;a href=&quot;abstract_class&quot;&gt;pure-specifier&lt;/a&gt;, if used.</source>
          <target state="translated">1) 멤버 함수 선언에서 &lt;code&gt;final&lt;/code&gt; 은 선언자 직후 및 &lt;a href=&quot;abstract_class&quot;&gt;순수 지정자&lt;/a&gt; 앞에 virt-specifier-seq에 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e87713d6a39f4e0ea9a3dfa0acccc59bf85daffe" translate="yes" xml:space="preserve">
          <source>1) In a member function declaration, &lt;code&gt;override&lt;/code&gt; may appear in virt-specifier-seq immediately after the declarator, and before the &lt;a href=&quot;abstract_class&quot;&gt;pure-specifier&lt;/a&gt;, if used.</source>
          <target state="translated">1) 멤버 함수 선언에서 &lt;code&gt;override&lt;/code&gt; 는 선언자 바로 후, 그리고 &lt;a href=&quot;abstract_class&quot;&gt;순수 지정자&lt;/a&gt; 앞에 사용될 경우 virt-specifier-seq에 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7f2af54ab23b9453df13b695a120657cdbb78f5" translate="yes" xml:space="preserve">
          <source>1) In the &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; of the constructor.</source>
          <target state="translated">1) 생성자 의 &lt;a href=&quot;constructor&quot;&gt;멤버 이니셜 라이저 목록&lt;/a&gt; 에서.</target>
        </trans-unit>
        <trans-unit id="ad85e856c86edd9721a76169fb3382fbd0691a1a" translate="yes" xml:space="preserve">
          <source>1) Index-based non-throwing accessor: If &lt;code&gt;pv&lt;/code&gt; is not a null pointer and &lt;code&gt;pv-&amp;gt;index() == I&lt;/code&gt;, returns a pointer to the value stored in the variant pointed to by &lt;code&gt;pv&lt;/code&gt;. Otherwise, returns a null pointer value. The call is ill-formed if &lt;code&gt;I&lt;/code&gt; is not a valid index in the variant.</source>
          <target state="translated">1) 인덱스 기반의 비 던지는 접근 : 경우 &lt;code&gt;pv&lt;/code&gt; 아니다 널 포인터 및 &lt;code&gt;pv-&amp;gt;index() == I&lt;/code&gt; , 변형에 저장된 값에 대한 포인터가 가리키는 반환 &lt;code&gt;pv&lt;/code&gt; . 그렇지 않으면 널 포인터 값을 리턴합니다. 경우 호출이 잘못 형성되어 &lt;code&gt;I&lt;/code&gt; 변형에 유효한 인덱스가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9aabcbed245a33739cb3035c8ee0b94c11b43add" translate="yes" xml:space="preserve">
          <source>1) Index-based value accessor: If &lt;code&gt;v.index() == I&lt;/code&gt;, returns a reference to the value stored in &lt;code&gt;v&lt;/code&gt;. Otherwise, throws &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt;. The call is ill-formed if &lt;code&gt;I&lt;/code&gt; is not a valid index in the variant.</source>
          <target state="translated">1) 인덱스 기반 값 접근 자 : &lt;code&gt;v.index() == I&lt;/code&gt; 인 경우 &lt;code&gt;v&lt;/code&gt; 에 저장된 값에 대한 참조를 반환합니다 . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; . 경우 호출이 잘못 형성되어 &lt;code&gt;I&lt;/code&gt; 변형에 유효한 인덱스가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="af4fb35a5ec3b4df2a4082311967437cd6c9b5db" translate="yes" xml:space="preserve">
          <source>1) Informs a &lt;code&gt;std::basic_string&lt;/code&gt; object of a planned change in size, so that it can manage the storage allocation appropriately.</source>
          <target state="translated">1) &lt;code&gt;std::basic_string&lt;/code&gt; 오브젝트에 계획된 크기 변경을 알리 므로 스토리지 할당을 적절하게 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="c71413d04de99f2d5426060b5049fea7209088cd" translate="yes" xml:space="preserve">
          <source>1) Initializes &lt;code&gt;r_&lt;/code&gt; with &lt;code&gt;nullptr&lt;/code&gt;. A default-initialized &lt;code&gt;ref_view&lt;/code&gt; references no &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1) &lt;code&gt;nullptr&lt;/code&gt; 로 &lt;code&gt;r_&lt;/code&gt; 를 초기화합니다 . 기본 초기화 된 &lt;code&gt;ref_view&lt;/code&gt; 는 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; 를&lt;/a&gt; 참조하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d666e6ac7a857628bc04dc566500208a77dfdfa4" translate="yes" xml:space="preserve">
          <source>1) Initializes the accumulator &lt;code&gt;acc&lt;/code&gt; with the initial value &lt;code&gt;init&lt;/code&gt; and then</source>
          <target state="translated">1) 초기 값 &lt;code&gt;init&lt;/code&gt; 로 누산기 &lt;code&gt;acc&lt;/code&gt; 를 초기화 한 다음</target>
        </trans-unit>
        <trans-unit id="390208e5ec0095fd5b6b97b7b3f847fcb7002d96" translate="yes" xml:space="preserve">
          <source>1) Initializes the base or member named by class-or-identifier using &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; or, if expression-list is empty, &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt;</source>
          <target state="translated">1) &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화를 사용&lt;/a&gt; 하거나 expression-list가 비어 있으면 &lt;a href=&quot;value_initialization&quot;&gt;값 &lt;/a&gt;초기화를 사용하여 클래스 또는 식별자로 명명 된 기본 또는 멤버를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0738aa8c98109913fcc387730825b9c7aaa58446" translate="yes" xml:space="preserve">
          <source>1) Initializes the contained value by &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializing&lt;/a&gt; (but not direct-list-initializing) with &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; as parameters.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; &amp;lt;Args&amp;gt; (args) ... 를 매개 변수로 사용 하여 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; (직접 목록 초기화는 아님)하여 포함 된 값을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="55b3a7a556eb22d3fddafb6be7ce6a255efdaa60" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; to default-constructed value</source>
          <target state="translated">1) 기본 &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 를 기본값으로 구성된 값으로 초기화합니다</target>
        </trans-unit>
        <trans-unit id="56d3077b0b0cef44db878906aa8a6c39943f7a5f" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying &lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; to default-constructed value</source>
          <target state="translated">1) 기본 &lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 를 기본값으로 구성된 값으로 초기화합니다</target>
        </trans-unit>
        <trans-unit id="4ac80d611dc008ae2fce6aea9e7cf692cd5e7b32" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying pointer to container with &lt;code&gt;nullptr&lt;/code&gt; and value-initializes the underlying iterator.</source>
          <target state="translated">1) &lt;code&gt;nullptr&lt;/code&gt; 로 컨테이너에 대한 기본 포인터를 초기화하고 기본 반복자를 value-initialize합니다.</target>
        </trans-unit>
        <trans-unit id="e37bfcf43e090a94cd623e83017e50e5bca2fc1a" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying pointer to container with &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;nullptr&lt;/code&gt; 로 컨테이너의 기본 포인터를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="dcd29c5e81afcd584e544f121d5f47dadd0f4de1" translate="yes" xml:space="preserve">
          <source>1) Initializes with streambuf &lt;code&gt;sb&lt;/code&gt;. The base classes are initialized as &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; and &lt;code&gt;basic_ostream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt;. After the call &lt;code&gt;rdbuf() == sb&lt;/code&gt; and &lt;code&gt;gcount() == 0&lt;/code&gt;.</source>
          <target state="translated">1) streambuf &lt;code&gt;sb&lt;/code&gt; 로 초기화합니다 . 기본 클래스는 &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; 및 &lt;code&gt;basic_ostream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; 로 초기화됩니다 . 통화 후 &lt;code&gt;rdbuf() == sb&lt;/code&gt; 와 &lt;code&gt;gcount() == 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="597197c59314c93c55128912be74ee54b394e721" translate="yes" xml:space="preserve">
          <source>1) Inserts &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt; at the position &lt;code&gt;index&lt;/code&gt;</source>
          <target state="translated">1) 삽입은 &lt;code&gt;count&lt;/code&gt; 캐릭터의 복사본 &lt;code&gt;ch&lt;/code&gt; 위치에 &lt;code&gt;index&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f9e626ebe4226924cf0f29adddd15e2078d9dc6" translate="yes" xml:space="preserve">
          <source>1) Inserts &lt;code&gt;value_type(key, T())&lt;/code&gt; if the key does not exist. This function is equivalent to &lt;code&gt;return insert(&lt;a href=&quot;../../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(key, T())).first-&amp;gt;second;&lt;/code&gt;</source>
          <target state="translated">1) 키가 존재하지 않으면 &lt;code&gt;value_type(key, T())&lt;/code&gt; )를 삽입 합니다. 이 함수는 &lt;code&gt;return insert(&lt;a href=&quot;../../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(key, T())).first-&amp;gt;second;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbcdba0d1f411974c0900c76adfb06fb4ddf41c" translate="yes" xml:space="preserve">
          <source>1) Inserts a &lt;code&gt;value_type&lt;/code&gt; object constructed in-place from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; if the key does not exist.  This function is equivalent to &lt;code&gt;return this-&amp;gt;try_emplace(key).first-&amp;gt;second;&lt;/code&gt;.(since C++17)</source>
          <target state="translated">1) 키가 존재하지 않는 경우 &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; , &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std :: forward_as_tuple&lt;/a&gt; (key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std :: tuple&lt;/a&gt; &amp;lt;&amp;gt; () 에서 &lt;code&gt;value_type&lt;/code&gt; 구성된 value_type 객체를 삽입 합니다. 이 함수는 &lt;code&gt;return this-&amp;gt;try_emplace(key).first-&amp;gt;second;&lt;/code&gt; . (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="1ed499190167ff7f4a4dca5f353727adf6c5d67d" translate="yes" xml:space="preserve">
          <source>1) Integer formatters: &lt;code&gt;value&lt;/code&gt; is converted to a string of digits in the given &lt;code&gt;base&lt;/code&gt; (with no redundant leading zeroes). Digits in the range &lt;code&gt;10..35&lt;/code&gt; (inclusive) are represented as lowercase characters &lt;code&gt;a..z&lt;/code&gt;. If value is less than zero, the representation starts with a minus sign. The library provides overloads for all signed and unsigned integer types and for the type &lt;code&gt;char&lt;/code&gt; as the type of the parameter &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) 정수 포맷터 : &lt;code&gt;value&lt;/code&gt; 은 주어진 &lt;code&gt;base&lt;/code&gt; (중복 선행 0없이) 의 문자열로 변환됩니다 . &lt;code&gt;10..35&lt;/code&gt; (포함) 범위의 숫자는 소문자 &lt;code&gt;a..z&lt;/code&gt; 로 표시됩니다 . 값이 0보다 작은 경우 표현은 빼기 기호로 시작합니다. 라이브러리는 모든 부호있는 정수 유형과 부호없는 정수 유형 및 매개 변수 &lt;code&gt;value&lt;/code&gt; 의 유형으로 &lt;code&gt;char&lt;/code&gt; 유형에 대한 과부하를 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="2cd742de2bf8d435baa1eb1ba04960df29830e0c" translate="yes" xml:space="preserve">
          <source>1) Integer parsers: Expects the pattern identical to the one used by &lt;code&gt;&lt;a href=&quot;../string/byte/strtol&quot;&gt;std::strtol&lt;/a&gt;&lt;/code&gt; in the default (&quot;C&quot;) locale and the given non-zero numeric base, except that</source>
          <target state="translated">1) 정수 파서 : 기본 ( &quot;C&quot;) 로케일의 &lt;code&gt;&lt;a href=&quot;../string/byte/strtol&quot;&gt;std::strtol&lt;/a&gt;&lt;/code&gt; 및 0이 아닌 숫자가 아닌 숫자 기반에서 사용 된 것과 동일한 패턴을 예상합니다.</target>
        </trans-unit>
        <trans-unit id="8a213779ff6418b03ee0523325685afdc5d484b9" translate="yes" xml:space="preserve">
          <source>1) It cannot be used anywhere in the program</source>
          <target state="translated">1) 프로그램의 어느 곳에서도 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="52283fc726cca49a55017924c746b83c68a86057" translate="yes" xml:space="preserve">
          <source>1) It must be declared &lt;code&gt;inline&lt;/code&gt; in every translation unit.</source>
          <target state="translated">1) 모든 번역 단위에서 &lt;code&gt;inline&lt;/code&gt; 으로 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="93c41523dfecbacf0866640c365002e86309d551" translate="yes" xml:space="preserve">
          <source>1) Iterator to the element following the erased one, or &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; if no such element exists.</source>
          <target state="translated">1) 지워진 요소 다음에 오는 요소에 대한 반복자 또는 해당 요소가 없으면 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db998b65059f221b9947c1e2b84b7328aa9c6731" translate="yes" xml:space="preserve">
          <source>1) Iterator to the first element of the path.</source>
          <target state="translated">1) 경로의 첫 번째 요소에 대한 반복자.</target>
        </trans-unit>
        <trans-unit id="5f63d6bacd5c75bb3d9c40afba52d76d0aa26b7a" translate="yes" xml:space="preserve">
          <source>1) Linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">1) 선형 &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bad57cdbf49ee5c9cf8b15794f0ba25ea25faaf6" translate="yes" xml:space="preserve">
          <source>1) Linear in the number of characters compared.</source>
          <target state="translated">1) 비교되는 문자 수의 선형.</target>
        </trans-unit>
        <trans-unit id="bfbdf175b676848b3b112f3b7622116e7ae24018" translate="yes" xml:space="preserve">
          <source>1) Linear in the size of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 크기의 선형 .</target>
        </trans-unit>
        <trans-unit id="ae3d9bc82a6c5df2515038c2bc04f8922fb3612d" translate="yes" xml:space="preserve">
          <source>1) Linear in the size of &lt;code&gt;other&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;other&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="b7138a1f54274e2bc82a87855f742eb60f4fcddc" translate="yes" xml:space="preserve">
          <source>1) Literal operators with this parameter list are the</source>
          <target state="translated">1)이 매개 변수 목록이있는 리터럴 연산자는</target>
        </trans-unit>
        <trans-unit id="d4f26c9f8811c2aa27521ffafb650efe7f636432" translate="yes" xml:space="preserve">
          <source>1) Literals (e.g. &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;&quot;Hello, world&quot;&lt;/code&gt;)</source>
          <target state="translated">1) 리터럴 (예 : &lt;code&gt;2&lt;/code&gt; 또는 &lt;code&gt;&quot;Hello, world&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="692f0144de0296503caf6eb540cde981dab090e2" translate="yes" xml:space="preserve">
          <source>1) Logical AND (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;). The value for the empty pack is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1) 논리 AND ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ). 빈 팩의 값이 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be220faf928704a940a2cf9ed4835d69e6844ef4" translate="yes" xml:space="preserve">
          <source>1) Logical NOT</source>
          <target state="translated">1) 논리 NOT</target>
        </trans-unit>
        <trans-unit id="dad928c0d3430b473633cea25234a47b689119c3" translate="yes" xml:space="preserve">
          <source>1) Manages a single object (e.g. allocated with &lt;code&gt;new&lt;/code&gt;)</source>
          <target state="translated">1) 단일 객체를 관리합니다 (예 : &lt;code&gt;new&lt;/code&gt; 로 할당 )</target>
        </trans-unit>
        <trans-unit id="c2dafa4c13c344cdd5b36d49ab1c8f9cb1618f3e" translate="yes" xml:space="preserve">
          <source>1) May throw &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt; if the thread has no privilege to create a condition variable, &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; if a non-memory resource limitation prevents this initialization, or another implementation-defined value.</source>
          <target state="translated">1) throw 될 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 같음 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt; 스레드는 조건 변수를 생성 할 권한이없는 경우, &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; 비 메모리 리소스 제한이없는 경우 이러한 초기화 또는 다른 구현 정의 값.</target>
        </trans-unit>
        <trans-unit id="e0f5008a342755f8d0c7df43b3ab66846dd152a1" translate="yes" xml:space="preserve">
          <source>1) May throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; in case of failure, if &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt; 인 경우 실패 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 를 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fec14884289d124fcea9cdbca0e3487bb3fefeab" translate="yes" xml:space="preserve">
          <source>1) May throw any exception thrown by the value initialization of the first alternative.</source>
          <target state="translated">1) 첫 번째 대안의 값 초기화로 인해 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d9856c647bd6f18f2c4199f99dda0d7103b839f" translate="yes" xml:space="preserve">
          <source>1) Member declarations of the form</source>
          <target state="translated">1) 양식의 회원 선언</target>
        </trans-unit>
        <trans-unit id="f54b805bef5f1481100f7bcad5d8d8c57550f520" translate="yes" xml:space="preserve">
          <source>1) Minimum offset between two objects to avoid false sharing. Guaranteed to be at least &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) 허위 공유를 피하기 위해 두 객체 사이의 최소 오프셋. 적어도 &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../types/max_align_t&quot;&gt;std :: max_align_t&lt;/a&gt; ) 임을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="cc024f12038108f0c21d9b9bb7028dab37fcc8fc" translate="yes" xml:space="preserve">
          <source>1) Modifies the &lt;code&gt;&lt;a href=&quot;timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;ts&lt;/code&gt; to hold the current calendar time in the time base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;ts&lt;/code&gt; 가 가리키는 &lt;code&gt;&lt;a href=&quot;timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt; 객체를 수정하여 현재 &lt;code&gt;base&lt;/code&gt; 시간을 시간 기준으로 유지 합니다 .</target>
        </trans-unit>
        <trans-unit id="019c13e7183a754e9d764c5fd9f436c7e5d5c9dd" translate="yes" xml:space="preserve">
          <source>1) Modifying the character array accessed through the const overload of &lt;code&gt;data&lt;/code&gt; has undefined behavior.</source>
          <target state="translated">1) &lt;code&gt;data&lt;/code&gt; 의 const 오버로드를 통해 액세스되는 문자 배열을 수정하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32267b5e71f7ec1d742dce72b339a8c92ce8f8bc" translate="yes" xml:space="preserve">
          <source>1) Move assignment operator. First, abandons the shared state (as in &lt;code&gt;~promise()&lt;/code&gt;), then assigns the shared state of &lt;code&gt;other&lt;/code&gt; as if by executing &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;(std::move(other)).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1) 할당 연산자를 이동하십시오. 먼저 &lt;code&gt;~promise()&lt;/code&gt; 에서와 같이 공유 상태를 버리고 &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;(std::move(other)).swap(*this)&lt;/code&gt; (std :: move (other)). swap (* this) 를 실행하여 &lt;code&gt;other&lt;/code&gt; 공유 상태를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="87be123334c79f86e66db927b0f1e69d4152ff3f" translate="yes" xml:space="preserve">
          <source>1) Move assignment operator: Moves the contents of &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. After the move, &lt;code&gt;*this&lt;/code&gt; has the associated string, the open mode, the locale, and all other state formerly held by &lt;code&gt;rhs&lt;/code&gt;. The six pointers of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;*this&lt;/code&gt; are guaranteed to be different from the corresponding pointers in the moved-from &lt;code&gt;rhs&lt;/code&gt; unless null.</source>
          <target state="translated">1) 대입 연산자 : &lt;code&gt;rhs&lt;/code&gt; 의 내용 을 &lt;code&gt;*this&lt;/code&gt; 로 옮깁니다 . 이동 후에는 &lt;code&gt;*this&lt;/code&gt; 관련 문자열, 열린 모드, 로케일 및 이전에 &lt;code&gt;rhs&lt;/code&gt; 가 보유한 다른 모든 상태가 있습니다. &lt;code&gt;*this&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 의 6 개 포인터는 null이 아닌 경우 이동 된 &lt;code&gt;rhs&lt;/code&gt; 의 해당 포인터와 달라야합니다 .</target>
        </trans-unit>
        <trans-unit id="7d6353cf0852cf732b2e80b3c54029fc7ed0252d" translate="yes" xml:space="preserve">
          <source>1) Moves &lt;code&gt;count&lt;/code&gt; elements from a range beginning at &lt;code&gt;first&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1)를 이동 &lt;code&gt;count&lt;/code&gt; 의 범위를 처음부터 요소 &lt;code&gt;first&lt;/code&gt; 에서 시작 초기화되지 않은 메모리 영역을 &lt;code&gt;d_first&lt;/code&gt; 같은 경우와</target>
        </trans-unit>
        <trans-unit id="baeda8b2207e79e0e28d467dccba16a337675b05" translate="yes" xml:space="preserve">
          <source>1) Moves all elements from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The elements are inserted after the element pointed to by &lt;code&gt;pos&lt;/code&gt;. The container &lt;code&gt;other&lt;/code&gt; becomes empty after the operation. The behavior is undefined if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) 모든 요소를 &lt;code&gt;other&lt;/code&gt; 에서 &lt;code&gt;*this&lt;/code&gt; 로 이동합니다 . 요소는 &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 뒤에 삽입됩니다 . 컨테이너 &lt;code&gt;other&lt;/code&gt; 수술 후 빈됩니다. &lt;code&gt;other&lt;/code&gt; 가 &lt;code&gt;*this&lt;/code&gt; 와 동일한 객체를 참조 하면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cbee85f489bfd5c711863ceb3ce35d639917da93" translate="yes" xml:space="preserve">
          <source>1) Moves elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1) 요소를 &lt;code&gt;[first, last)&lt;/code&gt; 범위 에서 &lt;code&gt;d_first&lt;/code&gt; 에서 시작하여 초기화되지 않은 메모리 영역 으로 이동</target>
        </trans-unit>
        <trans-unit id="a02bfb3935e9c4bd8c50e3ceaa51a1ac20773de1" translate="yes" xml:space="preserve">
          <source>1) Moves the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;, to another range beginning at &lt;code&gt;d_first&lt;/code&gt;, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.</source>
          <target state="translated">1) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소 를 &lt;code&gt;d_first&lt;/code&gt; 에서 시작하여 last-1로 진행하는 다른 범위 로 이동합니다.이 조작 후에 이동 한 범위의 요소는 여전히 해당 값의 유효한 값을 포함합니다. 유형, 그러나 이동 이전과 반드시 ​​같은 값일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e96eedb6a4729d6cd532f90b4c42d7009c20ae6" translate="yes" xml:space="preserve">
          <source>1) Names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope (which is also the scope of statement).</source>
          <target state="translated">1) init-statement에 의해 선언 된 이름 (init-statement이 선언 인 경우)과 condition에 의해 선언 된 이름 (condition이 선언 인 경우)은 같은 범위 (문의 범위이기도 함)에 있습니다.</target>
        </trans-unit>
        <trans-unit id="29f0125e541e7b6cb76f5dbbc2fb2c46cdd5ba5f" translate="yes" xml:space="preserve">
          <source>1) Narrow multibyte string literal. The type of an unprefixed string literal is &lt;code&gt;const char[N]&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the size of the string in code units of the execution narrow encoding, including the null terminator.</source>
          <target state="translated">1) 좁은 멀티 바이트 문자열 리터럴. 접두사가없는 문자열 리터럴의 유형은 &lt;code&gt;const char[N]&lt;/code&gt; . 여기서 &lt;code&gt;N&lt;/code&gt; 은 널 (null) 종료자를 포함하여 실행 범위가 좁은 인코딩의 코드 단위로 문자열의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="d4f47d080da433e4df7de35bc1790426bc94e157" translate="yes" xml:space="preserve">
          <source>1) Non-throwing dynamic exception specification</source>
          <target state="translated">1) 비 투척 동적 예외 사양</target>
        </trans-unit>
        <trans-unit id="6a6a9ceef837057cbc352d5ec70b0fd0f2b2c8bd" translate="yes" xml:space="preserve">
          <source>1) Number of elements with key &lt;code&gt;key&lt;/code&gt;, that is either 1 or 0.</source>
          <target state="translated">1) 키 &lt;code&gt;key&lt;/code&gt; 가있는 요소의 수 (1 또는 0)</target>
        </trans-unit>
        <trans-unit id="1564a87a6e67740b705461f9434aea174e148c19" translate="yes" xml:space="preserve">
          <source>1) Number of elements with key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1) 키 &lt;code&gt;key&lt;/code&gt; 가있는 요소 수 .</target>
        </trans-unit>
        <trans-unit id="3517215f133f6ebfae6482995743c32e01ac79c9" translate="yes" xml:space="preserve">
          <source>1) Obtains the actual address of the object or function &lt;code&gt;arg&lt;/code&gt;, even in presence of overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt;</source>
          <target state="translated">1) 과부하 된 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 가 존재하더라도 객체 또는 함수 &lt;code&gt;arg&lt;/code&gt; 의 실제 주소를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="63c030571149d7aea7d192bb60285199d1752b0e" translate="yes" xml:space="preserve">
          <source>1) Often known as &quot;C-style&quot; or &quot;multi-line&quot; comments.</source>
          <target state="translated">1) 종종 &quot;C 스타일&quot;또는 &quot;멀티 라인&quot;주석으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="842c5f199cfee8d76155c07d299c1fe9ce02bab8" translate="yes" xml:space="preserve">
          <source>1) Parses the date and time from the input character sequence &lt;code&gt;[beg, end)&lt;/code&gt; according to the format provided in the character sequence &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt;. The format is expected to follow the format described below, although actual processing of each format specifier can be customized by overriding &lt;code&gt;do_get&lt;/code&gt;. The &lt;code&gt;get&lt;/code&gt; function performs the following: First, clears the error bits in &lt;code&gt;err&lt;/code&gt; by executing &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt;. Then enters a loop, which terminates whenever any of the following conditions becomes true (checked in this order):</source>
          <target state="translated">1) 문자 시퀀스 &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; 제공된 형식에 따라 입력 문자 시퀀스 &lt;code&gt;[beg, end)&lt;/code&gt; 에서 날짜와 시간을 구문 분석합니다 . 각 형식 지정자의 실제 처리는 &lt;code&gt;do_get&lt;/code&gt; 을 재정 의하여 사용자 정의 할 수 있지만 형식은 아래 설명 된 형식을 따릅니다 . &lt;code&gt;get&lt;/code&gt; 기능을 수행하는 다음 우선에서 에러 비트를 클리어 &lt;code&gt;err&lt;/code&gt; 실행함으로써 &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;표준 : ios_base :: goodbit&lt;/a&gt; . 그런 다음 루프를 시작하여 다음 조건 중 하나라도 충족 될 때마다 종료됩니다 (이 순서대로 확인 됨).</target>
        </trans-unit>
        <trans-unit id="4251fa4ac37443b00ba495f01dec70943d49534e" translate="yes" xml:space="preserve">
          <source>1) Performs &lt;code&gt;*this = *this + d;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;*this = *this + d;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06459854688602a24bce5db298f1ff763c820069" translate="yes" xml:space="preserve">
          <source>1) Performs &lt;code&gt;*this = *this + m;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;*this = *this + m;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65fb962cbf281356d7871dec0c276ca503ae02f5" translate="yes" xml:space="preserve">
          <source>1) Performs a left rotation on a range of elements.</source>
          <target state="translated">1) 다양한 요소에 대해 왼쪽 회전을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="24157bdc426e8751a205fa626eea64b65972c149" translate="yes" xml:space="preserve">
          <source>1) Performs atomic addition. Equivalent to &lt;code&gt;fetch_add(arg)&lt;/code&gt; + arg.</source>
          <target state="translated">1) 원자 첨가를 수행합니다. &lt;code&gt;fetch_add(arg)&lt;/code&gt; + arg 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b7b35043c329a05e326ecc4ac09efa80c7ee56f7" translate="yes" xml:space="preserve">
          <source>1) Performs atomic addition. Equivalent to &lt;code&gt;return fetch_add(arg) + arg;&lt;/code&gt;.</source>
          <target state="translated">1) 원자 첨가를 수행합니다. &lt;code&gt;return fetch_add(arg) + arg;&lt;/code&gt; 를 반환하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="0419ff58b80e0ea3e34dbe1120d304b2154ccd33" translate="yes" xml:space="preserve">
          <source>1) Performs atomic pre-increment. Equivalent to &lt;code&gt;fetch_add(1)+1&lt;/code&gt;.</source>
          <target state="translated">1) 원자 사전 증가를 수행합니다. 등가 &lt;code&gt;fetch_add(1)+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d7cb0da243e1e814c426ca15e77bf948db18b30" translate="yes" xml:space="preserve">
          <source>1) Performs atomic pre-increment. Equivalent to &lt;code&gt;return fetch_add(1) + 1;&lt;/code&gt;.</source>
          <target state="translated">1) 원자 사전 증가를 수행합니다. &lt;code&gt;return fetch_add(1) + 1;&lt;/code&gt; 을 반환하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="8165604074e09874cc008cd54a9677022761ce36" translate="yes" xml:space="preserve">
          <source>1) Pre-increment. Returns the updated iterator.</source>
          <target state="translated">1) 사전 증가. 업데이트 된 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98b2b73f529f9a9c81704e2afa46fe127b827d7f" translate="yes" xml:space="preserve">
          <source>1) Previous associated locale.</source>
          <target state="translated">1) 이전에 연결된 로케일.</target>
        </trans-unit>
        <trans-unit id="90eaf4a181c70f4e6dd5dad828ce93c49a0f00b7" translate="yes" xml:space="preserve">
          <source>1) Primary template is an empty struct.</source>
          <target state="translated">1) 기본 템플릿은 빈 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="d3b8bab61ba0a04eca35d2c18428e6aaa3ccf10f" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_always_noconv&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_always_noconv&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="baf1382568df4bb859c2f19d25f5fa51f0d6c8b6" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_curr_symbol&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_curr_symbol&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="8803148252b377ffcd4da972f99e35584fa057b1" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_decimal_point&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_decimal_point&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6f5e8bfa91bd146e3eb1c442796dcc622fd2cb53" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_frac_digits&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_frac_digits&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="cd263bbd005fdfda08890b70706b6c4d80e469da" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_get&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_get&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2ea4e6b7dcb9f599bddec78e09271c36d3302c0e" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_grouping&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_grouping&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2f1cefcfa79a30f86558cc5d92aa1f12547b1071" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_in&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_in&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="caad5ee2da96131cd137488a3b8e49826497e05d" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_max_length&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_max_length&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c42e6d12a6460383165ecd093240a382422e7a50" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_pos_format&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_pos_format&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bc5bc70d6c3c7d1b63e978e2bb5f510449787adf" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_positive_sign&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_positive_sign&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6a7fb6649c9c1933430d44d28c9be6af80e73282" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_thousands_sep&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_thousands_sep&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a05a1a4712a55bd65ed1b7c2d0c6498741ebcfac" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_compare&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_compare&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="50240ff8cfc5297f7dea433cf9aa0e95cbb740bd" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_date_order&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_date_order&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="dc988aac8e2069c8157a164371668baa84732662" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_get&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_get&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e3956434b335523e445a7f66b881b7d9081d9286" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_get_date()&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_get_date()&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="aa8c3a179dd224f964496fd3cf87120527402883" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_hash&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_hash&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f5b1e143ebb344d5c93a9cd3e3d5c1234ffeed9a" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_open&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_open&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c3021e1c4d5e1cb04a9c13b29e49851c5fc32a48" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_put&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공용 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_put&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="02f297d72b24e5ec0b50eab50682c4aeb7a9ac16" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_transform&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_transform&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="8792ca5b24450313548e3eafb8702266f2eb881c" translate="yes" xml:space="preserve">
          <source>1) Reads one character and returns it if available. Otherwise, returns &lt;code&gt;Traits::eof()&lt;/code&gt; and sets &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;failbit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;eofbit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) 한 문자를 읽고 가능한 경우 반환합니다. 그렇지 않으면 &lt;code&gt;Traits::eof()&lt;/code&gt; 반환 하고 &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;failbit&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;eofbit&lt;/a&gt;&lt;/code&gt; 를 설정 합니다 .</target>
        </trans-unit>
        <trans-unit id="b24556d7aac836f48afb6674f5c717012f92f983" translate="yes" xml:space="preserve">
          <source>1) Reads the data from &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="7396d1f8b950a76b6370b58eb711a32d6d49c388" translate="yes" xml:space="preserve">
          <source>1) Reads the data from &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="6a217932442a1d0a2f62a838e385afc124dbe4bd" translate="yes" xml:space="preserve">
          <source>1) Refers to a &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object representing the type type. If type is a reference type, the result refers to a &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object representing the referenced type.</source>
          <target state="translated">1) 타입 타입을 나타내는 &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 객체를 참조하십시오. type이 참조 유형 인 경우 결과는 참조 된 유형을 나타내는 &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 객체를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="861842b860dc887a6543ee6224b6ce48a8a61aa1" translate="yes" xml:space="preserve">
          <source>1) Regular function declarator syntax</source>
          <target state="translated">1) 정규 함수 선언자 구문</target>
        </trans-unit>
        <trans-unit id="6cbbb4ec5d9adc038750b690542f0bc0dae8623a" translate="yes" xml:space="preserve">
          <source>1) Releases any shared state and assigns the contents of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. After the assignment, &lt;code&gt;this-&amp;gt;valid() == other.valid()&lt;/code&gt;.</source>
          <target state="translated">1) 공유 상태를 해제하고 &lt;code&gt;other&lt;/code&gt; 의 내용 을 &lt;code&gt;*this&lt;/code&gt; 에 지정하십시오 . 할당 후 &lt;code&gt;this-&amp;gt;valid() == other.valid()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38bb6282680f52e2fda17aa9983f1073eb7c0c47" translate="yes" xml:space="preserve">
          <source>1) Releases any shared state and move-assigns the contents of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. After the assignment, &lt;code&gt;other.valid() == false&lt;/code&gt; and &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;this-&amp;gt;valid()&lt;/code&gt;&lt;/a&gt; will yield the same value as &lt;code&gt;other.valid()&lt;/code&gt; before the assignment.</source>
          <target state="translated">1) 공유 상태를 해제하고 &lt;code&gt;other&lt;/code&gt; 내용 을 &lt;code&gt;*this&lt;/code&gt; 에 할당합니다 . 할당 후 &lt;code&gt;other.valid() == false&lt;/code&gt; 이고 &lt;a href=&quot;valid&quot;&gt; &lt;code&gt;this-&amp;gt;valid()&lt;/code&gt; &lt;/a&gt; 는 할당 전 &lt;code&gt;other.valid()&lt;/code&gt; 와 동일한 값을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="b5b667ade567f1b29b3c27fd07f95ac68433c004" translate="yes" xml:space="preserve">
          <source>1) Releases the ownership of the managed object, if any. After the call, &lt;code&gt;*this&lt;/code&gt; manages no object. Equivalent to &lt;code&gt;shared_ptr().swap(*this);&lt;/code&gt;</source>
          <target state="translated">1) 관리 객체의 소유권을 해제합니다 (있는 경우). 호출 후 &lt;code&gt;*this&lt;/code&gt; 객체를 관리하지 않습니다. &lt;code&gt;shared_ptr().swap(*this);&lt;/code&gt; 같습니다 .swap (* this);</target>
        </trans-unit>
        <trans-unit id="058dae359c875bb8aea961ac9a8c89d60ef65185" translate="yes" xml:space="preserve">
          <source>1) Removes</source>
          <target state="translated">1) 제거</target>
        </trans-unit>
        <trans-unit id="8c4e68b9d2c4305008d048fc061e3772b5809315" translate="yes" xml:space="preserve">
          <source>1) Removes all elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;value&lt;/code&gt; 와 같은 모든 요소를 ​​제거합니다 .</target>
        </trans-unit>
        <trans-unit id="869efa782ed2427565d277c2e6014424441dd053" translate="yes" xml:space="preserve">
          <source>1) Removes the element at &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;pos&lt;/code&gt; 에서 요소를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="ffec9f7979d764e0359835e77f17747b23d8b2dd" translate="yes" xml:space="preserve">
          <source>1) Removes the element following &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;pos&lt;/code&gt; 다음에 나오는 요소를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="17ef257965eb0ab3b49b26ba1ea702b626c6aa3f" translate="yes" xml:space="preserve">
          <source>1) Reorders the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in such a way that all elements for which the predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; precede the elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. Relative order of the elements is not preserved.</source>
          <target state="translated">1) 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 모든 요소 가 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는 요소 앞에 오도록 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소를 재정렬합니다 . 요소의 상대적 순서는 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="adce2245dd094ab71b482b217c791cf528174e3e" translate="yes" xml:space="preserve">
          <source>1) Reorders the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in such a way that all elements for which the predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; precede the elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. Relative order of the elements is preserved.</source>
          <target state="translated">1) 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 모든 요소 가 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는 요소 앞에 오도록 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소를 재정렬합니다 . 요소의 상대적 순서가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2dac5da3d02f4d437123f2a0b9d56eb2e4fd0857" translate="yes" xml:space="preserve">
          <source>1) Replaces all elements that are equal to &lt;code&gt;old_value&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;old_value&lt;/code&gt; 와 동일한 모든 요소를 ​​대체합니다 .</target>
        </trans-unit>
        <trans-unit id="2e3318a609e82a644898d7222b1da6b96eacbe12" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents of &lt;code&gt;*this&lt;/code&gt; with a pathname whose both native and generic format representations equal those of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 의 내용을 기본 형식 표현과 일반 형식 표현이 &lt;code&gt;p&lt;/code&gt; 의 것과 동일한 경로 이름으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="e240befa148e0203cedd59eee5956df5acad945f" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt;.</source>
          <target state="translated">1)와 대체 컨텐츠 &lt;code&gt;count&lt;/code&gt; 캐릭터의 복사본 &lt;code&gt;ch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6b05f959c13293d5a5d5af2a8637f634e41da89" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with &lt;code&gt;count&lt;/code&gt; copies of value &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">1)로 대체 컨텐츠를 &lt;code&gt;count&lt;/code&gt; 사본 값의 &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29d8d55620552a2c6832d320259ce67308463212" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with a copy of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; are the same object, this function has no effect.</source>
          <target state="translated">1) 내용을 &lt;code&gt;str&lt;/code&gt; 사본으로 바꿉니다 . 하면 &lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 동일한 목적이며,이 기능은 효과가 없다.</target>
        </trans-unit>
        <trans-unit id="270b4bf667b635c284aba5086d9e163a6e0904f5" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;container-&amp;gt;push_back(value)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;container-&amp;gt;push_back(value)&lt;/code&gt; 결과</target>
        </trans-unit>
        <trans-unit id="40ecaa5e7b5b215ddbaec386d81fbe27a35ad522" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;container-&amp;gt;push_front(value)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;container-&amp;gt;push_front(value)&lt;/code&gt; 결과</target>
        </trans-unit>
        <trans-unit id="8712ae4fa015816336c007fe3a9a6dcf1cb77223" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;iter = container-&amp;gt;insert(iter, value); ++iter;&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;iter = container-&amp;gt;insert(iter, value); ++iter;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65e2795a9414bee5546a758244d76abfed9cefbf" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;*lhs.resource() == *rhs.resource()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;*lhs.resource() == *rhs.resource()&lt;/code&gt; 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2502d83ce08382fe677e2911a3d1cccaddcc99f3" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;*this&lt;/code&gt; converted to &lt;a href=&quot;../path&quot;&gt;normal form&lt;/a&gt; in its generic format</source>
          <target state="translated">1) 반환은 &lt;code&gt;*this&lt;/code&gt; 로 변환 &lt;a href=&quot;../path&quot;&gt;정상적인 형태&lt;/a&gt; 의 일반적인 형식</target>
        </trans-unit>
        <trans-unit id="3a923a689d5fab3840318f3d549827b3318bcbf5" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;iter&lt;/code&gt; unchanged</source>
          <target state="translated">1) &lt;code&gt;iter&lt;/code&gt; 를 변경하지 않고 반환</target>
        </trans-unit>
        <trans-unit id="b92bef1e9a732e0b29effd33edcabf38014c435d" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;relative(p, current_path(), ec)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;relative(p, current_path(), ec)&lt;/code&gt; 반환합니다</target>
        </trans-unit>
        <trans-unit id="5de64d91bbdbee0c01c0e8e9cb2b99b1df930700" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 를 반환</target>
        </trans-unit>
        <trans-unit id="a484b37cffb98b770d8354adcf0625dcd7c1759e" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are both end-of-sequence iterators, or if all of the following conditions are true:</source>
          <target state="translated">1) 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 모두 끝 순서 반복자가 있거나 다음 조건 모두에 해당하면 :</target>
        </trans-unit>
        <trans-unit id="56de7954cc2d00b655ce1ec3c457bb6134e5cbf3" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;lhs&lt;/code&gt; 과 &lt;code&gt;rhs&lt;/code&gt; , 동일 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="c94da87dbdee081478fa1d7dee357f47bd78ed41" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">1) 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;lhs&lt;/code&gt; 있다</target>
        </trans-unit>
        <trans-unit id="7fac7f5450d225457e6b78589c98f2513f4014ce" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; that satisfy the predicate &lt;code&gt;p&lt;/code&gt; appear before all elements that don't. Also returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;[first, last)&lt;/code&gt; is empty.</source>
          <target state="translated">1) 술어 &lt;code&gt;p&lt;/code&gt; 를 만족하는 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 모든 요소가 그렇지 않은 모든 요소 앞에 나타나면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . &lt;code&gt;[first, last)&lt;/code&gt; 가 비어 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2aba12f91ced7a05bef1178e9c4fd5864add3fd6" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if lhs is less than rhs, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) lhs가 rhs보다 작 으면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a60b75738d79d6ba929ed47e4bcd56cf5f07f4d" translate="yes" xml:space="preserve">
          <source>1) Returns a &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; containing the result of binary AND on corresponding pairs of bits of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">1) 대응하는 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 쌍의 비트에 대해 이진 AND의 결과를 포함하는 비트 세트 &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e56d712102c4d0fe2dae24e3b57a4a8cfd5aa505" translate="yes" xml:space="preserve">
          <source>1) Returns a copy of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 의 사본을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ca096d06281ae150d54482a6cc1e549ce108c224" translate="yes" xml:space="preserve">
          <source>1) Returns a copy of the underlying string as if by calling &lt;code&gt;rdbuf()-&amp;gt;str()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;rdbuf()-&amp;gt;str()&lt;/code&gt; 을 호출하여 마치 기본 문자열의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a1c616be8d7e9418723ddfcbc3e52606258ec3df" translate="yes" xml:space="preserve">
          <source>1) Returns a null pointer if &lt;code&gt;fail()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, otherwise returns a non-null pointer. This pointer is implicitly convertible to &lt;code&gt;bool&lt;/code&gt; and may be used in boolean contexts.</source>
          <target state="translated">1) &lt;code&gt;fail()&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환하면 null 포인터를 반환 하고 , 그렇지 않으면 null이 아닌 포인터를 반환합니다. 이 포인터는 암시 적으로 &lt;code&gt;bool&lt;/code&gt; 로 변환 가능하며 부울 컨텍스트에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2284f1e367243c98935f80fc109c83a94a54f3c" translate="yes" xml:space="preserve">
          <source>1) Returns a numeric array of &lt;code&gt;bool&lt;/code&gt; containing elements each of which is obtained by applying the indicated comparison operator to the corresponding values of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">1) 표시된 비교 연산자를 대응하는 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 값에 적용하여 얻은 각 요소를 포함하는 &lt;code&gt;bool&lt;/code&gt; 의 숫자 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3100a3df15f07b6e5ef0d2e827ee2f7cdbf6175d" translate="yes" xml:space="preserve">
          <source>1) Returns a pointer to the contained value.</source>
          <target state="translated">1) 포함 된 값에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0d2c31549336b964b7be2eb179a144f92cc116bc" translate="yes" xml:space="preserve">
          <source>1) Returns a possibly const-qualified iterator to the reverse-beginning of the container &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">1) 컨테이너 &lt;code&gt;c&lt;/code&gt; 의 역 시작에 대해 const 한정된 반복자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7a063c1b9ad5e32ce34dcdfd8ca4b82cf3c236ca" translate="yes" xml:space="preserve">
          <source>1) Returns a possibly const-qualified iterator to the reverse-end of the container &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">1) 가능한 한정된 반복자를 컨테이너 &lt;code&gt;c&lt;/code&gt; 의 반대쪽 끝으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="13631d6a37bc7ed73ea92514ab164c6764fc704e" translate="yes" xml:space="preserve">
          <source>1) Returns a reference to the current &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) 현재 &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; 대한 참조를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f3b6280f71abf114f54373c3e7590153910cd5d6" translate="yes" xml:space="preserve">
          <source>1) Returns a reference to the global &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; singleton. If this is the first access to the database, initialize the database. After the initialization, the database will hold a single initialized &lt;code&gt;std::chrono::tzdb&lt;/code&gt; object. This function is thread-safe: concurrent calls to this function from multiple threads do not introduce a data race.</source>
          <target state="translated">1) 전역 &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; 싱글 톤에 대한 참조를 리턴합니다 . 이것이 데이터베이스에 대한 첫 번째 액세스 인 경우 데이터베이스를 초기화하십시오. 초기화 후 데이터베이스는 초기화 된 단일 &lt;code&gt;std::chrono::tzdb&lt;/code&gt; 오브젝트를 보유 합니다. 이 함수는 스레드로부터 안전합니다. 여러 스레드에서이 함수를 동시에 호출하면 데이터 경쟁이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a81e180b9a39b86ed42f18915e1912a4b70010f8" translate="yes" xml:space="preserve">
          <source>1) Returns an implementation-defined type that holds a reference to &lt;code&gt;*this&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; is &lt;a href=&quot;auto_ptr&quot;&gt;convertible&lt;/a&gt; and &lt;a href=&quot;operator=&quot;&gt;assignable&lt;/a&gt; from this template. The implementation is allowed to provide the template with a different name or implement equivalent functionality in other ways.</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 에 대한 참조를 보유한 구현 정의 유형을 리턴합니다 . &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; 이다 &lt;a href=&quot;auto_ptr&quot;&gt;컨버터블&lt;/a&gt; 및 &lt;a href=&quot;operator=&quot;&gt;양도&lt;/a&gt; 이 템플릿에서. 구현시 템플릿에 다른 이름을 제공하거나 다른 방식으로 동등한 기능을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ed78a0dd559758ebfb9c2949e5a988bace3ce62" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator pointing to the first element that is</source>
          <target state="translated">1) 첫 번째 요소를 가리키는 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6844338cdc96e911c46728c0c867f432dd1a50ec" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first character of the view. Equivalent to &lt;code&gt;sv.begin()&lt;/code&gt;.</source>
          <target state="translated">1) 반복자를 뷰의 첫 문자로 리턴합니다. &lt;code&gt;sv.begin()&lt;/code&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6cd397aaa829398a2797783162cadf8568d17dba" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first element of the path. If the path is empty, the returned iterator is equal to &lt;code&gt;end()&lt;/code&gt;.</source>
          <target state="translated">1) 반복자를 경로의 첫 번째 요소로 반환합니다. 경로가 비어 있으면 반환 된 반복자는 &lt;code&gt;end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbc84a634be5255d1d6be17b5b6cfff82d9198c3" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first element of the span. Equivalent to &lt;code&gt;s.begin()&lt;/code&gt;.</source>
          <target state="translated">1) 스팬의 첫 번째 요소에 반복자를 반환합니다. &lt;code&gt;s.begin()&lt;/code&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="964e9b36a5abe52ebf725814fc0423c129fbe227" translate="yes" xml:space="preserve">
          <source>1) Returns current maximum load factor.</source>
          <target state="translated">1) 현재 최대 부하 계수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc6b701735443a9096b6e72058c3c17fa0eb40fd" translate="yes" xml:space="preserve">
          <source>1) Returns exactly &lt;code&gt;c.begin()&lt;/code&gt;, which is typically an iterator to the beginning of the sequence represented by &lt;code&gt;c&lt;/code&gt;. If &lt;code&gt;C&lt;/code&gt; is a standard &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, this returns &lt;code&gt;C::iterator&lt;/code&gt; when &lt;code&gt;c&lt;/code&gt; is not const-qualified, and &lt;code&gt;C::const_iterator&lt;/code&gt; otherwise.</source>
          <target state="translated">1) 정확히 &lt;code&gt;c.begin()&lt;/code&gt; )을 반환합니다. 일반적으로 &lt;code&gt;c&lt;/code&gt; 로 표시된 시퀀스의 시작 부분에 대한 반복자 입니다. 경우 &lt;code&gt;C&lt;/code&gt; 가 표준입니다 &lt;a href=&quot;../named_req/container&quot;&gt;컨테이너&lt;/a&gt; 이 반환 &lt;code&gt;C::iterator&lt;/code&gt; 때 &lt;code&gt;c&lt;/code&gt; const를-자격이되지 않으며, &lt;code&gt;C::const_iterator&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="c8e94140f9ef40bf1d36874da1c9ebca27cad214" translate="yes" xml:space="preserve">
          <source>1) Returns exactly &lt;code&gt;c.end()&lt;/code&gt;, which is typically an iterator one past the end of the sequence represented by &lt;code&gt;c&lt;/code&gt;. If &lt;code&gt;C&lt;/code&gt; is a standard &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, this returns a &lt;code&gt;C::iterator&lt;/code&gt; when &lt;code&gt;c&lt;/code&gt; is not const-qualified, and a &lt;code&gt;C::const_iterator&lt;/code&gt; otherwise.</source>
          <target state="translated">1) 정확히 &lt;code&gt;c.end()&lt;/code&gt; )를 반환합니다. 일반적으로 &lt;code&gt;c&lt;/code&gt; 로 표시된 시퀀스의 끝을지나 반복자 입니다. 경우 &lt;code&gt;C&lt;/code&gt; 는 표준입니다 &lt;a href=&quot;../named_req/container&quot;&gt;컨테이너&lt;/a&gt; 이 리턴한다 &lt;code&gt;C::iterator&lt;/code&gt; 때 &lt;code&gt;c&lt;/code&gt; const를-규정되지 및 &lt;code&gt;C::const_iterator&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="d2d79bb6bfb415bc4799cd03340ea976f5e1ad4e" translate="yes" xml:space="preserve">
          <source>1) Returns file permissions information.</source>
          <target state="translated">1) 파일 권한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca8cb5bb5515d3f764ff15bb64205d48c54ff968" translate="yes" xml:space="preserve">
          <source>1) Returns file type information.</source>
          <target state="translated">1) 파일 형식 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbec588b4dae3ad630f2f6af2e54b55a2be244d6" translate="yes" xml:space="preserve">
          <source>1) Returns status of the entry, as if determined by a &lt;a href=&quot;../status&quot;&gt;status&lt;/a&gt; call (symlinks are followed to their targets)</source>
          <target state="translated">1) &lt;a href=&quot;../status&quot;&gt;상태&lt;/a&gt; 호출에 의해 결정된 것처럼 항목의 상태를 리턴합니다 (기호가 대상으로 이어짐)</target>
        </trans-unit>
        <trans-unit id="292239ac393513bb2a73e81850757d26b7552c99" translate="yes" xml:space="preserve">
          <source>1) Returns the</source>
          <target state="translated">1) 반환</target>
        </trans-unit>
        <trans-unit id="0fb0365146c39ac72ff8fc5a9c4e8c203a48497d" translate="yes" xml:space="preserve">
          <source>1) Returns the &amp;alpha; distribution parameter. It is also known as the shape parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) &amp;alpha; 분포 모수를 구합니다. 모양 매개 변수라고도합니다. 기본값은 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="21227b553d58a19b72f0fe801e0f03bd0a1049b3" translate="yes" xml:space="preserve">
          <source>1) Returns the a distribution parameter (location). The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) 분포 모수 (위치)를 반환합니다. 기본값은 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="143347fc7ff8e780591f1e29b03e2d7669e75b6f" translate="yes" xml:space="preserve">
          <source>1) Returns the a parameter. It defines the shape of the distribution. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) a 매개 변수를 리턴합니다. 분포의 모양을 정의합니다. 기본값은 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a2d1f91a5f400fc1fd6adcb1746a21b04fe35b6f" translate="yes" xml:space="preserve">
          <source>1) Returns the associated parameter set.</source>
          <target state="translated">1) 관련 파라미터 세트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a15f06fffff72065df3b268612d6a17f5310aa58" translate="yes" xml:space="preserve">
          <source>1) Returns the associated stream buffer. If there is no associated stream buffer, returns a null pointer.</source>
          <target state="translated">1) 연결된 스트림 버퍼를 반환합니다. 연결된 스트림 버퍼가 없으면 null 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="22cd7377868adb410066182a3c8def7ed5f1fa07" translate="yes" xml:space="preserve">
          <source>1) Returns the current field width.</source>
          <target state="translated">1) 현재 필드 너비를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f41a7bceca1233658cedea4989b3de36c56d029f" translate="yes" xml:space="preserve">
          <source>1) Returns the current precision.</source>
          <target state="translated">1) 현재 정밀도를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="001731be05f0e739b1a39d0921456a3adf786c45" translate="yes" xml:space="preserve">
          <source>1) Returns the current tied stream. If there is no tied stream, a null pointer is returned.</source>
          <target state="translated">1) 현재 연결된 스트림을 반환합니다. 묶인 스트림이 없으면 null 포인터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5acdce3496544fa0bd7b2c030f8bf1d9c5f72571" translate="yes" xml:space="preserve">
          <source>1) Returns the exception mask.</source>
          <target state="translated">1) 예외 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1694f8d96fa622b3f17ae9121b869a1b0312a6ef" translate="yes" xml:space="preserve">
          <source>1) Returns the imaginary component of the complex number &lt;code&gt;z&lt;/code&gt;, i.e. &lt;code&gt;z.imag()&lt;/code&gt;.</source>
          <target state="translated">1) 복소수 &lt;code&gt;z&lt;/code&gt; 의 허수 부 , 즉 &lt;code&gt;z.imag()&lt;/code&gt; )를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="49125a8b6077342f10be4d243d2ed33fbfe22de1" translate="yes" xml:space="preserve">
          <source>1) Returns the imaginary part.</source>
          <target state="translated">1) 허수 부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af75cb25c63821285d34593afc3031d58d00ddf9" translate="yes" xml:space="preserve">
          <source>1) Returns the list of boundaries of the intervals.</source>
          <target state="translated">1) 구간의 경계 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c3aa7a255032d162e6721d758482183c8e0d4e5" translate="yes" xml:space="preserve">
          <source>1) Returns the log-mean m distribution parameter. It defines the location of the peak. The default value is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">1) 로그 평균 m 분포 모수를 구합니다. 피크의 위치를 ​​정의합니다. 기본값은 &lt;code&gt;0.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cb15710c8fbb6d1b45fb72076cb13894fb56f750" translate="yes" xml:space="preserve">
          <source>1) Returns the m (the first degree of freedom) distribution parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) m (제 1 자유도) 분포 모수를 구합니다. 기본값은 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="12bbddb8b9d6e0fbda5e7775b18ff17adbbacb80" translate="yes" xml:space="preserve">
          <source>1) Returns the mean &amp;mu; distribution parameter. The mean specifies the location of the peak. The default value is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">1) 평균 &amp;mu; 분포 모수를 구합니다. 평균은 피크의 위치를 ​​지정합니다. 기본값은 &lt;code&gt;0.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="47a018754522c2f9b7cd2238570b2ebdebe1376b" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1) 키 &lt;code&gt;key&lt;/code&gt; 가있는 요소 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4307f7beb5cbf30b6fd034cf152d44ddfc23058a" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key that compares equal to the specified argument &lt;code&gt;key&lt;/code&gt;, which is either 1 or 0 since this container does not allow duplicates.</source>
          <target state="translated">1) 지정된 인수 &lt;code&gt;key&lt;/code&gt; 와 동일한 키를 가지는 요소 수를 돌려줍니다. 이 컨테이너는 복제를 허가하지 않기 때문에 1 또는 0입니다.</target>
        </trans-unit>
        <trans-unit id="eb9b09c24f4dd3756959d45d14cfe7322d3d6eb0" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key that compares equal to the specified argument &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1) 지정된 인수 &lt;code&gt;key&lt;/code&gt; 와 동일한 키를 가진 요소 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d0b0dd6464e410f3559cc88a021648404b61cfba" translate="yes" xml:space="preserve">
          <source>1) Returns the object owned by &lt;code&gt;*this&lt;/code&gt;, equivalent to &lt;code&gt;*get()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;*get()&lt;/code&gt; &lt;code&gt;*this&lt;/code&gt; 소유 한 객체를 반환합니다 . * get () 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="efadb8f443ff52a8a06ff3cca490584c99089f22" translate="yes" xml:space="preserve">
          <source>1) Returns the p distribution parameter. It defines the probability of a trial generating &lt;code&gt;true&lt;/code&gt;. The default value is &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">1) p 분포 모수를 구합니다. 시험이 &lt;code&gt;true&lt;/code&gt; 를 생성 할 확률을 정의 합니다 . 기본값은 &lt;code&gt;0.5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="06ea4503952409f3d220d8a31ac2c3d9a0b87e8b" translate="yes" xml:space="preserve">
          <source>1) Returns the pointer to the beginning (&quot;base&quot;) of the put area.</source>
          <target state="translated">1) 풋 영역의 시작 ( &quot;base&quot;)에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d711b398059e09252c735c5b767a6c4f3b8c2d28" translate="yes" xml:space="preserve">
          <source>1) Returns the pointer to the beginning of the get area.</source>
          <target state="translated">1) get 영역의 시작 부분에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81b834f0d5a61937ab85cb95196e573fab4dbf45" translate="yes" xml:space="preserve">
          <source>1) Returns the real component of the complex number &lt;code&gt;z&lt;/code&gt;, i.e. &lt;code&gt;z.real()&lt;/code&gt;.</source>
          <target state="translated">1) 복소수 &lt;code&gt;z&lt;/code&gt; 의 실수 성분 , 즉 &lt;code&gt;z.real()&lt;/code&gt; )을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="088dec1497a550df9243695c3279f03c8fb7947b" translate="yes" xml:space="preserve">
          <source>1) Returns the real part.</source>
          <target state="translated">1) 실수 부분을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f3e1ba68c1324385714f799b9c29d179d2e6b88" translate="yes" xml:space="preserve">
          <source>1) Returns the squared magnitude of the complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1) 복소수 &lt;code&gt;z&lt;/code&gt; 의 제곱 크기를 구합니다 .</target>
        </trans-unit>
        <trans-unit id="c70906930f9cd42e8f972b6ea9d3588d75bb9758" translate="yes" xml:space="preserve">
          <source>1) Returns the stored &lt;code&gt;std::chrono::month&lt;/code&gt; value.</source>
          <target state="translated">1) 저장된 &lt;code&gt;std::chrono::month&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ce5d3c03147c08fafbfcc97025b8268f78f5aaea" translate="yes" xml:space="preserve">
          <source>1) Returns the stored &lt;code&gt;std::chrono::year&lt;/code&gt; value.</source>
          <target state="translated">1) 저장된 &lt;code&gt;std::chrono::year&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="61dadd5c36bffe5a48255156199fa6c44fd84e1d" translate="yes" xml:space="preserve">
          <source>1) Returns the time of the last modification of &lt;code&gt;p&lt;/code&gt;, determined as if by accessing the member &lt;code&gt;st_mtime&lt;/code&gt; of the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed) The non-throwing overload returns &lt;code&gt;file_time_type::min()&lt;/code&gt; on errors.</source>
          <target state="translated">1)의 마지막 수정 시간 돌려 &lt;code&gt;p&lt;/code&gt; 멤버 액세스하여 것처럼 결정 &lt;code&gt;st_mtime&lt;/code&gt; 는 POSIX에서의 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;스탯&lt;/a&gt; (심볼릭 링크)는 비 던지고 과부하 반환 따른다 &lt;code&gt;file_time_type::min()&lt;/code&gt; 에러에있다.</target>
        </trans-unit>
        <trans-unit id="aa97c65b799f5efb0b02504a22a02ad70a88e318" translate="yes" xml:space="preserve">
          <source>1) Returns the value of its argument</source>
          <target state="translated">1) 인수 값을 반환</target>
        </trans-unit>
        <trans-unit id="533e65d4cbce1169e96cd03deb423e1ebed9ef4f" translate="yes" xml:space="preserve">
          <source>1) Returns the value of the file position state</source>
          <target state="translated">1) 파일 위치 상태의 값을 반환</target>
        </trans-unit>
        <trans-unit id="8bd1eba1fbdf89c5698365e7fe91902373d9c621" translate="yes" xml:space="preserve">
          <source>1) Returns true if all of the bits in &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 의 모든 비트 가 동일한 경우 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="998c1c493c58a67ce9bb205f050c7dbaf76aed9b" translate="yes" xml:space="preserve">
          <source>1) Reverses the order of the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;[first, last)&lt;/code&gt; 범위에서 요소의 순서를 반대로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="8d1ddbebd20349684cf4acb8ec8e6b2d4f4d96e9" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;a href=&quot;iterator_t&quot;&gt;&lt;code&gt;ranges::iterator_t&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;R&lt;/code&gt; models exposition-only concept &lt;a href=&quot;range&quot;&gt;&lt;code&gt;__ForwardingRange&lt;/code&gt;&lt;/a&gt;, otherwise yields &lt;a href=&quot;dangling&quot;&gt;&lt;code&gt;ranges::dangling&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">1) &lt;code&gt;R&lt;/code&gt; 이 박람회 전용 개념 인 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;__ForwardingRange&lt;/code&gt; 를&lt;/a&gt; 모델링하는 경우 &lt;a href=&quot;iterator_t&quot;&gt; &lt;code&gt;ranges::iterator_t&lt;/code&gt; &lt;/a&gt; 와 동일하며 , 그렇지 않으면 &lt;a href=&quot;dangling&quot;&gt; &lt;code&gt;ranges::dangling&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="14f30d52df1968fd80f273b59c9c1e7531df510b" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;a href=&quot;noexcept_spec&quot;&gt;&lt;code&gt;noexcept(true)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">1) &lt;a href=&quot;noexcept_spec&quot;&gt; &lt;code&gt;noexcept(true)&lt;/code&gt; &lt;/a&gt; 와 동일 (true)</target>
        </trans-unit>
        <trans-unit id="4def597a1104c9ab9fae317a750663a62c536d96" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;code&gt;noexcept&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;true&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;noexcept&lt;/code&gt; 와 동일 &lt;code&gt;(&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c9b60d20817d9dc8664bdd29847776bc1e84582" translate="yes" xml:space="preserve">
          <source>1) Searches for the file in implementation-defined manner. The intent of this syntax is to search for the files under control of the implementation. Typical implementations search only standard include directories. The standard C++ library and the standard C library are implicitly included in these standard include directories. The standard include directories usually can be controlled by the user through compiler options.</source>
          <target state="translated">1) 구현 정의 방식으로 파일을 검색합니다. 이 구문의 목적은 구현을 제어하는 ​​파일을 검색하는 것입니다. 일반적인 구현은 표준 include 디렉토리 만 검색합니다. 표준 C ++ 라이브러리 및 표준 C 라이브러리는 이러한 표준 포함 디렉토리에 내재적으로 포함됩니다. 표준 포함 디렉토리는 보통 컴파일러 옵션을 통해 사용자가 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40b026d27109ca4160eaec8af9d9260a322193ab" translate="yes" xml:space="preserve">
          <source>1) Seeds the underlying engine with the default seed value. Effectively calls &lt;code&gt;e.seed()&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is the underlying engine.</source>
          <target state="translated">1) 기본 시드 값으로 기본 엔진을 시드합니다. 효과적으로 &lt;code&gt;e.seed()&lt;/code&gt; 호출합니다 . 여기서 &lt;code&gt;e&lt;/code&gt; 는 기본 엔진입니다.</target>
        </trans-unit>
        <trans-unit id="f142d0432d80c80b2801b2b54dcc353009676c5d" translate="yes" xml:space="preserve">
          <source>1) Serializes the internal state of the pseudo-random number engine &lt;code&gt;e&lt;/code&gt; as a sequence of decimal numbers separated by one or more spaces, and inserts it to the stream &lt;code&gt;ost&lt;/code&gt;. The fill character and the formatting flags of the stream are ignored and unaffected.</source>
          <target state="translated">1) 의사 난수 엔진 &lt;code&gt;e&lt;/code&gt; 의 내부 상태를 하나 이상의 공백으로 구분 된 일련의 10 진수로 직렬화 하여 스트림 &lt;code&gt;ost&lt;/code&gt; 에 삽입합니다 . 스트림의 채우기 문자 및 서식 플래그는 무시되고 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08f8da6462aba2a7fffaed13b8fbb52f524e794c" translate="yes" xml:space="preserve">
          <source>1) Serializes the internal state of the pseudo-random number engine adaptor as a sequence of decimal numbers separated by one or more spaces, and inserts it to the stream &lt;code&gt;ost&lt;/code&gt;. The fill character and the formatting flags of the stream are ignored and unaffected.</source>
          <target state="translated">1) 의사 난수 엔진 어댑터의 내부 상태를 하나 이상의 공백으로 구분 된 10 진수 시퀀스로 직렬화하여 스트림 &lt;code&gt;ost&lt;/code&gt; 에 삽입합니다 . 스트림의 채우기 문자 및 서식 플래그는 무시되고 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36a998e3dc0e13d7209092f6c20763322ec5b8e6" translate="yes" xml:space="preserve">
          <source>1) Sets &lt;code&gt;loc&lt;/code&gt; as the associated locale. Calls &lt;code&gt;imbue(loc)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;loc&lt;/code&gt; 을 관련 로케일로 설정 합니다. 가장 파생 된 클래스의 &lt;code&gt;imbue(loc)&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="ed7ef78eb4d8ac7ad642d4f6b0d28e5671d8ee52" translate="yes" xml:space="preserve">
          <source>1) Sets all bits to &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">1) 모든 비트를 &lt;code&gt;false&lt;/code&gt; 설정</target>
        </trans-unit>
        <trans-unit id="748a476f9f45c4cb135ddad1e581399045772b64" translate="yes" xml:space="preserve">
          <source>1) Sets all bits to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1) 모든 비트를 &lt;code&gt;true&lt;/code&gt; 로 설정 합니다 .</target>
        </trans-unit>
        <trans-unit id="2021569fa06d5efa69909df75d00a3f4cd2a9408" translate="yes" xml:space="preserve">
          <source>1) Sets the &lt;code&gt;floatfield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;fixed&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: fixed&lt;/a&gt; , &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: floatfield&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 의 &lt;code&gt;floatfield&lt;/code&gt; 를 &lt;code&gt;fixed&lt;/code&gt; 것으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="50dc184d36fecae99d3273c9a89db78d54bc50c8" translate="yes" xml:space="preserve">
          <source>1) Sets the bits to the result of binary AND on corresponding pairs of bits of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 의 해당 비트 쌍에서 이진 AND의 결과로 비트를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a1cd0d7ac969813ee13818267a9de7c1936f1da7" translate="yes" xml:space="preserve">
          <source>1) Sets the formatting flags identified by &lt;code&gt;flags&lt;/code&gt;. Effectively the following operation is performed &lt;code&gt;fl = fl | flags&lt;/code&gt; where &lt;code&gt;fl&lt;/code&gt; defines the state of internal formatting flags.</source>
          <target state="translated">1)에 의해 확인 된 서식 플래그 설정 &lt;code&gt;flags&lt;/code&gt; . 효과적으로 다음 작업이 수행됩니다. &lt;code&gt;fl = fl | flags&lt;/code&gt; &lt;code&gt;fl&lt;/code&gt; 내부 서식 플래그의 상태를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5a76f71dc224d669d3f23245ebcbc6fe12cf100b" translate="yes" xml:space="preserve">
          <source>1) Shares ownership of the object managed by &lt;code&gt;r&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; manages no object, &lt;code&gt;*this&lt;/code&gt; manages no object too. Equivalent to &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;r&lt;/code&gt; 에 의해 관리되는 객체의 소유권을 공유합니다 . &lt;code&gt;r&lt;/code&gt; &lt;code&gt;*this&lt;/code&gt; 오브젝트를 관리하지 않으면 *이 오브젝트도 관리하지 않습니다. 당량 &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33d51240dc329ad03133b83ed63c310835b93f14" translate="yes" xml:space="preserve">
          <source>1) Shifts the elements towards the beginning of the range. If &lt;code&gt;n &amp;lt;= 0 || n &amp;gt;= last - first&lt;/code&gt;, there are no effects. Otherwise, for every integer &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, last - first - n)&lt;/code&gt;, moves the element originally at position &lt;code&gt;first + n + i&lt;/code&gt; to position &lt;code&gt;first + i&lt;/code&gt;. The moves are performed in increasing order of &lt;code&gt;i&lt;/code&gt; starting from &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1) 요소를 범위의 시작 부분으로 이동합니다. 만약 &lt;code&gt;n &amp;lt;= 0 || n &amp;gt;= last - first&lt;/code&gt; , 효과가 없습니다. 그렇지 않으면, &lt;code&gt;[0, last - first - n)&lt;/code&gt; 모든 정수 &lt;code&gt;i&lt;/code&gt; 에 대해 요소를 원래 위치 &lt;code&gt;first + n + i&lt;/code&gt; 에서 &lt;code&gt;first + i&lt;/code&gt; 위치로 이동합니다 . 움직임이 증가하는 순서로 수행되는 &lt;code&gt;i&lt;/code&gt; 부터 &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3c379223399d99299e4dd0ec4e8ae7d2df828f1" translate="yes" xml:space="preserve">
          <source>1) Specifies that a constructor  or conversion function(since C++11) is explicit, that is, it cannot be used for &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;.</source>
          <target state="translated">1) 생성자 또는 변환 함수 (C ++ 11부터)가 명시적임을 지정합니다. 즉, &lt;a href=&quot;implicit_cast&quot;&gt;암시 적 변환&lt;/a&gt; 및 &lt;a href=&quot;copy_initialization&quot;&gt;복사 초기화에&lt;/a&gt; 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3fc72a8629768287c31cd486267125fa2a02f24d" translate="yes" xml:space="preserve">
          <source>1) Static or thread-local references, if it is bound to static glvalue, to a temporary object (or its subobject), or to a function, and if every expression (including implicit conversions) in &lt;a href=&quot;reference_initialization&quot;&gt;the initializer&lt;/a&gt; of the reference is a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt;.</source>
          <target state="translated">1) 정적 또는 스레드 로컬 참조 (정적 glvalue, 임시 객체 (또는 해당 하위 객체) 또는 함수에 바인딩 된 경우 및 참조 &lt;a href=&quot;reference_initialization&quot;&gt;초기화 프로그램&lt;/a&gt; 의 모든 표현식 (암시 적 변환 포함) 이 &lt;a href=&quot;constant_expression&quot;&gt;상수 인 경우) 표현&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bba5893de10ec808038f251574bf599363a4baa" translate="yes" xml:space="preserve">
          <source>1) Steps through the character sequence &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt;, examining the characters. Every character that is not a part of a format sequence is written to the output iterator &lt;code&gt;out&lt;/code&gt; immediately. To identify format sequences, this function narrows the next character &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char_type&amp;gt;(str.getloc()).narrow(c,0)&lt;/code&gt; and if it equals &lt;code&gt;'%'&lt;/code&gt;, the next one or two characters are compared to the list of format sequences recognized by &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; plus any additional implementation-defined formats supported by this locale. For each valid format sequence, a call to &lt;code&gt;do_put(out, str, fill, t, format, modifier)&lt;/code&gt; is made, where &lt;code&gt;format&lt;/code&gt; is the format sequence character, and &lt;code&gt;modifier&lt;/code&gt; is the optional format sequence modifier (&lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'O'&lt;/code&gt;). A value of &lt;code&gt;'\0'&lt;/code&gt; is used if the modifier is absent.</source>
          <target state="translated">1) 문자를 검사하면서 문자 시퀀스 &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; 합니다. 형식 시퀀스의 일부가 아닌 모든 문자는 출력 반복자에 기록됩니다 &lt;code&gt;out&lt;/code&gt; 즉시. 형식 시퀀스를 식별하기 위해이 함수 는 &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char_type&amp;gt;(str.getloc()).narrow(c,0)&lt;/code&gt; &amp;lt;char_type&amp;gt; (str.getloc ()). narrow (c, 0)에 의한 것처럼 &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; 에서 다음 문자 &lt;code&gt;c&lt;/code&gt; 를 좁히고 &lt;code&gt;'%'&lt;/code&gt; 와 같으면 , 다음 1 개 또는 2 개의 문자는 &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; 의해 인식되는 형식 순서 목록 과이 로케일이 지원하는 추가 구현 정의 형식과 비교됩니다. 유효한 각 형식 순서에 대해 &lt;code&gt;do_put(out, str, fill, t, format, modifier)&lt;/code&gt; 호출하십시오.여기서 &lt;code&gt;format&lt;/code&gt; 은 형식 순서 문자이고 &lt;code&gt;modifier&lt;/code&gt; 는 선택적 형식 순서 수정 자 ( &lt;code&gt;'E'&lt;/code&gt; 또는 &lt;code&gt;'O'&lt;/code&gt; )입니다. 수정자가 없으면 &lt;code&gt;'\0'&lt;/code&gt; 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dbe4d06a8673e9980bbd8a34d0a33460ddce561c" translate="yes" xml:space="preserve">
          <source>1) Swaps the values &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. This overload does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_move_assignable&quot;&gt;std::is_move_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.(since C++17)</source>
          <target state="translated">1) 값 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 바꿉니다 . &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_move_assignable&quot;&gt;std::is_move_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 가 아니면이 과부하는 과부하 해결에 참여하지 않습니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="0e334356b91d7cf3ca8b843c79afa340cb4f3a9d" translate="yes" xml:space="preserve">
          <source>1) Template arguments (if any) are substituted into expression;</source>
          <target state="translated">1) 템플릿 인수 (있는 경우)가 표현식으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ce2782af810444b02f25f93a1dd29f5756552166" translate="yes" xml:space="preserve">
          <source>1) The</source>
          <target state="translated">1)</target>
        </trans-unit>
        <trans-unit id="2bf42c2016441eb61ea13c6e9fa609da95361a52" translate="yes" xml:space="preserve">
          <source>1) The &lt;a href=&quot;../preprocessor&quot;&gt;preprocessor&lt;/a&gt; is executed.</source>
          <target state="translated">1) &lt;a href=&quot;../preprocessor&quot;&gt;전처리 기가&lt;/a&gt; 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="65e8aa1cffd8b645e51e443b4510d72178b7b831" translate="yes" xml:space="preserve">
          <source>1) The &lt;a href=&quot;name&quot;&gt;name&lt;/a&gt; that is declared.</source>
          <target state="translated">1) 선언 된 &lt;a href=&quot;name&quot;&gt;이름&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f433a0c89c7f1e8799b60485288073c016147e00" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt; concept specifies the requirements of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; type that has constant time copy, move, and assignment operations (e.g. a pair of iterators, or a generator Range that creates its elements on-demand. Notably, the standard library containers are Ranges, but not Views)</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt; 개념 은 일정한 시간 복사, 이동 및 할당 작업 (예 : 반복기 쌍 또는 요청시 요소를 생성하는 생성기 범위)이 있는 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 유형 의 요구 사항을 지정합니다 . 특히 표준 라이브러리 컨테이너는 Ranges입니다. , 조회수는 아님)</target>
        </trans-unit>
        <trans-unit id="ec5eeb1c920435edfac9357c193554b45fa0d085" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;Range&lt;/code&gt; concept defines the requirements of a type that allows iteration over its elements by providing an iterator and sentinel that denote the elements of the range.</source>
          <target state="translated">1) &lt;code&gt;Range&lt;/code&gt; 개념은 범위 의 요소를 나타내는 반복자와 센티넬을 제공하여 요소에 대한 반복을 허용하는 유형의 요구 사항을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5664b3fe1fc216eb8579abb8ca6fc0ab64244ff1" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;auto&lt;/code&gt; specifier was only allowed for objects declared at block scope or in function parameter lists. It indicated automatic storage duration, which is the default for these kinds of declarations. The meaning of this keyword was changed in C++11.</source>
          <target state="translated">1) &lt;code&gt;auto&lt;/code&gt; 지정자는 블록 범위 또는 함수 매개 변수 목록에 선언 된 객체에만 허용되었습니다. 이러한 유형의 선언에 대한 기본값 인 자동 저장 기간을 표시했습니다. 이 키워드의 의미는 C ++ 11에서 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="5771f1de4aaeaaa160fa4e631f3e630380eaf437" translate="yes" xml:space="preserve">
          <source>1) The a distribution parameter (location).</source>
          <target state="translated">1) 분포 모수 (위치).</target>
        </trans-unit>
        <trans-unit id="a56f4b7e28c5e16ec27cb41041cbe5d377ab7dae" translate="yes" xml:space="preserve">
          <source>1) The alternative name this &lt;code&gt;link&lt;/code&gt; object represents.</source>
          <target state="translated">1)이 &lt;code&gt;link&lt;/code&gt; 개체가 나타내는 대체 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="13892ed49e94589b6b3b35aa23f26504383e1f3e" translate="yes" xml:space="preserve">
          <source>1) The argument list cannot be identical to the non-specialized argument list (it must specialize something)</source>
          <target state="translated">1) 인수 목록은 특수화되지 않은 인수 목록과 동일 할 수 없습니다 (특별해야합니다).</target>
        </trans-unit>
        <trans-unit id="55233ebd70c2b08df11e491094ea36d0775f225f" translate="yes" xml:space="preserve">
          <source>1) The associated parameter set.</source>
          <target state="translated">1) 관련 파라미터 세트.</target>
        </trans-unit>
        <trans-unit id="8cb340ccead28657a0f96c703f2768d7cbbcc0cb" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments or with &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; as the argument)</source>
          <target state="translated">1) 호출자가 get 영역을 한 문자로 백업하도록 요청합니다 ( &lt;code&gt;pbackfail()&lt;/code&gt; 은 인수없이 또는 인수로 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 로 호출 됨)</target>
        </trans-unit>
        <trans-unit id="3b59d07570db328903bdf39c6ee15b2e5874d234" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments or with &lt;code&gt;Traits::eof()&lt;/code&gt; as the argument)</source>
          <target state="translated">1) 호출자가 get 영역을 하나의 문자로 백업하도록 요청합니다 ( &lt;code&gt;pbackfail()&lt;/code&gt; 은 인수없이 또는 인수로 &lt;code&gt;Traits::eof()&lt;/code&gt; 를 사용하여 호출 됨)</target>
        </trans-unit>
        <trans-unit id="61adb3e6b0b307a7e54bcae25d20d2e0a7936478" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments), in which case, this function re-reads the file starting one byte earlier and decrements &lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;&lt;code&gt;basic_streambuf::gptr()&lt;/code&gt;&lt;/a&gt;, e.g. by calling &lt;code&gt;gbump(-1)&lt;/code&gt;.</source>
          <target state="translated">1) 호출자는 get 영역을 하나의 문자로 백업하도록 요청합니다 ( &lt;code&gt;pbackfail()&lt;/code&gt; 은 인수없이 호출 됨).이 경우이 함수는 1 바이트 더 일찍 시작하는 파일을 다시 읽고 &lt;a href=&quot;../basic_streambuf/gptr&quot;&gt; &lt;code&gt;basic_streambuf::gptr()&lt;/code&gt; &lt;/a&gt; 예를 들어 &lt;code&gt;gbump(-1)&lt;/code&gt; 을 호출 하여 .</target>
        </trans-unit>
        <trans-unit id="e1ae7223669c573a68efa4c16b06f3ce8570f1d7" translate="yes" xml:space="preserve">
          <source>1) The concept &lt;code&gt;StrictTotallyOrdered&amp;lt;T&amp;gt;&lt;/code&gt; specifies that the comparison operators &lt;code&gt;==,!=,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=&lt;/code&gt; on &lt;code&gt;T&lt;/code&gt; yield results consistent with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total order&lt;/a&gt; on &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) 개념 &lt;code&gt;StrictTotallyOrdered&amp;lt;T&amp;gt;&lt;/code&gt; 지정하는 비교 연산자 &lt;code&gt;==,!=,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 의 A의 항복 일관된 결과 &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;엄격한 전체 순서&lt;/a&gt; 에서 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="692cf4b8d8f5f53ecfe4d474f1ec25af3dddecf7" translate="yes" xml:space="preserve">
          <source>1) The constructor initializes the member object (of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt;) from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;. Throws any exception thrown by the constructor selected</source>
          <target state="translated">1) 생성자 는 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; &amp;lt;F&amp;gt; (f) 에서 멤버 객체 ( &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; 유형)를 초기화합니다 . 선택된 생성자가 던진 예외를 던집니다.</target>
        </trans-unit>
        <trans-unit id="2b56e5f14d5ec78f7a1a9e935292dc9c4e9c4bc1" translate="yes" xml:space="preserve">
          <source>1) The copy assignment operator is protected, and is deleted. Input streams are not CopyAssignable.</source>
          <target state="translated">1) 복사 할당 연산자가 보호되고 삭제됩니다. 입력 스트림이 CopyAssignable이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="cb957de92fc95959bfc746d86ce3609a64f1a4fd" translate="yes" xml:space="preserve">
          <source>1) The copy assignment operator is protected, and is deleted. Output streams are not CopyAssignable.</source>
          <target state="translated">1) 복사 할당 연산자가 보호되고 삭제됩니다. 출력 스트림은 CopyAssignable이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e34654c2e919d3a91813ff3288559504fc22e14a" translate="yes" xml:space="preserve">
          <source>1) The copy constructor is deleted: streams are not copyable.</source>
          <target state="translated">1) 복사 생성자가 삭제됩니다. 스트림은 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="10e7c6895d9ef10be5943bb1587dc03b33198d2f" translate="yes" xml:space="preserve">
          <source>1) The current exception mask.</source>
          <target state="translated">1) 현재 예외 마스크.</target>
        </trans-unit>
        <trans-unit id="3abfb5553c81efc2e23dc953228b75d755237163" translate="yes" xml:space="preserve">
          <source>1) The default constructor creates a &lt;code&gt;std::seed_seq&lt;/code&gt; object with an initial seed sequence of length zero.</source>
          <target state="translated">1) 기본 생성자 는 초기 시드 시퀀스 길이가 0 인 &lt;code&gt;std::seed_seq&lt;/code&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="4e2c38841269bc097ae1c47eda71b3fbdeb21c7e" translate="yes" xml:space="preserve">
          <source>1) The default constructor is defaulted.</source>
          <target state="translated">1) 기본 생성자가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="eaa9c330e0c1827f710a288a9214aaa3553943cf" translate="yes" xml:space="preserve">
          <source>1) The default constructor is trivial: no initialization takes place other than &lt;a href=&quot;../../language/zero_initialization&quot;&gt;zero initialization&lt;/a&gt; of static and thread-local objects. &lt;code&gt;&lt;a href=&quot;../atomic_init&quot;&gt;std::atomic_init&lt;/a&gt;&lt;/code&gt; may be used to complete initialization.</source>
          <target state="translated">1) 기본 생성자는 사소합니다. 정적 및 스레드 로컬 객체의 &lt;a href=&quot;../../language/zero_initialization&quot;&gt;0 초기화&lt;/a&gt; 이외의 초기화는 수행되지 않습니다 . &lt;code&gt;&lt;a href=&quot;../atomic_init&quot;&gt;std::atomic_init&lt;/a&gt;&lt;/code&gt; 사용하여 초기화를 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6475c63291c6da877aa299aa6f4d12b026b2cf4" translate="yes" xml:space="preserve">
          <source>1) The default, equivalent to (2) with &lt;code&gt;copy_options::none&lt;/code&gt; used as &lt;code&gt;options&lt;/code&gt;</source>
          <target state="translated">1) 기본값은 &lt;code&gt;copy_options::none&lt;/code&gt; 을 &lt;code&gt;options&lt;/code&gt; 사용 하는 (2)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf4124c6a6217a2beb35fda41d126dc7a4ceaa8e" translate="yes" xml:space="preserve">
          <source>1) The destructors of objects with thread local &lt;a href=&quot;../../language/storage_duration&quot;&gt;storage duration&lt;/a&gt; that are associated with the current thread, the destructors of objects with static storage duration, and the functions registered with &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are executed concurrently, while maintaining the following guarantees: a) The last destructor for thread-local objects is &lt;a href=&quot;../../language/eval_order&quot;&gt;sequenced-before&lt;/a&gt; the first destructor for a static object b) If the completion of the constructor or &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;dynamic initialization&lt;/a&gt; for thread-local or static object A was sequenced-before thread-local or static object B, the completion of the destruction of B is sequenced-before the start of the destruction of A c) If the completion of the initialization of a static object A was sequenced-before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F, the call to F during termination is sequenced-before the start of the destruction of A d) If the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F was sequenced-before the completion of initialization of a static object A, the start of the destruction of A is sequenced-before the call to F during termination. e) If a call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F1 was sequenced-before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F2, then the call to F2 during termination is sequenced-before the call to F1</source>
          <target state="translated">1) 현재 스레드와 연관된 스레드 로컬 &lt;a href=&quot;../../language/storage_duration&quot;&gt;스토리지 기간&lt;/a&gt; 이있는 오브젝트의 소멸자, 정적 스토리지 기간이있는 오브젝트의 소멸자 및 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 등록 된 기능 은 다음 보장을 유지하면서 동시에 실행됩니다. 스레드 로컬 객체의 마지막 소멸자 는 정적 객체의 첫 번째 소멸자 &lt;a href=&quot;../../language/eval_order&quot;&gt;보다&lt;/a&gt; 먼저 시퀀싱됩니다. b) 스레드 로컬 또는 정적 객체 A 의 생성자 또는 &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;동적 초기화&lt;/a&gt; 가 스레드 로컬 또는 정적 객체 B보다 먼저 시퀀싱 된 경우, B의 파괴의 완료는 A의 파괴가 시작되기 전에 순서화된다. c) 정적 객체 A의 초기화 완료의 완료가 다음에 호출하기 전에 순서화 된 경우 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 일부 함수 F에 대한 std :: atexit의 경우 종료 중 F에 대한 호출은 A의 소멸이 시작되기 전에 시퀀싱됩니다. d)일부 함수 F에 대한 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 대한호출이 시퀀싱 완료 전에 완료되었습니다 정적 객체 A에서, A의 파괴 시작은 종료 동안 F에 대한 호출 전에 순서화된다. e)일부 기능 F1에 대한 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 대한 호출이일부 기능 F2에 대한 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 대한 호출 전에 시퀀싱 된 경우 종료 중 F2에 대한 호출은 F1에 대한 호출 전에 순서화됩니다.</target>
        </trans-unit>
        <trans-unit id="984436ed4409399ee56d2edafaa76fa5827ade9b" translate="yes" xml:space="preserve">
          <source>1) The execution policy type used as a unique type to disambiguate parallel algorithm overloading and require that a parallel algorithm's execution may not be parallelized. The invocations of element access functions in parallel algorithms invoked with this policy (usually specified as &lt;code&gt;&lt;a href=&quot;execution_policy_tag&quot;&gt;std::execution::seq&lt;/a&gt;&lt;/code&gt;) are indeterminately sequenced in the calling thread.</source>
          <target state="translated">1) 병렬 알고리즘 과부하를 명확하게하기 위해 고유 한 유형으로 사용되는 실행 정책 유형이며 병렬 알고리즘의 실행이 병렬화되지 않아야합니다. 이 정책으로 호출 된 병렬 알고리즘에서 요소 액세스 함수의 호출 (보통 &lt;code&gt;&lt;a href=&quot;execution_policy_tag&quot;&gt;std::execution::seq&lt;/a&gt;&lt;/code&gt; 로 지정 )은 호출 스레드에서 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e362b206dffda02474ab2c007c80f4e6c881bbd6" translate="yes" xml:space="preserve">
          <source>1) The exponent syntax for a decimal floating-point literal</source>
          <target state="translated">1) 10 진수 부동 소수점 리터럴의 지수 구문</target>
        </trans-unit>
        <trans-unit id="64cdf221b5add07010de335de6d59fa388267951" translate="yes" xml:space="preserve">
          <source>1) The file or empty directory identified by the path &lt;code&gt;p&lt;/code&gt; is deleted as if by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;remove&lt;/a&gt;. Symlinks are not followed (symlink is removed, not its target)</source>
          <target state="translated">1) 경로 &lt;code&gt;p&lt;/code&gt; 로 식별 된 파일 또는 빈 디렉토리 는 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;remove에&lt;/a&gt; 의해 삭제됩니다 . 심볼릭 링크를 따르지 않음 (symlink는 대상이 아닌 제거됨)</target>
        </trans-unit>
        <trans-unit id="9be6415eb11ca6d2a6ae2ef6b1a8ebf53b49733f" translate="yes" xml:space="preserve">
          <source>1) The first operand must be an expression of &lt;a href=&quot;incomplete_type&quot;&gt;complete class type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) 첫 번째 피연산자는 &lt;a href=&quot;incomplete_type&quot;&gt;완전한 클래스 유형 &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 의 표현식이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f5ef6f6f7feb816947d23a3ea4f22b9c37b4705" translate="yes" xml:space="preserve">
          <source>1) The format character sequence is defined by the range &lt;code&gt;[fmt_first, fmt_last)&lt;/code&gt;. The resulting character sequence is copied to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">1) 형식 문자 순서는 &lt;code&gt;[fmt_first, fmt_last)&lt;/code&gt; 범위로 정의됩니다 . 결과 문자 시퀀스가 &lt;code&gt;out&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="95de870e8f49a93ec939ffd632a40a00558bdce7" translate="yes" xml:space="preserve">
          <source>1) The individual bytes of the source code file are mapped (in implementation-defined manner) to the characters of the</source>
          <target state="translated">1) 소스 코드 파일의 개별 바이트는 (구현 정의 방식으로)</target>
        </trans-unit>
        <trans-unit id="f69e48ffceb6307d147e62ebd3e15bb7bcf22d41" translate="yes" xml:space="preserve">
          <source>1) The length &lt;code&gt;rlen&lt;/code&gt; of the sequences to compare is the smaller of &lt;code&gt;size()&lt;/code&gt; and &lt;code&gt;v.size()&lt;/code&gt;. The function compares the two views by calling &lt;code&gt;traits::compare(data(), v.data(), rlen)&lt;/code&gt;, and returns a value according to the following table:</source>
          <target state="translated">1) 비교할 시퀀스 의 길이 &lt;code&gt;rlen&lt;/code&gt; 은 &lt;code&gt;size()&lt;/code&gt; 및 &lt;code&gt;v.size()&lt;/code&gt; 보다 작습니다 . 이 함수는 &lt;code&gt;traits::compare(data(), v.data(), rlen)&lt;/code&gt; 을 호출하여 두보기를 비교 하고 다음 표에 따라 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4037f7821b91877636d406cbce1bcacb0689bf42" translate="yes" xml:space="preserve">
          <source>1) The lifetime of the object allocated by E1 strictly contains the lifetime of the object allocated by E2, 2) E1 and E2 would invoke the same replaceable global allocation function 3) For a throwing allocation function, exceptions in E1 and E2 would be first caught in the same handler.</source>
          <target state="translated">1) E1에 의해 할당 된 객체의 수명은 E2에 의해 할당 된 객체의 수명을 엄격하게 포함합니다. 2) E1과 E2는 동일한 교체 가능한 전역 할당 함수를 호출합니다. 같은 처리기에 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="b5680fbc09a44d73240f35e66072e9eb23f44a63" translate="yes" xml:space="preserve">
          <source>1) The list of boundaries of the intervals.</source>
          <target state="translated">1) 구간의 경계 목록.</target>
        </trans-unit>
        <trans-unit id="b88da70e98e0b2688aca929c023fd479e8e2afd6" translate="yes" xml:space="preserve">
          <source>1) The log-mean m distribution parameter.</source>
          <target state="translated">1) 로그 평균 m 분포 모수.</target>
        </trans-unit>
        <trans-unit id="58a51494ba725af135bdfe4838b9d7d460044580" translate="yes" xml:space="preserve">
          <source>1) The m (the first degree of freedom) distribution parameter.</source>
          <target state="translated">1) m (제 1 자유도) 분포 모수.</target>
        </trans-unit>
        <trans-unit id="253b910778e1d968599094f0f2559f6818ab03e8" translate="yes" xml:space="preserve">
          <source>1) The mean &amp;mu; distribution parameter.</source>
          <target state="translated">1) 평균 &amp;mu; 분포 모수.</target>
        </trans-unit>
        <trans-unit id="419ac7c350c315de0c2fc313d43dafe994bfe4ae" translate="yes" xml:space="preserve">
          <source>1) The members declared after the specifier have public member access</source>
          <target state="translated">1) 지정자 후에 선언 된 멤버는 공개 멤버 액세스 권한을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bd8f7818635373bb03d0e69a14d67db0b342bd5c" translate="yes" xml:space="preserve">
          <source>1) The nested-name-specifier (everything to the left of the scope resolution operator &lt;code&gt;::&lt;/code&gt;) of a type that was specified using a &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified-id&lt;/a&gt;:</source>
          <target state="translated">범위 결정 연산자의 왼쪽에 1) 중첩 된 이름 지정 (모든 &lt;code&gt;::&lt;/code&gt; 사용하여 지정된 유형의) &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;자격-ID를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c5d2d5ea95e95309310a1f70f09cdbb08741b9eb" translate="yes" xml:space="preserve">
          <source>1) The new element is initialized as a copy of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) 새로운 요소는 &lt;code&gt;value&lt;/code&gt; 의 복사본으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="805754d1d5d23696faf5387fb9f75302e9f3de82" translate="yes" xml:space="preserve">
          <source>1) The non-specialized &lt;code&gt;default_delete&lt;/code&gt; uses &lt;code&gt;delete&lt;/code&gt; to deallocate memory for a single object.</source>
          <target state="translated">1) 특수화되지 않은 &lt;code&gt;default_delete&lt;/code&gt; 는 &lt;code&gt;delete&lt;/code&gt; 를 사용 하여 단일 객체에 대한 메모리 할당을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="078ba3fdb2f0208dd9e2307c39e67cfe68c5c1db" translate="yes" xml:space="preserve">
          <source>1) The non-specialized &lt;code&gt;pointer_traits&lt;/code&gt; declares the following types:</source>
          <target state="translated">1) 특수화되지 않은 &lt;code&gt;pointer_traits&lt;/code&gt; 는 다음 유형을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="92f8554972361f85396cc946915b450c4ce836c2" translate="yes" xml:space="preserve">
          <source>1) The normal form of the path</source>
          <target state="translated">1) 경로의 정상적인 형태</target>
        </trans-unit>
        <trans-unit id="7fcadaf3a1d0805d8241d4dcda9467625d082466" translate="yes" xml:space="preserve">
          <source>1) The operators works on valarrays of the same size and returns a valarray with the same size as the parameters with the operation applied to every elements of the two arguments.</source>
          <target state="translated">1) 연산자는 동일한 크기의 valarray에서 작동하며 두 인수의 모든 요소에 적용되는 연산을 사용하여 매개 변수와 동일한 크기의 valarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2682843d9db3de2fe0979f65226c8ec0ffc4a1ff" translate="yes" xml:space="preserve">
          <source>1) The p distribution parameter.</source>
          <target state="translated">1) p 분포 모수.</target>
        </trans-unit>
        <trans-unit id="52a76b9c4dc5d777618976dffcda053ec848076c" translate="yes" xml:space="preserve">
          <source>1) The pointer to the beginning of the get area.</source>
          <target state="translated">1) get 영역의 시작을 가리키는 포인터.</target>
        </trans-unit>
        <trans-unit id="2788ad850b2bbb3bcd1e26f30ae2197560170280" translate="yes" xml:space="preserve">
          <source>1) The pointer to the beginning of the put area.</source>
          <target state="translated">1) 풋 영역의 시작을 가리키는 포인터.</target>
        </trans-unit>
        <trans-unit id="ecd0301c6f2ffe2d0819343a365dcb5dd5fc514c" translate="yes" xml:space="preserve">
          <source>1) The program is ill-formed if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="76d0af0682d39a23e608870d902e924d40731f41" translate="yes" xml:space="preserve">
          <source>1) The random number generator is implementation-defined, but the function &lt;code&gt;&lt;a href=&quot;../numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; is often used.</source>
          <target state="translated">1) 난수 생성기는 구현 정의되어 있지만 &lt;code&gt;&lt;a href=&quot;../numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; 함수 가 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fcb6ec55992b506b45ac666f76eb78e9d99e9237" translate="yes" xml:space="preserve">
          <source>1) The real part.</source>
          <target state="translated">1) 진짜 부분.</target>
        </trans-unit>
        <trans-unit id="04499347610e4d853510728a08aea977c3eea26d" translate="yes" xml:space="preserve">
          <source>1) The result of &lt;code&gt;lhs.equal(rhs)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;lhs.equal(rhs)&lt;/code&gt; )의 결과 .</target>
        </trans-unit>
        <trans-unit id="acdfeea6d1916156d222310691b55c364fcf71aa" translate="yes" xml:space="preserve">
          <source>1) The result of dereferencing the stored pointer, i.e., &lt;code&gt;*get()&lt;/code&gt;</source>
          <target state="translated">1) 저장된 포인터를 역 참조한 결과, 즉 &lt;code&gt;*get()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85369193a6efe2baa8eac212d4d41eca7c7a29a4" translate="yes" xml:space="preserve">
          <source>1) The return type is deduced from the returned expression as if by &lt;code&gt;decltype&lt;/code&gt;. The call is ill-formed if the invocation above is not a valid expression of the same type and value category, for all combinations of alternative types of all variants.</source>
          <target state="translated">1) 반환 유형은 &lt;code&gt;decltype&lt;/code&gt; 에 의한 것처럼 반환 된 표현식에서 추론됩니다 . 위의 호출이 모든 유형의 대체 유형의 모든 조합에 대해 동일한 유형 및 값 범주의 유효한 표현식이 아닌 경우 호출이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7a36ba71f6e55e9d3da53e756c59b3b06287b854" translate="yes" xml:space="preserve">
          <source>1) The return type meets the requirements of mutable &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">1) 반환 유형은 변경 가능한 &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 의 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="6d3e7aa24867d0d8995a957c6318cd61a05292ec" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; )의 반환 값입니다 .</target>
        </trans-unit>
        <trans-unit id="dae9b5cd9ae861b669c70c471b4d08d50f4c940b" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;seekpos(pos, which)&lt;/code&gt;.</source>
          <target state="translated">1)의 반환 값 &lt;code&gt;seekpos(pos, which)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="898a982d82a90b60748ffe31055974436184caf1" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;setbuf(s, n)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;setbuf(s, n)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="1e96b281892b82cedb8d59abb7f447580daa3b5f" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;sync()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;sync()&lt;/code&gt; )의 반환 값 .</target>
        </trans-unit>
        <trans-unit id="7ca5f89c229d3f7753b51b3a66ee13e45d0b0f54" translate="yes" xml:space="preserve">
          <source>1) The source file is decomposed into &lt;a href=&quot;../comments&quot;&gt;comments&lt;/a&gt;, sequences of whitespace characters (space, horizontal tab, new-line, vertical tab, and form-feed), and</source>
          <target state="translated">1) 소스 파일은 &lt;a href=&quot;../comments&quot;&gt;주석&lt;/a&gt; , 일련의 공백 문자 (공백, 가로 탭, 줄 바꿈, 세로 탭 및 용지 공급) 로 분해 되고</target>
        </trans-unit>
        <trans-unit id="36843ad5bce393e021d99643d395dab108c20cf9" translate="yes" xml:space="preserve">
          <source>1) The sum of the given value and elements in the given range.</source>
          <target state="translated">1) 주어진 범위에서 주어진 값과 요소의 합.</target>
        </trans-unit>
        <trans-unit id="3b61bf4f0d9f6b04457c1b40ba6668a669b49d56" translate="yes" xml:space="preserve">
          <source>1) The time of the last modification of &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;p&lt;/code&gt; 의 마지막 수정 시간</target>
        </trans-unit>
        <trans-unit id="79302ea48e89e5dd8b66c9d489a0b5d0f35c2a34" translate="yes" xml:space="preserve">
          <source>1) The unary operation &lt;code&gt;unary_op&lt;/code&gt; is applied to the range defined by &lt;code&gt;[first1, last1)&lt;/code&gt;.</source>
          <target state="translated">1) 단항 연산 &lt;code&gt;unary_op&lt;/code&gt; 는 &lt;code&gt;[first1, last1)&lt;/code&gt; 의해 정의 된 범위에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="367330e87475392565d07397877349fb08e6bda2" translate="yes" xml:space="preserve">
          <source>1) The value &lt;code&gt;v&lt;/code&gt; stored in the shared state, as &lt;code&gt;std::move(v)&lt;/code&gt;.</source>
          <target state="translated">1) 값 &lt;code&gt;v&lt;/code&gt; 는 &lt;code&gt;std::move(v)&lt;/code&gt; 로 공유 상태에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="86eb511f8878afb18a55683fb47df9cdcc07ce8f" translate="yes" xml:space="preserve">
          <source>1) The value of A is used as an operand of B, &lt;b&gt;except&lt;/b&gt;</source>
          <target state="translated">1)의 값이 B의 피연산자로 사용된다 &lt;b&gt;제외시켰다&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7811702fe1807599a0bc78db6abc9c5bbdecab5f" translate="yes" xml:space="preserve">
          <source>1) The value of the</source>
          <target state="translated">1) 가치</target>
        </trans-unit>
        <trans-unit id="411cbaa6e8bdadb2ed80c96fcee27228278863bb" translate="yes" xml:space="preserve">
          <source>1) The value of the a parameter.</source>
          <target state="translated">1) 매개 변수의 값.</target>
        </trans-unit>
        <trans-unit id="ba3ffa0db89ccb1cd6d655154c05da75ee6c8142" translate="yes" xml:space="preserve">
          <source>1) The value of the obtained character.</source>
          <target state="translated">1) 획득 한 캐릭터의 가치.</target>
        </trans-unit>
        <trans-unit id="d34b7e1f53cc8550900ee8f2d0ed3e332b4489a8" translate="yes" xml:space="preserve">
          <source>1) The value returned by the selected invocation of the visitor.</source>
          <target state="translated">1) 선택된 방문자 호출에 의해 리턴 된 값.</target>
        </trans-unit>
        <trans-unit id="12cff07a54521cd958ba1ef6524cdcabff900eb6" translate="yes" xml:space="preserve">
          <source>1) The version of this function in the non-specialized &lt;code&gt;&lt;a href=&quot;../pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; template simply calls &lt;code&gt;Ptr::pointer_to(r)&lt;/code&gt;, and if Ptr does not provide a static member function &lt;code&gt;pointer_to&lt;/code&gt;, instantiation of this function is a compile-time error.</source>
          <target state="translated">1) 특수화되지 않은 &lt;code&gt;&lt;a href=&quot;../pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; 템플릿 에서이 함수의 버전은 단순히 &lt;code&gt;Ptr::pointer_to(r)&lt;/code&gt; 호출 하며 Ptr이 정적 멤버 함수 &lt;code&gt;pointer_to&lt;/code&gt; 를 제공하지 않으면 이 함수의 인스턴스화는 컴파일 타임 오류입니다.</target>
        </trans-unit>
        <trans-unit id="77538230530c6dca9afa92eaff1c01d3485f9dd2" translate="yes" xml:space="preserve">
          <source>1) There is no putback position in the get area (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments). In this situation, the purpose of &lt;code&gt;pbackfail()&lt;/code&gt; is to back up the get area by one character, if the associated character sequence allows this (e.g. a file-backed streambuf may reload the buffer from a file, starting one character earlier).</source>
          <target state="translated">1) get 영역에 putback 위치가 없습니다 ( &lt;code&gt;pbackfail()&lt;/code&gt; 은 인수없이 호출됩니다). 이 상황에서 &lt;code&gt;pbackfail()&lt;/code&gt; 의 목적은 연관된 문자 순서가이를 허용하는 경우 (예 : 파일 지원 streambuf가 파일에서 버퍼를 다시로드하여 한 문자 이전에 시작), get 영역을 한 문자 씩 백업하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="082233e2ccf1fae9f66efcf578a3583588a32ecb" translate="yes" xml:space="preserve">
          <source>1) There may be &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;more than one definition&lt;/a&gt; of an inline function or variable(since C++17) in the program as long as each definition appears in a different translation unit and (for non-static inline functions and variables(since C++17)) all definitions are identical. For example, an inline function or an inline variable(since C++17) may be defined in a header file that is #include'd in multiple source files.</source>
          <target state="translated">1) 각 정의가 다른 변환 단위 및 (비 정적 인라인 함수 및 변수 (C + 이후)에 표시되는 한 프로그램에 인라인 함수 또는 변수 (C ++ 17 이후)에 대한 &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;정의&lt;/a&gt; 가 둘 이상 있을 수 있습니다 +17)) 모든 정의가 동일합니다. 예를 들어, 인라인 함수 또는 인라인 변수 (C ++ 17부터)는 여러 소스 파일에 #include되는 헤더 파일에 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d6e10081835eca22b9e463651b1d3a90697a7c7" translate="yes" xml:space="preserve">
          <source>1) This &lt;a href=&quot;../../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; to allow deduction from functions.</source>
          <target state="translated">1)이 &lt;a href=&quot;../../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 에서 추론 할 수 있도록 std :: function 에 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="e77ab4d038ceec4a1c67d2938de66955af3e7eb7" translate="yes" xml:space="preserve">
          <source>1) This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">1)이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 에 제공되어 반복자 범위에서 추론 할 수 있습니다. 오버로드 확인하는 경우에이 과부하에만 참여하는 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; 및 &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e69d6a2bc178876f9e3235945528240ffcb9250" translate="yes" xml:space="preserve">
          <source>1) This overload only participates in overload resolution if T is not a specialization of std::pair. Returns &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; determined as follows:</source>
          <target state="translated">1)이 과부하는 T가 std :: pair의 전문화가 아닌 경우에만 과부하 해결에 참여합니다. 다음과 같이 결정된 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="5fbbf8a15549659900cafa2f8939bbc4169ae318" translate="yes" xml:space="preserve">
          <source>1) Throws a &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; if the conversion is ambiguous. Throws a &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; if &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time.</source>
          <target state="translated">1) 변환이 모호한 경우 &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; 던집니다 . 던져 &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; 경우 &lt;code&gt;tp&lt;/code&gt; 존재하지 않는 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2906ceaa024eb508139cc21c6337dbb9e099baa0" translate="yes" xml:space="preserve">
          <source>1) Throws an exception if the conversion is ambiguous or if &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time.</source>
          <target state="translated">1) 변환이 모호하거나 &lt;code&gt;tp&lt;/code&gt; 가 존재하지 않는 시간을 나타내는 경우 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="c11d4dcc55409becc8aa818ff21922ca67ab791c" translate="yes" xml:space="preserve">
          <source>1) Throws any exceptions thrown by &lt;code&gt;m.lock()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;m.lock()&lt;/code&gt; 던진 예외를 던진다</target>
        </trans-unit>
        <trans-unit id="843bb0e7d49c747ed1e190035bed5b051758038e" translate="yes" xml:space="preserve">
          <source>1) Throws any exceptions thrown by &lt;code&gt;m.lock()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;m.lock()&lt;/code&gt; 의해 발생 된 예외를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="50ee3b5d9f3ed3870841a5598217596f3a883f2a" translate="yes" xml:space="preserve">
          <source>1) Transfers all elements from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The elements are inserted before the element pointed to by &lt;code&gt;pos&lt;/code&gt;. The container &lt;code&gt;other&lt;/code&gt; becomes empty after the operation. The behavior is undefined if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;other&lt;/code&gt; 의 모든 요소 를 &lt;code&gt;*this&lt;/code&gt; 로 전송합니다 . 요소는 &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 앞에 삽입됩니다 . 컨테이너 &lt;code&gt;other&lt;/code&gt; 수술 후 빈됩니다. &lt;code&gt;other&lt;/code&gt; 가 &lt;code&gt;*this&lt;/code&gt; 와 동일한 객체를 참조 하면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6fff766c5a8c7a2f8e138a2e07caea5eb67929f1" translate="yes" xml:space="preserve">
          <source>1) Transfers ownership from &lt;code&gt;r&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; as if by calling &lt;code&gt;reset(r.release())&lt;/code&gt; followed by an assignment of &lt;code&gt;&lt;a href=&quot;get_deleter&quot;&gt;get_deleter()&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;E&amp;gt;(r.get_deleter())&lt;/code&gt;.</source>
          <target state="translated">1) 마치 &lt;code&gt;reset(r.release())&lt;/code&gt; 를 호출 하고 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;E&amp;gt;(r.get_deleter())&lt;/code&gt; &amp;lt;E&amp;gt; (r.get_deleter ()) 에서 &lt;code&gt;&lt;a href=&quot;get_deleter&quot;&gt;get_deleter()&lt;/a&gt;&lt;/code&gt; 를 할당하는 것처럼 &lt;code&gt;r&lt;/code&gt; 에서 &lt;code&gt;*this&lt;/code&gt; 로 소유권을 전송 합니다.</target>
        </trans-unit>
        <trans-unit id="f0d222c1ebe564b2e355ea589fe01bb4acb55570" translate="yes" xml:space="preserve">
          <source>1) Trivial default constructor, initializes &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to unspecified state.</source>
          <target state="translated">1) 간단한 기본 생성자, &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 를 지정되지 않은 상태로 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="fae808fef90ab07a5794289ac4c023c5fa8d10a8" translate="yes" xml:space="preserve">
          <source>1) Turns off the &lt;code&gt;skipws&lt;/code&gt; flag on the input stream</source>
          <target state="translated">1) 입력 스트림 에서 &lt;code&gt;skipws&lt;/code&gt; 플래그를 끕니다.</target>
        </trans-unit>
        <trans-unit id="4dfdb643b8926ec8e33691a11829911540004f8c" translate="yes" xml:space="preserve">
          <source>1) Two possibly multilevel pointers to the same type may be converted between each other, regardless of cv-qualifiers at each level.</source>
          <target state="translated">1) 각 레벨의 cv 한정자에 관계없이 동일한 유형에 대한 두 개의 가능한 다중 레벨 포인터가 서로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b27ef1c6720ded3dab7eb347fb4e754d45f36dfc" translate="yes" xml:space="preserve">
          <source>1) Typical declaration of a destructor</source>
          <target state="translated">1) 소멸자의 전형적인 선언</target>
        </trans-unit>
        <trans-unit id="c4708cafcd797737afa27ba9753427840fb5b5fb" translate="yes" xml:space="preserve">
          <source>1) Unary right fold (E op ...) becomes (E</source>
          <target state="translated">1) 단항 오른쪽 접기 (E op ...)는 (E</target>
        </trans-unit>
        <trans-unit id="257eeefa2a69c169c4e78577629e312d119acf41" translate="yes" xml:space="preserve">
          <source>1) Underflow occurs (and &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; may be raised) if a computation produces a result whose absolute value, computed as though both the exponent range and the precision were unbounded, is smaller than &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt;. Such implementation detects tinyness before rounding (e.g. UltraSparc, POWER).</source>
          <target state="translated">1) 지수 범위와 정밀도가 모두 제한이없는 것으로 계산 된 절대 값이 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; &amp;lt;T&amp;gt; :: min () 보다 작은 결과가 계산에서 생성되면 언더 플로가 발생하고 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; 가 발생할 수 있습니다 . 이러한 구현은 반올림 전에 작은 정도를 감지합니다 (예 : UltraSparc, POWER).</target>
        </trans-unit>
        <trans-unit id="5cd6d3f996be4c51f3f6895463d6cd072a7b915f" translate="yes" xml:space="preserve">
          <source>1) Unlinks the node that contains the element pointed to by &lt;code&gt;position&lt;/code&gt; and returns a &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt; that owns it</source>
          <target state="translated">1) &lt;code&gt;position&lt;/code&gt; 가리키는 요소를 포함하는 노드를 연결 해제 하고 소유하고 있는 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="6f8ce56ad604ec015f939e3d33efff5a54fb49aa" translate="yes" xml:space="preserve">
          <source>1) Unspecified (typically same as &lt;code&gt;Ptr::pointer_to&lt;/code&gt;)</source>
          <target state="translated">1) 지정되지 않음 (일반적으로 &lt;code&gt;Ptr::pointer_to&lt;/code&gt; 와 동일 )</target>
        </trans-unit>
        <trans-unit id="2316f7e9cdbdf01d620f24a734118320daa43c7c" translate="yes" xml:space="preserve">
          <source>1) Used to obtain the iterator type of the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) 유형 &lt;code&gt;T&lt;/code&gt; 의 반복자 유형을 얻는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4cb8f5cd2ca3417e49783847dbe0430c7912497b" translate="yes" xml:space="preserve">
          <source>1) Value of the &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; referred to by this iterator</source>
          <target state="translated">1) 이 반복자가 참조 하는 &lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; 의&lt;/a&gt; 값</target>
        </trans-unit>
        <trans-unit id="aba73510e6e868d87c0be08e6f8342096504cd67" translate="yes" xml:space="preserve">
          <source>1) When a named &lt;a href=&quot;reference#Lvalue_references&quot;&gt;lvalue reference&lt;/a&gt; variable is declared with an initializer</source>
          <target state="translated">1) 명명 된 &lt;a href=&quot;reference#Lvalue_references&quot;&gt;lvalue 참조&lt;/a&gt; 변수가 이니셜 라이저로 선언 된 경우</target>
        </trans-unit>
        <trans-unit id="d0bcc30ae3863a5e08bd6f03dc42a4e874ce1e74" translate="yes" xml:space="preserve">
          <source>1) When class member declarations and member function type declarations appear in a &lt;code&gt;&quot;C&quot;&lt;/code&gt; language block, their linkage remains &lt;code&gt;&quot;C++&quot;&lt;/code&gt;.</source>
          <target state="translated">1) 클래스 멤버 선언과 멤버 함수 타입 선언이 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 언어 블록에 나타날 때 , 그 연결은 &lt;code&gt;&quot;C++&quot;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b3820fb6503add189fb9d0185eccf94528cea1c0" translate="yes" xml:space="preserve">
          <source>1) When the</source>
          <target state="translated">1) 언제</target>
        </trans-unit>
        <trans-unit id="7b36527e4c99ad21a3b5acc56406892e9699bef5" translate="yes" xml:space="preserve">
          <source>1) Whenever backslash appears at the end of a line (immediately followed by the newline character), both backslash and newline are deleted, combining two physical source lines into one logical source line. This is a single-pass operation; a line ending in two backslashes followed by an empty line does not combine three lines into one. If a universal character name (&lt;code&gt;\uXXXX&lt;/code&gt;) is formed in this phase, the behavior is undefined.</source>
          <target state="translated">1) 줄 끝에 백 슬래시가 나타날 때마다 (즉시 줄 바꿈 문자 바로 뒤에) 백 슬래시와 줄 바꿈이 모두 삭제되어 두 개의 실제 소스 행이 하나의 논리 소스 행으로 결합됩니다. 이것은 단일 패스 작업입니다. 두 개의 백 슬래시로 끝나고 빈 줄이 오는 줄은 세 줄을 하나로 결합하지 않습니다. 이 단계에서 범용 문자 이름 ( &lt;code&gt;\uXXXX&lt;/code&gt; )이 형성되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84212c704512f8a7c5c7f860970eb1e0b2a423f0" translate="yes" xml:space="preserve">
          <source>1) Within the body of any non-static &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt;, including &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt;</source>
          <target state="translated">1) &lt;a href=&quot;constructor&quot;&gt;멤버 이니셜 라이저 목록을&lt;/a&gt; 포함하여 비 정적 &lt;a href=&quot;member_functions&quot;&gt;멤버 함수&lt;/a&gt; 본문 내</target>
        </trans-unit>
        <trans-unit id="575e5597bcb538c0ad9a57aef9059faafb04f903" translate="yes" xml:space="preserve">
          <source>1) Wraps a non-const member function with no parameters.</source>
          <target state="translated">1) 비 const 멤버 함수를 매개 변수없이 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="7d767b3af0e8610ce09659c8206561af10fa3322" translate="yes" xml:space="preserve">
          <source>1) Writes a textual representation of the distribution parameters and internal state to &lt;code&gt;ost&lt;/code&gt; as textual representation. The formatting flags and fill character of &lt;code&gt;ost&lt;/code&gt; are unchanged.</source>
          <target state="translated">1)에 분포 파라미터의 텍스트 표현과 내부 상태 기입 &lt;code&gt;ost&lt;/code&gt; 텍스트 표현으로한다. &lt;code&gt;ost&lt;/code&gt; 의 서식 플래그 및 채우기 문자 는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9c461a040145efb71a7d3ac968e14b99a1e726a" translate="yes" xml:space="preserve">
          <source>1) Writes performed by the same thread that performed A</source>
          <target state="translated">1) A와 동일한 스레드에서 수행 한 쓰기</target>
        </trans-unit>
        <trans-unit id="0a2b6a35046c21b8b1cdded7e012e4e02b54a352" translate="yes" xml:space="preserve">
          <source>1) Writes the bitset &lt;code&gt;x&lt;/code&gt; to the character stream &lt;code&gt;os&lt;/code&gt; as if by first converting it to a &lt;code&gt;basic_string&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;to_string&quot;&gt;to_string()&lt;/a&gt;&lt;/code&gt;, and then writing it into &lt;code&gt;os&lt;/code&gt; using the &lt;a href=&quot;../../string/basic_string/operator_ltltgtgt&quot;&gt;&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; (which is a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; for strings). The characters to use for ones and zeroes are obtained from the currently-imbued locale by calling &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;(os.getloc()).widen()&lt;/code&gt; with &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'0'&lt;/code&gt; as arguments.</source>
          <target state="translated">1) 비트 세트를 기입 &lt;code&gt;x&lt;/code&gt; 문자 스트림에 &lt;code&gt;os&lt;/code&gt; 제는로 변환하여 마치 &lt;code&gt;basic_string&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; 사용 &lt;code&gt;&lt;a href=&quot;to_string&quot;&gt;to_string()&lt;/a&gt;&lt;/code&gt; 로을 작성 후, 및 &lt;code&gt;os&lt;/code&gt; 은 USING &lt;a href=&quot;../../string/basic_string/operator_ltltgtgt&quot;&gt; &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; A는 ( &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; 문자열을). 1과 0에 사용할 문자는 &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;(os.getloc()).widen()&lt;/code&gt; 을 &lt;code&gt;'1'&lt;/code&gt; 과 &lt;code&gt;'0'&lt;/code&gt; 으로 호출하여 현재 임베드 된 로케일에서 가져옵니다 . 인수.</target>
        </trans-unit>
        <trans-unit id="db026f9be530b92309db59bd7e0e007f78c55584" translate="yes" xml:space="preserve">
          <source>1) Writes the results to &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) 결과를 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="9ca66f352a8a2c3fbfbb18ec52c430b1d4c5c3b4" translate="yes" xml:space="preserve">
          <source>1) Writes to &lt;code&gt;os&lt;/code&gt; the complex number in the form &lt;code&gt;(real,imaginary)&lt;/code&gt;.</source>
          <target state="translated">1)에 기록 &lt;code&gt;os&lt;/code&gt; 형태의 복소수 &lt;code&gt;(real,imaginary)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccfe5f32416ac78a6db71cb95900b356b4fac608" translate="yes" xml:space="preserve">
          <source>1) Yields the size in bytes of the &lt;a href=&quot;objects&quot;&gt;object representation&lt;/a&gt; of type.</source>
          <target state="translated">1) 유형 의 &lt;a href=&quot;objects&quot;&gt;객체 표현&lt;/a&gt; 의 크기를 바이트 단위로 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="bf3ab90f79f6983b5959522a0d973a0239a4ed67" translate="yes" xml:space="preserve">
          <source>1) a copy of the &lt;code&gt;std::chrono::month&lt;/code&gt; object stored in &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 에 저장된 &lt;code&gt;std::chrono::month&lt;/code&gt; 객체 의 사본</target>
        </trans-unit>
        <trans-unit id="f9872d13b34d100347a4789dbcf716915a245364" translate="yes" xml:space="preserve">
          <source>1) a copy of the argument, &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(val)&lt;/code&gt;</source>
          <target state="translated">1) 인수의 사본, &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(val)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5641277263a9a2b3de3620beebf734b8386a9a9d" translate="yes" xml:space="preserve">
          <source>1) a copy of the underlying string object.</source>
          <target state="translated">1) 기본 문자열 객체의 사본</target>
        </trans-unit>
        <trans-unit id="5c3bdc31cd27db3964c2112a2726a87812d74790" translate="yes" xml:space="preserve">
          <source>1) a copy of this duration object</source>
          <target state="translated">1)이 기간 객체의 사본</target>
        </trans-unit>
        <trans-unit id="038d7ce390c65cda2b59d3877a61b171fd122d75" translate="yes" xml:space="preserve">
          <source>1) a declaration of a class member</source>
          <target state="translated">1) 반원 선언</target>
        </trans-unit>
        <trans-unit id="d9e22ca8e57fb001efaf8220898429709ee9f67f" translate="yes" xml:space="preserve">
          <source>1) a variable &lt;code&gt;x&lt;/code&gt; in a</source>
          <target state="translated">1) 변수 &lt;code&gt;x&lt;/code&gt; A의</target>
        </trans-unit>
        <trans-unit id="2b6abfcba2f16f34c4b766c8332a1b0e568f8205" translate="yes" xml:space="preserve">
          <source>1) addition</source>
          <target state="translated">1) 추가</target>
        </trans-unit>
        <trans-unit id="a2d89e8d3bf7717ac619bee8df3e581c758d7c08" translate="yes" xml:space="preserve">
          <source>1) additional &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;default-inserted&lt;/a&gt; elements are appended</source>
          <target state="translated">1) 추가 &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;기본 삽입&lt;/a&gt; 요소가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ac7f27c304fab3327d4825700e7346a78e13d81e" translate="yes" xml:space="preserve">
          <source>1) additional &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;default-inserted&lt;/a&gt; elements are appended 2) additional copies of &lt;code&gt;value&lt;/code&gt; are appended</source>
          <target state="translated">1) 부가 &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;기본 삽입&lt;/a&gt; 요소의 추가 사본) 2 첨부되는 &lt;code&gt;value&lt;/code&gt; 추가된다</target>
        </trans-unit>
        <trans-unit id="6430a3b1d8a483dd3a81fb0ac4d2a6320ef9e24a" translate="yes" xml:space="preserve">
          <source>1) adds both &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;const&lt;/code&gt; 와 &lt;code&gt;volatile&lt;/code&gt; 을 모두 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="d59d7e196d66c2c5698b37c5fed11d45adb3fba0" translate="yes" xml:space="preserve">
          <source>1) amortized constant</source>
          <target state="translated">1) 상각 상수</target>
        </trans-unit>
        <trans-unit id="fec155bd296ef9eab4b5d4cff65799934437e2a4" translate="yes" xml:space="preserve">
          <source>1) an &lt;a href=&quot;../language/throw&quot;&gt;exception is thrown&lt;/a&gt; and not caught (it is implementation-defined whether any stack unwinding is done in this case)</source>
          <target state="translated">1) &lt;a href=&quot;../language/throw&quot;&gt;예외가 발생&lt;/a&gt; 하고 잡히지 않습니다 (이 경우 스택 해제가 수행되는지 여부는 구현 정의입니다)</target>
        </trans-unit>
        <trans-unit id="0795e639e2d423d045556b10922218964d38d551" translate="yes" xml:space="preserve">
          <source>1) array length is negative.</source>
          <target state="translated">1) 배열 길이가 음수입니다.</target>
        </trans-unit>
        <trans-unit id="b0fb04259e9dabc8e1469a331eb44c9e0e5ae305" translate="yes" xml:space="preserve">
          <source>1) as soon as atomic operations that are not tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; enter the picture, the sequential consistency guarantee for the program is lost 2) in many cases, &lt;code&gt;memory_order_seq_cst&lt;/code&gt; atomic operations are reorderable with respect to other atomic operations performed by the same thread</source>
          <target state="translated">1) 태그되지 않은 원자 작업을 가능한 한 빨리 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 이 사진을 입력, 프로그램의 순차적 일관성이 보장이 많은 경우) 2 손실, &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 원자 작업이 다른 원자 작업에 대한 재정렬되어 같은 스레드에 의해 수행</target>
        </trans-unit>
        <trans-unit id="2e8ab0d12b743aef878ea9e6130cac353570c696" translate="yes" xml:space="preserve">
          <source>1) as soon as atomic operations that are not tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; enter the picture, the sequential consistency is lost 2) the sequentially-consistent fences are only establishing total ordering for the fences themselves, not for the atomic operations in the general case (</source>
          <target state="translated">1) &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 태그가 지정되지 않은 원자 연산이 그림에 들어가 자마자 순차 일관성이 손실됩니다. 2) 순차 일관성이있는 펜스는 일반적인 경우의 원자 연산이 아닌 펜스 자체에 대한 전체 순서 만 설정합니다 (</target>
        </trans-unit>
        <trans-unit id="27196f9d734245d194416b40b601d5214e843c87" translate="yes" xml:space="preserve">
          <source>1) base template</source>
          <target state="translated">1) 기본 템플릿</target>
        </trans-unit>
        <trans-unit id="cb41c99c432b78323d4f377b74a0c397256353fa" translate="yes" xml:space="preserve">
          <source>1) bitwise NOT</source>
          <target state="translated">1) 비트 NOT</target>
        </trans-unit>
        <trans-unit id="f724933955aea428b179d4bd6c5ef4df12c510d5" translate="yes" xml:space="preserve">
          <source>1) buffer state, a bitmask type which can represent any combination of the four values &quot;allocated&quot; (destructor will deallocate), &quot;constant&quot; (output not allowed), &quot;dynamic&quot; (output may reallocate), or &quot;frozen&quot; (deallocation and reallocation are not allowed)</source>
          <target state="translated">1) 버퍼 상태, &quot;할당 됨&quot;(소멸자가 할당 해제), &quot;일정한&quot;(출력 허용되지 않음), &quot;동적&quot;(출력이 재 할당 될 수 있음) 또는 &quot;동결&quot;(할당 해제)의 4 가지 값의 조합을 나타낼 수있는 비트 마스크 유형 재 할당은 허용되지 않습니다)</target>
        </trans-unit>
        <trans-unit id="9bd596e30c7448227178639da643b5d2845998b0" translate="yes" xml:space="preserve">
          <source>1) by the members and friends of &lt;code&gt;Base&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;Base&lt;/code&gt; 멤버와 친구들</target>
        </trans-unit>
        <trans-unit id="de134b2dabb1a0cc9228c6962d95367bc50eab97" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c34ba446a37c84b0cf54a590242f4ba5233f98dd" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77e091034262c03ebbe67a594c859ba4cd168524" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26e3683b3a1f07d2796ab25306d2631c55c16c20" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtoul&quot;&gt;std::strtoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstoul&quot;&gt;std::wcstoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../byte/strtoul&quot;&gt;std::strtoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../wide/wcstoul&quot;&gt;std::wcstoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aaa2f9b040d07d7262ac1b6d9ffdb1abe31c9d94" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;buf.set_emit_on_sync(true)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;buf.set_emit_on_sync(true)&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="c82f9dfecce0de1545c8b1bc95f3a2951730d87a" translate="yes" xml:space="preserve">
          <source>1) comma-separated list of arbitrary expressions and braced-init-lists in parentheses</source>
          <target state="translated">1) 쉼표로 구분 된 임의의 표현식 및 괄호로 묶인 초기 목록</target>
        </trans-unit>
        <trans-unit id="292744bfc0b144652fe365e89093b1f3f3546203" translate="yes" xml:space="preserve">
          <source>1) conjunctions</source>
          <target state="translated">1) 연결</target>
        </trans-unit>
        <trans-unit id="a27605e813fa2e284a617a94d0b1c02a41db1130" translate="yes" xml:space="preserve">
          <source>1) constant</source>
          <target state="translated">1) 상수</target>
        </trans-unit>
        <trans-unit id="04557674944b51204be3247544693f0e0724501f" translate="yes" xml:space="preserve">
          <source>1) constructs an object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt;, &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-non-list-initialized&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;, as the contained object. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, Args...&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1) 유형의 객체를 생성 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; , &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 비리스트 초기화&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; , 포함 된 객체있다. 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, Args...&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; 이 모두 &lt;code&gt;true&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="ecf7299f36a57142311fe5ff018991aec05d1d9b" translate="yes" xml:space="preserve">
          <source>1) counts the elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;value&lt;/code&gt; 와 같은 요소를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="78923f4701cc466ff69a7e4c618b38c216680976" translate="yes" xml:space="preserve">
          <source>1) creates a facet with starting reference count &lt;code&gt;refs&lt;/code&gt;. If &lt;code&gt;refs&lt;/code&gt; is non-zero, the facet will not be deleted when the last locale referencing it goes out of scope. A facet with static or dynamic storage duration should always be constructed with a non-zero &lt;code&gt;refs&lt;/code&gt;.</source>
          <target state="translated">1) 참조 카운트를 시작하는 패싯 생성 &lt;code&gt;refs&lt;/code&gt; . 경우 &lt;code&gt;refs&lt;/code&gt; 제로가 아닌 그것을 참조하는 마지막 로케일이 범위를 벗어나면, 패싯은 삭제되지 않습니다. 정적 또는 동적 저장 기간이있는면은 항상 비제로 구성되어야 &lt;code&gt;refs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16f7bc88ebe12e9f46129bbcbe37a17442c63648" translate="yes" xml:space="preserve">
          <source>1) current maximum load factor.</source>
          <target state="translated">1) 현재 최대 부하 계수.</target>
        </trans-unit>
        <trans-unit id="020d736193c4f224afbc308288813ddd03120330" translate="yes" xml:space="preserve">
          <source>1) declares a scoped enumeration type whose underlying type is &lt;code&gt;int&lt;/code&gt; (the keywords &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt; are exactly equivalent) 2) declares a scoped enumeration type whose underlying type is type3) opaque enum declaration for a scoped enumeration whose underlying type is &lt;code&gt;int&lt;/code&gt;4) opaque enum declaration for a scoped enumeration whose underlying type is type</source>
          <target state="translated">1) 기본 유형이 &lt;code&gt;int&lt;/code&gt; 인 범위 열거 유형을 선언합니다 (키워드 &lt;code&gt;class&lt;/code&gt; 와 &lt;code&gt;struct&lt;/code&gt; 는 정확히 동일 함) 2) 기본 유형이 유형 인 범위 열거 유형을 선언합니다 3) 기본 유형이 &lt;code&gt;int&lt;/code&gt; 인 범위 열거에 대한 불투명 열거 선언 4) 불투명 기본 유형이 유형 인 범위가 지정된 열거에 대한 열거 선언</target>
        </trans-unit>
        <trans-unit id="9a00831c1516deb4278ae9da70bb95962035c0b1" translate="yes" xml:space="preserve">
          <source>1) default constructor: creates an object of type &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; with implementation-specific content.</source>
          <target state="translated">1) 기본 생성자 : 구현 별 내용으로 &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; 유형의 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="dde1237e4c299d5a88703d284c2d9f1b0330d7bc" translate="yes" xml:space="preserve">
          <source>1) destructors of objects with static storage duration are called in reverse order of completion of their constructors or the completion of their &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;dynamic initialization&lt;/a&gt;, and the functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are called in reverse order they are registered (last one first). a) any static objects whose initialization was completed before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F will be destroyed after the call to F during program termination. b) any static objects whose construction began after the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F will be destroyed before the call to F during program termination (this includes the case where &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; was called from the constructor of the static object)</source>
          <target state="translated">1) 정적 저장 기간을 가진 객체의 소멸자는 생성자의 완료 순서 또는 &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;동적 초기화&lt;/a&gt; 완료의 순서로 호출되며 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 전달 된 함수 는 등록 된 순서대로 호출됩니다 (마지막 첫 번째). a) 어떤 함수 F에 대한 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 를 호출하기 전에 초기화가 완료된 정적 객체는 프로그램 종료 중에 F를 호출 한 후 삭제됩니다. b) 프로그램 종료 중에 F를 호출하기 전에 일부 함수 F에 대한 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 호출 후 생성이 시작된 정적 오브젝트는 정적 오브젝트의 생성자 에서 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 가 호출 된 경우를 포함 합니다. )</target>
        </trans-unit>
        <trans-unit id="dcf7f086d26c92140d5665521d6f972ea28b4075" translate="yes" xml:space="preserve">
          <source>1) elaborated type specifier for a class type</source>
          <target state="translated">1) 클래스 타입을위한 정교한 타입 지정자</target>
        </trans-unit>
        <trans-unit id="6160fe4e565fb3d9b2b12c87b05a83e491dcc6e4" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showbase&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showbase&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showbase&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: showbase&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;showbase&lt;/code&gt; 플래그를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="3c9bb54bfcf8d4b0934ee7a2b61ffada58ca8f70" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showpoint&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpoint&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpoint&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: showpoint&lt;/a&gt; )를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;showpoint&lt;/code&gt; 플래그를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5cbc68830f2af6be690ee57ddb1a020743ee8a1f" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showpos&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpos&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpos&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: showpos&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;showpos&lt;/code&gt; 플래그를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="ec4fee75897569d1ba002fd796b242776e66d768" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;skipws&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::skipws&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::skipws&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: skipws&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;skipws&lt;/code&gt; 플래그를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="e78cc3813053d3dcc3353f63d38c9f3c40480169" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;unitbuf&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: unitbuf&lt;/a&gt; ) 를 호출하여 마치 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;unitbuf&lt;/code&gt; 플래그를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="e6c512f457d94c1407d26442e22f6caaa812de6e" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;uppercase&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::uppercase&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::uppercase&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: uppercase&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;uppercase&lt;/code&gt; 플래그를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="fca12c96ad1be6c8785cc47ea43d3c81665b28d0" translate="yes" xml:space="preserve">
          <source>1) expression statements;</source>
          <target state="translated">1) 표현 문;</target>
        </trans-unit>
        <trans-unit id="4f15378fe06eb783737d9e09aa30928eef4d729d" translate="yes" xml:space="preserve">
          <source>1) forms a literal &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; with the real part zero and imaginary part &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">1) 실수 부분 0과 허수 부분 &lt;code&gt;arg&lt;/code&gt; 로 리터럴 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; 을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="b1be539d05656ffe16187d9f074b5f435a3f1a78" translate="yes" xml:space="preserve">
          <source>1) function parameter of a function template declared as rvalue reference to cv-unqualified &lt;a href=&quot;template_parameters&quot;&gt;type template parameter&lt;/a&gt; of that same function template:</source>
          <target state="translated">1) 동일한 함수 템플릿의 cv-unqualified &lt;a href=&quot;template_parameters&quot;&gt;형식 템플릿 매개 변수&lt;/a&gt; 에 대한 rvalue 참조로 선언 된 함수 템플릿의 함수 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="933951affe5827f2ddb2f2c9addfe63c922b58e8" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;static&quot;&gt;static data member&lt;/a&gt;:</source>
          <target state="translated">1) &lt;code&gt;E2&lt;/code&gt; 가 &lt;a href=&quot;static&quot;&gt;정적 데이터 멤버 인 경우&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f24447a09ca19b04649b1c980278aea007b7651a" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;E2&lt;/code&gt; is a pointer to data member,</source>
          <target state="translated">1) &lt;code&gt;E2&lt;/code&gt; 가 데이터 멤버에 대한 포인터 인 경우</target>
        </trans-unit>
        <trans-unit id="fd8cbf371492e8ec4bdc5da5949d838ae310b0b6" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a class type with at least one user-provided constructor of any kind, the &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt; is called; 2) if &lt;code&gt;T&lt;/code&gt; is a non-union class type without any user-provided constructors, every non-static data member and base-class component of T is value-initialized;</source>
          <target state="translated">1) &lt;code&gt;T&lt;/code&gt; 가 어떤 종류의 사용자 제공 생성자가 하나 이상있는 클래스 유형 인 경우 &lt;a href=&quot;default_constructor&quot;&gt;기본 생성자&lt;/a&gt; 가 호출됩니다. 2) &lt;code&gt;T&lt;/code&gt; 가 사용자 제공 생성자가없는 비 유니언 클래스 유형 인 경우 T의 모든 비 정적 데이터 멤버 및 기본 클래스 구성 요소는 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="cc5cbe2c36375ecb8459cbffdcc5e56194637eb7" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a class type with no default constructor or with a user-provided or deleted default constructor, the object is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;; 2) if &lt;code&gt;T&lt;/code&gt; is a class type with a default constructor that is neither user-provided nor deleted (that is, it may be a class with an implicitly-defined or defaulted default constructor), the object is &lt;a href=&quot;zero_initialization&quot;&gt;zero-initialized&lt;/a&gt; and then it is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt; if it has a non-trivial default constructor;</source>
          <target state="translated">1) &lt;code&gt;T&lt;/code&gt; 가 기본 생성자가 없거나 사용자가 제공하거나 삭제 한 기본 생성자가없는 클래스 유형 인 경우 객체는 &lt;a href=&quot;default_initialization&quot;&gt;기본적으로 초기화됩니다&lt;/a&gt; . 2) &lt;code&gt;T&lt;/code&gt; 가 사용자 제공 또는 삭제되지 않은 기본 생성자를 가진 클래스 유형 인 경우 (즉, 암시 적으로 정의되거나 기본 기본 생성자를 가진 클래스 일 수 있음), 객체는 &lt;a href=&quot;zero_initialization&quot;&gt;0으로 초기화 된&lt;/a&gt; 다음 사소한 기본 생성자가 있으면 &lt;a href=&quot;default_initialization&quot;&gt;기본값으로 초기화&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="2567e503e479ddfa34c6e4c7e7e466e63c7a9083" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes one argument of type &lt;code&gt;A1&lt;/code&gt;, then &lt;code&gt;argument_type&lt;/code&gt; is &lt;code&gt;A1&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;A1&lt;/code&gt; 유형의 인수 하나를 취하는 함수 또는 함수에 대한 포인터 인 경우 &lt;code&gt;argument_type&lt;/code&gt; 은 &lt;code&gt;A1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05248e1e5cafa82d974bc4d2920820bbd80169d6" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes two arguments of type s &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt;, then &lt;code&gt;second_argument_type&lt;/code&gt; is &lt;code&gt;A2&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;T&lt;/code&gt; 가 s &lt;code&gt;A1&lt;/code&gt; 및 &lt;code&gt;A2&lt;/code&gt; 유형의 두 인수를 취하는 함수 또는 함수에 대한 포인터 인 경우 &lt;code&gt;second_argument_type&lt;/code&gt; 은 &lt;code&gt;A2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ccfd08717e620a2adb1e880c6d6d8a684f02c9b9" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes two arguments of types &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt;, then &lt;code&gt;first_argument_type&lt;/code&gt; is &lt;code&gt;A1&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;A1&lt;/code&gt; 및 &lt;code&gt;A2&lt;/code&gt; 유형의 두 인수를 취하는 함수 또는 함수에 대한 포인터 인 경우 &lt;code&gt;first_argument_type&lt;/code&gt; 은 &lt;code&gt;A1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a431179612485d24bc273e5248075c581ebeb99d" translate="yes" xml:space="preserve">
          <source>1) if A and B are &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, and A</source>
          <target state="translated">1) A와 B가 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 연산 인 경우 A</target>
        </trans-unit>
        <trans-unit id="649d80319d06d238094897a0c7387db3f34a9dba" translate="yes" xml:space="preserve">
          <source>1) initialization of a named variable with a</source>
          <target state="translated">1) 명명 된 변수의 초기화</target>
        </trans-unit>
        <trans-unit id="1368a73e49095bf4c57e55786671e41410e57ea6" translate="yes" xml:space="preserve">
          <source>1) initialization with a nonempty parenthesized list of expressions or braced-init-lists(since C++11)</source>
          <target state="translated">1) 비어 있지 않은 괄호로 묶은 표현식 목록 또는 braced-init-lists로 초기화 (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="99f4faeed3de5d70f2b4ff261841eff7c00945ba" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::hours&lt;/a&gt;(hrs)&lt;/code&gt;</source>
          <target state="translated">1) 정수 리터럴, 정확하게 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::hours&lt;/a&gt;(hrs)&lt;/code&gt; (hrs)를 반환</target>
        </trans-unit>
        <trans-unit id="b87dde5587a9a2ce938326ff6f293bb389b57a11" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::microseconds&lt;/a&gt;(us)&lt;/code&gt;</source>
          <target state="translated">1) 정수 리터럴, 정확하게 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::microseconds&lt;/a&gt;(us)&lt;/code&gt; (us)를 반환합니다</target>
        </trans-unit>
        <trans-unit id="73237f5b88515e9f07510adba322ff008703bf77" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::milliseconds&lt;/a&gt;(ms)&lt;/code&gt;</source>
          <target state="translated">1) 정수 리터럴, 정확하게 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::milliseconds&lt;/a&gt;(ms)&lt;/code&gt; (ms)를 반환</target>
        </trans-unit>
        <trans-unit id="75957235d93ab14971c5ead82631c15f8903fa9f" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::minutes&lt;/a&gt;(mins)&lt;/code&gt;</source>
          <target state="translated">1) 정수 리터럴, 정확하게 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::minutes&lt;/a&gt;(mins)&lt;/code&gt; (분)을 반환</target>
        </trans-unit>
        <trans-unit id="9a65c38cb3e887f8107e9bb7e034295d9e9ba661" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::nanoseconds&lt;/a&gt;(nsec)&lt;/code&gt;</source>
          <target state="translated">1) 정수 리터럴, 정확하게 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::nanoseconds&lt;/a&gt;(nsec)&lt;/code&gt; (nsec)를 반환</target>
        </trans-unit>
        <trans-unit id="d2ff5af48ac230f178ca8f7aae38f7e5b97cd4ae" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(secs)&lt;/code&gt;</source>
          <target state="translated">1) 정수 리터럴, 정확하게 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(secs)&lt;/code&gt; (secs)를 반환</target>
        </trans-unit>
        <trans-unit id="3c2ec705f86909dc012b45e0a5e5eac830bf7b5e" translate="yes" xml:space="preserve">
          <source>1) it may apply to the parameter declarations of a function or lambda-expressions, in which case it indicates that initialization of the parameter carries dependency into lvalue-to-rvalue conversion of that object.</source>
          <target state="translated">1) 함수 또는 람다 식의 매개 변수 선언에 적용될 수 있으며,이 경우 매개 변수의 초기화가 해당 개체의 lvalue-to-rvalue 변환에 종속됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f08aa13ffd87bf5b57bd2b5c39f8fe2c531e8de4" translate="yes" xml:space="preserve">
          <source>1) left shift of lhs by rhs bits</source>
          <target state="translated">1) rhs 비트에 의한 lhs의 왼쪽 시프트</target>
        </trans-unit>
        <trans-unit id="a0ef1b765d867fe5ee7805c81437d622e4207832" translate="yes" xml:space="preserve">
          <source>1) linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">1) 선형 &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ff0e7aba3a51ab3e96b766a29da0e2d4e95d71e" translate="yes" xml:space="preserve">
          <source>1) linear in size of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;str&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="9ba4f8c918b38171c581014561921c19d85a056e" translate="yes" xml:space="preserve">
          <source>1) make more memory available</source>
          <target state="translated">1) 사용 가능한 메모리를 더 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="a0c8b5c53f4a3270d0819e3eea46631ace784dc4" translate="yes" xml:space="preserve">
          <source>1) may throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if an exception is thrown during output.</source>
          <target state="translated">1) 출력 중에 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="818942971c8d5e6d4f974a900c33b24a7f7a56bb" translate="yes" xml:space="preserve">
          <source>1) may throw, e.g. if &lt;code&gt;pointer&lt;/code&gt; defines a throwing &lt;code&gt;operator*&lt;/code&gt;</source>
          <target state="translated">1) 예를 들어 &lt;code&gt;pointer&lt;/code&gt; 가 던지기 &lt;code&gt;operator*&lt;/code&gt; 정의하는 경우 던질 수 있음 *</target>
        </trans-unit>
        <trans-unit id="b746d566df1bafa8f84adef1c6b1bd18579c2ad4" translate="yes" xml:space="preserve">
          <source>1) multiplication</source>
          <target state="translated">1) 곱셈</target>
        </trans-unit>
        <trans-unit id="63b22e6c68841953ed2ca6a9ca96cff9639efe85" translate="yes" xml:space="preserve">
          <source>1) narrow character literal or ordinary character literal, e.g. &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt; or &lt;code&gt;'\13'&lt;/code&gt;. Such literal has type &lt;code&gt;char&lt;/code&gt; and the value equal to the representation of c-char in the execution character set. If c-char is not representable as a single byte in the execution character set, the literal has type &lt;code&gt;int&lt;/code&gt; and implementation-defined value</source>
          <target state="translated">1) 좁은 문자 그대로 또는 통상의 문자 그대로, 예를 들면 &lt;code&gt;'a'&lt;/code&gt; 또는 &lt;code&gt;'\n'&lt;/code&gt; 또는 &lt;code&gt;'\13'&lt;/code&gt; . 이러한 리터럴에는 &lt;code&gt;char&lt;/code&gt; 유형 과 실행 문자 세트의 c-char 표현과 동일한 값이 있습니다. c-char가 실행 문자 세트에서 단일 바이트로 표현할 수없는 경우 리터럴은 &lt;code&gt;int&lt;/code&gt; 유형 과 구현 정의 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b3526fa909cbee863631df5a0dd6e3dfe3d40b87" translate="yes" xml:space="preserve">
          <source>1) op E</source>
          <target state="translated">1) op E</target>
        </trans-unit>
        <trans-unit id="4adc80c0600353b3a1170e14f5e464ff13775a27" translate="yes" xml:space="preserve">
          <source>1) overloaded operator;</source>
          <target state="translated">1) 과부하 된 조작자;</target>
        </trans-unit>
        <trans-unit id="5e09baa491e636964ed3becfd3445f8709e44fad" translate="yes" xml:space="preserve">
          <source>1) p made relative against base.</source>
          <target state="translated">1) p는 염기에 대해 상대적으로 만들어졌다.</target>
        </trans-unit>
        <trans-unit id="f807176049911b041a40e01ee8ab370dcdb89766" translate="yes" xml:space="preserve">
          <source>1) postfix increment (post-increment)</source>
          <target state="translated">1) 접미사 증가 (사후 증가)</target>
        </trans-unit>
        <trans-unit id="2d5856705fcd5ea07c48025861fe3b1f79bc0d2c" translate="yes" xml:space="preserve">
          <source>1) prefix increment (pre-increment)</source>
          <target state="translated">1) 접두사 증가 (사전 증가)</target>
        </trans-unit>
        <trans-unit id="daa92feecb37a0d054ee8b707dc9aac07a31a3ea" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_encoding&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_encoding&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5328462b7087b609c543e78bd8d46692bea782df" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_length&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_length&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="53f57d286d6e754d726ea6cccf746a676dfa1638" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_out&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_out&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e4db4e3900ed888101fc0f5f38719bd3c6326b25" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_unshift&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_unshift&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="36bebe33f8e9dfba4ec0a7482223647307e5d502" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_close&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_close&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="087deceeef2229bfa0f69093a5dde5435352bc10" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_monthname&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_get_monthname&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="54d273175a96ff13269f617ec3bfb9a5e807469d" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_time&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_get_time&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2a24196c23f9b282e50225c8ce404605af1d591e" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_weekday&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_get_weekday&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c90b5960dcfdbae543519fd42dff106975cf6a49" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_year&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_get_year&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ced48bdf0ef79442409261aece9019fc894855a2" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_scan_is&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_scan_is&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="278c95483ac183d21fe5237adc621b7ef3fd15ff" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_scan_not&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_scan_not&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a5100d04826728fa57d41699139922616240294d" translate="yes" xml:space="preserve">
          <source>1) regular function body</source>
          <target state="translated">1) 정기 기능 체</target>
        </trans-unit>
        <trans-unit id="aeec3a3b882e59daf64402de22ed548e3658687c" translate="yes" xml:space="preserve">
          <source>1) removes the topmost &lt;code&gt;const&lt;/code&gt;, the topmost &lt;code&gt;volatile&lt;/code&gt;, or both, if present.</source>
          <target state="translated">1) 최상위 &lt;code&gt;const&lt;/code&gt; , 최상위 &lt;code&gt;volatile&lt;/code&gt; 또는 존재하는 경우 둘 다 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="1791c7ad104cbda662a1ae0402149dd47873c5da" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;{str, len}&lt;/code&gt; {str, len}을 반환합니다</target>
        </trans-unit>
        <trans-unit id="6f85b4809a3f0e34d7e0945ed1b8a2c6c86889a9" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::string_view&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::string_view&lt;/a&gt;{str, len}&lt;/code&gt; {str, len}을 반환합니다</target>
        </trans-unit>
        <trans-unit id="3e1e200684cc13c5bab72f139037d8694e2ed55a" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;c.empty()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;c.empty()&lt;/code&gt; )를 반환</target>
        </trans-unit>
        <trans-unit id="336ac5fcb4da96dfd10ca30f8265c27f9432fe83" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;static_cast&amp;lt;OuterAlloc&amp;amp;&amp;gt;(*this)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;static_cast&amp;lt;OuterAlloc&amp;amp;&amp;gt;(*this)&lt;/code&gt; )를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b910831624bf6214fa9cc9d794c642134d756feb" translate="yes" xml:space="preserve">
          <source>1) returns current formatting setting.</source>
          <target state="translated">1) 현재 서식 설정을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c6efa04b91565e54da0890082e64bf37e9ce1f7" translate="yes" xml:space="preserve">
          <source>1) returns the current fill character</source>
          <target state="translated">1) 현재 채우기 문자를 반환</target>
        </trans-unit>
        <trans-unit id="d936fcd6af68f91a166aa90e999f1232b7d7c9be" translate="yes" xml:space="preserve">
          <source>1) returns the pointer to the underlying byte stream.</source>
          <target state="translated">1) 기본 바이트 스트림에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c507b3bfa348dac59725e8ea55ae43c6356c3b0" translate="yes" xml:space="preserve">
          <source>1) same as &lt;code&gt;reduce(first, last, typename &lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;InputIt&amp;gt;::value_type{})&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;reduce(first, last, typename &lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;InputIt&amp;gt;::value_type{})&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
