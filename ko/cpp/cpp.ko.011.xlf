<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="622dca44b962cc1f074838d9efdbe8759696a1de" translate="yes" xml:space="preserve">
          <source>Associative containers implement sorted data structures that can be quickly searched (O(log n) complexity).</source>
          <target state="translated">연관 컨테이너는 신속하게 검색 할 수있는 정렬 된 데이터 구조를 구현합니다 (O (log n) 복잡성).</target>
        </trans-unit>
        <trans-unit id="1c6a25ab3379bdd54a1512bb45e9d133927a1700" translate="yes" xml:space="preserve">
          <source>Associative containers in the standard library</source>
          <target state="translated">표준 라이브러리의 연관 컨테이너</target>
        </trans-unit>
        <trans-unit id="f3b3c941634aac79492f857fc539fd4c9d008a56" translate="yes" xml:space="preserve">
          <source>AssociativeContainer</source>
          <target state="translated">AssociativeContainer</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="b3392e5205fe590e481f972619ef5508947ebdc5" translate="yes" xml:space="preserve">
          <source>Associativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left (&lt;code&gt;delete ++*p&lt;/code&gt; is &lt;code&gt;delete(++(*p))&lt;/code&gt;) and unary postfix operators always associate left-to-right (&lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt;). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: &lt;code&gt;a.b++&lt;/code&gt; is parsed &lt;code&gt;(a.b)++&lt;/code&gt; and not &lt;code&gt;a.(b++)&lt;/code&gt;.</source>
          <target state="translated">연관성 스펙은 단항 연산자에 대해 중복되며 완전성을 위해 표시됩니다. 단항 접 두부 연산자는 항상 오른쪽에서 왼쪽으로 연관 ( &lt;code&gt;delete ++*p&lt;/code&gt; is &lt;code&gt;delete(++(*p))&lt;/code&gt; ) 및 단항 접두어 연산자는 항상 왼쪽에서 연관 -right ( &lt;code&gt;a[1][2]++&lt;/code&gt; 는 &lt;code&gt;((a[1])[2])++&lt;/code&gt; )입니다. &lt;code&gt;a.b++&lt;/code&gt; 는 a &lt;code&gt;a.(b++)&lt;/code&gt; 아니라 구문 분석 된 &lt;code&gt;(a.b)++&lt;/code&gt; 이며, 단항 접두사 연산자로 그룹화되어 있어도 멤버 액세스 연산자에는 연관성이 의미가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6062b342e2d9e9c70ef9a02f2326265c628746c" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;i&lt;/code&gt; has built-in type or the postincrement operator is not &lt;a href=&quot;operators&quot;&gt;overloaded&lt;/a&gt; to return by lvalue reference.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 에 내장 유형이 있거나 사후 증분 연산자가 &lt;a href=&quot;operators&quot;&gt;과부하&lt;/a&gt; 되어 lvalue 참조로 리턴 되지 않는다고 가정 하십시오.</target>
        </trans-unit>
        <trans-unit id="74f381465fb7e488d40ff21e2669ec9bd0efa9fd" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;i&lt;/code&gt; has built-in type or the pre-increment operator is &lt;a href=&quot;operators&quot;&gt;overloaded&lt;/a&gt; to return by lvalue reference.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 에 내장 유형이 있거나 사전 증분 연산자가 &lt;a href=&quot;operators&quot;&gt;과부하&lt;/a&gt; 되어 lvalue 참조로 리턴 한다고 가정 하십시오.</target>
        </trans-unit>
        <trans-unit id="033599246c3928bd9bbc1f63fef180f75f1d6fa6" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;CD&lt;/code&gt; is the function return type and &lt;code&gt;CR&amp;lt;A, B&amp;gt; = &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;A, B&amp;gt;::type&lt;/code&gt;, then:</source>
          <target state="translated">한다고 가정 &lt;code&gt;CD&lt;/code&gt; 는 함수 리턴 형이고 &lt;code&gt;CR&amp;lt;A, B&amp;gt; = &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;A, B&amp;gt;::type&lt;/code&gt; 다음 :</target>
        </trans-unit>
        <trans-unit id="f51aeb937353e872aa16e888ad3642d2d51989e0" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;CT =&lt;br/&gt; &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep1, Period1&amp;gt;,&lt;br/&gt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep2, Period2&amp;gt;&amp;gt;::type&lt;/code&gt;, then:</source>
          <target state="translated">한다고 가정 &lt;code&gt;CT =&lt;br/&gt; &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep1, Period1&amp;gt;,&lt;br/&gt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep2, Period2&amp;gt;&amp;gt;::type&lt;/code&gt; 다음을 :</target>
        </trans-unit>
        <trans-unit id="16dad30e22d9f8f0b187b91674cdf99f5bfa4cfb" translate="yes" xml:space="preserve">
          <source>Assuming that alignment requirements are met, a &lt;code&gt;reinterpret_cast&lt;/code&gt; does not change the &lt;a href=&quot;pointer#Pointers&quot;&gt;value of a pointer&lt;/a&gt; outside of a few limited cases dealing with &lt;a href=&quot;static_cast#pointer-interconvertible&quot;&gt;&lt;i&gt;pointer-interconvertible&lt;/i&gt;&lt;/a&gt; objects:</source>
          <target state="translated">정렬 요구 사항이 충족되었다고 가정하면 &lt;code&gt;reinterpret_cast&lt;/code&gt; 는 &lt;a href=&quot;static_cast#pointer-interconvertible&quot;&gt;&lt;i&gt;포인터 상호 변환 가능한&lt;/i&gt;&lt;/a&gt; 객체를 다루는 몇 가지 제한된 경우 이외의 &lt;a href=&quot;pointer#Pointers&quot;&gt;포인터 값을&lt;/a&gt; 변경하지 않습니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="eaa51d32fe12f955eec03f2bc4bdb2751f3da027" translate="yes" xml:space="preserve">
          <source>At first, a local variable of type &lt;code&gt;BidirIt&lt;/code&gt; is constructed with the value of &lt;code&gt;match[0].second&lt;/code&gt;.</source>
          <target state="translated">처음에 &lt;code&gt;BidirIt&lt;/code&gt; 유형의 로컬 변수 는 &lt;code&gt;match[0].second&lt;/code&gt; 값으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9ec839d7fa04addb5ce25ff54e78bc29c079bf1" translate="yes" xml:space="preserve">
          <source>At least one major implementation does not implement these rules and instead optimizes out the store to &lt;code&gt;n&lt;/code&gt;. The lifetime rules are under reconsideration as &lt;a href=&quot;https://wg21.link/CWG2256&quot;&gt;core issue 2256&lt;/a&gt;.</source>
          <target state="translated">적어도 하나의 주요 구현은 이러한 규칙을 구현하지 않고 대신 저장소를 &lt;code&gt;n&lt;/code&gt; 으로 최적화합니다 . 수명 규칙은 &lt;a href=&quot;https://wg21.link/CWG2256&quot;&gt;핵심 이슈 2256&lt;/a&gt; 으로 재검토되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5357281e6d1ead597f87156333dc4e4a2d371458" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; depends on a user-defined type, and</source>
          <target state="translated">&lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 중 적어도 하나 는 사용자 정의 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b7ff6c8662e2b7c4ac75ca0560a6904f05eb0097" translate="yes" xml:space="preserve">
          <source>At most</source>
          <target state="translated">많으면</target>
        </trans-unit>
        <trans-unit id="a065be791d5f07e9b9b28e1a3ee4de5830efc2d5" translate="yes" xml:space="preserve">
          <source>At most 2&amp;middot;(N&lt;sub&gt;1&lt;/sub&gt;+N&lt;sub&gt;2&lt;/sub&gt;-1) comparisons, where N&lt;sub&gt;1&lt;/sub&gt;&lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; and N&lt;sub&gt;2&lt;/sub&gt;&lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt;.</source>
          <target state="translated">최대 2 &amp;middot; (N &lt;sub&gt;1&lt;/sub&gt; + N &lt;sub&gt;2&lt;/sub&gt; -1) 비교에서 N &lt;sub&gt;1 &lt;/sub&gt; &lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; 및 N &lt;sub&gt;2 &lt;/sub&gt; &lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f417027ea40c23a98d041983aee663fe84c4fd8a" translate="yes" xml:space="preserve">
          <source>At most 2&amp;middot;min(N1, N2) applications of the comparison operation, where &lt;code&gt;N1 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; and &lt;code&gt;N2 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N1 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; 및 &lt;code&gt;N2 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; 비교 연산의 최대 2 &amp;middot; min (N1, N2) 애플리케이션 .</target>
        </trans-unit>
        <trans-unit id="82ec885967ce3dacad15402cd2d8eb2b10af93f5" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;(last-first)/2&lt;/code&gt; swaps. Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.</source>
          <target state="translated">최대 &lt;code&gt;(last-first)/2&lt;/code&gt; 스왑. 전체 순열 순서에 대해 평균을 구한 일반적인 구현에서는 호출 당 약 3 개의 비교와 1.5 개의 스왑을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ddecdfce8186bf2f225c5a792633c5ddf7b502c1" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;3*&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; comparisons.</source>
          <target state="translated">최대 &lt;code&gt;3*&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 비교.</target>
        </trans-unit>
        <trans-unit id="37142ec0061a83658ba826e1c1afead3f11e0ec2" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;d_last - d_first&lt;/code&gt; of the elements are placed sorted to the range &lt;code&gt;[d_first, d_first + n)&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; is the number of elements to sort (&lt;code&gt;n = min(last - first, d_last - d_first)&lt;/code&gt;). The order of equal elements is not guaranteed to be preserved.</source>
          <target state="translated">최대 &lt;code&gt;d_last - d_first&lt;/code&gt; 요소는 &lt;code&gt;[d_first, d_first + n)&lt;/code&gt; 범위로 정렬됩니다 . &lt;code&gt;n&lt;/code&gt; 은 정렬 할 요소의 수입니다 ( &lt;code&gt;n = min(last - first, d_last - d_first)&lt;/code&gt; ). 동일한 요소의 순서는 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2675fe7d12495f05dcdb52627fa675c17129e6a" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last - first&lt;/code&gt; applications of the predicate and the projection.</source>
          <target state="translated">술어와 프로젝션의 기껏해야 &lt;code&gt;last - first&lt;/code&gt; 적용.</target>
        </trans-unit>
        <trans-unit id="29eb338ad07d90987b424a3ee5360988d67741cd" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last - first&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">대부분의에서 &lt;code&gt;last - first&lt;/code&gt; 술어의 응용 프로그램.</target>
        </trans-unit>
        <trans-unit id="c36a9685749cdd93b9b788e8f13203a1e8dd5a28" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">대부분에서 &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; 술어의 응용 프로그램.</target>
        </trans-unit>
        <trans-unit id="835c572fed24e005461e8303ab401feae3c77b72" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;std::distance(first, last)&lt;/code&gt; applications of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">대부분의 &lt;code&gt;std::distance(first, last)&lt;/code&gt; 의 응용 프로그램 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28b847c1c9ad7813c6cd6afbca6893f3a89d3246" translate="yes" xml:space="preserve">
          <source>At most N/2 swaps, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;. Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.</source>
          <target state="translated">최대 N / 2 스왑에서 &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 입니다. 전체 순열 순서에 대해 평균을 구한 일반적인 구현에서는 호출 당 약 3 개의 비교와 1.5 개의 스왑을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="87d08107753bb0853d26d589fe4f49b4791d7a3c" translate="yes" xml:space="preserve">
          <source>At most O(N&lt;sup&gt;2&lt;/sup&gt;) applications of the predicate, or exactly N if the sequences are already equal, where &lt;code&gt;N=&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt;.</source>
          <target state="translated">술어의 최대 O (N &lt;sup&gt;2&lt;/sup&gt; ) 애플리케이션 또는 시퀀스가 ​​이미 동일한 경우 정확히 N입니다. 여기서 &lt;code&gt;N=&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7e9957d5de91d4b7c6c68d594aa3aa480005b9e3" translate="yes" xml:space="preserve">
          <source>At most linear in the &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; of the container.</source>
          <target state="translated">컨테이너 의 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 에서 최대 선형 .</target>
        </trans-unit>
        <trans-unit id="7b67cf2f323c75240ad28ea0936fabdb2eb7dfd2" translate="yes" xml:space="preserve">
          <source>At most linear in the &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; of the string.</source>
          <target state="translated">문자열 의 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 에서 최대 선형입니다 .</target>
        </trans-unit>
        <trans-unit id="1f95351bbc9191f119c0c979d668c0b60be5e7b1" translate="yes" xml:space="preserve">
          <source>At most linear in the size of the container.</source>
          <target state="translated">컨테이너의 크기는 최대 선형입니다.</target>
        </trans-unit>
        <trans-unit id="a42136bb0320d6ac91f01ed89b5ec95ea11cd801" translate="yes" xml:space="preserve">
          <source>At most max(floor((3/2)*(N&amp;minus;1)), 0) applications of the predicate, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">술어의 최대 max (floor ((3/2) * (N&amp;minus;1)), 0) 응용 프로그램에서 &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1d7bca3c1a2d078e776e71dcbe99b35a321e5167" translate="yes" xml:space="preserve">
          <source>At most one &lt;a href=&quot;union#Union-like_classes&quot;&gt;variant member&lt;/a&gt; can have a &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;.</source>
          <target state="translated">하나의 &lt;a href=&quot;union#Union-like_classes&quot;&gt;변형 멤버&lt;/a&gt; 는 &lt;a href=&quot;data_members#Member_initialization&quot;&gt;기본 멤버 이니셜 라이저를&lt;/a&gt; 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c1f6896df7e191deb062d81024e89c21817f2db" translate="yes" xml:space="preserve">
          <source>At most one copy option in each of the following options groups may be present, otherwise the behavior of the copy functions is undefined.</source>
          <target state="translated">다음 각 옵션 그룹에 최대 하나의 복사 옵션이 존재할 수 있습니다. 그렇지 않으면 복사 기능의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d4b41d6c4f9d31917e8132872ca199c890aa525" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ECMAScript&lt;/code&gt; , &lt;code&gt;basic&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; , &lt;code&gt;awk&lt;/code&gt; , &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;egrep&lt;/code&gt; 중에서 최대 하나의 문법 옵션을 선택해야합니다 . 문법을 선택하지 않으면 &lt;code&gt;ECMAScript&lt;/code&gt; 가 선택된 것으로 간주됩니다. 다른 옵션은 &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt; 와 동일하도록 수정 자 역할을합니다. :: icase) .</target>
        </trans-unit>
        <trans-unit id="4664e42aaeebe95a9d1a078a45a775bf60943bc7" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ECMAScript&lt;/code&gt; , &lt;code&gt;basic&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; , &lt;code&gt;awk&lt;/code&gt; , &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;egrep&lt;/code&gt; 중에서 최대 하나의 문법 옵션을 선택해야합니다 . 문법을 선택하지 않으면 &lt;code&gt;ECMAScript&lt;/code&gt; 가 선택된 것으로 간주됩니다. 다른 옵션은 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt; 와 동일하도록 수정 자 역할을합니다. :: icase) .</target>
        </trans-unit>
        <trans-unit id="5e31fa82af84a5c287a47f543cebf5aedf134031" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ECMAScript&lt;/code&gt; , &lt;code&gt;basic&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; , &lt;code&gt;awk&lt;/code&gt; , &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;egrep&lt;/code&gt; 중에서 최대 하나의 문법 옵션을 선택해야합니다 . 문법을 선택하지 않으면 &lt;code&gt;ECMAScript&lt;/code&gt; 가 선택된 것으로 간주됩니다. 다른 옵션은 &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; 가 &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt; 와 동일하도록 수정 자 역할을합니다. :: icase) .</target>
        </trans-unit>
        <trans-unit id="311d67e063c452f5ead23f742890b672f660636b" translate="yes" xml:space="preserve">
          <source>At most one of &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; may be present, otherwise the behavior of the permissions function is undefined.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; 중 하나 이상이 존재할 수 있으며, 그렇지 않으면 권한 함수의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2395ecfd633261d1a9cd5400cd07b765cc2f7a58" translate="yes" xml:space="preserve">
          <source>At most two comparisons.</source>
          <target state="translated">최대 두 개의 비교.</target>
        </trans-unit>
        <trans-unit id="5c3f1418c87059f4cdb7e84bd90cc9bbf999a3c8" translate="yes" xml:space="preserve">
          <source>At or after modified element(s)</source>
          <target state="translated">수정 된 요소 또는 그 이후</target>
        </trans-unit>
        <trans-unit id="b99b53e1b81171c73a473d86eb4eba8e01df0ac3" translate="yes" xml:space="preserve">
          <source>At program startup,</source>
          <target state="translated">프로그램 시작시</target>
        </trans-unit>
        <trans-unit id="bc78dcde97d0faac3fa0ab3c4057950ede8cc9fd" translate="yes" xml:space="preserve">
          <source>At the point in the code the operator() is called, the type must be complete. In some implementations a &lt;code&gt;static_assert&lt;/code&gt; is used to make sure this is the case. The reason for this requirement is that calling &lt;a href=&quot;../language/delete&quot;&gt;delete&lt;/a&gt; on an incomplete type is undefined behavior in C++ if the complete class type has a nontrivial destructor or a deallocation function, as the compiler has no way of knowing whether such functions exist and must be invoked.</source>
          <target state="translated">코드에서 operator ()가 호출되면 형식이 완료되어야합니다. 일부 구현에서는 &lt;code&gt;static_assert&lt;/code&gt; 를 사용하여 이것이 사실인지 확인합니다. 이 요구 사항의 이유 는 완전한 클래스 유형에 중요하지 않은 소멸자 또는 할당 해제 함수가있는 경우 컴파일러가 해당 함수가 존재하는지 여부를 알 수있는 방법이 없기 때문에 불완전한 유형에서 &lt;a href=&quot;../language/delete&quot;&gt;delete&lt;/a&gt; 호출 이 정의되지 않은 동작이기 때문에 C ++에서 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="e34285cac72686e9e93e2ea071243a4d166878b4" translate="yes" xml:space="preserve">
          <source>Atomic Operations library</source>
          <target state="translated">원자력 운영 라이브러리</target>
        </trans-unit>
        <trans-unit id="8c9d8d00b5cb702da9e8a277758916eb4dd3cc1c" translate="yes" xml:space="preserve">
          <source>Atomic and synchronized blocks</source>
          <target state="translated">원자 및 동기화 블록</target>
        </trans-unit>
        <trans-unit id="6816e21f31c82f13f142f06d907125e6d3ac7b98" translate="yes" xml:space="preserve">
          <source>Atomic and synchronized blocks are used to implement &lt;a href=&quot;transactional_memory&quot;&gt;transactional memory&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;transactional_memory&quot;&gt;트랜잭션 메모리&lt;/a&gt; 를 구현하기 위해 원자 블록과 동기화 블록이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="82b6893aff5aea02a2292327874493a700ee80ae" translate="yes" xml:space="preserve">
          <source>Atomic blocks</source>
          <target state="translated">원자 블록</target>
        </trans-unit>
        <trans-unit id="17b2c09204bb130f11f065ef3080da8ab1f767cb" translate="yes" xml:space="preserve">
          <source>Atomic constraints</source>
          <target state="translated">원자 제약</target>
        </trans-unit>
        <trans-unit id="401a31bc657222e6c53d68e589a5e6bc2cfed3b4" translate="yes" xml:space="preserve">
          <source>Atomic constraints are formed during &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;constraint normalization&lt;/a&gt;. &lt;code&gt;E&lt;/code&gt; is never a logical AND or logical OR expression (those form conjunctions and disjunctions, respectively).</source>
          <target state="translated">원자 제약은 &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;제약 정규화&lt;/a&gt; 중에 형성됩니다 . &lt;code&gt;E&lt;/code&gt; 는 결코 논리 AND 또는 논리 OR 표현식이 아닙니다 (각각 형태 결합 및 분리).</target>
        </trans-unit>
        <trans-unit id="ab3668521ac1e65f2c9a3ca3cc545235dc9f88c8" translate="yes" xml:space="preserve">
          <source>Atomic load with &lt;code&gt;memory_order_acquire&lt;/code&gt; or stronger is an acquire operation. The lock() operation on a &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; is also an acquire operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than an acquire operation.</source>
          <target state="translated">&lt;code&gt;memory_order_acquire&lt;/code&gt; 이상의 원자로 드는 획득 조작입니다. &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; 의 lock () 작업 도 획득 작업입니다. 참고 &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; 강요하며에게 획득 작업보다 더 강한 동기화 요구 사항을.</target>
        </trans-unit>
        <trans-unit id="783585c8300c9cdf7a66c42d7b14307cfec6d73d" translate="yes" xml:space="preserve">
          <source>Atomic load with &lt;code&gt;memory_order_consume&lt;/code&gt; or stronger is a consume operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than a consume operation.</source>
          <target state="translated">&lt;code&gt;memory_order_consume&lt;/code&gt; 이상의 원자로 드는 소비 조작입니다. 참고 &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; A가 작업을 소비하는 것보다 강요하며 강하게 동기화 요구 사항을.</target>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="translated">원자력 운영</target>
        </trans-unit>
        <trans-unit id="99d4cd5536d79615f44163fe8a9526d16ce5bfca" translate="yes" xml:space="preserve">
          <source>Atomic operations applied to an object through an &lt;code&gt;atomic_ref&lt;/code&gt; are atomic with respect to atomic operations applied through any other &lt;code&gt;atomic_ref&lt;/code&gt; referencing the same object.</source>
          <target state="translated">&lt;code&gt;atomic_ref&lt;/code&gt; 를 통해 객체에 적용되는 원자 연산 은 동일한 객체를 참조하는 다른 &lt;code&gt;atomic_ref&lt;/code&gt; 를 통해 적용된 원자 연산과 관련하여 원자 적 입니다.</target>
        </trans-unit>
        <trans-unit id="ec45a74e461d6d1f9a6d6860119c9137a6fed5b2" translate="yes" xml:space="preserve">
          <source>Atomic operations library</source>
          <target state="translated">원자력 운영 라이브러리</target>
        </trans-unit>
        <trans-unit id="ac1cfc02a52dba8b178a48b4597760d28fb77ccd" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_relaxed&lt;/code&gt; are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.</source>
          <target state="translated">&lt;code&gt;memory_order_relaxed&lt;/code&gt; 태그가 붙은 원자 작업 은 동기화 작업이 아닙니다. 동시 메모리 액세스간에 순서를 부과하지 않습니다. 원 자성 및 수정 순서 일관성 만 보장합니다.</target>
        </trans-unit>
        <trans-unit id="4f6d4f2c68a571824e3f43d98c75cbda9d541c52" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; not only order memory the same way as release/acquire ordering (everything that</source>
          <target state="translated">&lt;code&gt;memory_order_seq_cst&lt;/code&gt; 태그가 지정된 원자 연산 은 릴리스 / 취득 순서와 동일한 방식으로 메모리를 주문할뿐만 아니라</target>
        </trans-unit>
        <trans-unit id="72d4efbfff4cc7a737493b1c1c5054ea34242989" translate="yes" xml:space="preserve">
          <source>Atomic store with &lt;code&gt;memory_order_release&lt;/code&gt; or stronger is a release operation. The unlock() operation on a &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; is also a release operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than a release operation.</source>
          <target state="translated">&lt;code&gt;memory_order_release&lt;/code&gt; 이상의 원자 저장소 는 릴리스 조작입니다. &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; 의 unlock () 작업 도 해제 작업입니다. 참고 &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; 강요하며에게 해제 조작보다 더 강한 동기화 요구 사항을.</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">원자 유형</target>
        </trans-unit>
        <trans-unit id="90945bda736ccd52d67480431115772e6ed72f07" translate="yes" xml:space="preserve">
          <source>Atomic-fence synchronization</source>
          <target state="translated">원자 울타리 동기화</target>
        </trans-unit>
        <trans-unit id="5d6ac2f41530550ee308dc296f9a8b617587365b" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 적으로 std :: atomic_flag 의 상태 를 clear ( &lt;code&gt;false&lt;/code&gt; )로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="29366d9f87188ae24c9efa9144aa990ffcfc84da" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the value it held before.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 적으로 std :: atomic_flag 의 상태 를 set ( &lt;code&gt;true&lt;/code&gt; )로 변경하고 이전에 보유한 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1ad9c0fc62bc1537d54b4759ea20c55784c16070" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; pointed to by &lt;code&gt;p&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 가리키는 &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 의 상태를 원자 적으로 변경하여 지 웁니다 ( &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="75a7c684721b08be0f1216c929374cec16cea043" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; pointed to by &lt;code&gt;p&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the value it held before.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 가리키는 &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 의 상태를 원자 적으로 변경하여 set ( &lt;code&gt;true&lt;/code&gt; ) 로 설정 하고 이전에 보유한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2222bc337f08cf3ae8d66cc236b81d457d5ceac1" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../../language/objects&quot;&gt;object representation&lt;/a&gt;(until C++20)&lt;a href=&quot;../../language/objects&quot;&gt;value representation&lt;/a&gt;(since C++20) of &lt;code&gt;*this&lt;/code&gt; with that of &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual value stored in &lt;code&gt;*this&lt;/code&gt; into &lt;code&gt;expected&lt;/code&gt; (performs load operation).</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 의 &lt;a href=&quot;../../language/objects&quot;&gt;객체 표현&lt;/a&gt; (C ++ 20까지) &lt;a href=&quot;../../language/objects&quot;&gt;값 표현&lt;/a&gt; (C ++ 20부터) 과 &lt;code&gt;expected&lt;/code&gt; 값 표현을 원자 적으로 비교하고 비트와 같으면 전자를 &lt;code&gt;desired&lt;/code&gt; 바꿉니다 (읽기-수정-쓰기 작업 수행) ). 그렇지 않으면 &lt;code&gt;*this&lt;/code&gt; 에 저장된 실제 값 을 &lt;code&gt;expected&lt;/code&gt; 로드합니다 (로드 작업 수행).</target>
        </trans-unit>
        <trans-unit id="7b40ae57bd4976e100c4d9ee74cf8c6179fd8839" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../../language/objects&quot;&gt;value representation&lt;/a&gt; of the referenced object with that of &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs a read-modify-write operation). Otherwise, loads the actual value stored in the referenced object into &lt;code&gt;expected&lt;/code&gt; (performs a load operation).</source>
          <target state="translated">참조 된 객체 의 &lt;a href=&quot;../../language/objects&quot;&gt;값 표현&lt;/a&gt; 을 &lt;code&gt;expected&lt;/code&gt; 객체 의 값 표현 과 원자 적으로 비교하고 비트와 같으면 전자를 &lt;code&gt;desired&lt;/code&gt; 바꿉니다 (읽기-수정-쓰기 작업 수행). 그렇지 않으면 참조 된 객체에 저장된 실제 값을 &lt;code&gt;expected&lt;/code&gt; 로드합니다 (로드 작업 수행).</target>
        </trans-unit>
        <trans-unit id="aeaea937abc0bf67a8421b823386eae91292163e" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;(until C++20)&lt;a href=&quot;../language/objects&quot;&gt;value representation&lt;/a&gt;(since C++20) of the object pointed to by &lt;code&gt;obj&lt;/code&gt; with that of the object pointed to by &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual value pointed to by &lt;code&gt;obj&lt;/code&gt; into &lt;code&gt;*expected&lt;/code&gt; (performs load operation). Copying is performed as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 &lt;a href=&quot;../language/objects&quot;&gt;객체&lt;/a&gt; 의 객체 표현 (C ++ 20까지) &lt;a href=&quot;../language/objects&quot;&gt;값 표현&lt;/a&gt; (C ++ 20 이후)을 &lt;code&gt;expected&lt;/code&gt; 가리키는 객체 의 객체 표현 과 비교하고 비트가 같으면 전자를 바꿉니다. &lt;code&gt;desired&lt;/code&gt; (읽기-수정-쓰기 작업 수행) 그렇지 않으면 &lt;code&gt;obj&lt;/code&gt; 가 가리키는 실제 값 을 &lt;code&gt;*expected&lt;/code&gt; 에 로드합니다 (로드 작업 수행). &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; 처럼 복사가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="100502f70f849b38ac64477081a65ec2c013fbb9" translate="yes" xml:space="preserve">
          <source>Atomically increments or decrements the current value of the referenced object. These operations are read-modify-write operations.</source>
          <target state="translated">참조 된 객체의 현재 값을 원자 적으로 증가 또는 감소시킵니다. 이러한 작업은 읽기-수정-쓰기 작업입니다.</target>
        </trans-unit>
        <trans-unit id="478a2d2041d2790f2221395bbe5bc4e3d3f3c4ae" translate="yes" xml:space="preserve">
          <source>Atomically increments or decrements the current value. The operation is read-modify-write operation.</source>
          <target state="translated">현재 값을 원자 적으로 증가 또는 감소시킵니다. 작업은 읽기-수정-쓰기 작업입니다.</target>
        </trans-unit>
        <trans-unit id="f7bed069080eb00025095bf335aa11983b2283e1" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable. Equivalent to &lt;code&gt;load()&lt;/code&gt;.</source>
          <target state="translated">원자 변수의 현재 값을 원자 적으로로드하고 반환합니다. &lt;code&gt;load()&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1952cd629d030a2fa8403e27ef4aeced380b94ae" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">원자 변수의 현재 값을 원자 적으로로드하고 반환합니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="1f83aead02c429c2fa534aa09292be21ef4c6405" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the referenced object. Equivalent to &lt;code&gt;load()&lt;/code&gt;.</source>
          <target state="translated">참조 된 객체의 현재 값을 원자 적으로로드하고 반환합니다. &lt;code&gt;load()&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e52c7a399bc235c4dbc0b29092d8308432fa02c0" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the referenced object. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">참조 된 객체의 현재 값을 원자 적으로로드하고 반환합니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="f53b29272e48fca5f9671422bca6315e7e6fd8c3" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with &lt;code&gt;desired&lt;/code&gt;. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">참조 된 객체의 현재 값을 &lt;code&gt;desired&lt;/code&gt; 원자 적으로 대체합니다 . 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="a19feea96676cb1f3c159f83afde19f4a6539c3e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of arithmetic addition of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">참조 된 객체의 현재 값을 값과 &lt;code&gt;arg&lt;/code&gt; 의 산술 추가 결과로 원자 적으로 대체합니다 . 이 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="6b3d0c0959425f2182650fbfbac226f664e7ddf7" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of arithmetic subtraction of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">참조 된 객체의 현재 값을 값과 &lt;code&gt;arg&lt;/code&gt; 의 산술 빼기 결과로 원자 적으로 대체합니다 . 이 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="99dda00379caf075c4d39211472eaedafbd4f762" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise AND of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">참조 된 객체의 현재 값을 비트 단위 AND 값 및 &lt;code&gt;arg&lt;/code&gt; 의 결과로 원자 적으로 대체합니다 . 이 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="323c91d66c8118d7dbee222ab3de24a8cae5e0b1" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise OR of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">참조 된 객체의 현재 값을 비트 단위 OR 값 및 &lt;code&gt;arg&lt;/code&gt; 의 결과로 원자 적으로 대체합니다 . 이 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="adf79a00626da82188ce094554607a0fe2a38357" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise XOR of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">참조 된 객체의 현재 값을 값의 비트 별 XOR 결과 및 &lt;code&gt;arg&lt;/code&gt; 로 원자 적으로 대체합니다 . 이 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="ed67e3ed1c1744cb0f490f47975b11310f42139e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of computation involving the previous value and &lt;code&gt;arg&lt;/code&gt;. These operations are read-modify-write operations.</source>
          <target state="translated">참조 된 객체의 현재 값을 이전 값과 &lt;code&gt;arg&lt;/code&gt; 가 포함 된 계산 결과로 원자 적으로 대체합니다 . 이러한 작업은 읽기-수정-쓰기 작업입니다.</target>
        </trans-unit>
        <trans-unit id="f9b3020972d1b8ef0fae02f3fff0adbd8b1bd992" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with &lt;code&gt;desired&lt;/code&gt;. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">현재 값을 &lt;code&gt;desired&lt;/code&gt; 원자 적으로 대체합니다 . 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="c638ee73c1897f53905a40e8ba22b46e8d59e4e1" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of arithmetic addition of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">현재 값을 값과 &lt;code&gt;arg&lt;/code&gt; 의 산술 추가 결과로 원자 적으로 대체합니다 . 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="b99663e5dfaace40d5f5294851f50381ac55b0bc" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of arithmetic subtraction of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">현재 값을 값과 &lt;code&gt;arg&lt;/code&gt; 의 산술 빼기 결과로 원자 적으로 대체합니다 . 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="79ead769b0375ec14ce72a88030040dd2a0e44be" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise AND of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">현재 값을 비트 단위 AND 값 및 &lt;code&gt;arg&lt;/code&gt; 의 결과로 원자 적으로 대체합니다 . 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="2b7fe2746833cc38f05662da6d971a85fc32df09" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise OR of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">현재 값을 비트 단위 OR 결과 및 &lt;code&gt;arg&lt;/code&gt; 의 결과로 원자 적으로 대체합니다 . 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="7ea95b2c69d82181c7d1ab5a7c21e9a5addde310" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise XOR of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">현재 값을 비트 XOR 및 &lt;code&gt;arg&lt;/code&gt; 의 결과로 원자 적으로 대체합니다 . 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="10212a346ea05ad906b686a41eca7ff8ef3b510f" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of computation involving the previous value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation.</source>
          <target state="translated">현재 값을 이전 값과 &lt;code&gt;arg&lt;/code&gt; 가 포함 된 계산 결과로 원자 적으로 대체합니다 . 작업은 읽기-수정-쓰기 작업입니다.</target>
        </trans-unit>
        <trans-unit id="3467c0dccb0c6c9b65479a9107e17419103cfb53" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; and returns a copy of the value that &lt;code&gt;p&lt;/code&gt; had immediately before the swap. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. This is an atomic read-modify-write operation.</source>
          <target state="translated">원자 대체 기본 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;desired&lt;/code&gt; 경우와 같이 &lt;code&gt;p.swap(desired)&lt;/code&gt; 여기서 &lt;code&gt;p&lt;/code&gt; 는 있는 기본 &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 반환하는 값의 사본 &lt;code&gt;p&lt;/code&gt; 는 스왑 직전에 있었다. 메모리에 따라 정렬되는 &lt;code&gt;order&lt;/code&gt; . 이것은 원자적인 읽기-수정-쓰기 작업입니다.</target>
        </trans-unit>
        <trans-unit id="85d280e69a1a33e2d68aa75acba96c49fd3e46b4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;, and returns a copy of the value that &lt;code&gt;p&lt;/code&gt; had immediately before the swap. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. This is an atomic read-modify-write operation.</source>
          <target state="translated">&lt;code&gt;p.swap(desired)&lt;/code&gt; 의한 것처럼 기본 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 를 &lt;code&gt;desired&lt;/code&gt; 대로 원자 적으로 대체합니다. 여기서 &lt;code&gt;p&lt;/code&gt; 는 기본 &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 입니다. &lt;code&gt;p&lt;/code&gt; 는 스왑 직전에 값의 사본을 리턴합니다 . 메모리에 따라 정렬되는 &lt;code&gt;order&lt;/code&gt; . 이것은 원자적인 읽기-수정-쓰기 작업입니다.</target>
        </trans-unit>
        <trans-unit id="0a463d97ca8c0c667a93bc169dce0bad4944f951" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying value with &lt;code&gt;desired&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">기본적으로 기본 값을 &lt;code&gt;desired&lt;/code&gt; 바꿉니다 . 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="718b9a19aefebfb54908169ba35b035711a206bc" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of &lt;code&gt;*this&lt;/code&gt; with the value of &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p.swap(desired)&lt;/code&gt; 의해 &lt;code&gt;*this&lt;/code&gt; 의 값을 &lt;code&gt;desired&lt;/code&gt; 값으로 원자 적으로 대체합니다. 여기서 &lt;code&gt;p&lt;/code&gt; 는 기본 &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 입니다. 메모리에 따라 정렬되는 &lt;code&gt;order&lt;/code&gt; . &lt;code&gt;order&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cc343521b195a9638c26a309b38189be49c6ff1c" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of &lt;code&gt;*this&lt;/code&gt; with the value of &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원자의 대체 값 &lt;code&gt;*this&lt;/code&gt; 값으로 &lt;code&gt;desired&lt;/code&gt; 경우와 같이 &lt;code&gt;p.swap(desired)&lt;/code&gt; 여기서, &lt;code&gt;p&lt;/code&gt; 기본 인 &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; . 메모리에 따라 정렬되는 &lt;code&gt;order&lt;/code&gt; . &lt;code&gt;order&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="eccb30a10adac1732c948846412c97a22323cf04" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of the referenced object with &lt;code&gt;desired&lt;/code&gt;. The operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">참조 된 객체의 값을 &lt;code&gt;desired&lt;/code&gt; 원자 적으로 대체합니다 . 작업은 읽기-수정-쓰기 작업입니다. 메모리는 &lt;code&gt;order&lt;/code&gt; 값에 따라 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="80dd75e8d600a19f4770f91cf5757274b7f5c6c5" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise AND between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;obj&lt;/code&gt; 와 &lt;code&gt;arg&lt;/code&gt; 의 이전 값 사이의 비트 AND 결과로 원자 적으로 대체합니다 . 이전에 보유한 &lt;code&gt;obj&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="790044bcc17db31e5c336936470c4daa1b6b3cd4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise OR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;obj&lt;/code&gt; 와 &lt;code&gt;arg&lt;/code&gt; 의 이전 값 사이의 비트 단위 OR 결과로 원자 적으로 대체합니다 . 이전에 보유한 &lt;code&gt;obj&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f251ecee591189cacdcc48a0936a14e913d943df" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise XOR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;obj&lt;/code&gt; 와 &lt;code&gt;arg&lt;/code&gt; 의 이전 값 사이의 비트 단위 XOR 결과로 원자 적으로 대체합니다 . 이전에 보유한 &lt;code&gt;obj&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3d9f4d98a3780918fb788b0a5026571e73af577e" translate="yes" xml:space="preserve">
          <source>Atomically returns a copy of the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 의 사본을 원자 적으로 리턴합니다 . 메모리에 따라 정렬되는 &lt;code&gt;order&lt;/code&gt; . &lt;code&gt;order&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="33f67f81fe0865ff25fe2875aabcaf4cb3ed91ca" translate="yes" xml:space="preserve">
          <source>Atomically returns a copy of the underlying shared pointer. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 공유 포인터의 복사본을 원자 적으로 반환합니다. 메모리에 따라 정렬되는 &lt;code&gt;order&lt;/code&gt; . &lt;code&gt;order&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="68c88562518723a64d9fcb4f31aa71ec0eefafe8" translate="yes" xml:space="preserve">
          <source>Atomically stores the exception pointer &lt;code&gt;p&lt;/code&gt; into the shared state and makes the state ready.</source>
          <target state="translated">예외 포인터 &lt;code&gt;p&lt;/code&gt; 를 공유 상태로 원자 적으로 저장하고 상태를 준비합니다.</target>
        </trans-unit>
        <trans-unit id="c5a3aae2b82d6bc278809f7ca79720a49ddb5e50" translate="yes" xml:space="preserve">
          <source>Atomically transmits all pending output to the wrapped stream.</source>
          <target state="translated">대기중인 모든 출력을 랩핑 된 스트림으로 원자 적으로 전송합니다.</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="a0416416d30eca6a7701e0924dc48acb5d8ff422" translate="yes" xml:space="preserve">
          <source>Attempting to forward an rvalue as an lvalue, such as by instantiating the form (2) with lvalue reference type T, is a compile-time error.</source>
          <target state="translated">lvalue 참조 유형 T를 사용하여 양식 (2)를 인스턴스화하는 것과 같이 rvalue를 lvalue로 전달하려고하면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="76a4004354e2dd4daf0348cba6cc1fc1999f48f1" translate="yes" xml:space="preserve">
          <source>Attempting to modify a string literal results in</source>
          <target state="translated">문자열 리터럴을 수정하려고하면</target>
        </trans-unit>
        <trans-unit id="abad2c050ad896c23b0ad28b3e223e6dd62344dd" translate="yes" xml:space="preserve">
          <source>Attempting to specialize a template defined in the &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; header results in undefined behavior, except that &lt;code&gt;&lt;a href=&quot;types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; may be specialized &lt;a href=&quot;types/common_type#Specializations&quot;&gt;as described in its description&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; 헤더에 정의 된 템플리트를 특수화하려고하면 &lt;code&gt;&lt;a href=&quot;types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; 이 &lt;a href=&quot;types/common_type#Specializations&quot;&gt;설명에 설명 된대로&lt;/a&gt; 특수화 될 수 있다는 점을 제외하고 정의되지 않은 동작 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="78a4a89b2d2486832b4cafece47f12bab7a55776" translate="yes" xml:space="preserve">
          <source>Attempts to acquire the lock for the current execution agent (thread, process, task) without blocking. If an exception is thrown, no lock is obtained.</source>
          <target state="translated">차단하지 않고 현재 실행 에이전트 (스레드, 프로세스, 작업)에 대한 잠금을 획득하려고 시도합니다. 예외가 발생하면 잠금이 획득되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="baca3810d2cde4b7e1025b84062248c5223beff5" translate="yes" xml:space="preserve">
          <source>Attempts to clear the floating-point exceptions that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">시도는 비트 마스크 인수에 나와있는 부동 소수점 예외 웁니다 &lt;code&gt;excepts&lt;/code&gt; 비트 단위 OR의이다, &lt;a href=&quot;fe_exceptions&quot;&gt;부동 소수점 예외 매크로&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7dbed2ba20cbcb53c66e4a383e6c53bad4b2eb39" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the comparison object of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 각 요소를 추출 ( &quot;splice&quot;) 하여 &lt;code&gt;*this&lt;/code&gt; 의 비교 오브젝트를 사용하여 * this에 삽입하려고 &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69638346260f8c39f54ee09036f959b95caeb136" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the comparison object of &lt;code&gt;*this&lt;/code&gt;. If there is an element in &lt;code&gt;*this&lt;/code&gt; with key equivalent to the key of an element from &lt;code&gt;source&lt;/code&gt;, then that element is not extracted from &lt;code&gt;source&lt;/code&gt;. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 각 요소를 추출 ( &quot;splice&quot;) 하여 &lt;code&gt;*this&lt;/code&gt; 의 비교 오브젝트를 사용하여 * this에 삽입하려고 &lt;code&gt;*this&lt;/code&gt; . 의 요소가있는 경우 &lt;code&gt;*this&lt;/code&gt; 에서 요소의 키에 해당하는 키 &lt;code&gt;source&lt;/code&gt; 이어서, 소자로부터 추출되지 않도록 &lt;code&gt;source&lt;/code&gt; . 요소가 복사되거나 이동되지 않으며 컨테이너 노드의 내부 포인터 만 재 지정됩니다. 전송 된 요소에 대한 모든 포인터 및 참조는 계속 유효하지만 이제 &lt;code&gt;source&lt;/code&gt; 가 아닌 &lt;code&gt;*this&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95555f012243a16b5fbac5ece1355dd665253556" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the hash function and key equality predicate of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 의 각 요소를 추출 ( &quot;splice&quot;) 하여 해시 함수 및 &lt;code&gt;*this&lt;/code&gt; 의 키 등호 술어를 사용하여 &lt;code&gt;*this&lt;/code&gt; 에 삽입하려고 합니다 .</target>
        </trans-unit>
        <trans-unit id="5462c1b9abbfcaedbee9e1ed5c5c12b594c2335b" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the hash function and key equality predicate of &lt;code&gt;*this&lt;/code&gt;. If there is an element in &lt;code&gt;*this&lt;/code&gt; with key equivalent to the key of an element from &lt;code&gt;source&lt;/code&gt;, then that element is not extracted from &lt;code&gt;source&lt;/code&gt;. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;. Iterators referring to the transferred elements and all iterators referring to &lt;code&gt;*this&lt;/code&gt; are invalidated. Iterators to elements remaining in &lt;code&gt;source&lt;/code&gt; remain valid.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 의 각 요소를 추출 ( &quot;splice&quot;) 하여 해시 함수 및 &lt;code&gt;*this&lt;/code&gt; 의 키 등호 술어를 사용하여 &lt;code&gt;*this&lt;/code&gt; 에 삽입하려고 합니다 . 의 요소가있는 경우 &lt;code&gt;*this&lt;/code&gt; 에서 요소의 키에 해당하는 키 &lt;code&gt;source&lt;/code&gt; 이어서, 소자로부터 추출되지 않도록 &lt;code&gt;source&lt;/code&gt; . 요소가 복사되거나 이동되지 않으며 컨테이너 노드의 내부 포인터 만 재 지정됩니다. 전송 된 요소에 대한 모든 포인터 및 참조는 계속 유효하지만 이제 &lt;code&gt;source&lt;/code&gt; 가 아닌 &lt;code&gt;*this&lt;/code&gt; 를 참조하십시오 . 전송 된 요소를 참조하는 반복자 및 &lt;code&gt;*this&lt;/code&gt; 를 참조하는 모든 반복자무효화되었습니다. &lt;code&gt;source&lt;/code&gt; 남아 있는 요소에 대한 반복자 는 유효합니다.</target>
        </trans-unit>
        <trans-unit id="92bc4254a3b00d301ffc057c9e050501ca173c4b" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex for the calling thread without blocking. If ownership is not obtained, returns immediately. The function is allowed to spuriously fail and return even if the mutex is not currently owned by another thread.</source>
          <target state="translated">차단하지 않고 호출 스레드에 대한 뮤텍스의 독점 소유권을 얻으려고 시도합니다. 소유권을 얻지 못하면 즉시 반환합니다. 뮤텍스가 현재 다른 스레드에 의해 소유되지 않은 경우에도 함수는 허위로 실패하고 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d99e4cbad6e4e7caa7d20dc148d4b12dfad9de6" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex within the duration specified by &lt;code&gt;duration&lt;/code&gt;. If &lt;code&gt;duration&lt;/code&gt; is less or equal &lt;code&gt;duration.zero()&lt;/code&gt;, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;duration&lt;/code&gt; passes. It returns within &lt;code&gt;duration&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time during &lt;code&gt;duration&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">시도에 의해 지정된 기간 내에 뮤텍스의 독점 소유권을 얻기 위해 &lt;code&gt;duration&lt;/code&gt; . 경우 &lt;code&gt;duration&lt;/code&gt; 작거나 같은 &lt;code&gt;duration.zero()&lt;/code&gt; , 시도 잠그지 않고 소유권을 얻었다 (기준 것처럼 &lt;code&gt;try_lock()&lt;/code&gt; ). 그렇지 않으면이 함수는 뮤텍스가 획득 될 때까지 또는 &lt;code&gt;duration&lt;/code&gt; 시간으로 지정된 시간 이 지날 때까지 차단됩니다 . 성공한 경우에만 &lt;code&gt;duration&lt;/code&gt; 내에 리턴 되지만 &lt;code&gt;duration&lt;/code&gt; 동안 특정 시점에서 다른 스레드가 소유하지 않은 경우에도 뮤텍스를 획득 하지 못했습니다. 어쨌든 뮤텍스가 획득되면 &lt;code&gt;true&lt;/code&gt; 를, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80bd748efa455b573b135d3617ebfa1fd13b34d8" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex within the time left until &lt;code&gt;time_point&lt;/code&gt;. If &lt;code&gt;time_point&lt;/code&gt; already passed, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;time_point&lt;/code&gt; passes. It returns before &lt;code&gt;time_point&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time before &lt;code&gt;time_point&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;time_point&lt;/code&gt; 까지 남은 시간 내에 뮤텍스의 독점 소유권을 얻으려고 시도합니다 . &lt;code&gt;time_point&lt;/code&gt; 가 이미 통과 된 경우 , 잠금없이 소유권을 얻으려고 시도합니다 ( &lt;code&gt;try_lock()&lt;/code&gt; 의한 것처럼 ). 그렇지 않으면이 함수는 뮤텍스가 획득 될 때까지 또는 &lt;code&gt;time_point&lt;/code&gt; 에 의해 지정된 시간이 지날 때까지 차단됩니다 . 성공한 경우에만 &lt;code&gt;time_point&lt;/code&gt; 이전에 리턴 되지만 &lt;code&gt;time_point&lt;/code&gt; 이전의 특정 시점에서 다른 스레드가 소유하지 않은 경우에도 뮤텍스를 획득 하지 못했습니다. 어쨌든 뮤텍스가 획득되면 &lt;code&gt;true&lt;/code&gt; 를, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fb190dc6b50cac16e4189df447478fcf3a9d392" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex for the calling thread without blocking. If ownership is not obtained, returns immediately. The function is allowed to spuriously fail and return even if the mutex is not currently owned by any threads in any mode.</source>
          <target state="translated">차단하지 않고 호출 스레드에 대한 뮤텍스의 공유 소유권을 얻으려고합니다. 소유권을 얻지 못하면 즉시 반환합니다. 어떤 모드에서든 스레드가 뮤텍스를 소유하고 있지 않더라도 함수는 허위로 실패하고 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1ab0535323ac87b863427dcfd803c52e2e71c97" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex within the duration specified by &lt;code&gt;duration&lt;/code&gt;. If &lt;code&gt;duration&lt;/code&gt; is less or equal &lt;code&gt;duration.zero()&lt;/code&gt;, attempts to obtain the ownership without waiting (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;duration&lt;/code&gt; passes. It returns within &lt;code&gt;duration&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time during &lt;code&gt;duration&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">시도에 의해 지정된 기간 내에 뮤텍스의 공유 소유권 얻기 위해 &lt;code&gt;duration&lt;/code&gt; . 경우 &lt;code&gt;duration&lt;/code&gt; 작거나 같은 &lt;code&gt;duration.zero()&lt;/code&gt; , 시도 기다리지 않고 소유권을 획득하는 (가 것처럼 &lt;code&gt;try_lock()&lt;/code&gt; ). 그렇지 않으면이 함수는 뮤텍스가 획득 될 때까지 또는 &lt;code&gt;duration&lt;/code&gt; 시간으로 지정된 시간 이 지날 때까지 차단됩니다 . 성공한 경우에만 &lt;code&gt;duration&lt;/code&gt; 내에 리턴 되지만 &lt;code&gt;duration&lt;/code&gt; 동안 특정 시점에서 다른 스레드가 소유하지 않은 경우에도 뮤텍스를 획득 하지 못했습니다. 어쨌든 뮤텍스가 획득되면 &lt;code&gt;true&lt;/code&gt; 를, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e1b61606843aa888af598e0c261d938b302f15a" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex within the time left until &lt;code&gt;time_point&lt;/code&gt;. If &lt;code&gt;time_point&lt;/code&gt; already passed, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;time_point&lt;/code&gt; passes. It returns before &lt;code&gt;time_point&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time before &lt;code&gt;time_point&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;time_point&lt;/code&gt; 까지 남은 시간 내에 뮤텍스의 공유 소유권을 얻으려고 시도합니다 . &lt;code&gt;time_point&lt;/code&gt; 가 이미 통과 된 경우 , 잠금없이 소유권을 얻으려고 시도합니다 ( &lt;code&gt;try_lock()&lt;/code&gt; 의한 것처럼 ). 그렇지 않으면이 함수는 뮤텍스가 획득 될 때까지 또는 &lt;code&gt;time_point&lt;/code&gt; 에 의해 지정된 시간이 지날 때까지 차단됩니다 . 성공한 경우에만 &lt;code&gt;time_point&lt;/code&gt; 이전에 리턴 되지만 &lt;code&gt;time_point&lt;/code&gt; 이전의 특정 시점에서 다른 스레드가 소유하지 않은 경우에도 뮤텍스를 획득 하지 못했습니다. 어쨌든 뮤텍스가 획득되면 &lt;code&gt;true&lt;/code&gt; 를, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="52d6b2b14e6e6fe30ee7f8d64fe95f33b5f6832a" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;&lt;code&gt;d&lt;/code&gt;, interpreted as the time of day since midnight, according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">시도 입력 스트림 파싱 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; 포맷 스트링에있어서, 자정 이후 하루의 시간으로 해석 &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="376efd8a04cc4bbd4dec0c37c8f77d83f331d150" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::day&lt;/code&gt;&lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">시도 입력 스트림 파싱 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;std::chrono::day&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ca1a9386d370561e811dd985b14a1c196b3e9e6" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::month&lt;/code&gt;&lt;code&gt;m&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">시도 입력 스트림 파싱 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;std::chrono::month&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40506d7d67c8bce66782b683f245a3f3fdf40954" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::month_day&lt;/code&gt;&lt;code&gt;md&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">입력 스트림을 파싱하기위한 시도 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;std::chrono::month_day&lt;/code&gt; &lt;code&gt;md&lt;/code&gt; 포맷 스트링에있어서 &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40de5b5311f786d5adb9ba2992f4f537c57266b8" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::weekday&lt;/code&gt;&lt;code&gt;wd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">입력 스트림을 파싱하기위한 시도 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;std::chrono::weekday&lt;/code&gt; &lt;code&gt;wd&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c5714af52ba60c907aab16771ef9fc12f5e61b9" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year&lt;/code&gt;&lt;code&gt;y&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">시도 입력 스트림 파싱 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;std::chrono::year&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40c30b9ec9cc1fd3faebf2fb9fdfd4762f1dbc0a" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year_month&lt;/code&gt;&lt;code&gt;ym&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">입력 스트림을 파싱하기위한 시도 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;std::chrono::year_month&lt;/code&gt; &lt;code&gt;ym&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca0d091ecc65883512fa43e7446c9c5bb23b7dda" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year_month_day&lt;/code&gt;&lt;code&gt;ymd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">입력 스트림을 파싱하기위한 시도 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;std::chrono::year_month_day&lt;/code&gt; &lt;code&gt;ymd&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31bf10609fbb5d90b5c351b1efc2680a881a160b" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the time point &lt;code&gt;tp&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">시도 입력 스트림 파싱 &lt;code&gt;is&lt;/code&gt; 시점으로 &lt;code&gt;tp&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80ba342b8785a08804a333bbfedec341d6d1c9c0" translate="yes" xml:space="preserve">
          <source>Attempts to raise all floating point exceptions listed in &lt;code&gt;excepts&lt;/code&gt; (a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;). If one of the exceptions is &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt;, this function may additionally raise &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;. The order in which the exceptions are raised is unspecified, except that &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; are always raised before &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시도에 나열된 모든 부동 소수점 예외 올리는 &lt;code&gt;excepts&lt;/code&gt; (또는의 비트 &lt;a href=&quot;fe_exceptions&quot;&gt;부동 소수점 예외 매크로&lt;/a&gt; ). 예외 중 하나가 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; 이면이 함수는 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 를 추가로 발생시킬 수 있습니다 . &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; 가 항상 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 전에 발생 한다는 점을 제외하고 예외가 발생하는 순서는 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="a902057674f85199d3ac1499e38efca7a4896e56" translate="yes" xml:space="preserve">
          <source>Attribute declaration (&lt;a href=&quot;attributes&quot;&gt;attr&lt;/a&gt;&lt;code&gt;;&lt;/code&gt;) (since C++11)</source>
          <target state="translated">속성 선언 ( &lt;a href=&quot;attributes&quot;&gt;attr &lt;/a&gt; &lt;code&gt;;&lt;/code&gt; ) (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="73fed77350865417033e78f8ec9ca2448d835567" translate="yes" xml:space="preserve">
          <source>Attribute list</source>
          <target state="translated">속성 목록</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="fad8ef5207a6faf8cf0a093eff47035c565b35b8" translate="yes" xml:space="preserve">
          <source>Attributes for &lt;a href=&quot;language/enum&quot;&gt;enumerators&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;language/enum&quot;&gt;열거 자에&lt;/a&gt; 대한 속성</target>
        </trans-unit>
        <trans-unit id="c24797e2f08fead2ed265ebddf05756fe163fa39" translate="yes" xml:space="preserve">
          <source>Attributes for &lt;a href=&quot;language/namespace&quot;&gt;namespaces&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;language/namespace&quot;&gt;네임 스페이스의&lt;/a&gt; 속성</target>
        </trans-unit>
        <trans-unit id="24a93aad8da8b2ecc0fb62d3635f7bcad0973aee" translate="yes" xml:space="preserve">
          <source>Attributes provide the unified standard syntax for implementation-defined language extensions, such as the GNU and IBM language extensions &lt;code&gt;__attribute__((...))&lt;/code&gt;, Microsoft extension &lt;code&gt;__declspec()&lt;/code&gt;, etc.</source>
          <target state="translated">속성은 GNU 및 IBM 언어 확장 &lt;code&gt;__attribute__((...))&lt;/code&gt; , Microsoft 확장 &lt;code&gt;__declspec()&lt;/code&gt; 등과 같은 구현 정의 언어 확장에 대한 통합 표준 구문을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="35d5b17890aadedb8aadfe40da01d18e88c0f170" translate="yes" xml:space="preserve">
          <source>Average case O(N), worst case O(N*size()+N), where N is &lt;code&gt;source.size()&lt;/code&gt;.</source>
          <target state="translated">평균 사례 O (N), 최악의 경우 O (N * size () + N). 여기서 N은 &lt;code&gt;source.size()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca02a8758f4a48f9665324811a74024dd77f1084" translate="yes" xml:space="preserve">
          <source>Average case linear in the number of elements with the key &lt;code&gt;key&lt;/code&gt;, worst case linear in the size of the container.</source>
          <target state="translated">키 &lt;code&gt;key&lt;/code&gt; 가있는 요소 수의 평균 대소 문자 선형 , 컨테이너 크기의 경우 최악의 경우 선형.</target>
        </trans-unit>
        <trans-unit id="500ca2374c6717aa20d965b6fb6566e425ffa363" translate="yes" xml:space="preserve">
          <source>Average case linear in the size of the container, worst case quadratic.</source>
          <target state="translated">컨테이너의 크기에서 평균 사례는 선형이며 최악의 경우 2 차입니다.</target>
        </trans-unit>
        <trans-unit id="0cf15213abbcf806e052466023c496d374b93c5e" translate="yes" xml:space="preserve">
          <source>Average case: constant, worst case: linear in size.</source>
          <target state="translated">평균 사례 : 일정, 최악의 경우 : 선형 크기.</target>
        </trans-unit>
        <trans-unit id="c69ec73023882fcdb14f4029c8b28967cb6b9150" translate="yes" xml:space="preserve">
          <source>Average number of elements per bucket.</source>
          <target state="translated">버킷 당 평균 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="5af1300096bdfebd096b49bf84d70a955eb1b7f9" translate="yes" xml:space="preserve">
          <source>Avoiding implicit copy assignment.</source>
          <target state="translated">암시 적 사본 할당 방지</target>
        </trans-unit>
        <trans-unit id="8c40560d40ca8b01a27ce21af51b6bb3a0aa5d77" translate="yes" xml:space="preserve">
          <source>Avoiding implicit generation of the copy constructor.</source>
          <target state="translated">복사 생성자의 암시 적 생성을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="55a6c927298fd43f61b985a13d7c9627855c38d0" translate="yes" xml:space="preserve">
          <source>Avoiding implicit move assignment.</source>
          <target state="translated">암시 적 이동 할당 방지</target>
        </trans-unit>
        <trans-unit id="21e51124dadde6f26a27f5ade3d091ebb552a9a3" translate="yes" xml:space="preserve">
          <source>Avoiding implicit move constructor.</source>
          <target state="translated">암시 적 이동 생성자를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="4c39141080123158d56211e39765a42a9728de5f" translate="yes" xml:space="preserve">
          <source>B 2) A</source>
          <target state="translated">B 2) A</target>
        </trans-unit>
        <trans-unit id="62706ba741ba699cbebde8104c0834806fb26022" translate="yes" xml:space="preserve">
          <source>B 3) A</source>
          <target state="translated">B 3) A</target>
        </trans-unit>
        <trans-unit id="0a1b08f2698d8eaa357ae4e4639ab5964829b92d" translate="yes" xml:space="preserve">
          <source>B 4) A</source>
          <target state="translated">B 4) A</target>
        </trans-unit>
        <trans-unit id="fc28f53619db61ee68c4c2b6467d93002c47863a" translate="yes" xml:space="preserve">
          <source>B and A appears before Y in the Single Total Order</source>
          <target state="translated">단일 총 주문에서 B와 A가 Y 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="403422f66cba2adadb0da593596292864fb30e29" translate="yes" xml:space="preserve">
          <source>B within thread 1 and C is</source>
          <target state="translated">스레드 1 내의 B와 C는</target>
        </trans-unit>
        <trans-unit id="4e54499211164f4b65d4e8324b3d4ca2593386d6" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order, then B observes either:</source>
          <target state="translated">B와 X가 단일 총 주문에서 Y 앞에 나타나면 B는 다음 중 하나를 관찰합니다.</target>
        </trans-unit>
        <trans-unit id="45e5662cbbb3c35284b81863cd8050953ac79093" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order.</source>
          <target state="translated">B와 X는 단일 총 주문에서 Y 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a4bf1b75c4f0c15c46e32fb9f6447c95ca649c7c" translate="yes" xml:space="preserve">
          <source>B, and both A and B are sequentially consistent atomic operations 3) A is</source>
          <target state="translated">B, A와 B 모두 순차적으로 일관된 원자 연산입니다. 3) A</target>
        </trans-unit>
        <trans-unit id="f4bf2b61e8848faddd0e0998dfeaa5d79d2e597c" translate="yes" xml:space="preserve">
          <source>B, then A appears to be evaluated before B in all contexts.</source>
          <target state="translated">B이면 A는 모든 상황에서 B보다 먼저 평가되는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="cd0adbaaff060b07baf50fd24c9446ab105890da" translate="yes" xml:space="preserve">
          <source>B, then A precedes B in S 2) for every pair of atomic operations A and B on an object M, where A is</source>
          <target state="translated">B, 그런 다음 A는 객체 M의 원자 연산 A와 B의 모든 쌍에 대해 S 2에서 B보다 우선합니다. 여기서 A는</target>
        </trans-unit>
        <trans-unit id="b23fad0d216b95f70509ee04aeb30c3631070eb7" translate="yes" xml:space="preserve">
          <source>B, then B observes one of the following:</source>
          <target state="translated">B이면 B는 다음 중 하나를 관찰합니다.</target>
        </trans-unit>
        <trans-unit id="bfcc02cf7f3d23e187eac12bb5d9ac766d223025" translate="yes" xml:space="preserve">
          <source>B. Stroustrup (2000), &quot;The C++ Programming Language&quot;&lt;a href=&quot;http://stroustrup.com/3rd_safe.pdf&quot;&gt;Appendix E&quot;&lt;/a&gt;</source>
          <target state="translated">B. Stroustrup (2000), &quot;C ++ 프로그래밍 언어&quot; &lt;a href=&quot;http://stroustrup.com/3rd_safe.pdf&quot;&gt;부록 E &quot;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c1a4c571996703e3e33bba826b70616b63fd77ac" translate="yes" xml:space="preserve">
          <source>B...</source>
          <target state="translated">B...</target>
        </trans-unit>
        <trans-unit id="56809777eee50fda776cf36fcf8f615216fd8cfd" translate="yes" xml:space="preserve">
          <source>B: a) if A and B are both &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, then A precedes B in S b) if A is a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation, and B</source>
          <target state="translated">B : a) A와 B가 모두 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 연산 인 경우 A가 S에서 B보다 우선합니다. b) A가 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 연산 인 경우 B</target>
        </trans-unit>
        <trans-unit id="90973d18393c2644dbda93e71ed88917ecac4b89" translate="yes" xml:space="preserve">
          <source>BLAS-like slice of a valarray: starting index, length, stride</source>
          <target state="translated">valarray의 BLAS와 같은 슬라이스 : 시작 인덱스, 길이, 보폭</target>
        </trans-unit>
        <trans-unit id="6909406a48bd13f476c9416147defba89909eee5" translate="yes" xml:space="preserve">
          <source>BUFSIZ</source>
          <target state="translated">BUFSIZ</target>
        </trans-unit>
        <trans-unit id="1afefdad8f394c65ed6d000a865d699a38489c6f" translate="yes" xml:space="preserve">
          <source>Bad address</source>
          <target state="translated">잘못된 주소</target>
        </trans-unit>
        <trans-unit id="100269e198b12a051ab659ff66bd324a08031278" translate="yes" xml:space="preserve">
          <source>Bad file descriptor</source>
          <target state="translated">잘못된 파일 설명자</target>
        </trans-unit>
        <trans-unit id="551cd91c11cd1216214e9eb9e26d84be076f8948" translate="yes" xml:space="preserve">
          <source>Bad message</source>
          <target state="translated">나쁜 메시지</target>
        </trans-unit>
        <trans-unit id="6bda91ea312720b2ec09940e98682034dcace7af" translate="yes" xml:space="preserve">
          <source>Barebones valarray-backed Matrix class with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_(linear_algebra)&quot;&gt;trace&lt;/a&gt; calculating function.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_(linear_algebra)&quot;&gt;트레이스&lt;/a&gt; 계산 기능을 갖춘 Barebones valarray-backed Matrix 클래스 .</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="3bcdbe728e1760eac3fdacb54d72efd9ba89bbaa" translate="yes" xml:space="preserve">
          <source>Base specifiers and member initializer lists</source>
          <target state="translated">기본 지정자와 멤버 이니셜 라이저 목록</target>
        </trans-unit>
        <trans-unit id="b1604e75055b78b9111dd5b59253504e535b02f2" translate="yes" xml:space="preserve">
          <source>Base::vf (whether or not the word &lt;code&gt;override&lt;/code&gt; is used in its declaration).</source>
          <target state="translated">Base :: vf (단어 &lt;code&gt;override&lt;/code&gt; 가 선언에 사용 되는지 여부 )</target>
        </trans-unit>
        <trans-unit id="5899059fb2d20a463b2a04266836e60a1b0645c6" translate="yes" xml:space="preserve">
          <source>BaseCharacteristic</source>
          <target state="translated">BaseCharacteristic</target>
        </trans-unit>
        <trans-unit id="aa2c96dacf00c451ef465f6115a45a20bccf1256" translate="yes" xml:space="preserve">
          <source>Basic</source>
          <target state="translated">Basic</target>
        </trans-unit>
        <trans-unit id="e4e7ae591b0abd861a75d3fa39a7cab907d2a5c8" translate="yes" xml:space="preserve">
          <source>Basic concepts</source>
          <target state="translated">기본 개념</target>
        </trans-unit>
        <trans-unit id="1dda37dbdb1d5ae832ec94dde2b8248f41206b6f" translate="yes" xml:space="preserve">
          <source>Basic exception guarantee</source>
          <target state="translated">기본 예외 보증</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">기본 조작</target>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="928b9aad5c0144f195e57231e11400d2c46ac0fb" translate="yes" xml:space="preserve">
          <source>Basic types (e.g. &lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;), RTTI (e.g. &lt;code&gt;&lt;a href=&quot;types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt;), type traits (e.g. &lt;code&gt;&lt;a href=&quot;types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;types/rank&quot;&gt;std::rank&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">기본 유형 (예 : &lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; ), RTTI (예 : &lt;code&gt;&lt;a href=&quot;types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; ), 유형 특성 (예 : &lt;code&gt;&lt;a href=&quot;types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;types/rank&quot;&gt;std::rank&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5c2ef712eeb88ff3db947441935726076c82c0bb" translate="yes" xml:space="preserve">
          <source>BasicLockable</source>
          <target state="translated">BasicLockable</target>
        </trans-unit>
        <trans-unit id="90870ca4432acfd7b541273fcb2661e871119daf" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; does not consider implicit conversions, these operators cannot be used for mixed integer/complex arithmetic. In all cases, the scalar must have the same type as the underlying type of the complex number.</source>
          <target state="translated">&lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;템플릿 인수 추론&lt;/a&gt; 은 암시 적 변환을 고려하지 않기 때문에이 연산자는 정수 / 복합 혼합 산술에 사용할 수 없습니다. 모든 경우에 스칼라는 복소수의 기본 유형과 유형이 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="d1f6ad19289944156463986759f118c4be88ae5a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; requires that the pointed-to type is a complete type in any context where the deleter is called, the destructor and the copy/move assignment operators must be user-declared and defined out-of-line, in the implementation file, where the implementation class is complete. This suppresses the move constructor, which has to be defined or defaulted.</source>
          <target state="translated">때문에 &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 필요하다는 지적-에 유형은 Deleter가 호출되는 모든 상황에서 완전한 형태, 소멸자 및 대입 연산자는 사용자가 선언 아웃 - 오브 - 라인을 정의해야합니다 복사 / 이동은, 구현에 파일, 구현 클래스가 완료되었습니다. 이것은 이동 생성자를 억제하며, 이는 정의되거나 기본값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ee2e8f20b5463733118ed9ad438d1e579dcd6096" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;assert&lt;/code&gt; is a &lt;a href=&quot;../preprocessor/replace&quot;&gt;function-like macro&lt;/a&gt;, commas anywhere in condition that are not protected by parentheses are interpreted as macro argument separators. Such commas are often found in template argument lists and list-initialization:</source>
          <target state="translated">때문에 &lt;code&gt;assert&lt;/code&gt; A는 &lt;a href=&quot;../preprocessor/replace&quot;&gt;함수가 같은 매크로&lt;/a&gt; 어디서나 매크로 인수 구분 기호로 해석됩니다 괄호로 보호되지 않은 상태에서 쉼표. 이러한 쉼표는 종종 템플릿 인수 목록 및 목록 초기화에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53424f213e903d21acf1145501cd3bd319bc65a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;regex_match&lt;/code&gt; only considers full matches, the same regex may give different matches between &lt;code&gt;regex_match&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;regex_match&lt;/code&gt; 는 전체 일치 만 고려 하기 때문에 동일한 정규 표현식이 &lt;code&gt;regex_match&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; 간에 다른 일치를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c2c9164d9adc62f94d817ac748a2112477652ed" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;setlocale&lt;/code&gt; modifies global state which affects execution of locale-dependent functions, it is undefined behavior to call it from one thread, while another thread is executing any of the following functions: &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isprint&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;std::iswdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;std::localeconv&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::tolower&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ispunct&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;std::iswgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;std::mblen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::toupper&lt;/code&gt;, &lt;code&gt;std::isalnum&lt;/code&gt;, &lt;code&gt;std::isspace&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;std::iswlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;std::mbstowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;std::towlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isalpha&lt;/code&gt;, &lt;code&gt;std::isupper&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;std::iswprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;std::towupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isblank&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;std::iswalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;std::iswpunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::setlocale&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::iscntrl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;std::iswalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;std::iswspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isdigit&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;std::iswblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;std::iswupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;std::wcstombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isgraph&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;std::iswcntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;std::wcsxfrm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::islower&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;std::iswctype&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isxdigit&lt;/code&gt;.</source>
          <target state="translated">때문에 &lt;code&gt;setlocale&lt;/code&gt; 에 로케일 종속 함수의 실행에 영향을 수정 전역 상태, 그것이 정의되지 않은 동작들이 다른 스레드는 다음 기능을 실행하는 동안, 하나 개의 스레드에서 호출한다 : &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isprint&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;std::iswdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;std::localeconv&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::tolower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ispunct&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;std::iswgraph&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;std::mblen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::toupper&lt;/code&gt; , &lt;code&gt;std::isalnum&lt;/code&gt; , &lt;code&gt;std::isspace&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;std::iswlower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;std::mbstowcs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;std::towlower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isalpha&lt;/code&gt; , &lt;code&gt;std::isupper&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;std::iswprint&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;std::towupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isblank&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;std::iswalnum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;std::iswpunct&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::setlocale&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::iscntrl&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;std::iswalpha&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;std::iswspace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isdigit&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;std::iswblank&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;std::iswupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;std::wcstombs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isgraph&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;std::iswcntrl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;std::wcsxfrm&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::islower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;std::iswctype&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isxdigit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89d8571118516caef2a1d25c02e79eb519ae1beb" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;std::remove&lt;/code&gt; takes &lt;code&gt;value&lt;/code&gt; by reference, it can have unexpected behavior if it is a reference to an element of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">왜냐하면 &lt;code&gt;std::remove&lt;/code&gt; 소요 &lt;code&gt;value&lt;/code&gt; 참조하여 그 범위의 요소에 대한 참조하면, 예기치 않은 동작을 가질 수 &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20471d58e5d2833a1993c6fb0cc59d825025d821" translate="yes" xml:space="preserve">
          <source>Because C++ copies and copy-assigns objects of user-defined types in various situations (passing/returning by value, manipulating a container, etc), these special member functions will be called, if accessible, and if they are not user-defined, they are implicitly-defined by the compiler.</source>
          <target state="translated">C ++은 다양한 상황 (값으로 전달 / 반환, 컨테이너 조작 등)에서 사용자 정의 유형의 객체를 복사 및 복사 할 수 있으므로 이러한 특수 멤버 함수는 액세스 가능하고 사용자 정의되지 않은 경우 호출됩니다. 그것들은 컴파일러에 의해 암시 적으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="517acf744121042d5f84823be03eeb3b29badaed" translate="yes" xml:space="preserve">
          <source>Because C++ interprets a character immediately following a string literal as a &lt;a href=&quot;../language/user_literal&quot;&gt;user-defined string literal&lt;/a&gt;, C code such as &lt;code&gt;printf(&quot;%&quot;PRId64&quot;\n&quot;,n);&lt;/code&gt; is invalid C++ and requires a space before &lt;code&gt;PRId64&lt;/code&gt;.</source>
          <target state="translated">C ++는 문자열 리터럴 바로 다음의 문자를 &lt;a href=&quot;../language/user_literal&quot;&gt;사용자 정의&lt;/a&gt; 문자열 리터럴로 해석 하므로 &lt;code&gt;printf(&quot;%&quot;PRId64&quot;\n&quot;,n);&lt;/code&gt; 유효하지 않은 C ++이며 &lt;code&gt;PRId64&lt;/code&gt; 앞에 공백이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="219e7d89011a786888d2482ec713003b1ecb5238" translate="yes" xml:space="preserve">
          <source>Because POSIX uses &quot;leftmost longest&quot; matching rule (the longest matching subsequence is matched, and if there are several such subsequences, the first one is matched), it is not suitable, for example, for parsing markup languages: a POSIX regex such as &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; would match everything from the first &lt;code&gt;&quot;&amp;lt;tag&quot;&lt;/code&gt; to the last &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt;, including every &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;lt;tag&amp;gt;&quot;&lt;/code&gt; inbetween. On the other hand, ECMAScript supports non-greedy matches, and the ECMAScript regex &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*?&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; would match only until the first closing tag.</source>
          <target state="translated">POSIX는 &quot;가장 긴 가장 긴&quot;일치 규칙 (가장 긴 일치하는 하위 시퀀스가 ​​일치하고 이러한 하위 시퀀스가 ​​여러 개있는 경우 첫 번째가 일치하는 경우)을 사용하므로 예를 들어 마크 업 언어 구문 분석에 적합하지 않습니다. POSIX 정규식 (예 : &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; 는 모든 &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;&amp;lt;tag&amp;gt;&quot;&lt;/code&gt; 를 포함 하여 첫 번째 &lt;code&gt;&quot;&amp;lt;tag&quot;&lt;/code&gt; 에서 마지막 &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; 까지 모든 항목과 일치합니다. 사이. 반면 ECMAScript는 욕심없는 일치를 지원하며 ECMAScript 정규식 &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*?&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; 는 첫 번째 닫기 태그까지만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b08396994d212dfe6289df9ec245e89c348fd76a" translate="yes" xml:space="preserve">
          <source>Because a pair of brackets following the keyword &lt;code&gt;delete&lt;/code&gt; is always interpreted as the array form of delete, a lambda-expression with empty capture list immediately after &lt;code&gt;delete&lt;/code&gt; must be enclosed in parentheses.</source>
          <target state="translated">키워드 다음 괄호 한 쌍 때문에 &lt;code&gt;delete&lt;/code&gt; 항상 삭제의 배열 형식으로 해석됩니다 직후 빈 캡처 목록 람다 표현 &lt;code&gt;delete&lt;/code&gt; 괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="672ca8a2390d44e9109a5b0f60fc6036a7a4d8de" translate="yes" xml:space="preserve">
          <source>Because a temporary copy of the object is constructed during post-increment and post-decrement,</source>
          <target state="translated">사후 증가 및 사후 감소 동안 오브젝트의 임시 사본이 구성되므로,</target>
        </trans-unit>
        <trans-unit id="52aa0f31213848ac5fabf7dcecdd2f55a132ed32" translate="yes" xml:space="preserve">
          <source>Because array elements cannot have incomplete type, multidimensional arrays cannot have unknown bound in a dimension other than the first:</source>
          <target state="translated">배열 요소는 불완전한 유형을 가질 수 없으므로 다차원 배열은 첫 번째 차원 이외의 차원에서 알 수없는 경계를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ebfd5a82361d89ed63a37a3062866f4e78777689" translate="yes" xml:space="preserve">
          <source>Because bit fields do not necessarily begin at the beginning of a byte, address of a bit field cannot be taken. Pointers and non-const references to bit fields are not possible. When &lt;a href=&quot;reference_initialization&quot;&gt;initializing a const reference&lt;/a&gt; from a bit field, a temporary is created (its type is the type of the bit field), copy initialized with the value of the bit field, and the reference is bound to that temporary.</source>
          <target state="translated">비트 필드는 반드시 바이트의 시작 부분에서 시작하지 않아도되므로 비트 필드의 주소를 가져올 수 없습니다. 비트 필드에 대한 포인터 및 비 콘스탄트 참조는 불가능합니다. 비트 필드에서 &lt;a href=&quot;reference_initialization&quot;&gt;const 참조&lt;/a&gt; 를 초기화 할 때 임시가 작성되고 (유형은 비트 필드의 유형 임) 비트 필드의 값으로 초기화 된 사본이 참조가 해당 임시에 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="165915841c598e436e4f4ef5949ddbdf66094494" translate="yes" xml:space="preserve">
          <source>Because both &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; are constant iterators (and may in fact be the same type), it is not possible to mutate the elements of the container through an iterator returned by any of these member functions.</source>
          <target state="translated">왜냐하면 두 &lt;code&gt;iterator&lt;/code&gt; 와 &lt;code&gt;const_iterator&lt;/code&gt; 상수 반복자있는 (실제로 동일한 유형일 수있다), 이들 부재의 기능 중 하나에 의해 반환 반복자 통해 용기의 요소를 돌연변이시킬 수 없다.</target>
        </trans-unit>
        <trans-unit id="b5ebf1a72c58aab22e302945eaa39d0cb80ef7c4" translate="yes" xml:space="preserve">
          <source>Because comments &lt;a href=&quot;language/translation_phases&quot;&gt;are removed&lt;/a&gt; before the preprocessor stage, a macro cannot be used to form a comment and an unterminated C-style comment doesn't spill over from an #include'd file.</source>
          <target state="translated">전 처리기 단계 전에 주석 &lt;a href=&quot;language/translation_phases&quot;&gt;이 제거&lt;/a&gt; 되므로 매크로를 사용하여 주석을 구성 할 수 없으며 종료되지 않은 C 스타일 주석이 # include'd 파일에서 넘겨지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8283f8b80380fa4e852889799ea8ad590ba8476b" translate="yes" xml:space="preserve">
          <source>Because condition #2 is tested before condition #3, the input line that exactly fits the buffer does not trigger failbit.</source>
          <target state="translated">조건 # 2는 조건 # 3보다 먼저 테스트되므로 버퍼에 정확히 맞는 입력 라인은 페일 비트를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="515369749f5f51688eb83df1f7be779be9524043" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::domain_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">&lt;code&gt;std::domain_error&lt;/code&gt; 복사 하면 예외가 발생하지 않으므로이 메시지는 일반적으로 내부적으로 별도로 할당 된 참조 횟수 문자열로 저장됩니다. &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; 생성자가없는 이유이기도 합니다. 어쨌든 내용을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ecb376ab21a6f256feb79f178105c51676d0d60" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::exception&lt;/code&gt; is not permitted to throw exceptions, when derived classes (such as &lt;code&gt;&lt;a href=&quot;../runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt;) have to manage a user-defined diagnostic message, it is typically implemented as a copy-on-write string.</source>
          <target state="translated">&lt;code&gt;std::exception&lt;/code&gt; 복사 는 예외 를 처리 할 수 ​​없으므로 파생 클래스 ( &lt;code&gt;&lt;a href=&quot;../runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; 와 같은 )가 사용자 정의 진단 메시지를 관리해야하는 경우 일반적으로 COW ( Copy-On-Write) 문자열로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="3da5bbc4235f4c93a80ce50bc387f0b13711c29a" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::invalid_argument&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">&lt;code&gt;std::invalid_argument&lt;/code&gt; 복사 하면 예외를 처리 할 수 없으므로이 메시지는 일반적으로 내부적으로 별도로 할당 된 참조 횟수 문자열로 저장됩니다. &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; 생성자가없는 이유이기도 합니다. 어쨌든 내용을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="976f924388c6dee8de713ae69d4c65520bd93b74" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::length_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">&lt;code&gt;std::length_error&lt;/code&gt; 복사 하면 예외를 처리 할 수 없으므로이 메시지는 일반적으로 내부적으로 별도로 할당 된 참조 횟수 문자열로 저장됩니다. &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; 생성자가없는 이유이기도 합니다. 어쨌든 내용을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="d329778fe1d9574d6ed3f3facfee5d31e87476c0" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::logic_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">&lt;code&gt;std::logic_error&lt;/code&gt; 복사 하면 예외를 처리 할 수 없으므로이 메시지는 일반적으로 내부적으로 별도로 할당 된 참조 횟수 문자열로 저장됩니다. &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; 생성자가없는 이유이기도 합니다. 어쨌든 내용을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="018a393e39e3b182ca10487c347de04d186be7cb" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::out_of_range&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">&lt;code&gt;std::out_of_range&lt;/code&gt; 복사 하면 예외가 발생하지 않으므로이 메시지는 일반적으로 내부적으로 별도로 할당 된 참조 횟수 문자열로 저장됩니다. &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; 생성자가없는 이유이기도 합니다. 어쨌든 내용을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f345edfef34a7652c4a3e8c88a8d58867553acd" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::overflow_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">&lt;code&gt;std::overflow_error&lt;/code&gt; 복사 하면 예외를 처리 할 수 ​​없으므로이 메시지는 일반적으로 내부적으로 별도로 할당 된 참조 횟수 문자열로 저장됩니다. &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; 생성자가없는 이유이기도 합니다. 어쨌든 내용을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="57850b32155ea45ecb9e2f25f07c6b9ec1154de7" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::range_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">&lt;code&gt;std::range_error&lt;/code&gt; 복사 하면 예외를 처리 할 수 없으므로이 메시지는 일반적으로 내부적으로 별도로 할당 된 참조 횟수 문자열로 저장됩니다. &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; 생성자가없는 이유이기도 합니다. 어쨌든 내용을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="402cb452aa1c6e8357e1ec6173212b86a7d33f65" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::runtime_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">&lt;code&gt;std::runtime_error&lt;/code&gt; 복사 하면 예외를 처리 할 수 없으므로이 메시지는 일반적으로 내부적으로 별도로 할당 된 참조 횟수 문자열로 저장됩니다. &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; 생성자가없는 이유이기도 합니다. 어쨌든 내용을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="37068db94b3bf966577e4aa45601ece784efa76c" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::underflow_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">&lt;code&gt;std::underflow_error&lt;/code&gt; 복사 하면 예외를 처리 할 수 ​​없으므로이 메시지는 일반적으로 내부적으로 별도로 할당 된 참조 횟수 문자열로 저장됩니다. &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; 생성자가없는 이유이기도 합니다. 어쨌든 내용을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="9379074a5072b78ee4eeef2326fa80c14b76e9c1" translate="yes" xml:space="preserve">
          <source>Because copying a standard library class derived from &lt;code&gt;std::exception&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string.</source>
          <target state="translated">&lt;code&gt;std::exception&lt;/code&gt; 에서 파생 된 표준 라이브러리 클래스를 복사하면 예외 가 발생하지 않으므로이 메시지는 일반적으로 내부적으로 별도로 할당 된 참조 횟수 문자열로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7ae6e0e63afdccc5b632c5cb746027af8b35d225" translate="yes" xml:space="preserve">
          <source>Because correct C++ programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:</source>
          <target state="translated">올바른 C ++ 프로그램에는 정의되지 않은 동작이 없으므로 실제로 UB가있는 프로그램을 최적화가 활성화 된 상태로 컴파일하면 컴파일러에서 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4626ae145ee72ecf116829f511a5171a1ace5607" translate="yes" xml:space="preserve">
          <source>Because currency symbol is optional if &lt;code&gt;showbase&lt;/code&gt; is off but the entire multicharacter &lt;code&gt;negative_sign()&lt;/code&gt; is required, given the formatting pattern &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; with &lt;code&gt;showbase&lt;/code&gt; off and negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt;, the string &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; parses as &lt;code&gt;-123&lt;/code&gt; and leaves &quot;&amp;euro;&quot; unconsumed on the input stream, but if negative_sign is &lt;code&gt;&quot;()&quot;&lt;/code&gt;, the string &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; is consumed completely.</source>
          <target state="translated">&lt;code&gt;showbase&lt;/code&gt; 가 꺼져 있지만 통화 기호는 선택적 이지만 &lt;code&gt;showbase&lt;/code&gt; 가 off이고 negative_sign이 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 인 형식화 패턴 &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; 을 고려 하면 전체 다중 문자 &lt;code&gt;negative_sign()&lt;/code&gt; 이 필요한 경우 문자열 &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; 가 구문 분석됩니다. 같은 &lt;code&gt;-123&lt;/code&gt; 와 잎 &quot;&amp;euro;&quot;입력 스트림에 사용되지 않은,하지만 negative_sign을 경우 &lt;code&gt;&quot;()&quot;&lt;/code&gt; 문자열 &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; 완전히 소모됩니다.</target>
        </trans-unit>
        <trans-unit id="9c7bc26a7deccd5754905307ee4096fdff25e864" translate="yes" xml:space="preserve">
          <source>Because each &lt;code&gt;std::array&amp;lt;T, N&amp;gt;&lt;/code&gt; is a fixed-size container, the value returned by &lt;code&gt;max_size&lt;/code&gt; equals &lt;code&gt;N&lt;/code&gt; (which is also the value returned by &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">각 &lt;code&gt;std::array&amp;lt;T, N&amp;gt;&lt;/code&gt; 은 고정 크기 컨테이너이므로 &lt;code&gt;max_size&lt;/code&gt; 에 의해 리턴되는 값 은 &lt;code&gt;N&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 값이기도 함 )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1d63aeceb4f0e5680d16d7c267971930a3bce18" translate="yes" xml:space="preserve">
          <source>Because locales and facets must be available for the IO stream objects with static storage duration, such as &lt;code&gt;&lt;a href=&quot;../../../io/cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, typical implementations let implicit default constructor zero-initialize the contents of &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; during static initialization (before constructors run for static objects), and when a facet is added to any locale for the first time, the locale completes initialization of the facet's &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../../io/cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 과 같은 정적 스토리지 기간을 갖는 IO 스트림 오브젝트에 로케일 및 패싯을 사용할 수 있어야하므로 일반적인 구현에서는 암시 적 기본 생성자가 정적 초기화 중에 &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; 의 컨텐츠를 초기화하지 않습니다 (생성자가 실행되기 전에) 정적 객체의 경우), 패싯이 로케일에 처음으로 추가되면 로케일은 패싯의 &lt;code&gt;id&lt;/code&gt; 초기화를 완료 합니다.</target>
        </trans-unit>
        <trans-unit id="bad967f19eac295089f2fac67901872b755b210a" translate="yes" xml:space="preserve">
          <source>Because most conversion specifiers first consume all consecutive whitespace, code such as.</source>
          <target state="translated">대부분의 변환 지정자는 먼저 모든 연속 공백을 소비하므로 다음과 같은 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="baeb5892e67350663f292930f0546a18e00a4338" translate="yes" xml:space="preserve">
          <source>Because of argument-dependent lookup, non-member functions and non-member operators defined in the same namespace as a class are considered part of the public interface of that class (if they are found through ADL) &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;adl#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;.  ADL is the reason behind the established idiom for swapping two objects in generic code:</source>
          <target state="translated">인수 종속 조회로 인해 클래스와 동일한 네임 스페이스에 정의 된 비 멤버 함수 및 비 멤버 연산자는 해당 클래스의 공용 인터페이스의 일부로 간주됩니다 (ADL을 통해 찾은 경우) &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;adl#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; . ADL은 일반 코드에서 두 개의 객체를 교환하기 위해 설정된 관용구 뒤에있는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="e744698bc894ffd70f35015c02148587a2699846" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;implicit_cast&quot;&gt;array-to-pointer&lt;/a&gt; implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:</source>
          <target state="translated">왜냐하면의 &lt;a href=&quot;implicit_cast&quot;&gt;배열에 포인터&lt;/a&gt; 암시 적 변환, 어레이의 첫 번째 요소의 포인터는 어레이 형의 식으로 초기화 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="940a6ecf2484f5047dcbde372b969605698443fc" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;implicit_cast&quot;&gt;derived-to-base&lt;/a&gt; implicit conversion for pointers, pointer to a base class can be initialized with the address of a derived class:</source>
          <target state="translated">포인터 에 대한 &lt;a href=&quot;implicit_cast&quot;&gt;파생 된 기본&lt;/a&gt; 암시 적 변환으로 인해 파생 클래스의 주소를 사용하여 기본 클래스에 대한 포인터를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d22544963a037f06cda7296c1659e0c18ea6896" translate="yes" xml:space="preserve">
          <source>Because of the rule above, if initialization of some object &lt;code&gt;o1&lt;/code&gt; refers to an namespace-scope object &lt;code&gt;o2&lt;/code&gt;, which potentially requires dynamic initialization, but is defined later in the same translation unit, it is unspecified whether the value of &lt;code&gt;o2&lt;/code&gt; used will be the value of the fully initialized &lt;code&gt;o2&lt;/code&gt; (because the compiler promoted initialization of &lt;code&gt;o2&lt;/code&gt; to compile time) or will be the value of &lt;code&gt;o2&lt;/code&gt; merely zero-initialized.</source>
          <target state="translated">위의 규칙으로 인해 일부 객체 &lt;code&gt;o1&lt;/code&gt; 의 초기화가 네임 스페이스 범위 객체 &lt;code&gt;o2&lt;/code&gt; 를 참조하여 잠재적으로 동적 초기화가 필요하지만 나중에 동일한 변환 단위로 정의 된 경우 사용 된 &lt;code&gt;o2&lt;/code&gt; 의 값이 값인지 여부는 지정되지 않습니다 (컴파일러 가 컴파일 시간을 컴파일하기 위해 &lt;code&gt;o2&lt;/code&gt; 의 초기화를 촉진했기 때문에) 완전히 초기화 된 &lt;code&gt;o2&lt;/code&gt; 의 값이거나 단순히 0으로 초기화 된 &lt;code&gt;o2&lt;/code&gt; 의 값이 됩니다.</target>
        </trans-unit>
        <trans-unit id="f9dfa5b6f4b206c84c88479521272aa1a77080bd" translate="yes" xml:space="preserve">
          <source>Because of the side-effects involved, built-in increment and decrement operators must be used with care to avoid undefined behavior due to violations of &lt;a href=&quot;eval_order&quot;&gt;sequencing rules&lt;/a&gt;.</source>
          <target state="translated">관련된 부작용으로 인해 &lt;a href=&quot;eval_order&quot;&gt;시퀀싱 규칙&lt;/a&gt; 위반으로 인한 정의되지 않은 동작을 피하기 위해 내장 증분 및 감소 연산자를주의해서 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e487fcdc25049314ba3c1aa8b2d5bde8e083329" translate="yes" xml:space="preserve">
          <source>Because of these rules, the following function declarations declare exactly the same function:</source>
          <target state="translated">이러한 규칙으로 인해 다음 함수 선언은 정확히 동일한 함수를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="d688b7551f970383439094dc77352596d64c75aa" translate="yes" xml:space="preserve">
          <source>Because operator&amp;lt; is defined for pairs, containers of pairs can be sorted.</source>
          <target state="translated">operator &amp;lt;는 쌍으로 정의되므로 쌍의 컨테이너를 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d70357852eee5a3977fc8f45f9558148ea3110c" translate="yes" xml:space="preserve">
          <source>Because operator&amp;lt; is defined for tuples, containers of tuples can be sorted.</source>
          <target state="translated">operator &amp;lt;는 튜플에 대해 정의되므로 튜플의 컨테이너를 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9988c3b00612ee646fb4689ee722feac6456ce93" translate="yes" xml:space="preserve">
          <source>Because private data members of a class participate in its object representation, affecting size and layout, and because private member functions of a class participate in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; (which takes place before member access checking), any change to those implementation details requires recompilation of all users of the class.</source>
          <target state="translated">클래스의 개인 데이터 멤버가 크기 및 레이아웃에 영향을 미치는 객체 표현에 참여하고 클래스의 개인 멤버 함수가 &lt;a href=&quot;overload_resolution&quot;&gt;오버로드 확인&lt;/a&gt; (멤버 액세스 확인 전에 발생)에 참여하기 때문에 이러한 구현 세부 사항을 변경하려면 모든 항목을 다시 컴파일해야합니다. 수업의 사용자.</target>
        </trans-unit>
        <trans-unit id="c3b6294e7526f54f684e9230a46827a20327483e" translate="yes" xml:space="preserve">
          <source>Because reallocation may involve bytewise copying (regardless of whether it's to expand or to contract), only the objects of &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types are safe to access in the preserved part of the memory block after a call to &lt;code&gt;realloc&lt;/code&gt;.</source>
          <target state="translated">재 할당 (확장 또는 축소 여부에 관계없이) 재 할당에는 바이트 단위 복사가 포함될 수 있으므로 &lt;code&gt;realloc&lt;/code&gt; 을 호출 한 후 &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 유형 의 객체 만 메모리 블록의 보존 된 부분에 액세스하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="a7a4b66b6298eef0d24f634e1a2d845ff026b299" translate="yes" xml:space="preserve">
          <source>Because references are not objects, there are no arrays of references, no pointers to references, and no references to references:</source>
          <target state="translated">참조는 객체가 아니므로 참조 배열, 참조에 대한 포인터 및 참조에 대한 참조가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2058d826c2c292a12210fe0965fc4ca9d8da0fd" translate="yes" xml:space="preserve">
          <source>Because rvalue references can bind to xvalues, they can refer to non-temporary objects:</source>
          <target state="translated">rvalue 참조는 xvalue에 바인딩 될 수 있으므로 임시가 아닌 객체를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04759d29e77b0401f5cb7e54b5a9ccc5b0666e57" translate="yes" xml:space="preserve">
          <source>Because some assignment operator (move or copy) is always declared for any class, the base class assignment operator is always hidden. If a using-declaration is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.</source>
          <target state="translated">클래스에 대해 일부 할당 연산자 (이동 또는 복사)가 항상 선언되므로 기본 클래스 할당 연산자는 항상 숨겨져 있습니다. using-declaration을 사용하여 기본 클래스에서 할당 연산자를 가져오고 해당 인수 유형이 파생 클래스의 암시 적 할당 연산자의 인수 유형과 같을 수있는 경우 using-declaration도 암시 적으로 숨겨집니다. 선언.</target>
        </trans-unit>
        <trans-unit id="00f0a274c1ab8c40e7bb092c85aefd4a4d48b525" translate="yes" xml:space="preserve">
          <source>Because stage 2 filters out characters such as 'p', 'N' or 'i', the hexadecimal floating-point numbers such as &quot;0x1.23p-10&quot; and the strings &quot;NaN&quot; or &quot;inf&quot; may be rejected by &lt;code&gt;do_get(double)&lt;/code&gt; even if they are valid input to &lt;code&gt;strtod&lt;/code&gt;: this is &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2381&quot;&gt;LWG #2381&lt;/a&gt;.</source>
          <target state="translated">2 단계는 'p', 'N'또는 'i'와 같은 문자를 필터링하므로 &quot;0x1.23p-10&quot;및 &quot;NaN&quot;또는 &quot;inf&quot;와 같은 16 진 부동 소수점 숫자는 &lt;code&gt;do_get(double)&lt;/code&gt; 의해 거부 될 수 있습니다. (더블) 그들이에 유효한 입력 경우에도 &lt;code&gt;strtod&lt;/code&gt; 이는 &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2381&quot;&gt;2381 LWG #&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa02ffb6258aec2d2486ffca8631f59286ef5ce5" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt; operator always returns &lt;code&gt;true&lt;/code&gt; for a constant expression, it can be used to check if a particular invocation of a constexpr function takes the constant expression branch:</source>
          <target state="translated">때문에 &lt;a href=&quot;noexcept&quot;&gt;noexcept의&lt;/a&gt; 연산자는 항상 반환 &lt;code&gt;true&lt;/code&gt; 상수 식에 대한, constexpr 기능의 특정 호출이 상수 표현 가지 걸리는 경우 확인하는 데 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="13956b893efc09b160ae84ba33c1cbb13cb7bc62" translate="yes" xml:space="preserve">
          <source>Because the C++ program terminates if a destructor throws an exception during stack unwinding (which usually cannot be predicted), all practical destructors are non-throwing even if they are not declared noexcept. All destructors found in the C++ standard library are non-throwing.</source>
          <target state="translated">스택 해제 (일반적으로 예측할 수 없음) 중에 소멸자가 예외를 throw하면 C ++ 프로그램이 종료되므로 모든 실제 소멸자는 noexcept로 선언되지 않은 경우에도 던지지 않습니다. C ++ 표준 라이브러리에있는 모든 소멸자는 던지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4b14ea26ead34a1997c4a30b1317b3b91b17acb" translate="yes" xml:space="preserve">
          <source>Because the algorithm takes &lt;code&gt;old_value&lt;/code&gt; and &lt;code&gt;new_value&lt;/code&gt; by reference, it can have unexpected behavior if either is a reference to an element of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">알고리즘은 참조로 &lt;code&gt;old_value&lt;/code&gt; 및 &lt;code&gt;new_value&lt;/code&gt; 를 사용하므로 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소에 대한 참조 인 경우 예상치 못한 동작이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="265f1e5e363f13b331939f8d44a25ab55d331f5b" translate="yes" xml:space="preserve">
          <source>Because the compiler is (usually) unable to analyze the code of an external library to determine whether it does or does not perform I/O or volatile access, third-party library calls also aren't affected by optimization. However, standard library calls may be replaced by other calls, eliminated, or added to the program during optimization. Statically-linked third-party library code may be subject to link-time optimization.</source>
          <target state="translated">컴파일러는 (일반적으로) 외부 라이브러리의 코드를 분석하여 I / O 또는 휘발성 액세스를 수행하는지 여부를 결정하지 못하므로 타사 라이브러리 호출도 최적화의 영향을받지 않습니다. 그러나 표준 라이브러리 호출은 최적화 중에 다른 호출로 대체되거나 제거되거나 프로그램에 추가 될 수 있습니다. 정적으로 링크 된 타사 라이브러리 코드는 링크 타임 최적화의 대상이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f7a16168cd91eaf4c419d45869f4dbf9eb22f7c" translate="yes" xml:space="preserve">
          <source>Because the copy assignment operator is always declared for any class, the base class assignment operator is always hidden. If a &lt;a href=&quot;using_declaration#In_class_definition&quot;&gt;using-declaration&lt;/a&gt; is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.</source>
          <target state="translated">복사 할당 연산자는 모든 클래스에 대해 항상 선언되므로 기본 클래스 할당 연산자는 항상 숨겨져 있습니다. 경우 &lt;a href=&quot;using_declaration#In_class_definition&quot;&gt;사용 선언은&lt;/a&gt; 기본 클래스에서 할당 연산자 유치하는 데 사용되며, 인수 유형이 파생 클래스의 암시 적 할당 연산자의 인수의 형태와 같은 수의 사용 선언은 암시 적으로 숨겨져 있습니다 선언.</target>
        </trans-unit>
        <trans-unit id="4f97ab617bba2611157c1c18672811c19cf4fbf8" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static &lt;code&gt;std::any&lt;/code&gt;s are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use an object of type &lt;code&gt;std::any&lt;/code&gt; in a constructor of any static object.</source>
          <target state="translated">기본 생성자가 &lt;code&gt;constexpr&lt;/code&gt; 이므로 정적 &lt;code&gt;std::any&lt;/code&gt; 는 &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;로컬이&lt;/a&gt; 아닌 동적 초기화가 시작되기 전에 정적이 아닌 로컬 초기화의 일부로 초기화됩니다. 따라서 정적 객체의 생성자에 &lt;code&gt;std::any&lt;/code&gt; 유형의 객체를 사용하는 것이 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="42b540f8fad9f3f5b7e3465475a9831636bf020b" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static &lt;code&gt;weak_ptr&lt;/code&gt;s are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a weak_ptr in a constructor of any static object.</source>
          <target state="translated">기본 생성자가 &lt;code&gt;constexpr&lt;/code&gt; 이므로 정적 &lt;code&gt;weak_ptr&lt;/code&gt; 은 &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;로컬이&lt;/a&gt; 아닌 동적 초기화가 시작되기 전에 정적이 아닌 로컬 초기화의 일부로 초기화됩니다. 따라서 정적 객체의 생성자에 weak_ptr을 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="fe59378ecb23670abf397ca1ed600f6c13757f88" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static mutexes are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to lock a mutex in a constructor of any static object.</source>
          <target state="translated">기본 생성자가 &lt;code&gt;constexpr&lt;/code&gt; 이므로 정적 로컬은 로컬이 아닌 동적 초기화가 시작되기 전에 &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;정적 로컬이 아닌&lt;/a&gt; 초기화의 일부로 초기화됩니다. 따라서 정적 객체의 생성자에서 뮤텍스를 안전하게 잠글 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="920e4279426f6b2bafbfaf754987ba73067a3aed" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static shared_ptrs are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a shared_ptr in a constructor of any static object.</source>
          <target state="translated">기본 생성자가 &lt;code&gt;constexpr&lt;/code&gt; 이므로 &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;정적 비 로컬 초기화의&lt;/a&gt; 일부로 정적 비공유 초기화가 시작되기 전에 정적 shared_ptrs가 초기화됩니다. 따라서 정적 객체의 생성자에서 shared_ptr을 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="534359d78874e4479c30413b7cac076114495993" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static unique_ptrs are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a unique_ptr in a constructor of any static object.</source>
          <target state="translated">기본 생성자가 &lt;code&gt;constexpr&lt;/code&gt; 이므로 정적 non_local 초기화의 일부로 정적 unique_ptrs가 초기화되어 &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;로컬이&lt;/a&gt; 아닌 동적 초기화가 시작됩니다. 따라서 정적 객체의 생성자에서 unique_ptr을 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="ebbf73d1f46f71b596f1282630351e427e8477a7" translate="yes" xml:space="preserve">
          <source>Because the meaning of the keyword inline for functions came to mean &quot;multiple definitions are permitted&quot; rather than &quot;inlining is preferred&quot;, that meaning was extended to variables.</source>
          <target state="translated">함수에 대한 키워드 인라인의 의미는 &quot;인라인이 선호 됨&quot;이 아니라 &quot;여러 정의가 허용됨&quot;을 의미하기 때문에 해당 의미가 변수로 확장되었습니다.</target>
        </trans-unit>
        <trans-unit id="006cf008ab0b4c79aa08791fcfe4af60405cca97" translate="yes" xml:space="preserve">
          <source>Because the presence of a user-defined destructor, copy-constructor, or copy-assignment operator prevents implicit definition of the &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt; and the &lt;a href=&quot;move_operator&quot;&gt;move assignment operator&lt;/a&gt;, any class for which move semantics are desirable, has to declare all five special member functions:</source>
          <target state="translated">사용자 정의 소멸자, 복사 생성자 또는 복사 할당 연산자가 있으면 &lt;a href=&quot;move_constructor&quot;&gt;이동 생성자&lt;/a&gt; 및 &lt;a href=&quot;move_operator&quot;&gt;이동 할당 연산자&lt;/a&gt; 의 암시 적 정의를 막을 수 있기 때문에 이동 의미론이 바람직한 모든 클래스는 5 개의 특수 멤버 함수를 모두 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6dd2c080a889192fcdc9756c073e592957f9bd5" translate="yes" xml:space="preserve">
          <source>Because the short-circuiting properties of &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;operator||&lt;/code&gt; do not apply to overloads, and because types with boolean semantics are uncommon, only two standard library classes overload these operators:</source>
          <target state="translated">&lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;operator||&lt;/code&gt; 의 단락 특성 때문에 오버로드에는 적용되지 않으며 부울 시맨틱이있는 유형은 드물기 때문에 두 개의 표준 라이브러리 클래스 만 이러한 연산자를 오버로드합니다.</target>
        </trans-unit>
        <trans-unit id="da716a2068c8a4a0779a87e17e684144cccab8b0" translate="yes" xml:space="preserve">
          <source>Because the terminating character is counted as an extracted character, an empty input line does not trigger failbit.</source>
          <target state="translated">종료 문자는 추출 된 문자로 계산되므로 빈 입력 행은 페일 비트를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d2b809785ffb9b84788684b26543ec41eac3af8" translate="yes" xml:space="preserve">
          <source>Because these operators group left-to-right, the expression &lt;code&gt;a&amp;lt;b&amp;lt;c&lt;/code&gt; is parsed &lt;code&gt;(a&amp;lt;b)&amp;lt;c&lt;/code&gt;, and not &lt;code&gt;a&amp;lt;(b&amp;lt;c)&lt;/code&gt; or &lt;code&gt;(a&amp;lt;b)&amp;amp;&amp;amp;(b&amp;lt;c)&lt;/code&gt;.</source>
          <target state="translated">이러한 연산자는 왼쪽에서 오른쪽으로 그룹화되므로 &lt;code&gt;a&amp;lt;b&amp;lt;c&lt;/code&gt; 표현식 또는 &lt;code&gt;(a&amp;lt;b)&amp;amp;&amp;amp;(b&amp;lt;c)&lt;/code&gt; 아닌 &lt;code&gt;a&amp;lt;(b&amp;lt;c)&lt;/code&gt; b &amp;lt;c 표현식 이 구문 분석됩니다 &lt;code&gt;(a&amp;lt;b)&amp;lt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70619bda160666d212cde7b85f1f8b5a55f4c5a2" translate="yes" xml:space="preserve">
          <source>Because this function provides the automatic fall back to direct call to the destructor, the member function &lt;code&gt;destroy()&lt;/code&gt; is an optional &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirement since C++11.</source>
          <target state="translated">이 함수는 소멸자를 직접 호출하는 자동 폴백을 제공하므로 멤버 함수 &lt;code&gt;destroy()&lt;/code&gt; 는 C ++ 11 이후 의 선택적 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; 요구 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7687252b20cc0d88dc4dda04b2b393cf7f223dc8" translate="yes" xml:space="preserve">
          <source>Because this function provides the automatic fall back to placement new, the member function &lt;code&gt;construct()&lt;/code&gt; is an optional &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirement since C++11.</source>
          <target state="translated">이 함수는 새로운 배치로 자동 폴백을 제공하므로 멤버 함수 &lt;code&gt;construct()&lt;/code&gt; 는 C ++ 11 이후 의 선택적 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; 요구 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7f86afd7df6f8079055e111a54ab1c7b1acee01f" translate="yes" xml:space="preserve">
          <source>Because this function takes an &lt;code&gt;int&lt;/code&gt;, it cannot manipulate buffers larger than &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;::max()&lt;/code&gt; characters (&lt;a href=&quot;http://wg21.link/lwg255&quot;&gt;LWG 255&lt;/a&gt;).</source>
          <target state="translated">이 함수는 &lt;code&gt;int&lt;/code&gt; 를 사용하므로 &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;::max()&lt;/code&gt; 문자 보다 큰 버퍼를 조작 할 수 없습니다 ( &lt;a href=&quot;http://wg21.link/lwg255&quot;&gt;LWG 255&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="96b9e8b9f2beaa29d6fe717de5892c225fc24e46" translate="yes" xml:space="preserve">
          <source>Because transfer of control is &lt;a href=&quot;goto&quot;&gt;not permitted to enter the scope&lt;/a&gt; of a variable, if a declaration statement is encountered inside the statement, it has to be scoped in its own compound statement:</source>
          <target state="translated">제어의 전송은 변수 &lt;a href=&quot;goto&quot;&gt;의 범위를 입력 할 수 없으므로&lt;/a&gt; 선언문이 명령문 내부에서 발견되면 고유 한 복합 명령문으로 범위를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8087588a9b0c2147f6476231103eced47874ee97" translate="yes" xml:space="preserve">
          <source>Because trigraphs are processed early, a comment such as &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; will effectively comment out the following line, and the string literal such as &lt;code&gt;&quot;Enter date ??/??/??&quot;&lt;/code&gt; is parsed as &lt;code&gt;&quot;Enter date \\??&quot;&lt;/code&gt;.</source>
          <target state="translated">trigraph를 일찍 같은 주석 처리되어 있기 때문에 &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; 효과적으로 다음 줄을 주석과 같은 문자열 리터럴 것 &lt;code&gt;&quot;Enter date ??/??/??&quot;&lt;/code&gt; &lt;code&gt;&quot;Enter date \\??&quot;&lt;/code&gt; 로 해석됩니다 . .</target>
        </trans-unit>
        <trans-unit id="48a81f0ee3ab4431a19bb6ed8bbbce0c2c607478" translate="yes" xml:space="preserve">
          <source>Because variadic parameters have the lowest rank for the purpose of &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, they are commonly used as the catch-all fallbacks in &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;.</source>
          <target state="translated">가변성 파라미터는 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결을&lt;/a&gt; 위해 가장 낮은 순위를 갖기 때문에 &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; 에서 포괄 폴백으로 일반적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3342f0b566e3613e9188ea93ab88f717f12a0f2c" translate="yes" xml:space="preserve">
          <source>Because when const member function calls a function through a non-const member pointer, the non-const overload of the implementation function is called, the pointer has to be wrapped in &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/propagate_const&quot;&gt;std::experimental::propagate_const&lt;/a&gt;&lt;/code&gt; or equivalent.</source>
          <target state="translated">const 멤버 함수가 비 const 멤버 포인터를 통해 함수를 호출 할 때 구현 함수의 비 const 오버로드가 호출되므로 포인터는 &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/propagate_const&quot;&gt;std::experimental::propagate_const&lt;/a&gt;&lt;/code&gt; 또는 이와 동등한 형식 으로 래핑되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="8374ae1ab38ced7f1c45fb4cad278a13b4530170" translate="yes" xml:space="preserve">
          <source>Before &lt;code&gt;std::bit_cast&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; can be used when it is needed to interpret the object representation as one of another type:</source>
          <target state="translated">전에 &lt;code&gt;std::bit_cast&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; 가 다른 유형의 하나로서 객체 표현을 해석하는 데 필요할 때 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fea4659c4c01a5438272693831b7a6cf369a447e" translate="yes" xml:space="preserve">
          <source>Before C++11, floating-point exceptions were not specified, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; was required for any domain error, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; was required for overflows and implementation-defined for underflows.</source>
          <target state="translated">C ++ 11 이전에는 부동 소수점 예외가 지정되지 않았으며 도메인 오류에는 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; 이 필요했으며 오버플로에는 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; 가 필요했으며 언더 플로에는 구현이 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="8315db453a2a5506755072ec6a7820d4232e1cea" translate="yes" xml:space="preserve">
          <source>Before a call to &lt;code&gt;str()&lt;/code&gt; that uses the result as a C string, the stream buffer must be null-terminated. Regular output such as with &lt;code&gt;stream &amp;lt;&amp;lt; 1.2&lt;/code&gt; does not store a null terminator, it must be appended explicitly, typically with the manipulator &lt;code&gt;&lt;a href=&quot;../manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">결과를 C 문자열로 사용하는 &lt;code&gt;str()&lt;/code&gt; 을 호출하기 전에 스트림 버퍼는 널 종료되어야합니다. &lt;code&gt;stream &amp;lt;&amp;lt; 1.2&lt;/code&gt; 와 같은 일반 출력 은 null 종료자를 저장하지 않으며 일반적으로 조작자 &lt;code&gt;&lt;a href=&quot;../manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt; 와 함께 명시 적으로 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a94bcd5b8d87a105ad9ebe672411a4e5e7749b2c" translate="yes" xml:space="preserve">
          <source>Before any call to &lt;code&gt;str()&lt;/code&gt; that uses the result as a C string, the buffer must be null-terminated, typically with &lt;code&gt;&lt;a href=&quot;manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">결과를 C 문자열로 사용하는 &lt;code&gt;str()&lt;/code&gt; 을 호출하기 전에 버퍼는 일반적으로 &lt;code&gt;&lt;a href=&quot;manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt; 로 null로 종료되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c35792e95cf3b07cb316904dfad082217f59a440" translate="yes" xml:space="preserve">
          <source>Before any catch clauses of a function-try-block on a constructor are entered, all fully-constructed members and bases have already been destroyed.</source>
          <target state="translated">생성자에서 function-try-block의 catch 절을 입력하기 전에 완전히 구성된 모든 멤버 및베이스가 이미 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="d25af084b2d0cf872bc310ddc2b32c2b646e23c4" translate="yes" xml:space="preserve">
          <source>Before any catch clauses of a function-try-block on a destructor are entered, all bases and non-variant members have already been destroyed.</source>
          <target state="translated">소멸자에서 function-try-block의 catch 절을 입력하기 전에 모든 기본 및 비 변형 멤버가 이미 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="73e853eca15162afc8c02a1bedca567760609d5c" translate="yes" xml:space="preserve">
          <source>Before any further analysis, constraints are &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;normalized&lt;/a&gt; by substituting the body of every name concept and every requires expression until what is left is a sequence of conjunctions and disjunctions on atomic constraints.</source>
          <target state="translated">추가 분석 전에 제약 조건은 모든 이름 개념의 본문을 대체하여 &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;정규화&lt;/a&gt; 되며 , 남아있는 것이 원자 제약 조건에 대한 일련의 연결 및 분리가 될 때까지 표현이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6aa106196ee396275230e60cf51ed929654bbc97" translate="yes" xml:space="preserve">
          <source>Before any of the member functions would yield undefined results, calls callbacks, registered by &lt;a href=&quot;register_callback&quot;&gt;&lt;code&gt;register_callback()&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;event&quot;&gt;&lt;code&gt;erase_event&lt;/code&gt;&lt;/a&gt; as parameter.</source>
          <target state="translated">멤버 함수가 정의되지 않은 결과를 생성하기 전에 &lt;a href=&quot;register_callback&quot;&gt; &lt;code&gt;register_callback()&lt;/code&gt; &lt;/a&gt; 의해 등록 된 콜백을 호출 하여 &lt;a href=&quot;event&quot;&gt; &lt;code&gt;erase_event&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="32981297d13de998df78a59af43e17581b0c92e7" translate="yes" xml:space="preserve">
          <source>Before class template argument deduction was introduced, a common approach to avoiding explicitly specifying arguments is to use a function template:</source>
          <target state="translated">클래스 템플릿 인수 공제가 도입되기 전에 인수를 명시 적으로 지정하지 않는 일반적인 방법은 함수 템플릿을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="448996df8021b850305d2f1a744547e3fb5a961d" translate="yes" xml:space="preserve">
          <source>Before deduction begins, the following adjustments to &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are made:</source>
          <target state="translated">공제가 시작되기 전에 &lt;code&gt;P&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 에 대해 다음과 같이 조정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec06b6296ed6cd7c8b9af0261c5f6873359d381f" translate="yes" xml:space="preserve">
          <source>Before doing anything else, &lt;code&gt;seekg&lt;/code&gt; clears &lt;code&gt;eofbit&lt;/code&gt;.</source>
          <target state="translated">다른 작업을 수행하기 전에 &lt;code&gt;seekg&lt;/code&gt; 은 &lt;code&gt;eofbit&lt;/code&gt; 를 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="7de5fab850d46a3b252876719b32d89d2a9ae789" translate="yes" xml:space="preserve">
          <source>Before insertion, first, all characters are widened using &lt;code&gt;os.widen()&lt;/code&gt;, then padding is determined as follows: if the number of characters to insert is less than &lt;code&gt;os.width()&lt;/code&gt;, then enough copies of &lt;code&gt;os.fill()&lt;/code&gt; are added to the character sequence to make its length equal &lt;code&gt;os.width()&lt;/code&gt;. If &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, the fill characters are added at the end of the output sequence, otherwise they are added before the output sequence. After insertion, &lt;code&gt;width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.  The behavior is undefined if &lt;code&gt;s&lt;/code&gt; is a null pointer.</source>
          <target state="translated">삽입하기 전에 먼저 &lt;code&gt;os.widen()&lt;/code&gt; 사용하여 모든 문자를 확장 한 다음 패딩은 다음과 같이 결정됩니다. 삽입 할 문자 수가 &lt;code&gt;os.width()&lt;/code&gt; 미만 이면 충분한 &lt;code&gt;os.fill()&lt;/code&gt; 사본 이 추가됩니다. 길이를 &lt;code&gt;os.width()&lt;/code&gt; 로 만들기 위해 문자 시퀀스로 . 만약 &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; 채우기 문자 그렇지 않으면 출력 시퀀스 전에 추가, 출력 시퀀스의 마지막에 추가됩니다. 삽입 후 &lt;code&gt;width(0)&lt;/code&gt; 이 호출되어 &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 의 영향을 취소합니다 (있는 경우). &lt;code&gt;s&lt;/code&gt; 가 널 포인터 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="66a732adfdd2f159eb6ed563c85a4950c2ff838b" translate="yes" xml:space="preserve">
          <source>Before modified element(s)</source>
          <target state="translated">수정 된 요소 전에</target>
        </trans-unit>
        <trans-unit id="d97a4012796ad8947371e2ae9f789d3c201395de" translate="yes" xml:space="preserve">
          <source>Before name lookup can be performed for the name on the right hand side of &lt;code&gt;::&lt;/code&gt;, lookup must be completed for the name on its left hand side (unless a &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; expression is used, or there is nothing on the left). This lookup, which may be qualified or unqualified, depending on whether there's another &lt;code&gt;::&lt;/code&gt; to the left of that name, considers only namespaces, class types, enumerations, and templates whose specializations are types:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 의 오른쪽에있는 이름에 대한 이름 조회를 수행 하려면 먼저 왼쪽에있는 이름에 대한 조회를 완료해야합니다 ( &lt;a href=&quot;decltype&quot;&gt;클러스터&lt;/a&gt; 표현이 사용되거나 왼쪽에 아무것도없는 경우 제외 ). 이 룩업 은 해당 이름 왼쪽에 &lt;code&gt;::&lt;/code&gt; 가 있는지 여부에 따라 정규화되거나 정규화되지 않을 수 있지만 네임 스페이스, 클래스 유형, 열거 및 특수화 유형이 유형 인 템플릿 만 고려합니다.</target>
        </trans-unit>
        <trans-unit id="82707517c83290ff1d38dc49904b3bfd7e902adb" translate="yes" xml:space="preserve">
          <source>Before overload resolution begins, the functions selected by name lookup and template argument deduction are combined to form the set of</source>
          <target state="translated">과부하 해결이 시작되기 전에 이름 조회 및 템플릿 인수 공제로 선택한 기능이 결합되어</target>
        </trans-unit>
        <trans-unit id="ff5ff5557a213e5cbabe46f3d7e81258ac04a845" translate="yes" xml:space="preserve">
          <source>Before the compound statement that forms the function body of the constructor begins executing, initialization of all direct bases, virtual bases, and non-static data members is finished. Member initializer list is the place where non-default initialization of these objects can be specified. For members that cannot be default-initialized, such as members of reference and const-qualified types, member initializers must be specified. No initialization is performed for &lt;a href=&quot;union#Anonymous_unions&quot;&gt;anonymous unions&lt;/a&gt; or &lt;a href=&quot;union#Union-like_class&quot;&gt;variant members&lt;/a&gt; that do not have a member initializer.</source>
          <target state="translated">생성자의 함수 본문을 구성하는 복합 명령문이 실행을 시작하기 전에 모든 직접 기본, 가상 기본 및 비 정적 데이터 멤버의 초기화가 완료됩니다. 멤버 이니셜 라이저 목록은 이러한 오브젝트의 비 기본 초기화를 지정할 수있는 위치입니다. 참조 멤버 및 const 한정 유형과 같이 기본 초기화 할 수없는 멤버의 경우 멤버 이니셜 라이저를 지정해야합니다. 멤버 이니셜 라이저가없는 &lt;a href=&quot;union#Anonymous_unions&quot;&gt;익명 공용체&lt;/a&gt; 또는 &lt;a href=&quot;union#Union-like_class&quot;&gt;변형 멤버에&lt;/a&gt; 대해서는 초기화가 수행 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0c425b7763137b46eb294c01dcbca3225e7768a" translate="yes" xml:space="preserve">
          <source>Before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, the following uses of the glvalue expression that identifies that object are undefined:</source>
          <target state="translated">객체의 수명이 시작되기 전이나 객체가 차지하는 저장 공간이 할당 된 후 또는 객체의 수명이 종료 된 후 및 객체가 차지하는 저장 공간이 재사용되거나 해제되기 전에 다음과 같은 glvalue 표현식 사용 객체가 정의되지 않았 음을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="01ee3728daf49b9887894e9051143ca70683a003" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; is not affected. After constructing and checking the sentry object,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; 가 영향을받지 않는 것을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후</target>
        </trans-unit>
        <trans-unit id="afa456ec56112ff3b6b761bd5b74f63ce75d28ec" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; is not affected. After constructing and checking the sentry object, if &lt;code&gt;fail() == true&lt;/code&gt;, returns &lt;code&gt;pos_type(-1)&lt;/code&gt;. Otherwise, returns &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; 가 영향을받지 않는 것을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 생성하고 확인한 후 &lt;code&gt;fail() == true&lt;/code&gt; 경우 &lt;code&gt;pos_type(-1)&lt;/code&gt; 반환합니다 . 그렇지 않으면 &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std :: ios_base :: cur&lt;/a&gt; , &lt;a href=&quot;../ios_base/openmode&quot;&gt;std :: ios_base :: in&lt;/a&gt; )을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3a77bac3067d3940c6b684599ba369eb392602c9" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object,</source>
          <target state="translated">&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후</target>
        </trans-unit>
        <trans-unit id="9678066f0a18b755a7a83de41a67b8f539cf21e5" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, extracts characters and stores them into successive locations of the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. Characters are extracted and stored until any of the following conditions occurs:</source>
          <target state="translated">&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후 문자를 추출하여 첫 ​​번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열의 연속 위치에 저장합니다 . 다음 조건 중 하나가 발생할 때까지 문자가 추출되어 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="5452e2d70444e38dce8d1658572b189b3491c062" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, extracts characters from &lt;code&gt;*this&lt;/code&gt; and stores them in successive locations of the array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, until any of the following occurs (tested in the order shown):</source>
          <target state="translated">&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후 &lt;code&gt;*this&lt;/code&gt; 에서 문자를 추출 하여 다음 중 하나가 발생할 때까지 (이 순서대로 테스트 될 때까지) &lt;code&gt;s&lt;/code&gt; 가 첫 번째 요소를 가리키는 배열의 연속 위치에 해당 문자를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="2ce9bf750568029bd6c252857e382b90c6756ee0" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and testing the sentry object, reads the next character from the input stream without extracting it.</source>
          <target state="translated">&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 테스트 한 후 추출하지 않고 입력 스트림에서 다음 문자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0749de46c88cb22f7c4409a2cfcef6bf1f8046f6" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt; (except without actually performing output). After constructing and checking the sentry object,</source>
          <target state="translated">&lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction으로&lt;/a&gt; 작동합니다 (실제로 출력을 수행하지 않는 경우 제외). 센트리 객체를 구성하고 확인한 후</target>
        </trans-unit>
        <trans-unit id="4672c00972c0e6a7e7c5cce22e6b19b90240fb04" translate="yes" xml:space="preserve">
          <source>Behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, determines the output format padding as follows:</source>
          <target state="translated">&lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후 다음과 같이 출력 형식 패딩을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="fd13a34bc371a84520ebfd6305bba27395aa1de8" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;is.gcount()&lt;/code&gt; is not modified. After constructing and checking the sentry object, extracts characters from the stream and discards them until any one of the following conditions occurs:</source>
          <target state="translated">&lt;code&gt;is.gcount()&lt;/code&gt; 가 수정 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;되지 않은&lt;/a&gt; 것을 제외하고 UnformattedInputFunction으로 작동 합니다. 센트리 객체를 구성하고 확인한 후 스트림에서 문자를 추출하여 다음 조건 중 하나가 발생할 때까지 해당 문자를 버립니다.</target>
        </trans-unit>
        <trans-unit id="fb87348382a678ef761dc7c93eddfa49c60fd167" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;d&lt;/code&gt; is not modified.</source>
          <target state="translated">&lt;code&gt;is.gcount()&lt;/code&gt; 에 지정되지 않은 영향을 미친다 는 점을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후에 시도 입력 스트림 파싱 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;d&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; . 구문 분석에 유효한 디코딩에 실패하면 &lt;code&gt;day&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;표준 : : ios_base :: failbit&lt;/a&gt; ) 라고하며 &lt;code&gt;d&lt;/code&gt; 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fa65d008ed7c245aef54a0ea0b67364379c951b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;duration&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;d&lt;/code&gt; is not modified.</source>
          <target state="translated">&lt;code&gt;is.gcount()&lt;/code&gt; 에 지정되지 않은 영향을 미친다 는 점을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후에 시도 입력 스트림 파싱 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;d&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; . 해석은 유효한 디코딩하는데 실패하면 &lt;code&gt;duration&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;표준 : ios_base :: failbit이&lt;/a&gt; ) 라고하며, &lt;code&gt;d&lt;/code&gt; 수정되지 않는다.</target>
        </trans-unit>
        <trans-unit id="d2831b6a6c206e8d8a233d91bfdec888a2de732b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;m&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;m&lt;/code&gt; is not modified.</source>
          <target state="translated">&lt;code&gt;is.gcount()&lt;/code&gt; 에 지정되지 않은 영향을 미친다 는 점을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후, 입력 스트림을 구문 분석하려고 하면 형식 문자열 &lt;code&gt;fmt&lt;/code&gt; 에 따라 &lt;code&gt;m&lt;/code&gt; &lt;code&gt;is&lt;/code&gt; 됩니다 . 구문 분석에 유효한 디코딩에 실패하면 &lt;code&gt;month&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;표준 : : ios_base :: failbit&lt;/a&gt; ) 라고하며, &lt;code&gt;m&lt;/code&gt; 은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="faffa23b913d2432b4e5d59afb1027604b07f00e" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;md&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;month_day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;md&lt;/code&gt; is not modified.</source>
          <target state="translated">&lt;code&gt;is.gcount()&lt;/code&gt; 에 지정되지 않은 영향을 미친다 는 점을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후에 시도 입력 스트림 파싱 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;md&lt;/code&gt; 포맷 스트링에있어서 &lt;code&gt;fmt&lt;/code&gt; . 구문 분석에 유효한 디코딩에 실패하면 &lt;code&gt;month_day&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;표준 : : ios_base :: failbit&lt;/a&gt; ) 라고하며 &lt;code&gt;md&lt;/code&gt; 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e065fe398d7803bd86c6a7e26d51804b3b96c6b0" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;tp&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid time point, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;tp&lt;/code&gt; is not modified.</source>
          <target state="translated">&lt;code&gt;is.gcount()&lt;/code&gt; 에 지정되지 않은 영향을 미친다 는 점을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후에 시도 입력 스트림 파싱 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;tp&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; . 구문 분석이 유효한 시점을 디코딩하지 못하면 &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std :: ios_base :: failbit&lt;/a&gt; ) 가 호출되고 &lt;code&gt;tp&lt;/code&gt; 는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e916f1ce3a09969712030a89b921f22ad91cde6" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;wd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;weekday&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;wd&lt;/code&gt; is not modified.</source>
          <target state="translated">&lt;code&gt;is.gcount()&lt;/code&gt; 에 지정되지 않은 영향을 미친다 는 점을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후, 입력 스트림을 구문 분석하려고 하면 형식 문자열 &lt;code&gt;fmt&lt;/code&gt; 에 따라 &lt;code&gt;wd&lt;/code&gt; &lt;code&gt;is&lt;/code&gt; 됩니다 . 구문 분석에 유효한 디코딩에 실패하면 &lt;code&gt;weekday&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;표준 : : ios_base :: failbit를&lt;/a&gt; ) 라고하며, &lt;code&gt;wd&lt;/code&gt; 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="534f077e6bac2d7fcd7ec6bfbd2ce8a229d9e671" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;y&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;y&lt;/code&gt; is not modified.</source>
          <target state="translated">&lt;code&gt;is.gcount()&lt;/code&gt; 에 지정되지 않은 영향을 미친다 는 점을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후에 시도 입력 스트림 파싱 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;y&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; . 구문 분석에 유효한 디코딩에 실패하면 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;표준 : : ios_base :: failbit&lt;/a&gt; ) 라고하며 &lt;code&gt;y&lt;/code&gt; 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d1a3df7d8a7fca81ecb344ddc22950a523c840e" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;ym&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year_month&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;ym&lt;/code&gt; is not modified.</source>
          <target state="translated">&lt;code&gt;is.gcount()&lt;/code&gt; 에 지정되지 않은 영향을 미친다 는 점을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후에 시도 입력 스트림 파싱 &lt;code&gt;is&lt;/code&gt; 으로 &lt;code&gt;ym&lt;/code&gt; 형식 문자열에 의한 &lt;code&gt;fmt&lt;/code&gt; . 구문 분석에 유효한 디코딩에 실패하면 &lt;code&gt;year_month&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;표준 : : ios_base :: failbit&lt;/a&gt; ) 라고하며 &lt;code&gt;ym&lt;/code&gt; 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="354ffd6415a45c8148f6d721a7550f4e07921a44" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;ymd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year_month_day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;ymd&lt;/code&gt; is not modified.</source>
          <target state="translated">&lt;code&gt;is.gcount()&lt;/code&gt; 에 지정되지 않은 영향을 미친다 는 점을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후 입력 문자열 을 구문 분석하려고 하면 형식 문자열 &lt;code&gt;fmt&lt;/code&gt; 에 따라 &lt;code&gt;ymd&lt;/code&gt; &lt;code&gt;is&lt;/code&gt; 됩니다 . 구문 분석에 유효한 디코딩에 실패하면 &lt;code&gt;year_month_day&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;표준 : : ios_base :: failbit&lt;/a&gt; ) 라고하며 &lt;code&gt;ymd&lt;/code&gt; 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b31240671d71f38c08c6175c2a624c5485aa3e4b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, outputs the characters from successive locations in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. Characters are inserted into the output sequence until one of the following occurs:</source>
          <target state="translated">&lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열의 연속 위치에서 문자를 출력합니다 . 다음 중 하나가 발생할 때까지 문자가 출력 순서에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="420d1377b9bbd844155a88eb257414b14d2edd8c" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, writes the character &lt;code&gt;ch&lt;/code&gt; to the output stream.</source>
          <target state="translated">&lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후 문자 &lt;code&gt;ch&lt;/code&gt; 를 출력 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="82ff397227b9a7ad0f8b7b725088913fce6ee471" translate="yes" xml:space="preserve">
          <source>Behaves as an atomic operation.</source>
          <target state="translated">원 자성 작업으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b9dc5d13ce0d39d79ca5f8d6c575a41f58014821" translate="yes" xml:space="preserve">
          <source>Behaves as if applying &lt;code&gt;&lt;a href=&quot;iter_swap&quot;&gt;std::iter_swap&lt;/a&gt;&lt;/code&gt; to every pair of iterators &lt;code&gt;first+i, (last-i) - 1&lt;/code&gt; for each non-negative &lt;code&gt;i &amp;lt; (last-first)/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;iter_swap&quot;&gt;std::iter_swap&lt;/a&gt;&lt;/code&gt; 을 모든 반복자 쌍에 &lt;code&gt;first+i, (last-i) - 1&lt;/code&gt; 각 음수가 아닌 &lt;code&gt;i &amp;lt; (last-first)/2&lt;/code&gt; 적용하는 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="bed410844ec9fd5b13e393d20c755ef0b8dfbf2d" translate="yes" xml:space="preserve">
          <source>Behaves as if by executing the assignment &lt;code&gt;*(d_first + (last - first) - 1 - i) = *(first + i)&lt;/code&gt; once for each non-negative &lt;code&gt;i &amp;lt; (last - first)&lt;/code&gt;</source>
          <target state="translated">음이 아닌 각 &lt;code&gt;i &amp;lt; (last - first)&lt;/code&gt; 에 대해 할당 &lt;code&gt;*(d_first + (last - first) - 1 - i) = *(first + i)&lt;/code&gt; 한 번 실행하는 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="c2095bbba3a93f2559c0792b761c684cd2ef1312" translate="yes" xml:space="preserve">
          <source>Behaves as if it forms a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;&lt;code&gt;str&lt;/code&gt; initially consisting of the characters in &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;(d.count())&lt;/code&gt; (if &lt;code&gt;CharT&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt;) or &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;(d.count())&lt;/code&gt; (if &lt;code&gt;CharT&lt;/code&gt; is &lt;code&gt;wchar_t&lt;/code&gt;). Appends to &lt;code&gt;str&lt;/code&gt; a suffix based on &lt;code&gt;Period::type&lt;/code&gt; according to the following table, and inserts &lt;code&gt;str&lt;/code&gt; into the stream with &lt;code&gt;os &amp;lt;&amp;lt; str;&lt;/code&gt;.</source>
          <target state="translated">마치 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;(d.count())&lt;/code&gt; (d.count ()) ( &lt;code&gt;CharT&lt;/code&gt; 가 &lt;code&gt;char&lt;/code&gt; 인 경우 ) 또는 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;(d.count())&lt;/code&gt; (d.count () 의 문자로 구성 되는 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; &lt;code&gt;str&lt;/code&gt; 처럼 작동합니다. ) ( &lt;code&gt;CharT&lt;/code&gt; 가 &lt;code&gt;wchar_t&lt;/code&gt; 인 경우 ). 다음 표에 따라 &lt;code&gt;Period::type&lt;/code&gt; 기반으로 접미사 에 &lt;code&gt;str&lt;/code&gt; 을 추가 하고 &lt;code&gt;os &amp;lt;&amp;lt; str;&lt;/code&gt; 를 사용하여 스트림에 &lt;code&gt;str&lt;/code&gt; 을 삽입합니다 . .</target>
        </trans-unit>
        <trans-unit id="1ba1f2a3eb212b1fa99c5e19994960cbf5cc4c56" translate="yes" xml:space="preserve">
          <source>Behaves like the &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;, except that if &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; succeeds (does not return &lt;code&gt;Traits::eof()&lt;/code&gt;), then advances the next pointer for the get area. In other words, consumes one of the characters obtained by &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 가 성공하면 ( &lt;code&gt;Traits::eof()&lt;/code&gt; 반환하지 않음 ) get 영역에 대한 다음 포인터를 진행 한다는 점을 제외하고 는 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 와 같이 작동 합니다. 즉, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 얻은 문자 중 하나를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c7424443eb2a5187f8df088d1e24d7b153e76c40" translate="yes" xml:space="preserve">
          <source>Behaves like the base class &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;std::basic_streambuf::overflow&lt;/a&gt;&lt;/code&gt;, except that to write the data, first uses &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; of the imbued locale to convert the characters into external (possibly multibyte) representation, stored in a temporary buffer (allocated as large as necessary), then uses file I/O to copy all fully-converted bytes into the file.</source>
          <target state="translated">기본 클래스 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;std::basic_streambuf::overflow&lt;/a&gt;&lt;/code&gt; 와 같이 작동 합니다. 데이터를 쓰려면 먼저 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; 로케일의 std :: codecvt :: out 을 사용 하여 문자를 임시 버퍼에 저장된 외부 (멀티 바이트) 표현으로 변환하십시오. (필요한만큼 할당 된) 파일 I / O를 사용하여 완전히 변환 된 모든 바이트를 파일로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="ead68b316b3a5bb13de60a50d4b049c735bc0457" translate="yes" xml:space="preserve">
          <source>Behaves like the base class &lt;code&gt;std::basic_streambuf::underflow&lt;/code&gt;, except that to read the data from the associated character sequence (the file) into the get area, first reads the bytes from the file into a temporary buffer (allocated as large as necessary), then uses &lt;code&gt;std::codecvt::in&lt;/code&gt; of the imbued locale to convert the external (typically, multibyte) representation to the internal form which is then used to populate the get area. The conversion may be skipped if the locale's &lt;code&gt;std::codecvt::always_noconv&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">기본 클래스 &lt;code&gt;std::basic_streambuf::underflow&lt;/code&gt; 와 같이 작동합니다 . 단, 연관된 문자 순서 (파일)에서 get 영역으로 데이터를 읽고 파일에서 임시 버퍼로 바이트를 읽습니다 (필요한만큼 크게 할당 됨). 그런 다음 imbued 로케일의 &lt;code&gt;std::codecvt::in&lt;/code&gt; 을 사용 하여 외부 (일반적으로 멀티 바이트) 표시를 내부 양식으로 변환 한 다음 가져 오기 영역을 채우는 데 사용합니다. 로케일의 &lt;code&gt;std::codecvt::always_noconv&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 변환을 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8144558f99cdff249c2ee868ada81e832e47eeb4" translate="yes" xml:space="preserve">
          <source>Behavior as published</source>
          <target state="translated">게시 된 동작</target>
        </trans-unit>
        <trans-unit id="3b4de82624ef063c5570a0aa0bb2fd68f2dc6163" translate="yes" xml:space="preserve">
          <source>Bernoulli distributions</source>
          <target state="translated">베르누이 분포</target>
        </trans-unit>
        <trans-unit id="1e5ebe6f1289f29133bcd6572d2c2241857b3a1a" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;operator_other&quot;&gt;function-call expressions&lt;/a&gt;, where &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; takes place, the name of an overloaded function may appear in the following 7 contexts:</source>
          <target state="translated">&lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결&lt;/a&gt; 이 발생 하는 &lt;a href=&quot;operator_other&quot;&gt;함수 호출 표현식&lt;/a&gt; 외에도 과부하 된 함수의 이름은 다음 7 가지 컨텍스트에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35a9468290c3394c97c047fe437a550a62007c54" translate="yes" xml:space="preserve">
          <source>Besides commenting out, other mechanisms used for source code exclusion are.</source>
          <target state="translated">주석 처리 외에도 소스 코드 제외에 사용되는 다른 메커니즘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="03958a7c9ad1213ec526869eb4c84b20e58f0961" translate="yes" xml:space="preserve">
          <source>Besides establishing new parse state and position, a call to this function undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file state, if it is set.</source>
          <target state="translated">새로운 구문 분석 상태 및 위치를 설정하는 것 외에도이 함수를 호출하면 &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; 의 효과가 취소되고 파일 끝 상태가 설정되어 있으면 지워집니다.</target>
        </trans-unit>
        <trans-unit id="cde31df5b3a6edf2b668225ad16ccbe6298bf72e" translate="yes" xml:space="preserve">
          <source>Besides function calls and operator expressions, template argument deduction is used in the following situations:</source>
          <target state="translated">함수 호출 및 연산자 표현식 외에도 템플릿 인수 공제는 다음과 같은 상황에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ea3de9ed1aa39d9d12037783bc2af648287a89b" translate="yes" xml:space="preserve">
          <source>Besides function lvalues, the function call expression supports pointers to functions, dereferenced pointers to member functions, &lt;a href=&quot;lambda&quot;&gt;lambda-expressions&lt;/a&gt;, and any variable of class type that overloads the function-call operator. Together, these types are known as &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObjects&lt;/a&gt;, and they are used ubiquitously through the C++ standard library, see for example, usages of &lt;a href=&quot;../named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; and &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;.</source>
          <target state="translated">함수 lvalue 외에도 함수 호출 표현식은 함수에 대한 포인터, 멤버 함수에 대한 역 참조 된 포인터, &lt;a href=&quot;lambda&quot;&gt;lambda-expressions&lt;/a&gt; 및 함수 호출 연산자를 오버로드하는 클래스 유형의 변수를 지원합니다. 이러한 유형을 함께 &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObjects&lt;/a&gt; 라고하며 C ++ 표준 라이브러리를 통해 어디에서나 사용됩니다 (예 : &lt;a href=&quot;../named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; 및 &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; 사용법 참조) .</target>
        </trans-unit>
        <trans-unit id="eadda9e8c93ae861b29d0afee13d836c6af0e0f7" translate="yes" xml:space="preserve">
          <source>Besides introducing the new exception template &lt;a href=&quot;../error/tx_exception&quot;&gt;&lt;code&gt;std::tx_exception&lt;/code&gt;&lt;/a&gt;, the transactional memory technical specification makes the following changes to the standard library:</source>
          <target state="translated">새로운 예외 템플릿 &lt;a href=&quot;../error/tx_exception&quot;&gt; &lt;code&gt;std::tx_exception&lt;/code&gt; &lt;/a&gt; 도입하는 것 외에도 트랜잭션 메모리 기술 사양은 표준 라이브러리를 다음과 같이 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f85f4cbfeeefb97ce1a4ae209c4036553a0f1353" translate="yes" xml:space="preserve">
          <source>Besides suitably declared identifiers, the following can be used in expressions in the same role:</source>
          <target state="translated">적절하게 선언 된 식별자 외에 다음과 같은 역할을하는 표현식에 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc609bbb82549ba7934f717ed858b800830e4534" translate="yes" xml:space="preserve">
          <source>Besides the minimal bit counts, the C++ Standard guarantees that  &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt;.</source>
          <target state="translated">최소 비트 수 외에도 C ++ 표준은 &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt; 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="c97ed01493243e69d10ffc8e50648f78cab73dcd" translate="yes" xml:space="preserve">
          <source>Besides the standard attributes listed below, implementations may support arbitrary non-standard attributes with implementation-defined behavior. All attributes unknown to an implementation are ignored without causing an error.(since C++17).</source>
          <target state="translated">아래에 나열된 표준 속성 외에도 구현은 구현 정의 동작으로 임의의 비표준 속성을 지원할 수 있습니다. 구현에 알려지지 않은 모든 속성은 오류를 발생시키지 않고 무시됩니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="326ce75ab410687b03d60753ab3b5a7bc3c6aa60" translate="yes" xml:space="preserve">
          <source>Besides the system-specific information necessary to access the device (e.g. a POSIX file descriptor), each C stream object holds the following:</source>
          <target state="translated">장치에 액세스하는 데 필요한 시스템 별 정보 (예 : POSIX 파일 디스크립터) 외에도 각 C 스트림 객체는 다음을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="987751c78ae2b93d437defad81b5467e3258fa00" translate="yes" xml:space="preserve">
          <source>Best viable function</source>
          <target state="translated">최고의 기능</target>
        </trans-unit>
        <trans-unit id="5445f48f941a5ad1d1542f8d66aef55a24056167" translate="yes" xml:space="preserve">
          <source>Between threads, evaluation A</source>
          <target state="translated">스레드 간, 평가 A</target>
        </trans-unit>
        <trans-unit id="08921ac97281717dcf3cc5edee55ed9ec1246d18" translate="yes" xml:space="preserve">
          <source>Between threads, evaluation A is</source>
          <target state="translated">스레드 사이에서 평가 A는</target>
        </trans-unit>
        <trans-unit id="2451baa075c4c2006f43575b68fffc6be3054416" translate="yes" xml:space="preserve">
          <source>BidirIt first</source>
          <target state="translated">먼저 BidirIt</target>
        </trans-unit>
        <trans-unit id="d0770f96a62e4dba7b78dc8ded5a3d2559e0c17b" translate="yes" xml:space="preserve">
          <source>BidirIt second</source>
          <target state="translated">BidirIt 초</target>
        </trans-unit>
        <trans-unit id="ffdf5ba9df9ed49abf7794c76ef97818235d86f9" translate="yes" xml:space="preserve">
          <source>BidirectionalIterator</source>
          <target state="translated">BidirectionalIterator</target>
        </trans-unit>
        <trans-unit id="482ad58667e3f2f9817b420cb310aa97436e0bbd" translate="yes" xml:space="preserve">
          <source>BidirectionalRange</source>
          <target state="translated">BidirectionalRange</target>
        </trans-unit>
        <trans-unit id="c460d3f926dfc813742e2a51770def855d27f159" translate="yes" xml:space="preserve">
          <source>Binary and text modes</source>
          <target state="translated">이진 및 텍스트 모드</target>
        </trans-unit>
        <trans-unit id="91150bd6516ac5f77628d936130ba9cf5ec13ae6" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operators</source>
          <target state="translated">이진 산술 연산자</target>
        </trans-unit>
        <trans-unit id="b85455cd395dfbce0c44e85498fb4706eb3346ce" translate="yes" xml:space="preserve">
          <source>Binary literals in the C++ core language</source>
          <target state="translated">C ++ 핵심 언어의 이진 리터럴</target>
        </trans-unit>
        <trans-unit id="cc724df4c71a335d592593fb78d0f54cdc71de39" translate="yes" xml:space="preserve">
          <source>Binary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if &lt;code&gt;operator+&lt;/code&gt; is a member function of the complex type, then only &lt;code&gt;complex+integer&lt;/code&gt; would compile, and not &lt;code&gt;integer+complex&lt;/code&gt;). Since for every binary arithmetic operator there exists a corresponding compound assignment operator, canonical forms of binary operators are implemented in terms of their compound assignments:</source>
          <target state="translated">이항 연산자는 일반적으로 대칭을 유지하기 위해 비 멤버로 구현됩니다 (예 : 복합 숫자와 정수를 추가 할 때 &lt;code&gt;operator+&lt;/code&gt; 가 복합 유형의 멤버 함수 인 경우 &lt;code&gt;integer+complex&lt;/code&gt; 가 아닌 &lt;code&gt;complex+integer&lt;/code&gt; 만 컴파일 됨 ) . 모든 이진 산술 연산자마다 해당하는 복합 할당 연산자가 있으므로 정식 이진 연산자 형식은 복합 할당 측면에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="9b181c7beda214f4532f13b77ba42314ece1f768" translate="yes" xml:space="preserve">
          <source>Binary search operations (on sorted ranges)</source>
          <target state="translated">이진 검색 작업 (정렬 된 범위)</target>
        </trans-unit>
        <trans-unit id="9b0e681b6c800f7b05bda65505fa83f5f1a1be72" translate="yes" xml:space="preserve">
          <source>BinaryPredicate</source>
          <target state="translated">BinaryPredicate</target>
        </trans-unit>
        <trans-unit id="d7b9396086e5ec8058fd32dd688322acc6d2bf68" translate="yes" xml:space="preserve">
          <source>BinaryTypeTrait</source>
          <target state="translated">BinaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="3dbc95d187c9e90ca622a826dd7edb08cc9cacfa" translate="yes" xml:space="preserve">
          <source>Binders</source>
          <target state="translated">Binders</target>
        </trans-unit>
        <trans-unit id="f4e69ca5e425a4bf55911c4e6db32c6119febe30" translate="yes" xml:space="preserve">
          <source>Binding a reference to a virtual base class subobject.</source>
          <target state="translated">가상 기본 클래스 하위 오브젝트에 대한 참조 바인딩</target>
        </trans-unit>
        <trans-unit id="e9f04cf314fb7952075910e2f9ba75070c56f9c6" translate="yes" xml:space="preserve">
          <source>Binding of</source>
          <target state="translated">바인딩</target>
        </trans-unit>
        <trans-unit id="c0cece0851be5efd26379576b4bcef2caf1dd812" translate="yes" xml:space="preserve">
          <source>Binding of a reference parameter directly to the argument expression is either Identity or a derived-to-base Conversion:</source>
          <target state="translated">참조 매개 변수를 인수 표현식에 직접 바인딩하는 것은 Identity 또는 파생 된 기본 변환입니다.</target>
        </trans-unit>
        <trans-unit id="d829dc6fbeb72ba40b4a6193d7c09ca8de6d9c66" translate="yes" xml:space="preserve">
          <source>Binding rules</source>
          <target state="translated">바인딩 규칙</target>
        </trans-unit>
        <trans-unit id="f722c7dc45abe867103665120ef13603cd9867f6" translate="yes" xml:space="preserve">
          <source>Binds a given argument &lt;code&gt;x&lt;/code&gt; to a first or second parameter of the given binary function object &lt;code&gt;f&lt;/code&gt;. That is, stores &lt;code&gt;x&lt;/code&gt; within the resulting wrapper, which, if called, passes &lt;code&gt;x&lt;/code&gt; as the first or the second parameter of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">주어진 인수 &lt;code&gt;x&lt;/code&gt; 를 주어진 이진 함수 객체 &lt;code&gt;f&lt;/code&gt; 의 첫 번째 또는 두 번째 매개 변수에 바인딩합니다 . 즉, 결과 래퍼 내에 &lt;code&gt;x&lt;/code&gt; 를 저장 합니다. 호출 된 경우 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;f&lt;/code&gt; 의 첫 번째 또는 두 번째 매개 변수로 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="2587e5513df92e2184a69043d5b2d8c64896348f" translate="yes" xml:space="preserve">
          <source>Binds a reference to an object.</source>
          <target state="translated">객체에 대한 참조를 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="7ff0b1c06c14891fb48b824df8e7692aa76016b3" translate="yes" xml:space="preserve">
          <source>Binds the specified names to subobjects or elements of the initializer.</source>
          <target state="translated">지정된 이름을 이니셜 라이저의 하위 오브젝트 또는 요소에 바인드합니다.</target>
        </trans-unit>
        <trans-unit id="48c22d075b084cd5b8d711e4184eb43a90b6c4ef" translate="yes" xml:space="preserve">
          <source>Binomial coefficients can be expressed in terms of the beta function: \(\binom{n}{k} = \frac{1}{(n+1)B(n-k+1,k+1)}\).</source>
          <target state="translated">이항 계수는 베타 함수로 표현할 수 있습니다 : \ (\ binom {n} {k} = \ fra {1} {(n + 1) B (n-k + 1, k + 1)} \).</target>
        </trans-unit>
        <trans-unit id="e8835c712451999e0a892ac12f5715c4350423b1" translate="yes" xml:space="preserve">
          <source>Bit</source>
          <target state="translated">Bit</target>
        </trans-unit>
        <trans-unit id="b5630cfa9108a371c432ca1b8e629cf6bc1b012a" translate="yes" xml:space="preserve">
          <source>Bit field</source>
          <target state="translated">비트 필드</target>
        </trans-unit>
        <trans-unit id="b045376f837c7f5b36378c8f4a5c40a869f8ef92" translate="yes" xml:space="preserve">
          <source>Bit fields</source>
          <target state="translated">비트 필드</target>
        </trans-unit>
        <trans-unit id="443a8710a8bef103647191f97f7cd879bcad9c73" translate="yes" xml:space="preserve">
          <source>Bit manipulation</source>
          <target state="translated">비트 조작</target>
        </trans-unit>
        <trans-unit id="491df97cfa5e39f515f28ec7e2a2d72a45a33da8" translate="yes" xml:space="preserve">
          <source>Bit manipulation (since C++20)</source>
          <target state="translated">비트 조작 (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="e6078ce7cb8ef5cea6018354d8a889b9edde5cbc" translate="yes" xml:space="preserve">
          <source>BitmaskType</source>
          <target state="translated">BitmaskType</target>
        </trans-unit>
        <trans-unit id="5ec768dbd17e419b41b32bba46a2d38687d9a71f" translate="yes" xml:space="preserve">
          <source>Bitset</source>
          <target state="translated">Bitset</target>
        </trans-unit>
        <trans-unit id="741c773876c69e2cd07b549c1ea8ece454c609e3" translate="yes" xml:space="preserve">
          <source>Bitwise &lt;a href=&quot;operator_arithmetic#Bitwise_shift_operators&quot;&gt;left shift and right shift&lt;/a&gt;</source>
          <target state="translated">비트 &lt;a href=&quot;operator_arithmetic#Bitwise_shift_operators&quot;&gt;왼쪽 시프트 및 오른쪽 시프트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">비트 AND</target>
        </trans-unit>
        <trans-unit id="306fd7520aac5bd6625750560fd55f52696ffa54" translate="yes" xml:space="preserve">
          <source>Bitwise OR of the floating-point exception macros that are both included in &lt;code&gt;excepts&lt;/code&gt; and correspond to floating-point exceptions currently set.</source>
          <target state="translated">모두에 포함 된 부동 소수점 예외 매크로의 비트 단위 OR &lt;code&gt;excepts&lt;/code&gt; 부동 소수점 예외 및 대응은 현재 설정합니다.</target>
        </trans-unit>
        <trans-unit id="35355cba328d12df3bd3dca4cc2c3703b1246bb3" translate="yes" xml:space="preserve">
          <source>Bitwise arithmetic operators</source>
          <target state="translated">비트 산술 연산자</target>
        </trans-unit>
        <trans-unit id="9137bddcb31c15dd59efa0751eb46d78510d3c77" translate="yes" xml:space="preserve">
          <source>Bitwise logic operators</source>
          <target state="translated">비트 논리 연산자</target>
        </trans-unit>
        <trans-unit id="67445a8812f7cd259e3b6e21272d2fddff30a9e2" translate="yes" xml:space="preserve">
          <source>Bitwise operations</source>
          <target state="translated">비트 단위 연산</target>
        </trans-unit>
        <trans-unit id="d49fb1543c1cf037be882f516f8283e8411c03af" translate="yes" xml:space="preserve">
          <source>Bitwise shift operators</source>
          <target state="translated">비트 시프트 연산자</target>
        </trans-unit>
        <trans-unit id="5bf1d047debbacfb72d2c4727d98ae3d266e79f4" translate="yes" xml:space="preserve">
          <source>Block declaration (a declaration that can appear inside a &lt;a href=&quot;statements#Compound_statement&quot;&gt;block&lt;/a&gt;), which, in turn, can be one of the following:</source>
          <target state="translated">블록 선언 ( &lt;a href=&quot;statements#Compound_statement&quot;&gt;블록&lt;/a&gt; 안에 나타날 수있는 선언 )은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">블록 범위</target>
        </trans-unit>
        <trans-unit id="ab7474d238eb40c9da20e933f1c1d4048b69acd4" translate="yes" xml:space="preserve">
          <source>Blocks for the provided duration or until a lock on &lt;code&gt;m&lt;/code&gt; is acquired.</source>
          <target state="translated">제공된 지속 시간 동안 또는 &lt;code&gt;m&lt;/code&gt; 에 대한 잠금 이 획득 될 때까지 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="92391cb25322ebaeda3d45357ca30e226b318b27" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until exclusive ownership of the mutex can be obtained.</source>
          <target state="translated">뮤텍스의 독점 소유권을 얻을 수있을 때까지 호출 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="8f7f11c61615ab6fa684880437bc9968e692fba9" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until shared ownership of the mutex can be obtained.</source>
          <target state="translated">뮤텍스의 공유 소유권을 얻을 수있을 때까지 호출 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="2fd2dcd848502428b39dc60b6225e09d3f0e7e57" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the thread identified by &lt;code&gt;*this&lt;/code&gt; finishes its execution.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 식별 된 스레드 가 실행을 완료 할 때까지 현재 스레드를 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="6e00d4fd15cea4053d3d66470eca6ff8a4eb81f0" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread for</source>
          <target state="translated">현재 스레드의 실행을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="74a224c0de9a1fe8a0d5475e7041194e73e5a53a" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread until specified &lt;code&gt;sleep_time&lt;/code&gt; has been reached.</source>
          <target state="translated">지정된 &lt;code&gt;sleep_time&lt;/code&gt; 에 도달 할 때까지 현재 스레드의 실행을 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="9af45472a96a859ddc1794b6abf6298174b74613" translate="yes" xml:space="preserve">
          <source>Blocks until a lock can be obtained for the current execution agent (thread, process, task). If an exception is thrown, no lock is obtained.</source>
          <target state="translated">현재 실행 에이전트 (스레드, 프로세스, 작업)에 대한 잠금을 얻을 수있을 때까지 차단합니다. 예외가 발생하면 잠금이 획득되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eba863ee2c609bd20888a9ee01d8f0bc03fe3b0b" translate="yes" xml:space="preserve">
          <source>Blocks until the provided time limit point is reached or a lock on &lt;code&gt;m&lt;/code&gt; is acquired.</source>
          <target state="translated">제공된 제한 시간에 도달하거나 &lt;code&gt;m&lt;/code&gt; 에 대한 잠금 이 획득 될 때까지 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="fb596caefce629504fd3a475f3183426b8a356e3" translate="yes" xml:space="preserve">
          <source>Blocks until the result becomes available. &lt;code&gt;valid() == true&lt;/code&gt; after the call.</source>
          <target state="translated">결과가 나올 때까지 차단합니다. 호출 후 &lt;code&gt;valid() == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="7bb852d637486dd2f9b852b32fe5bd9ba4fa4b63" translate="yes" xml:space="preserve">
          <source>Boolean conversions</source>
          <target state="translated">부울 변환</target>
        </trans-unit>
        <trans-unit id="c9a26dc7a812c76d486afec462ae9a205a68b3e6" translate="yes" xml:space="preserve">
          <source>Boolean literals</source>
          <target state="translated">부울 리터럴</target>
        </trans-unit>
        <trans-unit id="74e13cd703ad7a9a0db9e8fcedf7a2cbccdea7d3" translate="yes" xml:space="preserve">
          <source>Boolean negation operator</source>
          <target state="translated">부울 부정 연산자</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">부울 타입</target>
        </trans-unit>
        <trans-unit id="a14c6ec0166e69a3cf0be1f4ccc882e1dc773e55" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt; and &lt;a href=&quot;../../language/delete&quot;&gt;delete-expression&lt;/a&gt;, when used with objects whose alignment requirement is greater than &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, pass that alignment requirement as an argument of type &lt;code&gt;std::align_val_t&lt;/code&gt; to the selected allocation/deallocation function.</source>
          <target state="translated">모두 &lt;a href=&quot;../../language/new&quot;&gt;새로운 표현&lt;/a&gt; 및 &lt;a href=&quot;../../language/delete&quot;&gt;삭제 표현은&lt;/a&gt; , 그 정렬 조건보다 큰 객체에 사용될 때 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; , 형의 인수로 그 정렬 요구 사항을 전달 &lt;code&gt;std::align_val_t&lt;/code&gt; 선택된 할당 / 해제 함수.</target>
        </trans-unit>
        <trans-unit id="efa828bc8c6e261a85369b79ad278f982b80b478" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt; and &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt; declarations may appear with the &lt;code&gt;friend&lt;/code&gt; specifier in any non-local class or class template (although only function templates may be defined within the class or class template that is granting friendship). In this case, every specialization of the template becomes a friend, whether it is implicitly instantiated, partially specialized, or explicitly specialized.</source>
          <target state="translated">&lt;a href=&quot;function_template&quot;&gt;함수 템플릿&lt;/a&gt; 과 &lt;a href=&quot;class_template&quot;&gt;클래스 템플릿&lt;/a&gt; 선언은 모두 로컬이 아닌 클래스 또는 클래스 템플릿에서 &lt;code&gt;friend&lt;/code&gt; 지정 과 함께 나타날 수 있습니다 (함수는 우정을 부여하는 클래스 또는 클래스 템플릿 내에 정의 될 수 있지만). 이 경우 템플릿의 모든 전문화는 암시 적으로 인스턴스화되거나 부분적으로 전문화되거나 명시 적으로 전문화 되든 관계없이 친구가됩니다.</target>
        </trans-unit>
        <trans-unit id="63016d3fee2638a4d3429bfc299eeab7075b466b" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and the value zero indicate successful program execution status (see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;), although it is not required that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; equals zero.</source>
          <target state="translated">&lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 와 0 값은 모두 성공적인 프로그램 실행 상태를 나타냅니다 ( &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 참조 ) . &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 가 0 일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ff19dd1cff37c69bcf7f62a061f0632df661ad27" translate="yes" xml:space="preserve">
          <source>Both constructors (other than &lt;a href=&quot;copy_constructor&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_constructor&quot;&gt;move&lt;/a&gt;) and user-defined conversion functions may be function templates; the meaning of &lt;code&gt;explicit&lt;/code&gt; doesn't change.</source>
          <target state="translated">생성자 ( &lt;a href=&quot;copy_constructor&quot;&gt;복사&lt;/a&gt; / &lt;a href=&quot;move_constructor&quot;&gt;이동&lt;/a&gt; 이외 )와 사용자 정의 변환 함수는 모두 함수 템플릿 일 수 있습니다. &lt;code&gt;explicit&lt;/code&gt; 의미는 변하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b2dfd50c4fa7ea73355cbddda751f4dda04b1d2" translate="yes" xml:space="preserve">
          <source>Both constructors are protected, and are only called by the concrete streambuf classes, such as &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 생성자는 모두 보호되며 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 와 같은 콘크리트 streambuf 클래스에서만 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="a919957c7deab2ea5acd8f4154fbcf839bb6dac2" translate="yes" xml:space="preserve">
          <source>Both copy- and move-assignment operators for directory_entry are are defaulted.</source>
          <target state="translated">directory_entry에 대한 복사 및 이동 할당 연산자가 모두 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5bb05230f21307e6f1e1d771c4a72fefe561d481" translate="yes" xml:space="preserve">
          <source>Both scoped enumeration types and unscoped enumeration types whose underlying type is fixed can be initialized from an integer without a cast, using &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt;, if all of the following is true:</source>
          <target state="translated">범위가 지정된 열거 유형 및 기본 유형이 고정 된 범위가 지정되지 않은 열거 유형 은 다음 모두가 참인 경우 &lt;a href=&quot;list_initialization&quot;&gt;list initialize를&lt;/a&gt; 사용하여 캐스트없이 정수에서 초기화 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5deba5db9615b12e705c1e44fac1908355100dcb" translate="yes" xml:space="preserve">
          <source>Both single-object and array allocation functions may be defined as public static member functions of a class (versions (15-18)). If defined, these allocation functions are called by &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate memory for single objects and arrays of this class, unless the new expression used the form &lt;code&gt;::new&lt;/code&gt; which bypasses class-scope lookup. The keyword &lt;code&gt;static&lt;/code&gt; is optional for these functions: whether used or not, the allocation function is a static member function.</source>
          <target state="translated">단일 객체 및 배열 할당 함수는 모두 클래스의 공용 정적 멤버 함수 (버전 (15-18))로 정의 될 수 있습니다. 정의 된 경우, 새 표현식이 클래스 범위 조회를 우회하는 &lt;code&gt;::new&lt;/code&gt; 형식을 사용하지 않는 한 ,이 할당 함수는 &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt; 에 의해 호출 되어이 클래스의 단일 오브젝트 및 배열에 메모리를 할당합니다 . 키워드 &lt;code&gt;static&lt;/code&gt; 은이 함수에 대해 선택적입니다. 사용 여부에 관계없이 할당 함수는 정적 멤버 함수입니다.</target>
        </trans-unit>
        <trans-unit id="0028861eddd8245788364237b82fa610aebd0d8e" translate="yes" xml:space="preserve">
          <source>Both this function and the constructor of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; may be used to acquire temporary ownership of the managed object referred to by a &lt;code&gt;std::weak_ptr&lt;/code&gt;. The difference is that the constructor of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; throws an exception when its &lt;code&gt;std::weak_ptr&lt;/code&gt; argument is empty, while &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;::lock()&lt;/code&gt; constructs an empty &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수와 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 의 생성자 모두 &lt;code&gt;std::weak_ptr&lt;/code&gt; 에 의해 참조되는 관리 오브젝트의 임시 소유권을 확보하는 데 사용될 수 있습니다 . 차이점은 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 의 생성자가 std :: &lt;code&gt;std::weak_ptr&lt;/code&gt; 인수가 비어있는 경우 예외를 처리하는 반면 &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;::lock()&lt;/code&gt; 은 빈 &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 생성한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c71adfce132d82af6ce298cc94111b2a04e3c1ab" translate="yes" xml:space="preserve">
          <source>Both versions are constant expressions of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 버전 모두 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 유형의 상수 표현식입니다 .</target>
        </trans-unit>
        <trans-unit id="943facfd40f56533abfb37b73ee46c45ee23481a" translate="yes" xml:space="preserve">
          <source>Boyer-Moore search algorithm implementation</source>
          <target state="translated">보이어 무어 검색 알고리즘 구현</target>
        </trans-unit>
        <trans-unit id="498eeb65762b20bc8f5d61f62b5b2037e626f9c9" translate="yes" xml:space="preserve">
          <source>Boyer-Moore-Horspool search algorithm implementation</source>
          <target state="translated">Boyer-Moore-Horspool 검색 알고리즘 구현</target>
        </trans-unit>
        <trans-unit id="f87d9810eeab220cb3bd2cc07cbf939aafc31cb1" translate="yes" xml:space="preserve">
          <source>Brace-enclosed initializers</source>
          <target state="translated">괄호로 묶인 초기화</target>
        </trans-unit>
        <trans-unit id="014d790a3d5a9df8c0ff4408ebe540186f635544" translate="yes" xml:space="preserve">
          <source>Breaks the association of the associated mutex, if any, and &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">연관된 뮤텍스 (있는 경우)와 &lt;code&gt;*this&lt;/code&gt; 의 연관을 끊습니다 .</target>
        </trans-unit>
        <trans-unit id="c7dfd8323fd5e72ce649953eb9bbb100abdbf328" translate="yes" xml:space="preserve">
          <source>Broken pipe</source>
          <target state="translated">깨진 파이프</target>
        </trans-unit>
        <trans-unit id="e5817b915ebc6c65487325f1fad96d1830f9ec3a" translate="yes" xml:space="preserve">
          <source>Bucket index for the key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">키 &lt;code&gt;key&lt;/code&gt; 버킷 인덱스 .</target>
        </trans-unit>
        <trans-unit id="1578c16566abfd5ed0ac525177c29f906ca89176" translate="yes" xml:space="preserve">
          <source>Bucket interface</source>
          <target state="translated">버킷 인터페이스</target>
        </trans-unit>
        <trans-unit id="39da5ebcfeabc5cbfab75222627dd08adc0b92bb" translate="yes" xml:space="preserve">
          <source>Build level and violation handling</source>
          <target state="translated">빌드 레벨 및 위반 처리</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="5620451e3028694b641893b89d306b16dd893957" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;operator_comparison#Three-way_comparison&quot;&gt;three-way comparison operator&lt;/a&gt;</source>
          <target state="translated">내장 된 &lt;a href=&quot;operator_comparison#Three-way_comparison&quot;&gt;3 방향 비교 연산자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba57c0678fa197d58d012dcdbd8ff367ded4373c" translate="yes" xml:space="preserve">
          <source>Built-in address-of operator</source>
          <target state="translated">기본 제공 주소 연산자</target>
        </trans-unit>
        <trans-unit id="89c57ad877bc748c74e85159feaaf08e70f5f5a1" translate="yes" xml:space="preserve">
          <source>Built-in comma operator</source>
          <target state="translated">내장 쉼표 연산자</target>
        </trans-unit>
        <trans-unit id="29c41e2e5a519d072283f8900cfb2aecddea654d" translate="yes" xml:space="preserve">
          <source>Built-in function call operator</source>
          <target state="translated">내장 함수 호출 연산자</target>
        </trans-unit>
        <trans-unit id="6a837a52363a7caaa8043442690c260da71652ff" translate="yes" xml:space="preserve">
          <source>Built-in indirection operator</source>
          <target state="translated">내장 된 간접 연산자</target>
        </trans-unit>
        <trans-unit id="667f2d7df45e4a7b467abfa721de0d718054104f" translate="yes" xml:space="preserve">
          <source>Built-in member access operators</source>
          <target state="translated">내장 멤버 액세스 운영자</target>
        </trans-unit>
        <trans-unit id="76bd10380a7941d509b7c26c3c0d87d1eddae2bc" translate="yes" xml:space="preserve">
          <source>Built-in pointer-to-member access operators</source>
          <target state="translated">내장 포인터-투-멤버 액세스 연산자</target>
        </trans-unit>
        <trans-unit id="74faee7794760c0f5ba932d0cc3927a1f7c63af0" translate="yes" xml:space="preserve">
          <source>Built-in postfix operators</source>
          <target state="translated">붙박이 접미사 연산자</target>
        </trans-unit>
        <trans-unit id="c49aba310c5c949e131422dc6d86594cd3fd9999" translate="yes" xml:space="preserve">
          <source>Built-in prefix operators</source>
          <target state="translated">내장 접두사 연산자</target>
        </trans-unit>
        <trans-unit id="01e1dbd00564662647a6c23a14ae45eff862413d" translate="yes" xml:space="preserve">
          <source>Built-in subscript operator</source>
          <target state="translated">내장 첨자 연산자</target>
        </trans-unit>
        <trans-unit id="97de26f6f9f063ed744153d8d933e88e0b59a100" translate="yes" xml:space="preserve">
          <source>Builtin compound assignment</source>
          <target state="translated">내장 화합물 할당</target>
        </trans-unit>
        <trans-unit id="860269ba76f59f407f62610e614523ed6bb2b17c" translate="yes" xml:space="preserve">
          <source>Builtin direct assignment</source>
          <target state="translated">내장 된 직접 할당</target>
        </trans-unit>
        <trans-unit id="cd27a3b8b65f3e0b8397cd40fb51bd882218435c" translate="yes" xml:space="preserve">
          <source>Builtin operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; perform short-circuit evaluation (do not evaluate the second operand if the result is known after evaluating the first), but overloaded operators behave like regular function calls and always evaluate both operands</source>
          <target state="translated">내장 연산자 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 단락 평가 수행 (첫 번째 평가 후 결과가 알려진 경우 두 번째 피연산자를 평가하지 마십시오), 과부하 된 연산자는 일반 함수 호출처럼 동작하며 항상 두 피연산자를 모두 평가합니다</target>
        </trans-unit>
        <trans-unit id="05d591efb279e3a248c17303baf5ea55526a4063" translate="yes" xml:space="preserve">
          <source>But the same parameter cannot be given default arguments twice in the same scope.</source>
          <target state="translated">그러나 동일한 매개 변수에 동일한 범위에서 기본 인수를 두 번 부여 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae372236d69794d1162dbcde117c87725ee50599" translate="yes" xml:space="preserve">
          <source>By default (with the default &lt;code&gt;&lt;a href=&quot;../char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt;), this function is not locale-sensitive. See &lt;code&gt;&lt;a href=&quot;../../locale/collate/compare&quot;&gt;std::collate::compare&lt;/a&gt;&lt;/code&gt; for locale-aware three-way string comparison.</source>
          <target state="translated">기본적으로 (기본 &lt;code&gt;&lt;a href=&quot;../char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; )이 기능은 로케일에 민감하지 않습니다. 로케일 인식 3 방향 문자열 비교는 &lt;code&gt;&lt;a href=&quot;../../locale/collate/compare&quot;&gt;std::collate::compare&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3a260b7cae289fb8e1fb6ad3c38b354a5c26916" translate="yes" xml:space="preserve">
          <source>By default, all eight standard C++ streams are synchronized with their respective C streams.</source>
          <target state="translated">기본적으로 8 개의 표준 C ++ 스트림은 모두 해당 C 스트림과 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="ce023180676c6490743b29e9926007bad4819315" translate="yes" xml:space="preserve">
          <source>By default, symlinks are not followed, but this can be enabled by specifying the directory option &lt;a href=&quot;directory_options&quot;&gt;&lt;code&gt;follow_directory_symlink&lt;/code&gt;&lt;/a&gt; at construction time.</source>
          <target state="translated">기본적으로 심볼릭 링크는 따르지 않지만 생성시 디렉토리 옵션 &lt;a href=&quot;directory_options&quot;&gt; &lt;code&gt;follow_directory_symlink&lt;/code&gt; &lt;/a&gt; 를 지정하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0eb851d780be859c6cd08434ab3959f35e91fa13" translate="yes" xml:space="preserve">
          <source>By default, the standard streams &lt;code&gt;cin&lt;/code&gt; and &lt;code&gt;cerr&lt;/code&gt; are tied to &lt;code&gt;cout&lt;/code&gt;. Similarly, their wide counterparts &lt;code&gt;wcin&lt;/code&gt; and &lt;code&gt;wcerr&lt;/code&gt; are tied to &lt;code&gt;wcout&lt;/code&gt;.</source>
          <target state="translated">기본적으로 표준 스트림 &lt;code&gt;cin&lt;/code&gt; 및 &lt;code&gt;cerr&lt;/code&gt; 은 &lt;code&gt;cout&lt;/code&gt; 에 연결됩니다 . 마찬가지로 &lt;code&gt;wcin&lt;/code&gt; 과 &lt;code&gt;wcerr&lt;/code&gt; 의 넓은 상대 는 wcout 에 연결되어 &lt;code&gt;wcout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0541acf21651250dc0b8e2afd7f3da25009343a" translate="yes" xml:space="preserve">
          <source>By default, this will call placement-new, as by &lt;code&gt;::new((void*)p) T()&lt;/code&gt; (that is, &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialize&lt;/a&gt; the object pointed to by &lt;code&gt;p&lt;/code&gt;). If value-initialization is undesirable, for example, if the object is of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="translated">기본적으로 이것은 &lt;code&gt;::new((void*)p) T()&lt;/code&gt; 와 같이 Placement-new를 호출합니다 (즉, &lt;code&gt;p&lt;/code&gt; 가 가리키는 객체의 &lt;a href=&quot;../language/value_initialization&quot;&gt;값을 초기화 함&lt;/a&gt; ). 값 초기화가 바람직하지 않은 경우, 예를 들어 객체가 비 클래스 유형이고 0을 입력하지 않아도되는 경우 &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;사용자 지정 Allocator :: construct를&lt;/a&gt; 제공하면 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7803ee252527503b67d1eeb0deb252622746cebd" translate="yes" xml:space="preserve">
          <source>Byte</source>
          <target state="translated">Byte</target>
        </trans-unit>
        <trans-unit id="8e26337cf6bb10967dc0cb055379c6312a7a94ee" translate="yes" xml:space="preserve">
          <source>Byte/multibyte character</source>
          <target state="translated">바이트 / 멀티 바이트 문자</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="15c24806702abe5ea48e31ecde1d9e103ea60746" translate="yes" xml:space="preserve">
          <source>C &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; is not allowed.</source>
          <target state="translated">C &lt;a href=&quot;language_linkage&quot;&gt;언어 연결&lt;/a&gt; 은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09b5b3333cb4ff4683a9d0855cb7f956ff522e8f" translate="yes" xml:space="preserve">
          <source>C Date and time utilities</source>
          <target state="translated">C 날짜 및 시간 유틸리티</target>
        </trans-unit>
        <trans-unit id="1eca25182c934c202df4d629e6f313747250a6f1" translate="yes" xml:space="preserve">
          <source>C compatibility header.</source>
          <target state="translated">C 호환성 헤더.</target>
        </trans-unit>
        <trans-unit id="f27d46df9dc50736ed4e3b3843a69d430fee37b8" translate="yes" xml:space="preserve">
          <source>C compatibility headers</source>
          <target state="translated">C 호환성 헤더</target>
        </trans-unit>
        <trans-unit id="b75858e6f52757d42995120144302a816dcfb58b" translate="yes" xml:space="preserve">
          <source>C compatibility macro constant, expands to integer constant &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">C 호환성 매크로 상수, 정수 상수 &lt;code&gt;1&lt;/code&gt; 로 확장</target>
        </trans-unit>
        <trans-unit id="3a96bb87493004f593e10038ce1e6395886cc3ef" translate="yes" xml:space="preserve">
          <source>C library</source>
          <target state="translated">C 라이브러리</target>
        </trans-unit>
        <trans-unit id="085bb2391a15d3dae8b4fa9f82fd51d51923f45e" translate="yes" xml:space="preserve">
          <source>C library locales</source>
          <target state="translated">C 라이브러리 로캘</target>
        </trans-unit>
        <trans-unit id="401eb191196e5e41faa446684424f56e654762b8" translate="yes" xml:space="preserve">
          <source>C localization utilities</source>
          <target state="translated">C 현지화 유틸리티</target>
        </trans-unit>
        <trans-unit id="f247a737aad973565e0ba61f676327ab62c8b7fc" translate="yes" xml:space="preserve">
          <source>C memory management library</source>
          <target state="translated">C 메모리 관리 라이브러리</target>
        </trans-unit>
        <trans-unit id="726cf0d2d039a3d7cb20400e7f928d472fbf197c" translate="yes" xml:space="preserve">
          <source>C numeric limits interface</source>
          <target state="translated">C 수치 한계 인터페이스</target>
        </trans-unit>
        <trans-unit id="b970bd670bcff0b0de508ab26d86ee7e72402f93" translate="yes" xml:space="preserve">
          <source>C random library</source>
          <target state="translated">C 랜덤 라이브러리</target>
        </trans-unit>
        <trans-unit id="56b2ac8093b8f482b9514d65903de1ddffba1b90" translate="yes" xml:space="preserve">
          <source>C streams are objects of type &lt;code&gt;std::FILE&lt;/code&gt; that can only be accessed and manipulated through pointers of type &lt;code&gt;std::FILE*&lt;/code&gt; (Note: while it may be possible to create a local object of type &lt;code&gt;std::FILE&lt;/code&gt; by dereferencing and copying a valid &lt;code&gt;std::FILE*&lt;/code&gt;, using the address of such copy in the I/O functions is undefined behavior). Each C stream is associated with an external physical device (file, standard input stream, printer, serial port, etc).</source>
          <target state="translated">C 스트림 타입의 객체 &lt;code&gt;std::FILE&lt;/code&gt; 만 액세스하여 유형의 포인터를 통해 조작 할 수있는 &lt;code&gt;std::FILE*&lt;/code&gt; (주 : 유형의 로컬 객체 생성시킬 수 있지만 &lt;code&gt;std::FILE&lt;/code&gt; 간접 참조하고 복사하여 유효한 &lt;code&gt;std::FILE*&lt;/code&gt; , I / O 함수에서 이러한 사본의 주소를 사용하는 것은 정의되지 않은 동작입니다). 각 C 스트림은 외부 물리적 장치 (파일, 표준 입력 스트림, 프린터, 직렬 포트 등)와 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a6cb82dfe4668eb03399d738975e3f7f2a00e75b" translate="yes" xml:space="preserve">
          <source>C streams can be used for both unformatted and formatted input and output. They are locale-sensitive and may perform wide/multibyte conversions as necessary. Unlike C++ streams, where each stream is associated with its own locale, all C streams access the same locale object: the one most recently installed with &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;std::setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">C 스트림은 형식화되지 않은 형식의 입력 및 출력 모두에 사용할 수 있습니다. 로케일에 민감하며 필요에 따라 와이드 / 멀티 바이트 변환을 수행 할 수 있습니다. 각 스트림이 자체 로케일과 연관된 C ++ 스트림과 달리 모든 C 스트림은 동일한 로케일 오브젝트 ( &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;std::setlocale&lt;/a&gt;&lt;/code&gt; 가장 최근에 설치된 것)에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="79c384f1ba053ea6a78d8c958d790e56d9052ca1" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired category</source>
          <target state="translated">원하는 카테고리의 이름을 보유한 C 문자열</target>
        </trans-unit>
        <trans-unit id="437c617752c611b36293355138fcbc5720307f88" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired mapping.</source>
          <target state="translated">원하는 맵핑 이름을 보유한 C 문자열.</target>
        </trans-unit>
        <trans-unit id="136b0b9b8ee0529927aebb743b29982272ffa9e4" translate="yes" xml:space="preserve">
          <source>C&amp;amp;</source>
          <target state="translated">C&amp;amp;</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="2f6d341776b09562a2d3ff15e2b8fa6906d9644e" translate="yes" xml:space="preserve">
          <source>C++ (and C) source code may be written in any non-ASCII 7-bit character set that includes the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646:1983&lt;/a&gt; invariant character set. However, several C++ operators and punctuators require characters that are outside of the ISO 646 codeset: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt;. To be able to use character encodings where some or all of these symbols do not exist (such as the German &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt;), C++ defines the following alternatives composed of ISO 646 compatible characters.</source>
          <target state="translated">C ++ (및 C) 소스 코드는 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646 : 1983&lt;/a&gt; 불변 문자 세트 를 포함하는 비 ASCII 7 비트 문자 세트로 작성 될 수 있습니다 . 그러나 여러 C ++ 연산자와 문장 부호에는 ISO 646 코드 세트 ( &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt; 외부의 문자가 필요합니다 . 이러한 기호 중 일부 또는 전부가 존재하지 않는 경우 (예 : 독일어 &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt; ) 문자 인코딩을 사용할 수 있도록 C ++은 ISO 646 호환 문자로 구성된 다음 대안을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3c7d95b436ecd68b95eaa98a87bac58f93c37e6b" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types&quot;&gt;E.14&lt;/a&gt;</source>
          <target state="translated">C ++ 핵심 지침 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types&quot;&gt;E.14&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cd612f2751329bbc16fee8f0091854df9f6031e" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e15-catch-exceptions-from-a-hierarchy-by-reference&quot;&gt;E.15&lt;/a&gt;</source>
          <target state="translated">C ++ 핵심 지침 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e15-catch-exceptions-from-a-hierarchy-by-reference&quot;&gt;E.15&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98881b02a247b26f94eb74fc06a45d722e646dd5" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i10-use-exceptions-to-signal-a-failure-to-perform-a-required-task&quot;&gt;I.10&lt;/a&gt;</source>
          <target state="translated">C ++ 핵심 지침 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i10-use-exceptions-to-signal-a-failure-to-perform-a-required-task&quot;&gt;I.10&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8be3e815f49596e499ad72b4130d9ecd2f1b149" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines E.6 &quot;Use RAII to prevent leaks&quot;</source>
          <target state="translated">C ++ 핵심 지침 E.6 &quot;RAII를 사용하여 누출 방지&quot;</target>
        </trans-unit>
        <trans-unit id="147230a86e1c7e0bef8e1878444e4fbcc383fa96" translate="yes" xml:space="preserve">
          <source>C++ Operator Precedence</source>
          <target state="translated">C ++ 연산자 우선 순위</target>
        </trans-unit>
        <trans-unit id="c31eca9ef3dcd7526b7195249185a9729b743830" translate="yes" xml:space="preserve">
          <source>C++ Programming Language</source>
          <target state="translated">C ++ 프로그래밍 언어</target>
        </trans-unit>
        <trans-unit id="e7e7bcbec1050d7f0d883fbb8bc2748f84236f39" translate="yes" xml:space="preserve">
          <source>C++ also includes the &lt;a href=&quot;io/c&quot;&gt; input/output functions defined by C&lt;/a&gt;, such as &lt;code&gt;&lt;a href=&quot;io/c/fopen&quot;&gt;std::fopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/c/fgetc&quot;&gt;std::getc&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">C ++에는 &lt;code&gt;&lt;a href=&quot;io/c/fopen&quot;&gt;std::fopen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io/c/fgetc&quot;&gt;std::getc&lt;/a&gt;&lt;/code&gt; 등 &lt;a href=&quot;io/c&quot;&gt;C&lt;/a&gt; 에 의해 정의 된 입력 / 출력 함수 도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="06557fdbe17d2e091891cc63144b53692b2f4c27" translate="yes" xml:space="preserve">
          <source>C++ attribute: carries_dependency (since C++11)</source>
          <target state="translated">C ++ 속성 : carry_dependency (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="3a80c78aa3d0be4365d4a4aace53df1894fafefe" translate="yes" xml:space="preserve">
          <source>C++ attribute: deprecated (since C++14)</source>
          <target state="translated">C ++ 속성 : 더 이상 사용되지 않음 (C ++ 14부터)</target>
        </trans-unit>
        <trans-unit id="ad4b4ad5889a95c53ae7ededcaefccd580e10788" translate="yes" xml:space="preserve">
          <source>C++ attribute: expects, ensures, assert (C++20)</source>
          <target state="translated">C ++ 속성 : 기대, 보장, 주장 (C ++ 20)</target>
        </trans-unit>
        <trans-unit id="1f01e78c670736bcfbc7cbb131e20f9036aefa35" translate="yes" xml:space="preserve">
          <source>C++ attribute: fallthrough (since C++17)</source>
          <target state="translated">C ++ 속성 : 폴 스루 (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="a55af33c93fad900d8f3c516df19e406f43533ff" translate="yes" xml:space="preserve">
          <source>C++ attribute: likely, unlikely (since C++20)</source>
          <target state="translated">C ++ 속성 : 가능성이 낮음 (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="69ebed955bad0cdef08a090954f7632df7b64103" translate="yes" xml:space="preserve">
          <source>C++ attribute: maybe_unused (since C++17)</source>
          <target state="translated">C ++ 속성 : maybe_unused (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="127add9901453ff701417a6b814f3ecc1b88d1ac" translate="yes" xml:space="preserve">
          <source>C++ attribute: no_unique_address (since C++20)</source>
          <target state="translated">C ++ 속성 : no_unique_address (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="f9e91b3dd1ac40fbbb8928fd5021a1da6124dcb0" translate="yes" xml:space="preserve">
          <source>C++ attribute: nodiscard (since C++17)</source>
          <target state="translated">C ++ 속성 : nodiscard (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="1f8de489858717f3061b65d4e3dae9adad203d70" translate="yes" xml:space="preserve">
          <source>C++ attribute: noreturn (since C++11)</source>
          <target state="translated">C ++ 속성 : noreturn (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="387814363c5c1f906d9da1e85cb5bc67e4f38c05" translate="yes" xml:space="preserve">
          <source>C++ attribute: optimize_for_synchronized (TM TS)</source>
          <target state="translated">C ++ 속성 : optimize_for_synchronized (TM TS)</target>
        </trans-unit>
        <trans-unit id="4583aeee6b4e07e7a7eb1f6b99f908d66bf96f40" translate="yes" xml:space="preserve">
          <source>C++ defines several function objects that represent common arithmetic and logical operations:</source>
          <target state="translated">C ++는 일반적인 산술 및 논리 연산을 나타내는 여러 함수 객체를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c67f57f6a26a137cf9bc71e8f9c5a5af0559e777" translate="yes" xml:space="preserve">
          <source>C++ includes a variety of utility libraries that provide functionality ranging from &lt;a href=&quot;utility/bitset&quot;&gt;bit-counting&lt;/a&gt; to &lt;a href=&quot;utility/functional/bind&quot;&gt;partial function application&lt;/a&gt;. These libraries can be broadly divided into two groups:</source>
          <target state="translated">C ++에는 &lt;a href=&quot;utility/bitset&quot;&gt;비트 카운팅&lt;/a&gt; 에서 &lt;a href=&quot;utility/functional/bind&quot;&gt;부분 함수 애플리케이션에&lt;/a&gt; 이르는 기능을 제공하는 다양한 유틸리티 라이브러리가 포함되어 있습니다. 이 라이브러리는 크게 두 그룹으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76aad39fcff3282441a6d5280586f60940cc31a5" translate="yes" xml:space="preserve">
          <source>C++ includes built-in support for threads, mutual exclusion, condition variables, and futures.</source>
          <target state="translated">C ++에는 스레드, 상호 배제, 조건 변수 및 미래에 대한 지원 기능이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3934f659aacbf1f001d3645344748b8c444cd791" translate="yes" xml:space="preserve">
          <source>C++ includes support for two types of time manipulation:</source>
          <target state="translated">C ++에는 두 가지 유형의 시간 조작이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="92a2c968a34da23e4708e71892c2ffb721fa839a" translate="yes" xml:space="preserve">
          <source>C++ includes the following types of statements:</source>
          <target state="translated">C ++에는 다음 유형의 명령문이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="49dd66f99c3d0ac54dc62b7ee7eb01eca487493b" translate="yes" xml:space="preserve">
          <source>C++ includes two input/output libraries: a modern, stream-based I/O library and the standard set of C-style I/O functions.</source>
          <target state="translated">C ++에는 현대식 스트림 기반 I / O 라이브러리와 표준 C 스타일 I / O 함수 세트의 두 가지 입력 / 출력 라이브러리가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0e04efcb6a316f4e833950df1ac7962ec66959a" translate="yes" xml:space="preserve">
          <source>C++ keywords</source>
          <target state="translated">C ++ 키워드</target>
        </trans-unit>
        <trans-unit id="3aee0b831c4708d12c9406617e0cc1e8018f2d74" translate="yes" xml:space="preserve">
          <source>C++ keywords: alignas (since C++11)</source>
          <target state="translated">C ++ 키워드 : alignas (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="29507b9a59ffc6150615d0d338bd1beb939dfad0" translate="yes" xml:space="preserve">
          <source>C++ keywords: alignof (since C++11)</source>
          <target state="translated">C ++ 키워드 : alignof (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="183b1dcdba07c3b1be4b49fab102e89c9a7de240" translate="yes" xml:space="preserve">
          <source>C++ keywords: and</source>
          <target state="translated">C ++ 키워드 : 및</target>
        </trans-unit>
        <trans-unit id="3a6e38d19cc3dc2909a3faa576f245fdf6217690" translate="yes" xml:space="preserve">
          <source>C++ keywords: and_eq</source>
          <target state="translated">C ++ 키워드 : and_eq</target>
        </trans-unit>
        <trans-unit id="124a64afaa6c8c5bfca6047dd460511a6b97db33" translate="yes" xml:space="preserve">
          <source>C++ keywords: asm</source>
          <target state="translated">C ++ 키워드 : asm</target>
        </trans-unit>
        <trans-unit id="a0612d43a8ba92fee978df18206be3adce6458fa" translate="yes" xml:space="preserve">
          <source>C++ keywords: audit (since C++20)</source>
          <target state="translated">C ++ 키워드 : 감사 (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="b2ccdccd648a0f0a224169f56af64c5a94ea2b07" translate="yes" xml:space="preserve">
          <source>C++ keywords: auto</source>
          <target state="translated">C ++ 키워드 : 자동</target>
        </trans-unit>
        <trans-unit id="526ec64f9498eb1229f0b99304e24893a3786743" translate="yes" xml:space="preserve">
          <source>C++ keywords: axiom (since C++20)</source>
          <target state="translated">C ++ 키워드 : 공리 (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="163810b967745c12225f305e7e817d651df13205" translate="yes" xml:space="preserve">
          <source>C++ keywords: bitand</source>
          <target state="translated">C ++ 키워드 : bitand</target>
        </trans-unit>
        <trans-unit id="05bce8999813ae5f7d868f68ce64fcade539f423" translate="yes" xml:space="preserve">
          <source>C++ keywords: bitor</source>
          <target state="translated">C ++ 키워드 : bitor</target>
        </trans-unit>
        <trans-unit id="ba78f8f4b5950d9d7ebfc170c7afd751c59bdc1f" translate="yes" xml:space="preserve">
          <source>C++ keywords: bool</source>
          <target state="translated">C ++ 키워드 : bool</target>
        </trans-unit>
        <trans-unit id="d69d38c5fa6d513f4ee223cae0f80ada3cf1eb0b" translate="yes" xml:space="preserve">
          <source>C++ keywords: break</source>
          <target state="translated">C ++ 키워드 : 중단</target>
        </trans-unit>
        <trans-unit id="1b869375d71945d8fecb773bf590ce8095cc4588" translate="yes" xml:space="preserve">
          <source>C++ keywords: case</source>
          <target state="translated">C ++ 키워드 : 사례</target>
        </trans-unit>
        <trans-unit id="a7c81faed45b85c8dcd86de0734ee278e34df717" translate="yes" xml:space="preserve">
          <source>C++ keywords: catch</source>
          <target state="translated">C ++ 키워드 : catch</target>
        </trans-unit>
        <trans-unit id="fb289f167e01192a7926393875a6c8672f6c6f9e" translate="yes" xml:space="preserve">
          <source>C++ keywords: char</source>
          <target state="translated">C ++ 키워드 : char</target>
        </trans-unit>
        <trans-unit id="eacf79f3f8a785c01bc0ce19bb78a42fbe110d2b" translate="yes" xml:space="preserve">
          <source>C++ keywords: char16_t (since C++11)</source>
          <target state="translated">C ++ 키워드 : char16_t (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="d42a327c13fbb384479588185d9a50190dde3cf8" translate="yes" xml:space="preserve">
          <source>C++ keywords: char32_t (since C++11)</source>
          <target state="translated">C ++ 키워드 : char32_t (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="e2545bdc74a2da147dd1af1123e6aa8edbc09e87" translate="yes" xml:space="preserve">
          <source>C++ keywords: char8_t (since C++20)</source>
          <target state="translated">C ++ 키워드 : char8_t (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="c2ebb8c0d088a0587ab8ccaeece91bd9e176a491" translate="yes" xml:space="preserve">
          <source>C++ keywords: class</source>
          <target state="translated">C ++ 키워드 : 클래스</target>
        </trans-unit>
        <trans-unit id="29b898e1bb17af4eedf763c0844dd1fbb1bdd22d" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_await</source>
          <target state="translated">C ++ 키워드 : co_await</target>
        </trans-unit>
        <trans-unit id="16a636816ed7f754d904e9002adf34e537a3bbfa" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_return</source>
          <target state="translated">C ++ 키워드 : co_return</target>
        </trans-unit>
        <trans-unit id="33bc95e36c6779fdbd2d85867f4c0f747ae853fe" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_yield</source>
          <target state="translated">C ++ 키워드 : co_yield</target>
        </trans-unit>
        <trans-unit id="01848e98ae4887d344100accfb0dc0f687fda24d" translate="yes" xml:space="preserve">
          <source>C++ keywords: compl</source>
          <target state="translated">C ++ 키워드 : compl</target>
        </trans-unit>
        <trans-unit id="6f9e6b0ca42a7a44125068643d4aeacd6ed22adc" translate="yes" xml:space="preserve">
          <source>C++ keywords: concept</source>
          <target state="translated">C ++ 키워드 : 개념</target>
        </trans-unit>
        <trans-unit id="26d8438420078942bafe0fcabb0f3a9ff8f21c57" translate="yes" xml:space="preserve">
          <source>C++ keywords: const</source>
          <target state="translated">C ++ 키워드 : const</target>
        </trans-unit>
        <trans-unit id="69601052b6f31cbc68f401b4565ce386a65a23c2" translate="yes" xml:space="preserve">
          <source>C++ keywords: const_cast</source>
          <target state="translated">C ++ 키워드 : const_cast</target>
        </trans-unit>
        <trans-unit id="bf6dfea8cb8956898c49e4b94e6e3b12224c1209" translate="yes" xml:space="preserve">
          <source>C++ keywords: consteval</source>
          <target state="translated">C ++ 키워드 : consteval</target>
        </trans-unit>
        <trans-unit id="527aef1fbeeb02aed3a5fdbfc85d582ce0f515aa" translate="yes" xml:space="preserve">
          <source>C++ keywords: constexpr (since C++11)</source>
          <target state="translated">C ++ 키워드 : constexpr (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="395fd0f15c5d8fac44a7288a59ea5a86379a156b" translate="yes" xml:space="preserve">
          <source>C++ keywords: continue</source>
          <target state="translated">C ++ 키워드 : 계속</target>
        </trans-unit>
        <trans-unit id="36bf9192492d110977874a62802f3f0cbf1c7005" translate="yes" xml:space="preserve">
          <source>C++ keywords: decltype</source>
          <target state="translated">C ++ 키워드 : decltype</target>
        </trans-unit>
        <trans-unit id="f30dc791d0616219ea0defdde70ed1cfef4ff5c8" translate="yes" xml:space="preserve">
          <source>C++ keywords: default</source>
          <target state="translated">C ++ 키워드 : 기본값</target>
        </trans-unit>
        <trans-unit id="94d1f98ddc77ffbdfd69b93ceca8b8d435110d3c" translate="yes" xml:space="preserve">
          <source>C++ keywords: delete</source>
          <target state="translated">C ++ 키워드 : 삭제</target>
        </trans-unit>
        <trans-unit id="2fec1767b7b69a4a327e04a5a4c3a4f27379bdd2" translate="yes" xml:space="preserve">
          <source>C++ keywords: do</source>
          <target state="translated">C ++ 키워드 : do</target>
        </trans-unit>
        <trans-unit id="7bafac1a9bd6cde00b59ed3cdcbd753151e0a51a" translate="yes" xml:space="preserve">
          <source>C++ keywords: double</source>
          <target state="translated">C ++ 키워드 : double</target>
        </trans-unit>
        <trans-unit id="0b4a595b8bfbe949f6ca15f733e9e13331a42383" translate="yes" xml:space="preserve">
          <source>C++ keywords: dynamic_cast</source>
          <target state="translated">C ++ 키워드 : dynamic_cast</target>
        </trans-unit>
        <trans-unit id="b32114b3f766f8a6739a7358915b26ea1b71457a" translate="yes" xml:space="preserve">
          <source>C++ keywords: else</source>
          <target state="translated">C ++ 키워드 : else</target>
        </trans-unit>
        <trans-unit id="9917c70089a8094b6d2fbb8e852e373f906a704b" translate="yes" xml:space="preserve">
          <source>C++ keywords: enum</source>
          <target state="translated">C ++ 키워드 : 열거 형</target>
        </trans-unit>
        <trans-unit id="d544a09b352faa3a994cc54ccff972a5a3cb000b" translate="yes" xml:space="preserve">
          <source>C++ keywords: explicit</source>
          <target state="translated">C ++ 키워드 : 명시 적</target>
        </trans-unit>
        <trans-unit id="3c3210a8eec85af05733531fd5df52b05cdd6aa9" translate="yes" xml:space="preserve">
          <source>C++ keywords: export</source>
          <target state="translated">C ++ 키워드 : 내보내기</target>
        </trans-unit>
        <trans-unit id="de55ab46e46dffbf77fad964ecd27e3f0d9ef421" translate="yes" xml:space="preserve">
          <source>C++ keywords: extern</source>
          <target state="translated">C ++ 키워드 : extern</target>
        </trans-unit>
        <trans-unit id="e57865b70fcda2180074588769785ddc1a36b1c4" translate="yes" xml:space="preserve">
          <source>C++ keywords: false</source>
          <target state="translated">C ++ 키워드 : false</target>
        </trans-unit>
        <trans-unit id="a700071e23581008cd76b45c2c69fea512ecb640" translate="yes" xml:space="preserve">
          <source>C++ keywords: final (since C++11)</source>
          <target state="translated">C ++ 키워드 : final (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="d02f9afd3fb00647e6a8e3424d891ceecd47fa78" translate="yes" xml:space="preserve">
          <source>C++ keywords: float</source>
          <target state="translated">C ++ 키워드 : float</target>
        </trans-unit>
        <trans-unit id="a5cd84453036526e60fa4e42dda9e069ff310fd3" translate="yes" xml:space="preserve">
          <source>C++ keywords: for</source>
          <target state="translated">C ++ 키워드 : for</target>
        </trans-unit>
        <trans-unit id="48f95d56f056fed8728e03635e48afcd5b420407" translate="yes" xml:space="preserve">
          <source>C++ keywords: friend</source>
          <target state="translated">C ++ 키워드 : 친구</target>
        </trans-unit>
        <trans-unit id="1e68fa94e046f072a7ff1b219e912a351a979625" translate="yes" xml:space="preserve">
          <source>C++ keywords: goto</source>
          <target state="translated">C ++ 키워드 : goto</target>
        </trans-unit>
        <trans-unit id="4725b0f2dcc6d3119ce93a5f3e3d49658b9f6ae7" translate="yes" xml:space="preserve">
          <source>C++ keywords: if</source>
          <target state="translated">C ++ 키워드 : if</target>
        </trans-unit>
        <trans-unit id="e499739fb3e6977144ad9e1eeb2e5bc4a8ddc540" translate="yes" xml:space="preserve">
          <source>C++ keywords: inline</source>
          <target state="translated">C ++ 키워드 : 인라인</target>
        </trans-unit>
        <trans-unit id="b3fd1b872d293865c0aefeed8e6183dd1c548684" translate="yes" xml:space="preserve">
          <source>C++ keywords: int</source>
          <target state="translated">C ++ 키워드 : int</target>
        </trans-unit>
        <trans-unit id="c27210515d0813a21164dfce05ea3be2f9ae3b66" translate="yes" xml:space="preserve">
          <source>C++ keywords: long</source>
          <target state="translated">C ++ 키워드 : long</target>
        </trans-unit>
        <trans-unit id="4d43f4cb276936dd386b3bd9758fc75c328cc95f" translate="yes" xml:space="preserve">
          <source>C++ keywords: mutable</source>
          <target state="translated">C ++ 키워드 : 가변</target>
        </trans-unit>
        <trans-unit id="b02800bd96f0d61d78a098b7b68899cdbbd6afe6" translate="yes" xml:space="preserve">
          <source>C++ keywords: namespace</source>
          <target state="translated">C ++ 키워드 : 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="4f9a52b4836fa43713e1e3fa4d56214068cc8def" translate="yes" xml:space="preserve">
          <source>C++ keywords: new</source>
          <target state="translated">C ++ 키워드 : 새로운</target>
        </trans-unit>
        <trans-unit id="9c0ca031ba0d25429ecf94970709e58032f30ab8" translate="yes" xml:space="preserve">
          <source>C++ keywords: noexcept (since C++11)</source>
          <target state="translated">C ++ 키워드 : noexcept (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="c89b31c825167c40b35e37235a165123fdf5b4e4" translate="yes" xml:space="preserve">
          <source>C++ keywords: not</source>
          <target state="translated">C ++ 키워드 : 아닙니다</target>
        </trans-unit>
        <trans-unit id="3cc0c7490348f3b3ba14089762bd72de7bd639ce" translate="yes" xml:space="preserve">
          <source>C++ keywords: not_eq</source>
          <target state="translated">C ++ 키워드 : not_eq</target>
        </trans-unit>
        <trans-unit id="b19ba534185a30e68c38be176f0412bc1f2bc6b5" translate="yes" xml:space="preserve">
          <source>C++ keywords: nullptr (since C++11)</source>
          <target state="translated">C ++ 키워드 : nullptr (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="70814bfe02a7af8b95ce36bc95a7da1123095a6a" translate="yes" xml:space="preserve">
          <source>C++ keywords: operator</source>
          <target state="translated">C ++ 키워드 : 연산자</target>
        </trans-unit>
        <trans-unit id="c23df376605d78f63a5500160b48ee512157ad7c" translate="yes" xml:space="preserve">
          <source>C++ keywords: or</source>
          <target state="translated">C ++ 키워드 : 또는</target>
        </trans-unit>
        <trans-unit id="d20cac1ee4d77d9ffa9e5793ad0383aa3ad51475" translate="yes" xml:space="preserve">
          <source>C++ keywords: or_eq</source>
          <target state="translated">C ++ 키워드 : or_eq</target>
        </trans-unit>
        <trans-unit id="8a0293371d55246ce973ae3e75626127f1504b6a" translate="yes" xml:space="preserve">
          <source>C++ keywords: override (since C++11)</source>
          <target state="translated">C ++ 키워드 : 재정의 (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="03786ae3b9f628796529d09b809dbfc8b46793fe" translate="yes" xml:space="preserve">
          <source>C++ keywords: private</source>
          <target state="translated">C ++ 키워드 : 개인</target>
        </trans-unit>
        <trans-unit id="df7d4ea5bc32cb787a6f750294cd5227c2fcd0d1" translate="yes" xml:space="preserve">
          <source>C++ keywords: protected</source>
          <target state="translated">C ++ 키워드 : protected</target>
        </trans-unit>
        <trans-unit id="bfab844551173e61ef5a9ab220a29b66c69734b6" translate="yes" xml:space="preserve">
          <source>C++ keywords: public</source>
          <target state="translated">C ++ 키워드 : 공개</target>
        </trans-unit>
        <trans-unit id="1f1f72ef9a8c96008d1a90280fd58c243aa19f0b" translate="yes" xml:space="preserve">
          <source>C++ keywords: register</source>
          <target state="translated">C ++ 키워드 : 등록</target>
        </trans-unit>
        <trans-unit id="cd98a0128d90a9233e207ec1405b9a7e57585055" translate="yes" xml:space="preserve">
          <source>C++ keywords: reinterpret_cast</source>
          <target state="translated">C ++ 키워드 : reinterpret_cast</target>
        </trans-unit>
        <trans-unit id="e57ca4acf8809388dce3238247eb7aa0f55ae138" translate="yes" xml:space="preserve">
          <source>C++ keywords: requires</source>
          <target state="translated">C ++ 키워드 : 필수</target>
        </trans-unit>
        <trans-unit id="1abcca2b0e66ee60c977a4e5782dd98d5b4d457d" translate="yes" xml:space="preserve">
          <source>C++ keywords: return</source>
          <target state="translated">C ++ 키워드 : return</target>
        </trans-unit>
        <trans-unit id="4b1adaad1115bcff0759ad4794ff292ed78b3c23" translate="yes" xml:space="preserve">
          <source>C++ keywords: short</source>
          <target state="translated">C ++ 키워드 : short</target>
        </trans-unit>
        <trans-unit id="7bd3bfdfb2f3297c5564232cb8f3314290cdc7cf" translate="yes" xml:space="preserve">
          <source>C++ keywords: signed</source>
          <target state="translated">C ++ 키워드 : signed</target>
        </trans-unit>
        <trans-unit id="4ff280c7a565563348f26be8d65133c336d662d3" translate="yes" xml:space="preserve">
          <source>C++ keywords: sizeof</source>
          <target state="translated">C ++ 키워드 : sizeof</target>
        </trans-unit>
        <trans-unit id="1a6d44df359c5334d919f430e3f3a4ac0d088d64" translate="yes" xml:space="preserve">
          <source>C++ keywords: static</source>
          <target state="translated">C ++ 키워드 : 정적</target>
        </trans-unit>
        <trans-unit id="94bea4546792cb644fbf90e8a6f9c16d09f62ef3" translate="yes" xml:space="preserve">
          <source>C++ keywords: static_assert (since C++11)</source>
          <target state="translated">C ++ 키워드 : static_assert (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="72096556dc877cb5f85ffd02a8ca80027a3dd3aa" translate="yes" xml:space="preserve">
          <source>C++ keywords: static_cast</source>
          <target state="translated">C ++ 키워드 : static_cast</target>
        </trans-unit>
        <trans-unit id="b2fb75279739ad8e2dec4f932c10feab705444ec" translate="yes" xml:space="preserve">
          <source>C++ keywords: struct</source>
          <target state="translated">C ++ 키워드 : struct</target>
        </trans-unit>
        <trans-unit id="1d55fcffd470c877223faca7c22ebb0001352b9e" translate="yes" xml:space="preserve">
          <source>C++ keywords: switch</source>
          <target state="translated">C ++ 키워드 : 스위치</target>
        </trans-unit>
        <trans-unit id="8a86cf3a93c4b52678e6d0617edc0697e04f2ca0" translate="yes" xml:space="preserve">
          <source>C++ keywords: template</source>
          <target state="translated">C ++ 키워드 : 템플릿</target>
        </trans-unit>
        <trans-unit id="917e6e9b4ef5b0862e8ac7fdc4490ad8424f619e" translate="yes" xml:space="preserve">
          <source>C++ keywords: this</source>
          <target state="translated">C ++ 키워드 : this</target>
        </trans-unit>
        <trans-unit id="7be930465dc63b127e9244e46b51e76cf2df9d25" translate="yes" xml:space="preserve">
          <source>C++ keywords: thread_local (since C++11)</source>
          <target state="translated">C ++ 키워드 : thread_local (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="b6e56566966d5710214d6f3ea6c95ab6c44200df" translate="yes" xml:space="preserve">
          <source>C++ keywords: throw</source>
          <target state="translated">C ++ 키워드 : 던지기</target>
        </trans-unit>
        <trans-unit id="0044cc96e436f4b21ecd72cd8dfbd5e16f91d829" translate="yes" xml:space="preserve">
          <source>C++ keywords: true</source>
          <target state="translated">C ++ 키워드 : true</target>
        </trans-unit>
        <trans-unit id="98ac0c70a9cb341c8cd03989ea0fb7d75b0bb05a" translate="yes" xml:space="preserve">
          <source>C++ keywords: try</source>
          <target state="translated">C ++ 키워드 : 시도</target>
        </trans-unit>
        <trans-unit id="ef86b57182f4ee052964937a9ab5e68c63c4ce5f" translate="yes" xml:space="preserve">
          <source>C++ keywords: typedef</source>
          <target state="translated">C ++ 키워드 : typedef</target>
        </trans-unit>
        <trans-unit id="454d53b90b0b8d7c3a3e8ad398ac791969143134" translate="yes" xml:space="preserve">
          <source>C++ keywords: typeid</source>
          <target state="translated">C ++ 키워드 : typeid</target>
        </trans-unit>
        <trans-unit id="f09f8d522055844ed39f38a10e8d3068231112c5" translate="yes" xml:space="preserve">
          <source>C++ keywords: typename</source>
          <target state="translated">C ++ 키워드 : typename</target>
        </trans-unit>
        <trans-unit id="e9cfe8a8699032565be2259c78cf9cf21c03061f" translate="yes" xml:space="preserve">
          <source>C++ keywords: union</source>
          <target state="translated">C ++ 키워드 : 공용체</target>
        </trans-unit>
        <trans-unit id="3a2039a0d25e07bab54ea79e32cbb688dd58e12e" translate="yes" xml:space="preserve">
          <source>C++ keywords: unsigned</source>
          <target state="translated">C ++ 키워드 : 서명되지 않은</target>
        </trans-unit>
        <trans-unit id="8471d9f4d77d2e5eb14371c1da076716f02eaa32" translate="yes" xml:space="preserve">
          <source>C++ keywords: using</source>
          <target state="translated">C ++ 키워드 : using</target>
        </trans-unit>
        <trans-unit id="ca2d0f00321b8103f435fd2b14b1924abd2dfb05" translate="yes" xml:space="preserve">
          <source>C++ keywords: virtual</source>
          <target state="translated">C ++ 키워드 : 가상</target>
        </trans-unit>
        <trans-unit id="624f83b1ecef18ff894e0bb447112f9f3014800a" translate="yes" xml:space="preserve">
          <source>C++ keywords: void</source>
          <target state="translated">C ++ 키워드 : void</target>
        </trans-unit>
        <trans-unit id="f78e5cc4134b90e370b281fe8d44693b1ec58e36" translate="yes" xml:space="preserve">
          <source>C++ keywords: volatile</source>
          <target state="translated">C ++ 키워드 : 일시적</target>
        </trans-unit>
        <trans-unit id="9c61c84d1b44e56098d4c56e5048e58138e3fbc7" translate="yes" xml:space="preserve">
          <source>C++ keywords: wchar_t</source>
          <target state="translated">C ++ 키워드 : wchar_t</target>
        </trans-unit>
        <trans-unit id="2c909f57896904cc34b1cc4e253dd5d79ed3ab7b" translate="yes" xml:space="preserve">
          <source>C++ keywords: while</source>
          <target state="translated">C ++ 키워드 : while</target>
        </trans-unit>
        <trans-unit id="7b74b5079b0e1bc6b6d3a9df3f3dcaf748b4fdf4" translate="yes" xml:space="preserve">
          <source>C++ keywords: xor</source>
          <target state="translated">C ++ 키워드 : xor</target>
        </trans-unit>
        <trans-unit id="eb3705de2bf421a4730d1843c818dc31e4324286" translate="yes" xml:space="preserve">
          <source>C++ keywords: xor_eq</source>
          <target state="translated">C ++ 키워드 : xor_eq</target>
        </trans-unit>
        <trans-unit id="00d4296327feae05e7f754006f1f81e7b3df74e7" translate="yes" xml:space="preserve">
          <source>C++ language</source>
          <target state="translated">C ++ 언어</target>
        </trans-unit>
        <trans-unit id="5c6e1f137cae8deef2fe086c3a40c23cb3abd95c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Allocator</source>
          <target state="translated">C ++ 명명 된 요구 사항 : 할당 자</target>
        </trans-unit>
        <trans-unit id="68093762465efd54450ba8bcd9c0a91c4dbf0f1b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: AllocatorAwareContainer</source>
          <target state="translated">C ++ 명명 요구 사항 : AllocatorAwareContainer</target>
        </trans-unit>
        <trans-unit id="ab7ac32bec349da4c19ab2096d1b1255564f39b0" translate="yes" xml:space="preserve">
          <source>C++ named requirements: AssociativeContainer</source>
          <target state="translated">C ++ 명명 요구 사항 : AssociativeContainer</target>
        </trans-unit>
        <trans-unit id="bce38a21c7a5a1ec76fbe77837afdf562ff1649d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BasicLockable</source>
          <target state="translated">C ++ 명명 요구 사항 : BasicLockable</target>
        </trans-unit>
        <trans-unit id="e1a9abc4c52e314d687b58fdfa28003600137949" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BinaryPredicate</source>
          <target state="translated">C ++ 명명 요구 사항 : BinaryPredicate</target>
        </trans-unit>
        <trans-unit id="77f706b668a619259c5204b16d231a4b5f303147" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BinaryTypeTrait</source>
          <target state="translated">C ++ 명명 요구 사항 : BinaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="2dac169f409edf4d6004eeef2aa80e3ce234acba" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BitmaskType</source>
          <target state="translated">C ++ 명명 요구 사항 : BitmaskType</target>
        </trans-unit>
        <trans-unit id="3ac90618765ee9c85f861c53f0604fe5b1bece8f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Callable</source>
          <target state="translated">C ++ 명명 요구 사항 : 호출 가능</target>
        </trans-unit>
        <trans-unit id="ee45309ee631f97e8c54fdd32dd4c7314a219410" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CharTraits</source>
          <target state="translated">C ++ 명명 요구 사항 : CharTraits</target>
        </trans-unit>
        <trans-unit id="e49e0b2de04ceaac02567e3c466ce7f34aa9139b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Clock</source>
          <target state="translated">C ++ 명명 요구 사항 : 시계</target>
        </trans-unit>
        <trans-unit id="03d4cd85a40261a51658ef8d686e3877be8fb96e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Compare</source>
          <target state="translated">C ++ 명명 된 요구 사항 : 비교</target>
        </trans-unit>
        <trans-unit id="ac0da8de55de872e9c67b652831ec7e483b09c3b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ConstexprIterator</source>
          <target state="translated">C ++ 명명 요구 사항 : ConstexprIterator</target>
        </trans-unit>
        <trans-unit id="d0267fe31b3826841ff7251625998f2fcb06717e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Container</source>
          <target state="translated">C ++ 명명 요구 사항 : 컨테이너</target>
        </trans-unit>
        <trans-unit id="cf843c7d6d3dc3a137cc532583586f04e6c312a3" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ContiguousContainer</source>
          <target state="translated">C ++ 명명 된 요구 사항 : ContiguousContainer</target>
        </trans-unit>
        <trans-unit id="8f039fec7eb71a74ef921bce40ef720e3e7301f7" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyAssignable</source>
          <target state="translated">C ++ 명명 요구 사항 : CopyAssignable</target>
        </trans-unit>
        <trans-unit id="a5a5a4d38564c8be046908e5b71fa8fc1c5617c2" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyConstructible</source>
          <target state="translated">C ++ 명명 요구 사항 : CopyConstructible</target>
        </trans-unit>
        <trans-unit id="8a6121d6fc5b64e9265c4080e5c5342c8e2ea499" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyInsertable</source>
          <target state="translated">C ++ 명명 요구 사항 : CopyInsertable</target>
        </trans-unit>
        <trans-unit id="e0410f086a810b23ccfa34f4b0166c8fba23f310" translate="yes" xml:space="preserve">
          <source>C++ named requirements: DefaultConstructible</source>
          <target state="translated">C ++ 명명 요구 사항 : DefaultConstructible</target>
        </trans-unit>
        <trans-unit id="a0e9c4ff46f14ebb3f87a8006d8b76bdc0d3803b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: DefaultInsertable</source>
          <target state="translated">C ++ 명명 된 요구 사항 : DefaultInsertable</target>
        </trans-unit>
        <trans-unit id="5f0c828f8de0769b3ee1f87f72ae6283f03e4208" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Destructible</source>
          <target state="translated">C ++ 명명 요구 사항 : 파괴 가능</target>
        </trans-unit>
        <trans-unit id="a3846bfd4ceb5970ead3569546441faa22d6f618" translate="yes" xml:space="preserve">
          <source>C++ named requirements: EmplaceConstructible (since C++11)</source>
          <target state="translated">C ++ 명명 요구 사항 : EmplaceConstructible (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="0f00c016cd8d60c879ed8f11a065a6cdb2245c1a" translate="yes" xml:space="preserve">
          <source>C++ named requirements: EqualityComparable</source>
          <target state="translated">C ++ 명명 요구 사항 : EqualityComparable</target>
        </trans-unit>
        <trans-unit id="a4bdf57055cd7c0dae92592574976fad30e86740" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Erasable</source>
          <target state="translated">C ++ 명명 요구 사항 : 지우기</target>
        </trans-unit>
        <trans-unit id="c9dce4c90e1ab07bd8e4f26bfd59c7bb93d2c13b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FormattedInputFunction</source>
          <target state="translated">C ++ 명명 요구 사항 : FormattedInputFunction</target>
        </trans-unit>
        <trans-unit id="78390db68319248607d73e238aa034d36af5547e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FormattedOutputFunction</source>
          <target state="translated">C ++ 명명 된 요구 사항 : FormattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="17341909637487f66a0a51420af28ebc0ff53f17" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FunctionObject</source>
          <target state="translated">C ++ 명명 된 요구 사항 : FunctionObject</target>
        </trans-unit>
        <trans-unit id="83eafac0e33fd85d404291ef083b29a6c21e4bd5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Hash</source>
          <target state="translated">C ++ 명명 요구 사항 : 해시</target>
        </trans-unit>
        <trans-unit id="b7114351c4bbaa9528560ef257598f798ddb3de5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyBidirectionalIterator</source>
          <target state="translated">C ++ 명명 요구 사항 : LegacyBidirectionalIterator</target>
        </trans-unit>
        <trans-unit id="333591b546d46f2b2872fef1e1d696156e3d4da4" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyContiguousIterator</source>
          <target state="translated">C ++ 명명 된 요구 사항 : LegacyContiguousIterator</target>
        </trans-unit>
        <trans-unit id="49fdc557343b56a30b7a499efbbea9f6e8d5ea27" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyForwardIterator</source>
          <target state="translated">C ++ 명명 요구 사항 : LegacyForwardIterator</target>
        </trans-unit>
        <trans-unit id="b0ca593d796d2c1f1cdfea5aaaa5bcc718fed510" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyInputIterator</source>
          <target state="translated">C ++ 명명 요구 사항 : LegacyInputIterator</target>
        </trans-unit>
        <trans-unit id="daac43c9c4fb82513fe27e3efbdb288f38305a58" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyIterator</source>
          <target state="translated">C ++ 명명 요구 사항 : LegacyIterator</target>
        </trans-unit>
        <trans-unit id="491d2d06bd47da0deeddf998db8a57451119a47e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyOutputIterator</source>
          <target state="translated">C ++ 명명 요구 사항 : LegacyOutputIterator</target>
        </trans-unit>
        <trans-unit id="2bae53a7d3573b63c5126a51eeda215a90f01f27" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyRandomAccessIterator</source>
          <target state="translated">C ++ 명명 요구 사항 : LegacyRandomAccessIterator</target>
        </trans-unit>
        <trans-unit id="234fc9eae136300c3a84df869801ddac1bc39e85" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LessThanComparable</source>
          <target state="translated">C ++ 명명 요구 사항 : LessThanComparable</target>
        </trans-unit>
        <trans-unit id="fa488eac6c38cb8817603703df4bd4bc17b5bc3c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LiteralType</source>
          <target state="translated">C ++ 명명 요구 사항 : LiteralType</target>
        </trans-unit>
        <trans-unit id="7e27d143c2848bfc04da8fa00c12fc56eba98a8f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Lockable</source>
          <target state="translated">C ++ 명명 요구 사항 : 잠금 가능</target>
        </trans-unit>
        <trans-unit id="ffa229dee12fb9a9290b1083466a57ea9ef88cb2" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveAssignable (since C++11)</source>
          <target state="translated">C ++ 명명 요구 사항 : MoveAssignable (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="3c7af72e00db75b25a6339c6bc85b14f40833ea5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveConstructible (since C++11)</source>
          <target state="translated">C ++ 명명 요구 사항 : MoveConstructible (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="596d45856032c8c30536491e6532eb33250543a6" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveInsertable (since C++11)</source>
          <target state="translated">C ++ 명명 요구 사항 : MoveInsertable (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="1c772f99ba3b1d592fe8bec17544a1e701895811" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Mutex</source>
          <target state="translated">C ++ 명명 요구 사항 : Mutex</target>
        </trans-unit>
        <trans-unit id="e88a54faa0bd94e7b4c8d3cd5b28da3afb45b924" translate="yes" xml:space="preserve">
          <source>C++ named requirements: NullablePointer (since C++11)</source>
          <target state="translated">C ++ 명명 요구 사항 : NullablePointer (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="dc4469e68ff2c5b54f8ee6d9e3f309ac6b21c5bb" translate="yes" xml:space="preserve">
          <source>C++ named requirements: NumericType</source>
          <target state="translated">C ++ 명명 요구 사항 : NumericType</target>
        </trans-unit>
        <trans-unit id="c535b9a77f5571dd0ffba42bac2b8d4ab54373c3" translate="yes" xml:space="preserve">
          <source>C++ named requirements: PODType</source>
          <target state="translated">C ++ 명명 요구 사항 : PODType</target>
        </trans-unit>
        <trans-unit id="f8a0530ac14d26f5e08f4d837ff5542a4988b36d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Predicate</source>
          <target state="translated">C ++ 명명 된 요구 사항 : 술어</target>
        </trans-unit>
        <trans-unit id="84db291a7430e53241b723b9cdb6f5c57cf85f43" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberDistribution</source>
          <target state="translated">C ++ 명명 된 요구 사항 : RandomNumberDistribution</target>
        </trans-unit>
        <trans-unit id="16dd49ad42be796cea9fe6814de48219bd526a22" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberEngine</source>
          <target state="translated">C ++ 명명 요구 사항 : RandomNumberEngine</target>
        </trans-unit>
        <trans-unit id="57db25a8dd2fe59f88627a14f0d9f4454923652f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberEngineAdaptor</source>
          <target state="translated">C ++ 명명 된 요구 사항 : RandomNumberEngineAdaptor</target>
        </trans-unit>
        <trans-unit id="ada05a46bb39c300a568907c930d2a57c5b9005d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RegexTraits</source>
          <target state="translated">C ++ 명명 요구 사항 : RegexTraits</target>
        </trans-unit>
        <trans-unit id="016355c7ec2c0cd838b6de26f8a355d0c2f26913" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ReversibleContainer</source>
          <target state="translated">C ++ 명명 요구 사항 : ReversibleContainer</target>
        </trans-unit>
        <trans-unit id="19a660b52b4b8c99460cfc9a560b03a16cf9cb42" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SeedSequence</source>
          <target state="translated">C ++ 명명 요구 사항 : SeedSequence</target>
        </trans-unit>
        <trans-unit id="331ae8b25a90d44993d56e79517cc81206e0068d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SequenceContainer</source>
          <target state="translated">C ++ 명명 요구 사항 : SequenceContainer</target>
        </trans-unit>
        <trans-unit id="5f9909d09bcc4eb0bdaada38cd2e514913d23668" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SharedMutex</source>
          <target state="translated">C ++ 명명 요구 사항 : SharedMutex</target>
        </trans-unit>
        <trans-unit id="f60730295a5aa0cd12e4416e599d5f966530ef4d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SharedTimedMutex</source>
          <target state="translated">C ++ 명명 요구 사항 : SharedTimedMutex</target>
        </trans-unit>
        <trans-unit id="d03f73195120ea59f692bd306fc14c4f75ddea6e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: StandardLayoutType</source>
          <target state="translated">C ++ 명명 요구 사항 : StandardLayoutType</target>
        </trans-unit>
        <trans-unit id="7c2afe9643847a18800f6549859cddf158aebfc0" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Swappable</source>
          <target state="translated">C ++ 명명 요구 사항 : 교환 가능</target>
        </trans-unit>
        <trans-unit id="2699ee8a713e7d4efdc2e45280ccf4b85602bf33" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TimedLockable</source>
          <target state="translated">C ++ 명명 요구 사항 : TimedLockable</target>
        </trans-unit>
        <trans-unit id="e4b09ebf2a8a166fe825d2ef813341e3cf6c00c4" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TimedMutex</source>
          <target state="translated">C ++ 명명 요구 사항 : TimedMutex</target>
        </trans-unit>
        <trans-unit id="0f87af6136487f4529c077f27de7397f9b71930c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TransformationTrait</source>
          <target state="translated">C ++ 명명 요구 사항 : TransformationTrait</target>
        </trans-unit>
        <trans-unit id="90ecc6e1cfa9c37cd7a9058209da8423a4e1b338" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TrivialClock</source>
          <target state="translated">C ++ 명명 요구 사항 : TrivialClock</target>
        </trans-unit>
        <trans-unit id="6e4be673e637f57a59a671d691fed257e408bde7" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TrivialType</source>
          <target state="translated">C ++ 명명 요구 사항 : TrivialType</target>
        </trans-unit>
        <trans-unit id="547fb3490fe494ac4547d562d1e3a4efcf9201ea" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TriviallyCopyable</source>
          <target state="translated">C ++ 명명 요구 사항 : TriviallyCopyable</target>
        </trans-unit>
        <trans-unit id="5dbb493f4749a745c93c18f6210f4d60d51e03a6" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnaryTypeTrait</source>
          <target state="translated">C ++ 명명 요구 사항 : UnaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="4994b5268d59d59fba759c4ba742ecf79924693a" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnformattedInputFunction</source>
          <target state="translated">C ++ 명명 된 요구 사항 : UnformattedInputFunction</target>
        </trans-unit>
        <trans-unit id="d5d9e9fb8d202091be5c90998db3426e13ad8496" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnformattedOutputFunction</source>
          <target state="translated">C ++ 명명 된 요구 사항 : UnformattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="6e75c2aeea843d06f31a9ca2caeb62946537533d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UniformRandomBitGenerator</source>
          <target state="translated">C ++ 명명 요구 사항 : UniformRandomBitGenerator</target>
        </trans-unit>
        <trans-unit id="87ad5436e94ce7e8b55c4f29d6f5a45aad21cf59" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnorderedAssociativeContainer</source>
          <target state="translated">C ++ 명명 요구 사항 : UnorderAssociativeContainer</target>
        </trans-unit>
        <trans-unit id="15fe7066a6555232e049a6b5ae3a3b40fcc5e98b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ValueSwappable</source>
          <target state="translated">C ++ 명명 요구 사항 : ValueSwappable</target>
        </trans-unit>
        <trans-unit id="bb6995247feeb0031e28871e5d52bb0bde2f6ab2" translate="yes" xml:space="preserve">
          <source>C++ pragmas in Visual Studio 2015</source>
          <target state="translated">Visual Studio 2015의 C ++ pragma</target>
        </trans-unit>
        <trans-unit id="7b72da128624ab00dbe11304128e495f5b161352" translate="yes" xml:space="preserve">
          <source>C++ programs create, destroy, refer to, access, and manipulate</source>
          <target state="translated">C ++ 프로그램은 작성, 파괴, 참조, 액세스 및 조작</target>
        </trans-unit>
        <trans-unit id="cc223fe085208876202452b5634bdb87b28fe03f" translate="yes" xml:space="preserve">
          <source>C++ standard</source>
          <target state="translated">C ++ 표준</target>
        </trans-unit>
        <trans-unit id="1a70571302b7aef91f6a1709d3bff98dbbe103cc" translate="yes" xml:space="preserve">
          <source>C++ time utilites</source>
          <target state="translated">C ++ 시간 활용</target>
        </trans-unit>
        <trans-unit id="4ae06f5fc59967a95d7d2edd41265fb164cde198" translate="yes" xml:space="preserve">
          <source>C++ type system overview</source>
          <target state="translated">C ++ 타입 시스템 개요</target>
        </trans-unit>
        <trans-unit id="59267432adf8c9336c020edab8c6d1687c5a8555" translate="yes" xml:space="preserve">
          <source>C++-style</source>
          <target state="translated">C++-style</target>
        </trans-unit>
        <trans-unit id="741b2c379deb40170659b19eb9ef222dbd5fa167" translate="yes" xml:space="preserve">
          <source>C++-style comments are usually used to comment single lines, however, multiple C++-style comments can be placed together to form multi-line comments. C++-style comments tell the compiler to ignore all content between &lt;code&gt;//&lt;/code&gt; and a new line.</source>
          <target state="translated">C ++ 스타일 주석은 일반적으로 한 줄 주석에 사용되지만 여러 C ++ 스타일 주석을 함께 배치하여 여러 줄 주석을 구성 할 수 있습니다. C ++ 스타일의 주석은 &lt;code&gt;//&lt;/code&gt; 와 줄 바꿈 사이의 모든 내용을 무시하도록 컴파일러에 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="59fa0388313caf4655070a0038f68ffbc408c139" translate="yes" xml:space="preserve">
          <source>C++03</source>
          <target state="translated">C++03</target>
        </trans-unit>
        <trans-unit id="afd7c0601f217ac99e680979ea51cdb99e023353" translate="yes" xml:space="preserve">
          <source>C++03 POD with deleted non-trivial assignment was not trivial</source>
          <target state="translated">사소하지 않은 할당이 삭제 된 C ++ 03 POD가 사소하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d030954e126ef3cc7aa28e489ff18c492566d17e" translate="yes" xml:space="preserve">
          <source>C++03 standard (ISO/IEC 14882:2003):</source>
          <target state="translated">C ++ 03 표준 (ISO / IEC 14882 : 2003) :</target>
        </trans-unit>
        <trans-unit id="aa182f32a2b889bab8bb654d1c6efd34ac494dd1" translate="yes" xml:space="preserve">
          <source>C++11</source>
          <target state="translated">C++11</target>
        </trans-unit>
        <trans-unit id="eb6204614cbf77403cd382a95e0f929788c6393d" translate="yes" xml:space="preserve">
          <source>C++11 (class type)</source>
          <target state="translated">C ++ 11 (클래스 타입)</target>
        </trans-unit>
        <trans-unit id="bca730909e080a8fc13db2273be471dfdb358b21" translate="yes" xml:space="preserve">
          <source>C++11 standard (ISO/IEC 14882:2011):</source>
          <target state="translated">C ++ 11 표준 (ISO / IEC 14882 : 2011) :</target>
        </trans-unit>
        <trans-unit id="526d8c7b1c46f07481431485812086e8bde79cad" translate="yes" xml:space="preserve">
          <source>C++14</source>
          <target state="translated">C++14</target>
        </trans-unit>
        <trans-unit id="3cf652fe8eeb36408d7f957624dd1e5feb276abf" translate="yes" xml:space="preserve">
          <source>C++14 (void)</source>
          <target state="translated">C ++ 14 (void)</target>
        </trans-unit>
        <trans-unit id="451b62af75ef22e7c1ee3794a50c6a6c3fdd7f7e" translate="yes" xml:space="preserve">
          <source>C++14 standard (ISO/IEC 14882:2014):</source>
          <target state="translated">C ++ 14 표준 (ISO / IEC 14882 : 2014) :</target>
        </trans-unit>
        <trans-unit id="69ae287a1096db334e322d2404e3cd62fc5f7016" translate="yes" xml:space="preserve">
          <source>C++17</source>
          <target state="translated">C++17</target>
        </trans-unit>
        <trans-unit id="4c20ccb3f39c8ffe021987c4ad44fbb012e0262a" translate="yes" xml:space="preserve">
          <source>C++17 standard (ISO/IEC 14882:2017):</source>
          <target state="translated">C ++ 17 표준 (ISO / IEC 14882 : 2017) :</target>
        </trans-unit>
        <trans-unit id="9f0db8e1214a8ccf376f0bc5ba61385a18fbb5cc" translate="yes" xml:space="preserve">
          <source>C++20 defines a set of &lt;a href=&quot;../language/constraints&quot;&gt;constrained&lt;/a&gt; comparison function objects. The equality operators (&lt;code&gt;ranges::equal_to&lt;/code&gt; and &lt;code&gt;ranges::not_equal_to&lt;/code&gt;) require the types of the arguments to model &lt;a href=&quot;../concepts/equalitycomparable&quot;&gt;&lt;code&gt;EqualityComparableWith&lt;/code&gt;&lt;/a&gt;. The relational operators (&lt;code&gt;ranges::less&lt;/code&gt;, &lt;code&gt;ranges::greater&lt;/code&gt;, &lt;code&gt;ranges::less_equal&lt;/code&gt;, and &lt;code&gt;ranges::greater_equal&lt;/code&gt;) require the types of the arguments to model &lt;a href=&quot;../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C ++ 20은 일련의 &lt;a href=&quot;../language/constraints&quot;&gt;제한된&lt;/a&gt; 비교 함수 객체를 정의 합니다. 항등 연산자 ( &lt;code&gt;ranges::equal_to&lt;/code&gt; 및 &lt;code&gt;ranges::not_equal_to&lt;/code&gt; )에는 &lt;a href=&quot;../concepts/equalitycomparable&quot;&gt; &lt;code&gt;EqualityComparableWith&lt;/code&gt; &lt;/a&gt; 를 모델링하기위한 인수 유형이 필요합니다 . 관계 연산자 ( &lt;code&gt;ranges::less&lt;/code&gt; , &lt;code&gt;ranges::greater&lt;/code&gt; , &lt;code&gt;ranges::less_equal&lt;/code&gt; 및 &lt;code&gt;ranges::greater_equal&lt;/code&gt; )에는 &lt;a href=&quot;../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt; 를 모델링하기위한 인수 유형이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="05eb29d2d943895480cbf23e5a4b02a727a6e2db" translate="yes" xml:space="preserve">
          <source>C++20 introduces a new system of iterators based on &lt;a href=&quot;language/constraints&quot;&gt;concepts&lt;/a&gt; that are different from C++17 iterators. While the basic taxonomy remains similar, the requirements for individual iterator categories are somewhat different.</source>
          <target state="translated">C ++ 20 은 C ++ 17 반복자와는 다른 &lt;a href=&quot;language/constraints&quot;&gt;개념&lt;/a&gt; 을 기반으로하는 새로운 반복기 시스템을 소개 합니다. 기본 분류법은 비슷하지만 개별 반복자 범주에 대한 요구 사항은 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2e528f3cc4d3fc3ca8b281cef54dbb5b071d694e" translate="yes" xml:space="preserve">
          <source>C++20 iterator concepts</source>
          <target state="translated">C ++ 20 반복자 개념</target>
        </trans-unit>
        <trans-unit id="098b2706a0a08c620a10641456b665a828dbc0fa" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;../language/constraints&quot;&gt;constrained&lt;/a&gt; versions of most algorithms in the namespace &lt;code&gt;std::ranges&lt;/code&gt;. In these algorithms, a range can be specified as either a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;-&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt;&lt;/a&gt; pair or as a single &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument, and projections and pointer-to-member callables are supported. Additionally, the return type of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm.</source>
          <target state="translated">C ++ 20은 네임 스페이스 &lt;code&gt;std::ranges&lt;/code&gt; 에서 대부분의 알고리즘의 &lt;a href=&quot;../language/constraints&quot;&gt;제한된&lt;/a&gt; 버전을 제공 합니다 . 이 알고리즘에서 범위는 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; - &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Sentinel&lt;/code&gt; &lt;/a&gt; 쌍 또는 단일 &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 인수 로 지정 될 수 있으며 투영 및 멤버 간 호출 가능 항목이 지원됩니다. 또한 대부분의 알고리즘의 반환 유형은 알고리즘을 실행하는 동안 계산 된 잠재적으로 유용한 모든 정보를 반환하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="1e947bf13606a87a8b5513ba351822e6dad8eca6" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;language/constraints&quot;&gt;constrained&lt;/a&gt; uninitialized memory algorithms that accept range arguments or iterator-sentinel pairs.</source>
          <target state="translated">C ++ 20은 범위 인수 또는 반복자-센티넬 쌍을 허용 하는 &lt;a href=&quot;language/constraints&quot;&gt;제한된&lt;/a&gt; 초기화되지 않은 메모리 알고리즘을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="02dac318248d623e3712f39050dab4b9f4c60683" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;language/constraints&quot;&gt;constrained&lt;/a&gt; versions of most algorithms in the namespace &lt;code&gt;std::ranges&lt;/code&gt;. In these algorithms, a range can be specified as either an &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;-&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt;&lt;/a&gt; pair or as a single &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument, and projections and pointer-to-member callables are supported. Additionally, the return types of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm.</source>
          <target state="translated">C ++ 20은 네임 스페이스 &lt;code&gt;std::ranges&lt;/code&gt; 에서 대부분의 알고리즘의 &lt;a href=&quot;language/constraints&quot;&gt;제한된&lt;/a&gt; 버전을 제공 합니다 . 이 알고리즘에서 범위는 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; - &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Sentinel&lt;/code&gt; &lt;/a&gt; 쌍 또는 단일 &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 인수 로 지정 될 수 있으며 투영 및 멤버 간 호출 가능 항목이 지원됩니다. 또한 대부분의 알고리즘의 반환 유형은 알고리즘을 실행하는 동안 계산 된 잠재적으로 유용한 모든 정보를 반환하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="b22ed7e9c883004117343b0e71726914a2fd2287" translate="yes" xml:space="preserve">
          <source>C++98</source>
          <target state="translated">C++98</target>
        </trans-unit>
        <trans-unit id="ba0489b5be9b76c42ad4405b0950fd7062f9aa6d" translate="yes" xml:space="preserve">
          <source>C++98 standard (ISO/IEC 14882:1998):</source>
          <target state="translated">C ++ 98 표준 (ISO / IEC 14882 : 1998) :</target>
        </trans-unit>
        <trans-unit id="f192047d0579fa733e3007a4b4927c4192eec128" translate="yes" xml:space="preserve">
          <source>C, but C precedes A in the single total order C-E-F-A of &lt;code&gt;memory_order_seq_cst&lt;/code&gt; (see &lt;a href=&quot;https://plv.mpi-sws.org/scfix/paper.pdf&quot;&gt;Lahav et al&lt;/a&gt;).</source>
          <target state="translated">C, 그러나 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 의 단일 총 차수 CEFA에서 C가 A보다 우선합니다 ( &lt;a href=&quot;https://plv.mpi-sws.org/scfix/paper.pdf&quot;&gt;Lahav et al&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f56f539774c9129a13109892792a99de9ce3ec15" translate="yes" xml:space="preserve">
          <source>C-string or char array to use as the contents of the stream</source>
          <target state="translated">스트림의 내용으로 사용할 C- 문자열 또는 char 배열</target>
        </trans-unit>
        <trans-unit id="bd39761895022d52ef2184edffb0689497519cb3" translate="yes" xml:space="preserve">
          <source>C-style</source>
          <target state="translated">C-style</target>
        </trans-unit>
        <trans-unit id="7526d60a0c8e276994609ec345feddbe30ee8465" translate="yes" xml:space="preserve">
          <source>C-style &lt;a href=&quot;string/multibyte&quot;&gt; Unicode character conversion functions&lt;/a&gt;</source>
          <target state="translated">C 스타일 &lt;a href=&quot;string/multibyte&quot;&gt;유니 코드 문자 변환 기능&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56a020c22140d662b6720ea7925672fd8f454173" translate="yes" xml:space="preserve">
          <source>C-style IO</source>
          <target state="translated">C 스타일 IO</target>
        </trans-unit>
        <trans-unit id="44c1448ec5b283e6541ef6028da691d71017b995" translate="yes" xml:space="preserve">
          <source>C-style cast</source>
          <target state="translated">C 스타일 캐스트</target>
        </trans-unit>
        <trans-unit id="c2150e9d35b98ece63e7d4b63009872a56f2d872" translate="yes" xml:space="preserve">
          <source>C-style cast expression</source>
          <target state="translated">C 스타일 캐스트 표현</target>
        </trans-unit>
        <trans-unit id="c663a9e8a239cedd93c5da9c15d557da154de974" translate="yes" xml:space="preserve">
          <source>C-style comments are usually used to comment large blocks of text, however, they can be used to comment single lines. To insert a C-style comment, simply surround text with &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;; this will cause the contents of the comment to be ignored by the compiler. Although it is not part of the C++ standard, &lt;code&gt;/**&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment. C-style comments cannot be nested.</source>
          <target state="translated">C 스타일 주석은 일반적으로 큰 텍스트 블록을 주석으로 사용하지만 한 줄을 주석으로 표시하는 데 사용할 수 있습니다. C 스타일 주석을 삽입하려면 &lt;code&gt;/*&lt;/code&gt; 및 &lt;code&gt;*/&lt;/code&gt; 로 텍스트를 둘러싸십시오 . 이로 인해 주석 내용이 컴파일러에서 무시됩니다. C ++ 표준의 일부는 아니지만 &lt;code&gt;/**&lt;/code&gt; 및 &lt;code&gt;*/&lt;/code&gt; 는 종종 문서 블록을 나타내는 데 사용됩니다. 이것은 두 번째 별표가 단순히 주석의 일부로 취급되기 때문에 합법적입니다. C 스타일 주석은 중첩 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="48253fbd0ad94c130de734e904780378dbaf86ae" translate="yes" xml:space="preserve">
          <source>C-style date and time library</source>
          <target state="translated">C 스타일 날짜 및 시간 라이브러리</target>
        </trans-unit>
        <trans-unit id="2f7dc08f72f32281ebb854326effae89b085e12d" translate="yes" xml:space="preserve">
          <source>C-style date and time library (e.g. &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">C 스타일 날짜 및 시간 라이브러리 (예 : &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f58953ee114042660a40fb46cdbb6561045fdd9e" translate="yes" xml:space="preserve">
          <source>C-style file input/output</source>
          <target state="translated">C 스타일 파일 입력 / 출력</target>
        </trans-unit>
        <trans-unit id="ee69eba17157f0bd643ab8f69127f0bbfedd84dc" translate="yes" xml:space="preserve">
          <source>C-style input-output functions</source>
          <target state="translated">C 스타일 입출력 기능</target>
        </trans-unit>
        <trans-unit id="78e1709449ee6d0679c98c9e988b4d20f58cb3c2" translate="yes" xml:space="preserve">
          <source>C-style memory management</source>
          <target state="translated">C 스타일 메모리 관리</target>
        </trans-unit>
        <trans-unit id="b3df26bb0867d25f5ab994e73d5725e15e0b58b0" translate="yes" xml:space="preserve">
          <source>C-style time/date utilites</source>
          <target state="translated">C 스타일 시간 / 날짜 유틸리티</target>
        </trans-unit>
        <trans-unit id="52aea3b6618c4eb66aee74f7ff3b04621de74570" translate="yes" xml:space="preserve">
          <source>C-style variadic functions</source>
          <target state="translated">C 스타일의 가변 함수</target>
        </trans-unit>
        <trans-unit id="24fc58ea2f98cd20a27008421ec7f7e3dfc35435" translate="yes" xml:space="preserve">
          <source>CHAR_BIT</source>
          <target state="translated">CHAR_BIT</target>
        </trans-unit>
        <trans-unit id="725f72738449b33d5ed2db35158ace2f646b043c" translate="yes" xml:space="preserve">
          <source>CHAR_MAX</source>
          <target state="translated">CHAR_MAX</target>
        </trans-unit>
        <trans-unit id="b30c9342a5465cef0a56934460b3bfa4e2e74c49" translate="yes" xml:space="preserve">
          <source>CHAR_MIN</source>
          <target state="translated">CHAR_MIN</target>
        </trans-unit>
        <trans-unit id="c820f67f5827175c8c204a8b983dc8a39b93cac1" translate="yes" xml:space="preserve">
          <source>CIRCLED DIGIT ONE - NEGATIVE CIRCLED DIGIT ZERO</source>
          <target state="translated">CIRCLED DIGIT ONE-네거티브 CIRCLED DIGIT ZERO</target>
        </trans-unit>
        <trans-unit id="fff8f67cf9fc327818272d81ae72e6f4b9164d0a" translate="yes" xml:space="preserve">
          <source>CJK COMPATIBILITY IDEOGRAPH-F900 - ARABIC LIGATURE ALEF WITH FATHATAN ISOLATED FORM</source>
          <target state="translated">CJK 호환성 IDEOGRAPH-F900-FATHATAN ISOLATED 형식의 아랍어 합자</target>
        </trans-unit>
        <trans-unit id="190e1ea5952f0d388e456800d46304578b3a93e8" translate="yes" xml:space="preserve">
          <source>CJK RADICAL REPEAT - IDEOGRAPHIC DESCRIPTION CHARACTER OVERLAID</source>
          <target state="translated">CJK 라디 컬 반복-사상 설명 문자 오버레이</target>
        </trans-unit>
        <trans-unit id="789b032a45d264e7a02138bff69b47aacb370fca" translate="yes" xml:space="preserve">
          <source>CLOCKS_PER_SEC</source>
          <target state="translated">CLOCKS_PER_SEC</target>
        </trans-unit>
        <trans-unit id="8b6654ec4bc3d0c514cc6e4b4ad72a0db37a1444" translate="yes" xml:space="preserve">
          <source>COMBINING DOTTED GRAVE ACCENT - COMBINING RIGHT ARROWHEAD AND DOWN ARROWHEAD BELOW</source>
          <target state="translated">결합 된 무덤 악세사리 결합-오른쪽 화살표 키와 아래쪽 화살표 키 조합</target>
        </trans-unit>
        <trans-unit id="714ab47a0e6f413b3bf281d1f4cbe410847fe7f1" translate="yes" xml:space="preserve">
          <source>COMBINING GRAVE ACCENT - COMBINING LATIN SMALL LETTER X</source>
          <target state="translated">콤비네이션 그레이브 악센트-콤팩트 라틴 라틴 문자 X</target>
        </trans-unit>
        <trans-unit id="35575c776ae958fb9883f5bf9ba9b6cfaf676fb9" translate="yes" xml:space="preserve">
          <source>COMBINING LEFT HARPOON ABOVE - COMBINING ASTERISK ABOVE</source>
          <target state="translated">왼쪽 작살 조합-위의 별표 결합</target>
        </trans-unit>
        <trans-unit id="7febb4b03096c80654f363847dc95a2cfb84fefe" translate="yes" xml:space="preserve">
          <source>COMBINING LIGATURE LEFT HALF - COMBINING CYRILLIC TITLO RIGHT HALF</source>
          <target state="translated">결합 합자 왼쪽 절반-순환 시탈 오른쪽 오른쪽 절반 결합</target>
        </trans-unit>
        <trans-unit id="9560447a54fd74d0cf86900665e48394b8c2274d" translate="yes" xml:space="preserve">
          <source>CPL</source>
          <target state="translated">CPL</target>
        </trans-unit>
        <trans-unit id="b24be71613a88ae74ef2222af07f1f8532a2eb06" translate="yes" xml:space="preserve">
          <source>CRTP</source>
          <target state="translated">CRTP</target>
        </trans-unit>
        <trans-unit id="a59d9bcee7f8794c67d0f8eaac8b827616f73808" translate="yes" xml:space="preserve">
          <source>CTAD</source>
          <target state="translated">CTAD</target>
        </trans-unit>
        <trans-unit id="47563e02f34b97527aa11cd2660b1c531f28a7a0" translate="yes" xml:space="preserve">
          <source>CWG 1213</source>
          <target state="translated">CWG 1213</target>
        </trans-unit>
        <trans-unit id="4b2c33f3b2901add653231f28b9837371837d438" translate="yes" xml:space="preserve">
          <source>CWG 1301</source>
          <target state="translated">CWG 1301</target>
        </trans-unit>
        <trans-unit id="6ffd78fdcfc97704227c81ed211b654ae584f03c" translate="yes" xml:space="preserve">
          <source>CWG 1313</source>
          <target state="translated">CWG 1313</target>
        </trans-unit>
        <trans-unit id="e72262c1f7923c69acd5b6e632a6ea0b0ee13223" translate="yes" xml:space="preserve">
          <source>CWG 1315</source>
          <target state="translated">CWG 1315</target>
        </trans-unit>
        <trans-unit id="74b12783757c5081b7fb53b3cd6b878928af8eae" translate="yes" xml:space="preserve">
          <source>CWG 1391</source>
          <target state="translated">CWG 1391</target>
        </trans-unit>
        <trans-unit id="d9e49fbd701bbcdc956dcedc347ee4c2dab0f2ed" translate="yes" xml:space="preserve">
          <source>CWG 1394</source>
          <target state="translated">CWG 1394</target>
        </trans-unit>
        <trans-unit id="4fb7724609c8a8b0dcca0bada49c63e843cf4195" translate="yes" xml:space="preserve">
          <source>CWG 1395</source>
          <target state="translated">CWG 1395</target>
        </trans-unit>
        <trans-unit id="7154988f61117199c76a049798a28cf90de02420" translate="yes" xml:space="preserve">
          <source>CWG 1397</source>
          <target state="translated">CWG 1397</target>
        </trans-unit>
        <trans-unit id="b449890ac0834487b5eaf123c275fd35b1137504" translate="yes" xml:space="preserve">
          <source>CWG 1423</source>
          <target state="translated">CWG 1423</target>
        </trans-unit>
        <trans-unit id="9a7b9cc74202f3c29fa36c900f6ba27c585313fc" translate="yes" xml:space="preserve">
          <source>CWG 1458</source>
          <target state="translated">CWG 1458</target>
        </trans-unit>
        <trans-unit id="40d23e9f1ab69a460e82608189870f9b5cac5e51" translate="yes" xml:space="preserve">
          <source>CWG 1467</source>
          <target state="translated">CWG 1467</target>
        </trans-unit>
        <trans-unit id="d9c41df53bb29177228be09033e92e1deef54502" translate="yes" xml:space="preserve">
          <source>CWG 1550</source>
          <target state="translated">CWG 1550</target>
        </trans-unit>
        <trans-unit id="2749cb8bd08487f07f57b026d7f0a32906248fc7" translate="yes" xml:space="preserve">
          <source>CWG 1558</source>
          <target state="translated">CWG 1558</target>
        </trans-unit>
        <trans-unit id="1930e406ede3e006c8d9aac6e7043f5d94676955" translate="yes" xml:space="preserve">
          <source>CWG 1560</source>
          <target state="translated">CWG 1560</target>
        </trans-unit>
        <trans-unit id="e6ba8d164871c6a798203d13dfcb1e6e4da6da78" translate="yes" xml:space="preserve">
          <source>CWG 1579</source>
          <target state="translated">CWG 1579</target>
        </trans-unit>
        <trans-unit id="73c5f99cc638773086e35615fade4d4947d1d60e" translate="yes" xml:space="preserve">
          <source>CWG 1591</source>
          <target state="translated">CWG 1591</target>
        </trans-unit>
        <trans-unit id="735a2e213b861827190fdf465dd014f41f1f5684" translate="yes" xml:space="preserve">
          <source>CWG 1601</source>
          <target state="translated">CWG 1601</target>
        </trans-unit>
        <trans-unit id="f698a022a799e476a4b5d90908c4f0968039b3a4" translate="yes" xml:space="preserve">
          <source>CWG 1638</source>
          <target state="translated">CWG 1638</target>
        </trans-unit>
        <trans-unit id="9d6075634dd8060a300813233ee99f173cd90be3" translate="yes" xml:space="preserve">
          <source>CWG 1672</source>
          <target state="translated">CWG 1672</target>
        </trans-unit>
        <trans-unit id="b72ace2ad31c1e2fb91f1346d396608578b35f79" translate="yes" xml:space="preserve">
          <source>CWG 1696</source>
          <target state="translated">CWG 1696</target>
        </trans-unit>
        <trans-unit id="28347337bf2cc1f1919d510e1adbb168425a77c2" translate="yes" xml:space="preserve">
          <source>CWG 1719</source>
          <target state="translated">CWG 1719</target>
        </trans-unit>
        <trans-unit id="be03df1470395dcc9eeb7f3194fc4e5a81102ad5" translate="yes" xml:space="preserve">
          <source>CWG 1722</source>
          <target state="translated">CWG 1722</target>
        </trans-unit>
        <trans-unit id="0c7f27ab354ac1a80a384197c76d4e3d24b3a644" translate="yes" xml:space="preserve">
          <source>CWG 1734</source>
          <target state="translated">CWG 1734</target>
        </trans-unit>
        <trans-unit id="93fb30cfc8e126fb5fe13f8d64ea000c6669b4e0" translate="yes" xml:space="preserve">
          <source>CWG 1781</source>
          <target state="translated">CWG 1781</target>
        </trans-unit>
        <trans-unit id="75c74907ac6a6383a90bffab070b3ef5f33e6cdb" translate="yes" xml:space="preserve">
          <source>CWG 1813</source>
          <target state="translated">CWG 1813</target>
        </trans-unit>
        <trans-unit id="2eaa057756492b48b304275aed682a52bf13bef5" translate="yes" xml:space="preserve">
          <source>CWG 1838</source>
          <target state="translated">CWG 1838</target>
        </trans-unit>
        <trans-unit id="0d25ef040ac6f3edbf12f878493bba23ddbf903d" translate="yes" xml:space="preserve">
          <source>CWG 1863</source>
          <target state="translated">CWG 1863</target>
        </trans-unit>
        <trans-unit id="d31cb5a2e409347064465cd90ecdb5de73cbbcca" translate="yes" xml:space="preserve">
          <source>CWG 1866</source>
          <target state="translated">CWG 1866</target>
        </trans-unit>
        <trans-unit id="af6cfdd2ae9b748b30376111eb2e1a4d17271d87" translate="yes" xml:space="preserve">
          <source>CWG 1878</source>
          <target state="translated">CWG 1878</target>
        </trans-unit>
        <trans-unit id="76b6b3653d71fac1420ccfc68013d1df012f6885" translate="yes" xml:space="preserve">
          <source>CWG 1885</source>
          <target state="translated">CWG 1885</target>
        </trans-unit>
        <trans-unit id="80077256fcd7c8d10a1735e2561b5761dc72781c" translate="yes" xml:space="preserve">
          <source>CWG 1891</source>
          <target state="translated">CWG 1891</target>
        </trans-unit>
        <trans-unit id="1028a0754e9331957ee9dec60315a06334455543" translate="yes" xml:space="preserve">
          <source>CWG 1895</source>
          <target state="translated">CWG 1895</target>
        </trans-unit>
        <trans-unit id="715e6f5a0af4ea83c2adbba2e1c4a84c4cdf4c23" translate="yes" xml:space="preserve">
          <source>CWG 1911</source>
          <target state="translated">CWG 1911</target>
        </trans-unit>
        <trans-unit id="d59063371cbbf3c50fa4004a2c980a915a5a3712" translate="yes" xml:space="preserve">
          <source>CWG 1932</source>
          <target state="translated">CWG 1932</target>
        </trans-unit>
        <trans-unit id="fee2040205e11bfb3c90d627d95a3ef1b06bf7c8" translate="yes" xml:space="preserve">
          <source>CWG 1940</source>
          <target state="translated">CWG 1940</target>
        </trans-unit>
        <trans-unit id="7be04ab603086e1fe7b3d69077927db8d61e60df" translate="yes" xml:space="preserve">
          <source>CWG 195</source>
          <target state="translated">CWG 195</target>
        </trans-unit>
        <trans-unit id="401b02ff04774bdf69dfc351c0fc646e8c52792c" translate="yes" xml:space="preserve">
          <source>CWG 1951</source>
          <target state="translated">CWG 1951</target>
        </trans-unit>
        <trans-unit id="28c16abcb79a7d2985fffaea2e7091ceaeedcb15" translate="yes" xml:space="preserve">
          <source>CWG 1952</source>
          <target state="translated">CWG 1952</target>
        </trans-unit>
        <trans-unit id="78e6d54c5d8c416b62b8bc7f6de701b3133dfbaa" translate="yes" xml:space="preserve">
          <source>CWG 1955</source>
          <target state="translated">CWG 1955</target>
        </trans-unit>
        <trans-unit id="41f749570a89d069549057499232a1cc43471407" translate="yes" xml:space="preserve">
          <source>CWG 1992</source>
          <target state="translated">CWG 1992</target>
        </trans-unit>
        <trans-unit id="1463942fad687beb04e017d429368db857b7bf10" translate="yes" xml:space="preserve">
          <source>CWG 2004</source>
          <target state="translated">CWG 2004</target>
        </trans-unit>
        <trans-unit id="24b2f326ff1dbd6e75b7fe0777847a2048e25f64" translate="yes" xml:space="preserve">
          <source>CWG 2012</source>
          <target state="translated">CWG 2012</target>
        </trans-unit>
        <trans-unit id="a252ff07735443b3b89651fd3662e3f4c3a99e40" translate="yes" xml:space="preserve">
          <source>CWG 2022</source>
          <target state="translated">CWG 2022</target>
        </trans-unit>
        <trans-unit id="585fa29096b9165f2e65d4ab7ac3d55d4ccca16d" translate="yes" xml:space="preserve">
          <source>CWG 2026</source>
          <target state="translated">CWG 2026</target>
        </trans-unit>
        <trans-unit id="8190296876c615aed0b58aa2986f2e3603ff068b" translate="yes" xml:space="preserve">
          <source>CWG 2039</source>
          <target state="translated">CWG 2039</target>
        </trans-unit>
        <trans-unit id="9fac3c0f458bed3f35cc6e7ea77169bfd642f791" translate="yes" xml:space="preserve">
          <source>CWG 2052</source>
          <target state="translated">CWG 2052</target>
        </trans-unit>
        <trans-unit id="905971b8c2ebad4151cef0c505c6db3c3443e509" translate="yes" xml:space="preserve">
          <source>CWG 2082</source>
          <target state="translated">CWG 2082</target>
        </trans-unit>
        <trans-unit id="a60400639f386cc83b091425fd72478bd78dccb6" translate="yes" xml:space="preserve">
          <source>CWG 2084</source>
          <target state="translated">CWG 2084</target>
        </trans-unit>
        <trans-unit id="d0912de9c62ce2a759dd40ba5c95059625c84704" translate="yes" xml:space="preserve">
          <source>CWG 2091</source>
          <target state="translated">CWG 2091</target>
        </trans-unit>
        <trans-unit id="97ce1e0c528bfc8a4aee8f304b082d78f3313d15" translate="yes" xml:space="preserve">
          <source>CWG 2094</source>
          <target state="translated">CWG 2094</target>
        </trans-unit>
        <trans-unit id="bb553bbdccad20b58a6287507179e7aaac1138f8" translate="yes" xml:space="preserve">
          <source>CWG 2100</source>
          <target state="translated">CWG 2100</target>
        </trans-unit>
        <trans-unit id="7d55f979aebc02a17a304196dbaedd6e39446715" translate="yes" xml:space="preserve">
          <source>CWG 2120</source>
          <target state="translated">CWG 2120</target>
        </trans-unit>
        <trans-unit id="57a98d99b6d9403964ab62e7650db4ce2125747b" translate="yes" xml:space="preserve">
          <source>CWG 2137</source>
          <target state="translated">CWG 2137</target>
        </trans-unit>
        <trans-unit id="5e7983e2eff1437835ae2c5af3c0e619bb441ca6" translate="yes" xml:space="preserve">
          <source>CWG 2163</source>
          <target state="translated">CWG 2163</target>
        </trans-unit>
        <trans-unit id="fab7f39f8b013bbf0a59f2fe8002534da773c8aa" translate="yes" xml:space="preserve">
          <source>CWG 2167</source>
          <target state="translated">CWG 2167</target>
        </trans-unit>
        <trans-unit id="3f873603897faddf9e479a2f3afd854cd91d6381" translate="yes" xml:space="preserve">
          <source>CWG 2171</source>
          <target state="translated">CWG 2171</target>
        </trans-unit>
        <trans-unit id="fe9644b244394c2eabfc31e02ec47a961f67cb01" translate="yes" xml:space="preserve">
          <source>CWG 2176</source>
          <target state="translated">CWG 2176</target>
        </trans-unit>
        <trans-unit id="203df293763ce0d669052a6832f14d3fafcf7792" translate="yes" xml:space="preserve">
          <source>CWG 2268</source>
          <target state="translated">CWG 2268</target>
        </trans-unit>
        <trans-unit id="0654e95544b6a3934ee54bf50137e9773bf4eece" translate="yes" xml:space="preserve">
          <source>CWG 2278</source>
          <target state="translated">CWG 2278</target>
        </trans-unit>
        <trans-unit id="1e706907058df91acb35f56258b08ab09a4a3a70" translate="yes" xml:space="preserve">
          <source>CWG 2387</source>
          <target state="translated">CWG 2387</target>
        </trans-unit>
        <trans-unit id="82d53da8356c3ca3b92f1c7356ff3db1988d1b75" translate="yes" xml:space="preserve">
          <source>CWG 330</source>
          <target state="translated">CWG 330</target>
        </trans-unit>
        <trans-unit id="ccb6c3b42336d94c15bb3870d96c4815af38060e" translate="yes" xml:space="preserve">
          <source>CWG 393</source>
          <target state="translated">CWG 393</target>
        </trans-unit>
        <trans-unit id="e15dfefc20dc9707f7b3d7e3bfd742f4ba2fe0e6" translate="yes" xml:space="preserve">
          <source>CWG 45</source>
          <target state="translated">CWG 45</target>
        </trans-unit>
        <trans-unit id="a683182b298c47030d15a78fb9455cd68db3f4e1" translate="yes" xml:space="preserve">
          <source>CWG 496</source>
          <target state="translated">CWG 496</target>
        </trans-unit>
        <trans-unit id="f6a4d2d7852a929bdef3282acacef0950c6827a3" translate="yes" xml:space="preserve">
          <source>CWG 500</source>
          <target state="translated">CWG 500</target>
        </trans-unit>
        <trans-unit id="8168079f990033b28ee30baf555b21dac700dbe5" translate="yes" xml:space="preserve">
          <source>CWG 577</source>
          <target state="translated">CWG 577</target>
        </trans-unit>
        <trans-unit id="6fc7f7d941214d7e90028d76ec9df5aece8e4b10" translate="yes" xml:space="preserve">
          <source>CWG 613</source>
          <target state="translated">CWG 613</target>
        </trans-unit>
        <trans-unit id="65ecce3064605f43be72ea3dd69ca82afaeced68" translate="yes" xml:space="preserve">
          <source>CWG 616</source>
          <target state="translated">CWG 616</target>
        </trans-unit>
        <trans-unit id="de85001d3da367b6bc9e3cd052c9bab51ab5abda" translate="yes" xml:space="preserve">
          <source>CWG 727</source>
          <target state="translated">CWG 727</target>
        </trans-unit>
        <trans-unit id="1617da0092a5442eeec85cdd1cb1225081fe44bf" translate="yes" xml:space="preserve">
          <source>CWG 903</source>
          <target state="translated">CWG 903</target>
        </trans-unit>
        <trans-unit id="af14bcf58f1a68925b0a5504ba2c3fedd31bf275" translate="yes" xml:space="preserve">
          <source>CWG 975</source>
          <target state="translated">CWG 975</target>
        </trans-unit>
        <trans-unit id="883938ab5275fd7f506eef92dcbd07ff4e7d5615" translate="yes" xml:space="preserve">
          <source>Cache size access</source>
          <target state="translated">캐시 크기 액세스</target>
        </trans-unit>
        <trans-unit id="abd58164af939ff4d9cde0c5a458880ac0375eb1" translate="yes" xml:space="preserve">
          <source>Calculates the length of a null-terminated character sequence, that is, the smallest &lt;code&gt;i&lt;/code&gt; such that &lt;code&gt;p[i]==0&lt;/code&gt;.</source>
          <target state="translated">널 종료 문자 시퀀스의 길이, 즉 &lt;code&gt;p[i]==0&lt;/code&gt; 과 같은 가장 작은 &lt;code&gt;i&lt;/code&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="cf186f04df8bd87628a780c3378dd3632fd2a3a3" translate="yes" xml:space="preserve">
          <source>Calculates the phase angle (in radians) of the complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">복소수 &lt;code&gt;z&lt;/code&gt; 의 위상 각 (라디안)을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="57f0569da38bf80c03db47109bd43da72eb97f7c" translate="yes" xml:space="preserve">
          <source>Calculates the smallest integral power of two that is not smaller than &lt;code&gt;x&lt;/code&gt;. If that value is not representable in &lt;code&gt;T&lt;/code&gt;, the result is unspecified.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 보다 작은 2의 최소 적분을 계산합니다 . 해당 값을 &lt;code&gt;T&lt;/code&gt; 로 표현할 수없는 경우 결과는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="adab5090ac6a1b7b5420faac7be86c41721ba27c" translate="yes" xml:space="preserve">
          <source>Calendar</source>
          <target state="translated">Calendar</target>
        </trans-unit>
        <trans-unit id="77ea7aa743c8ae5ceebe6476bf7df6ad49a72839" translate="yes" xml:space="preserve">
          <source>Call once</source>
          <target state="translated">한 번 전화</target>
        </trans-unit>
        <trans-unit id="f4eba4ac4450eda1340606ecffb5eb5859411715" translate="yes" xml:space="preserve">
          <source>Call signature</source>
          <target state="translated">통화 서명</target>
        </trans-unit>
        <trans-unit id="31298f54f958dfd787e62fd18a5dfa0ea246238e" translate="yes" xml:space="preserve">
          <source>Call to a class object</source>
          <target state="translated">클래스 객체를 호출</target>
        </trans-unit>
        <trans-unit id="788d2b3c20bc6bb4acdf2e12c362e93fcf9f86e9" translate="yes" xml:space="preserve">
          <source>Call to a named function</source>
          <target state="translated">명명 된 함수 호출</target>
        </trans-unit>
        <trans-unit id="25e89ac78843ab3e453d550dab696b1c2685d9c8" translate="yes" xml:space="preserve">
          <source>Call to an overloaded operator</source>
          <target state="translated">과부하 된 운영자에게 전화</target>
        </trans-unit>
        <trans-unit id="3b55289fd0c473d42c2d6be6391e6a9f53a24056" translate="yes" xml:space="preserve">
          <source>Callable</source>
          <target state="translated">Callable</target>
        </trans-unit>
        <trans-unit id="23d949dfc4bd360aaa190a7d8b95216e5ade27f3" translate="yes" xml:space="preserve">
          <source>Callable concepts</source>
          <target state="translated">호출 가능한 개념</target>
        </trans-unit>
        <trans-unit id="26f12919d9abcbe806f8a77ed9eb33b55d766a0f" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;back&lt;/code&gt; on an empty container is undefined.</source>
          <target state="translated">호출 &lt;code&gt;back&lt;/code&gt; 빈 컨테이너는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff2ffbf673a19e18259ea1cb76992f714681e368" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;back&lt;/code&gt; on an empty span results in undefined behavior.</source>
          <target state="translated">호출 &lt;code&gt;back&lt;/code&gt; 정의되지 않은 동작에 빈 스팬 결과에 대한합니다.</target>
        </trans-unit>
        <trans-unit id="6717d3aa8431f388fa22c83faef176dba4e916c3" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;front&lt;/code&gt; on an empty container is undefined.</source>
          <target state="translated">호출 &lt;code&gt;front&lt;/code&gt; 빈 컨테이너 것은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b224fd770585fb9a84773057036aa9e7e6d3a7e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;front&lt;/code&gt; on an empty span results in undefined behavior.</source>
          <target state="translated">호출 &lt;code&gt;front&lt;/code&gt; 정의되지 않은 동작에 빈 스팬 결과에 대한합니다.</target>
        </trans-unit>
        <trans-unit id="2c9aa3a9eae1452c28134c585eb3820a002e81bd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;pop_back&lt;/code&gt; on an empty container is undefined.</source>
          <target state="translated">빈 컨테이너에서 &lt;code&gt;pop_back&lt;/code&gt; 호출 은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3735210d481937108546f459443e5f1fd0f227c2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;std::snprintf&lt;/code&gt; with zero &lt;code&gt;buf_size&lt;/code&gt; and null pointer for &lt;code&gt;buffer&lt;/code&gt; is useful to determine the necessary buffer size to contain the output:</source>
          <target state="translated">호출 &lt;code&gt;std::snprintf&lt;/code&gt; 0으로 &lt;code&gt;buf_size&lt;/code&gt; 및 널 포인터 &lt;code&gt;buffer&lt;/code&gt; 출력을 포함하는 데 필요한 버퍼의 크기를 결정하는 데 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="8ca41836763a311e7e3b63538aadbcd41b01f43b" translate="yes" xml:space="preserve">
          <source>Calling a member function of class X on an object of any other type invokes undefined behavior.</source>
          <target state="translated">다른 유형의 객체에서 클래스 X의 멤버 함수를 호출하면 정의되지 않은 동작이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b21d6934e73f94ffe04f7672733609014752fd4f" translate="yes" xml:space="preserve">
          <source>Calling any non-const member function of a &lt;code&gt;path&lt;/code&gt; invalidates all iterators referring to elements of that object.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 의 비 const 멤버 함수를 호출하면 해당 객체의 요소를 참조하는 모든 반복자가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="6605741078828d4b9eb94a61e28230ca57d44e38" translate="yes" xml:space="preserve">
          <source>Calling non-const member functions on the string, excluding &lt;a href=&quot;operator_at&quot;&gt;&lt;code&gt;operator[]()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자열에서 const가 아닌 멤버 함수 호출, &lt;a href=&quot;operator_at&quot;&gt; &lt;code&gt;operator[]()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe2bc9fc50f90ff08c540ee75e64a547ec4aa73" translate="yes" xml:space="preserve">
          <source>Calling non-const member functions on the string, excluding &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제외 문자열에 비 const 멤버 함수 호출 &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1590423ec88dccd74976d9c0b4a15cd539e5de0f" translate="yes" xml:space="preserve">
          <source>Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least &lt;code&gt;32&lt;/code&gt; functions.</source>
          <target state="translated">여러 스레드에서 함수를 호출해도 데이터 경쟁이 발생하지 않습니다. 이 구현은 &lt;code&gt;32&lt;/code&gt; 개 이상의 기능 등록을 지원해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ae706e35be31c74437d8b879378de31abca1e947" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;a href=&quot;../unique_lock/mutex&quot;&gt;&lt;code&gt;lock.mutex()&lt;/code&gt;&lt;/a&gt; is not locked by the current thread is undefined behavior.</source>
          <target state="translated">현재 스레드에서 &lt;a href=&quot;../unique_lock/mutex&quot;&gt; &lt;code&gt;lock.mutex()&lt;/code&gt; &lt;/a&gt; 를 잠그지 않은 경우이 함수를 호출하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75bbd4aac5cc1d989e699d782da569785e80372d" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;a href=&quot;../unique_lock/mutex&quot;&gt;&lt;code&gt;lock.mutex()&lt;/code&gt;&lt;/a&gt; is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;../unique_lock/mutex&quot;&gt; &lt;code&gt;lock.mutex()&lt;/code&gt; &lt;/a&gt; 경우이 함수 호출 가 현재 동일한 조건 변수에서 대기중인 다른 모든 스레드가 사용하는 것과 같은 뮤텍스가 아닌 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="4dc1176c569db8cabf9eb9a19f697b5eace8b739" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;code&gt;lock.mutex()&lt;/code&gt; is not locked by the current thread is undefined behavior.</source>
          <target state="translated">현재 스레드에서 &lt;code&gt;lock.mutex()&lt;/code&gt; 를 잠그지 않은 경우이 함수를 호출하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59ddebba5c0c5f3cf16d2db3348b2a06ea675f9c" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;code&gt;lock.mutex()&lt;/code&gt; is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior.</source>
          <target state="translated">&lt;code&gt;lock.mutex()&lt;/code&gt; 가 현재 동일한 조건 변수에서 대기중인 다른 모든 스레드가 사용하는 것과 같은 뮤텍스가 아닌 경우이 함수를 호출하면 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="ca1101d4e72ebfdcdf0ad75bb31490874ef21229" translate="yes" xml:space="preserve">
          <source>Calling wait on the same &lt;code&gt;std::shared_future&lt;/code&gt; from multiple threads is not safe; the intended use is for each thread that waits on the same shared state to have a copy of a &lt;code&gt;std::shared_future&lt;/code&gt;.</source>
          <target state="translated">여러 스레드에서 동일한 &lt;code&gt;std::shared_future&lt;/code&gt; 에서 대기 호출 은 안전하지 않습니다. 동일한 공유 상태에서 &lt;code&gt;std::shared_future&lt;/code&gt; 의 사본을 갖기를 기다리는 각 스레드에 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe2219fd2346b0443d87479d3d6381482c45d02" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt; to transmit all pending output (and delayed flush, if any) to the wrapped stream. If an exception is thrown by this call, it is caught and ignored.</source>
          <target state="translated">대기중인 모든 출력 (및 지연된 플러시가있는 경우)을 래핑 된 스트림으로 전송하기 위해 &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 호출에 의해 예외가 발생하면 포착되어 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e7211e6009a18f7a09fbc9ac46b8a624714b4410" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*)&lt;/code&gt;or &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt;(since C++17), but it is unspecified when and how it is called.</source>
          <target state="translated">전화 &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*)&lt;/code&gt; 또는 &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt; (17 ++ C부터),하지만이 지정되지 않은 경우 및이 방법이라고합니다.</target>
        </trans-unit>
        <trans-unit id="d77a5af1e4348b5987265920ffaec5aa8d151398" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; to close the associated file and destructs all other members of &lt;code&gt;basic_filebuf&lt;/code&gt;. If an exception is thrown by &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;, it is caught and not rethrown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 를 호출 하여 관련 파일을 닫고 &lt;code&gt;basic_filebuf&lt;/code&gt; 의 다른 모든 멤버를 제거합니다 . &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 의해 예외가 발생하면 다시 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36548e9702a28bd62ee76fcd892dc9bc23d3cf34" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze()&lt;/a&gt;&lt;/code&gt;, then returns a copy of start pointer of the get area, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::streambuf::eback()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze()&lt;/a&gt;&lt;/code&gt; 호출 한 다음 get 영역의 시작 포인터 사본 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::streambuf::eback()&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d5eeb168b574d3d4c252825f4a3753f9379de82e" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; to swap all data members of the base class except for &lt;code&gt;rdbuf()&lt;/code&gt;, and swaps the values of the &lt;code&gt;gcount()&lt;/code&gt; counters between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. This swap function is protected: it is called by the swap functions of the swappable input stream classes &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="translated">&lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; 을 호출 하여 &lt;code&gt;rdbuf()&lt;/code&gt; 제외한 기본 클래스의 모든 데이터 멤버를 바꾸고 &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 사이 에서 &lt;code&gt;gcount()&lt;/code&gt; 카운터 의 값을 바꿉니다 . 이 스왑 함수는 보호됩니다. 스왑 가능한 입력 스트림 클래스 &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; 의 스왑 함수에 의해 호출되며 관련 스트림 버퍼 를 올바르게 바꾸는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ac56e091391242bbdc4ad807edc846cff28d837" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; to swap all data members of the base class, except for &lt;code&gt;rdbuf()&lt;/code&gt;, between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. This swap function is protected: it is called by the swap functions of the swappable output stream classes &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 사이 에서 &lt;code&gt;rdbuf()&lt;/code&gt; 제외한 기본 클래스의 모든 데이터 멤버를 교환하기 위해 &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; 를 호출 합니다. 이 스왑 함수는 보호됩니다. 스왑 가능한 출력 스트림 클래스 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt; 의 스왑 함수에 의해 호출되며 관련 스트림 버퍼 를 올바르게 바꾸는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3dc184d2193e1837c7b1ab6ae910b4a5a68b463" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;clear()&lt;/code&gt; on success.</source>
          <target state="translated">성공하면 &lt;code&gt;clear()&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3934f9f9eebfbb559e3c31093566b7ed8b1d4ffc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;setstate(failbit)&lt;/code&gt; on failure.</source>
          <target state="translated">실패시 &lt;code&gt;setstate(failbit)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d2c103774ce296202589b581a39e2733fbd14eeb" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;swap&lt;/code&gt; (which might be &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;, or might be found via ADL) for each element in &lt;code&gt;*this&lt;/code&gt; and its corresponding element in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 의 각 요소 와 &lt;code&gt;other&lt;/code&gt; 의 해당 요소에 대해 &lt;code&gt;swap&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 일 수 있거나 ADL을 통해 찾을 수 있음)을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="481431a2735414dcd8592892b784b43366935f35" translate="yes" xml:space="preserve">
          <source>Calls the &lt;a href=&quot;../../../named_req/callable&quot;&gt;Callable&lt;/a&gt; object, reference to which is stored. This function is available only if the stored reference points to a &lt;a href=&quot;../../../named_req/callable&quot;&gt;Callable&lt;/a&gt; object.</source>
          <target state="translated">참조가 저장된 &lt;a href=&quot;../../../named_req/callable&quot;&gt;Callable&lt;/a&gt; 객체를 호출합니다 . 이 기능은 저장된 참조가 &lt;a href=&quot;../../../named_req/callable&quot;&gt;Callable&lt;/a&gt; 객체를 가리키는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bbf1dcddfa6e1ab86b5f404a8df59c3e805b815" translate="yes" xml:space="preserve">
          <source>Calls the appropriate extraction operator, given an rvalue reference to an input stream object (equivalent to &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt;). This function does not participate in overload resolution unless the expression &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt; is well-formed.</source>
          <target state="translated">입력 스트림 객체에 대한 rvalue 참조가 제공된 경우 적절한 추출 연산자를 호출합니다 ( &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt; ). 이 함수는 &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt; 식이 제대로 구성되어 있지 않으면 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9c48a860ccae7d78225a13d6988e12c01b392911" translate="yes" xml:space="preserve">
          <source>Calls the appropriate extraction operator, given an rvalue reference to an input stream object (equivalent to &lt;code&gt;st &amp;gt;&amp;gt; value&lt;/code&gt;).</source>
          <target state="translated">입력 스트림 객체에 대한 rvalue 참조 ( &lt;code&gt;st &amp;gt;&amp;gt; value&lt;/code&gt; 와 동일)가 제공되면 적절한 추출 연산자를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7b5b7a129b3ced37543947e6912ecc3cecfa84d6" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;, as if by &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;~T()&lt;/code&gt; 처럼 &lt;code&gt;p&lt;/code&gt; 가 가리키는 객체의 소멸자를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b405a9cd2b966c4bc34d98cc6f9f7cf4e95fe857" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 가리키는 객체의 소멸자를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="78b1409922d2e4a9785fcea7996d5ce02b31a4ce" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;. If possible, does so by calling &lt;code&gt;a.destroy(p)&lt;/code&gt;. If not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;destroy()&lt;/code&gt;), then calls the destructor of &lt;code&gt;*p&lt;/code&gt; directly, as &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 가리키는 객체의 소멸자를 호출합니다 . 가능하다면 &lt;code&gt;a.destroy(p)&lt;/code&gt; 호출하면됩니다 . 가능하지 않은 경우 (예 : &lt;code&gt;a&lt;/code&gt; 에 멤버 함수 &lt;code&gt;destroy()&lt;/code&gt; 가없는 경우 ) &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt; 와 같이 &lt;code&gt;*p&lt;/code&gt; 의 소멸자를 직접 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d65d02c76675e1ef2e0ab59d434954fbf4aab1b9" translate="yes" xml:space="preserve">
          <source>Calls the function named &lt;code&gt;swap()&lt;/code&gt; found by overload resolution among all functions with that name that are found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; and the two &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; templates defined in the header &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../language/adl&quot;&gt;인수 종속 조회&lt;/a&gt; 에서 발견되는 해당 이름을 가진 모든 함수와 &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; 헤더에 정의 된 두 개의 &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 템플리트 중에서 과부하 분석에서 찾은 &lt;code&gt;swap()&lt;/code&gt; 이라는 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fb046b6586e057bb9aae9a1e6bfffa31963ec5ed" translate="yes" xml:space="preserve">
          <source>Calls the host environment's command processor (e.g. &lt;code&gt;/bin/sh&lt;/code&gt;, &lt;code&gt;cmd.exe&lt;/code&gt;, &lt;code&gt;command.com&lt;/code&gt;) with the parameter &lt;code&gt;command&lt;/code&gt;. Returns an implementation-defined value (usually the value that the invoked program returns).</source>
          <target state="translated">매개 변수 &lt;code&gt;command&lt;/code&gt; 를 사용 하여 호스트 환경의 명령 프로세서 (예 : &lt;code&gt;/bin/sh&lt;/code&gt; , &lt;code&gt;cmd.exe&lt;/code&gt; , &lt;code&gt;command.com&lt;/code&gt; )를 호출합니다 . 구현 정의 값 (보통 호출 된 프로그램이 반환하는 값)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b26b8306a6c31504edbc512428e1a837332ab1bd" translate="yes" xml:space="preserve">
          <source>Calls the stored function.</source>
          <target state="translated">저장된 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="afca4766bb42b40e6c34338087393e97b7c59c19" translate="yes" xml:space="preserve">
          <source>Calls the stored task with &lt;code&gt;args&lt;/code&gt; as the arguments. The return value of the task or any exceptions thrown are stored in the shared state. The shared state is made ready and any threads waiting for this are unblocked.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 로 args 를 사용 하여 저장된 작업을 호출합니다 . 작업의 반환 값 또는 발생한 예외는 공유 상태로 저장됩니다. 공유 상태가 준비되고이를 기다리는 스레드는 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="dd90a8cace7a8f14fa555e29a7e7953fe85896a1" translate="yes" xml:space="preserve">
          <source>Calls the stored task with forwarded &lt;code&gt;args&lt;/code&gt; as the arguments. The return value of the task or any exception thrown by it is stored in the shared state of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">전달 된 &lt;code&gt;args&lt;/code&gt; 를 인수 로 사용하여 저장된 작업을 호출합니다 . 태스크의 리턴 값 또는 태스크에서 발생한 예외는 공유 상태 &lt;code&gt;*this&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ee1a97db496e5e5a537daa1da0e2cec32168671" translate="yes" xml:space="preserve">
          <source>Calls to &lt;a href=&quot;synchronized_pool_resource/do_allocate&quot;&gt;&lt;code&gt;do_allocate&lt;/code&gt;&lt;/a&gt; are dispatched to the pool serving the smallest blocks accommodating the requested size.</source>
          <target state="translated">요청 된 크기를 수용하는 가장 작은 블록을 제공하는 풀 에 &lt;a href=&quot;synchronized_pool_resource/do_allocate&quot;&gt; &lt;code&gt;do_allocate&lt;/code&gt; &lt;/a&gt; 호출 이 발송됩니다.</target>
        </trans-unit>
        <trans-unit id="40a3a9a4b8f56ea0c9cc9b74ebd031cfe3acb404" translate="yes" xml:space="preserve">
          <source>Calls to &lt;a href=&quot;unsynchronized_pool_resource/do_allocate&quot;&gt;&lt;code&gt;do_allocate&lt;/code&gt;&lt;/a&gt; are dispatched to the pool serving the smallest blocks accommodating the requested size.</source>
          <target state="translated">요청 된 크기를 수용하는 가장 작은 블록을 제공하는 풀 에 &lt;a href=&quot;unsynchronized_pool_resource/do_allocate&quot;&gt; &lt;code&gt;do_allocate&lt;/code&gt; &lt;/a&gt; 호출 이 발송됩니다.</target>
        </trans-unit>
        <trans-unit id="2bc1581a9b7b77d7540b30aeb4545a58a025742b" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;Allocator::allocate&lt;/code&gt; may throw.</source>
          <target state="translated">&lt;code&gt;Allocator::allocate&lt;/code&gt; 호출이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e921f3a7ab8c6ee7f214b9ae25dfd4e6dac7ed9" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;c8rtomb&lt;/code&gt; with a null pointer argument for &lt;code&gt;s&lt;/code&gt; may introduce a data race with other calls to &lt;code&gt;c8rtomb&lt;/code&gt; with a null pointer argument for &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">통화하는 &lt;code&gt;c8rtomb&lt;/code&gt; 에 대한 NULL 포인터 인수 &lt;code&gt;s&lt;/code&gt; 는 다른 통화와 데이터 경쟁 도입 할 수 &lt;code&gt;c8rtomb&lt;/code&gt; 에 대한 널 포인터 인수를 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="842bfa338f91c208278bfed4b504f42e1234ae0a" translate="yes" xml:space="preserve">
          <source>Calls to const member functions of the distribution and &lt;code&gt;os &amp;lt;&amp;lt; d&lt;/code&gt; do not affect the sequence of numbers produced by repeated &lt;code&gt;d(g)&lt;/code&gt;.</source>
          <target state="translated">분포와 &lt;code&gt;os &amp;lt;&amp;lt; d&lt;/code&gt; 의 const 멤버 함수에 대한 호출 은 반복 된 &lt;code&gt;d(g)&lt;/code&gt; 의해 생성 된 숫자 시퀀스에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8f6bda6c551be6982977241156d440ef692185ef" translate="yes" xml:space="preserve">
          <source>Calls to these functions that allocate or deallocate a particular unit of storage occur in a single total order, and each such deallocation call &lt;a href=&quot;../../atomic/memory_order&quot;&gt;happens-before&lt;/a&gt; the next allocation (if any) in this order.</source>
          <target state="translated">특정 스토리지 단위를 할당하거나 할당 해제하는 이러한 기능에 대한 호출은 단일 총 순서로 발생하며, 이러한 할당 해제 호출 은이 순서에서 다음 할당 (있는 경우) &lt;a href=&quot;../../atomic/memory_order&quot;&gt;전에 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f6d16e4b3fb1f8e6d8ebfda2e4deaa82522158" translate="yes" xml:space="preserve">
          <source>Calls to this function do not introduce data races with calls to &lt;code&gt;&lt;a href=&quot;get_future&quot;&gt;get_future&lt;/a&gt;&lt;/code&gt; (but they need not synchronize with each other).</source>
          <target state="translated">이 함수에 대한 호출은 &lt;code&gt;&lt;a href=&quot;get_future&quot;&gt;get_future&lt;/a&gt;&lt;/code&gt; 에 대한 호출과 함께 데이터 경쟁을 일으키지 않습니다 (그러나 서로 동기화 할 필요는 없습니다).</target>
        </trans-unit>
        <trans-unit id="0e8b087d01af0042b03fbd3b40cf94cd4b629f74" translate="yes" xml:space="preserve">
          <source>Calls to this function do not introduce data races with calls to &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; (but they need not synchronize with each other).</source>
          <target state="translated">이 함수를 호출 해도 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; 에 대한 호출로 데이터 레이스가 발생하지는 않습니다 (그러나 서로 동기화 할 필요는 없습니다).</target>
        </trans-unit>
        <trans-unit id="978f12bb4868b3da1bd6017109c32a97b6cc062a" translate="yes" xml:space="preserve">
          <source>Can be used to iterate through a single bucket</source>
          <target state="translated">단일 버킷을 반복하는 데 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0754caffdf7dc1f3c428a31d5458447d8f2078b5" translate="yes" xml:space="preserve">
          <source>Can be variadic as well</source>
          <target state="translated">다변 일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="32df764f4a004f4803750cb06a6e1038b85f5ab0" translate="yes" xml:space="preserve">
          <source>Can throw the exceptions thrown from &lt;code&gt;Alloc::allocate()&lt;/code&gt; or from the constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, (1) has no effect. If an exception is thrown during the construction of the array, already-initialized elements are destroyed in reverse order(since C++20).</source>
          <target state="translated">&lt;code&gt;Alloc::allocate()&lt;/code&gt; 또는 &lt;code&gt;T&lt;/code&gt; 생성자 에서 발생한 예외를 throw 할 수 있습니다. 예외가 발생하면 (1)은 효과가 없습니다. 배열을 구성하는 동안 예외가 발생하면 이미 초기화 된 요소가 역순으로 소멸됩니다 (C ++ 20 이후).</target>
        </trans-unit>
        <trans-unit id="a4c126ec0c1d28e21fc971d14fbf29c30650c27c" translate="yes" xml:space="preserve">
          <source>Candidate functions</source>
          <target state="translated">후보자 기능</target>
        </trans-unit>
        <trans-unit id="3a1ea5de25db4a707e5b97c9c93167ca46913fc0" translate="yes" xml:space="preserve">
          <source>Cannot be called and thus never returns a value. The return type is &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; unless &lt;code&gt;T&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, in which case the return type is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">호출 할 수 없으므로 값을 반환하지 않습니다. &lt;code&gt;T&lt;/code&gt; 가 (cv-qualified) &lt;code&gt;void&lt;/code&gt; 가 아닌 경우 반환 유형은 &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; 이며,이 경우 반환 유형은 &lt;code&gt;T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a47709738a13682382a8bb47d1c3c176fb6cf434" translate="yes" xml:space="preserve">
          <source>Canonical implementations</source>
          <target state="translated">정식 구현</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="45bd908df490edd79694ba0daff82fc092970b55" translate="yes" xml:space="preserve">
          <source>Capacity</source>
          <target state="translated">Capacity</target>
        </trans-unit>
        <trans-unit id="8c8a5e126ef7ec6a6ad77d0edf96fa8a146e07ff" translate="yes" xml:space="preserve">
          <source>Capacity of the currently allocated storage.</source>
          <target state="translated">현재 할당 된 스토리지의 용량</target>
        </trans-unit>
        <trans-unit id="b17823bc1728ea261d27feb54556ae24540f0e72" translate="yes" xml:space="preserve">
          <source>Capture and storage of exception objects</source>
          <target state="translated">예외 객체의 캡처 및 저장</target>
        </trans-unit>
        <trans-unit id="dc6500dd683ae5c40011f02be84c903248d14d1b" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::clamp&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="translated">매개 변수 중 하나가 rvalue 인 경우 참조 로 &lt;code&gt;std::clamp&lt;/code&gt; 의 결과를 캡처 하면 해당 매개 변수가 리턴되면 댕글 링 참조가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f412180178dea3bf686bb7206b2a1c6f412f169f" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::max&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="translated">매개 변수 중 하나가 rvalue 인 경우 참조 로 &lt;code&gt;std::max&lt;/code&gt; 의 결과를 캡처 하면 해당 매개 변수가 리턴되면 댕글 링 참조가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="37013b98a907be74378196d00c40398eaed52529" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::min&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="translated">매개 변수 중 하나가 rvalue 인 경우 참조 로 &lt;code&gt;std::min&lt;/code&gt; 의 결과를 캡처 하면 해당 매개 변수가 리턴되면 댕글 링 참조가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="aeac558c74f367c4d77b33a3b991b9293571a506" translate="yes" xml:space="preserve">
          <source>Care should be taken when using &lt;code&gt;enable_if&lt;/code&gt; in the type of a template non-type parameter of a namespace-scope function template. Some ABI specifications like the Itanium ABI do not include the instantiation-dependent portions of non-type template parameters in the mangling, meaning that specializations of two distinct function templates might end up with the same mangled name and be erroneously linked together. For example:</source>
          <target state="translated">네임 스페이스 범위 함수 템플릿의 템플릿 비 유형 매개 변수 유형에서 &lt;code&gt;enable_if&lt;/code&gt; 를 사용할 때는주의해야합니다 . Itanium ABI와 같은 일부 ABI 사양에는 맹 글링에 비 유형 템플릿 매개 변수의 인스턴스화 종속 부분이 포함되어 있지 않습니다. 즉, 두 개의 고유 한 기능 템플릿의 전문화가 동일한 맹 글링 된 이름으로 끝나고 잘못 연결될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bbfb9c69143915569ecc52059ab10ea7a1d14360" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;) is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emplace&lt;/code&gt; 주의해서 사용 하면 불필요한 복사 또는 이동 작업을 피하면서 새로운 요소를 구성 할 수 있습니다. 새 요소의 생성자 (예 : &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; )는 &lt;code&gt;emplace&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 를 통해 전달 된 emplace에 제공된 것과 정확히 동일한 인수로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="52b9bfebd40c006ea3917327fed74d66704c9687" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;) is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</source>
          <target state="translated">&lt;code&gt;emplace&lt;/code&gt; 주의해서 사용 하면 불필요한 복사 또는 이동 작업을 피하면서 새로운 요소를 구성 할 수 있습니다. 새 요소의 생성자 (예 : &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; )는 &lt;code&gt;emplace&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 를 통해 전달 된 emplace에 제공된 것과 정확히 동일한 인수로 호출됩니다 . 컨테이너에 키가있는 요소가 이미있는 경우에도 요소가 생성 될 수 있으며,이 경우 새로 구성된 요소는 즉시 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="4714de10bb9278addf37bd8e9cf61fba91ba9335" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emplace&lt;/code&gt; 주의해서 사용 하면 불필요한 복사 또는 이동 작업을 피하면서 새로운 요소를 구성 할 수 있습니다. 새 요소의 생성자는 &lt;code&gt;emplace&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 를 통해 전달 된 emplace에 제공된 것과 정확히 동일한 인수로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d62f1320fbf353fbac4ea498ae530ee45805f5d" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</source>
          <target state="translated">&lt;code&gt;emplace&lt;/code&gt; 주의해서 사용 하면 불필요한 복사 또는 이동 작업을 피하면서 새로운 요소를 구성 할 수 있습니다. 새 요소의 생성자는 &lt;code&gt;emplace&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 를 통해 전달 된 emplace에 제공된 것과 정확히 동일한 인수로 호출됩니다 . 컨테이너에 키가있는 요소가 이미있는 경우에도 요소가 생성 될 수 있으며,이 경우 새로 구성된 요소는 즉시 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="9ba8ece0eb57ce634431d006ebb786d69e1c0fb8" translate="yes" xml:space="preserve">
          <source>Carries dependency</source>
          <target state="translated">의존성</target>
        </trans-unit>
        <trans-unit id="349f4b2217e91ab2d1ba3827cff21266a8c0e7bc" translate="yes" xml:space="preserve">
          <source>Case 1: binding an array</source>
          <target state="translated">사례 1 : 배열 바인딩</target>
        </trans-unit>
        <trans-unit id="56f64fdbefc9674a22cdd908d97b4da3d5e9aac5" translate="yes" xml:space="preserve">
          <source>Case 1: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is an array type, then the names are bound to the array elements.</source>
          <target state="translated">사례 1 : &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 가 배열 유형이면 이름이 배열 요소에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="8fc50ba85c9e0bf4533570a0c18a73541e34b19c" translate="yes" xml:space="preserve">
          <source>Case 2: binding a tuple-like type</source>
          <target state="translated">사례 2 : 튜플과 같은 유형 바인딩</target>
        </trans-unit>
        <trans-unit id="a28b6bd53fab5c5518781c66d9367f259e8a1a8b" translate="yes" xml:space="preserve">
          <source>Case 2: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is a non-union class type and &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is a complete type, then the &quot;tuple-like&quot; binding protocol is used.</source>
          <target state="translated">사례 2 : &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 가 비 유니언 클래스 유형이고 &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; 가 완전한 유형 인 경우 &quot;튜플 유사&quot;바인딩 프로토콜이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="511322fb92a18ad6c803db32b44850aa3b21431d" translate="yes" xml:space="preserve">
          <source>Case 3: binding to data members</source>
          <target state="translated">사례 3 : 데이터 멤버에 바인딩</target>
        </trans-unit>
        <trans-unit id="d6570c00b51cbb8acf7b8685b39e65082f79bd7f" translate="yes" xml:space="preserve">
          <source>Case 3: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is a non-union class type but &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is not a complete type, then the names are bound to the accessible data members of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">사례 3 : &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 가 비 유니언 클래스 유형이지만 &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; 가 완전한 유형이 아닌 경우 이름은 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 의 액세스 가능한 데이터 멤버에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="74473f63620ac45f2911b86a7f11c6501a7660cd" translate="yes" xml:space="preserve">
          <source>Cast and assignment strip away any extraneous range and precision: this models the action of storing a value from an extended-precision FPU register into a standard-sized memory location.</source>
          <target state="translated">캐스트 및 할당은 불필요한 범위와 정밀도를 제거합니다. 이는 확장 정밀 FPU 레지스터의 값을 표준 크기의 메모리 위치에 저장하는 동작을 모델링합니다.</target>
        </trans-unit>
        <trans-unit id="8107a9770cf1c808e1686a8e8b7cced06eac8bfc" translate="yes" xml:space="preserve">
          <source>Casting between integer durations where the source period is exactly divisible by the target period (e.g. hours to minutes) or between floating-point durations can be performed with ordinary casts or implicitly via &lt;a href=&quot;duration&quot;&gt;std::chrono::duration constructors&lt;/a&gt;, no &lt;code&gt;duration_cast&lt;/code&gt; is needed.</source>
          <target state="translated">소스 기간이 목표 기간으로 정확히 나눌 수있는 정수 기간 (예 : 시간에서 분으로) 또는 부동 소수점 기간으로의 캐스팅은 일반 캐스트로 수행하거나 &lt;a href=&quot;duration&quot;&gt;std :: chrono :: duration 생성자&lt;/a&gt; 를 통해 내재적으로 수행 할 수 있으며 &lt;code&gt;duration_cast&lt;/code&gt; 는 필요 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f784c0dfdd40d5aecdcc755d6d0d02557b2aa7e" translate="yes" xml:space="preserve">
          <source>Casting from a floating-point duration to an integer duration is &lt;a href=&quot;../../language/implicit_cast#Floating_-_integral_conversions&quot;&gt;subject to undefined behavior&lt;/a&gt; when the floating-point value is NaN, infinity, or too large to be representable by the target's integer type. Otherwise, casting to an integer duration is subject to truncation as with any static_cast to an integer type.</source>
          <target state="translated">부동 소수점 기간에서 정수 기간으로 캐스트하는 경우 부동 소수점 값이 NaN, 무한대 또는 대상의 정수 유형으로 표현하기에는 너무 큰 경우 &lt;a href=&quot;../../language/implicit_cast#Floating_-_integral_conversions&quot;&gt;정의되지 않은 동작&lt;/a&gt; 이 적용됩니다 . 그렇지 않으면 정수 기간으로의 캐스트는 정수 유형에 대한 static_cast와 같이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="d1bd210bf015301c8468da6b036f05fe262ff0f0" translate="yes" xml:space="preserve">
          <source>Catch clause of a function-try block</source>
          <target state="translated">function-try 블록의 catch 절</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="8610c7e6c1a1322fdf2ebc74043f66b624b393a8" translate="yes" xml:space="preserve">
          <source>Causes abnormal program termination unless &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; is being caught by a signal handler passed to &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; and the handler does not return.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; 전달 된 신호 처리기에 의해 &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; 가 포착 되지 않고 처리기가 리턴 되지 않으면 프로그램이 비정상 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5fc98a179eaefefc7383473561adf59469b047c" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur without completely cleaning the resources.</source>
          <target state="translated">리소스를 완전히 정리하지 않고 정상적인 프로그램 종료가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="03d84237d77c18a1ea9454f00c0d5a2c4def6e6a" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur.</source>
          <target state="translated">정상적인 프로그램 종료가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e1f612c1cf7abef4418592e6cc6efbf397106128" translate="yes" xml:space="preserve">
          <source>Causes reallocation if the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than the old &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;. If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</source>
          <target state="translated">새 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 가 이전 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 보다 큰 경우 재 할당합니다 . 새 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 보다 큰 경우 모든 반복자와 참조가 무효화됩니다. 그렇지 않으면 삽입 점 이전의 반복자와 참조 만 유효합니다. 과거의 이터레이터도 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="1b3b922a89d7fd2178e02a2f975053d39cd95e01" translate="yes" xml:space="preserve">
          <source>Causes the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop or &lt;a href=&quot;switch&quot;&gt; switch statement&lt;/a&gt; to terminate.</source>
          <target state="translated">둘러싸 원인 &lt;a href=&quot;for&quot;&gt;를 들어&lt;/a&gt; , &lt;a href=&quot;range-for&quot;&gt;범위-을 위해&lt;/a&gt; , &lt;a href=&quot;while&quot;&gt;동안&lt;/a&gt; 또는 &lt;a href=&quot;do&quot;&gt;-않는 동안&lt;/a&gt; 루프 또는 &lt;a href=&quot;switch&quot;&gt;switch 문을&lt;/a&gt; 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c910b43d8c16258ce3d66377f217e9ecf4da3d0f" translate="yes" xml:space="preserve">
          <source>Causes the remaining portion of the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt; do-while&lt;/a&gt; loop body to be skipped.</source>
          <target state="translated">바깥 쪽의 나머지 부분 일으킴 &lt;a href=&quot;for&quot;&gt;를 들어&lt;/a&gt; , &lt;a href=&quot;range-for&quot;&gt;범위 - 위해&lt;/a&gt; , &lt;a href=&quot;while&quot;&gt;동안&lt;/a&gt; 또는 &lt;a href=&quot;do&quot;&gt;수행하는 동시에&lt;/a&gt; 루프 본체는 생략한다.</target>
        </trans-unit>
        <trans-unit id="e2cc09c65ee94e9da20a5da53ff7a1764aa2d212" translate="yes" xml:space="preserve">
          <source>Certain &lt;a href=&quot;operator_arithmetic#Additive_operators&quot;&gt;addition, subtraction&lt;/a&gt;, &lt;a href=&quot;operator_incdec&quot;&gt;increment, and decrement&lt;/a&gt; operators are defined for pointers to elements of arrays: such pointers satisfy the &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; requirements and allow the C++ library &lt;a href=&quot;../algorithm&quot;&gt;algorithms&lt;/a&gt; to work with raw arrays.</source>
          <target state="translated">배열 요소에 대한 포인터에 대해 특정 &lt;a href=&quot;operator_arithmetic#Additive_operators&quot;&gt;더하기, 빼기&lt;/a&gt; , &lt;a href=&quot;operator_incdec&quot;&gt;증분 및 감소&lt;/a&gt; 연산자가 정의됩니다. 이러한 포인터는 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 요구 사항을 충족하고 C ++ 라이브러리 &lt;a href=&quot;../algorithm&quot;&gt;알고리즘&lt;/a&gt; 이 원시 배열과 함께 작동 할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="16ced4992002374e1ee48c60ab57aa3dd53629bb" translate="yes" xml:space="preserve">
          <source>Certain words in a C++ program have special meaning, and these are known as &lt;a href=&quot;../keywords&quot;&gt;keywords&lt;/a&gt;. Others can be used as &lt;a href=&quot;name&quot;&gt;identifiers&lt;/a&gt;. &lt;a href=&quot;../comments&quot;&gt;Comments&lt;/a&gt; are ignored during translation. Certain characters in the program have to be represented with &lt;a href=&quot;escape&quot;&gt;escape sequences&lt;/a&gt;.</source>
          <target state="translated">C ++ 프로그램의 특정 단어에는 특별한 의미가 있으며 &lt;a href=&quot;../keywords&quot;&gt;키워드&lt;/a&gt; 라고 합니다 . 다른 것들은 &lt;a href=&quot;name&quot;&gt;식별자&lt;/a&gt; 로 사용될 수 있습니다 . 번역 중에는 &lt;a href=&quot;../comments&quot;&gt;주석&lt;/a&gt; 이 무시됩니다. 프로그램의 특정 문자는 &lt;a href=&quot;escape&quot;&gt;이스케이프 시퀀스&lt;/a&gt; 로 표시되어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="191f1780427cc9f433fedbcd960fd714be286f24" translate="yes" xml:space="preserve">
          <source>Change the return type of the &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove_if()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;container/list/unique&quot;&gt;unique()&lt;/a&gt;&lt;/code&gt; members of &lt;code&gt;&lt;a href=&quot;container/forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;container/forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove_if()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;container/list/unique&quot;&gt;unique()&lt;/a&gt;&lt;/code&gt; 멤버의 리턴 유형을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="a51058c46332744397288d2669e24ba920dc2025" translate="yes" xml:space="preserve">
          <source>Changes access permissions of the file to which &lt;code&gt;p&lt;/code&gt; resolves, as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html&quot;&gt;fchmodat&lt;/a&gt;. Symlinks are followed unless &lt;code&gt;perm_options::nofollow&lt;/code&gt; is set in &lt;code&gt;opts&lt;/code&gt;.</source>
          <target state="translated">POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html&quot;&gt;fchmodat에&lt;/a&gt; 의한 것처럼 &lt;code&gt;p&lt;/code&gt; 가 해결 하는 파일의 액세스 권한을 변경 합니다 . perm_options &lt;code&gt;perm_options::nofollow&lt;/code&gt; 가 &lt;code&gt;opts&lt;/code&gt; 에 설정되어 있지 않으면 심볼릭 링크가 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="d059f7f607e7b98754449b95b9c9f18d224be17e" translate="yes" xml:space="preserve">
          <source>Changes the associated locale so that all characters inserted or extracted after this call (and until another call to &lt;code&gt;imbue()&lt;/code&gt;) are converted using the &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet of &lt;code&gt;loc&lt;/code&gt;.</source>
          <target state="translated">이 호출 후에 (및 &lt;code&gt;imbue()&lt;/code&gt; 다른 호출이있을 때까지) 삽입되거나 추출 된 모든 문자 가 &lt;code&gt;loc&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 패싯을 사용하여 변환 되도록 연관된 로케일을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="59519c86c11d2513037e609c3becf73e19a3102f" translate="yes" xml:space="preserve">
          <source>Changes the associated locale.</source>
          <target state="translated">연결된 로캘을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="e1931e70aa0ae325fe795a9e9d024fe1264be193" translate="yes" xml:space="preserve">
          <source>Changes the contained object to one of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; constructed from the arguments.</source>
          <target state="translated">포함 된 객체를 인수로 구성된 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; 유형 중 하나로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="7260987e96fdc55dd04ca01a135da1cbdd6808b1" translate="yes" xml:space="preserve">
          <source>Changes the current emit-on-sync policy.</source>
          <target state="translated">현재 동기화시 방출 정책을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="900063105ed808c1839aeda96993e8913c65dcff" translate="yes" xml:space="preserve">
          <source>Changes the current file name and number in the preprocessor.</source>
          <target state="translated">전 처리기에서 현재 파일 이름과 번호를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="bcd3bc7bc25f117f48576a1067f3eab87dc09962" translate="yes" xml:space="preserve">
          <source>Changes the filename of a file. The file is identified by character string pointed to by &lt;code&gt;old_filename&lt;/code&gt;. The new filename is identified by character string pointed to by &lt;code&gt;new_filename&lt;/code&gt;.</source>
          <target state="translated">파일의 파일 이름을 변경합니다. 파일은 &lt;code&gt;old_filename&lt;/code&gt; 이 가리키는 문자열로 식별됩니다 . 새 파일 이름은 &lt;code&gt;new_filename&lt;/code&gt; 이 가리키는 문자열로 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="a983560b5611c7eaf3bbb1134baa772fadd17a2a" translate="yes" xml:space="preserve">
          <source>Changes the filename of the directory entry.</source>
          <target state="translated">디렉토리 항목의 파일 이름을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="15ca90f2bd5d157747f2bcfd7fd13098d9365990" translate="yes" xml:space="preserve">
          <source>Changes the output format.</source>
          <target state="translated">출력 형식을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="028cce033fce6f33e2a026dffc3790dff3f7ae1a" translate="yes" xml:space="preserve">
          <source>Changes the size of the regular file named by &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html&quot;&gt;truncate&lt;/a&gt;: if the file size was previously larger than &lt;code&gt;new_size&lt;/code&gt;, the remainder of the file is discarded. If the file was previously smaller than &lt;code&gt;new_size&lt;/code&gt;, the file size is increased and the new area appears as if zero-filled.</source>
          <target state="translated">POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html&quot;&gt;truncate&lt;/a&gt; 에서처럼 &lt;code&gt;p&lt;/code&gt; 로 명명 된 일반 파일의 크기를 변경합니다 . 파일 크기가 이전에 &lt;code&gt;new_size&lt;/code&gt; 보다 큰 경우 나머지 파일은 삭제됩니다. 파일이 이전에 &lt;code&gt;new_size&lt;/code&gt; 보다 작은 경우 파일 크기가 증가하고 새 영역은 0으로 채워진 것처럼 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9f1702f311546e930d8f583ff60c5b7dafb56f91" translate="yes" xml:space="preserve">
          <source>Changes the the buffering mode of the given file stream &lt;code&gt;stream&lt;/code&gt; as indicated by the argument &lt;code&gt;mode&lt;/code&gt;. In addition,</source>
          <target state="translated">인수 &lt;code&gt;mode&lt;/code&gt; 로 표시되는 지정된 파일 스트림 &lt;code&gt;stream&lt;/code&gt; 의 버퍼링 모드를 변경 합니다 . 게다가,</target>
        </trans-unit>
        <trans-unit id="db66637e4bd602383b9a36e093d02ad744d50d19" translate="yes" xml:space="preserve">
          <source>CharT</source>
          <target state="translated">CharT</target>
        </trans-unit>
        <trans-unit id="075d1aa22da1d1a791ea28f036dd3029899ef7df" translate="yes" xml:space="preserve">
          <source>CharTarray&lt;code&gt;[&lt;/code&gt;n&lt;code&gt;]&lt;/code&gt;&lt;code&gt;= &quot;&quot;;&lt;/code&gt;</source>
          <target state="translated">CharTarray &lt;code&gt;[&lt;/code&gt; n &lt;code&gt;]&lt;/code&gt; &lt;code&gt;= &quot;&quot;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a40d3a3e7cab1d5912b21bb9180e2c135f3d1b0" translate="yes" xml:space="preserve">
          <source>CharTraits</source>
          <target state="translated">CharTraits</target>
        </trans-unit>
        <trans-unit id="ea0427dd5d6f2fd22fb387a84f007ebffee5c102" translate="yes" xml:space="preserve">
          <source>CharTraits is required by the following standard library class templates as a template type parameter:</source>
          <target state="translated">CharTraits는 다음 표준 라이브러리 클래스 템플리트에서 템플리트 유형 매개 변수로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0f52782a792cc00d2892c8162c4d20455ac882bd" translate="yes" xml:space="preserve">
          <source>CharTraits is satisfied by the following standard library classes:</source>
          <target state="translated">CharTraits는 다음 표준 라이브러리 클래스에 의해 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="ee9946c82d4a077c5be79e3015a3d2479d9fcaf2" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Character</target>
        </trans-unit>
        <trans-unit id="f72882235ad60f37016237d8303fb8c1162e42f0" translate="yes" xml:space="preserve">
          <source>Character and character string arguments (e.g., of type &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;const char*&lt;/code&gt;) are handled by the &lt;a href=&quot;operator_ltlt2&quot;&gt;non-member overloads&lt;/a&gt; of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. Attempting to output a character using the member function call syntax (e.g., &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.operator&amp;lt;&amp;lt;('c');&lt;/code&gt;) will call one of overloads (2-4) and output the numerical value. Attempting to output a character string using the member function call syntax will call overload (7) and print the pointer value instead.</source>
          <target state="translated">문자 및 문자열 인수 (예 : &lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;const char*&lt;/code&gt; 유형 )는 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;operator_ltlt2&quot;&gt;멤버&lt;/a&gt; 가 아닌 오버로드 에 의해 처리됩니다 . 멤버 함수 호출 구문 (예 : &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.operator&amp;lt;&amp;lt;('c');&lt;/code&gt; .operator &amp;lt;&amp;lt; ( 'c'); )을 사용하여 문자를 출력하려고하면 과부하 (2-4) 중 하나를 호출하고 숫자 값을 출력합니다. 멤버 함수 호출 구문을 사용하여 문자열을 출력하려고하면 오버로드 (7)를 호출하고 대신 포인터 값을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6512adfeb2b6b71a8085a0b4569a9025105f6ea1" translate="yes" xml:space="preserve">
          <source>Character array manipulation</source>
          <target state="translated">문자 배열 조작</target>
        </trans-unit>
        <trans-unit id="e6c2fd1aae71d170866344f96ee158518de8bbea" translate="yes" xml:space="preserve">
          <source>Character arrays</source>
          <target state="translated">문자형 배열</target>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="translated">문자 분류</target>
        </trans-unit>
        <trans-unit id="5e46fee36b88268f4391d4aab452946b36ee208f" translate="yes" xml:space="preserve">
          <source>Character conversions</source>
          <target state="translated">문자 변환</target>
        </trans-unit>
        <trans-unit id="ea3303247b226441481c96408e89f86363fc056f" translate="yes" xml:space="preserve">
          <source>Character converted to &lt;code&gt;char_type&lt;/code&gt;.</source>
          <target state="translated">문자가 &lt;code&gt;char_type&lt;/code&gt; 으로 변환되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c75ca2fc8c1a6a863ef50c02a9cfe0d0c2a00888" translate="yes" xml:space="preserve">
          <source>Character converted to its standard equivalent and then to &lt;code&gt;char&lt;/code&gt;. &lt;code&gt;dfault&lt;/code&gt; is returned if the conversion fails.</source>
          <target state="translated">문자가 해당 표준으로 변환 된 다음 &lt;code&gt;char&lt;/code&gt; 로 변환되었습니다 . 변환에 실패하면 &lt;code&gt;dfault&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="71abf6f6cdd425368811b306d03c5406b82396a5" translate="yes" xml:space="preserve">
          <source>Character manipulation</source>
          <target state="translated">캐릭터 조작</target>
        </trans-unit>
        <trans-unit id="4c58f86ca967b4e419cb22f348fc6985fce2677c" translate="yes" xml:space="preserve">
          <source>Character matching should be performed without regard to case.</source>
          <target state="translated">대소 문자를 구분하지 않고 문자를 일치시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="2c0613c06e2948d7013037f534e1060ec71035f9" translate="yes" xml:space="preserve">
          <source>Character ranges of the form</source>
          <target state="translated">형태의 문자 범위</target>
        </trans-unit>
        <trans-unit id="01b4f31695ebfef5e54e268eeccaa5f720d189d9" translate="yes" xml:space="preserve">
          <source>Character string identifying the value of the environmental variable or null pointer if such variable is not found.</source>
          <target state="translated">환경 변수의 값을 식별하는 문자열 또는 해당 변수를 찾을 수없는 경우 널 포인터</target>
        </trans-unit>
        <trans-unit id="ce6ddaa694e2a7b4942fbc87cf18e8f64d26f9b2" translate="yes" xml:space="preserve">
          <source>Character types</source>
          <target state="translated">문자 종류</target>
        </trans-unit>
        <trans-unit id="2fa17410341c773958ab0b06148ed01369e49360" translate="yes" xml:space="preserve">
          <source>Characteristics</source>
          <target state="translated">Characteristics</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="f75befe1513c72cfd4b48f48e3e273b661b4521f" translate="yes" xml:space="preserve">
          <source>Characters are extracted until either.</source>
          <target state="translated">문자는 어느 때 까지나 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="5d0fadb68912f46be7478bf1dc2a449a1ccab7e3" translate="yes" xml:space="preserve">
          <source>Characters following the null character are not compared.</source>
          <target state="translated">널 문자 뒤에 오는 문자는 비교되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbb7ac13141743e85ef9cf35d0729e5e44ee839e" translate="yes" xml:space="preserve">
          <source>Checks for the presence of an &lt;a href=&quot;language/attributes&quot;&gt;attribute&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;language/attributes&quot;&gt;속성&lt;/a&gt; 이 있는지 확인 합니다 .</target>
        </trans-unit>
        <trans-unit id="5c239cb24da30a931bb645a231c2c1a422922f55" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; is the only &lt;code&gt;shared_ptr&lt;/code&gt; instance managing the current object, i.e. whether &lt;code&gt;use_count() == 1&lt;/code&gt;.</source>
          <target state="translated">만약 점검 &lt;code&gt;*this&lt;/code&gt; 유일하다 &lt;code&gt;shared_ptr&lt;/code&gt; 의 현재 오브젝트를 관리하는 경우, 즉 여부 &lt;code&gt;use_count() == 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64fe6c568f795adfd098e0d63f6859cec6831cc6" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; represents a valid date. Because a &lt;code&gt;year_month_day_last&lt;/code&gt; represents the last day of a particular month, it represents a valid date as long as the year and month are valid.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 유효한 날짜 인지 확인합니다 . 때문에 &lt;code&gt;year_month_day_last&lt;/code&gt; 가 특정 월의 마지막 날을 나타냅니다, 그것은 연도와 월이 유효로만큼 유효한 날짜를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0373b2fbb18e3c084d0c6cb8a8392f2d23211bd2" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; stores a non-null pointer, i.e. whether &lt;code&gt;get() != nullptr&lt;/code&gt;.</source>
          <target state="translated">수표의 경우 &lt;code&gt;*this&lt;/code&gt; 저장 널이 아닌 포인터, 즉 여부 &lt;code&gt;get() != nullptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4fb57d3244245c7b2c53e5525199fd6990e81a5" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate type&lt;/a&gt;. The member constant &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is an aggregate type and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;집계 유형&lt;/a&gt; 인지 확인합니다 . 멤버 상수의 &lt;code&gt;value&lt;/code&gt; 동일하다 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;T&lt;/code&gt; 는 집합 형이고 &lt;code&gt;false&lt;/code&gt; 달리.</target>
        </trans-unit>
        <trans-unit id="46810c15e7731f0bcc598e64e82c003580066f60" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;ch&lt;/code&gt; is a printable character as classified by the currently installed C locale. In the default, &quot;C&quot; locale, the following characters are printable:</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 가 현재 설치된 C 로케일로 분류 된 인쇄 가능한 문자 인지 확인합니다 . 기본 &quot;C&quot;로켈에서 다음 문자를 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bef2c39f0952ee3e2e6df2eb7c4b6c1cb97c1231" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 가 있는지 확인</target>
        </trans-unit>
        <trans-unit id="8742a8ea58f9f8b2f58eab45ce84322d20b1ef7e" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;x&lt;/code&gt; is an integral power of two.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 2의 제곱 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e01f0ff952438d49e950107b31dc2f6d176fb839" translate="yes" xml:space="preserve">
          <source>Checks if all, any or none of the bits are set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">비트의 전부 또는 일부가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있는지 확인 합니다 .</target>
        </trans-unit>
        <trans-unit id="ebd2ed423ea71f7993be85315a4cf55c91df927f" translate="yes" xml:space="preserve">
          <source>Checks if an element equivalent to &lt;code&gt;value&lt;/code&gt; appears within the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 와 동등한 요소 가 &lt;code&gt;[first, last)&lt;/code&gt; 범위 내에 나타나는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="3df65edb22a1ea82942fb937399112c261a1ddf5" translate="yes" xml:space="preserve">
          <source>Checks if the &lt;code&gt;month&lt;/code&gt; object stored in &lt;code&gt;*this&lt;/code&gt; is valid.</source>
          <target state="translated">있는지 검사 &lt;code&gt;month&lt;/code&gt; 객체에 저장 &lt;code&gt;*this&lt;/code&gt; 유효합니다.</target>
        </trans-unit>
        <trans-unit id="cf1c1960bf8bd117039d083bce42dfd50d32f263" translate="yes" xml:space="preserve">
          <source>Checks if the contained &lt;a href=&quot;../month&quot;&gt;&lt;code&gt;month&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../weekday_indexed&quot;&gt;&lt;code&gt;weekday_indexed&lt;/code&gt;&lt;/a&gt; objects are valid.</source>
          <target state="translated">포함 된 &lt;a href=&quot;../month&quot;&gt; &lt;code&gt;month&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../weekday_indexed&quot;&gt; &lt;code&gt;weekday_indexed&lt;/code&gt; &lt;/a&gt; 객체가 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c0e9dbc22fbac3c623e99fa4b12c00c784887ebb" translate="yes" xml:space="preserve">
          <source>Checks if the contained &lt;a href=&quot;../month&quot;&gt;&lt;code&gt;month&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../weekday_last&quot;&gt;&lt;code&gt;weekday_last&lt;/code&gt;&lt;/a&gt; objects are valid.</source>
          <target state="translated">포함 된 &lt;a href=&quot;../month&quot;&gt; &lt;code&gt;month&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../weekday_last&quot;&gt; &lt;code&gt;weekday_last&lt;/code&gt; &lt;/a&gt; 객체가 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a186fda0be6fbf8b4f0463ca58545aab4b63c811" translate="yes" xml:space="preserve">
          <source>Checks if the container has no elements, i.e. whether &lt;code&gt;begin() == end()&lt;/code&gt;.</source>
          <target state="translated">컨테이너에 요소가 없는지 확인 &lt;code&gt;begin() == end()&lt;/code&gt; 예 : begin () == end ()) .</target>
        </trans-unit>
        <trans-unit id="bdababdda3b078e8a754954e78f43fa63c1e9fca" translate="yes" xml:space="preserve">
          <source>Checks if the day value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [1, 31].</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 저장된 일 값 이 유효한 범위에 있는지 확인합니다 ( 예 : [1, 31]).</target>
        </trans-unit>
        <trans-unit id="883d61f7b86b64216417405d15836a0059e52c16" translate="yes" xml:space="preserve">
          <source>Checks if the elements in range &lt;code&gt;[first, last)&lt;/code&gt; are a</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소 가 a인지 확인</target>
        </trans-unit>
        <trans-unit id="edd5932dbd43271b51bea92b6301c914eb0d9627" translate="yes" xml:space="preserve">
          <source>Checks if the elements in range &lt;code&gt;[first, last)&lt;/code&gt; are sorted in non-descending order.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소가 내림차순으로 정렬되어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="7583a23f352a0114e03ecd5b421ac82f127e76d4" translate="yes" xml:space="preserve">
          <source>Checks if the end of the given file stream has been reached.</source>
          <target state="translated">주어진 파일 스트림의 끝에 도달했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0ea631da0eac64b4493283ac77224a99a20a1afb" translate="yes" xml:space="preserve">
          <source>Checks if the error value is valid, i.e. non-zero.</source>
          <target state="translated">오류 값이 유효한지 확인합니다 (예 : 0이 아님).</target>
        </trans-unit>
        <trans-unit id="e0a4ec6efbb9408286b1f97366f614bd6aebe167" translate="yes" xml:space="preserve">
          <source>Checks if the file stream has an associated file.</source>
          <target state="translated">파일 스트림에 연결된 파일이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="9939f20d92c8448e034a9fb2ce041b3a30041e38" translate="yes" xml:space="preserve">
          <source>Checks if the first range &lt;code&gt;[first1, last1)&lt;/code&gt; is lexicographically</source>
          <target state="translated">첫 번째 범위 &lt;code&gt;[first1, last1)&lt;/code&gt; 가 사전 식 인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="9c9cf6d9c81ca1a6f48142b146482b5a7d92c18d" translate="yes" xml:space="preserve">
          <source>Checks if the future refers to a shared state.</source>
          <target state="translated">미래가 공유 상태를 나타내는 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1f541bb8843b33c6aed03a6b4cf9d5e87a333b18" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as a graphic character (i.e. printable, excluding space) by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">주어진 로케일의 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 주어진 문자가 그래픽 문자 (즉, 공백을 제외하고 인쇄 가능)로 분류되는지 확인</target>
        </trans-unit>
        <trans-unit id="2b8c77159013c45824384fde718470edb60e4d82" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as a printable character (including space) by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">주어진 로케일의 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 주어진 문자가 인쇄 가능한 문자 (공백 포함)로 분류되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="8c2b1f4fcd055b704d957a1b2cdeb2187a3b7dbc" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as an alphanumeric character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">지정된 문자가 지정된 로케일의 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 영숫자 문자로 분류되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="4f79c82fa33d708a83fc2cde057f0b8a25d9b077" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are classified as blank characters.</source>
          <target state="translated">주어진 문자가 현재 설치된 C 로케일로 분류 된 빈 문자인지 확인합니다. 공백 문자는 문장 내에서 단어를 구분하는 데 사용되는 공백 문자입니다. 기본 C 로캘에서는 공백 ( &lt;code&gt;0x20&lt;/code&gt; )과 가로 탭 ( &lt;code&gt;0x09&lt;/code&gt; ) 만 공백 문자로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="63924bd06b9cfc417682f6f2da0b8cccc1b40b2a" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a control character as classified by the currently installed C locale. In the default, &quot;C&quot; locale, the control characters are the characters with the codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt;.</source>
          <target state="translated">주어진 문자가 현재 설치된 C 로케일로 분류 된 제어 문자인지 확인합니다. 기본 &quot;C&quot;로케일에서 제어 문자는 코드가 &lt;code&gt;0x00-0x1F&lt;/code&gt; 및 &lt;code&gt;0x7F&lt;/code&gt; 인 문자 입니다.</target>
        </trans-unit>
        <trans-unit id="620ca22193327aabe490bc69707b719cd34918b4" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a hexadecimal numeric character (&lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;).</source>
          <target state="translated">주어진 문자가 16 진수 ( &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; )인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8b960e379d1de64e4dd59c0a98f8f7ba08f6e01b" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a punctuation character as classified by the current C locale. The default C locale classifies the characters &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; as punctuation.</source>
          <target state="translated">주어진 문자가 현재 C 로케일로 분류 된 문장 부호 문자인지 확인합니다. 기본 C 로케일은 &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; 문자를 문장 부호로 분류합니다.</target>
        </trans-unit>
        <trans-unit id="e36cb86f2350ed7cbcb8c08ff869f068fcb37a55" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphabetic character as classified by the currently installed C locale. In the default locale, the following characters are alphabetic:</source>
          <target state="translated">주어진 문자가 현재 설치된 C 로케일로 분류 된 알파벳 문자인지 확인합니다. 기본 로케일에서 다음 문자는 알파벳입니다.</target>
        </trans-unit>
        <trans-unit id="8460053f4f6257cbef25ff160120cc6c7e959e75" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:</source>
          <target state="translated">주어진 문자가 현재 C 로케일로 분류 된 영숫자 문자인지 확인합니다. 기본 로케일에서 다음 문자는 영숫자입니다.</target>
        </trans-unit>
        <trans-unit id="e7168f1ddb2b4d425325e246ea920d97240da433" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an uppercase character as classified by the currently installed C locale. In the default &quot;C&quot; locale, &lt;code&gt;isupper&lt;/code&gt; returns a nonzero value only for the uppercase letters (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;).</source>
          <target state="translated">주어진 문자가 현재 설치된 C 로케일로 분류 된 대문자인지 확인합니다. 기본 &quot;C&quot;로케일에서 &lt;code&gt;isupper&lt;/code&gt; 는 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; )에 대해서만 0이 아닌 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="11145349eb5a7ce12671e4ea9c07676f5f562772" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a blank character by the given locale's ctype facet.</source>
          <target state="translated">주어진 문자가 주어진 로케일의 ctype 패싯에 의해 공백 문자로 분류되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6d19f846387e2564dd01a4273fc111bb0f3752b9" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a control character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">주어진 문자가 주어진 로케일의 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 제어 문자로 분류되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d14d696222c936849b54795e37e65ab005fff8" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a digit by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">지정된 문자가 지정된 로케일의 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 숫자로 분류되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="65f5cc11ad968a30d5184556f3ca2929d52f75ca" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a hexadecimal digit by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">지정된 문자가 지정된 로케일의 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 16 진 숫자로 분류되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="5a564f70b3df82a305537021cab411cdbd81adce" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">지정된 문자가 지정된 로케일의 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 소문자 알파벳 문자로 분류되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2a2d197badc519c2b6d6b8c1c0f0089443b1e3e0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;islower&lt;/code&gt; returns a nonzero value only for the lowercase letters (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="translated">주어진 문자가 현재 C 로케일에 따라 소문자로 분류되는지 확인합니다. 기본 &quot;C&quot;로케일에서 &lt;code&gt;islower&lt;/code&gt; 는 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; )에 대해서만 0이 아닌 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="23434ffbce64a443ceebe9b25bfd4dee6b410a4d" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a whitespace character by the given locale's ctype facet.</source>
          <target state="translated">주어진 문자가 주어진 로케일의 ctype 패싯에 의해 공백 문자로 분류되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="29b8c4707acb6f5f5b0af799234d886e0c8bdb59" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">지정된 문자가 지정된 로케일의 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 알파벳 문자로 분류되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="f13395f8feb0b1900f02da016716c265861d48bd" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an punctuation character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">주어진 문자가 주어진 로케일의 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 문장 부호 문자로 분류되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="06bebae7934c976345409e18e4892deb4f07b810" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an uppercase alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">지정된 문자가 지정된 로케일의 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 대문자 알파벳 문자로 분류되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="05ecdcea5d58ceaa8ef5f1b140c063bf55d26ae8" translate="yes" xml:space="preserve">
          <source>Checks if the given character is graphic (has a graphical representation) as classified by the currently installed C locale. In the default C locale, the following characters are graphic:</source>
          <target state="translated">주어진 문자가 현재 설치된 C 로케일로 분류 된 그래픽인지 (그래픽 표시가 있는지) 확인합니다. 기본 C 로케일에서 다음 문자는 그래픽입니다.</target>
        </trans-unit>
        <trans-unit id="53e2f7b7aaa15bbc121a001ba778520977aa5a41" translate="yes" xml:space="preserve">
          <source>Checks if the given character is one of the 10 decimal digits: &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="translated">주어진 문자가 10 진수 10 진수 중 하나인지 확인합니다 : &lt;code&gt;0123456789&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe8cd0a6bef5c367f22c30f7a34e386596daca0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:</source>
          <target state="translated">주어진 문자가 현재 설치된 C 로케일로 분류 된 공백 문자인지 확인합니다. 기본 로케일에서 공백 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb1f23b247c77dd957a70ee1a23c0abb19665059" translate="yes" xml:space="preserve">
          <source>Checks if the given file status is known, Equivalent to &lt;code&gt;s.type() != file_type::none&lt;/code&gt;.</source>
          <target state="translated">주어진 파일 상태를 알고 있는지 확인합니다. &lt;code&gt;s.type() != file_type::none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="218bbbf54d03f6b2078dbf8b7f02244dc7b15314" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a FIFO or pipe file as if determined by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISFIFO&lt;/a&gt;.</source>
          <target state="translated">POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISFIFO에&lt;/a&gt; 의해 결정된 것처럼 주어진 파일 상태 또는 경로가 FIFO 또는 파이프 파일에 해당하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="a5bbc2239e82c8c44869791aa800f48187a92cdb" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a block special file, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISBLK &lt;/a&gt;. Examples of block special files are block devices such as &lt;code&gt;/dev/sda&lt;/code&gt; or &lt;code&gt;/dev/loop0&lt;/code&gt; on Linux.</source>
          <target state="translated">POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISBLK에&lt;/a&gt; 의해 결정된 것처럼 주어진 파일 상태 또는 경로가 블록 특수 파일에 해당하는지 확인합니다 . 블록 특수 파일의 예로는 Linux의 &lt;code&gt;/dev/sda&lt;/code&gt; 또는 &lt;code&gt;/dev/loop0&lt;/code&gt; 과 같은 블록 장치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd5468dc57f1c432cf3158ebdd4f2506febe1e97" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a character special file, as if determined by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISCHR&lt;/a&gt;. Examples of character special files are character devices such as &lt;code&gt;/dev/null&lt;/code&gt;, &lt;code&gt;/dev/tty&lt;/code&gt;, &lt;code&gt;/dev/audio&lt;/code&gt;, or &lt;code&gt;/dev/nvram&lt;/code&gt; on Linux.</source>
          <target state="translated">POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISCHR에&lt;/a&gt; 의해 결정된 것처럼 주어진 파일 상태 또는 경로가 문자 특수 파일에 해당하는지 확인합니다 . 문자 특수 파일의 예는 Linux의 &lt;code&gt;/dev/null&lt;/code&gt; , &lt;code&gt;/dev/tty&lt;/code&gt; , &lt;code&gt;/dev/audio&lt;/code&gt; 또는 &lt;code&gt;/dev/nvram&lt;/code&gt; 과 같은 문자 장치 입니다.</target>
        </trans-unit>
        <trans-unit id="5800e2498685522757fe31c5c55c07d4ca923fef" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a directory.</source>
          <target state="translated">주어진 파일 상태 또는 경로가 디렉토리에 해당하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1a93cdcd4a85825d11b2a20b899602004622f63c" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a file of type</source>
          <target state="translated">주어진 파일 상태 또는 경로가 파일 형식의 파일에 해당하는지 확인</target>
        </trans-unit>
        <trans-unit id="bac818da5390c8dda2cd14c441525beaeb1ca7ce" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a named IPC socket, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFSOCK&lt;/a&gt;.</source>
          <target state="translated">POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFSOCK에&lt;/a&gt; 의해 결정된 것처럼 지정된 파일 상태 또는 경로가 명명 된 IPC 소켓에 해당하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="5cbb58c72659913381cfab0101affa7e32b4218a" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a regular file.</source>
          <target state="translated">주어진 파일 상태 또는 경로가 일반 파일에 해당하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="069358c7a4934c3a0eff64f5a19fd200748050f4" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a symbolic link, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFLNK&lt;/a&gt;.</source>
          <target state="translated">POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFLNK에&lt;/a&gt; 의해 결정된 것처럼 지정된 파일 상태 또는 경로가 기호 링크에 해당하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="7887d8d69526f9ccd0654883e159eed9a48b721d" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to an existing file or directory.</source>
          <target state="translated">주어진 파일 상태 또는 경로가 기존 파일 또는 디렉토리에 해당하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="86e15e5f001ace8d5ed732d67f679b17b8027345" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), space or any printable character specific to the current C locale.</source>
          <target state="translated">지정된 넓은 문자를 인쇄 할 수 있는지 확인합니다. 즉, 숫자 ( &lt;code&gt;0123456789&lt;/code&gt; ), 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), 문장 부호 문자 ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ), 공백 또는 현재 C 로케일에 특정한 인쇄 가능한 문자.</target>
        </trans-unit>
        <trans-unit id="6ddf1d4606203515c454d3cbf72c353c2b7a5550" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;.</source>
          <target state="translated">주어진 넓은 문자가 16 진수 (예 : &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; 중 하나)에 해당하는지 (좁은 경우) 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="9737563245a39a0f23f82812e136487feb35b8a3" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="translated">주어진 넓은 문자가 10 진 10 진수 문자 &lt;code&gt;0123456789&lt;/code&gt; 중 하나에 해당하는지 (좁은 경우) 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="901c321d30a4b9e0c1bb0f4ce4f0b7f3fc5086ff" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;) or any graphical character specific to the current C locale.</source>
          <target state="translated">주어진 넓은 문자가 그래픽 표현인지, 즉 숫자 ( &lt;code&gt;0123456789&lt;/code&gt; ), 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), 문장 부호 문자 ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ) 또는 현재 C 로케일에 특정한 그래픽 문자.</target>
        </trans-unit>
        <trans-unit id="69347e858d3166f00f30fe95f9dd5f5ae37bc816" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt; and any control characters specific to the current locale.</source>
          <target state="translated">지정된 와이드 문자가 제어 문자 (예 : 코드 &lt;code&gt;0x00-0x1F&lt;/code&gt; 및 &lt;code&gt;0x7F&lt;/code&gt; ) 및 현재 로케일에 특정한 제어 문자인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f75e93760224f49060fa9daae484b93562cec26c" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a lowercase letter, i.e. one of &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; or any lowercase letter specific to the current locale.</source>
          <target state="translated">주어진 넓은 문자가 소문자인지, 즉 &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; 또는 현재 로케일에 특정한 소문자인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d3bc1df8c65e55dc36b4066a3cfbf00b5eb6d139" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a punctuation character, i.e. it is one of &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; or any punctuation character specific to the current locale.</source>
          <target state="translated">주어진 넓은 문자가 구두점 문자인지 확인합니다. 즉, &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; 또는 현재 로케일에 고유 한 문장 부호 문자입니다.</target>
        </trans-unit>
        <trans-unit id="7082207d2a2725304cb1acc7985965ef85b95446" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:</source>
          <target state="translated">주어진 넓은 문자가 현재 설치된 C 로케일로 분류 된 넓은 공백 문자인지 확인합니다. 기본 로케일에서 공백 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecee395d873139c5f79bbced8e5ab2094298ef99" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphabetic character specific to the current locale.</source>
          <target state="translated">주어진 넓은 문자가 알파벳 문자인지, 즉 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ) 또는 현재 로케일에 특정한 알파벳 문자인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5467527cb982943f926960fa171baeacafcc85de" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphanumeric character, i.e. either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphanumeric character specific to the current locale.</source>
          <target state="translated">주어진 넓은 문자가 영숫자 문자인지, 즉 숫자 ( &lt;code&gt;0123456789&lt;/code&gt; ), 대문자 ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), 소문자 ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ) 또는 현재 로케일에 특정한 영숫자 문자인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="43c33322c3d3cfbcbf8bd68f060fd927a3eb782d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an uppercase letter, i.e. one of &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; or any uppercase letter specific to the current locale.</source>
          <target state="translated">지정된 와이드 문자가 대문자인지 (즉, &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; 또는 현재 로케일에 특정한 대문자)인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1541b6076382859c29bdb454303ad0411f5bf188" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are blank characters.</source>
          <target state="translated">주어진 와이드 문자가 현재 C 로케일에 의해 공백 문자 (문에서 단어를 구분하는 데 사용되는 공백 문자)로 분류되는지 확인합니다. 기본 C 로캘에서는 공백 ( &lt;code&gt;0x20&lt;/code&gt; )과 가로 탭 ( &lt;code&gt;0x09&lt;/code&gt; ) 만 공백 문자입니다.</target>
        </trans-unit>
        <trans-unit id="5b129df05edbccc2dbdbb661453142c518a02f19" translate="yes" xml:space="preserve">
          <source>Checks if the identifier was &lt;a href=&quot;replace&quot;&gt;defined as a macro name&lt;/a&gt;.</source>
          <target state="translated">식별자가 &lt;a href=&quot;replace&quot;&gt;매크로 이름&lt;/a&gt; 으로 정의 되었는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="64cb0aa280d8c5b49543261dbfb062c65e2ea369" translate="yes" xml:space="preserve">
          <source>Checks if the locale &lt;code&gt;loc&lt;/code&gt; implements the facet &lt;code&gt;Facet&lt;/code&gt;.</source>
          <target state="translated">확인 로케일의 경우 &lt;code&gt;loc&lt;/code&gt; 패싯 구현 &lt;code&gt;Facet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9985c18b99c624309993b776322be3e5b6066d2" translate="yes" xml:space="preserve">
          <source>Checks if the month value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [1, 12].</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 저장된 월 값 이 유효한 범위 (예 : [1, 12])인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f0dd7dcb8d83418ab5c1982a79ec6863927fac41" translate="yes" xml:space="preserve">
          <source>Checks if the objects refer to the same types.</source>
          <target state="translated">객체가 동일한 유형을 참조하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="afce813d540f870643a2e6dca3dce7be3e73c275" translate="yes" xml:space="preserve">
          <source>Checks if the path in generic format is empty.</source>
          <target state="translated">일반 형식의 경로가 비어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="071d812ba3714e0179abe833e7757fda078f2ab3" translate="yes" xml:space="preserve">
          <source>Checks if the span is empty.</source>
          <target state="translated">스팬이 비어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8d21231b9c8a7c7e4c607dfb289d854bd85592b5" translate="yes" xml:space="preserve">
          <source>Checks if the string begins with the given prefix, where.</source>
          <target state="translated">문자열이 지정된 접두사로 시작하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="71b7c6ae3905a663f394b1116d26498963174727" translate="yes" xml:space="preserve">
          <source>Checks if the string ends with the given suffix, where.</source>
          <target state="translated">문자열이 주어진 접미사로 끝나는 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="49c8ee0c41c7b9956041b8533f0a3c22e35fb914" translate="yes" xml:space="preserve">
          <source>Checks if the string has no characters, i.e. whether &lt;code&gt;begin() == end()&lt;/code&gt;.</source>
          <target state="translated">문자열에 문자가 없는지 확인 &lt;code&gt;begin() == end()&lt;/code&gt; 예 : begin () == end ()) .</target>
        </trans-unit>
        <trans-unit id="f75909c8025e14e89620cb4160aa02ff233aed4b" translate="yes" xml:space="preserve">
          <source>Checks if the string view begins with the given prefix, where.</source>
          <target state="translated">문자열 뷰가 주어진 접두사로 시작하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7427d8a4aadff39d88d1b06e6bec36a6333d8cae" translate="yes" xml:space="preserve">
          <source>Checks if the string view ends with the given suffix, where.</source>
          <target state="translated">문자열보기가 주어진 접미사로 끝나는 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4c97dbdbc5ab4d6a6b9d169e205e7ed31539d6f2" translate="yes" xml:space="preserve">
          <source>Checks if the thread object identifies an active thread of execution. Specifically, returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;get_id() != &lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;()&lt;/code&gt;. So a default constructed &lt;code&gt;thread&lt;/code&gt; is not joinable.</source>
          <target state="translated">스레드 개체가 활성 실행 스레드를 식별하는지 확인합니다. 특히 &lt;code&gt;get_id() != &lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;id&quot;&gt;std :: thread :: id&lt;/a&gt; () 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 따라서 기본 생성 된 &lt;code&gt;thread&lt;/code&gt; 는 결합 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5f3b8028d75916c6cdb6ba96aa95864bd377eef" translate="yes" xml:space="preserve">
          <source>Checks if the underlying container has no elements, i.e. whether &lt;code&gt;c.empty()&lt;/code&gt;.</source>
          <target state="translated">기본 컨테이너에 요소가 없는지 확인합니다 &lt;code&gt;c.empty()&lt;/code&gt; 예 : c.empty ()) .</target>
        </trans-unit>
        <trans-unit id="a67620d24bc287120096a35fb784d0aa23f510f3" translate="yes" xml:space="preserve">
          <source>Checks if the variant &lt;code&gt;v&lt;/code&gt; holds the alternative &lt;code&gt;T&lt;/code&gt;. The call is ill-formed if &lt;code&gt;T&lt;/code&gt; does not appear exactly once in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">변형 &lt;code&gt;v&lt;/code&gt; 가 대체 &lt;code&gt;T&lt;/code&gt; 를 보유 하는지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Types...&lt;/code&gt; 정확히 한 번 나타나지 않으면 통화가 잘못 됩니다 ...</target>
        </trans-unit>
        <trans-unit id="af699c2fb33c530d4e019c89f05d9a81a1ed9be7" translate="yes" xml:space="preserve">
          <source>Checks if the view has no characters, i.e. whether &lt;code&gt;size() == 0&lt;/code&gt;.</source>
          <target state="translated">뷰에 문자가 없는지 확인 &lt;code&gt;size() == 0&lt;/code&gt; 예 : size () == 0) .</target>
        </trans-unit>
        <trans-unit id="1bb1c34feb70b41fb26ff6f15e61488cf7b90f70" translate="yes" xml:space="preserve">
          <source>Checks if the weekday object and the index stored in &lt;code&gt;*this&lt;/code&gt; are both valid.</source>
          <target state="translated">요일 개체와 &lt;code&gt;*this&lt;/code&gt; 에 저장된 인덱스 가 모두 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2f994a993b7fef807fb525562e15e1525c1a69a9" translate="yes" xml:space="preserve">
          <source>Checks if the weekday object stored in &lt;code&gt;*this&lt;/code&gt; is valid.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 저장된 요일 객체 가 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1b7ab4115c5420b5077429b962479db9584a2da3" translate="yes" xml:space="preserve">
          <source>Checks if the weekday value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [0, 6].</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 저장된 요일 값 이 유효한 범위에 있는지 확인합니다 ( 예 : [0, 6]).</target>
        </trans-unit>
        <trans-unit id="9931d20719fee825f5a129c05c9d24c6dd21e79b" translate="yes" xml:space="preserve">
          <source>Checks if the year and month values stored in this object are valid.</source>
          <target state="translated">이 객체에 저장된 연도 및 월 값이 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dd3b595aeae50a14c0fc3a412a6eb6ed2aaf74d7" translate="yes" xml:space="preserve">
          <source>Checks if the year value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [-32767, 32767].</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 저장된 연도 값 이 유효한 범위 (예 : [-32767, 32767])인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="464075ee2620831863a05ac3a062d2394191d131" translate="yes" xml:space="preserve">
          <source>Checks if this &lt;code&gt;year_month_day&lt;/code&gt; object represents a valid calendar date.</source>
          <target state="translated">이 &lt;code&gt;year_month_day&lt;/code&gt; 객체가 유효한 달력 날짜를 나타내는 지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2f08fd0aa437da8d48e5c7e55ec6138f44d1d5e3" translate="yes" xml:space="preserve">
          <source>Checks if this &lt;code&gt;year_month_weekday&lt;/code&gt; object represents a valid date.</source>
          <target state="translated">이 &lt;code&gt;year_month_weekday&lt;/code&gt; 객체가 유효한 날짜를 나타내는 지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="7012f03f45a478e758270c82fce18acc13dfab8e" translate="yes" xml:space="preserve">
          <source>Checks if this object represents a valid date. Since a &lt;code&gt;year_month_weekday_last&lt;/code&gt; represents the last weekday of a particular month, it is valid as long as the year, month and weekday are valid.</source>
          <target state="translated">이 개체가 유효한 날짜를 나타내는 지 확인합니다. &lt;code&gt;year_month_weekday_last&lt;/code&gt; 는 특정 월의 마지막 요일을 나타내 므로 해당 연도, 월 및 요일이 유효한 한 유효합니다.</target>
        </trans-unit>
        <trans-unit id="587976447f530aa6d25584b121ecdd151dbddd88" translate="yes" xml:space="preserve">
          <source>Checks the given stream for errors.</source>
          <target state="translated">주어진 스트림에 오류가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e063831806b4abf69aa95a8f1d0b948f8c9a0902" translate="yes" xml:space="preserve">
          <source>Checks the status of the sentry by calling &lt;code&gt;sentry::operator bool()&lt;/code&gt;, which is equivalent to &lt;a href=&quot;../io/basic_ios/good&quot;&gt;&lt;code&gt;basic_ios::good&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;sentry::operator bool()&lt;/code&gt; 을 호출하여 센트리의 상태를 점검합니다 . 이는 &lt;a href=&quot;../io/basic_ios/good&quot;&gt; &lt;code&gt;basic_ios::good&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="635ea4eba5accbfc249cd25209bcc3997533d8d6" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; contains a value.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 여기에 값 이 포함되어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="c38bd2aaae4ae9aad431571bc2897944efdb92f3" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; has a shared state.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 공유 상태 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="71b816d1cfbb4f8588b6af2666d0efc8ea0c81d9" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; owns a locked mutex or not.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 잠긴 뮤텍스를 소유 하는지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ed68d48f6a1e0644798c3fa0bfc8f385861ea72e" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; owns a locked mutex or not. Effectively calls &lt;code&gt;&lt;a href=&quot;owns_lock&quot;&gt;owns_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 잠긴 뮤텍스를 소유 하는지 여부를 확인합니다 . 효과적으로 &lt;code&gt;&lt;a href=&quot;owns_lock&quot;&gt;owns_lock()&lt;/a&gt;&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f31ae0eaa08456edf17a19eb82949ee2db0b8878" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; owns an object, i.e. whether &lt;code&gt;get() != nullptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 객체를 소유하는지, 즉 &lt;code&gt;get() != nullptr&lt;/code&gt; 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="4ed8174a7598bc58814343000b3811be1096f8ba" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; stores a callable function target, i.e. is not empty.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 함수는 호출 가능한 함수 대상을 저장 하는지 , 즉 비어 있지 않은지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="7022e1e52a32f5446f404931d6fe2823c8c69dd3" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/pointer&quot;&gt;pointer to object&lt;/a&gt; or a pointer to function (but not a pointer to member/member function). Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a object/function pointer type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../language/pointer&quot;&gt;객체에&lt;/a&gt; 대한 포인터 인지 또는 함수에 대한 포인터 인지 확인합니다 (하지만 멤버 / 멤버 함수에 대한 포인터는 아님). &lt;code&gt;T&lt;/code&gt; 가 객체 / 함수 포인터 유형 인 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f8a0aab7ac34afa964604fd6771adf4104c3b8e7" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a floating-point type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, including any cv-qualified variants. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 부동 소수점 유형 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 cv-qualified 변형을 포함하여 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; 유형 인 경우 &lt;code&gt;true&lt;/code&gt; 와 같은 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e59abc34df71bdf6c32c2c5ea33dd17229fe5b19" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a function type. Types like &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, lambdas, classes with overloaded &lt;code&gt;operator()&lt;/code&gt; and pointers to functions don't count as function types. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a function type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 함수 유형 인지 확인합니다 . 같은 유형 &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , 람다, 오버로드와 클래스 &lt;code&gt;operator()&lt;/code&gt; 함수와 포인터 기능 유형으로 포함되지 않습니다. &lt;code&gt;T&lt;/code&gt; 가 함수 유형 인 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공합니다. 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3e28cb24a251f49a5aebb9fae5f5a3ec5667c582" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a lvalue reference type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a lvalue reference type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 lvalue 참조 유형 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 lvalue 참조 유형 인 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0b883e14dd2e029695b8fd5542cec26d4e9260ac" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a non-static member function pointer. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a non-static member function pointer type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 비 정적 멤버 함수 포인터 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 비 정적 멤버 함수 포인터 유형 인 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9164f6a53718da4919f5f96385b37cf47562a131" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a non-static member object. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a non-static member object type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 비 정적 구성원 개체 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 비 정적 멤버 객체 유형 인 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7ecf7dc059b4ed93776d32d000af1b4107668e74" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a non-union class type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a class type (but not union). Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 비 유니언 클래스 유형 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 클래스 유형이지만 공용체가 아닌 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2bedc64ebaaa15f40dee6eca6d599bd4bb747d7b" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a rvalue reference type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a rvalue reference type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 rvalue 참조 유형 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 rvalue 참조 유형 인 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4a8715fd468c9164b80d434876b0f9a130176110" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a standard or implementation-defined execution policy type.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 표준 또는 구현 정의 실행 정책 유형 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="dfe90d9b7dabaa2818a7d2a0d184dea435b97627" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a union type. Provides the member constant &lt;code&gt;value&lt;/code&gt;, which is equal to &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a union type . Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 공용체 유형 인지 확인합니다 . 멤버 상수 &lt;code&gt;value&lt;/code&gt; 제공합니다.이 상수 는 &lt;code&gt;T&lt;/code&gt; 가 공용체 유형 인 경우 &lt;code&gt;true&lt;/code&gt; 입니다. 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e6df4126bdcc6310ebb0cdad5780493d77d0c187" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a void type. Provides the member constant &lt;code&gt;value&lt;/code&gt; that is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;const void&lt;/code&gt;, &lt;code&gt;volatile void&lt;/code&gt;, or &lt;code&gt;const volatile void&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 void 유형 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;void&lt;/code&gt; , &lt;code&gt;const void&lt;/code&gt; , &lt;code&gt;volatile void&lt;/code&gt; 또는 &lt;code&gt;const volatile void&lt;/code&gt; 유형 인 경우 &lt;code&gt;true&lt;/code&gt; 와 같은 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2be34e132a60607ab5dd9c04136e75642192abbf" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/array#Arrays_of_unknown_bound&quot;&gt;array type of unknown bound&lt;/a&gt;. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an array type of unknown bound. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../language/array#Arrays_of_unknown_bound&quot;&gt;알 수없는 바운드&lt;/a&gt; 의 배열 유형 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 알 수없는 바운드의 배열 유형 인 경우 &lt;code&gt;true&lt;/code&gt; 와 같은 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1833b30272f19f6543d86fb787e9532baf6350d0" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/enum&quot;&gt;enumeration type&lt;/a&gt;. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an enumeration type . Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../language/enum&quot;&gt;열거 형&lt;/a&gt; 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 열거 형인 경우 &lt;code&gt;true&lt;/code&gt; 과 동일한 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="130f7441ba35a78873bfe867bf57a2fe54bb8190" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an array type of known bound. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an array type of known bound. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 알려진 바운드의 배열 유형 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 알려진 바운드의 배열 유형 인 경우 &lt;code&gt;true&lt;/code&gt; 인 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8f1fcc5981b134a62c10ce0c25e9c946467ed28b" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an array type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an array type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 배열 유형 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 배열 유형 인 경우 &lt;code&gt;true&lt;/code&gt; 인 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 제공합니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1d91afb5a075ac60e9677a8cc4754febe1adbc79" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an integral type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, or any implementation-defined extended integer types, including any signed, unsigned, and cv-qualified variants. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 정수 유형 인지 확인합니다 . &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; 또는 부호있는 것을 포함하여 구현 정의 확장 정수 유형 인 경우 &lt;code&gt;true&lt;/code&gt; 와 같은 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 제공합니다. 부호없는 cv-qualified 변형. 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bffa9e6d94cce1dcc42a4c7c509890d27926c672" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 유형 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="f73a2b89f64c132a7a2db95ab8f3890b3255a62a" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;e&lt;/code&gt; is not equivalent to</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 가 동일하지 않은지 확인</target>
        </trans-unit>
        <trans-unit id="a77ef24ff3015dfba3640ad0d13f58fcf1e32d5e" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 가 있는지 확인</target>
        </trans-unit>
        <trans-unit id="f66fee9824887853dd82d29f509864b5623f6f69" translate="yes" xml:space="preserve">
          <source>Checks whether both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;it&lt;/code&gt; are valid, or both are invalid, regardless of the stream buffer objects they use.</source>
          <target state="translated">양쪽 검사인지 &lt;code&gt;*this&lt;/code&gt; 하고 &lt;code&gt;it&lt;/code&gt; 유효한지 또는 모두없이, 스트림 버퍼들이 사용 목적, 무효.</target>
        </trans-unit>
        <trans-unit id="b4244940d730169d64aee1da2da131b1ed135f26" translate="yes" xml:space="preserve">
          <source>Checks whether both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal. Two stream iterators are equal if both of them are end-of-stream iterators or both of them refer to the same stream.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은지 확인합니다 . 두 스트림 반복자가 둘 다 스트림 끝 반복자이거나 둘 다 동일한 스트림을 참조하면 두 스트림 반복자가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="87eaad996e60cbb3cfe0fcdde3be3c14e4f9c4d4" translate="yes" xml:space="preserve">
          <source>Checks whether both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are valid, or both are invalid, regardless of the stream buffer objects they use.</source>
          <target state="translated">사용하는 스트림 버퍼 객체에 관계없이 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 모두 유효한지 또는 둘 다 유효한지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="229342a11042ce2ed84a995d5ff77f850ed69020" translate="yes" xml:space="preserve">
          <source>Checks whether error code is equivalent to an error condition for the error category represented by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">오류 코드가 &lt;code&gt;*this&lt;/code&gt; 로 표시되는 오류 범주의 오류 조건과 동일한 지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="43194b114099424f38087d59c9ce8423ad80e636" translate="yes" xml:space="preserve">
          <source>Checks whether the atomic operations on all objects of this type are lock-free.</source>
          <target state="translated">이 유형의 모든 객체에 대한 원자 연산에 잠금이 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7846cd20df099e25c9a395f85406d0c13c14521b" translate="yes" xml:space="preserve">
          <source>Checks whether the atomic operations on this object are lock-free.</source>
          <target state="translated">이 객체에 대한 원 자성 작업에 잠금이 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c1704ab82dfc96f2bfbaf877fe0ee93b65d75c37" translate="yes" xml:space="preserve">
          <source>Checks whether the given path refers to an empty file or directory.</source>
          <target state="translated">지정된 경로가 빈 파일 또는 디렉토리를 나타내는 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b5fe5582e4c95a42678f653d245fc0d8ca7e77c8" translate="yes" xml:space="preserve">
          <source>Checks whether the match was successful.</source>
          <target state="translated">일치 여부를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="37b6b4e530b3a44ad4560ab7cb9ddc3bdf92e02b" translate="yes" xml:space="preserve">
          <source>Checks whether the object contains a value.</source>
          <target state="translated">객체에 값이 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4dea1801ed41e688c9e6537be30704d3706b1021" translate="yes" xml:space="preserve">
          <source>Checks whether the path contains the corresponding path element.</source>
          <target state="translated">경로에 해당 경로 요소가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f5ac19b39ecb671ac7a345baa1d1f56bbccd9a62" translate="yes" xml:space="preserve">
          <source>Checks whether the path is absolute or relative. An absolute path is a path that unambiguously identifies the location of a file without reference to an additional starting location. The first version returns &lt;code&gt;true&lt;/code&gt; if the path, in native format, is absolute, &lt;code&gt;false&lt;/code&gt; otherwise; the second version the other way round.</source>
          <target state="translated">경로가 절대인지 상대인지 확인합니다. 절대 경로는 추가 시작 위치를 참조하지 않고 파일의 위치를 ​​명확하게 식별하는 경로입니다. 첫 번째 버전은 기본 형식의 경로가 절대 경로 &lt;code&gt;true&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다. 다른 방법으로는 두 번째 버전입니다.</target>
        </trans-unit>
        <trans-unit id="1c6d7504c98282a80ee4254b4ab667a6d5ecaf40" translate="yes" xml:space="preserve">
          <source>Checks whether the paths &lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt; resolve to the same file system entity.</source>
          <target state="translated">경로 &lt;code&gt;p1&lt;/code&gt; 및 &lt;code&gt;p2&lt;/code&gt; 가 동일한 파일 시스템 엔티티로 해석 되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="d03ecb587e7beec78ef27e7550fba2bb1b68ac55" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object exists. Effectively returns &lt;code&gt;std::filesystem::exists(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::exists(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">지정된 객체가 존재하는지 확인합니다. 효과적으로 &lt;code&gt;std::filesystem::exists(status())&lt;/code&gt; 또는 &lt;code&gt;std::filesystem::exists(status(ec))&lt;/code&gt; 를 각각 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7ea5dd068aa953cd3a0e1bd7233cfb66ad43dfac" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a FIFO or pipe file. Effectively returns &lt;code&gt;std::filesystem::is_fifo(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_fifo(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">지정된 객체가 FIFO인지 파이프 파일인지 확인합니다. 효과적으로 &lt;code&gt;std::filesystem::is_fifo(status())&lt;/code&gt; 또는 &lt;code&gt;std::filesystem::is_fifo(status(ec))&lt;/code&gt; 를 각각 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="38196c9d5c220a32c0349e4637ac5aa258b11038" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a block device. Effectively returns &lt;code&gt;std::filesystem::is_block_file(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_block_file(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">지정된 객체가 블록 장치인지 확인합니다. 효과적으로 &lt;code&gt;std::filesystem::is_block_file(status())&lt;/code&gt; 또는 &lt;code&gt;std::filesystem::is_block_file(status(ec))&lt;/code&gt; 을 각각 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="751e0118d57f62587cc9a3a0af0af434ad3c1600" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a character device. Effectively returns &lt;code&gt;std::filesystem::is_character_file(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_character_file(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">지정된 객체가 문자 장치인지 확인합니다. 효과적으로 &lt;code&gt;std::filesystem::is_character_file(status())&lt;/code&gt; 또는 &lt;code&gt;std::filesystem::is_character_file(status(ec))&lt;/code&gt; 을 각각 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0540859f0b874033d66529a5545b918e9abbefb3" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a directory. Effectively returns &lt;code&gt;std::filesystem::is_directory(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_directory(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">지정된 객체가 디렉토리인지 확인합니다. 효과적으로 &lt;code&gt;std::filesystem::is_directory(status())&lt;/code&gt; 또는 &lt;code&gt;std::filesystem::is_directory(status(ec))&lt;/code&gt; 를 각각 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2308e9815e22ffba2f923b2d946ea52b4cda4576" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a named socket. Effectively returns &lt;code&gt;std::filesystem::is_socket(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_socket(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">지정된 객체가 명명 된 소켓인지 확인합니다. 효과적으로 &lt;code&gt;std::filesystem::is_socket(status())&lt;/code&gt; 또는 &lt;code&gt;std::filesystem::is_socket(status(ec))&lt;/code&gt; 을 각각 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b951526e00e6f97e074e12e389d2a9920ec6315e" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a regular file. Effectively returns &lt;code&gt;std::filesystem::is_regular_file(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_regular_file(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">지정된 객체가 일반 파일인지 확인합니다. 효과적으로 &lt;code&gt;std::filesystem::is_regular_file(status())&lt;/code&gt; 또는 &lt;code&gt;std::filesystem::is_regular_file(status(ec))&lt;/code&gt; 을 각각 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="acf48ae97d4d120a878b0e576cd023878de18fa6" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a symlink. Effectively returns &lt;code&gt;std::filesystem::is_symlink(symlink_status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_symlink(symlink_status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">지정된 객체가 심볼릭 링크인지 확인합니다. 효과적으로 &lt;code&gt;std::filesystem::is_symlink(symlink_status())&lt;/code&gt; 또는 &lt;code&gt;std::filesystem::is_symlink(symlink_status(ec))&lt;/code&gt; 를 각각 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="279a1e6eab42861c169fe61939f083dce62d93e0" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is an</source>
          <target state="translated">지정된 객체가 객체인지 확인</target>
        </trans-unit>
        <trans-unit id="8e8a0961bfa95374e31de6c178abd1091a03292e" translate="yes" xml:space="preserve">
          <source>Checks whether the preparation of the input stream was successful.</source>
          <target state="translated">입력 스트림 준비가 완료되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6813cbedc840219b2040df151acc0737b0c8c377" translate="yes" xml:space="preserve">
          <source>Checks whether the preparation of the output stream was successful.</source>
          <target state="translated">출력 스트림 준비가 완료되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="34d57af6172a5843af278992c90022d6be885f65" translate="yes" xml:space="preserve">
          <source>Checks whether the stored error code is not zero.</source>
          <target state="translated">저장된 오류 코드가 0이 아닌지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a10aac416e423604412995d69f280cd38d6aa63f" translate="yes" xml:space="preserve">
          <source>Checks whether the stream has no errors.</source>
          <target state="translated">스트림에 오류가 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7558d5daa29a73a6092a6bb0ffb197bd0adfe9f6" translate="yes" xml:space="preserve">
          <source>Checks whether this &lt;code&gt;shared_ptr&lt;/code&gt; precedes &lt;code&gt;other&lt;/code&gt; in implementation defined owner-based (as opposed to value-based) order. The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by get() are different (e.g. because they point at different subobjects within the same object).</source>
          <target state="translated">구현 기반 소유자 기반 (값 기반이 아닌) 순서 에서이 &lt;code&gt;shared_ptr&lt;/code&gt; 이 &lt;code&gt;other&lt;/code&gt; 보다 우선 하는지 여부를 확인합니다 . 순서는 두 개의 스마트 포인터가 둘 다 비어 있거나 get ()에 의해 얻은 포인터 값이 다른 경우에도 동일한 객체를 소유하는 경우에만 동등한 것을 비교하도록하는 것입니다 (예 : 동일한 하위 내에서 다른 하위 객체를 가리 키기 때문에) 목적).</target>
        </trans-unit>
        <trans-unit id="c75ecfbdc7f9038d0ac97b90b6953481e5484923" translate="yes" xml:space="preserve">
          <source>Checks whether this &lt;code&gt;weak_ptr&lt;/code&gt; precedes &lt;code&gt;other&lt;/code&gt; in implementation defined owner-based (as opposed to value-based) order. The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by get() are different (e.g. because they point at different subobjects within the same object).</source>
          <target state="translated">이 &lt;code&gt;weak_ptr&lt;/code&gt; 이 구현 정의 소유자 기반 (값 기반이 아닌) 순서에서 &lt;code&gt;other&lt;/code&gt; 보다 우선 하는지 여부를 확인합니다 . 순서는 두 개의 스마트 포인터가 둘 다 비어 있거나 get ()에 의해 얻은 포인터 값이 다른 경우에도 동일한 객체를 소유하는 경우에만 동등한 것을 비교하도록하는 것입니다 (예 : 동일한 하위 내에서 다른 하위 객체를 가리 키기 때문에) 목적).</target>
        </trans-unit>
        <trans-unit id="9e99c517d029e72bf940a22ccc78ab9409097406" translate="yes" xml:space="preserve">
          <source>Checks whether two values of type &lt;code&gt;int_type&lt;/code&gt; are equal.</source>
          <target state="translated">&lt;code&gt;int_type&lt;/code&gt; 유형의 두 값 이 같은지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="34eb3f9df1785987205174d978835deeb45e94ad" translate="yes" xml:space="preserve">
          <source>Choose clang to observe the output shown.</source>
          <target state="translated">표시된 출력을 관찰하려면 clang을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="0dd1c8b596b65fa50cf7f5efdd880ad3089168ac" translate="yes" xml:space="preserve">
          <source>Clang++3.0 libc++</source>
          <target state="translated">Clang ++ 3.0 libc ++</target>
        </trans-unit>
        <trans-unit id="128f6dc5d7caa59dda6044d3e8e6c55352499ea0" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">클래스 &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04c10a537c6bab1bf5c4017ce72824562df9ab4f" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../atomic/atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">클래스 &lt;code&gt;&lt;a href=&quot;../atomic/atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d939a5c95da9331b931381710149919c5d9fa22" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../chrono/c/timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">클래스 &lt;code&gt;&lt;a href=&quot;../chrono/c/timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0fa1da504a8e1edfacf0be0377679a386d14664" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">클래스 &lt;code&gt;&lt;a href=&quot;../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a55038579f31c03e4e93f4a6273203742021c97" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">클래스 &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="225da75ec2fdc972d380bbb0e74573b3ffe5aab4" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">클래스 &lt;code&gt;&lt;a href=&quot;../container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
