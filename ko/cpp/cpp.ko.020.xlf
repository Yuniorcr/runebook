<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="0dc45828951839d51ed09a34e9ec04114252f1c0" translate="yes" xml:space="preserve">
          <source>SIG_ATOMIC_MAX</source>
          <target state="translated">SIG_ATOMIC_MAX</target>
        </trans-unit>
        <trans-unit id="ed5fe11c179ff72e658bdf95049d44be1deebeae" translate="yes" xml:space="preserve">
          <source>SIG_ATOMIC_MIN</source>
          <target state="translated">SIG_ATOMIC_MIN</target>
        </trans-unit>
        <trans-unit id="11ba97d97359684906853156cac74443ad3705c5" translate="yes" xml:space="preserve">
          <source>SIG_DFL, SIG_IGN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6895a2910b6ef7a004e7772ca3f499a19fa27cde" translate="yes" xml:space="preserve">
          <source>SIG_DFLSIG_IGN</source>
          <target state="translated">SIG_DFLSIG_IGN</target>
        </trans-unit>
        <trans-unit id="acd6ee1f7bbae2aab00eb4fc3df100932eee5d46" translate="yes" xml:space="preserve">
          <source>SIG_ERR</source>
          <target state="translated">SIG_ERR</target>
        </trans-unit>
        <trans-unit id="6a03d61729004eed59186d910c6f0d01251b936b" translate="yes" xml:space="preserve">
          <source>SIG_IGN</source>
          <target state="translated">SIG_IGN</target>
        </trans-unit>
        <trans-unit id="256c9f9a067e633db18da0ec81de7b585e074898" translate="yes" xml:space="preserve">
          <source>SIZE_MAX</source>
          <target state="translated">SIZE_MAX</target>
        </trans-unit>
        <trans-unit id="6b120e14066922d2c95dfb4dc0409090007a4356" translate="yes" xml:space="preserve">
          <source>SOFT HYPHEN</source>
          <target state="translated">소프트 하이픈</target>
        </trans-unit>
        <trans-unit id="35adac21ea20f23e44a0f9718d8d1c8194e953c8" translate="yes" xml:space="preserve">
          <source>SOO</source>
          <target state="translated">SOO</target>
        </trans-unit>
        <trans-unit id="5fa55a6001cc9852171849c95c4031c7b8464066" translate="yes" xml:space="preserve">
          <source>SSO</source>
          <target state="translated">SSO</target>
        </trans-unit>
        <trans-unit id="d77543daa1a67aba4224a92c3a2e905f4d7d3caf" translate="yes" xml:space="preserve">
          <source>SUPERSCRIPT TWO - MICRO SIGN</source>
          <target state="translated">슈퍼 스크립 션 2-MICRO SIGN</target>
        </trans-unit>
        <trans-unit id="ecc39ffd33475d94ae9c3663ce19924217f5ad56" translate="yes" xml:space="preserve">
          <source>SYRIAC LETTER BETH - GREEK DASIA</source>
          <target state="translated">시리아 레터 베스-그리스</target>
        </trans-unit>
        <trans-unit id="9f9ffea621b762dbfb7be294c8d40ffe49bec187" translate="yes" xml:space="preserve">
          <source>Safely converts pointers and references to classes up, down, and sideways along the inheritance hierarchy.</source>
          <target state="translated">상속 계층을 따라 포인터와 참조를 클래스의 위, 아래 및 옆으로 안전하게 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b76aee974c5bb8b37f0f7cb657a1de3a091c77c3" translate="yes" xml:space="preserve">
          <source>Same</source>
          <target state="translated">Same</target>
        </trans-unit>
        <trans-unit id="a744c69a2ecd83490fd88d463f1cfbe827dbb30e" translate="yes" xml:space="preserve">
          <source>Same applies to dot operator following an integer or floating-point user-defined literal:</source>
          <target state="translated">정수 또는 부동 소수점 사용자 정의 리터럴을 따르는 도트 연산자에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="66a5254cea4091f8ebcab7a4aa66c35896845aed" translate="yes" xml:space="preserve">
          <source>Same applies to the lifetime of the object pointed to by the captured &lt;code&gt;this&lt;/code&gt; pointer.</source>
          <target state="translated">캡처 된 &lt;code&gt;this&lt;/code&gt; 포인터가 가리키는 객체의 수명에도 동일하게 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c7b71f021b8cdf1bd6c0b20d7e10412fb74444f" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;p&lt;/code&gt;'s construction</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 의 구성 과 동일</target>
        </trans-unit>
        <trans-unit id="b6c01bbf4fe382bbcb4f95f2825434f25228cf1c" translate="yes" xml:space="preserve">
          <source>Same as glvalue (below).</source>
          <target state="translated">glvalue와 동일합니다 (아래).</target>
        </trans-unit>
        <trans-unit id="84f78fbebf7e3bcf9865660ef89b13869f35e07f" translate="yes" xml:space="preserve">
          <source>Same as rvalue (below).</source>
          <target state="translated">rvalue (아래)와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c0f78a1b71ae77c728d70862a9e3368568083194" translate="yes" xml:space="preserve">
          <source>Same as swapping the underlying container.</source>
          <target state="translated">기본 컨테이너를 바꾸는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="054e7e20cdfbca536050cb79e89a02a85759a9a9" translate="yes" xml:space="preserve">
          <source>Same as the corresponding operation on the wrapped container.</source>
          <target state="translated">랩핑 된 컨테이너의 해당 작업과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0e1da25a3233f63ae21f226c776372740cc6993a" translate="yes" xml:space="preserve">
          <source>Same as underlying container (typically constant).</source>
          <target state="translated">기본 컨테이너와 동일합니다 (일반적으로 상수).</target>
        </trans-unit>
        <trans-unit id="e7796be95ee97968bc00eac447bfca361f350fb8" translate="yes" xml:space="preserve">
          <source>Sampling distributions</source>
          <target state="translated">샘플링 분포</target>
        </trans-unit>
        <trans-unit id="9aa4ace930e13f1369da3a2f415ac3d312db56cf" translate="yes" xml:space="preserve">
          <source>Satisfaction of an atomic constraint is checked by substituting the parameter mapping and template arguments into the expression &lt;code&gt;E&lt;/code&gt;. If the substitution results in an invalid type or expression, the constraint is not satisfied. Otherwise, &lt;code&gt;E&lt;/code&gt;, after any lvalue-to-rvalue conversion, shall be a prvalue constant expression of type &lt;code&gt;bool&lt;/code&gt; , and the constraint is satisfied if and only if it evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">원자 제한 조건의 만족은 매개 변수 맵핑 및 템플리트 인수를 표현식 &lt;code&gt;E&lt;/code&gt; 로 대체하여 점검됩니다 . 대체 결과에 유효하지 않은 유형 또는 표현식이 있으면 제한 조건이 충족되지 않습니다. 그렇지 않으면, lvalue-to-rvalue 변환 후 &lt;code&gt;E&lt;/code&gt; 는 &lt;code&gt;bool&lt;/code&gt; 유형의 prvalue 상수 표현식이어야하며 제약 조건이 &lt;code&gt;true&lt;/code&gt; 로 평가되는 경우에만 만족됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a79fb659ab4ca153a9d632c0dbfaa99b80dbe0d" translate="yes" xml:space="preserve">
          <source>Satisfies &lt;a href=&quot;nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;, &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, and &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; (see &lt;a href=&quot;allocator#Fancy_pointers&quot;&gt;fancy pointers&lt;/a&gt; below)</source>
          <target state="translated">&lt;a href=&quot;nullablepointer&quot;&gt;NullablePointer&lt;/a&gt; , &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 및 &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterator를&lt;/a&gt; 만족 시킵니다 (아래의 &lt;a href=&quot;allocator#Fancy_pointers&quot;&gt;멋진 포인터&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="c939f8b440f4e444c93888c7523c6a753295690a" translate="yes" xml:space="preserve">
          <source>Saves a copy of the current pointer &lt;code&gt;old_ptr = current_ptr&lt;/code&gt;</source>
          <target state="translated">현재 포인터의 사본을 저장합니다. &lt;code&gt;old_ptr = current_ptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6dcd124e9d2652692f02ca05f075f2889be740f0" translate="yes" xml:space="preserve">
          <source>Saves the current execution context into a variable &lt;code&gt;env&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;std::jmp_buf&lt;/a&gt;&lt;/code&gt;. This variable can later be used to restore the current execution context by &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; function. That is, when a call to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; function is made, the execution continues at the particular call site that constructed the &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;std::jmp_buf&lt;/a&gt;&lt;/code&gt; variable passed to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt;. In that case &lt;code&gt;setjmp&lt;/code&gt; returns the value passed to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 실행 컨텍스트를 &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;std::jmp_buf&lt;/a&gt;&lt;/code&gt; 유형 의 변수 &lt;code&gt;env&lt;/code&gt; 에 저장합니다 . 이 변수는 나중에 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; 함수로 현재 실행 컨텍스트를 복원하는 데 사용할 수 있습니다 . 즉, &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; 함수를 호출 할 때 &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;std::jmp_buf&lt;/a&gt;&lt;/code&gt; 변수 를 구성한 특정 호출 사이트 에서 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; 전달 된 실행이 계속됩니다 . 이 경우 &lt;code&gt;setjmp&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; 전달 된 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f0e38625398ddd28f177386b7df9d368b87ce9c8" translate="yes" xml:space="preserve">
          <source>Scalar types and arrays of TriviallyCopyable objects are TriviallyCopyable as well, as well as the &lt;a href=&quot;../language/cv&quot;&gt;const&lt;/a&gt;-qualified (but not &lt;a href=&quot;../language/cv&quot;&gt;volatile&lt;/a&gt;-qualified) versions of such types.</source>
          <target state="translated">TriviallyCopyable 객체의 스칼라 유형 및 배열은 이러한 유형의 &lt;a href=&quot;../language/cv&quot;&gt;const&lt;/a&gt; -qualified (그러나 &lt;a href=&quot;../language/cv&quot;&gt;휘발성이&lt;/a&gt; 아닌 ) 버전 뿐만 아니라 TriviallyCopyable 입니다.</target>
        </trans-unit>
        <trans-unit id="94a0975d11ee0823098d55f8c5543d8c95757535" translate="yes" xml:space="preserve">
          <source>Scan an array of mailboxes, and process only the ones intended for us, without unnecessary synchronization. This example uses atomic-fence synchronization.</source>
          <target state="translated">사서함 배열을 스캔하고 불필요한 동기화없이 원하는 사서함 만 처리하십시오. 이 예는 원자 울타리 동기화를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="39320a9f36bca32338b46a710d9f674ca8c85e52" translate="yes" xml:space="preserve">
          <source>Scans the null-terminated byte string pointed to by &lt;code&gt;dest&lt;/code&gt; for any character from the null-terminated byte string pointed to by &lt;code&gt;breakset&lt;/code&gt;, and returns a pointer to that character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="3c0fabcd3460b1386add05b5b912787b96bceeaa" translate="yes" xml:space="preserve">
          <source>Scope begins at the</source>
          <target state="translated">범위는</target>
        </trans-unit>
        <trans-unit id="4317efd965faa4c9e59bd6003e10dbe6e565fc82" translate="yes" xml:space="preserve">
          <source>Scope resolution</source>
          <target state="translated">범위 해상도</target>
        </trans-unit>
        <trans-unit id="931b2f0203a11cf4f16ccf11a8abc5d164f83cd5" translate="yes" xml:space="preserve">
          <source>Scope-Bound Resource Management</source>
          <target state="translated">범위 바운드 리소스 관리</target>
        </trans-unit>
        <trans-unit id="6144de524b9c3009de80c6ebb469d9da9d780fe8" translate="yes" xml:space="preserve">
          <source>Scoped enumerations</source>
          <target state="translated">범위가 지정된 열거</target>
        </trans-unit>
        <trans-unit id="bce06414177f72ab70e6387b6af9f8ceef0d6049" translate="yes" xml:space="preserve">
          <source>Search</source>
          <target state="translated">Search</target>
        </trans-unit>
        <trans-unit id="f2535d6e767f49b8124024bcd11da510f6f782bd" translate="yes" xml:space="preserve">
          <source>Search an array of characters.</source>
          <target state="translated">문자 배열을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="081570b66f26a6217e51edfae5b2f5f442c3bbc8" translate="yes" xml:space="preserve">
          <source>Searchers</source>
          <target state="translated">Searchers</target>
        </trans-unit>
        <trans-unit id="be80c5d8537a2b3c995d81bdb8d3ae633186fea1" translate="yes" xml:space="preserve">
          <source>Searchers implementing several string searching algorithms are provided and can be used either directly or with &lt;code&gt;&lt;a href=&quot;../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">여러 문자열 검색 알고리즘을 구현하는 검색자가 제공되며 직접 또는 &lt;code&gt;&lt;a href=&quot;../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33c71193b71000219f2bd6b9f54cb3bf29a41ddc" translate="yes" xml:space="preserve">
          <source>Searches for character &lt;code&gt;ch&lt;/code&gt; within the first &lt;code&gt;count&lt;/code&gt; characters of the sequence pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 가리키는 시퀀스 의 첫 번째 &lt;code&gt;count&lt;/code&gt; 문자 내에서 &lt;code&gt;ch&lt;/code&gt; 문자를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="37caebe595bd3a25fdffa0ec8c5c448832c11501" translate="yes" xml:space="preserve">
          <source>Searches for the last occurrence of the sequence &lt;code&gt;[s_first, s_last)&lt;/code&gt; in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위에서 &lt;code&gt;[s_first, s_last)&lt;/code&gt; 시퀀스의 마지막 항목을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="754ce955d614da4c802b64da2e1c3ddc6bee054d" translate="yes" xml:space="preserve">
          <source>Searches the</source>
          <target state="translated">검색</target>
        </trans-unit>
        <trans-unit id="769049f398e61b7f7ad4e6b14c38a23da9c22170" translate="yes" xml:space="preserve">
          <source>Searches the range &lt;code&gt;[first, last)&lt;/code&gt; for any of the elements in the range &lt;code&gt;[s_first, s_last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[s_first, s_last)&lt;/code&gt; 범위의 모든 요소에 대해 &lt;code&gt;[first, last)&lt;/code&gt; 범위를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="1e308cb25d0ed13526c73f64ffe66b93da65e203" translate="yes" xml:space="preserve">
          <source>Searches the range &lt;code&gt;[first, last)&lt;/code&gt; for the first sequence of count identical elements, each equal to the given value value.</source>
          <target state="translated">주어진 값 값과 동일한 개수의 동일한 요소의 첫 번째 시퀀스에 대한 범위 &lt;code&gt;[first, last)&lt;/code&gt; 를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="7fa3cd6cb9bf46973989d4709c8226edf99fa4ae" translate="yes" xml:space="preserve">
          <source>Searches the range &lt;code&gt;[first, last)&lt;/code&gt; for two consecutive identical elements.</source>
          <target state="translated">두 개의 연속 된 동일한 요소에 대해 &lt;code&gt;[first, last)&lt;/code&gt; 범위를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="7c36d1e16b84bc65d65582ef2f66c0a6af5df9a5" translate="yes" xml:space="preserve">
          <source>Second version</source>
          <target state="translated">두 번째 버전</target>
        </trans-unit>
        <trans-unit id="3b7372ecf5cd839751ecadd7eb6342e697de5920" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../../language/delete&quot;&gt;delete-expression&lt;/a&gt; for exact details on the overload resolution rules between alignment-aware and alignment-unaware overloads of usual (non-placement) deallocation functions.</source>
          <target state="translated">일반적인 (비 배치) 할당 해제 기능의 정렬 인식 및 정렬 비 인식 과부하 사이의 과부하 해결 규칙에 대한 자세한 내용은 &lt;a href=&quot;../../language/delete&quot;&gt;Delete-expression&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae818aabc9d932654ddcaaf489a23a68152adf27" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;integral conversions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;적분 변환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6378dcdb16aa74b2d40b16a1e6ee4135e9695749" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/a&gt; for the list of conditions that set &lt;code&gt;badbit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;badbit&lt;/code&gt; 를 설정 한 조건 목록은 &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;ios_base::iostate&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dee8fd6f97edfa7a7cf0f34968b55a706acc4284" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/a&gt; for the list of conditions that set &lt;code&gt;eofbit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eofbit&lt;/code&gt; 설정 조건 목록은 &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;ios_base::iostate&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9ae9ac7299d29baeec9d43cbba4ba0ce1c9aa6e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/a&gt; for the list of conditions that set &lt;code&gt;failbit&lt;/code&gt; or &lt;code&gt;badbit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;failbit&lt;/code&gt; 또는 &lt;code&gt;badbit&lt;/code&gt; 를 설정하는 조건 목록은 &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;ios_base::iostate&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c25f06c677695c66cf5160af1585d19e44dae901" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/a&gt; for the list of conditions that set the stream status bits.</source>
          <target state="translated">스트림 상태 비트를 설정하는 조건 목록은 &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;ios_base::iostate&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="174c2342f47ac83dd4dd125d8e0118900b8a0e79" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;Standard layout&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;표준 레이아웃을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e50ce5cb884f5a58dd6c6ce681c3eba7330d42fa" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; for the special rules behind forwarding references (&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; used as a function parameter) and &lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;forwarding references&lt;/a&gt; for other detail.</source>
          <target state="translated">참조 &lt;a href=&quot;../language/template_argument_deduction&quot;&gt;템플릿 인수 공제를&lt;/a&gt; 특별 전달 참조 뒤에 규칙 (위해 &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; 함수 매개 변수로 사용) 및 &lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;전달 참조&lt;/a&gt; 기타 세부 사항에 대한.</target>
        </trans-unit>
        <trans-unit id="39bd03185bceffe6a43d25662a58dc151998d110" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../memory/shared_ptr/atomic2&quot;&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&lt;/a&gt; and &lt;a href=&quot;../memory/weak_ptr/atomic2&quot;&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../memory/shared_ptr/atomic2&quot;&gt;std :: atomic &amp;lt;std :: shared_ptr&amp;gt;&lt;/a&gt; 및 &lt;a href=&quot;../memory/weak_ptr/atomic2&quot;&gt;std :: atomic &amp;lt;std :: weak_ptr&amp;gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e167622e5c42d7bf8a95ec5740e244c7093b646f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../types/climits#Limits_of_floating_point_types&quot;&gt;Limits of floating point types&lt;/a&gt; and &lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt; for additional details, limits, and properties of the floating-point types.</source>
          <target state="translated">참조 &lt;a href=&quot;../types/climits#Limits_of_floating_point_types&quot;&gt;점 유형 부동의 한계&lt;/a&gt; 와 &lt;a href=&quot;../types/numeric_limits&quot;&gt;표준 : : numeric_limits를&lt;/a&gt; 추가 세부 사항, 제한 및 부동 소수점 형식의 속성을.</target>
        </trans-unit>
        <trans-unit id="2274fab11ee4834d5966c40c307e91c5df243ce8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;classes&quot;&gt;classes&lt;/a&gt; for general overview of the syntax. If class-key is &lt;code&gt;union&lt;/code&gt;, the declaration introduces a &lt;a href=&quot;union&quot;&gt;union type&lt;/a&gt;.</source>
          <target state="translated">구문에 대한 일반적인 개요는 &lt;a href=&quot;classes&quot;&gt;클래스&lt;/a&gt; 를 참조하십시오 . class-key가 &lt;code&gt;union&lt;/code&gt; 인 경우 선언은 &lt;a href=&quot;union&quot;&gt;union type을&lt;/a&gt; 도입합니다 .</target>
        </trans-unit>
        <trans-unit id="7ba0349c426a2f24e3620c1aa021d44618face46" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;default_comparisons&quot;&gt;기본 비교&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="429a878af958318f5598c06dd5a9dc47b55c4f9e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;derived_class&quot;&gt;derived classes&lt;/a&gt; for the meaning of public, protected, and private inheritance.</source>
          <target state="translated">공개, 보호 및 개인 상속의 의미에 대해서는 &lt;a href=&quot;derived_class&quot;&gt;파생 클래스&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="914ee0d12625d0d50c9171297ac04778b61de7f4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;elaborated_type_specifier&quot;&gt;정교한 형식 지정자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ced721a5d7f98361f7017a972c098ee6051d9a7a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;escape&quot;&gt;escape sequences&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;escape&quot;&gt;이스케이프 시퀀스&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="44c333ad00625ae699f2584f163b982fd72ac7a1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;except_spec&quot;&gt;동적 예외 사양을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="74cdc7b25c3c97c3a8434eb20f61651a5eb87ae3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;fe_round&quot;&gt;floating-point rounding macros&lt;/a&gt; for the effects of rounding.</source>
          <target state="translated">&lt;a href=&quot;fe_round&quot;&gt;반올림&lt;/a&gt; 효과는 부동 소수점 반올림 매크로 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29e4344e032e36ed94ddfee614e0e36909dc87e6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;function#Return_type_deduction&quot;&gt;function#Return_type_deduction&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;function#Return_type_deduction&quot;&gt;function # Return_type_deduction을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8283046607e90210c1c29d8f4f84a8fab2d1ede3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;Mathematical special functions&lt;/a&gt; for the ISO/IEC 29124:2010 version of this library.</source>
          <target state="translated">이 라이브러리의 ISO / IEC 29124 : 2010 버전에 대한 &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;수학 특수 함수&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0aae26af8fe26013b5446f34d12625d4c3f4ca0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;Integral conversions&lt;/a&gt; for implicit conversions from &lt;code&gt;bool&lt;/code&gt; to other types and &lt;a href=&quot;implicit_cast#Boolean_conversions&quot;&gt;boolean conversions&lt;/a&gt; for the implicit conversions from other types to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">참조 &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;적분 변환&lt;/a&gt; 에서 암시 적 변환을위한 &lt;code&gt;bool&lt;/code&gt; 다른 유형과에 &lt;a href=&quot;implicit_cast#Boolean_conversions&quot;&gt;부울 변환&lt;/a&gt; 하는 다른 종류의 암시 적 변환을위한 &lt;code&gt;bool&lt;/code&gt; 로를 .</target>
        </trans-unit>
        <trans-unit id="37d388b1ae038b8ac6156d9085ce7d62388e00ee" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;lambda#Lambda_capture&quot;&gt;below&lt;/a&gt; for the detailed description of captures.</source>
          <target state="translated">캡처에 대한 자세한 설명은 &lt;a href=&quot;lambda#Lambda_capture&quot;&gt;아래&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cad14c22748843bfa2798b2b209a13ead862881" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;member_template#Conversion_function_templates&quot;&gt;member template&lt;/a&gt; for other rules regarding conversion function templates.</source>
          <target state="translated">변환 함수 템플릿에 대한 다른 규칙 은 &lt;a href=&quot;member_template#Conversion_function_templates&quot;&gt;멤버 템플릿&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad0d65393aca93e974d44085f5919bd7839c0d28" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;namespace&quot;&gt;namespace&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;namespace&quot;&gt;네임 스페이스&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="102f8e37106ae040bb5f89e22fa071d096f41648" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;objects#Alignment&quot;&gt;alignment&lt;/a&gt; for the meaning and properties of the value returned by &lt;code&gt;alignof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alignof&lt;/code&gt; 가 반환 한 값의 의미와 속성에 대해서는 &lt;a href=&quot;objects#Alignment&quot;&gt;정렬&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55b4bb18224bfdfff99896bdba23ef4d69d413d1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;operators#Assignment_operator&quot;&gt;assignment operator overloading&lt;/a&gt; for additional detail on the expected behavior of a user-defined copy-assignment operator.</source>
          <target state="translated">사용자 정의 복사 할당 연산자의 예상 동작에 대한 자세한 내용은 &lt;a href=&quot;operators#Assignment_operator&quot;&gt;할당 연산자 오버로드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb67647e0da113c3fbe9fee863f0d9d63fe13a8d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;operators#Assignment_operator&quot;&gt;assignment operator overloading&lt;/a&gt; for additional detail on the expected behavior of a user-defined move-assignment operator.</source>
          <target state="translated">사용자 정의 이동 할당 연산자의 예상 동작에 대한 자세한 내용은 &lt;a href=&quot;operators#Assignment_operator&quot;&gt;할당 연산자 오버로드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5493d4122dd67d4c17caa6d5ef78b487507ea02" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; for the details of the name lookup for qualified identifiers.</source>
          <target state="translated">규정 된 식별자의 이름 조회에 대한 자세한 내용은 &lt;a href=&quot;qualified_lookup&quot;&gt;규정 된 조회&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24c313aec15f752b8eef19d4f89751a772bc838e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;static&quot;&gt;static data members&lt;/a&gt; for additional rules about inline static members.</source>
          <target state="translated">인라인 정적 멤버에 대한 추가 규칙은 &lt;a href=&quot;static&quot;&gt;정적 데이터 멤버&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="605869828b172cc97a29434e43b6498562b03788" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;template_argument_deduction&quot;&gt;템플릿 인수 공제&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="283313eb9b1d55b39e9f5d89e00fc3a1bf6de70e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;throw&quot;&gt; throw exceptions&lt;/a&gt; for more information about throw-expressions</source>
          <target state="translated">throw-expressions에 대한 자세한 내용은 &lt;a href=&quot;throw&quot;&gt;throw 예외&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="69df8ac605b2aefcade71d4a0331b3b48494c6a9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;try_catch&quot;&gt; try-catch block&lt;/a&gt; for more information about</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;try_catch&quot;&gt;try-catch 블록&lt;/a&gt; 을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="17f682c920cda25dc371eb3bc3ea16fcc0afeebf" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;using_declaration&quot;&gt;선언 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7daaa65ada396227e4a622fdcc20e20911f6b1c" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;&lt;a href=&quot;../../atomic/kill_dependency&quot;&gt;std::kill_dependency&lt;/a&gt;&lt;/code&gt; for example usage.</source>
          <target state="translated">사용법 예는 &lt;code&gt;&lt;a href=&quot;../../atomic/kill_dependency&quot;&gt;std::kill_dependency&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="47b8073db41056b2af9125a4b55737d9e0d4b080" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; for the handling of errors that arise during exception handling.</source>
          <target state="translated">예외 처리 중에 발생하는 오류 처리에 대해서는 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf502c77fe0dc9f40d34f9c7f2c4d63957dc4f8b" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; for further details.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="bd9cdf06a8071ae98a7163dd1f7bbfd07f483e5f" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; for the description of the semantics of condition variables.</source>
          <target state="translated">조건 변수의 의미에 대한 설명은 &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="f79bb58417489ef566fe0f186f5e68a673856c4b" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;../types/integer&quot;&gt;Fixed width integer types&lt;/a&gt;.(since C++11).</source>
          <target state="translated">&lt;a href=&quot;../types/integer&quot;&gt;고정 너비 정수 유형&lt;/a&gt; (C ++ 11부터) 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="724eeee50828e55ed4fb99b05ec0d10f041d0b32" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;template_argument_deduction#Deduction_from_a_function_call&quot;&gt;template argument deduction&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;template_argument_deduction#Deduction_from_a_function_call&quot;&gt;템플릿 인수 공제&lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29bf3e42f6bade0c2ad8b91112d660163e3f9bb3" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;&lt;a href=&quot;kill_dependency&quot;&gt;std::kill_dependency&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; for fine-grained dependency chain control.</source>
          <target state="translated">세분화 된 종속성 체인 제어에 대해서는 &lt;code&gt;&lt;a href=&quot;kill_dependency&quot;&gt;std::kill_dependency&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99a9b1a0ad5fb2550b4eaca7c7ed9743c7009041" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;&lt;a href=&quot;numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; 인터페이스 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fe39f07296abb94820a0213f51053afc2b83f28" translate="yes" xml:space="preserve">
          <source>See also the implementations in &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1125-L1187&quot;&gt;libstdc++&lt;/a&gt; and &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2259-L2291&quot;&gt;libc++&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1125-L1187&quot;&gt;libstdc ++&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2259-L2291&quot;&gt;libc ++&lt;/a&gt; 의 구현도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abcd5647b5dbfde0bf3b5841d67951f24a735a10" translate="yes" xml:space="preserve">
          <source>See also the implementations in &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1207&quot;&gt;libstdc++&lt;/a&gt; and &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2298&quot;&gt;libc++&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1207&quot;&gt;libstdc ++&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2298&quot;&gt;libc ++&lt;/a&gt; 의 구현도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ad1a04d56e3d6822bfa65c3769d0ddd0aa829c4" translate="yes" xml:space="preserve">
          <source>See also the implementations in &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1249&quot;&gt;libstdc++&lt;/a&gt; and &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2417&quot;&gt;libc++&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1249&quot;&gt;libstdc ++&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2417&quot;&gt;libc ++&lt;/a&gt; 의 구현도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7972791dec6e10e047e38baff6fab2a8513c7838" translate="yes" xml:space="preserve">
          <source>See also the implementations in &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1461&quot;&gt;libstdc++&lt;/a&gt; and &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2482&quot;&gt;libc++&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1461&quot;&gt;libstdc ++&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2482&quot;&gt;libc ++&lt;/a&gt; 의 구현도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="10ed34d430c362ea64daf3b6f9f28052ab07af01" translate="yes" xml:space="preserve">
          <source>SeedSequence</source>
          <target state="translated">SeedSequence</target>
        </trans-unit>
        <trans-unit id="3f0cf8e2782befc24fe377038ac19de212006a14" translate="yes" xml:space="preserve">
          <source>Seeds the pseudo-random number generator used by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand()&lt;/a&gt;&lt;/code&gt; with the value &lt;code&gt;seed&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand()&lt;/a&gt;&lt;/code&gt; 의해 사용되는 의사 난수 생성기를 &lt;code&gt;seed&lt;/code&gt; 값으로 시드 합니다.</target>
        </trans-unit>
        <trans-unit id="1e1921a75e80a596c9a940068df630bd1b9feed6" translate="yes" xml:space="preserve">
          <source>Selection statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b9ea4555f2e87f0b5e1a8666aa986618f09c19" translate="yes" xml:space="preserve">
          <source>Selection statements choose between one of several flows of control.</source>
          <target state="translated">선택문은 여러 가지 제어 흐름 중 하나를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="776c569a16268c74debac2a7f912b4ace14fe2d5" translate="yes" xml:space="preserve">
          <source>Selects &lt;code&gt;n&lt;/code&gt; elements from the sequence [first; last) such that each possible sample has equal probability of appearance, and writes those selected elements into the output iterator &lt;code&gt;out&lt;/code&gt;. Random numbers are generated using the random number generator &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">시퀀스에서 &lt;code&gt;n&lt;/code&gt; 개의 요소를 선택합니다 . [first; 각 가능한 샘플 외관의 동일한 확률을 가지고, 상기 출력 반복자에 그 선택된 요소에 기록 지난) 등의 &lt;code&gt;out&lt;/code&gt; . 난수 생성기는 난수 생성기 &lt;code&gt;g&lt;/code&gt; 를 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe03c3515833357d89e7094df960e757cae3bc1d" translate="yes" xml:space="preserve">
          <source>Semantics</source>
          <target state="translated">Semantics</target>
        </trans-unit>
        <trans-unit id="fcb3a84856a9093f8cbfaa3811dd4b157eac0989" translate="yes" xml:space="preserve">
          <source>Semiregular</source>
          <target state="translated">Semiregular</target>
        </trans-unit>
        <trans-unit id="5ab18e1afa30ee21a995753ce9370cb63f6c68b4" translate="yes" xml:space="preserve">
          <source>Semiregular wrapper</source>
          <target state="translated">반 정규 포장지</target>
        </trans-unit>
        <trans-unit id="8d982da36907626a11a5ba3e814abbe3a393e179" translate="yes" xml:space="preserve">
          <source>Semiregular wrapper (C++20)</source>
          <target state="translated">반 정규 포장지 (C ++ 20)</target>
        </trans-unit>
        <trans-unit id="058beef7599ef0fca7a043fe7e6842246cc841f4" translate="yes" xml:space="preserve">
          <source>Sends signal sig to the program. The signal handler (specified using the &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; function) is invoked.</source>
          <target state="translated">신호 sig를 프로그램으로 보냅니다. 신호 핸들러 ( &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 지정 )가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1b723f9a0711150c35ac643e01416774bd288ff8" translate="yes" xml:space="preserve">
          <source>Sentinel</source>
          <target state="translated">Sentinel</target>
        </trans-unit>
        <trans-unit id="ade75186a4f45f23ca1cb8f7cad6a1638de0d6e0" translate="yes" xml:space="preserve">
          <source>Separates the thread of execution from the thread object, allowing execution to continue independently. Any allocated resources will be freed once the thread exits.</source>
          <target state="translated">실행 스레드를 스레드 개체와 분리하여 실행을 독립적으로 계속할 수 있습니다. 스레드가 종료되면 할당 된 모든 자원이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="627861d895f61db64e072c3541f0299ce0be392b" translate="yes" xml:space="preserve">
          <source>Sequence containers</source>
          <target state="translated">시퀀스 컨테이너</target>
        </trans-unit>
        <trans-unit id="5f156be6c395dbb2a3a82e5a5a15edfff2ce72c6" translate="yes" xml:space="preserve">
          <source>Sequence containers implement data structures which can be accessed sequentially.</source>
          <target state="translated">시퀀스 컨테이너는 순차적으로 액세스 할 수있는 데이터 구조를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="586248de4df6f2fb686141acbe275f15919cdcd3" translate="yes" xml:space="preserve">
          <source>Sequence containers in the standard library</source>
          <target state="translated">표준 라이브러리의 시퀀스 컨테이너</target>
        </trans-unit>
        <trans-unit id="1dd2a98d87981aeed996e59fae4a850b7b8cce75" translate="yes" xml:space="preserve">
          <source>SequenceContainer</source>
          <target state="translated">SequenceContainer</target>
        </trans-unit>
        <trans-unit id="cb196565d6396245ad6a50208b3e628e5f581b0b" translate="yes" xml:space="preserve">
          <source>Sequenced-before</source>
          <target state="translated">Sequenced-before</target>
        </trans-unit>
        <trans-unit id="64cf851b8491eff8f5a5c736de201846803398a1" translate="yes" xml:space="preserve">
          <source>Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3c02107bfafa471d5b3be0bbb231a73bba241c" translate="yes" xml:space="preserve">
          <source>Sequentially-consistent ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9dd132139144d6bb8d37bb56baaf697a3046e5a" translate="yes" xml:space="preserve">
          <source>Set group ID to file's user group ID on execution</source>
          <target state="translated">실행시 그룹 ID를 파일의 사용자 그룹 ID로 설정</target>
        </trans-unit>
        <trans-unit id="e1637e859e4377992588527df8ff19bd1c80c203" translate="yes" xml:space="preserve">
          <source>Set operations (on sorted ranges)</source>
          <target state="translated">작업 설정 (정렬 된 범위)</target>
        </trans-unit>
        <trans-unit id="89aff6dc709371a1e75349cff7f89ce318bf48f3" translate="yes" xml:space="preserve">
          <source>Set user ID to file owner user ID on execution</source>
          <target state="translated">실행시 사용자 ID를 파일 소유자 사용자 ID로 설정</target>
        </trans-unit>
        <trans-unit id="5a7c71125a1b285d19cc080c75758da9c81b3646" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;e == E()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;e == E()&lt;/code&gt; 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="5472e26bd7acfe2a9e13b0c0a52960a1f0c432c5" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;e == E(q)&lt;/code&gt;.</source>
          <target state="translated">설정 &lt;code&gt;e == E(q)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0afe1632304164b54c66cff4a98eb13baed5d65" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;e == E(s)&lt;/code&gt;.</source>
          <target state="translated">설정 &lt;code&gt;e == E(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23d22a46a8394d6e4f18b68e1628cb04aa3fe300" translate="yes" xml:space="preserve">
          <source>Sets all bits to &lt;code&gt;true&lt;/code&gt; or to specified value.</source>
          <target state="translated">모든 비트를 &lt;code&gt;true&lt;/code&gt; 또는 지정된 값으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="43384d288b4c5906f92816e5a1a730f85b8f1fb4" translate="yes" xml:space="preserve">
          <source>Sets bits to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">비트를 &lt;code&gt;false&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="df702a27723655552b5082b9500508a154b9a7a9" translate="yes" xml:space="preserve">
          <source>Sets input position indicator of the current associated &lt;code&gt;streambuf&lt;/code&gt; object. In case of failure, calls &lt;code&gt;setstate(&lt;a href=&quot;../ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">현재 연결된 &lt;code&gt;streambuf&lt;/code&gt; 객체 의 입력 위치 표시기를 설정 합니다. 실패한 경우 &lt;code&gt;setstate(&lt;a href=&quot;../ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="990595a0ab4c45f3eb5d0fcf59aa896be2bd913a" translate="yes" xml:space="preserve">
          <source>Sets the associated locale of the stream to the given one. Before returning, each function, registered by &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; is called with &lt;code&gt;imbue_event&lt;/code&gt; as a parameter.</source>
          <target state="translated">스트림의 관련 로케일을 지정된 로케일로 설정합니다. 반환하기 전에 &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; 의해 등록 된 각 함수 는 &lt;code&gt;imbue_event&lt;/code&gt; 와 함께 매개 변수로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="995344713122a7e40f3d1c41777d1c25df014b44" translate="yes" xml:space="preserve">
          <source>Sets the associated stream buffer to &lt;code&gt;sb&lt;/code&gt; and initializes the internal state.</source>
          <target state="translated">연관된 스트림 버퍼를 &lt;code&gt;sb&lt;/code&gt; 로 설정하고 내부 상태를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="b7a3958ed34eda423f1812162bb7ead7f8f7386b" translate="yes" xml:space="preserve">
          <source>Sets the associated stream buffer to &lt;code&gt;sb&lt;/code&gt; without clearing the error state.</source>
          <target state="translated">오류 상태를 지우지 않고 연관된 스트림 버퍼를 &lt;code&gt;sb&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="dc84cbf09f54497d82bb5b62d2a2d517c0f640e5" translate="yes" xml:space="preserve">
          <source>Sets the file position indicator and the multibyte parsing state (if any) for the C file stream &lt;code&gt;stream&lt;/code&gt; according to the value pointed to by &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 가 가리키는 값에 따라 C 파일 스트림 &lt;code&gt;stream&lt;/code&gt; 에 대한 파일 위치 표시기 및 멀티 바이트 구문 분석 상태 (있는 경우)를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="e8981596fc41bcb7790694f68d1d762fd8c679d5" translate="yes" xml:space="preserve">
          <source>Sets the file position indicator for the file stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">파일 스트림 &lt;code&gt;stream&lt;/code&gt; 대한 파일 위치 표시기를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="dd531265ea608469a544e2f55635683ca3d4497c" translate="yes" xml:space="preserve">
          <source>Sets the formatting flags to specified settings.</source>
          <target state="translated">포맷 플래그를 지정된 설정으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="79eb6b783a4567ddc5405a0414a0c6ec9ca40fb5" translate="yes" xml:space="preserve">
          <source>Sets the handler for signal &lt;code&gt;sig&lt;/code&gt;. The signal handler can be set so that default handling will occur, signal is ignored, or a user-defined function is called.</source>
          <target state="translated">signal &lt;code&gt;sig&lt;/code&gt; 핸들러를 설정합니다 . 기본 처리가 발생하거나 신호가 무시되거나 사용자 정의 함수가 호출되도록 신호 처리기를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09a2100140edfd67ac8ff2932600ec68a127f06e" translate="yes" xml:space="preserve">
          <source>Sets the initial value of an object to zero.</source>
          <target state="translated">객체의 초기 값을 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e1eb3620fe2b05e18c0f858094a88945ee7f3c72" translate="yes" xml:space="preserve">
          <source>Sets the initial values of the &lt;a href=&quot;storage_duration&quot;&gt;static&lt;/a&gt; variables to a compile-time constant.</source>
          <target state="translated">&lt;a href=&quot;storage_duration&quot;&gt;정적&lt;/a&gt; 변수 의 초기 값을 컴파일 타임 상수로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b1ca0346b3e08f30a6472d9f167a325e8d1e4753" translate="yes" xml:space="preserve">
          <source>Sets the internal buffer to use for I/O operations performed on the C stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">C 스트림 &lt;code&gt;stream&lt;/code&gt; 에서 수행되는 I / O 작업에 사용할 내부 버퍼를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="cd02608b401728e9aec88e6cbdb388fde515882f" translate="yes" xml:space="preserve">
          <source>Sets the number of buckets to &lt;code&gt;count&lt;/code&gt; and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (&lt;code&gt;count &amp;lt; size() / max_load_factor()&lt;/code&gt;), then the new number of buckets is at least &lt;code&gt;size() / max_load_factor()&lt;/code&gt;.</source>
          <target state="translated">컨테이너 를 &lt;code&gt;count&lt;/code&gt; 하고 다시 해시 할 버킷 수를 설정합니다 . 즉, 총 버킷 수가 변경되었다는 점을 고려하여 요소를 적절한 버킷에 넣습니다. 새 버킷 수로 인해로드 팩터가 최대로드 팩터 ( &lt;code&gt;count &amp;lt; size() / max_load_factor()&lt;/code&gt; ) 보다 큰 경우 새 버킷 수는 최소한 &lt;code&gt;size() / max_load_factor()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44ffba405c63cb8f4ea0d962441828c7289a2a74" translate="yes" xml:space="preserve">
          <source>Sets the number of buckets to the number needed to accomodate at least &lt;code&gt;count&lt;/code&gt; elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls &lt;code&gt;rehash(&lt;a href=&quot;../../numeric/math/ceil&quot;&gt;std::ceil&lt;/a&gt;(count / max_load_factor()))&lt;/code&gt;.</source>
          <target state="translated">버킷 수 를 최대로드 팩터를 초과하지 않고 요소 를 적어도 &lt;code&gt;count&lt;/code&gt; 데 필요한 수로 설정하고 컨테이너를 다시 해시합니다. 즉, 총 버킷 수가 변경되었다는 점을 고려하여 요소를 적절한 버킷에 넣습니다. 효과적으로 &lt;code&gt;rehash(&lt;a href=&quot;../../numeric/math/ceil&quot;&gt;std::ceil&lt;/a&gt;(count / max_load_factor()))&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="872d658af6ea90478845715a23df835aadd67a4f" translate="yes" xml:space="preserve">
          <source>Sets the numeric base of the stream. When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setbase(base)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setbase(base)&lt;/code&gt;, changes the &lt;code&gt;basefield&lt;/code&gt; flag of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt;, depending on the value of &lt;code&gt;base&lt;/code&gt;:</source>
          <target state="translated">스트림의 숫자 기준을 설정합니다. 표현식에서 사용될 때 &lt;code&gt;out &amp;lt;&amp;lt; setbase(base)&lt;/code&gt; 또는 &lt;code&gt;in &amp;gt;&amp;gt; setbase(base)&lt;/code&gt; , 변경 &lt;code&gt;basefield&lt;/code&gt; 스트림 플래그 &lt;code&gt;out&lt;/code&gt; 이나 &lt;code&gt;in&lt;/code&gt; 의 값에 따라, &lt;code&gt;base&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4458ba443567a1698e8223d365c93646c1809952" translate="yes" xml:space="preserve">
          <source>Sets the output position indicator of the current associated &lt;code&gt;streambuf&lt;/code&gt; object.</source>
          <target state="translated">현재 연결된 &lt;code&gt;streambuf&lt;/code&gt; 객체 의 출력 위치 표시기를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="f848851d17ce421067d84a2f77e7deaea69e3c90" translate="yes" xml:space="preserve">
          <source>Sets the position indicator of the input and/or output sequence relative to some other position.</source>
          <target state="translated">다른 위치를 기준으로 입력 및 / 또는 출력 시퀀스의 위치 표시기를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3a8ee43d265a420d1f758efe248a25c59cb316ca" translate="yes" xml:space="preserve">
          <source>Sets the position indicator of the input and/or output sequence to an absolute position.</source>
          <target state="translated">입력 및 / 또는 출력 시퀀스의 위치 표시기를 절대 위치로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="13053efd8b77ed7f7e086552a051ef07d0612487" translate="yes" xml:space="preserve">
          <source>Sets the stream error flags &lt;code&gt;state&lt;/code&gt; in addition to currently set flags. Essentially calls &lt;code&gt;clear(rdstate() | state)&lt;/code&gt;. May throw an exception.</source>
          <target state="translated">현재 설정된 플래그와 함께 스트림 오류 플래그 &lt;code&gt;state&lt;/code&gt; 를 설정합니다. 본질적으로 &lt;code&gt;clear(rdstate() | state)&lt;/code&gt; 호출합니다 . 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a6e53a3b1a7551e0adedf2f964d9589e2d7700d" translate="yes" xml:space="preserve">
          <source>Sets the stream error state flags by assigning them the value of &lt;code&gt;state&lt;/code&gt;. By default, assigns &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; which has the effect of clearing all error state flags.</source>
          <target state="translated">스트림 오류 상태 플래그를 &lt;code&gt;state&lt;/code&gt; 값을 지정하여 설정합니다 . 기본적으로 모든 오류 상태 플래그를 지우는 효과가있는 &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="31107c4e3971ba07d2b23b105a5b48d627e90338" translate="yes" xml:space="preserve">
          <source>Sets the values of the pointers defining the get area. Specifically, after the call &lt;code&gt;eback() == gbeg&lt;/code&gt;, &lt;code&gt;gptr() == gcurr&lt;/code&gt;, &lt;code&gt;egptr() == gend&lt;/code&gt;.</source>
          <target state="translated">get 영역을 정의하는 포인터의 값을 설정합니다. 특히, &lt;code&gt;eback() == gbeg&lt;/code&gt; , &lt;code&gt;gptr() == gcurr&lt;/code&gt; , &lt;code&gt;egptr() == gend&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c80d20a12ae08a03e22ce68dd881ce0d84f3b63" translate="yes" xml:space="preserve">
          <source>Sets the values of the pointers defining the put area. Specifically, after the call &lt;code&gt;pbase() == pbeg&lt;/code&gt;, &lt;code&gt;pptr() == pbeg&lt;/code&gt;, &lt;code&gt;epptr() == pend&lt;/code&gt;.</source>
          <target state="translated">풋 영역을 정의하는 포인터의 값을 설정합니다. 특히 &lt;code&gt;pbase() == pbeg&lt;/code&gt; , &lt;code&gt;pptr() == pbeg&lt;/code&gt; , &lt;code&gt;epptr() == pend&lt;/code&gt; 호출 후 .</target>
        </trans-unit>
        <trans-unit id="5199b18d2d2b0a0af45438d34940fd5e1b006963" translate="yes" xml:space="preserve">
          <source>Sets whether the standard C++ streams are synchronized to the standard C streams after each input/output operation.</source>
          <target state="translated">각 입력 / 출력 작업 후 표준 C ++ 스트림을 표준 C 스트림에 동기화할지 여부를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="64e31adef7a3933fd26bffedd7b084d8fec7dcc6" translate="yes" xml:space="preserve">
          <source>Setting the result</source>
          <target state="translated">결과 설정</target>
        </trans-unit>
        <trans-unit id="236b5bbbb7e1393bb181a9a22a43242bd679e759" translate="yes" xml:space="preserve">
          <source>Several C++ compilers transform suitable memory-copying loops to &lt;code&gt;std::memcpy&lt;/code&gt; calls.</source>
          <target state="translated">몇몇 C ++ 컴파일러는 적절한 메모리 복사 루프를 &lt;code&gt;std::memcpy&lt;/code&gt; 호출로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="20e064cb02a2e6366e9769ca91b6159a518d574a" translate="yes" xml:space="preserve">
          <source>Several alias templates, that perform arithmetic operations on &lt;code&gt;ratio&lt;/code&gt; objects at compile-time are provided.</source>
          <target state="translated">컴파일 타임 에 &lt;code&gt;ratio&lt;/code&gt; 객체에 대한 산술 연산을 수행하는 여러 별칭 템플릿 이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8795d93d5e0421a57d6b71c2c710d10c8092b33e" translate="yes" xml:space="preserve">
          <source>Several class templates, that perform comparison operations on &lt;code&gt;ratio&lt;/code&gt; objects at compile-time are provided.</source>
          <target state="translated">컴파일 타임 에 &lt;code&gt;ratio&lt;/code&gt; 객체에 대한 비교 작업을 수행하는 여러 클래스 템플릿 이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c26bd0ea0f59b8ae2c73c9e1a142bd1fcfdbf81d" translate="yes" xml:space="preserve">
          <source>Several cleanup steps are performed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afe923e6efa1a1608806b55078e16f7523db71b" translate="yes" xml:space="preserve">
          <source>Several convenience classes are predefined in the header &lt;code&gt;&amp;lt;stdexcept&amp;gt;&lt;/code&gt; to report particular error conditions. These classes can be divided into two categories:</source>
          <target state="translated">특정 오류 조건을보고하기 위해 헤더 &lt;code&gt;&amp;lt;stdexcept&amp;gt;&lt;/code&gt; 에 여러 편의 클래스가 사전 정의되어 있습니다. 이 클래스는 두 가지 범주로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4648776dcbe754ec199fc020a5d382f56667916" translate="yes" xml:space="preserve">
          <source>Several convenience typedefs that correspond to the SI ratios are provided by the standard library:</source>
          <target state="translated">SI 비율에 해당하는 몇 가지 편리한 typedef가 표준 라이브러리에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="096f451fac0362d4ca2620596aca61e92e355777" translate="yes" xml:space="preserve">
          <source>Several functions and macro constants for signal management are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0116e99087157300ae52a7a94e87ce089818304c" translate="yes" xml:space="preserve">
          <source>Several specializations for common character sequence types are defined:</source>
          <target state="translated">공통 문자 순서 유형에 대한 몇 가지 특수화가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6d52405699141b6d980e9aac92099ec2171d14c" translate="yes" xml:space="preserve">
          <source>Several specializations for common character sequence types are provided:</source>
          <target state="translated">공통 문자 순서 유형에 대한 몇 가지 특수화가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5e4842d83deb970b14592b06aac5a6de2b59130f" translate="yes" xml:space="preserve">
          <source>Several specializations for common character types are provided:</source>
          <target state="translated">일반적인 문자 유형에 대한 몇 가지 전문화가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b1a5848f4dd2490f2d5769aac542fd551b4e177f" translate="yes" xml:space="preserve">
          <source>Several specializations of &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; are provided for commonly-used types:</source>
          <target state="translated">일반적으로 사용되는 유형에 대해 &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 의 여러 전문화 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6ebda6bee6f8e82c2d1bf625330591c499530bd5" translate="yes" xml:space="preserve">
          <source>Several specializations of &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; are provided for commonly-used types:</source>
          <target state="translated">일반적으로 사용되는 유형에 대해 &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 의 여러 전문화 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ae4d382f3f173206dd82ede2629eb16f42a22b" translate="yes" xml:space="preserve">
          <source>Several specific popular algorithms are predefined.</source>
          <target state="translated">몇 가지 특정 인기 알고리즘이 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="93f03b20c634996625d4716bcc756c52b32b3d54" translate="yes" xml:space="preserve">
          <source>Several standard library functions indicate errors by writing positive integers to &lt;code&gt;errno&lt;/code&gt;. Typically, the value of &lt;code&gt;errno&lt;/code&gt; is set to one of the error codes, listed in &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; as macro constants that begin with the letter &lt;code&gt;E&lt;/code&gt;, followed by uppercase letters or digits.</source>
          <target state="translated">여러 표준 라이브러리 함수는 양의 정수를 &lt;code&gt;errno&lt;/code&gt; 에 기록하여 오류를 나타냅니다 . 일반적으로 &lt;code&gt;errno&lt;/code&gt; 값은 오류 코드 중 하나로 설정되며 &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; 에 문자 &lt;code&gt;E&lt;/code&gt; 로 시작하는 매크로 상수와 대문자 또는 숫자가옵니다.</target>
        </trans-unit>
        <trans-unit id="17bd9dc914c33e15ed5ac3d96acb6e3cd62e8b38" translate="yes" xml:space="preserve">
          <source>Several typedefs for common character types are provided:</source>
          <target state="translated">일반적인 문자 유형에 대한 몇 가지 typedef가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="49157ea525f663890f621bd2ab2c9be20931cd0e" translate="yes" xml:space="preserve">
          <source>Several utilities are provided to create and access raw storage.</source>
          <target state="translated">원시 스토리지를 작성하고 액세스하기위한 여러 유틸리티가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f184e7fb63088309cbd0a9fe3300a64508bc0131" translate="yes" xml:space="preserve">
          <source>Several utilities that provided early functional support are deprecated in C++11 and removed in C++17 (old negators are deprecated in C++17 and removed in C++20):</source>
          <target state="translated">초기 기능 지원을 제공하는 여러 유틸리티는 C ++ 11에서 더 이상 사용되지 않으며 C ++ 17에서 제거됩니다 (이전 부정자는 C ++ 17에서 더 이상 사용되지 않으며 C ++ 20에서 제거됨).</target>
        </trans-unit>
        <trans-unit id="4b6768882a645687cc1622eb5df417b554b27c00" translate="yes" xml:space="preserve">
          <source>Several ways to generate a NaN (the output string is compiler-specific).</source>
          <target state="translated">NaN을 생성하는 몇 가지 방법 (출력 문자열은 컴파일러마다 다릅니다).</target>
        </trans-unit>
        <trans-unit id="a68c6d89cb2cb95ce1d60e96889a9fa5dc8212d4" translate="yes" xml:space="preserve">
          <source>Shared locking</source>
          <target state="translated">공유 잠금</target>
        </trans-unit>
        <trans-unit id="73451d10ad1723ad84471a2028b592eaced1e7fb" translate="yes" xml:space="preserve">
          <source>Shared mutexes are usually used in situations when multiple readers can access the same resource at the same time without causing data races, but only one writer can do so.</source>
          <target state="translated">공유 뮤텍스는 일반적으로 여러 명의 리더가 데이터 경쟁을 일으키지 않고 동시에 동일한 리소스에 액세스 할 수 있지만 한 명의 작성자 만 그렇게 할 수있는 상황에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5eb61d2dff132f2129980e537c9cfdac411b9d16" translate="yes" xml:space="preserve">
          <source>Shared mutexes do not support direct transition from shared to unique ownership mode: the shared lock has to be relinquished with &lt;code&gt;&lt;a href=&quot;unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; before exclusive ownership may be obtained with &lt;code&gt;lock()&lt;/code&gt;. &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/thread/synchronization.html#thread.synchronization.mutex_types.upgrade_mutex&quot;&gt;boost::upgrade_mutex&lt;/a&gt; may be used for this purpose.</source>
          <target state="translated">독특한 소유권 모드로 공유에서 공유 뮤텍스 직접 전환을 지원하지 않습니다 공유 잠금으로 포기해야 &lt;code&gt;&lt;a href=&quot;unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; 독점 소유권을 얻을 수 있습니다 전에 &lt;code&gt;lock()&lt;/code&gt; . &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/thread/synchronization.html#thread.synchronization.mutex_types.upgrade_mutex&quot;&gt;boost :: upgrade_mutex&lt;/a&gt; 가이 목적으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37a0431da83771aa22d91f0f6aadf1383e976f46" translate="yes" xml:space="preserve">
          <source>SharedMutex</source>
          <target state="translated">SharedMutex</target>
        </trans-unit>
        <trans-unit id="57a75cc42950df8e7be8033d9c108015544f09cd" translate="yes" xml:space="preserve">
          <source>SharedTimedMutex</source>
          <target state="translated">SharedTimedMutex</target>
        </trans-unit>
        <trans-unit id="f02680b3393117ec07357eb9f1a55eb3ffb43839" translate="yes" xml:space="preserve">
          <source>Shifts the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; positions.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소를 &lt;code&gt;n&lt;/code&gt; 위치 만큼 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="0aa2fd65f221fb441668eabd3b7d043130d5f61e" translate="yes" xml:space="preserve">
          <source>Shows the given error message and renders the program ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115bd61002d38ae0f96bbafaa3faad3d6f1cd957" translate="yes" xml:space="preserve">
          <source>Sign modifiers</source>
          <target state="translated">부호 수정 자</target>
        </trans-unit>
        <trans-unit id="577457386419e49cc011db96f147d3e3e75e3f09" translate="yes" xml:space="preserve">
          <source>Signal handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84a6ab629fde6a64e054e143bd33f5477fde80c" translate="yes" xml:space="preserve">
          <source>Signal handlers are expected to have &lt;a href=&quot;../../language/language_linkage&quot;&gt;C linkage&lt;/a&gt; and, in general, only use the features from the common subset of C and C++. It is implementation-defined if a function with C++ linkage can be used as a signal handler.</source>
          <target state="translated">신호 처리기는 &lt;a href=&quot;../../language/language_linkage&quot;&gt;C 연결&lt;/a&gt; 이 있어야 하며 일반적으로 C 및 C ++의 공통 서브 세트의 기능 만 사용합니다. C ++ 연결을 가진 함수를 신호 처리기로 사용할 수 있으면 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="2d946cd91c48d2465b1861bb4f63d569ff6618d1" translate="yes" xml:space="preserve">
          <source>Signal types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="f4ba37e52b5e712f327df4086478be0bb37e10af" translate="yes" xml:space="preserve">
          <source>Signals an erroneous condition and executes an error handler.</source>
          <target state="translated">잘못된 조건을 알리고 오류 처리기를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="99645a25e106b37349c4a9e5cf923d508621ff34" translate="yes" xml:space="preserve">
          <source>Signed integer arithmetic is defined to use two's complement; there are no undefined results.</source>
          <target state="translated">부호있는 정수 산술은 2의 보수를 사용하도록 정의됩니다. 정의되지 않은 결과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5fc62c21332a22fd75bd285de995cb4fccf6af62" translate="yes" xml:space="preserve">
          <source>Signed integer type (usually &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">부호있는 정수 유형 (일반적으로 &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="83cbfd47b41a4ebb43e27ff9728af42d399bbda3" translate="yes" xml:space="preserve">
          <source>Signed integers : maximum value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46aa2d10272ed1c7e156088e86d214a184422894" translate="yes" xml:space="preserve">
          <source>Signed integers : minimum value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7add2e2fdaaac8a1396e22391085b13ed07cb9bd" translate="yes" xml:space="preserve">
          <source>Signed overflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950ab1101b17ae5a4d17079adf2c1a753a563569" translate="yes" xml:space="preserve">
          <source>SignedIntegral</source>
          <target state="translated">SignedIntegral</target>
        </trans-unit>
        <trans-unit id="57623bc18a34da85f689f9b07a9ba0fe9841f116" translate="yes" xml:space="preserve">
          <source>Similar to other cast expressions, the result is:</source>
          <target state="translated">다른 캐스트 표현식과 유사하게 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cac5ae9e99757e61c6a90cda939d609dbc62d711" translate="yes" xml:space="preserve">
          <source>Similar to other nested scopes, the name of a template parameter hides the same name from the outer scope for the duration of its own:</source>
          <target state="translated">다른 중첩 범위와 마찬가지로 템플릿 매개 변수의 이름은 자체 지속 시간 동안 외부 범위에서 동일한 이름을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="ab34722f320413e959a59dbf8a947c6022642672" translate="yes" xml:space="preserve">
          <source>Similar to protected inheritance, private inheritance may also be used for controlled polymorphism: within the members of the derived (but not within further-derived classes), derived IS-A base.</source>
          <target state="translated">보호 된 상속과 마찬가지로 개인 상속도 제어 된 다형성에 사용될 수 있습니다. 파생 된 멤버 내 (추가 파생 클래스 내), 파생 된 IS-A 기반.</target>
        </trans-unit>
        <trans-unit id="65db8c5edde8bf68dee1cacb22bbacf452f01291" translate="yes" xml:space="preserve">
          <source>Similar to the use of &lt;code&gt;swap&lt;/code&gt; (described in &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;), typical use of the &lt;code&gt;begin&lt;/code&gt; function in generic context is an equivalent of &lt;code&gt;using std::begin; begin(arg);&lt;/code&gt;, which allows both the &lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt;-selected overloads for user-defined types and the standard library function templates to appear in the same overload set.</source>
          <target state="translated">&lt;code&gt;swap&lt;/code&gt; 사용 ( &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable에&lt;/a&gt; 설명 됨 )과 유사하게 일반 컨텍스트에서 &lt;code&gt;begin&lt;/code&gt; 함수를 &lt;code&gt;using std::begin; begin(arg);&lt;/code&gt; 하는 것은 std :: begin; begin (arg); 이를 통해 사용자 정의 유형에 대한 &lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt; 선택 과부하와 표준 라이브러리 함수 템플릿이 동일한 과부하 세트에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="960d524c56dc7eea207997f2fd93dc3344684d27" translate="yes" xml:space="preserve">
          <source>Similar to the use of &lt;code&gt;swap&lt;/code&gt; (described in &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;), typical use of the &lt;code&gt;end&lt;/code&gt; function in generic context is an equivalent of &lt;code&gt;using std::end; end(arg);&lt;/code&gt;, which lets both the &lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt;-selected overloads for user-defined types and the standard library function templates to appear in the same overload set.</source>
          <target state="translated">&lt;code&gt;swap&lt;/code&gt; 사용 ( &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable에&lt;/a&gt; 설명 됨 )과 유사하게 일반 컨텍스트에서 &lt;code&gt;end&lt;/code&gt; 함수를 &lt;code&gt;using std::end; end(arg);&lt;/code&gt; 하는 것은 std :: end 를 사용 하는 것과 같습니다 . 끝 (arg); , 둘 다 할 수있는 &lt;a href=&quot;../language/adl&quot;&gt;ADL이&lt;/a&gt; 같은 과부하 세트에 표시 할 사용자 정의 유형 및 표준 라이브러리 함수 템플릿 오버로드 - 선정.</target>
        </trans-unit>
        <trans-unit id="e9a4d7ed9741e60fb0d8c1ef96f19d3ca3529036" translate="yes" xml:space="preserve">
          <source>Similarly, if an object is created in the storage of a class member or array element, the created object is only a subobject (member or element) of the original object's containing object if:</source>
          <target state="translated">마찬가지로, 클래스 멤버 또는 배열 요소의 저장소에 객체가 생성 된 경우 다음과 같은 경우 생성 된 객체는 원래 객체가 포함 된 객체의 하위 객체 (멤버 또는 요소)입니다.</target>
        </trans-unit>
        <trans-unit id="7479f5fc17cb0f2873e10124edd6bb55ddb644e2" translate="yes" xml:space="preserve">
          <source>Similarly, in a template definition, a dependent name that is not a member of the</source>
          <target state="translated">마찬가지로 템플릿 정의에서 멤버가 아닌 종속 이름</target>
        </trans-unit>
        <trans-unit id="0078135187246fe8bb297259663e248d2026c8e8" translate="yes" xml:space="preserve">
          <source>Similarly, in the case of an ambiguity between a expression statement with a function-style cast expression (3) as its leftmost subexpression and a declaration statement, the ambiguity is resolved by treating it as a declaration. This disambiguation is purely syntactic: it doesn't consider the meaning of names occurring in the statement other than whether they are type names.</source>
          <target state="translated">마찬가지로 함수 스타일 캐스트 표현식 (3)이 가장 왼쪽에있는 하위 표현식으로 선언문과 선언문 사이에 모호성이있는 경우, 모호성은 선언문으로 취급하여 해결됩니다. 이 모호한 표현은 순전히 구문입니다. 문장에서 유형 이름인지 아닌 다른 이름의 의미를 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="482ca159f5a9e05f0355ea23bd2b1dca91576d34" translate="yes" xml:space="preserve">
          <source>Similarly, the decimal value 0.3, which is between 0x1.3333333333333*2-2</source>
          <target state="translated">마찬가지로 10 진수 값 0.3은 0x1.3333333333333 * 2-2입니다.</target>
        </trans-unit>
        <trans-unit id="c89741be4b5567d1abddb43c7960bf1492274817" translate="yes" xml:space="preserve">
          <source>Similarly, the object on which a member function is being called is prepended to the argument list as the</source>
          <target state="translated">마찬가지로 멤버 함수가 호출되는 객체는 인수 목록 앞에</target>
        </trans-unit>
        <trans-unit id="44c42f7a157d61d5df84ae12ff944cc8a7f796d4" translate="yes" xml:space="preserve">
          <source>Similarly, they should not be directly used with standard algorithms when the iterator's value type is &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;signed char&lt;/code&gt;. Instead, convert the value to &lt;code&gt;unsigned char&lt;/code&gt; first:</source>
          <target state="translated">마찬가지로 반복자의 값 유형이 &lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;signed char&lt;/code&gt; 일 때 표준 알고리즘과 직접 사용해서는 안됩니다 . 대신 값을 &lt;code&gt;unsigned char&lt;/code&gt; 먼저 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="555f4661a1c9474d8436af0119724e3bb946b92e" translate="yes" xml:space="preserve">
          <source>Simple declaration</source>
          <target state="translated">간단한 선언</target>
        </trans-unit>
        <trans-unit id="e22e3bdd3d9fe2365a2a7c845db318164b219429" translate="yes" xml:space="preserve">
          <source>Simple requirements</source>
          <target state="translated">간단한 요구 사항</target>
        </trans-unit>
        <trans-unit id="a61f6c3644c94b95e9501c6216722561ceaeda20" translate="yes" xml:space="preserve">
          <source>Simply happens-before</source>
          <target state="translated">단순히 이전에 일어난 일</target>
        </trans-unit>
        <trans-unit id="2bfece18772a73e9e86bc04ddb99403446d3714b" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; and unhinted &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; always insert at the upper bound, the order of equivalent elements in the equal range is the order of insertion unless hinted &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace_hint&quot;&gt;emplace_hint&lt;/a&gt; was used to insert an element at a different position.</source>
          <target state="translated">이후 &lt;a href=&quot;emplace&quot;&gt;설치하다&lt;/a&gt; 및 unhinted &lt;a href=&quot;insert&quot;&gt;삽입&lt;/a&gt; 항상 상한에 삽입 암시하지 않는 한 동일 내지 상당하는 구성 요소들의 순서는 삽입 순서는 &lt;a href=&quot;insert&quot;&gt;삽입&lt;/a&gt; 또는 &lt;a href=&quot;emplace_hint&quot;&gt;emplace_hint가&lt;/a&gt; 다른 위치에서 요소를 삽입 하였다.</target>
        </trans-unit>
        <trans-unit id="c085f0eb950f92da79964d5ad79765742cef364f" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;U&lt;/code&gt; is not deduced, it must be provided as a template argument when calling this function.</source>
          <target state="translated">이후 &lt;code&gt;U&lt;/code&gt; 가 도출되지 않은이 함수를 호출 할 때, 그것은 템플릿 인수로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4fd9ce185a2267e216b09c9fc53119a294a6f13" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;std::size_t&lt;/code&gt; is an unsigned type, an equivalent definition is:</source>
          <target state="translated">이후 &lt;code&gt;std::size_t&lt;/code&gt; 부호없는 형식이며, 동등한 정의는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="843699963892a9d8456a647280dafa700ecdc937" translate="yes" xml:space="preserve">
          <source>Since C++11, &lt;code&gt;auto&lt;/code&gt; is no longer a storage class specifier; it is used to indicate type deduction.</source>
          <target state="translated">C ++ 11부터 &lt;code&gt;auto&lt;/code&gt; 는 더 이상 스토리지 클래스 지정자가 아닙니다. 유형 공제를 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="285604ae9a85be58f4823b4cb9df0815028c2dfd" translate="yes" xml:space="preserve">
          <source>Since C++11, value-initializing a class without a user-provided constructor, which has a member of a class type with a user-provided constructor zeroes out the member before calling its constructor:</source>
          <target state="translated">C ++ 11부터, 사용자 제공 생성자가있는 클래스 유형의 멤버가있는 사용자 제공 생성자가없는 클래스의 값을 초기화하면 생성자를 호출하기 전에 멤버를 0으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aabd76632c3d8473aa4688d0b37f3aced9e7b198" translate="yes" xml:space="preserve">
          <source>Since in a call context considers only parameters for which there are explicit call arguments, those function parameter packs, ellipsis parameters, and parameters with default arguments, for which there is no explicit call argument, are ignored:</source>
          <target state="translated">호출 컨텍스트에서 명시적인 호출 인수가있는 매개 변수 만 고려하므로, 명시적인 호출 인수가없는 함수 매개 변수 팩, 줄임표 매개 변수 및 기본 인수가있는 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bce6909434e4eba25b5845a8222d3e359b346452" translate="yes" xml:space="preserve">
          <source>Since its representation may by optimized, &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; does not necessarily meet all &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; or &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; requirements. For example, because &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::iterator&lt;/code&gt; is implementation-defined, it may not satisfy the &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; requirement. Use of algorithms such as &lt;code&gt;&lt;a href=&quot;../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that require &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterators&lt;/a&gt; may result in &lt;a href=&quot;http://www.boost.org/doc/libs/1_52_0/libs/dynamic_bitset/dynamic_bitset.html#rationale&quot;&gt;either compile-time or run-time errors&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 은 최적화 된 표현으로 모든 &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; 또는 &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; 요구 사항을 반드시 충족 할 필요는 없습니다 . 예를 들어 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::iterator&lt;/code&gt; 는 구현에 따라 정의되므로 &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; 요구 사항을 충족하지 않을 수 있습니다 . &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; 가 필요한 &lt;code&gt;&lt;a href=&quot;../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; 와 같은 알고리즘을 사용 &lt;a href=&quot;http://www.boost.org/doc/libs/1_52_0/libs/dynamic_bitset/dynamic_bitset.html#rationale&quot;&gt;하면 컴파일 타임 또는 런타임 오류가 발생할 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59120bf45bf0e3dc09f7ad3363dc1b08094ba734" translate="yes" xml:space="preserve">
          <source>Since language linkage is part of every function type, pointers to functions maintain language linkage as well. Language linkage of function types (which represents calling convention) and language linkage of function names (which represents name mangling) are independent of each other:</source>
          <target state="translated">언어 연결은 모든 함수 유형의 일부이므로 함수에 대한 포인터는 언어 연결도 유지합니다. 함수 유형의 언어 연결 (호출 규칙을 나타냄)과 함수 이름의 언어 연결 (이름 맹 글링을 나타냄)은 서로 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="00aa71d9edfae3bc000e4211aec722c02ac23c61" translate="yes" xml:space="preserve">
          <source>Since many of regex operations are locale-sensitive (when &lt;code&gt;&lt;a href=&quot;syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; flag is set), the regex_traits class typically holds an instance of a &lt;code&gt;&lt;a href=&quot;../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; as a private member.</source>
          <target state="translated">많은 정규식 작업이 로케일에 민감하기 때문에 ( &lt;code&gt;&lt;a href=&quot;syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; 플래그가 설정된 경우) regex_traits 클래스는 일반적으로 &lt;code&gt;&lt;a href=&quot;../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; 인스턴스를 개인 멤버로 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="e1154928a5e14f8714e9865148a4606da277f324" translate="yes" xml:space="preserve">
          <source>Since message has to be a string literal, it cannot contain dynamic information or even a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; that is not a string literal itself. In particular, it cannot contain the &lt;a href=&quot;name&quot;&gt;name&lt;/a&gt; of the &lt;a href=&quot;template_parameters&quot;&gt;template type argument&lt;/a&gt;.</source>
          <target state="translated">메시지는 문자열 리터럴이어야하므로 동적 정보 나 문자열 리터럴 자체가 아닌 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현식&lt;/a&gt; 을 포함 할 수 없습니다 . 특히 &lt;a href=&quot;template_parameters&quot;&gt;템플리트 유형 인수&lt;/a&gt; 의 &lt;a href=&quot;name&quot;&gt;이름&lt;/a&gt; 을 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="22c8aa4c1624c1e165427ced739188017b6400e5" translate="yes" xml:space="preserve">
          <source>Since ranking of conversion sequences operates with types and value categories only, a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; can bind to a reference argument for the purpose of ranking, but if that function gets selected, it will be ill-formed.</source>
          <target state="translated">변환 순서의 순위는 유형 및 값 범주로만 작동하므로 &lt;a href=&quot;bit_field&quot;&gt;비트 필드&lt;/a&gt; 는 순위를 목적으로 참조 인수에 바인딩 할 수 있지만 해당 함수가 선택되면 형식이 잘못됩니다.</target>
        </trans-unit>
        <trans-unit id="4460285e125395b2552b4be6766da2d831503ab6" translate="yes" xml:space="preserve">
          <source>Since reallocation may take place, &lt;code&gt;emplace_back&lt;/code&gt; requires the element type to be &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; for vectors.</source>
          <target state="translated">재 할당이 발생할 수 있으므로 &lt;code&gt;emplace_back&lt;/code&gt; 에서는 요소 유형이 벡터에 대해 &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable이어야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e40de4f7be410b2629d9d803e2b1896eb7796159" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;shared_ptr&lt;/code&gt; obtains its deleter (a &lt;code&gt;&lt;a href=&quot;../default_delete&quot;&gt;std::default_delete&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; object) from the &lt;code&gt;unique_ptr&lt;/code&gt;, the array will be correctly deallocated.</source>
          <target state="translated">때문에 &lt;code&gt;shared_ptr&lt;/code&gt; 의이 그 획득을 Deleter가 (a &lt;code&gt;&lt;a href=&quot;../default_delete&quot;&gt;std::default_delete&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; 객체)로부터 &lt;code&gt;unique_ptr&lt;/code&gt; 어레이가 정확하게 해제 될 것이다.</target>
        </trans-unit>
        <trans-unit id="1620299a964087a7c68a2c6947cce22ccf933751" translate="yes" xml:space="preserve">
          <source>Since the introduction of user-defined literals, the code that uses &lt;a href=&quot;http://en.cppreference.com/w/c/types/integer.html&quot;&gt;format macro constants for fixed-width integer types&lt;/a&gt; with no space after the preceding string literal became invalid: &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%&quot;&lt;a href=&quot;../types/integer&quot;&gt;PRId64&lt;/a&gt;&quot;\n&quot;,&lt;a href=&quot;../types/integer&quot;&gt;INT64_MIN&lt;/a&gt;);&lt;/code&gt; has to be replaced by &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%&quot; &lt;a href=&quot;../types/integer&quot;&gt;PRId64&lt;/a&gt;&quot;\n&quot;,&lt;a href=&quot;../types/integer&quot;&gt;INT64_MIN&lt;/a&gt;);&lt;/code&gt;</source>
          <target state="translated">사용자 정의 리터럴이 도입 &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%&quot;&lt;a href=&quot;../types/integer&quot;&gt;PRId64&lt;/a&gt;&quot;\n&quot;,&lt;a href=&quot;../types/integer&quot;&gt;INT64_MIN&lt;/a&gt;);&lt;/code&gt; 앞의 문자열 리터럴 뒤에 공백이없는 &lt;a href=&quot;http://en.cppreference.com/w/c/types/integer.html&quot;&gt;고정 너비 정수 유형에 형식 매크로 상수를&lt;/a&gt; 사용하는 코드 는 유효하지 않습니다. &lt;a href=&quot;../io/c/fprintf&quot;&gt;std :: printf&lt;/a&gt; ( &quot;%&quot; PRId64 &quot;\ n&quot;, &lt;a href=&quot;../types/integer&quot;&gt;INT64_MIN&lt;/a&gt; ); 대체되어야 &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%&quot; &lt;a href=&quot;../types/integer&quot;&gt;PRId64&lt;/a&gt;&quot;\n&quot;,&lt;a href=&quot;../types/integer&quot;&gt;INT64_MIN&lt;/a&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6605890e57506cfb54ca1476387e076094c45493" translate="yes" xml:space="preserve">
          <source>Since this meaning of the keyword &lt;code&gt;inline&lt;/code&gt; is non-binding, compilers are free to use inline substitution for any function that's not marked inline, and are free to generate function calls to any function marked inline. Those optimization choices do not change the rules regarding multiple definitions and shared statics listed above.</source>
          <target state="translated">키워드 &lt;code&gt;inline&lt;/code&gt; 의 이러한 의미는 구속력 이 없기 때문에 컴파일러는 인라인으로 표시되지 않은 함수에 대해 인라인 대체를 자유롭게 사용할 수 있으며 인라인으로 표시된 함수에 대한 함수 호출을 자유롭게 생성 할 수 있습니다. 이러한 최적화 선택은 위에 나열된 여러 정의 및 공유 정적에 관한 규칙을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc80190c0d22504d80be6153894b93b31cfb604d" translate="yes" xml:space="preserve">
          <source>Since variant is never permitted to allocate dynamic memory, previous value cannot be retained in these situations.</source>
          <target state="translated">변형은 동적 메모리 할당을 허용하지 않으므로 이러한 상황에서는 이전 값을 유지할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c45f24beb57e38b698d3ce8c5ae37ca439685549" translate="yes" xml:space="preserve">
          <source>Since virtual members are part of the interface component of pImpl, mocking a pImpl implies mocking the interface component alone. A testable pImpl is typically designed to allow full test coverage through the available interface.</source>
          <target state="translated">가상 멤버는 pImpl의 인터페이스 구성 요소의 일부이므로 pImpl을 조롱하면 인터페이스 구성 요소 만 조롱하는 것을 의미합니다. 테스트 가능한 pImpl은 일반적으로 사용 가능한 인터페이스를 통해 전체 테스트 범위를 허용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="01023f649513952abe496b73748117186e5a306e" translate="yes" xml:space="preserve">
          <source>Single character is preceded by a space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f240da1d0f429d9b1906f5ac8b6dd8cc37d07d" translate="yes" xml:space="preserve">
          <source>Single digit is preceded by a space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef55c5b9eaee331f66eae74df02c2af41eafb71" translate="yes" xml:space="preserve">
          <source>Single-object version, &lt;code&gt;unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">단일 객체 버전, &lt;code&gt;unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22d0803f659b9a68120fc2d5a3996d0572f0d784" translate="yes" xml:space="preserve">
          <source>Single-writer/multiple-reader lock can be made with fetch_add. Note that this simplistic implementation is not lockout-free.</source>
          <target state="translated">fetch_add로 단일 작성기 / 다중 판독기 잠금을 수행 할 수 있습니다. 이 간단한 구현은 잠금이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef575e12952f61f9bac204b82b00f1839b3ca9e3" translate="yes" xml:space="preserve">
          <source>Singular iterators</source>
          <target state="translated">특이 반복자</target>
        </trans-unit>
        <trans-unit id="5b347a3919b8069efdf614137abd1e4d916c644e" translate="yes" xml:space="preserve">
          <source>Six deduction guides are provided for &lt;code&gt;zoned_time&lt;/code&gt;. They normalize &lt;code&gt;Duration&lt;/code&gt; to a minimum resolution of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt;, and provide correct handling for time zone names specified using types convertible to &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;zoned_time&lt;/code&gt; 에 6 개의 추론 가이드가 제공됩니다 . &lt;code&gt;Duration&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt; 의 최소 ​​해상도로 정규화 하고 &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt; 로 변환 가능한 유형을 사용하여 지정된 시간대 이름을 올바르게 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="381b9cba23adca3666e3c1bed8420bdccab985a9" translate="yes" xml:space="preserve">
          <source>Six global basic_ostream objects are provided by the standard library.</source>
          <target state="translated">표준 라이브러리는 6 개의 전역 basic_ostream 객체를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="1089a09be10396c011527de780e9b49cb3308d4a" translate="yes" xml:space="preserve">
          <source>Size in bits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8a0e2cd42b491da31e41308e9287bdfe97bf7c" translate="yes" xml:space="preserve">
          <source>Sized deallocation</source>
          <target state="translated">규모가 큰 할당 해제</target>
        </trans-unit>
        <trans-unit id="a6ceb63258d717a681c569cf041196fa6b5c1c87" translate="yes" xml:space="preserve">
          <source>SizedRange</source>
          <target state="translated">SizedRange</target>
        </trans-unit>
        <trans-unit id="961842b5d2fd3472c9d52acdca1dc7c3ffb770d1" translate="yes" xml:space="preserve">
          <source>SizedSentinel</source>
          <target state="translated">SizedSentinel</target>
        </trans-unit>
        <trans-unit id="32f8bf96a0bd875194723dd6f7b3b0d18f1291fa" translate="yes" xml:space="preserve">
          <source>Sizes may be rounded to an unspecified granularity.</source>
          <target state="translated">크기는 지정되지 않은 세분성으로 반올림 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="338622e75d7f5d93bff486ccb15b9f19545a1937" translate="yes" xml:space="preserve">
          <source>Skip directories that would otherwise result in permission denied errors.</source>
          <target state="translated">그렇지 않으면 권한 거부 오류가 발생하는 디렉토리를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="39ce73047a637a26adee194ba2061f2e02dd69d0" translate="yes" xml:space="preserve">
          <source>Skip subdirectories (default behavior)</source>
          <target state="translated">하위 디렉토리 건너 뛰기 (기본 동작)</target>
        </trans-unit>
        <trans-unit id="2460e6fd123cf1efd38917ed660654cd31ec9506" translate="yes" xml:space="preserve">
          <source>Skips &lt;code&gt;count&lt;/code&gt; characters in the get area. This is done by advancing the</source>
          <target state="translated">가져 오기 영역에서 &lt;code&gt;count&lt;/code&gt; 문자를 건너 뜁니다 . 이것은 전진하여 이루어집니다</target>
        </trans-unit>
        <trans-unit id="301d79d18fe92372bfd14f52cdb1fb9deb17a4a4" translate="yes" xml:space="preserve">
          <source>Slice/mask/indirect index accesses do not chain: &lt;code&gt;v[v==n][&lt;a href=&quot;slice&quot;&gt;std::slice&lt;/a&gt;(0,5,2)] = x;&lt;/code&gt; is an error because &lt;code&gt;&lt;a href=&quot;mask_array&quot;&gt;std::mask_array&lt;/a&gt;&lt;/code&gt; (the type of &lt;code&gt;v[v==n]&lt;/code&gt;) does not have &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">슬라이스 / 마스크 / 간접 인덱스 액세스는 연결되지 않습니다. &lt;code&gt;v[v==n][&lt;a href=&quot;slice&quot;&gt;std::slice&lt;/a&gt;(0,5,2)] = x;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;mask_array&quot;&gt;std::mask_array&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;v[v==n]&lt;/code&gt; 유형 )에 &lt;code&gt;operator[]&lt;/code&gt; 가 없기 때문에 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="7449b96680387cef7a35514f8b4cc968d87552e7" translate="yes" xml:space="preserve">
          <source>Small Buffer Optimization</source>
          <target state="translated">작은 버퍼 최적화</target>
        </trans-unit>
        <trans-unit id="2dda9285d4bfd3311fa52a7391e1f10b968de46c" translate="yes" xml:space="preserve">
          <source>Small Object Optimization</source>
          <target state="translated">작은 물체 최적화</target>
        </trans-unit>
        <trans-unit id="657c4b92030f950f98c992a4f6c147e40488cb5d" translate="yes" xml:space="preserve">
          <source>Small String Optimization</source>
          <target state="translated">작은 문자열 최적화</target>
        </trans-unit>
        <trans-unit id="5280487b4a39af03996e3bd19a8268c63c1877bd" translate="yes" xml:space="preserve">
          <source>Smart pointer non-member operations</source>
          <target state="translated">스마트 포인터 비 멤버 작업</target>
        </trans-unit>
        <trans-unit id="bf0fcdc3a447c0f10f6f532765bcc76c84847421" translate="yes" xml:space="preserve">
          <source>Smart pointers</source>
          <target state="translated">스마트 포인터</target>
        </trans-unit>
        <trans-unit id="81da943626b80ddf7742b25bead2b748e84981fc" translate="yes" xml:space="preserve">
          <source>Smart pointers (e.g. &lt;code&gt;&lt;a href=&quot;memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;), allocators (e.g. &lt;code&gt;&lt;a href=&quot;memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;std::memory_resource&lt;/code&gt;), C-style memory management (e.g. &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">스마트 포인터 (예 : &lt;code&gt;&lt;a href=&quot;memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; ), 할당 자 (예 : &lt;code&gt;&lt;a href=&quot;memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;std::memory_resource&lt;/code&gt; ), C 스타일 메모리 관리 (예 : &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5237636d1bbbca8bfd0e9212d068f275af782a07" translate="yes" xml:space="preserve">
          <source>Smart pointers enable automatic, exception-safe, object lifetime management.</source>
          <target state="translated">스마트 포인터를 사용하면 예외없이 안전하고 자동으로 객체 수명을 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="99d962452bf23cfce358191ab2ce40997d4a7521" translate="yes" xml:space="preserve">
          <source>So that all but the first inclusion of the header in any translation unit are excluded from compilation. All modern compilers record the fact that a header file uses an include guard and do not re-parse the file if it is encountered again, as long as the guard is still defined. (see e.g. &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Once-Only-Headers.html&quot;&gt;gcc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10279063fcdbb5e2692d2226f688d7b65ac2fb32" translate="yes" xml:space="preserve">
          <source>Socket is connected</source>
          <target state="translated">소켓이 연결되었습니다</target>
        </trans-unit>
        <trans-unit id="a4db4b6c518a0310c7a9175dae07831f11097843" translate="yes" xml:space="preserve">
          <source>Some I/O functions call &lt;code&gt;width(0)&lt;/code&gt; before returning, see &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; (this results in this field having effect on the next I/O function only, and not on any subsequent I/O).</source>
          <target state="translated">리턴하기 전에 일부 I / O 함수는 &lt;code&gt;width(0)&lt;/code&gt; 호출합니다. &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 참조하십시오 (이 필드는 후속 I / O가 아닌 다음 I / O 함수에만 영향을 미칩니다).</target>
        </trans-unit>
        <trans-unit id="5adbe247c42621c892c4aa15bf359467135fbfb1" translate="yes" xml:space="preserve">
          <source>Some compilers don't implement instantiation units (also known as &lt;a href=&quot;http://docs.oracle.com/cd/E18659_01/html/821-1383/bkagr.html#scrolltoc&quot;&gt;template repositories&lt;/a&gt; or &lt;a href=&quot;http://www-01.ibm.com/support/knowledgecenter/SSXVZZ_12.1.0/com.ibm.xlcpp121.linux.doc/compiler_ref/fcat_template.html?lang=en&quot;&gt;template registries&lt;/a&gt;) and simply compile each template instantiation at Phase 7, storing the code in the object file where it is implicitly or explicitly requested, and then the linker collapses these compiled instantiations into one at Phase 9.</source>
          <target state="translated">일부 컴파일러는 인스턴스화 단위 ( &lt;a href=&quot;http://docs.oracle.com/cd/E18659_01/html/821-1383/bkagr.html#scrolltoc&quot;&gt;템플리트 리포지토리&lt;/a&gt; 또는 &lt;a href=&quot;http://www-01.ibm.com/support/knowledgecenter/SSXVZZ_12.1.0/com.ibm.xlcpp121.linux.doc/compiler_ref/fcat_template.html?lang=en&quot;&gt;템플릿 레지스트리&lt;/a&gt; 라고도 함)를 구현하지 않고 7 단계에서 각 템플릿 인스턴스화를 간단히 컴파일하여 암시 적 또는 명시 적으로 요청 된 오브젝트 파일에 코드를 저장 한 다음 링커에서 컴파일 된 코드를 접습니다. 단계 9에서 하나로 인스턴스화.</target>
        </trans-unit>
        <trans-unit id="4c54e7b53f7cadf1e6c3559a8ef1472882f98a89" translate="yes" xml:space="preserve">
          <source>Some existing implementations have a bug where they may occasionally return &lt;code&gt;1.0&lt;/code&gt; if &lt;code&gt;RealType&lt;/code&gt; is &lt;code&gt;float&lt;/code&gt;&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63176&quot;&gt;GCC #63176&lt;/a&gt;&lt;a href=&quot;http://llvm.org/bugs/show_bug.cgi?id=18767&quot;&gt;LLVM #18767&lt;/a&gt;. This is &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2524&quot;&gt;LWG issue 2524 &lt;/a&gt;</source>
          <target state="translated">일부 기존 구현에는 &lt;code&gt;RealType&lt;/code&gt; 이 &lt;code&gt;float&lt;/code&gt; &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63176&quot;&gt;GCC # 63176 &lt;/a&gt;&lt;a href=&quot;http://llvm.org/bugs/show_bug.cgi?id=18767&quot;&gt;LLVM # 18767 인&lt;/a&gt; 경우 때때로 &lt;code&gt;1.0&lt;/code&gt; 을 반환 할 수있는 버그가 있습니다 . 이것은 &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2524&quot;&gt;LWG 문제 2524입니다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ec2aada0af03043ccc865c1099f969a15be807a" translate="yes" xml:space="preserve">
          <source>Some existing implementations have a bug where they may occasionally return b if &lt;code&gt;RealType&lt;/code&gt; is &lt;code&gt;float&lt;/code&gt;&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63176&quot;&gt;GCC #63176&lt;/a&gt;&lt;a href=&quot;http://llvm.org/bugs/show_bug.cgi?id=18767&quot;&gt;LLVM #18767&lt;/a&gt;. This is caused by &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2524&quot;&gt;LWG issue 2524 &lt;/a&gt;</source>
          <target state="translated">일부 기존 구현에는 &lt;code&gt;RealType&lt;/code&gt; 이 &lt;code&gt;float&lt;/code&gt; &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63176&quot;&gt;GCC # 63176 &lt;/a&gt;&lt;a href=&quot;http://llvm.org/bugs/show_bug.cgi?id=18767&quot;&gt;LLVM # 18767 인&lt;/a&gt; 경우 때때로 b를 반환 할 수있는 버그가 있습니다 . 이는 &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2524&quot;&gt;LWG 문제 2524로&lt;/a&gt; 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8ae96e14b066d0ec8a8395d164b310c7927bac50" translate="yes" xml:space="preserve">
          <source>Some file systems do not support hard links regardless of the operating system: the FAT file system used on memory cards and flash drives, for example.</source>
          <target state="translated">일부 파일 시스템은 운영 체제와 상관없이 하드 링크를 지원하지 않습니다. 예를 들어 메모리 카드 및 플래시 드라이브에 사용되는 FAT 파일 시스템.</target>
        </trans-unit>
        <trans-unit id="25651c80339ed821602271ae6cf24d89af5e9ee0" translate="yes" xml:space="preserve">
          <source>Some file systems do not support symbolic links regardless of the operating system, for example the FAT system used on some memory cards and flash drives.</source>
          <target state="translated">일부 파일 시스템은 운영 체제와 상관없이 기호 링크를 지원하지 않습니다 (예 : 일부 메모리 카드 및 플래시 드라이브에 사용되는 FAT 시스템).</target>
        </trans-unit>
        <trans-unit id="b5842b00ee9574c370ef65e50ea3aa3f71da0f84" translate="yes" xml:space="preserve">
          <source>Some file systems limit the number of links per file.</source>
          <target state="translated">일부 파일 시스템은 파일 당 링크 수를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="3baebc4d02301b876a42c09dafb12fd777d30fb5" translate="yes" xml:space="preserve">
          <source>Some forms of &lt;code&gt;dynamic_cast&lt;/code&gt; rely on &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-time_type_information&quot;&gt;runtime type identification&lt;/a&gt; (RTTI), that is, information about each polymorphic class in the compiled program. Compilers typically have options to disable the inclusion of this information.</source>
          <target state="translated">&lt;code&gt;dynamic_cast&lt;/code&gt; 의 일부 형식은 RTTI ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-time_type_information&quot;&gt;런타임 유형 식별&lt;/a&gt; ), 즉 컴파일 된 프로그램의 각 다형성 클래스에 대한 정보에 의존 합니다. 컴파일러에는 일반적으로이 정보 포함을 비활성화하는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f45f2bc9dd0eef9a815d996c8598d556c1d75b2f" translate="yes" xml:space="preserve">
          <source>Some implementations (such as MSVC, IBM, Oracle) produce a human-readable type name. Others, most notably gcc and clang, return the mangled name. The mangled name can be converted to human-readable form using implementation-specific API such as &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/libstdc%20%20/manual/ext_demangling.html&quot;&gt;abi::__cxa_demangle&lt;/a&gt; directly or through &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/core/doc/html/core/demangle.html&quot;&gt;boost::core::demangle&lt;/a&gt;. It can also be piped through the commandline utility &lt;code&gt;c++filt -t&lt;/code&gt;.</source>
          <target state="translated">MSVC, IBM, Oracle과 같은 일부 구현은 사람이 읽을 수있는 유형 이름을 생성합니다. gcc와 clang과 같은 다른 사람들은 맹 글링 된 이름을 반환합니다. 맹 글링 된 이름은 직접 또는 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/core/doc/html/core/demangle.html&quot;&gt;boost :: core :: demangle을&lt;/a&gt; 통해 &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/libstdc%20%20/manual/ext_demangling.html&quot;&gt;abi :: __ cxa_demangle&lt;/a&gt; 과 같은 구현 별 API를 사용하여 사람이 읽을 수있는 형식으로 변환 될 수 있습니다 . 명령 줄 유틸리티 &lt;code&gt;c++filt -t&lt;/code&gt; 통해 파이프 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e9f769d3f52ad14152cedf0345bfc21cff89b9b" translate="yes" xml:space="preserve">
          <source>Some implementations also throw &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;push_back&lt;/code&gt; causes a reallocation that would exceed &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt;, due to implicitly calling an equivalent of &lt;code&gt;reserve(size()+1)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;push_back&lt;/code&gt; 이 암시 적으로 &lt;code&gt;reserve(size()+1)&lt;/code&gt; 해당하는 호출로 인해 &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt; 를 초과하는 재 할당을 발생시키는 경우 일부 구현에서는 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="1211a18140d5c923fb6d564901b0cd227d7c8de1" translate="yes" xml:space="preserve">
          <source>Some implementations are able to delete any facet, including the locale-specific facets with protected destructors. Other implementations require the facet to have a public destructor, similar to the the locale-independent facets from &lt;code&gt;&amp;lt;codecvt&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">일부 구현에서는 보호 된 소멸자가있는 로케일 특정 패싯을 포함하여 모든 패싯을 삭제할 수 있습니다. 다른 구현에서는 패싯에 &lt;code&gt;&amp;lt;codecvt&amp;gt;&lt;/code&gt; 의 로케일 독립적 패싯과 유사한 공개 소멸자가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="23bf9c695f08640c97ac98dea8399ad1f810bbb1" translate="yes" xml:space="preserve">
          <source>Some implementations are able to delete any facet, including the locale-specific facets with protected destructors. Other implementations require the facet to have a public destructor, similar to the the locale-independent facets from &lt;code&gt;&amp;lt;codecvt&amp;gt;&lt;/code&gt;. This is &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721&quot;&gt;LWG issue 721&lt;/a&gt;.</source>
          <target state="translated">일부 구현에서는 보호 된 소멸자가있는 로케일 특정 패싯을 포함하여 모든 패싯을 삭제할 수 있습니다. 다른 구현에서는 패싯에 &lt;code&gt;&amp;lt;codecvt&amp;gt;&lt;/code&gt; 의 로케일 독립적 패싯과 유사한 공개 소멸자가 필요합니다 . 이것은 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721&quot;&gt;LWG 문제 721&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ba520fb2c503cdc25ec5b9b6f3a0f079c16b72d8" translate="yes" xml:space="preserve">
          <source>Some implementations handle &lt;code&gt;timeptr-&amp;gt;tm_mday==0&lt;/code&gt; as meaning the last day of the preceding month.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6438dffce87e65a616bf990b409e64a0fe8a0484" translate="yes" xml:space="preserve">
          <source>Some implementations may occasionally return infinity if &lt;code&gt;RealType&lt;/code&gt; is &lt;code&gt;float&lt;/code&gt;. This is &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2524&quot;&gt;LWG issue 2524&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;RealType&lt;/code&gt; 이 &lt;code&gt;float&lt;/code&gt; 인 경우 일부 구현은 때때로 무한대를 반환 할 수 있습니다 . 이것은 &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2524&quot;&gt;LWG 문제 2524&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69d9a9a13766d236996c1d2bb4d126a13661dd61" translate="yes" xml:space="preserve">
          <source>Some locales offer additional character classes that detect non-ASCII digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2984dbcf7994a8b794a77e7494406d337036fa6" translate="yes" xml:space="preserve">
          <source>Some member functions are</source>
          <target state="translated">일부 멤버 함수는</target>
        </trans-unit>
        <trans-unit id="a7d6cdd50583dc42bfdb814089c96c038db55e75" translate="yes" xml:space="preserve">
          <source>Some member functions are special: under certain circumstances they are defined by the compiler even if not defined by the user. They are:</source>
          <target state="translated">일부 멤버 함수는 특별합니다. 특정 상황에서는 사용자가 정의하지 않은 경우에도 컴파일러에서 정의합니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="837173a7f0c46c404633f2871fb260cf5e1fc724" translate="yes" xml:space="preserve">
          <source>Some non-standard libraries define a type trait &quot;BitwiseMovable&quot; or &quot;Relocatable&quot;, which describes a type that doesn't have:</source>
          <target state="translated">일부 비표준 라이브러리는 유형 특성 &quot;BitwiseMovable&quot;또는 &quot;Relocatable&quot;을 정의하며 다음과 같은 유형이없는 유형을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="be708867f7f47ff2e9f45f6a8f29ccfdd0cce8fd" translate="yes" xml:space="preserve">
          <source>Some of the &lt;a href=&quot;../io&quot;&gt;I/O streams member functions&lt;/a&gt; return and manipulate objects of member typedef &lt;code&gt;pos_type&lt;/code&gt;. For streams, these member typedefs are provided by the template parameter &lt;code&gt;Traits&lt;/code&gt;, which defaults to &lt;code&gt;&lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt;, which define their &lt;code&gt;pos_type&lt;/code&gt;s to be specializations of &lt;code&gt;std::fpos&lt;/code&gt;. The behavior of the I/O streams library is implementation-defined when &lt;code&gt;Traits::pos_type&lt;/code&gt; is not &lt;code&gt;std::fpos&amp;lt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; (aka &lt;code&gt;std::streampos&lt;/code&gt; or &lt;code&gt;std::wstreampos&lt;/code&gt;).</source>
          <target state="translated">일부 &lt;a href=&quot;../io&quot;&gt;I / O 스트림 멤버 함수&lt;/a&gt; 는 typedef &lt;code&gt;pos_type&lt;/code&gt; 멤버의 오브젝트를 리턴하고 조작합니다 . 스트림의 경우, 이러한 멤버 typedef는 템플리트 매개 변수 &lt;code&gt;Traits&lt;/code&gt; 에 의해 제공되며, 기본값은 &lt;code&gt;&lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; 이며, &lt;code&gt;pos_type&lt;/code&gt; 은 &lt;code&gt;std::fpos&lt;/code&gt; 전문화되도록 정의합니다 . I / O 스트림 라이브러리의 동작은 &lt;code&gt;Traits::pos_type&lt;/code&gt; 이 &lt;code&gt;std::fpos&amp;lt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; (일명 &lt;code&gt;std::streampos&lt;/code&gt; 또는 &lt;code&gt;std::wstreampos&lt;/code&gt; ) 가 아닌 경우 구현 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="42f4721337bfcd1c4414747ff2568f867f2077d7" translate="yes" xml:space="preserve">
          <source>Some of the operators have &lt;a href=&quot;operator_alternative&quot;&gt;alternate spellings&lt;/a&gt; (e.g., &lt;code&gt;and&lt;/code&gt; for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; for &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;, etc.).</source>
          <target state="translated">연산자의 일부가 &lt;a href=&quot;operator_alternative&quot;&gt;대체 철자&lt;/a&gt; (예를, &lt;code&gt;and&lt;/code&gt; 위한 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; 에 대한 &lt;code&gt;||&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; 에 &lt;code&gt;!&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="765e9b729b33e7053ac6c10ee70ba3f6b6995835" translate="yes" xml:space="preserve">
          <source>Some of the standard-required facets, such as the UTF-8/UTF-32 conversion facet &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char32_t, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt;, have no equivalents in the &quot;C&quot; locale, but they are nevertheless present in the locale returned by &lt;code&gt;std::locale::classic()&lt;/code&gt;, as in any other locale constructed in a C++ program.</source>
          <target state="translated">UTF-8 / UTF-32 변환 패싯 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char32_t, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 와 같은 일부 표준 필수 패싯 은 &quot;C&quot;로케일에 해당하는 항목이 없지만 그럼에도 불구하고 존재합니다. C ++ 프로그램에서 생성 된 다른 로케일에서와 같이 &lt;code&gt;std::locale::classic()&lt;/code&gt; 의해 리턴 된 로케일에서</target>
        </trans-unit>
        <trans-unit id="caa174c46ca2ec6d14f7d14a1986d4b238a9d0ec" translate="yes" xml:space="preserve">
          <source>Some of these requirements are being formalized in C++20 using the &lt;a href=&quot;language/constraints&quot;&gt;concepts&lt;/a&gt; language feature. Until then, the burden is on the programmer to ensure that library templates are instantiated with template arguments that satisfy these requirements. Failure to do so may result in very complex compiler diagnostics.</source>
          <target state="translated">이러한 요구 사항 중 일부는 &lt;a href=&quot;language/constraints&quot;&gt;개념&lt;/a&gt; 언어 기능을 사용하여 C ++ 20으로 공식화되고 있습니다. 그때까지는 라이브러리 템플릿이 이러한 요구 사항을 충족하는 템플릿 인수로 인스턴스화되어야하는 부담이 프로그래머에게 있습니다. 그렇지 않으면 컴파일러 진단이 매우 복잡해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfcefe079222e4c23d3487cf53ffb814bc175ca7" translate="yes" xml:space="preserve">
          <source>Some operating systems do not support hard links at all or support them only for regular files.</source>
          <target state="translated">일부 운영 체제는 하드 링크를 전혀 지원하지 않거나 일반 파일에 대해서만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cd02034e447f5be2058fe371e17584fad666449c" translate="yes" xml:space="preserve">
          <source>Some operating systems do not support symbolic links at all or support them only for regular files.</source>
          <target state="translated">일부 운영 체제는 기호 링크를 전혀 지원하지 않거나 일반 파일에 대해서만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a6d76a7395176458beb737711e50d3138c198101" translate="yes" xml:space="preserve">
          <source>Some operating systems require symlink creation to identify that the link is to a directory. Portable code should use (2) to create directory symlinks rather than (1), even though there is no distinction on POSIX systems.</source>
          <target state="translated">일부 운영 체제에서는 링크가 디렉토리에 대한 것임을 식별하기 위해 symlink 작성이 필요합니다. POSIX 시스템에 차이가 없더라도 이식 가능한 코드는 (1) 대신 (2)를 사용하여 디렉토리 심볼릭 링크를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="fb8327d50eb27e2d33c783ff01dfd4bd720a5528" translate="yes" xml:space="preserve">
          <source>Some operations on floating-point numbers are affected by and modify the state of &lt;a href=&quot;../numeric/fenv&quot;&gt;the floating-point environment&lt;/a&gt; (most notably, the rounding direction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b438936ace997fb03408714f0cc8c0d6e4e62b22" translate="yes" xml:space="preserve">
          <source>Some permission bits may be ignored on some systems, and changing some bits may automatically change others (e.g. on platforms without owner/group/all distinction, setting any of the three write bits set all three).</source>
          <target state="translated">일부 권한 비트는 일부 시스템에서 무시 될 수 있으며, 일부 비트를 변경하면 다른 비트가 자동으로 변경 될 수 있습니다 (예 : 소유자 / 그룹 / 모든 구별이없는 플랫폼에서 3 개의 쓰기 비트 중 하나를 설정).</target>
        </trans-unit>
        <trans-unit id="5fc481c89819102012a9d0f89914c46dff389023" translate="yes" xml:space="preserve">
          <source>Some range adaptors wrap their element or function object with the &lt;a href=&quot;ranges/semiregular_wrapper&quot;&gt;semiregular wrapper&lt;/a&gt;.</source>
          <target state="translated">일부 범위 어댑터는 해당 요소 또는 함수 객체를 &lt;a href=&quot;ranges/semiregular_wrapper&quot;&gt;반 정규 래퍼로 래핑&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f7ab779158c707137836b8aca6e4154cf5a7a3c2" translate="yes" xml:space="preserve">
          <source>Some requirements are optional: the template &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; supplies the default implementations for all optional requirements, and all standard library containers and other allocator-aware classes access the allocator through &lt;code&gt;std::allocator_traits&lt;/code&gt;, not directly.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; 템플리트 는 모든 선택적 요구 사항에 대한 기본 구현을 제공하며 모든 표준 라이브러리 컨테이너 및 기타 할당 자 인식 클래스는 직접이 아닌 &lt;code&gt;std::allocator_traits&lt;/code&gt; 통해 할당 자에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="1edcbd0864e00de6bc3ed666e900623b2628f887" translate="yes" xml:space="preserve">
          <source>Some return types of functions of &lt;a href=&quot;../header/functional&quot;&gt;&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../header/functional&quot;&gt; &lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 일부 리턴 유형 함수</target>
        </trans-unit>
        <trans-unit id="17e1b6b6fdfa075b5d4bcbe52a9b4bcc63b8b045" translate="yes" xml:space="preserve">
          <source>Some standard library function object adaptors, such as &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt;, require the function objects they adapt to have certain types defined; &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; requires the function object being adapted to have a type named &lt;code&gt;argument_type&lt;/code&gt;. Deriving function objects that take one argument from &lt;code&gt;unary_function&lt;/code&gt; is an easy way to make them compatible with those adaptors.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; 과 같은 일부 표준 라이브러리 함수 객체 어댑터 에는 특정 유형이 정의되도록 적응하는 함수 객체가 필요합니다. &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;argument_type&lt;/code&gt; 이라는 유형을 갖도록 함수 객체가 필요합니다 . &lt;code&gt;unary_function&lt;/code&gt; 에서 하나의 인수를 취하는 함수 객체를 파생 시키는 것은 이러한 어댑터와 호환되도록하는 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="09b957f5dade6785ca0c00036e5b0d560f353891" translate="yes" xml:space="preserve">
          <source>Some standard library function object adaptors, such as &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt;, require the function objects they adapt to have certain types defined; &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; requires the function object being adapted to have two types named &lt;code&gt;first_argument_type&lt;/code&gt; and &lt;code&gt;second_argument_type&lt;/code&gt;. Deriving function objects that take two arguments from &lt;code&gt;binary_function&lt;/code&gt; is an easy way to make them compatible with those adaptors.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; 와 같은 일부 표준 라이브러리 함수 오브젝트 어댑터 에는 특정 유형이 정의되도록 적응하는 함수 오브젝트가 필요합니다. &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; 는 함수 객체에 &lt;code&gt;first_argument_type&lt;/code&gt; 과 &lt;code&gt;second_argument_type&lt;/code&gt; 이라는 두 가지 유형을 갖도록 조정해야합니다 . &lt;code&gt;binary_function&lt;/code&gt; 에서 두 개의 인수를 사용하는 함수 객체를 파생 하면 해당 어댑터와 호환되도록하는 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7f250b829207ebe1245ad903482a0b2738133c9e" translate="yes" xml:space="preserve">
          <source>Sometimes it's safe to throw an exception even while &lt;code&gt;std::uncaught_exception() == true&lt;/code&gt;. For example, if &lt;a href=&quot;../../language/throw#Stack_unwinding&quot;&gt;stack unwinding&lt;/a&gt; causes an object to be destructed, the destructor for that object could run code that throws an exception as long as the exception is caught by some catch block before escaping the destructor.</source>
          <target state="translated">때로는 &lt;code&gt;std::uncaught_exception() == true&lt;/code&gt; 동안에도 예외를 throw하는 것이 안전 합니다 . 예를 들어 &lt;a href=&quot;../../language/throw#Stack_unwinding&quot;&gt;스택 해제로&lt;/a&gt; 인해 객체가 소멸되는 경우 해당 객체의 소멸자는 소멸자를 이스케이프하기 전에 일부 catch 블록에 의해 예외가 포착되는 한 예외를 발생시키는 코드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11110b24bcb6cedda127c754fb50036327560b2e" translate="yes" xml:space="preserve">
          <source>Sortable</source>
          <target state="translated">Sortable</target>
        </trans-unit>
        <trans-unit id="13696f439559b7aa831e1895b1974678571e434f" translate="yes" xml:space="preserve">
          <source>Sorting operations</source>
          <target state="translated">정렬 작업</target>
        </trans-unit>
        <trans-unit id="4e278b12f4f35189855f7d8b8761299f2cee21cb" translate="yes" xml:space="preserve">
          <source>Sorts some of the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in ascending order, storing the result in the range &lt;code&gt;[d_first, d_last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위의 일부 요소를 오름차순으로 정렬하고 결과를 &lt;code&gt;[d_first, d_last)&lt;/code&gt; 범위에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="ec2affa5e1e0bfa4da3bd5957467157ce4eec8f9" translate="yes" xml:space="preserve">
          <source>Sorts the elements in ascending order. The order of equal elements is preserved. The first version uses &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the elements, the second version uses the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">요소를 오름차순으로 정렬합니다. 동일한 요소의 순서가 유지됩니다. 첫 번째 버전은 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 를 사용하여 요소를 비교하고 두 번째 버전은 주어진 비교 함수 &lt;code&gt;comp&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f9ee61d95eb7ca033304a6c28affa88aea2875d6" translate="yes" xml:space="preserve">
          <source>Sorts the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in ascending order. The order of equal elements is not guaranteed to be preserved.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소 를 오름차순으로 정렬합니다. 동일한 요소의 순서는 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7fd2050346980b84ef2af829697dc3f0ed185be" translate="yes" xml:space="preserve">
          <source>Sorts the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in ascending order. The order of equivalent elements is guaranteed to be preserved.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소 를 오름차순으로 정렬합니다. 동등한 요소의 순서는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="da63b0d03cf0983af48537a59297f919f164f1bd" translate="yes" xml:space="preserve">
          <source>Sorts the given array pointed to by &lt;code&gt;ptr&lt;/code&gt; in ascending order. The array contains &lt;code&gt;count&lt;/code&gt; elements of &lt;code&gt;size&lt;/code&gt; bytes. Function pointed to by &lt;code&gt;comp&lt;/code&gt; is used for object comparison.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 가리키는 지정된 배열 을 오름차순으로 정렬합니다. 배열에는 &lt;code&gt;size&lt;/code&gt; 바이트 의 &lt;code&gt;count&lt;/code&gt; 요소가 포함 됩니다. &lt;code&gt;comp&lt;/code&gt; 가 가리키는 기능은 객체 비교에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1062d4ec3477261e4a029a283ebcf5e673c0c76e" translate="yes" xml:space="preserve">
          <source>Source file inclusion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737413ce7a08697aa3d4382b04c67b58abda52ab" translate="yes" xml:space="preserve">
          <source>Space overhead: pImpl adds one pointer to the public component and, if any private member needs access to a public member, another pointer is either added to the implementation component or passed as a parameter for each call to the private member that requires it. If stateful custom allocators are supported, the allocator instance also has to be stored.</source>
          <target state="translated">공간 오버 헤드 : pImpl은 공용 구성 요소에 하나의 포인터를 추가하고 개인 구성원이 공용 구성원에 액세스해야하는 경우 다른 구성 요소가 구현 구성 요소에 추가되거나이를 요구하는 개인 구성원에 대한 각 호출에 대한 매개 변수로 전달됩니다. 상태 저장 사용자 지정 할당자가 지원되는 경우 할당 자 인스턴스도 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0d61499cc942eb1278687007fde841d4bb2b516" translate="yes" xml:space="preserve">
          <source>Special categories</source>
          <target state="translated">특별 카테고리</target>
        </trans-unit>
        <trans-unit id="9ff426b0abd95de6e45376aa10b2853795200f0f" translate="yes" xml:space="preserve">
          <source>Special mathematical functions</source>
          <target state="translated">특수한 수학 함수</target>
        </trans-unit>
        <trans-unit id="827e6674de363a70897b99e51fffefdb810a4c6e" translate="yes" xml:space="preserve">
          <source>Special member functions</source>
          <target state="translated">특별 회원 기능</target>
        </trans-unit>
        <trans-unit id="471ddcb69cf1017797006b55d79f5f809498401a" translate="yes" xml:space="preserve">
          <source>Special member functions along with the &lt;a href=&quot;default_comparisons&quot;&gt;comparison operators&lt;/a&gt;(since C++20) are the only functions that can be</source>
          <target state="translated">&lt;a href=&quot;default_comparisons&quot;&gt;비교 연산자&lt;/a&gt; 와 함께 특수 멤버 함수 (C ++ 20부터)는 유일한 함수입니다.</target>
        </trans-unit>
        <trans-unit id="288289b7c043a255232197a83ad1c7f6a2f423f4" translate="yes" xml:space="preserve">
          <source>Special operators</source>
          <target state="translated">특수 연산자</target>
        </trans-unit>
        <trans-unit id="33035fa15c251880c6ca4666e10791e819d68abe" translate="yes" xml:space="preserve">
          <source>Special rules for &quot;C&quot; linkage</source>
          <target state="translated">&quot;C&quot;연계에 대한 특별 규칙</target>
        </trans-unit>
        <trans-unit id="eedd5b116274ae72545327b12c1f13a7daad71f8" translate="yes" xml:space="preserve">
          <source>Special rvalue category, see pending member function call.</source>
          <target state="translated">특수 rvalue 범주. 보류중인 멤버 함수 호출을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b0f090c0f44aceac36d2c9eb988dd8280d3ee8e3" translate="yes" xml:space="preserve">
          <source>Specialization</source>
          <target state="translated">Specialization</target>
        </trans-unit>
        <trans-unit id="257368682d0c8829b4ef3064212d06ea74f41e65" translate="yes" xml:space="preserve">
          <source>Specialization &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;</source>
          <target state="translated">전문화 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e647f7352410c64aa331edaf62ef052333f79c68" translate="yes" xml:space="preserve">
          <source>Specialization &lt;code&gt;&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;</source>
          <target state="translated">전문화 &lt;code&gt;&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b0ccfc71697ff533aa930f7710e55cb2073cb26" translate="yes" xml:space="preserve">
          <source>Specialization must be declared before the first use that would cause implicit instantiation, in every translation unit where such use occurs:</source>
          <target state="translated">이러한 번역이 사용되는 모든 번역 단위에서 암시 적 인스턴스화를 유발하는 최초 사용 전에 전문화를 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6e6a1cdf4edea6046f6580c6738f01dd9e2eb68" translate="yes" xml:space="preserve">
          <source>Specializations</source>
          <target state="translated">Specializations</target>
        </trans-unit>
        <trans-unit id="667dbdfed67d185499ee8e7b7611aa3094f35afa" translate="yes" xml:space="preserve">
          <source>Specializations for floating-point types</source>
          <target state="translated">부동 소수점 유형의 전문화</target>
        </trans-unit>
        <trans-unit id="1e564affdb1d23ebeeab32e35cfcdb3ef5d27755" translate="yes" xml:space="preserve">
          <source>Specializations for integral types</source>
          <target state="translated">통합 유형에 대한 전문화</target>
        </trans-unit>
        <trans-unit id="81d786495f28b64fb15d8f1b253ae6a120395aae" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for floating point types</source>
          <target state="translated">부동 소수점 유형에 대한 &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 전문화</target>
        </trans-unit>
        <trans-unit id="52623e5481935e9f4fe12a1d8fde12df3283eaeb" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for integral types</source>
          <target state="translated">정수형에 대한 &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 전문화</target>
        </trans-unit>
        <trans-unit id="b0cad4dac395f6b45cc7974188363bedca342e95" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for pointer types</source>
          <target state="translated">포인터 유형에 대한 &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 전문화</target>
        </trans-unit>
        <trans-unit id="377f7d31027e1bb1b02cf7940a0a9917ef71c589" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; should define an &lt;code&gt;operator()&lt;/code&gt; that:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 전문화 는 다음과 같은 &lt;code&gt;operator()&lt;/code&gt; 를 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="36c0df18df7950df4493024cd46642126fc345b1" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;&lt;a href=&quot;numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; are provided for all arithmetic types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; 전문은 모든 산술 유형에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="dbea40d88457b94b63f4441c672d628c0bd77376" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;std::atomic_ref&lt;/code&gt; for floating-point types</source>
          <target state="translated">부동 소수점 유형에 대한 &lt;code&gt;std::atomic_ref&lt;/code&gt; 전문화</target>
        </trans-unit>
        <trans-unit id="f9a3fe8a7a8d6f63e8edd13971f4a8b970846637" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;std::atomic_ref&lt;/code&gt; for integral types</source>
          <target state="translated">&lt;code&gt;std::atomic_ref&lt;/code&gt; 대한 std :: atomic_ref의 전문화</target>
        </trans-unit>
        <trans-unit id="ea1a6c692ae02c74631a5647ff24a474c733394a" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;std::atomic_ref&lt;/code&gt; for pointer types</source>
          <target state="translated">포인터 유형에 대한 &lt;code&gt;std::atomic_ref&lt;/code&gt; 전문화</target>
        </trans-unit>
        <trans-unit id="10c93d4df33d89a3d3b9956b10ec16964e8e76ff" translate="yes" xml:space="preserve">
          <source>Specializations of function templates that use return type deduction must use the same return type placeholders.</source>
          <target state="translated">리턴 유형 공제를 사용하는 함수 템플리트의 전문화는 동일한 리턴 유형 플레이스 홀더를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6fc6d385e979957bd666e908f38acd5a72c6379a" translate="yes" xml:space="preserve">
          <source>Specializations of the class template &lt;code&gt;std::fpos&lt;/code&gt; identify absolute positions in a stream or in a file. Each object of type &lt;code&gt;fpos&lt;/code&gt; holds the byte position in the stream (typically as a private member of type &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;) and the current shift state, a value of type &lt;code&gt;State&lt;/code&gt; (typically &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">클래스 템플릿 &lt;code&gt;std::fpos&lt;/code&gt; 의 전문화는 스트림 또는 파일에서 절대 위치를 식별합니다. &lt;code&gt;fpos&lt;/code&gt; 유형의 각 객체는 스트림의 바이트 위치 (일반적으로 &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; 유형의 개인 멤버 )와 현재 시프트 상태, &lt;code&gt;State&lt;/code&gt; 유형 값 (일반적으로 &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; )을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="dcb381e699d0f5d7bab1d45e7515b1ded9af4a69" translate="yes" xml:space="preserve">
          <source>Specialized algorithms</source>
          <target state="translated">전문화 된 알고리즘</target>
        </trans-unit>
        <trans-unit id="c100660f26a9d1f8adf27e8599e6a7912bf7468b" translate="yes" xml:space="preserve">
          <source>Specialized member functions</source>
          <target state="translated">전문화 된 멤버 기능</target>
        </trans-unit>
        <trans-unit id="be5330502c84077d0a164ee3df4702dd3df1710f" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; &amp;lt;bool&amp;gt;에 대해 &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 를 전문화합니다.</target>
        </trans-unit>
        <trans-unit id="929faefa4be755f2446f61c5b58a7a6bf54b5e98" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 대해 &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 를 전문화합니다</target>
        </trans-unit>
        <trans-unit id="92884ecc4dc1ad9f0b6ada755479b29b96b1923c" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 전문화</target>
        </trans-unit>
        <trans-unit id="24c368abf6dc5ee77bbd5a19b5d872d8c1b483c8" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::u16string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::u32string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::wstring&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::u16string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::u32string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::wstring&lt;/a&gt;&lt;/code&gt; 대해 &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 를 전문화합니다.</target>
        </trans-unit>
        <trans-unit id="1edf31ebee30072fed71727277770c7e7c4dd605" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../thread/thread/id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../thread/thread/id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; 대해 &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 를 전문화합니다.</target>
        </trans-unit>
        <trans-unit id="0ad1e738230665a0185ea33fbf613ac5e62f5c47" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; 대해 &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 를 전문화합니다</target>
        </trans-unit>
        <trans-unit id="d1ce044002508eef713f870c694c01793be9dab2" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; 대해 &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 를 전문화합니다</target>
        </trans-unit>
        <trans-unit id="10203904019075a8eaa7d7a2cf3d7d0f3719dbe4" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a374bafcebddec1398aa41e1afd2fd5ce478d640" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 상태 를 &lt;code&gt;rhs&lt;/code&gt; 상태와 교환합니다 . 효과적으로 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="14fd4179daf4c10d5aca433c91fb556e4214b53b" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 상태 를 &lt;code&gt;rhs&lt;/code&gt; 상태와 교환합니다 . 효과적으로 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6c980d649f1c3fd00981e147ecf386dbdc2a6a3e" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 상태 를 &lt;code&gt;rhs&lt;/code&gt; 상태와 교환합니다 . 효과적으로 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f09853eb90e71e2ecdcbc85d2086b5e9df32a0b5" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 상태 를 &lt;code&gt;rhs&lt;/code&gt; 상태와 교환합니다 . 효과적으로 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="144a7d7a089e07620f9fa29a59e74050d09800b3" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 상태 를 &lt;code&gt;rhs&lt;/code&gt; 상태와 교환합니다 . 효과적으로 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3d276b1eee4a17a3edc097fb2a067fce5bc607db" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Equivalent to &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="11e5d4812028e7a563bd32972648c719eb6f83a0" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 상태 를 &lt;code&gt;rhs&lt;/code&gt; 상태와 교환합니다 . 효과적으로 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b38379cc0d135eb904af1e44b19ca4a4a225d92c" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3425e599adf74f2b78d5db4942f7824d31bb0cea" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="16ec64ededba9da81e174ff8ce23dac9e2f45778" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="68611ad0297c8b865b1e69bf87f9494a059b776e" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fcbfdb7046d6b717fd839db9eb8989c022e7861d" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt;. Exchanges the contents of &lt;code&gt;x1&lt;/code&gt; with those of &lt;code&gt;x2&lt;/code&gt;. Effectively calls &lt;code&gt;x1.swap(x2)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . 교류의 내용 &lt;code&gt;x1&lt;/code&gt; 의 사람들과 &lt;code&gt;x2&lt;/code&gt; . &lt;code&gt;x1.swap(x2)&lt;/code&gt; 효과적으로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="348e920b666cb2b95dfb021675885057cfedbfa5" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a66cdab60bbc874750a1df6ce467f9bf1858001d" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ae0a18b802f0a1c4ce8ee99c449a083dabdc8bee" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 전문화 &lt;code&gt;&lt;a href=&quot;../packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; 대한 알고리즘을 . &lt;code&gt;lhs&lt;/code&gt; 상태 를 &lt;code&gt;rhs&lt;/code&gt; 상태와 교환합니다 . 효과적으로 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4b01140469becbcad3df73849ca87a41d0e904b5" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다. &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d0ca2b58e0a53194c4a1dc67a48572272d61d66f" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;. Exchanges the shared state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;lhs&lt;/code&gt; 공유 상태를 &lt;code&gt;rhs&lt;/code&gt; 공유 상태와 교환합니다. 효과적으로 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4dc613f89602630345443f1c0041e1fabdefa79d" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../queue&quot;&gt;std::queue&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 &lt;code&gt;&lt;a href=&quot;../queue&quot;&gt;std::queue&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다. &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4b0c41f14ec24dff0b21fa6fe23b1d7d8f579137" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 &lt;code&gt;&lt;a href=&quot;../set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다. &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="16678edb55e165fd3aac9bc1f30b29146586e4a2" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 &lt;code&gt;&lt;a href=&quot;../shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;lhs&lt;/code&gt; 상태를 &lt;code&gt;rhs&lt;/code&gt; 상태와 교환합니다. 효과적으로 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="6b09f2e1442d1482454c8d40093f682389f57dfa" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. Swaps the pointers of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 포인터를 바꿉니다. &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c702d5c420dc39e28437791aec8f6f4e42699182" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../stack&quot;&gt;std::stack&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../stack&quot;&gt;std::stack&lt;/a&gt;&lt;/code&gt; 대한 std :: &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2ce2db2f2cdd5c943018c47e72511be6601b08af" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; 대한 std :: &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 상태 를 &lt;code&gt;rhs&lt;/code&gt; 상태와 교환합니다 . 효과적으로 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7c3d9c626acc7ec9ede7b418ff9991a65bf9ef4a" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;. Swaps the pointers of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 대한 std :: &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 포인터를 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1d8e50681a06d76bec134dd34f752390f238bfdb" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . 내용을 교환 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="53efb070e9c5b714af093163836a104b272133f1" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . 내용을 교환 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e76cd152ab11af0238bc62fc1e18423ba39b562a" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . 내용을 교환 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e51a278bf9c5106974b28e471705f51023452d39" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="17706eccbf62ab82782b8202ae83243d762b0bc9" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="762ba2bac666c73f3f396229a66d00033365c9d3" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2371af2f2d7914c984098900b4eed95ae1383bbc" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;. Swaps the pointers of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 . &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 포인터를 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="84fd25a7b30671a6417f94003de811a3e983ac78" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;std::monostate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::monostate&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 알고리즘을 전문화합니다 .</target>
        </trans-unit>
        <trans-unit id="efef95e91be1d84c2538bd2f5d8be0bfb5e24588" translate="yes" xml:space="preserve">
          <source>Specific error categories</source>
          <target state="translated">특정 오류 범주</target>
        </trans-unit>
        <trans-unit id="95c59c79b4cdd1fc7b8e82868c219069dbfbbe1c" translate="yes" xml:space="preserve">
          <source>Specifically,</source>
          <target state="translated">Specifically,</target>
        </trans-unit>
        <trans-unit id="602bc4c034950f0ade4842b450786dbf7326e87f" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;&lt;a href=&quot;convertibleto&quot;&gt;ConvertibleTo&lt;/a&gt;&amp;lt;From, To&amp;gt;&lt;/code&gt; is satisfied only if, given a function &lt;code&gt;fun&lt;/code&gt; of type &lt;code&gt;From ()&lt;/code&gt; such that the expression &lt;code&gt;fun()&lt;/code&gt; is equality-preserving (see below),</source>
          <target state="translated">특히 &lt;code&gt;&lt;a href=&quot;convertibleto&quot;&gt;ConvertibleTo&lt;/a&gt;&amp;lt;From, To&amp;gt;&lt;/code&gt; 는 유형 의 함수 &lt;code&gt;fun&lt;/code&gt; 가 주어진 경우에만 만족됩니다. &lt;code&gt;From ()&lt;/code&gt; 되도록 발현 &lt;code&gt;fun()&lt;/code&gt; 인 항등 보존 (아래 참조),</target>
        </trans-unit>
        <trans-unit id="db78dbdb71aaa90916530b98b58ced9ba6564cdc" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;std::reference_wrapper&lt;/code&gt; is a &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; wrapper around a reference to object or reference to function of type &lt;code&gt;T&lt;/code&gt;. Instances of &lt;code&gt;std::reference_wrapper&lt;/code&gt; are objects (they can be copied or stored in containers) but they are implicitly convertible to &lt;code&gt;T&amp;amp;&lt;/code&gt;, so that they can be used as arguments with the functions that take the underlying type by reference.</source>
          <target state="translated">특히 &lt;code&gt;std::reference_wrapper&lt;/code&gt; 는 객체 참조 또는 &lt;code&gt;T&lt;/code&gt; 유형의 함수 참조 에 대한 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 래퍼 입니다. &lt;code&gt;std::reference_wrapper&lt;/code&gt; 인스턴스 는 객체 (컨테이너에 복사 또는 저장 될 수 있음)이지만 암시 적으로 &lt;code&gt;T&amp;amp;&lt;/code&gt; 로 변환 가능 하므로 기본 유형을 참조로 사용하는 함수를 가진 인수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1df412f45187c35d9893c7c5b5cd27a2f6d6a112" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;std::rotate&lt;/code&gt; swaps the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in such a way that the element &lt;code&gt;n_first&lt;/code&gt; becomes the first element of the new range and &lt;code&gt;n_first - 1&lt;/code&gt; becomes the last element.</source>
          <target state="translated">특히 &lt;code&gt;std::rotate&lt;/code&gt; 는 &lt;code&gt;[first, last)&lt;/code&gt; 범위 의 요소를 요소가 &lt;code&gt;n_first&lt;/code&gt; 요소가 새 범위의 첫 번째 요소가되고 &lt;code&gt;n_first - 1&lt;/code&gt; 이 마지막 요소가 교체 합니다 .</target>
        </trans-unit>
        <trans-unit id="f84f5f4badf21edc006628f5798445653f43f512" translate="yes" xml:space="preserve">
          <source>Specifically, first &lt;code&gt;P&lt;/code&gt; is converted to disjunctive normal form and &lt;code&gt;Q&lt;/code&gt; is converted to conjunctive normal form. &lt;code&gt;P&lt;/code&gt; subsumes &lt;code&gt;Q&lt;/code&gt; if and only if:</source>
          <target state="translated">구체적으로, 제 1 &lt;code&gt;P&lt;/code&gt; 는 결막 정규형으로 변환 되고 &lt;code&gt;Q&lt;/code&gt; 는 결막 정규형으로 변환된다. &lt;code&gt;P&lt;/code&gt; 포섭 &lt;code&gt;Q&lt;/code&gt; 경우에만,이 :</target>
        </trans-unit>
        <trans-unit id="5cba85f77aa7430cfee47126ca01127a3952aa86" translate="yes" xml:space="preserve">
          <source>Specifically, partial ordering takes place in the following situations:</source>
          <target state="translated">특히, 부분적 순서는 다음 상황에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9a4be71b2931c171b2d4e3c19119a4720e801cc3" translate="yes" xml:space="preserve">
          <source>Specifically, these functions return.</source>
          <target state="translated">특히이 함수는 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="675adfe3476229cd237b4d2fd189146d41be73b2" translate="yes" xml:space="preserve">
          <source>Specifiers</source>
          <target state="translated">Specifiers</target>
        </trans-unit>
        <trans-unit id="a1caa2edff634e8bec98acd995f893dc449a0d6e" translate="yes" xml:space="preserve">
          <source>Specifies available file open flags. It is a &lt;a href=&quot;../../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;, the following constants are defined:</source>
          <target state="translated">사용 가능한 파일 열기 플래그를 지정합니다. 그것은이다 &lt;a href=&quot;../../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; , 다음 상수가 정의되었다 :</target>
        </trans-unit>
        <trans-unit id="2850fef006b6b944b6497794aaefb91b462abe2d" translate="yes" xml:space="preserve">
          <source>Specifies available formatting flags. It is a &lt;a href=&quot;../../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;. The following constants are defined:</source>
          <target state="translated">사용 가능한 형식 플래그를 지정합니다. 그것은이다 &lt;a href=&quot;../../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; . 다음 상수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="cb779dd079a8d3e459e51752dd5d4816b0f83b35" translate="yes" xml:space="preserve">
          <source>Specifies file seeking direction type. The following constants are defined:</source>
          <target state="translated">파일 탐색 방향 유형을 지정합니다. 다음 상수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3499f44ebeefc016594ac5c37f09b8d9129d27da" translate="yes" xml:space="preserve">
          <source>Specifies preconditions, postconditions, and assertions for functions.</source>
          <target state="translated">함수에 대한 사전 조건, 사후 조건 및 어설 션을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2143bad35d1f2fbbd47539662a7a179dc7bf47ab" translate="yes" xml:space="preserve">
          <source>Specifies state of a future as returned by &lt;code&gt;wait_for&lt;/code&gt; and &lt;code&gt;wait_until&lt;/code&gt; functions of &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; &lt;code&gt;wait_until&lt;/code&gt; &lt;code&gt;wait_for&lt;/code&gt; 및 wait_until 함수가 리턴 한 미래 상태를 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="da11e8ee385feb14fbf004b5f791712dc0780517" translate="yes" xml:space="preserve">
          <source>Specifies stream state flags. It is a &lt;a href=&quot;../../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;, the following constants are defined:</source>
          <target state="translated">스트림 상태 플래그를 지정합니다. 그것은됩니다 &lt;a href=&quot;../../named_req/bitmasktype&quot;&gt;BitmaskType은&lt;/a&gt; , 다음 상수가 정의되었다 :</target>
        </trans-unit>
        <trans-unit id="71f6b5a60b0b269826814ffa140e352effb52a5e" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc&lt;/a&gt;&lt;/code&gt; is an error condition enum. This enables implicit conversion to &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc&lt;/a&gt;&lt;/code&gt; 가 오류 조건 열거 임을 지정합니다 . 이를 통해 &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 암시 적으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40209fd8a369aa7fc6403e72f4b4716656d7082e" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; is an error code enum. This enables &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; 가 오류 코드 열거 임을 지정합니다 . 이것은 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 활성화합니다 자동 변환을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="412fe6ca3230fdc26500228eca990cd8bb20c0fb" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;^&lt;/code&gt; shall match the beginning of a line and &lt;code&gt;$&lt;/code&gt; shall match the end of a line, if the ECMAScript engine is selected.</source>
          <target state="translated">ECMAScript 엔진이 선택된 경우 &lt;code&gt;^&lt;/code&gt; 는 행의 시작과 일치하고 &lt;code&gt;$&lt;/code&gt; 는 행 의 끝 과 일치하도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="ce22337568229feaeef44935c6a25aeef4047a6f" translate="yes" xml:space="preserve">
          <source>Specifies that a &lt;a href=&quot;virtual&quot;&gt;virtual function&lt;/a&gt; cannot be overridden in a derived class or that a class cannot be &lt;a href=&quot;derived_class&quot;&gt;inherited from&lt;/a&gt;.</source>
          <target state="translated">&amp;bull; 그래도 지정 &lt;a href=&quot;virtual&quot;&gt;가상 함수는&lt;/a&gt; 클래스 파생 클래스에서 또는 재정의 할 수 없습니다가 될 수 없습니다 &lt;a href=&quot;derived_class&quot;&gt;로부터 상속&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6652410dc292c5007f2fda79d6e08c4ff46aed4" translate="yes" xml:space="preserve">
          <source>Specifies that a &lt;a href=&quot;virtual&quot;&gt;virtual function&lt;/a&gt; overrides another virtual function.</source>
          <target state="translated">&lt;a href=&quot;virtual&quot;&gt;가상 기능이&lt;/a&gt; 다른 가상 기능을 대체 하도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="58a189457ac13432965bf5e933104b789fcc04df" translate="yes" xml:space="preserve">
          <source>Specifies that a type is &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;standard layout type&lt;/a&gt;. Standard layout types are useful for communicating with code written in other programming languages.</source>
          <target state="translated">유형이 &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;표준 레이아웃 유형&lt;/a&gt; 임을 지정합니다 . 표준 레이아웃 유형은 다른 프로그래밍 언어로 작성된 코드와 통신하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="97f2db1cf7b23349d1adeebe865a180e6747d323" translate="yes" xml:space="preserve">
          <source>Specifies that a type is a</source>
          <target state="translated">유형이</target>
        </trans-unit>
        <trans-unit id="e2ab2c1f43001817230ea7b5da552514bf9545e0" translate="yes" xml:space="preserve">
          <source>Specifies that a type is a trivial type.</source>
          <target state="translated">유형이 사소한 유형임을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2e72390ff2950300b0856757bee126466769677f" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be assigned from an &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; argument.</source>
          <target state="translated">유형의 인스턴스가 &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; 인수 에서 지정 될 수 있도록 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="ca72e6c27c36bc11e82dd994ddb760bc39ee3df1" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be constructed from an &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; argument.</source>
          <target state="translated">유형의 인스턴스가 &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; 인수 로 구성 될 수 있도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="fada4cd707b398cb1a5f86f68cfc3038b346c42e" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be copy-assigned from an &lt;a href=&quot;../language/value_category&quot;&gt;lvalue expression&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../language/value_category&quot;&gt;lvalue expression&lt;/a&gt; 에서 유형의 인스턴스를 복사 할 수 있도록 지정 합니다 .</target>
        </trans-unit>
        <trans-unit id="dd59f96e22ded7e4286f96c96495f1e28b8bb0ff" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be copy-constructed from an &lt;a href=&quot;../language/value_category&quot;&gt;lvalue expression&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../language/value_category&quot;&gt;lvalue expression&lt;/a&gt; 에서 유형의 인스턴스를 복사 구성 할 수 있도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="8ac12f39fb79216f7e1a02d97e0b63af88a4643a" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be copy-constructed in-place by a given allocator.</source>
          <target state="translated">지정된 할당자가 해당 유형의 인스턴스를 제자리에 복사 할 수 있도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="03fae4eb0c4ad42c583a672e2e545d274ab592b7" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be default constructed.</source>
          <target state="translated">유형의 인스턴스가 기본적으로 구성 될 수 있도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b23f9e379358b39515cc638465e5eef9c060039a" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be default-constructed in-place by a given allocator.</source>
          <target state="translated">지정된 할당자가 해당 유형의 인스턴스를 기본 구성 위치로 지정할 수 있도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="50aa7b3d1e4fcbdf2207bccb8a04a767175e6369" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be destructed.</source>
          <target state="translated">유형의 인스턴스가 제거 될 수 있도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3d47e9869a2643d9f79cb28f6a04ee15b388eb74" translate="yes" xml:space="preserve">
          <source>Specifies that an object of the type can be constructed from a given set of arguments in uninitialized storage by a given allocator.</source>
          <target state="translated">지정된 할당 자에 의해 초기화되지 않은 스토리지의 지정된 인수 세트에서 유형의 오브젝트를 구성 할 수 있도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7f0f9886e068ff9ff576b4c801087069812b4ba9" translate="yes" xml:space="preserve">
          <source>Specifies that an object of the type can be constructed into uninitialized storage from an rvalue of that type by a given allocator.</source>
          <target state="translated">지정된 할당자가 해당 유형의 rvalue에서 유형의 오브젝트를 초기화되지 않은 스토리지로 구성 할 수 있도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="70d20b70339dff5e1ba087d45352207cfaace310" translate="yes" xml:space="preserve">
          <source>Specifies that an object of the type can be destroyed by a given &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; 가 타입의 객체를 파기 할 수 있도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="27c439236dbcdd96b8d9abb6b7e6d97a9cfc0caa" translate="yes" xml:space="preserve">
          <source>Specifies that the type can be used as the template argument of &lt;code&gt;&lt;a href=&quot;../numeric/valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유형을 &lt;code&gt;&lt;a href=&quot;../numeric/valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 의 템플리트 인수로 사용할 수 있도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="baa189d189bb2fc05ffc4c0f6cb568c1117f8841" translate="yes" xml:space="preserve">
          <source>Specifies that the type is POD (Plain Old Data) type. This means the type is compatible with the types used in the C programming language, that is, can be exchanged with C libraries directly, in its binary form.</source>
          <target state="translated">유형이 POD (Plain Old Data) 유형임을 지정합니다. 이는 타입이 C 프로그래밍 언어에서 사용되는 타입과 호환 가능함을 의미합니다. 즉, 이진 형식으로 C 라이브러리와 직접 교환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aae228780e11235e1b16e156a121c9f3fdc04a2" translate="yes" xml:space="preserve">
          <source>Specifies that the type is a pointer-like object which can be compared to &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; objects.</source>
          <target state="translated">유형이 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 객체 와 비교할 수있는 포인터와 유사한 객체 임을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="3541d77f9d2355ee7b5c6624cc3612f9b80fd905" translate="yes" xml:space="preserve">
          <source>Specifies the &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirement&lt;/a&gt; of a type or an object.</source>
          <target state="translated">유형 또는 객체 의 &lt;a href=&quot;objects#Alignment&quot;&gt;정렬 요구 사항&lt;/a&gt; 을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="b77403e83293931543e74e71906ebdf304265e72" translate="yes" xml:space="preserve">
          <source>Specifies the current rounding direction of floating-point arithmetic operations.</source>
          <target state="translated">부동 소수점 산술 연산의 현재 반올림 방향을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7d379181a80eaa4855639c972b4a9c64ce8af284" translate="yes" xml:space="preserve">
          <source>Specifies the event type which is passed to functions registered by &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; on specific events. The following constants are defined:</source>
          <target state="translated">특정 이벤트에서 &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; 에 의해 등록 된 함수에 전달되는 이벤트 유형을 지정 합니다. 다음 상수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="fca0d9d3165620a22e1ca17eeba63839f6f29489" translate="yes" xml:space="preserve">
          <source>Specifies the launch policy for a task executed by the &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; function. &lt;code&gt;std::launch&lt;/code&gt; is an enumeration used as &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; 함수가 실행하는 태스크의 시작 정책을 지정합니다 . &lt;code&gt;std::launch&lt;/code&gt; 는 &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType으로&lt;/a&gt; 사용되는 열거 입니다.</target>
        </trans-unit>
        <trans-unit id="48b0001fd2a02fb0f468013a53302aefe8836854" translate="yes" xml:space="preserve">
          <source>Specifies the precision in which all floating-point arithmetic operations other than assignment and cast are done.</source>
          <target state="translated">대입 및 캐스트 이외의 모든 부동 소수점 산술 연산이 수행되는 정밀도를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f50baf895b35222407d8333cfba86a5891605e65" translate="yes" xml:space="preserve">
          <source>Specifies whether a function could throw exceptions.</source>
          <target state="translated">함수가 예외를 던질 수 있는지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2b26298b40d0f4780093d39d638a913d5430e82b" translate="yes" xml:space="preserve">
          <source>Splicing maps and sets (&lt;code&gt;&lt;a href=&quot;container/map/extract&quot;&gt;std::map::extract&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/map/merge&quot;&gt;std::map::merge&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;container/map/insert&quot;&gt;&lt;code&gt;std::map::insert(node_type)&lt;/code&gt;&lt;/a&gt;, etc)</source>
          <target state="translated">스 플라이 싱 맵 및 세트 ( &lt;code&gt;&lt;a href=&quot;container/map/extract&quot;&gt;std::map::extract&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/map/merge&quot;&gt;std::map::merge&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;container/map/insert&quot;&gt; &lt;code&gt;std::map::insert(node_type)&lt;/code&gt; &lt;/a&gt; 등)</target>
        </trans-unit>
        <trans-unit id="d128c542a0977a832c33da77100282c39f685850" translate="yes" xml:space="preserve">
          <source>Stack is not unwound: destructors of variables with automatic &lt;a href=&quot;../../language/storage_duration&quot;&gt; storage duration&lt;/a&gt; are not called.</source>
          <target state="translated">스택이 풀리지 않음 : 자동 &lt;a href=&quot;../../language/storage_duration&quot;&gt;저장 기간&lt;/a&gt; 이있는 변수의 소멸자가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4567779bd1675996144b2748fafeb695d8826f97" translate="yes" xml:space="preserve">
          <source>Stack unwinding</source>
          <target state="translated">풀기 스택</target>
        </trans-unit>
        <trans-unit id="7734fcdf94be5e3e0e62cbe34bf10da82bd57664" translate="yes" xml:space="preserve">
          <source>Stage 1: conversion specifier selection</source>
          <target state="translated">1 단계 : 변환 지정자 선택</target>
        </trans-unit>
        <trans-unit id="f229abe33b912ba3dfcb35234eca7eda55ea2436" translate="yes" xml:space="preserve">
          <source>Stage 2: character extraction</source>
          <target state="translated">2 단계 : 캐릭터 추출</target>
        </trans-unit>
        <trans-unit id="f1af41900429ff41a2249450493e1008b35eef80" translate="yes" xml:space="preserve">
          <source>Stage 2: locale-specific conversion</source>
          <target state="translated">2 단계 : 로캘 별 변환</target>
        </trans-unit>
        <trans-unit id="32f4145279ebf203d787e38ce057d611157577de" translate="yes" xml:space="preserve">
          <source>Stage 3: conversion and storage</source>
          <target state="translated">3 단계 : 변환 및 저장</target>
        </trans-unit>
        <trans-unit id="a4131d11d9a0e8c35b6c408e01ffdce46ef839c7" translate="yes" xml:space="preserve">
          <source>Stage 3: padding</source>
          <target state="translated">3 단계 : 패딩</target>
        </trans-unit>
        <trans-unit id="f99aab4a8642dbb54c9c31ed3e6c1b7e1ea21d61" translate="yes" xml:space="preserve">
          <source>Stage 4: output</source>
          <target state="translated">4 단계 : 출력</target>
        </trans-unit>
        <trans-unit id="2dfa66079d9b7229409430972fd5f1567d78a3b6" translate="yes" xml:space="preserve">
          <source>Standard</source>
          <target state="translated">Standard</target>
        </trans-unit>
        <trans-unit id="4f8403e30afda69e5d85ce78b52a98f57c10276f" translate="yes" xml:space="preserve">
          <source>Standard algorithms such as &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; and containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; expect &lt;code&gt;operator&amp;lt;&lt;/code&gt; to be defined, by default, for the user-provided types, and expect it to implement strict weak ordering (thus satisfying the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements). An idiomatic way to implement strict weak ordering for a structure is to use lexicographical comparison provided by &lt;code&gt;&lt;a href=&quot;../utility/tuple/tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">같은 표준 알고리즘 &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; 와 같은 용기 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; 기대 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 사용자가 제공 한 유형에 대해 기본적으로 정의하고 (따라서 만족 엄격한 약한 순서를 구현하기 위해 기대되는 &lt;a href=&quot;../named_req/compare&quot;&gt;비교&lt;/a&gt; 요구 사항을). 구조에 대해 엄격한 약한 순서를 구현하는 관용적 방법은 &lt;code&gt;&lt;a href=&quot;../utility/tuple/tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt; 제공하는 사전 비교를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="5328552aac39954649b5d41d7c9d3dceb11e3086" translate="yes" xml:space="preserve">
          <source>Standard approach to preventing multiple inclusion of the same header is by using &lt;a href=&quot;https://en.wikipedia.org/wiki/Include_guard&quot;&gt;include guards&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a6dcfa27a50519251182ae7d40e7305827e30f" translate="yes" xml:space="preserve">
          <source>Standard attributes</source>
          <target state="translated">표준 속성</target>
        </trans-unit>
        <trans-unit id="71d764f76d4965fc86057a5939b4a260bac04aff" translate="yes" xml:space="preserve">
          <source>Standard exception objects</source>
          <target state="translated">표준 예외 객체</target>
        </trans-unit>
        <trans-unit id="4699acdfb53b46562b7b56c7205e17320756dba8" translate="yes" xml:space="preserve">
          <source>Standard layout</source>
          <target state="translated">표준 레이아웃</target>
        </trans-unit>
        <trans-unit id="24cdc73cf5d5cd6b52d459b131965c7490f35646" translate="yes" xml:space="preserve">
          <source>Standard layout types have the following special properties:</source>
          <target state="translated">표준 레이아웃 유형에는 다음과 같은 특수 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="360c57caedbd1d1ff38dde144677c893d6ad3792" translate="yes" xml:space="preserve">
          <source>Standard library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b65c784c24e64adb5fb181fab92370d4eb9c22" translate="yes" xml:space="preserve">
          <source>Standard library concepts</source>
          <target state="translated">표준 라이브러리 개념</target>
        </trans-unit>
        <trans-unit id="30310cff7697d93c13896a3a67af260d5ac15abe" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;algorithm&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;알고리즘&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5344d1cec2faadaebd419c796e19f8c028b4dc6c" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;any&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;any&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c9625d8b6cb5d990c798ad2022e9bdd3dc5447d1" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;array&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;배열&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a530bd05fce769575e24496fcfdd72538bb4d119" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;atomic&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;원자&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f10a243ee71eb95d0ac0c027199b1c5806f1c4b5" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;bit&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;비트&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3db9347fa205973e43295f2a661f44267dfdb525" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;bitset&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;비트 세트&amp;gt;</target>
        </trans-unit>
        <trans-unit id="aa3dbcd5aa2ae89b3545f3ea6c49ddc3c5666f8c" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cassert&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cassert&amp;gt;</target>
        </trans-unit>
        <trans-unit id="df3cee2bf7a87d57f1feab1408c95b1ec3e6bffd" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ccomplex&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;ccomplex&amp;gt;</target>
        </trans-unit>
        <trans-unit id="08d91eea93243071941079aeece2a92fb3bfe82c" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cctype&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cctype&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c331f5c576ec7ee184ffeabece835d0638a5381d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cerrno&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cerrno&amp;gt;</target>
        </trans-unit>
        <trans-unit id="830e9e4da6bf32e8dfee8a84aac3326ded51b59b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cfenv&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cfenv&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ad562de008a9052d500945091f82459b8008e4b2" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cfloat&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cfloat&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d546c38369695420f59e87bf6a807dfe86de89e7" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;charconv&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;charconv&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f756f3f41db8d5458a4516da178bff0063c084a8" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;chrono&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;chrono&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e916a895ce400df95c2636c67692899fd43470cd" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cinttypes&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cinttypes&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6597f1b7afbc44e2063e8ac6c6d9660786f3b9c5" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ciso646&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;ciso646&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d666b426218283af2a00e6c438e0180e8a245379" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;climits&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;climits&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1631ea3f206efa9ef405b40cdbc5a15718f6515a" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;clocale&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;clocale&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92713620a0b61bdd61d2d29e019839c9f2901a7d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cmath&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cmath&amp;gt;</target>
        </trans-unit>
        <trans-unit id="906f1f5f3a4714d9c3d8e2754c1217c810037ed5" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;codecvt&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;codecvt&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9c276a1d54c8cb82e3e38bf0b647dae253b3bfe8" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;compare&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;비교&amp;gt;</target>
        </trans-unit>
        <trans-unit id="aa1c30a31bd0f54b89b18d77ca14ad7cdbc8ee08" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;complex&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;복잡한&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b0369b803a0638ae66301a82f5a513d5664dd188" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;concepts&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;개념&amp;gt;</target>
        </trans-unit>
        <trans-unit id="233e3073fb8f89c94465d27d51856227467c314f" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;condition_variable&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;condition_variable&amp;gt;</target>
        </trans-unit>
        <trans-unit id="351a759a265e3e8e556c5d972856fb61ba8bdc8b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;contract&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;계약&amp;gt;</target>
        </trans-unit>
        <trans-unit id="43eaa00ef27cc10c810d1383719652104d09d428" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;csetjmp&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;csetjmp&amp;gt;</target>
        </trans-unit>
        <trans-unit id="12033a038a7443be07e73859625c633d9bfdff93" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;csignal&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;csignal&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ec12d91f53956a9a0af121e45d4189f320f61565" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdalign&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cstdalign&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ea6a5851554b8ff8e984144b36d2d1c13bea0008" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdarg&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cstdarg&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3f80662ebf89f08df7d8af0e8e6a2176995d6f27" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdbool&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cstdbool&amp;gt;</target>
        </trans-unit>
        <trans-unit id="079d44f3fc59b40b54b5f8acafa551a74edc2e22" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstddef&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cstddef&amp;gt;</target>
        </trans-unit>
        <trans-unit id="63e3266e930172336eb078485a75b8919264ca78" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdint&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cstdint&amp;gt;</target>
        </trans-unit>
        <trans-unit id="11d5cb8c021822da90fafef999077828ad8ab5a7" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdio&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cstdio&amp;gt;</target>
        </trans-unit>
        <trans-unit id="577206f7a97d3603251f05ecf1edf20e6acf0962" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdlib&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cstdlib&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1a90b5389499364b47d1a36742b91c24b0310d26" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstring&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cstring&amp;gt;</target>
        </trans-unit>
        <trans-unit id="299970c7900bda638ac85a38e14969c15293ee41" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ctgmath&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;ctgmath&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ff6fbcd4e55e5c106b2c07aa666868d9a3dfb1db" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ctime&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;ctime&amp;gt;</target>
        </trans-unit>
        <trans-unit id="48a271bfc9dada552cf9be719f164a3fd49ea12d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cuchar&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cuchar&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2f9df7f6c4488b01abfd0e614a3f1e92e9212b2b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cwchar&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cwchar&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c01c30d663c313a1e2a4b054a60a033f651b189b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cwctype&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;cwctype&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f4629e786fd7addb2685516f54f1e8ce49e41b1c" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;deque&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;deque&amp;gt;</target>
        </trans-unit>
        <trans-unit id="60e438e3415d1f8cbdf62bee12e375ef78c1f51d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;exception&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;예외&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6ba10e4b6a68932b7c60073bb46b3f5aed140231" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;execution&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;실행&amp;gt;</target>
        </trans-unit>
        <trans-unit id="faefee713db48bf27967466e82c31d0610246f30" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;filesystem&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;파일 시스템&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1d875954e0a2ef650c43a6671a35a6dbc76f36db" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;forward_list&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;forward_list&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ac325916c78f0414563b9a70f6eb5b7a57c42025" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;fstream&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;fstream&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f7b68d46c5e7472cabb6595bb9ce1d93b67ba991" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;functional&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;기능적&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d96aaf61f1d6e7f54dd7956941708c503c0be452" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;future&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;미래&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a00067ade34a10bd1a45c15e2e0ef910df4114d2" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;initializer_list&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;initializer_list&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a91d48c0f4a86cd2f4d47246198afd343d656523" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;iomanip&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;iomanip&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bc322e45cd1fed81b3bab917180b6baf54106d5b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ios&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;ios&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cf0dd7c7b613409eda7d05ab59a1390748609d4d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;iosfwd&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;iosfwd&amp;gt;</target>
        </trans-unit>
        <trans-unit id="32094c5a92210cb3de27616406d1b148df67a476" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;iostream&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;iostream&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b908fd7d41deb24ead7593991fb25cf90f6502a9" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;istream&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;istream&amp;gt;</target>
        </trans-unit>
        <trans-unit id="399fcfa6fe77d3965437ae6534d0e2a7a9bc1026" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;iterator&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;반복자&amp;gt;</target>
        </trans-unit>
        <trans-unit id="96367d7ad1f1162a7e8b08e3a07859319a2699fa" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;limits&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;limits&amp;gt;</target>
        </trans-unit>
        <trans-unit id="724dedb2749e1d51c8dc5d7fbe651bbca2f5fa73" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;list&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;목록&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2b992a0581c637592ab75f131008e805ea39ebca" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;locale&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;locale&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d7054a59522cc13caf893f31a9f9cad637811cec" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;map&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;map&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f45cf910d7be8b33b2c672801cf7d3369acdf3d3" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;memory&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;메모리&amp;gt;</target>
        </trans-unit>
        <trans-unit id="719d1944cc64a805fb7c6ce11306559e6f26a70f" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;memory_resource&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;memory_resource&amp;gt;</target>
        </trans-unit>
        <trans-unit id="905738ae8c67056cdb44f49cd4526170f8dc668f" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;mutex&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;mutex&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3868c3bf80a77fad928a4182e9475d99185f519e" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;new&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;신규&amp;gt;</target>
        </trans-unit>
        <trans-unit id="927c3b2f40db408bdeb32453b1c2c882400a9e67" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;numeric&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;숫자&amp;gt;</target>
        </trans-unit>
        <trans-unit id="03d0b5be06821d285dfcef64f0faaf8b939037c5" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;optional&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;선택 사항&amp;gt;</target>
        </trans-unit>
        <trans-unit id="25440f88b2737d09c41a26279353c4381e83dd15" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ostream&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;ostream&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c4b011ab900fefd40ff0629146651abfc03db5fb" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;queue&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;큐&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4c6d9f52d447ecd9024e3ca364c76ecb28adc8ba" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;random&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;무작위&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6eb3b8e90d58778b73b7097c2a4ad368ba35093b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ranges&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;범위&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cd292d1c47c7882b2cf07a12511af1ff4ef92afe" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ratio&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;비율&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5d31d2b6b6a47547e02d0b141ea0800237510092" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;regex&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;regex&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eb47001f264dcc1c680176fb2843fa65dbb6ecb6" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;scoped_allocator&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;scoped_allocator&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d8f139b7202096f839805ef1e717c3e2bb313603" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;set&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;set&amp;gt;</target>
        </trans-unit>
        <trans-unit id="40e6565c7672a21b3d9bc0d6f36b31b6ea208c94" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;shared_mutex&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;shared_mutex&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8015c2c01a1ae801b223f37fac713ab5b7537d09" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;span&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;span&amp;gt;</target>
        </trans-unit>
        <trans-unit id="111a2709c0e03fd25e235fce2df43647ac8b4ddc" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;sstream&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;sstream&amp;gt;</target>
        </trans-unit>
        <trans-unit id="00ce51fe4c6946cc68da2bccc13751e6d3cff9a2" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;stack&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;스택&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e263b215d26df4051400712c1d1de85fe0e78519" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;stdexcept&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;stdexcept&amp;gt;</target>
        </trans-unit>
        <trans-unit id="82fa68079e46872ba6371e43ee90f4c324eeed1f" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;streambuf&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;streambuf&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8802568376c0ff3f8ebe2167589ad64374bffc42" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;string&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;문자열&amp;gt;</target>
        </trans-unit>
        <trans-unit id="16e8da8e6bf9aa0ee9b3bb707adae835fa5ba169" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;string_view&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;string_view&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9041d59548ad1a70e69dc40c13beb14f42758389" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;strstream&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;strstream&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7b78926579795f08a3525c13e9088a103cc9745d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;syncstream&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;syncstream&amp;gt;</target>
        </trans-unit>
        <trans-unit id="05dd2bbc57d39045b9c15efa3feb0a2d5d844556" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;system_error&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;system_error&amp;gt;</target>
        </trans-unit>
        <trans-unit id="75920c437b550c3b1db353e1208e7d540dfb2bf0" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;thread&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;스레드&amp;gt;</target>
        </trans-unit>
        <trans-unit id="86d8f634b2e8d69b06effca9680a02ca8aa34506" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;tuple&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;tuple&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ccd913703c6d50f2e44b16e9b267aabab9c224e1" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;type_traits&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;type_traits&amp;gt;</target>
        </trans-unit>
        <trans-unit id="56e7fbf2767165dddaca2e7ba21050eeb330c81d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;typeindex&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;typeindex&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2772bbfb508fb75267220342312055d9d30838d1" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;typeinfo&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;typeinfo&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7030b6512b57104f0b8d85ba95160e019cfe54a3" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;unordered_map&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;unorder_map&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b18e2c06223adba975bd8ec9c619568c802d1fa0" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;unordered_set&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;unorder_set&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ab8030be3b81a9a57ebdc4f4ee783c00d8db9ddc" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;utility&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;유틸리티&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6f0f7734302859b53edd0f1002e029c78892838a" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;valarray&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;valarray&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e625455d2631c1ace87ec154d71694548b6588b6" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;variant&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;variant&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8a1baf0e66b18f753027746ddac2bc1ed49cc5e4" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;vector&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;벡터&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1ffd6a8eb705dc937a7fe0d0e6b35bf87ff1db29" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;version&amp;gt;</source>
          <target state="translated">표준 라이브러리 헤더 &amp;lt;버전&amp;gt;</target>
        </trans-unit>
        <trans-unit id="654d328591592d08dc8271315e1ebea904bb6852" translate="yes" xml:space="preserve">
          <source>Standard library headers</source>
          <target state="translated">표준 라이브러리 헤더</target>
        </trans-unit>
        <trans-unit id="c3dac9dbde4233c05e9af6bd14d756cda62d81a6" translate="yes" xml:space="preserve">
          <source>Standard library implementations (but not the users) may define additional execution policies as an extension. The semantics of parallel algorithms invoked with an execution policy object of implementation-defined type is implementation-defined.</source>
          <target state="translated">표준 라이브러리 구현 (사용자는 아님)은 추가 실행 정책을 확장으로 정의 할 수 있습니다. 구현 정의 유형의 실행 정책 객체로 호출 된 병렬 알고리즘의 의미는 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="7f59b13f4443014dd818d6d62e0ca50de93aac7f" translate="yes" xml:space="preserve">
          <source>Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; execute &lt;code&gt;&lt;a href=&quot;../../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;CharT&amp;gt;::length(p);&lt;/code&gt;</source>
          <target state="translated">표준 라이브러리 전문 &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 실행 &lt;code&gt;&lt;a href=&quot;../../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;CharT&amp;gt;::length(p);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7f11a5bc54d097a97edced7adee37d68edf2a87" translate="yes" xml:space="preserve">
          <source>Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(getloc()).transform(str.data(), str.data() + str.length())&lt;/code&gt; for some temporary string &lt;code&gt;str&lt;/code&gt; constructed as &lt;code&gt;string_type str(first, last)&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리 전문 &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 반환 &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(getloc()).transform(str.data(), str.data() + str.length())&lt;/code&gt; 에 대한 몇 가지를 임시 문자열 &lt;code&gt;str&lt;/code&gt; 을은 으로 구성 &lt;code&gt;string_type str(first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c2e99d8ea2e28058e6a2c145dd8bbb69247703" translate="yes" xml:space="preserve">
          <source>Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(getloc()).tolower(c)&lt;/code&gt;, that is, convert &lt;code&gt;c&lt;/code&gt; to lowercase, using the currently imbued locale.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 의 표준 라이브러리 전문화는 std :: &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(getloc()).tolower(c)&lt;/code&gt; 리턴 합니다. 즉 , 현재 임베드 된 로케일을 사용하여 &lt;code&gt;c&lt;/code&gt; 를 소문자 로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="c5144e981c6c6484149dff7f4f0beecce8e30139" translate="yes" xml:space="preserve">
          <source>Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;c&lt;/code&gt; unmodified.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 의 표준 라이브러리 전문화는 &lt;code&gt;c&lt;/code&gt; 를 수정하지 않고 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="12d5d651a15ccfe72706786c2855cd1678d884f1" translate="yes" xml:space="preserve">
          <source>Standard practice is to use the result of a call to &lt;code&gt;time(0)&lt;/code&gt; as the seed. However, &lt;code&gt;time()&lt;/code&gt; returns a &lt;code&gt;time_t&lt;/code&gt; value, and &lt;code&gt;time_t&lt;/code&gt; is not guaranteed to be an integral type. In practice, though, every major implementation defines &lt;code&gt;time_t&lt;/code&gt; to be an integral type, and this is also what POSIX requires.</source>
          <target state="translated">표준 관행은 &lt;code&gt;time(0)&lt;/code&gt; 에 대한 호출 결과를 시드로 사용하는 것입니다. 그러나, &lt;code&gt;time()&lt;/code&gt; 반환 &lt;code&gt;time_t&lt;/code&gt; 값을, 그리고 &lt;code&gt;time_t&lt;/code&gt; 는 불가분의 유형으로 보장 할 수 없습니다. 그러나 실제로 모든 주요 구현은 &lt;code&gt;time_t&lt;/code&gt; 를 정수 유형으로 정의 하며 이것이 POSIX에 필요한 것이기도합니다.</target>
        </trans-unit>
        <trans-unit id="f96278355d7a86fd4872e0419bd210178419944b" translate="yes" xml:space="preserve">
          <source>Standard specializations</source>
          <target state="translated">표준 전문화</target>
        </trans-unit>
        <trans-unit id="50d93a9bc9b3b9d66c4edb7cde0b8c0cb17652e2" translate="yes" xml:space="preserve">
          <source>Standard specializations for basic types</source>
          <target state="translated">기본 유형에 대한 표준 전문화</target>
        </trans-unit>
        <trans-unit id="e17d7dcf6519a0eb9d420c2f744d5d6623aba9f6" translate="yes" xml:space="preserve">
          <source>Standard specializations for library types</source>
          <target state="translated">라이브러리 유형에 대한 표준 전문화</target>
        </trans-unit>
        <trans-unit id="ed6715a35349ec5186a2258a1fc2b8a7e6600fb4" translate="yes" xml:space="preserve">
          <source>Standard-compliant IEEE 754 floating-point implementations are required to detect the floating-point underflow, and have two alternative situations where this can be done.</source>
          <target state="translated">부동 소수점 언더 플로우를 감지하려면 표준 호환 IEEE 754 부동 소수점 구현이 필요하며,이를 수행 할 수있는 두 가지 대체 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e26cb26c5dd59e71ed80fc7cfcfda7a8c768940d" translate="yes" xml:space="preserve">
          <source>Standard-compliant IEEE 754 floating-point implementations of subnormal numbers are required to detect the loss of accuracy associated with the creation of such number, if it occurs, and may do so in one of the two distinct ways:</source>
          <target state="translated">비정규 숫자의 표준 호환 IEEE 754 부동 소수점 구현은 그러한 숫자의 생성과 관련된 정확도 손실이 발생하는 경우이를 감지하는 데 필요하며 다음 두 가지 방법 중 하나로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb57ea5ef3c29b0f002a0ec25815bd661eb3ebf" translate="yes" xml:space="preserve">
          <source>StandardLayoutType</source>
          <target state="translated">StandardLayoutType</target>
        </trans-unit>
        <trans-unit id="f7730d7471c71dacebca7e0efdb78a6fa0cf6783" translate="yes" xml:space="preserve">
          <source>Standing Document 6</source>
          <target state="translated">스탠딩 문서 6</target>
        </trans-unit>
        <trans-unit id="b1dd515aa2381f04476ea569b39d96a450fd3318" translate="yes" xml:space="preserve">
          <source>Start and termination</source>
          <target state="translated">시작과 종료</target>
        </trans-unit>
        <trans-unit id="4f9106212988ffb212518950c1b57cd1a214ebec" translate="yes" xml:space="preserve">
          <source>Start of the match sequence.</source>
          <target state="translated">경기 순서의 시작.</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="8599e6e165d2bcb838c46be096bed576d7097ec1" translate="yes" xml:space="preserve">
          <source>State functions</source>
          <target state="translated">상태 함수</target>
        </trans-unit>
        <trans-unit id="de775277311a1f15adade206c2c728fd44d33fe4" translate="yes" xml:space="preserve">
          <source>State not recoverable</source>
          <target state="translated">회복 불가능한 상태</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="ac9ab88c4da84329c3b27c4e3b5bb1de7c492136" translate="yes" xml:space="preserve">
          <source>Statements are fragments of the C++ program that are executed in sequence. The body of any function is a sequence of statements. For example:</source>
          <target state="translated">명령문은 순서대로 실행되는 C ++ 프로그램의 단편입니다. 모든 함수의 본문은 일련의 문장입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94cc4f19c494bbef2c1d56c06acf5a9829ac16cc" translate="yes" xml:space="preserve">
          <source>Static Assertion</source>
          <target state="translated">정적 어설 션</target>
        </trans-unit>
        <trans-unit id="bb550afd1ebb32356a77de0371e760348130ef0c" translate="yes" xml:space="preserve">
          <source>Static data member definition</source>
          <target state="translated">정적 데이터 멤버 정의</target>
        </trans-unit>
        <trans-unit id="46bd22af5dd67ebd874efc2e0ac50e03cd30c502" translate="yes" xml:space="preserve">
          <source>Static data members</source>
          <target state="translated">정적 데이터 멤버</target>
        </trans-unit>
        <trans-unit id="97afd45f475da08d8c0f908949451f73e1e2051f" translate="yes" xml:space="preserve">
          <source>Static data members and unnamed bit-fields are skipped during aggregate initialization.</source>
          <target state="translated">정적 데이터 멤버 및 명명되지 않은 비트 필드는 집계 초기화 중에 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="eb38fc7b36b66e06d5bf9efbc0bb09a0026e8e85" translate="yes" xml:space="preserve">
          <source>Static data members are not associated with any object. They exist even if no objects of the class have been defined. There is only one instance of the static data member in the entire program with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, unless the keyword &lt;a href=&quot;../keyword/thread_local&quot;&gt;&lt;code&gt;thread_local&lt;/code&gt;&lt;/a&gt; is used, in which case there is one such object per thread with thread storage duration(since C++11).</source>
          <target state="translated">정적 데이터 멤버는 오브젝트와 연관되지 않습니다. 클래스의 객체가 정의되지 않은 경우에도 존재합니다. 키워드 &lt;a href=&quot;../keyword/thread_local&quot;&gt; &lt;code&gt;thread_local&lt;/code&gt; &lt;/a&gt; 을 사용 하지 않는 한 전체 프로그램에서 정적 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간을&lt;/a&gt; 갖는 정적 데이터 멤버의 인스턴스는 하나뿐입니다 .</target>
        </trans-unit>
        <trans-unit id="5a10105f9c5b523dd7b45c238796e10e4690c992" translate="yes" xml:space="preserve">
          <source>Static data members cannot be &lt;code&gt;mutable&lt;/code&gt;.</source>
          <target state="translated">정적 데이터 멤버는 &lt;code&gt;mutable&lt;/code&gt; 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="371b57153df1ed513114ab949e27cebd491c8434" translate="yes" xml:space="preserve">
          <source>Static data members of a class in namespace scope have &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt; if the class itself has external linkage (i.e. is not a member of &lt;a href=&quot;namespace#Unnamed_namespaces&quot;&gt;unnamed namespace&lt;/a&gt;). Local classes (classes defined inside functions) and unnamed classes, including member classes of unnamed classes, cannot have static data members.</source>
          <target state="translated">네임 스페이스 범위에서 클래스의 정적 데이터 멤버가있는 &lt;a href=&quot;storage_duration&quot;&gt;외부 링크를&lt;/a&gt; 클래스 자체가 외부 링크를 (즉의 구성원이 아닌 경우 &lt;a href=&quot;namespace#Unnamed_namespaces&quot;&gt;이름이 네임 스페이스&lt;/a&gt; ). 명명되지 않은 클래스의 멤버 클래스를 포함하여 로컬 클래스 (함수 내에 정의 된 클래스) 및 명명되지 않은 클래스는 정적 데이터 멤버를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="66c70953f1f5a5d30cc40fb358b4d5f32a610e70" translate="yes" xml:space="preserve">
          <source>Static initialization</source>
          <target state="translated">정적 초기화</target>
        </trans-unit>
        <trans-unit id="f30eb0885bcec4fd1755afedbe57f9601ef1f529" translate="yes" xml:space="preserve">
          <source>Static local variables</source>
          <target state="translated">정적 지역 변수</target>
        </trans-unit>
        <trans-unit id="d1c5547b3f51ba366a4284d49631b8e01791d63a" translate="yes" xml:space="preserve">
          <source>Static member functions</source>
          <target state="translated">정적 멤버 함수</target>
        </trans-unit>
        <trans-unit id="2af32f47f8018d9be8b0b47c61a0cc38f2d5c6d1" translate="yes" xml:space="preserve">
          <source>Static member functions are not associated with any object. When called, they have no &lt;code&gt;this&lt;/code&gt; pointer.</source>
          <target state="translated">정적 멤버 함수는 오브젝트와 연관되지 않습니다. 호출되면 &lt;code&gt;this&lt;/code&gt; 포인터 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b6b778cb1881bdfe8ba589dfa1d7e64a8648b347" translate="yes" xml:space="preserve">
          <source>Static member functions cannot be &lt;code&gt;virtual&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, or &lt;code&gt;volatile&lt;/code&gt;.</source>
          <target state="translated">정적 멤버 함수는 &lt;code&gt;virtual&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;volatile&lt;/code&gt; 일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fc21ad13d962a86f6af81e2532633a2953381105" translate="yes" xml:space="preserve">
          <source>Static members obey the &lt;a href=&quot;access&quot;&gt;class member access rules (private, protected, public)&lt;/a&gt;.</source>
          <target state="translated">정적 멤버는 &lt;a href=&quot;access&quot;&gt;클래스 멤버 액세스 규칙 (개인, 보호, 공개)을&lt;/a&gt; 준수합니다 .</target>
        </trans-unit>
        <trans-unit id="ad5e53a8243d18db544d0e4aef917bd32945122b" translate="yes" xml:space="preserve">
          <source>Static members of a class are not associated with the objects of the class: they are independent variables with &lt;a href=&quot;storage_duration&quot;&gt;static or thread (since C++11) storage duration&lt;/a&gt; or regular functions.</source>
          <target state="translated">클래스의 정적 멤버는 클래스의 객체와 관련이 없습니다. &lt;a href=&quot;storage_duration&quot;&gt;정적 또는 스레드 (C ++ 11부터) 저장 기간&lt;/a&gt; 또는 일반 함수를 갖는 독립 변수입니다 .</target>
        </trans-unit>
        <trans-unit id="eb3a67571fc5f93c2c2097d93c994d457dbd23db" translate="yes" xml:space="preserve">
          <source>Static non-local initialization</source>
          <target state="translated">정적 로컬이 아닌 초기화</target>
        </trans-unit>
        <trans-unit id="9574eed3a2fa1c67fc0230215243b3da4ecc1747" translate="yes" xml:space="preserve">
          <source>Static type</source>
          <target state="translated">정적 유형</target>
        </trans-unit>
        <trans-unit id="c45b18c0f0f4b3cf24da66312054a56ccf27d9c5" translate="yes" xml:space="preserve">
          <source>Std</source>
          <target state="translated">Std</target>
        </trans-unit>
        <trans-unit id="d5aa1dfd94faedad10f0a8dc6dfafde4729ce588" translate="yes" xml:space="preserve">
          <source>Storage allocator used by &lt;code&gt;X&lt;/code&gt;, or &lt;code&gt;std::allocator_type&amp;lt;X::value_type&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 또는 &lt;code&gt;std::allocator_type&amp;lt;X::value_type&amp;gt;&lt;/code&gt; 사용하는 스토리지 할당 자</target>
        </trans-unit>
        <trans-unit id="ec15fc4dbb2ee73ac6af794fcba5534c45a6a4be" translate="yes" xml:space="preserve">
          <source>Storage class specifiers</source>
          <target state="translated">스토리지 클래스 지정자</target>
        </trans-unit>
        <trans-unit id="f67686a12828f8c435b9873713c43fb5b2da0449" translate="yes" xml:space="preserve">
          <source>Storage class specifiers are not allowed in friend function declarations. A function that is defined in the friend declaration has external linkage, a function that was previously defined, keeps the linkage it was defined with.</source>
          <target state="translated">동반자 함수 선언에는 스토리지 클래스 지정자가 허용되지 않습니다. 프렌드 선언에 정의 된 함수에는 이전에 정의 된 함수 인 외부 링크가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d2e5a537eb298ee43ba92a7262f494050e37b01" translate="yes" xml:space="preserve">
          <source>Storage class specifiers, except for &lt;code&gt;thread_local&lt;/code&gt;, are not allowed on &lt;a href=&quot;template_specialization&quot;&gt;explicit specializations&lt;/a&gt; and &lt;a href=&quot;class_template#Explicit_instantiation&quot;&gt;explicit instantiations&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;thread_local&lt;/code&gt; 을 제외한 스토리지 클래스 지정자는 &lt;a href=&quot;template_specialization&quot;&gt;명시 적 특수화&lt;/a&gt; 및 &lt;a href=&quot;class_template#Explicit_instantiation&quot;&gt;명시 적 인스턴스화&lt;/a&gt; 에서 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="054b352055da9aba89fd42abb819a5be6e8dda75" translate="yes" xml:space="preserve">
          <source>Storage duration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee607356de208b84b5b4f1b3aa07ccd66969aa16" translate="yes" xml:space="preserve">
          <source>Storage duration and linkage</source>
          <target state="translated">저장 기간 및 연결</target>
        </trans-unit>
        <trans-unit id="ab679a7d893805c39464b199136b607026da7bb7" translate="yes" xml:space="preserve">
          <source>Storage occupied by trivially destructible objects &lt;a href=&quot;../language/lifetime#Storage_reuse&quot;&gt;may be reused&lt;/a&gt; without calling the destructor.</source>
          <target state="translated">사소한 파괴 가능한 객체 &lt;a href=&quot;../language/lifetime#Storage_reuse&quot;&gt;가&lt;/a&gt; 차지하는 스토리지 는 소멸자를 호출하지 않고도 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7302554a147c8f1ef58779b6dcfb25b50489faa" translate="yes" xml:space="preserve">
          <source>Storage reuse</source>
          <target state="translated">스토리지 재사용</target>
        </trans-unit>
        <trans-unit id="7eff65dcae7f41c301872cc53e3deb0f34e8823a" translate="yes" xml:space="preserve">
          <source>Stores information about the type and permissions of a file.</source>
          <target state="translated">파일 유형 및 권한에 대한 정보를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="2da9e099a998176bcb262c98bedcd788bd461bcd" translate="yes" xml:space="preserve">
          <source>Stores the &lt;code&gt;value&lt;/code&gt; into the shared state without making the state ready immediately. The state is made ready when the current thread exits, after all variables with thread-local storage duration have been destroyed.</source>
          <target state="translated">상태를 즉시 준비하지 않고 &lt;code&gt;value&lt;/code&gt; 을 공유 상태로 저장합니다 . 스레드 로컬 스토리지 기간이있는 모든 변수가 삭제 된 후 현재 스레드가 종료되면 상태가 준비됩니다.</target>
        </trans-unit>
        <trans-unit id="185739e7299f86de0648cf745f16fe6aa8f259af" translate="yes" xml:space="preserve">
          <source>Stores the exception pointer &lt;code&gt;p&lt;/code&gt; into the shared state without making the state ready immediately. The state is made ready when the current thread exits, after all variables with thread-local storage duration have been destroyed.</source>
          <target state="translated">상태를 즉시 준비하지 않고 예외 포인터 &lt;code&gt;p&lt;/code&gt; 를 공유 상태로 저장합니다 . 스레드 로컬 스토리지 기간이있는 모든 변수가 삭제 된 후 현재 스레드가 종료되면 상태가 준비됩니다.</target>
        </trans-unit>
        <trans-unit id="7f4f9fe73fb68dcc407f1e0ef33265a27a253cac" translate="yes" xml:space="preserve">
          <source>Straightforward implementation of &lt;code&gt;std::basic_ios&lt;/code&gt; stores only the following members (which all depend on the template parameters and thus cannot be part of &lt;code&gt;&lt;a href=&quot;ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;std::basic_ios&lt;/code&gt; 의 간단한 구현은 다음 멤버 만 저장합니다 (모두 템플리트 매개 변수에 의존하므로 &lt;code&gt;&lt;a href=&quot;ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; 일부가 될 수 없음 ).</target>
        </trans-unit>
        <trans-unit id="4da38c43ed7080f8a49dff900d3cff58aefb2a07" translate="yes" xml:space="preserve">
          <source>Stream I/O functions</source>
          <target state="translated">스트림 I / O 기능</target>
        </trans-unit>
        <trans-unit id="27d49e129b02b87ad3e682b42ebfdf9bf5a57eca" translate="yes" xml:space="preserve">
          <source>Stream Iterators</source>
          <target state="translated">스트림 반복자</target>
        </trans-unit>
        <trans-unit id="f92543e2fc6c9b6b0c1348fe72efaf553f416cfd" translate="yes" xml:space="preserve">
          <source>Stream extraction and insertion</source>
          <target state="translated">스트림 추출 및 삽입</target>
        </trans-unit>
        <trans-unit id="4117e115ebe03d0f0cc37b33d0ce1b9feb2ef514" translate="yes" xml:space="preserve">
          <source>Stream insertion/extraction operators</source>
          <target state="translated">스트림 삽입 / 추출 연산자</target>
        </trans-unit>
        <trans-unit id="4efdedd0ec1a3401856545ce2cc8c17664fa2bf2" translate="yes" xml:space="preserve">
          <source>Stream ioctl() timeout</source>
          <target state="translated">스트림 ioctl () 시간 초과</target>
        </trans-unit>
        <trans-unit id="e4c27387ff9f1b49239b2a3296d0f1c69f4d91d5" translate="yes" xml:space="preserve">
          <source>Stream iterators</source>
          <target state="translated">스트림 반복자</target>
        </trans-unit>
        <trans-unit id="c67c540c988e57a5f4befbaef40deda7583ff172" translate="yes" xml:space="preserve">
          <source>Stream repositioning operations &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;std::fsetpos&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;std::rewind&lt;/a&gt;&lt;/code&gt; discard the effects of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">스트림 재배치 작업 &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;std::fsetpos&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;std::rewind&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;ungetc&lt;/code&gt; 의 영향을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="c5dff59c7e8474e86f09f5231350118743b2ca36" translate="yes" xml:space="preserve">
          <source>Stream repositioning operations &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;std::fsetpos&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;std::rewind&lt;/a&gt;&lt;/code&gt; discard the effects of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">스트림 재배치 작업 &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;std::fsetpos&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;std::rewind&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;ungetwc&lt;/code&gt; 의 영향을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="68075f452f35232e13e6ccd0643d8f58364296fe" translate="yes" xml:space="preserve">
          <source>Stream-based I/O</source>
          <target state="translated">스트림 기반 I / O</target>
        </trans-unit>
        <trans-unit id="f5f5e1a47da510fa4386d462c1aa32523fb29a1e" translate="yes" xml:space="preserve">
          <source>Strict aliasing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0097c41d010531d07269f98771f7552ca6ec4e" translate="yes" xml:space="preserve">
          <source>Strict total ordering relation:</source>
          <target state="translated">엄격한 총 주문 관계 :</target>
        </trans-unit>
        <trans-unit id="a95223de1ad301f6e7666d5804a6b78f32f20dc0" translate="yes" xml:space="preserve">
          <source>StrictTotallyOrderedStrictTotallyOrderedWith</source>
          <target state="translated">StrictTotallyOrderedStrictTotallyOrderedWith</target>
        </trans-unit>
        <trans-unit id="d2cf8bb476d3824fdc86b7f80f14dd73afec32f3" translate="yes" xml:space="preserve">
          <source>StrictWeakOrder</source>
          <target state="translated">StrictWeakOrder</target>
        </trans-unit>
        <trans-unit id="db0a185fa483bab1a27815a0aad3de4ddd23c346" translate="yes" xml:space="preserve">
          <source>String I/O implementation</source>
          <target state="translated">문자열 I / O 구현</target>
        </trans-unit>
        <trans-unit id="fa36590c2f94b03fb1fdfe69ed29015d079c3c83" translate="yes" xml:space="preserve">
          <source>String and stream conversions</source>
          <target state="translated">문자열 및 스트림 변환</target>
        </trans-unit>
        <trans-unit id="41d8cba12ab83e606dc848af9a593af42eacf80b" translate="yes" xml:space="preserve">
          <source>String containing the substring &lt;code&gt;[pos, pos+count)&lt;/code&gt;.</source>
          <target state="translated">하위 문자열을 포함하는 문자열 &lt;code&gt;[pos, pos+count)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e031acc885a0faad2e48479ddf43e3a5c3bc69" translate="yes" xml:space="preserve">
          <source>String conversions</source>
          <target state="translated">문자열 변환</target>
        </trans-unit>
        <trans-unit id="d26b1bbd9eee2dfd3f5c0a081017d1db1f7dfe02" translate="yes" xml:space="preserve">
          <source>String examination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8131be0a54d163595856a74881c0952b86c731" translate="yes" xml:space="preserve">
          <source>String literals can be used to &lt;a href=&quot;aggregate_initialization&quot;&gt;initialize character arrays&lt;/a&gt;. If an array is initialized like &lt;code&gt;char str[] = &quot;foo&quot;;&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt; will contain a copy of the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt;.</source>
          <target state="translated">문자열 리터럴을 사용하여 &lt;a href=&quot;aggregate_initialization&quot;&gt;문자 배열&lt;/a&gt; 을 초기화 할 수 있습니다 . 배열이 &lt;code&gt;char str[] = &quot;foo&quot;;&lt;/code&gt; 와 같이 초기화 된 경우 ; , &lt;code&gt;str&lt;/code&gt; 문자열의 사본이 포함됩니다 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="992ce5d61dd55466d37181c4d6e57b2e90b9eaa5" translate="yes" xml:space="preserve">
          <source>String literals have &lt;a href=&quot;storage_duration&quot;&gt;static storage duration&lt;/a&gt;, and thus exist in memory for the life of the program.</source>
          <target state="translated">문자열 리터럴은 &lt;a href=&quot;storage_duration&quot;&gt;정적 저장 시간을&lt;/a&gt; 가지므로 프로그램 수명 동안 메모리에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="7a8ce38efd037714bf10ba473a6eba0fcb37596d" translate="yes" xml:space="preserve">
          <source>String literals placed side-by-side are concatenated at &lt;a href=&quot;translation_phases&quot;&gt;translation phase 6&lt;/a&gt; (after the preprocessor). That is, &lt;code&gt;&quot;Hello,&quot; &quot; world!&quot;&lt;/code&gt; yields the (single) string &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt;. If the two strings have the same encoding prefix (or neither has one), the resulting string will have the same encoding prefix (or no prefix).</source>
          <target state="translated">나란히 배치 된 문자열 리터럴은 &lt;a href=&quot;translation_phases&quot;&gt;변환 단계 6&lt;/a&gt; (전 처리기 이후)에 연결됩니다. 즉 &lt;code&gt;&quot;Hello,&quot; &quot; world!&quot;&lt;/code&gt; (단일) 문자열 &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; . 두 문자열의 인코딩 접두사가 같거나 둘 다없는 경우 결과 문자열은 동일한 인코딩 접두사를 갖습니다 (또는 접두사가 없음).</target>
        </trans-unit>
        <trans-unit id="411f94c6ca34e4478bca225615707da562686a1d" translate="yes" xml:space="preserve">
          <source>String manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766f45c1227c8c7d13e31b3c8218c7c441dc99b1" translate="yes" xml:space="preserve">
          <source>String operations</source>
          <target state="translated">문자열 연산</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="85aec181db33cf00bdd54f1cb9ce01b7d7ff51de" translate="yes" xml:space="preserve">
          <source>Strings library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0ec7dd80d15f28024dcdf6ef00a96517fd3337" translate="yes" xml:space="preserve">
          <source>Strong equality</source>
          <target state="translated">강한 평등</target>
        </trans-unit>
        <trans-unit id="2a2cba0627fce84913a263b1689bcc1a5f52e879" translate="yes" xml:space="preserve">
          <source>Strong exception guarantee</source>
          <target state="translated">강력한 예외 보장</target>
        </trans-unit>
        <trans-unit id="e6e1cc7391bbf33d477f2846d55201bd5dc45d0b" translate="yes" xml:space="preserve">
          <source>Strong ordering</source>
          <target state="translated">강력한 주문</target>
        </trans-unit>
        <trans-unit id="b23ece5c063f8e292de60a2d5bc21311633d6bab" translate="yes" xml:space="preserve">
          <source>Strongly happens-before</source>
          <target state="translated">강하게 일어나기 전에</target>
        </trans-unit>
        <trans-unit id="7f9dcf8956ae1c0d6f55e5d5d3036df614ef80f7" translate="yes" xml:space="preserve">
          <source>Structure holding a calendar date and time broken down into its components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6829a88eb9844dcc19a2c6962557c4417821a67d" translate="yes" xml:space="preserve">
          <source>Structure holding an interval broken down into seconds and nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973b2408e7e7197be8a8e1752c113a94b7f7898b" translate="yes" xml:space="preserve">
          <source>Structured binding declaration</source>
          <target state="translated">구조적 바인딩 선언</target>
        </trans-unit>
        <trans-unit id="bc78a4804f98729f1fc5b2a33b36920a69e741f5" translate="yes" xml:space="preserve">
          <source>Structured binding declaration (since C++17)</source>
          <target state="translated">구조적 바인딩 선언 (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="0d6798b48c01e645bbcf19570110d23f14c8b068" translate="yes" xml:space="preserve">
          <source>Subobjects</source>
          <target state="translated">Subobjects</target>
        </trans-unit>
        <trans-unit id="b1bd6eaaf0ebc0fa2da36cbd85120b995ab0f777" translate="yes" xml:space="preserve">
          <source>Subscript</source>
          <target state="translated">Subscript</target>
        </trans-unit>
        <trans-unit id="c1583fa3ea82816d07fd7988b265e391b3ed9264" translate="yes" xml:space="preserve">
          <source>Subscript operator is overloaded by many standard container classes.</source>
          <target state="translated">첨자 연산자는 많은 표준 컨테이너 클래스에 의해 오버로드됩니다.</target>
        </trans-unit>
        <trans-unit id="4355b7045e1b93f4ce4ee9fe614f3e36f42492fe" translate="yes" xml:space="preserve">
          <source>Substitution Failure Is Not An Error</source>
          <target state="translated">대체 실패는 오류가 아닙니다</target>
        </trans-unit>
        <trans-unit id="5a0ac414a99278539760176a2a901e652944aa12" translate="yes" xml:space="preserve">
          <source>Substitution failure (that is, failure to replace template parameters with the deduced or provided template arguments) of a function template removes the function template from the &lt;a href=&quot;overload_resolution&quot;&gt;overload set&lt;/a&gt;. This allows a number of ways to manipulate overload sets using template metaprogramming: see &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; for details.</source>
          <target state="translated">함수 템플리트의 대체 실패 (즉, 템플리트 매개 변수를 추론되거나 제공된 템플리트 인수로 대체하지 못함)는 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 세트&lt;/a&gt; 에서 함수 템플리트를 제거합니다 . 이 템플릿 메타 프로그래밍을 사용하여 과부하 세트를 조작 할 수있는 여러 가지 방법으로 할 수 있습니다 : 볼 &lt;a href=&quot;sfinae&quot;&gt;SFINAE를&lt;/a&gt; . 자세한 내용 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="591c5df87c474f7001b9a4b343441ece26f906a9" translate="yes" xml:space="preserve">
          <source>Substitution occurs in.</source>
          <target state="translated">대체가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="22318c19ebfcbe8742eb22bc4dd2a56e26bc5ca5" translate="yes" xml:space="preserve">
          <source>Substitution proceeds in lexical order and stops when a failure is encountered.</source>
          <target state="translated">대체는 어휘 순서로 진행되며 실패가 발생하면 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="0a045f4c6f39f937114f65c98c1c2c42cae38a88" translate="yes" xml:space="preserve">
          <source>Subsumption relationship defines partial order of constraints, which is used to determine:</source>
          <target state="translated">Subsumption relation은 다음을 결정하는 데 사용되는 제약 조건의 부분 순서를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="444502efceec69003dab264c206c253cf80e3d8d" translate="yes" xml:space="preserve">
          <source>Subviews</source>
          <target state="translated">Subviews</target>
        </trans-unit>
        <trans-unit id="6bcbfb9f1192e212a275dd730eb5425c37042275" translate="yes" xml:space="preserve">
          <source>Successive characters obtained from the input iterator &lt;code&gt;in&lt;/code&gt; are matched against the character sequences obtained from &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt; &amp;gt;(str.getloc()).truename()&lt;/code&gt; only as necessary as to identify the unique match. The input iterator &lt;code&gt;in&lt;/code&gt; is compared to &lt;code&gt;end&lt;/code&gt; only when necessary to obtain a character.</source>
          <target state="translated">입력 반복자 &lt;code&gt;in&lt;/code&gt; 얻은 연속 문자 는 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt; &amp;gt;(str.getloc()).truename()&lt;/code&gt; 에서 얻은 문자 시퀀스와 일치합니다 . 고유 한 일치를 식별하기 위해 필요한 경우에만 &amp;lt;charT&amp;gt;&amp;gt; (str.getloc ()). truename () 을 사용하십시오. 입력 반복기 &lt;code&gt;in&lt;/code&gt; 비교된다 &lt;code&gt;end&lt;/code&gt; 문자를 얻었다 필요할 때만.</target>
        </trans-unit>
        <trans-unit id="02dd1aa421985efb1844e6484a1dadac82aaf55c" translate="yes" xml:space="preserve">
          <source>Such expressions can be used as non-type template arguments, array sizes, and in other contexts that require constant expressions, e.g.</source>
          <target state="translated">이러한 표현식은 유형이 아닌 템플릿 인수, 배열 크기 및 상수 표현식이 필요한 다른 컨텍스트 (예 :</target>
        </trans-unit>
        <trans-unit id="21363a6ad79a6a39e59b2152a0df07dbc463441d" translate="yes" xml:space="preserve">
          <source>Such operator can be defined in the class body, which has the effect of generating a separate non-template &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for each &lt;code&gt;T&lt;/code&gt; and makes that non-template &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; a friend of its &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이러한 운전자는 별도의 비 템플릿을 생성하는 효과가있는 클래스 본문에 정의 될 수 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 각각 &lt;code&gt;T&lt;/code&gt; 를 그 비 템플릿하게 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 그 친구 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b03105f26235b8bb335ef3b1058edc0bbb2150d1" translate="yes" xml:space="preserve">
          <source>Such operator will be deleted if overload resolution over x &amp;lt;=&amp;gt; y (considering also operator&amp;lt;=&amp;gt; with reversed order of parameters) fails, or if this operator@ is not applicable to the result of that x&amp;lt;=&amp;gt;y. Otherwise, the defaulted operator@ calls &lt;code&gt;x &amp;lt;=&amp;gt; y @ 0&lt;/code&gt; if an operator&amp;lt;=&amp;gt; with the original order of parameters was selected by overload resolution, or &lt;code&gt;0 @ y &amp;lt;=&amp;gt; x&lt;/code&gt; otherwise:</source>
          <target state="translated">x &amp;lt;=&amp;gt; y에 대한 과부하 해상도 (역순으로 매개 변수의 연산자 &amp;lt;=&amp;gt;도 고려)가 실패하거나이 operator @가 해당 x &amp;lt;=&amp;gt; y의 결과에 적용되지 않는 경우 이러한 연산자는 삭제됩니다. 그렇지 않으면, 원래의 파라미터 순서를 가진 연산자 &amp;lt;=&amp;gt;가 과부하 해결에 의해 선택된 경우 기본 operator @는 &lt;code&gt;x &amp;lt;=&amp;gt; y @ 0&lt;/code&gt; 호출하고, 그렇지 않으면 &lt;code&gt;0 @ y &amp;lt;=&amp;gt; x&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f59b30f2283f05ae65b26b5ae58feb0b51a1b44e" translate="yes" xml:space="preserve">
          <source>Such pointer may be used as the right-hand operand of the &lt;a href=&quot;operator_member_access&quot;&gt;pointer-to-member access operators&lt;/a&gt;&lt;code&gt;operator.*&lt;/code&gt; and &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;. The &lt;a href=&quot;value_category#Pending_member_function_call&quot;&gt;resulting expression&lt;/a&gt; can be used only as the left-hand operand of a function-call operator:</source>
          <target state="translated">이러한 포인터는 &lt;a href=&quot;operator_member_access&quot;&gt;포인터 대 멤버 액세스 연산자 &lt;/a&gt; &lt;code&gt;operator.*&lt;/code&gt; 및 &lt;code&gt;operator-&amp;gt;*&lt;/code&gt; 의 오른쪽 피연산자로 사용할 수 있습니다 . &lt;a href=&quot;value_category#Pending_member_function_call&quot;&gt;얻어진 식은&lt;/a&gt; 단지 함수 호출 연산자의 왼쪽 피연산자로서 사용될 수있다 :</target>
        </trans-unit>
        <trans-unit id="4a86835bbedf2d82f06941a7eca5e62c9d3bb06d" translate="yes" xml:space="preserve">
          <source>Such pointer may be used as the right-hand operand of the &lt;a href=&quot;operator_member_access&quot;&gt;pointer-to-member access operators&lt;/a&gt;&lt;code&gt;operator.*&lt;/code&gt; and &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;:</source>
          <target state="translated">이러한 포인터는 &lt;a href=&quot;operator_member_access&quot;&gt;포인터 대 멤버 액세스 연산자 &lt;/a&gt; &lt;code&gt;operator.*&lt;/code&gt; 의 오른쪽 피연산자로 사용할 수 있습니다 . * 및 &lt;code&gt;operator-&amp;gt;*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="525c748fc518254c41cc517df9846906fa547dd6" translate="yes" xml:space="preserve">
          <source>Such threads can still be guaranteed to make progress by blocking with forward progress guarantee delegation: if a thread P blocks in this manner on the completion of a set of threads S, then at least one thread in S will offer a forward progress guarantee that is same or stronger than P. Once that thread completes, another thread in S will be similarly strengthened. Once the set is empty, P will unblock.</source>
          <target state="translated">이러한 스레드는 여전히 순방향 진행 보장 위임으로 차단하여 진행을 보장 할 수 있습니다. 스레드 P가 일련의 스레드 S 완료시 이러한 방식으로 차단되면 S의 최소 하나의 스레드가 다음과 같은 순방향 진행 보증을 제공합니다. 스레드가 완료되면 S의 다른 스레드도 비슷하게 강화됩니다. 세트가 비어 있으면 P가 차단을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="885db975a310a3bb649f91e5771f94988987874d" translate="yes" xml:space="preserve">
          <source>Suffix</source>
          <target state="translated">Suffix</target>
        </trans-unit>
        <trans-unit id="a155b76eeff83c1b360d01d1d9f1a602a79c9a17" translate="yes" xml:space="preserve">
          <source>Suffix/postfix &lt;a href=&quot;operator_incdec&quot;&gt;increment and decrement&lt;/a&gt;</source>
          <target state="translated">접미사 / 접미사 &lt;a href=&quot;operator_incdec&quot;&gt;증가 및 감소&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19171fbcdbee77041c634a610bfe878ef0ce0cc9" translate="yes" xml:space="preserve">
          <source>Sun Studio 12 Asm Statements</source>
          <target state="translated">썬 스튜디오 12 Asm 선언문</target>
        </trans-unit>
        <trans-unit id="14b6c11b5ace8897cf95dd45dac490e5c600cea0" translate="yes" xml:space="preserve">
          <source>Support for functions that take an arbitrary number of parameters (via e.g. &lt;code&gt;&lt;a href=&quot;utility/variadic/va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">파라미터의 임의의 수 (예를 통해 수행 기능을 지원 &lt;code&gt;&lt;a href=&quot;utility/variadic/va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; 를 , &lt;code&gt;&lt;a href=&quot;utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; 의가 ).</target>
        </trans-unit>
        <trans-unit id="182a3d18bc1ed1dddb8e31853aeb6af1e8a0f41e" translate="yes" xml:space="preserve">
          <source>Support of subnormal values cannot be determined</source>
          <target state="translated">비정규 값의 지원을 결정할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="b43556e57ddc8fd912e77789b8be419ca8952ed4" translate="yes" xml:space="preserve">
          <source>Supported facets</source>
          <target state="translated">지원되는 패싯</target>
        </trans-unit>
        <trans-unit id="e1fa93264c642e6139202201a55bd0e027398ffd" translate="yes" xml:space="preserve">
          <source>Supported operations</source>
          <target state="translated">지원되는 작업</target>
        </trans-unit>
        <trans-unit id="a9f4e1ca1505826ce533842453633c496fbcc06f" translate="yes" xml:space="preserve">
          <source>Suppresses warnings on unused entities.</source>
          <target state="translated">사용하지 않는 엔터티에 대한 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a4cb3f45ae9718b61a344bc44ccbb234548bd2f" translate="yes" xml:space="preserve">
          <source>Swap will replace the allocator only if &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Specifically, it will exchange the allocator instances through an unqualified call to the non-member function swap, see &lt;a href=&quot;swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 스왑이 할당자를 대체 합니다 . 특히, 비 멤버 함수 스왑에 대한 규정되지 않은 호출을 통해 할당 자 인스턴스를 교환합니다 ( &lt;a href=&quot;swappable&quot;&gt;스왑 가능&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="2d99a0e5c0a9ee8ca98669825be4b7a2c66f5f90" translate="yes" xml:space="preserve">
          <source>Swap, forward and move</source>
          <target state="translated">스왑, 앞으로 이동</target>
        </trans-unit>
        <trans-unit id="05c1d85c002e28643f01e9daa1e79b8890fdda4c" translate="yes" xml:space="preserve">
          <source>Swappable</source>
          <target state="translated">Swappable</target>
        </trans-unit>
        <trans-unit id="6b34e97f93836d5c33eae87b0dff11e13379be29" translate="yes" xml:space="preserve">
          <source>SwappableSwappableWith</source>
          <target state="translated">SwappableSwappableWith</target>
        </trans-unit>
        <trans-unit id="3129fb81987fb272c265d1cd137eafd6477ca2ca" translate="yes" xml:space="preserve">
          <source>Swaps &lt;code&gt;first&lt;/code&gt; with &lt;code&gt;other.first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; with &lt;code&gt;other.second&lt;/code&gt;.</source>
          <target state="translated">스왑 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;other.first&lt;/code&gt; 및 &lt;code&gt;second&lt;/code&gt; 와 &lt;code&gt;other.second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46949daeb4adb6e15c19a65c88f33a850a883f5f" translate="yes" xml:space="preserve">
          <source>Swaps the content of two &lt;code&gt;any&lt;/code&gt; objects.</source>
          <target state="translated">두 가지의 내용을 바꿉니다 &lt;code&gt;any&lt;/code&gt; 물체를.</target>
        </trans-unit>
        <trans-unit id="fe4d8941704ab78369e432742b37c716fb6b94d8" translate="yes" xml:space="preserve">
          <source>Swaps the contents (both native and generic format) of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 의 내용 (기본 및 일반 형식)을 교환합니다 .</target>
        </trans-unit>
        <trans-unit id="c66074c19195e8d22fd5cfbc04ba7660d205b20e" translate="yes" xml:space="preserve">
          <source>Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Equivalent to &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f5b50cb7ed1a1f2555712b311ea6515482f921bc" translate="yes" xml:space="preserve">
          <source>Swaps the contents of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 내용을 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="3025dc5a0136ff8b6b3463e082445e487801a56c" translate="yes" xml:space="preserve">
          <source>Swaps the contents of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Equivalent to &lt;code&gt;x.swap(y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 내용을 바꿉니다 . &lt;code&gt;x.swap(y)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="39a37ca052dbf59922f3df1878e2f1d4dab4556f" translate="yes" xml:space="preserve">
          <source>Swaps the contents with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">내용을 &lt;code&gt;other&lt;/code&gt; 내용으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="bafd3277089c568f441f3a36e08ea4ed9188dfe6" translate="yes" xml:space="preserve">
          <source>Swaps the managed objects and associated deleters of &lt;code&gt;*this&lt;/code&gt; and another &lt;code&gt;unique_ptr&lt;/code&gt; object &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 및 다른 &lt;code&gt;unique_ptr&lt;/code&gt; 객체 &lt;code&gt;other&lt;/code&gt; 의 관리 객체 및 관련 삭제자를 교체 합니다 .</target>
        </trans-unit>
        <trans-unit id="a3d1188493c20906244358c4de7315ef4603ceeb" translate="yes" xml:space="preserve">
          <source>Swaps the state and the contents of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 의 상태와 내용을 교환 합니다.</target>
        </trans-unit>
        <trans-unit id="e9c2ea3679f877cd2374a4920f575171ae6dca64" translate="yes" xml:space="preserve">
          <source>Swaps the value in the position &lt;code&gt;first&lt;/code&gt; and the value in the position &lt;code&gt;last-1&lt;/code&gt; and makes the subrange &lt;code&gt;[first, last-1)&lt;/code&gt; into a</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 위치 의 값과 &lt;code&gt;last-1&lt;/code&gt; 위치의 값을 교환하고 하위 범위 &lt;code&gt;[first, last-1)&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="cb09cfe768ac5b78438066756631c25180f3bab3" translate="yes" xml:space="preserve">
          <source>Swaps the values of the elements the given iterators are pointing to.</source>
          <target state="translated">주어진 반복자가 가리키는 요소의 값을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="161bcece44d78f71a4f003092121d67d0ab5d642" translate="yes" xml:space="preserve">
          <source>Swaps two &lt;code&gt;variant&lt;/code&gt; objects.</source>
          <target state="translated">두 개의 &lt;code&gt;variant&lt;/code&gt; 객체를 교체 합니다.</target>
        </trans-unit>
        <trans-unit id="3f6ad43437efe3f1f457bebcc0c6ca88eeeb0171" translate="yes" xml:space="preserve">
          <source>Switch and goto are not allowed to jump into a branch of constexpr if statement.</source>
          <target state="translated">switch와 goto는 constexpr if 문의 분기로 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="84353db6d9e8f7c963a844d9880e97431ba69dd8" translate="yes" xml:space="preserve">
          <source>Symbols declared inside a namespace block are placed in a named scope that prevents them from being mistaken for identically-named symbols in other scopes.</source>
          <target state="translated">네임 스페이스 블록 내에 선언 된 심볼은 이름이 지정된 범위에 배치되어 다른 범위에서 동일한 이름의 심볼로 오인되는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="1708e8cb2dc2bc2a9736cd2e80f3b93534413b5d" translate="yes" xml:space="preserve">
          <source>Symlinks are not followed: if &lt;code&gt;old_p&lt;/code&gt; is a symlink, it is itself renamed, not its target. If &lt;code&gt;new_p&lt;/code&gt; is an existing symlink, it is itself erased, not its target.</source>
          <target state="translated">심볼릭 링크를 따르지 않음 : &lt;code&gt;old_p&lt;/code&gt; 가 심볼릭 링크 인 경우 대상이 아니라 이름이 바뀝니다. 경우 &lt;code&gt;new_p&lt;/code&gt; 는 기존의 심볼릭 링크이며, 그 자체가 목표를 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6603020623945d110a59e6535ec15891594b9d9" translate="yes" xml:space="preserve">
          <source>Synchronized blocks</source>
          <target state="translated">동기화 된 블록</target>
        </trans-unit>
        <trans-unit id="264cc97c04d4dd288f7b8d52441434b3d6f796e8" translate="yes" xml:space="preserve">
          <source>Synchronized blocks are not transactions (unlike the atomic blocks below) and may call transaction-unsafe functions.</source>
          <target state="translated">동기화 된 블록은 트랜잭션이 아니며 (아래의 원자 블록과 달리) 안전하지 않은 트랜잭션 기능을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d4065b4c63a635d07eda74bc4ecf84cec1ab74c" translate="yes" xml:space="preserve">
          <source>Synchronized output</source>
          <target state="translated">동기화 된 출력</target>
        </trans-unit>
        <trans-unit id="678d1aed3562116c3434743edc141fd1affe2688" translate="yes" xml:space="preserve">
          <source>Synchronizes the controlled character sequence (the buffers) with the associated character sequence.</source>
          <target state="translated">제어 된 문자 순서 (버퍼)를 연관된 문자 순서와 동기화합니다.</target>
        </trans-unit>
        <trans-unit id="b3405f14edc4065f66c994c9d5d69885a3408f74" translate="yes" xml:space="preserve">
          <source>Synchronizes the input buffer with the associated data source.</source>
          <target state="translated">입력 버퍼를 관련 데이터 소스와 동기화합니다.</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="0b4a6369cc47acd5ca23eef4e71b18705b9a52f1" translate="yes" xml:space="preserve">
          <source>Synospis</source>
          <target state="translated">Synospis</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="c3bad23f83eae7e38e2e9c0816279a52be410261" translate="yes" xml:space="preserve">
          <source>System error</source>
          <target state="translated">시스템 오류</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="cc46072906546a69cdff466e38285847984778ab" translate="yes" xml:space="preserve">
          <source>T and U model &lt;code&gt;Common&amp;lt;T, U&amp;gt;&lt;/code&gt; only if, given equality-preserving expressions &lt;code&gt;t1&lt;/code&gt;, &lt;code&gt;t2&lt;/code&gt;, &lt;code&gt;u1&lt;/code&gt; and &lt;code&gt;u2&lt;/code&gt; such that &lt;code&gt;decltype((t1))&lt;/code&gt; and &lt;code&gt;decltype((t2))&lt;/code&gt; are both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;decltype((u1))&lt;/code&gt; and &lt;code&gt;decltype((u2))&lt;/code&gt; are both &lt;code&gt;U&lt;/code&gt;,</source>
          <target state="translated">T 및 U 모델 &lt;code&gt;Common&amp;lt;T, U&amp;gt;&lt;/code&gt; 인 경우에만, 주어진 평등 보존 식 &lt;code&gt;t1&lt;/code&gt; , &lt;code&gt;t2&lt;/code&gt; , &lt;code&gt;u1&lt;/code&gt; 과 &lt;code&gt;u2&lt;/code&gt; 되도록 &lt;code&gt;decltype((t1))&lt;/code&gt; 과 &lt;code&gt;decltype((t2))&lt;/code&gt; 둘 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;decltype((u1))&lt;/code&gt; 및 &lt;code&gt;decltype((u2))&lt;/code&gt; 둘 &lt;code&gt;U&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f6300a60075c19a15c0be3e2d7fca0143ba49de7" translate="yes" xml:space="preserve">
          <source>T and U model &lt;code&gt;CommonReference&amp;lt;T, U&amp;gt;&lt;/code&gt; only if, given equality-preserving expressions &lt;code&gt;t1&lt;/code&gt;, &lt;code&gt;t2&lt;/code&gt;, &lt;code&gt;u1&lt;/code&gt; and &lt;code&gt;u2&lt;/code&gt; such that &lt;code&gt;decltype((t1))&lt;/code&gt; and &lt;code&gt;decltype((t2))&lt;/code&gt; are both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;decltype((u1))&lt;/code&gt; and &lt;code&gt;decltype((u2))&lt;/code&gt; are both &lt;code&gt;U&lt;/code&gt;,</source>
          <target state="translated">T 및 U 모델 &lt;code&gt;CommonReference&amp;lt;T, U&amp;gt;&lt;/code&gt; 주어진 평등 보존 식에만 &lt;code&gt;t1&lt;/code&gt; , &lt;code&gt;t2&lt;/code&gt; , &lt;code&gt;u1&lt;/code&gt; 과 &lt;code&gt;u2&lt;/code&gt; 되도록 &lt;code&gt;decltype((t1))&lt;/code&gt; 과 &lt;code&gt;decltype((t2))&lt;/code&gt; 모두 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;decltype((u1))&lt;/code&gt; 및 &lt;code&gt;decltype((u2))&lt;/code&gt; 둘 &lt;code&gt;U&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="b53c771c25daa8d30e1e76628baca20eb6a18d75" translate="yes" xml:space="preserve">
          <source>T is &lt;a href=&quot;copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; and &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;</source>
          <target state="translated">T는 &lt;a href=&quot;copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; 및 &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="660ec12bc6e5a1e7982309431632c35fe746b923" translate="yes" xml:space="preserve">
          <source>T is a specialization of std::pair</source>
          <target state="translated">T는 std :: pair의 전문화입니다</target>
        </trans-unit>
        <trans-unit id="bbf4ff0e53e541effb1e235b11c19303e4bc1591" translate="yes" xml:space="preserve">
          <source>T is not a specialization of std::pair</source>
          <target state="translated">T는 std :: pair의 전문화가 아닙니다</target>
        </trans-unit>
        <trans-unit id="9a2bbd623250bcdc2f4256f3c667f1311bd1ea45" translate="yes" xml:space="preserve">
          <source>T&amp;amp;</source>
          <target state="translated">T&amp;amp;</target>
        </trans-unit>
        <trans-unit id="6e5fca6c212eb7f30524d15a6dc91bbbc02e869b" translate="yes" xml:space="preserve">
          <source>T1, T2</source>
          <target state="translated">T1, T2</target>
        </trans-unit>
        <trans-unit id="f43137848b69e68deafd2185ce622e6a39c55145" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;ref&lt;code&gt;(&lt;/code&gt;object&lt;code&gt;) &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">T &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ref &lt;code&gt;(&lt;/code&gt; 객체 &lt;code&gt;) &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef9a78c2915f5528e6505eb949b5d58b569182c0" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">T &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ref &lt;code&gt;=&lt;/code&gt; &lt;code&gt;{ &lt;/code&gt; arg1, arg2, ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58403cefdd9cce7fb1b1abb61fee8f704e81cefc" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">T&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9431801b45a6671a5d7b975963f60b42024ed42f" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;ref&lt;code&gt;{&lt;/code&gt;arg1, arg2, ...&lt;code&gt;} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">T &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ref &lt;code&gt;{&lt;/code&gt; arg1, arg2, ... &lt;code&gt;} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a78744dbead2041514127933b52bd90d2354990" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;(&lt;/code&gt;object&lt;code&gt;) &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">T &lt;code&gt;&amp;amp;&lt;/code&gt; ref &lt;code&gt;(&lt;/code&gt; 객체 &lt;code&gt;) &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a52fff1be29878c152fa370ba2e77e69a8b66be8" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">T &lt;code&gt;&amp;amp;&lt;/code&gt; ref &lt;code&gt;=&lt;/code&gt; &lt;code&gt;{ &lt;/code&gt; arg1, arg2, ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dec3d4801dd098b9864d27b532b2c378206f708e" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="479a67ea0aebcaef66ddb9c2ab92083a0b606dd2" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">T &lt;code&gt;&amp;amp;&lt;/code&gt; ref &lt;code&gt;{ &lt;/code&gt; arg1, arg2, ... &lt;code&gt;} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee407094b576204d3e9ff1a1ef6f03f2f02a76f7" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;( &lt;/code&gt;arg1, arg2, ...&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">T &lt;code&gt;( &lt;/code&gt; arg1, arg2, ... &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f501dc40cc73438d58b2dbe4beef5b6d5c77c35b" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;( &lt;/code&gt;other&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">T &lt;code&gt;( &lt;/code&gt; 그 외 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="161a744b49ef6011a7ff0e37cc55aabe270180c8" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;()&lt;/code&gt;</source>
          <target state="translated">T&lt;code&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee6c63fec9c61b160ec6024c893178ae87a7b869" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;()&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">T&lt;code&gt;()&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29ee971a37413b2bbd54f8424d9f7659e197f9c2" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">T &lt;code&gt;{ &lt;/code&gt; arg1, arg2, ... &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fadaca5a938ae44efac53c8c00d48b1226cd5101" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;{} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">T &lt;code&gt;{} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="704b2797979fc2cf181e0b0022c2c1aa42a47fd9" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">T&lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f253ae3f8717d2493fc839cb70cdefdfc61ad41" translate="yes" xml:space="preserve">
          <source>TMP</source>
          <target state="translated">TMP</target>
        </trans-unit>
        <trans-unit id="ca5c7a79c25392e9261be4500084c2271c6fc9bc" translate="yes" xml:space="preserve">
          <source>TMP_MAX</source>
          <target state="translated">TMP_MAX</target>
        </trans-unit>
        <trans-unit id="0e6ee3d11aac2536c0d557b99d27e8db4bb8e627" translate="yes" xml:space="preserve">
          <source>Tag type used to identify the destroying delete form of &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt; 삭제 양식을 식별하는 데 사용되는 태그 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="c9d8b8edbb3576235d034b9dc26918683ab8bf3c" translate="yes" xml:space="preserve">
          <source>Tagged tuples</source>
          <target state="translated">태그가 달린 튜플</target>
        </trans-unit>
        <trans-unit id="8177f361688582b655f06aa8c611cdca7f6344ce" translate="yes" xml:space="preserve">
          <source>Takes a single argument &lt;code&gt;key&lt;/code&gt; of type &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 유형 의 단일 인수 &lt;code&gt;key&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="22c108f2e2290618334ae1bdda09c993c77d2243" translate="yes" xml:space="preserve">
          <source>Takes one template type parameter (additional template parameters are optional and allowed)</source>
          <target state="translated">하나의 템플릿 유형 매개 변수를 사용합니다 (추가 템플릿 매개 변수는 선택 사항이며 허용됨).</target>
        </trans-unit>
        <trans-unit id="8649cc453a7e81b2900bc0a1d7daee7ff8a39513" translate="yes" xml:space="preserve">
          <source>Takes two template type parameters (additional template parameters are optional and allowed)</source>
          <target state="translated">두 가지 템플릿 유형 매개 변수를 사용합니다 (추가 템플릿 매개 변수는 선택 사항이며 허용됨).</target>
        </trans-unit>
        <trans-unit id="14ae799bf325e27219d4ab3dc8ddcea9a6895d3c" translate="yes" xml:space="preserve">
          <source>Tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the real component, with period &amp;pi;i, and has poles of the first order along the real line, at coordinates (&amp;pi;(1/2 + n), 0). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.  Mathematical definition of the tangent is tan z =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b891e43fd714701379334fa86fe6cdd601c66db" translate="yes" xml:space="preserve">
          <source>Target access</source>
          <target state="translated">대상 액세스</target>
        </trans-unit>
        <trans-unit id="a578e2926fd3399f91a9bf9c3cd2f37d9c064719" translate="yes" xml:space="preserve">
          <source>Tarray&lt;code&gt;[&lt;/code&gt;N&lt;code&gt;] = {&lt;/code&gt;other&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">타 레이 &lt;code&gt;[&lt;/code&gt; N &lt;code&gt;] = {&lt;/code&gt; 기타 &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="df44c520fa404c47fb9c3a2fa460f9f6b5a92d1b" translate="yes" xml:space="preserve">
          <source>Template Meta Programming</source>
          <target state="translated">템플릿 메타 프로그래밍</target>
        </trans-unit>
        <trans-unit id="a5f5d8926b48548b87471b3b504f71aa41a2c5f9" translate="yes" xml:space="preserve">
          <source>Template Parameters</source>
          <target state="translated">템플릿 매개 변수</target>
        </trans-unit>
        <trans-unit id="45f8ada88f0feca34f6f71100875096825e76c58" translate="yes" xml:space="preserve">
          <source>Template aliases</source>
          <target state="translated">템플릿 별칭</target>
        </trans-unit>
        <trans-unit id="caca60d6981d2b988a9916fd062c816f7d6cd2ae" translate="yes" xml:space="preserve">
          <source>Template argument deduction</source>
          <target state="translated">템플릿 인수 공제</target>
        </trans-unit>
        <trans-unit id="d8261e155b7964ea0c5c0dbb05cec222ffaa203b" translate="yes" xml:space="preserve">
          <source>Template argument deduction attempts to determine template arguments (types for type template parameters &lt;code&gt;T&lt;/code&gt;i, templates for template template parameters &lt;code&gt;TT&lt;/code&gt;i, and values for non-type template parameters &lt;code&gt;I&lt;/code&gt;i), which can be substituted into each parameter &lt;code&gt;P&lt;/code&gt; to produce the type</source>
          <target state="translated">템플릿 인수 추론은 템플릿 인수 (유형 템플릿 매개 변수 유형 &lt;code&gt;T&lt;/code&gt; i, 템플릿 템플릿 매개 변수 유형 &lt;code&gt;TT&lt;/code&gt; i 및 비 유형 템플릿 매개 변수 &lt;code&gt;I&lt;/code&gt; i 값) 를 결정하려고 시도합니다. 이러한 유형은 각 매개 변수 &lt;code&gt;P&lt;/code&gt; 로 대체되어 유형을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc1107a314a5a9280ec0248d4fdc19f3040c0000" translate="yes" xml:space="preserve">
          <source>Template argument deduction for class templates</source>
          <target state="translated">클래스 템플릿에 대한 템플릿 인수 공제</target>
        </trans-unit>
        <trans-unit id="d1eb3324cb08470182136c50093a4f24735ee4ee" translate="yes" xml:space="preserve">
          <source>Template argument deduction for class templates takes place in declarations and in explicit cast expressions; see &lt;a href=&quot;deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt; for details.</source>
          <target state="translated">클래스 템플릿에 대한 템플릿 인수 공제는 선언과 명시 적 캐스트 표현식에서 발생합니다. 자세한 내용은 &lt;a href=&quot;deduction_guide&quot;&gt;클래스 템플릿 인수 공제&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8647f32c4462a684e87c28a515f4f9f8bb64fe31" translate="yes" xml:space="preserve">
          <source>Template argument deduction is also performed when the name of a class template is used as the type of an object being constructed:</source>
          <target state="translated">템플릿 인수 공제는 클래스 템플릿의 이름이 생성되는 객체의 유형으로 사용될 때도 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="94ba7965884a8778a58214e334e4b77b327dbbf2" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used during &lt;a href=&quot;function_template&quot;&gt;partial ordering of overloaded function templates&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;function_template&quot;&gt;오버로드 된 함수 템플릿을 부분적으로 정렬&lt;/a&gt; 하는 동안 템플릿 인수 공제가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="021b7fe06e4148b5e0923a0f571d8cfcb6d1d1c9" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used during &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, when generating specializations from a candidate template function. &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are the same as in a regular function call:</source>
          <target state="translated">템플릿 인수 추론은 후보 템플릿 함수에서 전문화를 생성 할 때 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결&lt;/a&gt; 중에 사용됩니다 . &lt;code&gt;P&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 일반 함수 호출에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a7ca94beae95ff3d5d1f84a863c4f4d7d10504e5" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used in &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt; of variables, when deducing the meaning of the &lt;b&gt;&lt;a href=&quot;auto&quot;&gt;auto specifier&lt;/a&gt;&lt;/b&gt; from the variable's initializer.</source>
          <target state="translated">템플릿 인수 공제는 변수의 이니셜 라이저에서 &lt;b&gt;&lt;a href=&quot;auto&quot;&gt;자동 지정자&lt;/a&gt;&lt;/b&gt; 의 의미를 추론 할 때 변수 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 에 사용됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ab922d0c264f2678cc14178cbe3b3a2aaa8b213" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used in &lt;a href=&quot;function_template#Explicit_instantiation&quot;&gt;explicit instantiations&lt;/a&gt;, &lt;a href=&quot;template_specialization&quot;&gt;explicit specializations&lt;/a&gt;, and those &lt;a href=&quot;friend#Template_friends&quot;&gt;friend declarations&lt;/a&gt; where the declarator-id happens to refer to a specialization of a function template (for example, &lt;code&gt;friend ostream&amp;amp; operator&amp;lt;&amp;lt; &amp;lt;&amp;gt; (...)&lt;/code&gt;), if not all template arguments are explicitly specified or defaulted, template argument deduction is used to determine which template's specialization is referred to.</source>
          <target state="translated">템플릿 인수 공제는 &lt;a href=&quot;function_template#Explicit_instantiation&quot;&gt;명시 적 인스턴스화&lt;/a&gt; , &lt;a href=&quot;template_specialization&quot;&gt;명시 적 특수화&lt;/a&gt; 및 선언자 ID가 함수 템플리트의 특수화 (예 : &lt;code&gt;friend ostream&amp;amp; operator&amp;lt;&amp;lt; &amp;lt;&amp;gt; (...)&lt;/code&gt; ) 를 참조 하는 &lt;a href=&quot;friend#Template_friends&quot;&gt;친구 선언&lt;/a&gt; 에서 사용 됩니다. 모든 템플릿 인수가 명시 적으로 지정되거나 기본값으로 지정되는 것은 아니며 템플릿 인수 공제를 사용하여 어떤 템플릿의 전문화가 참조되는지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="a3d42493811e1d60b682098b0b94617aea28bfcc" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used in declarations of &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt;, when deducing the meaning of the &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; specifier in the function's return type, from the return statement.</source>
          <target state="translated">템플릿 인수 추론은 함수의 반환 유형에서 &lt;a href=&quot;auto&quot;&gt;자동&lt;/a&gt; 지정자 의 의미를 return 문에서 추론 할 때 &lt;a href=&quot;functions&quot;&gt;함수&lt;/a&gt; 선언에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b8140b3f1c13e487f6303e128091147759d3453" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used when determining if a &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; template specialization matches a given placement form of &lt;code&gt;operator new&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;할당 해제 기능&lt;/a&gt; 템플리트 전문화가 주어진 &lt;code&gt;operator new&lt;/code&gt; 배치 양식 new 연산자 와 일치 하는지 판별 할 때 템플리트 인수 공제가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b30b6f11850a4b69e5c82442ee4977df7c35d742" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used when selecting &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; template arguments.</source>
          <target state="translated">템플릿 인수 공제는 &lt;a href=&quot;cast_operator&quot;&gt;사용자 정의 변환 함수&lt;/a&gt; 템플릿 인수를 선택할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="784e859c9570b3743b308b59311190ef5b96f971" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used when taking an &lt;a href=&quot;overloaded_address&quot;&gt;address of a overload set&lt;/a&gt;, which includes function templates.</source>
          <target state="translated">템플릿 인자 공제는 함수 템플릿을 포함 &lt;a href=&quot;overloaded_address&quot;&gt;하는 과부하 세트&lt;/a&gt; 의 주소를 취할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d46a2bb0daf61718a14fe7d647244512540a80df" translate="yes" xml:space="preserve">
          <source>Template argument deduction takes place after the function template &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; (which may involve &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;) and before &lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;template argument substitution&lt;/a&gt; (which may involve &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;) and &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="translated">템플릿 인수 추론은 함수 템플릿 &lt;a href=&quot;lookup&quot;&gt;이름 조회&lt;/a&gt; ( &lt;a href=&quot;adl&quot;&gt;인수 종속 조회를&lt;/a&gt; 포함 할 수 있음 ) 및 &lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;템플릿 인수 대체&lt;/a&gt; ( &lt;a href=&quot;sfinae&quot;&gt;SFINAE를&lt;/a&gt; 포함 할 수 있음 ) 및 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결&lt;/a&gt; 전에 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="9cc4c883fb9b243ff19f8109f0263f72db75c7ab" translate="yes" xml:space="preserve">
          <source>Template argument deduction takes place after the function template &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; (which may involve &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;) and before &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="translated">템플릿 인수 추론은 함수 템플릿 &lt;a href=&quot;lookup&quot;&gt;이름 조회&lt;/a&gt; ( &lt;a href=&quot;adl&quot;&gt;인수 종속 조회&lt;/a&gt; 가 포함될 수 있음 ) 후 및 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결&lt;/a&gt; 전에 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f2066a0f0eb39482438496a80f76796effd02820" translate="yes" xml:space="preserve">
          <source>Template argument lists</source>
          <target state="translated">템플릿 인수 목록</target>
        </trans-unit>
        <trans-unit id="e9449cf668b334bd388dd84fab3562fa1c4de76a" translate="yes" xml:space="preserve">
          <source>Template argument substitution</source>
          <target state="translated">템플릿 인수 대체</target>
        </trans-unit>
        <trans-unit id="a9799ad420934ea9199f67000a327e674f897581" translate="yes" xml:space="preserve">
          <source>Template arguments</source>
          <target state="translated">템플릿 인수</target>
        </trans-unit>
        <trans-unit id="f1d3b836e1b1c2984f2611a0dd02d3350041ad2a" translate="yes" xml:space="preserve">
          <source>Template arguments of a function template may be obtained from.</source>
          <target state="translated">함수 템플릿의 템플릿 인수는에서 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a6226598cf2e2ba90359b0f5427dce4a74f9148" translate="yes" xml:space="preserve">
          <source>Template declarations (&lt;a href=&quot;class_template&quot;&gt;class&lt;/a&gt;, &lt;a href=&quot;function_template&quot;&gt;function&lt;/a&gt;, and &lt;a href=&quot;variable_template&quot;&gt;variables&lt;/a&gt;(since C++14)) can appear inside a &lt;a href=&quot;class&quot;&gt;member specification&lt;/a&gt; of any class, struct, or union that aren't &lt;a href=&quot;class#Local_classes&quot;&gt;local classes&lt;/a&gt;.</source>
          <target state="translated">템플릿 선언 ( &lt;a href=&quot;class_template&quot;&gt;class&lt;/a&gt; , &lt;a href=&quot;function_template&quot;&gt;function&lt;/a&gt; 및 &lt;a href=&quot;variable_template&quot;&gt;변수&lt;/a&gt; (C ++ 14부터))은 &lt;a href=&quot;class#Local_classes&quot;&gt;로컬 클래스&lt;/a&gt; 가 아닌 클래스, 구조체 또는 공용체 의 &lt;a href=&quot;class&quot;&gt;멤버 사양&lt;/a&gt; 내에 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d3e4d385a0a47bf71b99c56c3cae38ff61af816" translate="yes" xml:space="preserve">
          <source>Template definition</source>
          <target state="translated">템플릿 정의</target>
        </trans-unit>
        <trans-unit id="1123fb8fb4f7d6610d019c3d869ba19bf4e459dc" translate="yes" xml:space="preserve">
          <source>Template friend operators</source>
          <target state="translated">템플릿 친구 운영자</target>
        </trans-unit>
        <trans-unit id="0369ea2ee9ff567354532b828c23169851ad589d" translate="yes" xml:space="preserve">
          <source>Template friends</source>
          <target state="translated">템플릿 친구</target>
        </trans-unit>
        <trans-unit id="954ab955f2a4e981e2a42027ac3b702c33779a3e" translate="yes" xml:space="preserve">
          <source>Template name</source>
          <target state="translated">템플릿 이름</target>
        </trans-unit>
        <trans-unit id="8f1c92453a495d014a71c7b055869feba9395bd3" translate="yes" xml:space="preserve">
          <source>Template non-type arguments</source>
          <target state="translated">템플릿 비 유형 인수</target>
        </trans-unit>
        <trans-unit id="4c635002659404447d4c7e2ab8abd988522ff7bb" translate="yes" xml:space="preserve">
          <source>Template parameter</source>
          <target state="translated">템플릿 매개 변수</target>
        </trans-unit>
        <trans-unit id="158f89ebdcef88d4b325fe5c789cce36a70e806b" translate="yes" xml:space="preserve">
          <source>Template parameter list</source>
          <target state="translated">템플릿 파라미터 목록</target>
        </trans-unit>
        <trans-unit id="6e20fe4a2857b8358f1ccd8985d9145db81f9591" translate="yes" xml:space="preserve">
          <source>Template parameter pack (appears in &lt;a href=&quot;type_alias&quot;&gt;alias template&lt;/a&gt;, &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt; and &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt; parameter lists).</source>
          <target state="translated">템플릿 매개 변수 팩 ( &lt;a href=&quot;type_alias&quot;&gt;별명 template&lt;/a&gt; , &lt;a href=&quot;class_template&quot;&gt;클래스 템플릿&lt;/a&gt; 및 &lt;a href=&quot;function_template&quot;&gt;함수 템플릿&lt;/a&gt; 매개 변수 목록에 나타남 ).</target>
        </trans-unit>
        <trans-unit id="84344a875baa3f63cc16a697c88ae0a96722df2e" translate="yes" xml:space="preserve">
          <source>Template parameter scope</source>
          <target state="translated">템플릿 매개 변수 범위</target>
        </trans-unit>
        <trans-unit id="169528213450496bf8081e48bcf48a1c7a41eda9" translate="yes" xml:space="preserve">
          <source>Template parameters</source>
          <target state="translated">템플릿 매개 변수</target>
        </trans-unit>
        <trans-unit id="0edccc1d1dd08de6c12a8dfe9520a49934e55347" translate="yes" xml:space="preserve">
          <source>Template parameters and arguments</source>
          <target state="translated">템플릿 매개 변수 및 인수</target>
        </trans-unit>
        <trans-unit id="98bc23c9456db71ba2bceaf2673d07299b1c8963" translate="yes" xml:space="preserve">
          <source>Template parameters and template arguments</source>
          <target state="translated">템플릿 매개 변수 및 템플릿 인수</target>
        </trans-unit>
        <trans-unit id="1e5e58ea037a2428a3329abe77243fae65638428" translate="yes" xml:space="preserve">
          <source>Template specializations of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the various view classes for hashing views.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 뷰에 대한 다양한 뷰 클래스를위한 std :: hash 의 템플릿 전문화</target>
        </trans-unit>
        <trans-unit id="4ec627c749ee6afdaa31903df6588d3408de6241" translate="yes" xml:space="preserve">
          <source>Template template arguments</source>
          <target state="translated">템플릿 템플릿 인수</target>
        </trans-unit>
        <trans-unit id="aa36d3224fbf7f05abd3bc8b6d198706bc54e99c" translate="yes" xml:space="preserve">
          <source>Template template parameter</source>
          <target state="translated">템플릿 템플릿 매개 변수</target>
        </trans-unit>
        <trans-unit id="e92b938702fb48797a6c0a42d95e30ea695a76f0" translate="yes" xml:space="preserve">
          <source>Template type argument cannot be deduced from the type of a non-type template argument:</source>
          <target state="translated">템플리트 유형 인수는 유형이 아닌 템플리트 인수의 유형에서 추론 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3272d29aacc7e69853e8119de9e0103ff80f8cb" translate="yes" xml:space="preserve">
          <source>Template type arguments</source>
          <target state="translated">템플릿 유형 인수</target>
        </trans-unit>
        <trans-unit id="1147ee04573a7cd067766e4b59abbd08612715a4" translate="yes" xml:space="preserve">
          <source>Templated entity</source>
          <target state="translated">템플릿 엔티티</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="4037e0f46eaecd5f8b76cb0d91a186ad57a8adf8" translate="yes" xml:space="preserve">
          <source>Templates are parametrized by one or more &lt;a href=&quot;template_parameters&quot;&gt;template parameters&lt;/a&gt;, of three kinds: type template parameters, non-type template parameters, and template template parameters.</source>
          <target state="translated">템플릿은 유형 템플릿 매개 변수, 비 유형 템플릿 매개 변수 및 템플릿 템플릿 매개 변수의 세 가지 종류 중 하나 이상의 &lt;a href=&quot;template_parameters&quot;&gt;템플릿 매개&lt;/a&gt; 변수로 매개 변수화됩니다.</target>
        </trans-unit>
        <trans-unit id="5dd47d975501c17b1a1ca16d301aae785c1f28b2" translate="yes" xml:space="preserve">
          <source>Temporary materialization</source>
          <target state="translated">임시 구체화</target>
        </trans-unit>
        <trans-unit id="87fdc9da30b92d4a08598b93f4ff2ca23dd3687d" translate="yes" xml:space="preserve">
          <source>Temporary materialization occurs in the following situations:</source>
          <target state="translated">다음과 같은 상황에서 임시 구체화가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0084b2c9da7ea557315059b130689d4497b1a547" translate="yes" xml:space="preserve">
          <source>Temporary object lifetime</source>
          <target state="translated">임시 객체 수명</target>
        </trans-unit>
        <trans-unit id="3b266d3f9ca89db726a727b7e50ba573b837fc17" translate="yes" xml:space="preserve">
          <source>Temporary objects are created when a prvalue is &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; so that it can be used as a glvalue, which occurs(since C++17) in the following situations:</source>
          <target state="translated">임시 값은 prvalue가 &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;구체화&lt;/a&gt; 될 때 생성 되어 다음 상황에서 발생하는 glvalue로 사용될 수 있습니다 (C ++ 17 이후).</target>
        </trans-unit>
        <trans-unit id="b57510c542f5a993e2618bd5690916e7fa2112f8" translate="yes" xml:space="preserve">
          <source>Terminates the current function and returns the specified value (if any) to its caller.</source>
          <target state="translated">현재 함수를 종료하고 지정된 값 (있는 경우)을 호출자에게 반환합니다.</target>
        </trans-unit>
        <trans-unit id="53cfde24b063bc9582b42597d027b0b8dffcfacd" translate="yes" xml:space="preserve">
          <source>Terminating functions</source>
          <target state="translated">종료 기능</target>
        </trans-unit>
        <trans-unit id="ddf71a1eb1ddc085dfce1004387d01a5ff9cc02b" translate="yes" xml:space="preserve">
          <source>Termination (e.g. &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt;), environment (e.g. &lt;code&gt;&lt;a href=&quot;utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;), signals (e.g. &lt;code&gt;&lt;a href=&quot;utility/program/raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">종료 (예 : &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; ), 환경 (예 : &lt;code&gt;&lt;a href=&quot;utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt; ), 신호 (예 : &lt;code&gt;&lt;a href=&quot;utility/program/raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e8c520bcd2f6ebd89c7fb968b08b7787bde36d95" translate="yes" xml:space="preserve">
          <source>Test for the stringstream's setbuf functionality.</source>
          <target state="translated">문자열 스트림의 setbuf 기능을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="22d0fe21a5525b59123ac9716f8c51966f199982" translate="yes" xml:space="preserve">
          <source>Tests two locales for equality. Named locales are considered equal if their names are equal. Unnamed locales are considered equal if they are copies of each other.</source>
          <target state="translated">두 로케일이 동일한 지 테스트합니다. 이름이 지정된 로케일은 이름이 동일한 경우 동일하다고 간주됩니다. 이름이없는 로케일은 서로의 사본 인 경우 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="660f799d669d5b7231f67c281132ba4f5cffb5db" translate="yes" xml:space="preserve">
          <source>Text file busy</source>
          <target state="translated">바쁜 텍스트 파일</target>
        </trans-unit>
        <trans-unit id="4ceaad237ce0d960d8aadd10ab31382cc8cdd772" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;pseudo destructor call&lt;/a&gt;, all scalar types meet the requirement of Destructible, while array types and reference types do not. Note that &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_destructible&lt;/a&gt;&lt;/code&gt; allows arrays and reference types.</source>
          <target state="translated">&lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;의사 소멸자 호출&lt;/a&gt; 덕분에 모든 스칼라 유형은 Destructible의 요구 사항을 충족하지만 배열 유형 및 참조 유형은 그렇지 않습니다. 참고 &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_destructible&lt;/a&gt;&lt;/code&gt; 배열과 참조 타입을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="991c0d6625cff5b8f151f80564a5913700404658" translate="yes" xml:space="preserve">
          <source>That is, depending on whether the destination type is wider or narrower, signed integers are sign-extended&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;implicit_cast#cite_note-1&quot;&gt;[footnote 1]&lt;/a&gt;&lt;/sup&gt; or truncated and unsigned integers are zero-extended or truncated respectively.</source>
          <target state="translated">즉, 대상 유형이 더 넓거나 좁은 지 여부에 따라 부호있는 정수는 부호 확장 &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;implicit_cast#cite_note-1&quot;&gt;[각주 1]&lt;/a&gt;&lt;/sup&gt; 이거나 잘리고 정수 부호없는 정수는 각각 0 확장되거나 잘립니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="7f99f89abc7064489bc92e58f82cd9a4f80c8567" translate="yes" xml:space="preserve">
          <source>The &quot;unspecified when and how&quot; wording makes it possible to &lt;a href=&quot;../../language/new#Allocation&quot;&gt;combine or optimize away heap allocations&lt;/a&gt; made by the standard library containers, even though such optimizations are disallowed for direct calls to &lt;code&gt;::operator new&lt;/code&gt;. For example, this is implemented by libc++ (&lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master@%7B2017-02-09%7D/include/memory#L1766-L1772&quot;&gt;[1]&lt;/a&gt; and &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master@%7B2017-02-09%7D/include/new#L211-L217&quot;&gt;[2]&lt;/a&gt;).</source>
          <target state="translated">&quot;지정되지 않은시기와 방법&quot;문구를 사용하면 &lt;code&gt;::operator new&lt;/code&gt; 에 대한 직접 호출에 대한 최적화가 허용되지 않더라도 표준 라이브러리 컨테이너에 의해 &lt;a href=&quot;../../language/new#Allocation&quot;&gt;작성된 힙 할당&lt;/a&gt; 을 결합하거나 최적화 할 수 있습니다 . 예를 들어, 이것은 libc ++ ( &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master@%7B2017-02-09%7D/include/memory#L1766-L1772&quot;&gt;[1]&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master@%7B2017-02-09%7D/include/new#L211-L217&quot;&gt;[2]&lt;/a&gt; )에 의해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec8b503e021f77990d950dce6036517b5a03066c" translate="yes" xml:space="preserve">
          <source>The 'c' in the name refers to &quot;character&quot; (&lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt;); &lt;code&gt;cerr&lt;/code&gt; means &quot;character error (stream)&quot; and &lt;code&gt;wcerr&lt;/code&gt; means &quot;wide character error (stream)&quot;</source>
          <target state="translated">이름에서 'c'는 &quot;문자&quot;( &lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt; )를 나타냅니다 . &lt;code&gt;cerr&lt;/code&gt; 은 &quot;문자 오류 (스트림)&quot;를 의미 하고 &lt;code&gt;wcerr&lt;/code&gt; 은 &quot;와이드 문자 오류 (스트림)&quot;를 의미</target>
        </trans-unit>
        <trans-unit id="8a8fecf5384bb58f5f1f3c578eb7a6b317ee79fc" translate="yes" xml:space="preserve">
          <source>The 'c' in the name refers to &quot;character&quot; (&lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt;); &lt;code&gt;cin&lt;/code&gt; means &quot;character input&quot; and &lt;code&gt;wcin&lt;/code&gt; means &quot;wide character input&quot;</source>
          <target state="translated">이름에서 'c'는 &quot;문자&quot;( &lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt; )를 나타냅니다 . &lt;code&gt;cin&lt;/code&gt; 은 &quot;문자 입력&quot;을 의미 하고 &lt;code&gt;wcin&lt;/code&gt; 은 &quot;와이드 문자 입력&quot;을 의미</target>
        </trans-unit>
        <trans-unit id="7f79cbf5556a15f45028f844ce3055e0744314bd" translate="yes" xml:space="preserve">
          <source>The 'c' in the name refers to &quot;character&quot; (&lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt;); &lt;code&gt;clog&lt;/code&gt; means &quot;character log&quot; and &lt;code&gt;wclog&lt;/code&gt; means &quot;wide character log&quot;</source>
          <target state="translated">이름에서 'c'는 &quot;문자&quot;( &lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt; )를 나타냅니다 . &lt;code&gt;clog&lt;/code&gt; 는 &quot;문자 로그&quot;를 의미 하고 &lt;code&gt;wclog&lt;/code&gt; 는 &quot;와이드 문자 로그&quot;를 의미</target>
        </trans-unit>
        <trans-unit id="b39ed7ebcf3324b6b14cde3229744c18d31dabe6" translate="yes" xml:space="preserve">
          <source>The 'c' in the name refers to &quot;character&quot; (&lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt;); &lt;code&gt;cout&lt;/code&gt; means &quot;character output&quot; and &lt;code&gt;wcout&lt;/code&gt; means &quot;wide character output&quot;</source>
          <target state="translated">이름에서 'c'는 &quot;문자&quot;( &lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt; )를 나타냅니다 . &lt;code&gt;cout&lt;/code&gt; 은 &quot;문자 출력&quot;을 의미 하고 &lt;code&gt;wcout&lt;/code&gt; 은 &quot;와이드 문자 출력&quot;을 의미</target>
        </trans-unit>
        <trans-unit id="eff5189172eae02363633052a355d76231baa69f" translate="yes" xml:space="preserve">
          <source>The (1,3) versions use &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the values, the (2,4) versions use the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">(1,3) 버전은 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 를 사용하여 값을 비교하고 (2,4) 버전은 주어진 비교 함수 &lt;code&gt;comp&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="dafcf0eaeb756f05d2a7ee64ed4d401cfeaa9f16" translate="yes" xml:space="preserve">
          <source>The (1,3) versions use &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the values, whereas the (2,4) versions use the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">(1,3) 버전은 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 를 사용하여 값을 비교하는 반면 (2,4) 버전은 주어진 비교 함수 &lt;code&gt;comp&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="72d965e72fed1724b83c60ac53dfc7b1420fc061" translate="yes" xml:space="preserve">
          <source>The 10000th consecutive invocation of a default-constructed &lt;code&gt;std::mt19937&lt;/code&gt; is required to produce the value &lt;code&gt;4123659995&lt;/code&gt;.</source>
          <target state="translated">기본-건설의 10,000번째 연속 호출 &lt;code&gt;std::mt19937&lt;/code&gt; 값을 생성하는 데 필요한 &lt;code&gt;4123659995&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e984147075a8e19185c784f917a48a1255282c00" translate="yes" xml:space="preserve">
          <source>The 10000th consecutive invocation of a default-constructed &lt;code&gt;std::mt19937_64&lt;/code&gt; is required to produce the value &lt;code&gt;9981545732273789042&lt;/code&gt;.</source>
          <target state="translated">기본-건설의 10,000번째 연속 호출 &lt;code&gt;std::mt19937_64&lt;/code&gt; 값을 생성하는 데 필요한 &lt;code&gt;9981545732273789042&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="22a2a7106aa748d02361b5b68e6c3538fa1a14a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../language/implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from floating-point to integral types also rounds towards zero, but is limited to the values that can be represented by the target type.</source>
          <target state="translated">부동 소수점에서 정수 유형으로 의 &lt;a href=&quot;../../language/implicit_cast&quot;&gt;암시 적 변환&lt;/a&gt; 도 0으로 반올림되지만 대상 유형으로 표시 할 수있는 값으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="bc7ca13e4dd512b9edc6ada98b8b9e3bb683e777" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;built-in operator &amp;lt;=&amp;gt;&lt;/a&gt; between floating-point values uses this ordering: the positive zero and the negative zero compare &lt;code&gt;equivalent&lt;/code&gt;, but can be distinguished, and NaN values compare &lt;code&gt;unordered&lt;/code&gt; with any other value.</source>
          <target state="translated">부동 소수점 값 사이 의 &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;내장 연산자 &amp;lt;=&amp;gt;&lt;/a&gt; 는이 순서를 사용합니다. 양의 0과 음의 0은 &lt;code&gt;equivalent&lt;/code&gt; 비교 하지만 구별 할 수 있으며 NaN 값은 다른 값과 &lt;code&gt;unordered&lt;/code&gt; 로 비교 됩니다.</target>
        </trans-unit>
        <trans-unit id="d000eea4291a415d9c69d5748511309341684c13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; to use.</source>
          <target state="translated">&lt;a href=&quot;../../named_req/allocator&quot;&gt;할당자는&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd79d33be09689ea727915a9822da9a6d0521504" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../algorithm&quot;&gt;parallel algorithms&lt;/a&gt; from the C++ standard library block with forward progress delegation on the completion of an unspecified set of library-managed threads.</source>
          <target state="translated">지정되지 않은 라이브러리 관리 스레드 세트의 완료시 순방향 진행 위임이있는 C ++ 표준 라이브러리 블록 의 &lt;a href=&quot;../algorithm&quot;&gt;병렬 알고리즘&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f384097a3ae4467a606ee3b68db7ca3598cd80c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basic_istream/sentry&quot;&gt;&lt;code&gt;basic_istream::sentry&lt;/code&gt;&lt;/a&gt; constructor, executed at the beginning of every formatted input function: unless the &lt;code&gt;skipws&lt;/code&gt; bit is unset (e.g. by issuing &lt;code&gt;&lt;a href=&quot;../manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt;), sentry reads and discards the leading whitespace characters. If the end of the input stream is reached during this operation, both &lt;code&gt;eofbit&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt; are set, and no input takes place.</source>
          <target state="translated">&lt;a href=&quot;../basic_istream/sentry&quot;&gt; &lt;code&gt;basic_istream::sentry&lt;/code&gt; &lt;/a&gt; 모든 포맷 입력 기능의 시작 부분에 실행 생성자, 상기하지 않는 &lt;code&gt;skipws&lt;/code&gt; 비트가 설정 (예 : 실행하여 &lt;code&gt;&lt;a href=&quot;../manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt; ), 보초는 최고의 공백 문자를 읽고 삭제합니다. 이 작업 중에 입력 스트림의 끝에 도달하면 &lt;code&gt;eofbit&lt;/code&gt; 와 &lt;code&gt;failbit&lt;/code&gt; 가 모두 설정되고 입력이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="199af1ea4bea41c373d1d6f366f0d224e116dc92" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basic_istream/sentry&quot;&gt;&lt;code&gt;basic_istream::sentry&lt;/code&gt;&lt;/a&gt; constructor, executed at the beginning of every input function, if either &lt;code&gt;eofbit&lt;/code&gt; or &lt;code&gt;badbit&lt;/code&gt; is already set on the stream, or if the end of stream is encountered while consuming leading whitespace.</source>
          <target state="translated">&lt;a href=&quot;../basic_istream/sentry&quot;&gt; &lt;code&gt;basic_istream::sentry&lt;/code&gt; &lt;/a&gt; 어느 경우 생성자는 모든 입력 기능의 시작에서 실행 &lt;code&gt;eofbit&lt;/code&gt; 또는 &lt;code&gt;badbit&lt;/code&gt; 이 이미 스트림에 설정되어 있거나 선두 공백을 소모하면서 스트림의 끝이 발생했을 경우.</target>
        </trans-unit>
        <trans-unit id="d96f80b80220186129523ee520a0da3f49221e7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basic_ostream/sentry&quot;&gt;&lt;code&gt;basic_ostream::sentry&lt;/code&gt;&lt;/a&gt; constructor, executed at the beginning of every output function, under implementation-defined conditions.</source>
          <target state="translated">&lt;a href=&quot;../basic_ostream/sentry&quot;&gt; &lt;code&gt;basic_ostream::sentry&lt;/code&gt; &lt;/a&gt; 구현 정의 조건마다 출력 기능의 시작에서 실행 구성자.</target>
        </trans-unit>
        <trans-unit id="67ebf820ed34aa7b8ca3afede0441918c21cb408" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../language/converting_constructor&quot;&gt;converting constructor&lt;/a&gt; template of &lt;code&gt;std::default_delete&lt;/code&gt; makes possible the implicit conversion from &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Derived&amp;gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Base&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::default_delete&lt;/code&gt; 의 &lt;a href=&quot;../language/converting_constructor&quot;&gt;변환 생성자&lt;/a&gt; 템플리트는 std :: &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Derived&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Base&amp;gt;&lt;/code&gt; 로의 암시 적 변환을 가능하게합니다 .</target>
        </trans-unit>
        <trans-unit id="cb78bdf488984400241ded004fa4fc61ae9f25cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../language/new&quot;&gt;new-expression&lt;/a&gt; is the only way to create an object or an array of objects with dynamic storage duration, that is, with lifetime not restricted to the scope in which it is created. A new-expression obtains storage by calling an allocation function. A &lt;a href=&quot;../language/delete&quot;&gt;delete-expression&lt;/a&gt; destroys a most derived object or an array created by a new-expression and calls the deallocation function. The default allocation and deallocation functions, along with related functions, types, and objects, are declared in the header &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../language/new&quot;&gt;새로운 표현은&lt;/a&gt; 그것이 생성 된 범위에 한정되지 수명과 객체이거나 동적 저장 기간을 가진 오브젝트의 배열을 생성 할 수있는 유일한 방법이다. 새로운 표현식은 할당 함수를 호출하여 스토리지를 얻습니다. &lt;a href=&quot;../language/delete&quot;&gt;삭제 표현은&lt;/a&gt; 가장 파생 된 객체 또는 새로운 표현에 의해 생성 된 배열을 파괴하여 해제 함수를 호출한다. 기본 할당 및 할당 취소 기능과 관련 함수, 유형 및 객체는 &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; 헤더에 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="309aca672b29807c4114477b4882bf35957b6215" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../types#Type_modifications&quot;&gt;type modifications and transformations&lt;/a&gt; all satisfy &lt;strong&gt;TransformationTrait&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;../types#Type_modifications&quot;&gt;형 수정 및 변형&lt;/a&gt; 모두 충족 &lt;strong&gt;TransformationTrait를&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="51a3397d80b8ebe672bc53b120dbbf572747d85e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;alignas&quot;&gt;&lt;code&gt;alignas&lt;/code&gt; specifier&lt;/a&gt; is a part of the attribute specifier sequence, although it has different syntax. It may appear where the &lt;code&gt;[[...]]&lt;/code&gt; attributes appear and may mix with them (provided it is used where &lt;code&gt;alignas&lt;/code&gt; is permitted).</source>
          <target state="translated">&lt;a href=&quot;alignas&quot;&gt; &lt;code&gt;alignas&lt;/code&gt; 지정자&lt;/a&gt; 가 다른 구문을 갖지만, 속성 지정 시퀀스의 일부이다. &lt;code&gt;[[...]]&lt;/code&gt; 속성 이 나타나는 곳에 나타날 수 있으며 그것들과 혼합 될 수 있습니다 ( &lt;code&gt;alignas&lt;/code&gt; 이 허용 되는 경우 사용됨 ).</target>
        </trans-unit>
        <trans-unit id="29ea1c4abb344140ca1bcb71ac4c71ee678785ca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;attributes/contract&quot;&gt;contract attributes&lt;/a&gt; use a special attribute syntax. Each contract attribute must be in its own attribute specifier (&lt;code&gt;[[]]&lt;/code&gt;). Multiple contract attribute specifiers can be applied to the same entity.</source>
          <target state="translated">&lt;a href=&quot;attributes/contract&quot;&gt;계약 속성은&lt;/a&gt; 특별한 속성 구문을 사용합니다. 각 계약 속성은 자체 속성 지정자 ( &lt;code&gt;[[]]&lt;/code&gt; )에 있어야합니다 . 여러 계약 속성 지정자를 동일한 엔터티에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0514e99e818aef28d34a3920ed0faa60a58c9c07" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;break&quot;&gt;break&lt;/a&gt; statement, when encountered in statement exits the switch statement:</source>
          <target state="translated">&lt;a href=&quot;break&quot;&gt;휴식&lt;/a&gt; 문에서 발생하는 문은 switch 문을 종료합니다 :</target>
        </trans-unit>
        <trans-unit id="0f7e1b4bfb4e870274e353c9c7a72c2da4c1c7a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;constraints&quot;&gt;requires-expressions&lt;/a&gt; are also unevaluated expressions.</source>
          <target state="translated">&lt;a href=&quot;constraints&quot;&gt;필요-표현은&lt;/a&gt; 또한 평가되지 않은 표현이다.</target>
        </trans-unit>
        <trans-unit id="4bd00385fb62722a0d9108affa4f29eb6e8ab044" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;duration/zero&quot;&gt;zero&lt;/a&gt;, &lt;a href=&quot;duration/min&quot;&gt;min&lt;/a&gt;, and &lt;a href=&quot;duration/max&quot;&gt;max&lt;/a&gt; methods in &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; forward their work to these methods.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 의 &lt;a href=&quot;duration/zero&quot;&gt;zero&lt;/a&gt; , &lt;a href=&quot;duration/min&quot;&gt;min&lt;/a&gt; 및 &lt;a href=&quot;duration/max&quot;&gt;max&lt;/a&gt; 메소드는 이 메소드로 작업을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f913643a12b0d0e00b4ddb338d2afdcf084e81f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;explicit&quot;&gt;explicit bool conversion&lt;/a&gt; can also be used to resolve the safe bool problem.</source>
          <target state="translated">&lt;a href=&quot;explicit&quot;&gt;명시 적 부울 변환은&lt;/a&gt; 또한 안전 부울 문제를 해결하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e2f5aca60ecf6a78733b0021ae9fcf6d42f4b7f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;explicit_cast&quot;&gt;explicit cast&lt;/a&gt; (C-style and function-style) allows casting from a derived lvalue to reference to its private base, or from a pointer to derived to a pointer to its private base.</source>
          <target state="translated">&lt;a href=&quot;explicit_cast&quot;&gt;명시 적 캐스트&lt;/a&gt; (C-스타일과 기능 스타일은)는 개인베이스에 참조로 파생 좌변에서 캐스팅 할 수 있습니다, 또는 포인터로부터 개인베이스에 대한 포인터로 파생합니다.</target>
        </trans-unit>
        <trans-unit id="9dbf4257871ad796d81b6aa61568a2a7f80c91ba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/concurrency&quot;&gt;Concurrency TS&lt;/a&gt; offers atomic smart pointer classes &lt;code&gt;atomic_shared_ptr&lt;/code&gt; and &lt;code&gt;atomic_weak_ptr&lt;/code&gt; as a replacement for the use of these functions.</source>
          <target state="translated">&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/concurrency&quot;&gt;동시성 TS는&lt;/a&gt; 원자 스마트 포인터 클래스가 제공하는 &lt;code&gt;atomic_shared_ptr&lt;/code&gt; 및 &lt;code&gt;atomic_weak_ptr&lt;/code&gt; 이 기능의 사용을 대체.</target>
        </trans-unit>
        <trans-unit id="08ddf054b9d98118850acc7743563e5e0b4e9519" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/lgamma.html&quot;&gt;POSIX version of lgamma&lt;/a&gt; is not thread-safe: each execution of the function stores the sign of the gamma function of &lt;code&gt;arg&lt;/code&gt; in the static external variable &lt;code&gt;signgam&lt;/code&gt;. Some implementations provide &lt;code&gt;lgamma_r&lt;/code&gt;, which takes a pointer to user-provided storage for singgam as the second parameter, and is thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9eae232676e01d5fd6170668f3da0c95ea6118" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/intrusive/pointer_traits.html&quot;&gt;Boost.Intrusive library version&lt;/a&gt; of this function returns &lt;code&gt;pointer(&lt;a href=&quot;../addressof&quot;&gt;std::addressof&lt;/a&gt;(r))&lt;/code&gt; if Ptr::pointer_to does not exist.</source>
          <target state="translated">이 함수 의 &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/intrusive/pointer_traits.html&quot;&gt;Boost.Intrusive 라이브러리 버전&lt;/a&gt; 은 Ptr :: pointer_to가없는 경우 &lt;code&gt;pointer(&lt;a href=&quot;../addressof&quot;&gt;std::addressof&lt;/a&gt;(r))&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="010635233092fde8e055bbf80d2c12bb918dcd10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Pendulum_(mathematics)&quot;&gt;period of a pendulum&lt;/a&gt; of length l, given acceleration due to gravity g, and initial angle &amp;theta; equals 4&amp;radic;l/gK(sin2</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Pendulum_(mathematics)&quot;&gt;진자의주기&lt;/a&gt; 길이 (L)의은, 중력 가속도를 g로 주어 초기 각도 &amp;theta;는 4&amp;radic;l / GK (sin2 같다</target>
        </trans-unit>
        <trans-unit id="3c1b8fdbe6f999bd3bde041a408fe4f61954baca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.boost.org/doc/libs/1_69_0/doc/html/boost/container/vector.html&quot;&gt;Boost.Container version of &lt;code&gt;vector&lt;/code&gt;&lt;/a&gt; does not specialize for &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.boost.org/doc/libs/1_69_0/doc/html/boost/container/vector.html&quot;&gt; &lt;code&gt;vector&lt;/code&gt; &lt;/a&gt; 의 Boost.Container 버전은 &lt;code&gt;bool&lt;/code&gt; 을 전문화하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="25b6c7d0f7829048a23706dba4d464728152672c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; of a union member begins when the member is made active. If another member was active previously, its lifetime ends.</source>
          <target state="translated">멤버가 활성화되면 노조 멤버 의 &lt;a href=&quot;lifetime&quot;&gt;수명&lt;/a&gt; 이 시작됩니다. 다른 멤버가 이전에 활성화 된 경우 수명이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="75569aea6242143bafa72b9244654b2f1ffee9b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;locale&quot;&gt;localizations library&lt;/a&gt; provides support for string conversions (e.g. &lt;code&gt;&lt;a href=&quot;locale/wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;std::toupper&lt;/code&gt;) as well as functions that classify characters (e.g. &lt;code&gt;std::isspace&lt;/code&gt; or &lt;code&gt;std::isdigit&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;locale&quot;&gt;지역화 라이브러리는&lt;/a&gt; 문자열 변환을 지원합니다 (예 : &lt;code&gt;&lt;a href=&quot;locale/wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;std::toupper&lt;/code&gt; )뿐만 아니라 함수로 분류 할 문자 (예 : &lt;code&gt;std::isspace&lt;/code&gt; 또는 &lt;code&gt;std::isdigit&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6392fcea478e829169e87444fc4c60b8cb4b9864" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;namespace#Using-declarations&quot;&gt;using-declaration&lt;/a&gt; carries over the set of known default arguments, and if more arguments are added later to the function's namespace, those defaults are also visible anywhere the using-declaration is visible.</source>
          <target state="translated">&lt;a href=&quot;namespace#Using-declarations&quot;&gt;사용하여 선언은&lt;/a&gt; 알려진 기본 인수의 집합을 통해 전달, 그리고 더 많은 인수가 함수의 네임 스페이스에 나중에 추가하는 경우, 그 기본값은 사용 선언이 보이는 가시 어느 곳도 있습니다.</target>
        </trans-unit>
        <trans-unit id="69cb2d817c289d67773a04ab2bae52ceb82957ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sizeof...&quot;&gt;sizeof...&lt;/a&gt; operator is classified as a pack expansion as well.</source>
          <target state="translated">&lt;a href=&quot;sizeof...&quot;&gt;는 sizeof ...&lt;/a&gt; 연산자뿐만 아니라 팩 확장으로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="9047dc8b99e11f74d359b855ae4a29a09c1fbb0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer is not allowed in default arguments:</source>
          <target state="translated">&lt;a href=&quot;this&quot;&gt;이&lt;/a&gt; 포인터는 기본적 인수에서 허용되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="ebb064a9427a1fa7970d44bed331bc5281f03c83" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types&quot;&gt;types&lt;/a&gt;&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, and &lt;code&gt;signed char&lt;/code&gt; use one byte for both storage and &lt;a href=&quot;objects&quot;&gt;value representation&lt;/a&gt;. The number of bits in a byte is accessible as &lt;code&gt;&lt;a href=&quot;../types/climits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;unsigned char&amp;gt;::digits&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;types&quot;&gt;종류의 &lt;/a&gt; &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; 및 &lt;code&gt;signed char&lt;/code&gt; 저장 및 사용 모두 하나의 바이트 &lt;a href=&quot;objects&quot;&gt;값으로 표현&lt;/a&gt; . 바이트의 비트 수는 &lt;code&gt;&lt;a href=&quot;../types/climits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;unsigned char&amp;gt;::digits&lt;/code&gt; 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7deaf166831ce5c7a13969ac2e92d63024ee5c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#define&lt;/code&gt; directives define the identifier as macro, that is instruct the compiler to replace all successive occurrences of identifier with replacement-list, which can be optionally additionally processed. If the identifier is already defined as any type of macro, the program is ill-formed unless the definitions are identical.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 지시 컴파일러가 임의로 추가 가공 될 수 교체리스트와 식별자의 모든 연속적인 발생을 교체하는 지시 인 매크로 같은 식별자를 정의한다. 식별자가 이미 모든 유형의 매크로로 정의 된 경우, 정의가 동일하지 않으면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="287587d438d07ca409150386008ca217010582fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#undef&lt;/code&gt; directive undefines the identifier, that is cancels previous definition of the identifier by &lt;code&gt;#define&lt;/code&gt; directive. If the identifier does not have associated macro, the directive is ignored.</source>
          <target state="translated">&lt;code&gt;#undef&lt;/code&gt; 를의 지시자가 식별자의 이전 정의를 취소되는 식별자 정의를 해제 &lt;code&gt;#define&lt;/code&gt; 지시자. 식별자에 연관된 매크로가 없으면 지시문이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b5eee63a87c12a11bb1c8a0a0749af63ec71ad7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/&lt;/code&gt; character is used as the directory separator.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 문자 디렉토리 세퍼레이터로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="29ef5aafaaf469702d40ab87247fd921b47e112e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; class includes &lt;code&gt;std::bitset::reference&lt;/code&gt; as a publicly-accessible nested class. This class is used as a proxy object to allow users to interact with individual bits of a bitset, since standard C++ types (like references and pointers) are not built with enough precision to specify individual bits.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; 클래스는 포함 &lt;code&gt;std::bitset::reference&lt;/code&gt; 공개적으로 접근 가능한 중첩 클래스로. 이 클래스는 표준 C ++ 유형 (참조 및 포인터와 같은)이 개별 비트를 지정하기에 충분한 정밀도로 구축되지 않기 때문에 사용자가 비트 세트의 개별 비트와 상호 작용할 수 있도록 프록시 객체로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ff91fcef49846bb86b26acc3f9bb92f3953489ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; type of the clock. C1 and C2 shall refer to the same epoch.</source>
          <target state="translated">시계 의 &lt;code&gt;&lt;a href=&quot;../chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; 유형입니다. C1과 C2는 같은 시대를 지칭해야한다.</target>
        </trans-unit>
        <trans-unit id="af79d3235b89d256527053836a204ade24c05400" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; literal with the real part zero and imaginary part &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; 실수 부 제로 허수 부분의 리터럴 &lt;code&gt;arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2731448977f0cbf91abc6a9042bd867718792a0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; class should be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, and &lt;a href=&quot;../../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 클래스는해야 &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; 와 &lt;a href=&quot;../../named_req/destructible&quot;&gt;파괴 가능한&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="256311ca8ebf43604948d87d24e1085571bf6f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; I/O manipulator and &lt;a href=&quot;../../locale/money_get/get&quot;&gt;&lt;code&gt;money_get::get&lt;/code&gt;&lt;/a&gt; function, if the end of the stream is reached before the last character needed to parse the expected monetary value was processed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; I / O 조작 및 &lt;a href=&quot;../../locale/money_get/get&quot;&gt; &lt;code&gt;money_get::get&lt;/code&gt; &lt;/a&gt; 기능, 예상되는 금전적 가치를 구문 분석하는 데 필요한 마지막 문자가 처리되기 전에 스트림의 마지막에 이르렀을 경우.</target>
        </trans-unit>
        <trans-unit id="855c845c4c3a199f90f14aaf76eca19e27247859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; I/O manipulator and any of the &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; parsing functions: &lt;a href=&quot;../../locale/time_get/get&quot;&gt;&lt;code&gt;time_get::get&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../locale/time_get/get_time&quot;&gt;&lt;code&gt;time_get::get_time&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../locale/time_get/get_date&quot;&gt;&lt;code&gt;time_get::get_date&lt;/code&gt;&lt;/a&gt;, etc., if the end of the stream is reached before the last character needed to parse the expected date/time value was processed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; I / O 조작하는 사람과의 &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; 기능 분석 : &lt;a href=&quot;../../locale/time_get/get&quot;&gt; &lt;code&gt;time_get::get&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../locale/time_get/get_time&quot;&gt; &lt;code&gt;time_get::get_time&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../locale/time_get/get_date&quot;&gt; &lt;code&gt;time_get::get_date&lt;/code&gt; &lt;/a&gt; 등, 스트림의 마지막이 마지막 문자 앞에 이르렀을 경우 예상 날짜 / 시간 값을 구문 분석하는 데 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="1b35cd52c40c238d2e9a4ff26960212d9fbf9298" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../range/bidirectionalrange&quot;&gt;BidirectionalRange&lt;/a&gt;&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../range/bidirectionalrange&quot;&gt;BidirectionalRange&lt;/a&gt;&lt;/code&gt; 의 개념의 정교화하고있다 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 있는 &lt;code&gt;ranges::begin&lt;/code&gt; 반환에게의 모델 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;BidirectionalIterator&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1bf354f8099857c98c4c162bdb943e1320618bc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../range/forwardrange&quot;&gt;ForwardRange&lt;/a&gt;&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../range/forwardrange&quot;&gt;ForwardRange&lt;/a&gt;&lt;/code&gt; 의 개념의 정교화하고있다 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 있는 &lt;code&gt;ranges::begin&lt;/code&gt; 반환에게의 모델 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ForwardIterator&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c51d556d7d72ec5f4c07fd94f97a33c4dda222f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../range/inputrange&quot;&gt;InputRange&lt;/a&gt;&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../range/inputrange&quot;&gt;InputRange&lt;/a&gt;&lt;/code&gt; 의 개념의 정교화하고있다 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 있는 &lt;code&gt;ranges::begin&lt;/code&gt; 반환에게의 모델 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;InputIterator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8dea9bfb485f84e3103496966c620db434adb7a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../range/outputrange&quot;&gt;OutputRange&lt;/a&gt;&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/OutputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;OutputIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../range/outputrange&quot;&gt;OutputRange&lt;/a&gt;&lt;/code&gt; 의 개념의 정교화하고있다 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 있는 &lt;code&gt;ranges::begin&lt;/code&gt; 반환에게의 모델 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/OutputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;OutputIterator&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="582b57be33c23d5adc91c4522e8fff2b7e87b04d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../range/randomaccessrange&quot;&gt;RandomAccessRange&lt;/a&gt;&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../range/randomaccessrange&quot;&gt;RandomAccessRange&lt;/a&gt;&lt;/code&gt; 의 개념의 정교화하고있다 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 있는 &lt;code&gt;ranges::begin&lt;/code&gt; 반환에게의 모델 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;RandomAccessIterator&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f98db1655ef0f271fb435a6239101324463dabb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; specialization defines &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; as a publicly-accessible nested class. &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; proxies the behavior of references to a single bit in &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 전문성을 정의하는 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; 공개적으로 접근 가능한 중첩 클래스로. &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 의 단일 비트에 대한 참조 동작을 프록시합니다 .</target>
        </trans-unit>
        <trans-unit id="7bea81b9244b70065719191c6c0629d573941f04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 문자.</target>
        </trans-unit>
        <trans-unit id="d4172c516b68500c9770e2bdf9941b5988e6ff32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;sputc&quot;&gt;sputc()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sputn&quot;&gt;sputn()&lt;/a&gt;&lt;/code&gt; call this function in case of an overflow (&lt;code&gt;pptr() == nullptr&lt;/code&gt; or &lt;code&gt;pptr() &amp;gt;= epptr()&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sputc&quot;&gt;sputc()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;sputn&quot;&gt;sputn()&lt;/a&gt;&lt;/code&gt; 오버 플로우의 경우이 함수를 호출 ( &lt;code&gt;pptr() == nullptr&lt;/code&gt; 또는 &lt;code&gt;pptr() &amp;gt;= epptr()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f6967c213bc2e93fe61b8bd41eb28f5ebb0dfd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CommonRange&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; and &lt;code&gt;ranges::end&lt;/code&gt; return the same type (e.g. all standard library containers).</source>
          <target state="translated">&lt;code&gt;CommonRange&lt;/code&gt; 의 개념의 정교화하고있다 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 있는 &lt;code&gt;ranges::begin&lt;/code&gt; 과 &lt;code&gt;ranges::end&lt;/code&gt; 동일한 유형 (예 : 모든 표준 라이브러리 컨테이너)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0abeef975f9212d53e66b1527efeb888666e8efc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Constructible&lt;/code&gt; concept specifies that a variable of type &lt;code&gt;T&lt;/code&gt; can be initialized with the given set of argument types &lt;code&gt;Args...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Constructible&lt;/code&gt; 형 가변한다는 개념 지정 &lt;code&gt;T&lt;/code&gt; 는 인수 형의 주어진 세트로 초기화 될 수 &lt;code&gt;Args...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f7de4726e679b44af8c8d284cb95faef91bff36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ContiguousRange&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ContiguousIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ContiguousIterator&lt;/code&gt;&lt;/a&gt; and the customization point &lt;code&gt;ranges::data&lt;/code&gt; is usable.</source>
          <target state="translated">&lt;code&gt;ContiguousRange&lt;/code&gt; 의 개념의 정교화하고있다 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 있는 &lt;code&gt;ranges::begin&lt;/code&gt; 반환에게의 모델 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ContiguousIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ContiguousIterator&lt;/code&gt; &lt;/a&gt; 및 사용자 정의 점 &lt;code&gt;ranges::data&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ecc9e88401481b0a24b03216493707c334d31f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DefaultConstructible&lt;/code&gt; concept provides a shorthand for the common case when the question is whether a type can be constructed with no arguments.</source>
          <target state="translated">&lt;code&gt;DefaultConstructible&lt;/code&gt; 질문 유형이 인수로 구성 할 수 있는지 여부를 때 개념은 일반적인 경우에 대한 속기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c0205c222ca9d21e9d05367ef4c2ea7fd533e2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; macros expand into integral expressions that can be used as arguments to the &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; function (and, therefore, as the values to return from the &lt;a href=&quot;../../language/main_function&quot;&gt;main function&lt;/a&gt;), and indicate program execution status.</source>
          <target state="translated">&lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 및 &lt;code&gt;EXIT_FAILURE&lt;/code&gt; 매크로는 인수로 사용할 수있는 통합 식으로 확장 &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; (값이 리턴되는대로, 그리고 따라서, 기능 &lt;a href=&quot;../../language/main_function&quot;&gt;주요 기능&lt;/a&gt; ), 및 프로그램 실행 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2d5615a09c39393c229b9c18967835ce479d5d69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FP_NORMAL&lt;/code&gt;, &lt;code&gt;FP_SUBNORMAL&lt;/code&gt;, &lt;code&gt;FP_ZERO&lt;/code&gt;, &lt;code&gt;FP_INFINITE&lt;/code&gt;, &lt;code&gt;FP_NAN&lt;/code&gt; macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4771d6adfbe4d104e6fadb4ac1ec96d29484beb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HUGE_VALF&lt;/code&gt;, &lt;code&gt;HUGE_VAL&lt;/code&gt; and &lt;code&gt;HUGE_VALL&lt;/code&gt; macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;HUGE_VALF&lt;/code&gt; , &lt;code&gt;HUGE_VAL&lt;/code&gt; 및 &lt;code&gt;HUGE_VALL&lt;/code&gt; 매크로 (참조 플로우의 경우에는 부동 소수점 연산자와 함수에 의해 리턴 된 값과 비교 동등한 양의 부동 소수점 상수 식으로 확장 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="b53889e1fa8ec514487167aa966e17170b8cc75a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Hash&lt;/code&gt; and &lt;code&gt;KeyEqual&lt;/code&gt; objects must be &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;, and they are exchanged using unqualified calls to non-member &lt;code&gt;swap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; 및 &lt;code&gt;KeyEqual&lt;/code&gt; 개체를해야 &lt;a href=&quot;../../named_req/swappable&quot;&gt;스왑&lt;/a&gt; , 그들은 비회원으로 지정되지 않은 호출하여 교환하는 &lt;code&gt;swap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c876028ed259f9708a4f843ab3d6aab2c902892f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Invocable&lt;/code&gt; concept specifies that a callable type &lt;code&gt;F&lt;/code&gt; can be called with a set of argument types &lt;code&gt;Args...&lt;/code&gt; using the function template &lt;code&gt;&lt;a href=&quot;../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Invocable&lt;/code&gt; 호출 가능 형 있다는 개념 지정 &lt;code&gt;F&lt;/code&gt; 가 인수 형식의 세트로 호출 할 수 있습니다 &lt;code&gt;Args...&lt;/code&gt; 함수 템플릿을 사용하여 &lt;code&gt;&lt;a href=&quot;../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8c6d2bb20815cb4086648b5791bd3296ece4645" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pred&lt;/code&gt; objects must be &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;, and they are exchanged using unqualified call to non-member &lt;code&gt;swap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pred&lt;/code&gt; 를 가산의 객체는해야 &lt;a href=&quot;../../named_req/swappable&quot;&gt;스왑&lt;/a&gt; , 그들은 비회원으로되지 않은 호출을 사용하여 교환하는 &lt;code&gt;swap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fdd47f91dc15f27f84bdafb62f28f3485f1e1f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Regular&lt;/code&gt; concept specifies that a type is</source>
          <target state="translated">&lt;code&gt;Regular&lt;/code&gt; 유형인지 개념 지정</target>
        </trans-unit>
        <trans-unit id="0ce0e6d69f4d620d6fcae2b4f8fef1abc8b43a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RegularInvocable&lt;/code&gt; concept adds to the &lt;code&gt;Invocable&lt;/code&gt; concept by requiring the &lt;code&gt;invoke&lt;/code&gt; expression to be equality preserving and not modify either the function object or the arguments.</source>
          <target state="translated">&lt;code&gt;RegularInvocable&lt;/code&gt; 개념은에 추가 &lt;code&gt;Invocable&lt;/code&gt; 요구에 의해 개념 &lt;code&gt;invoke&lt;/code&gt; 평등 유지를하고 함수 개체 또는 인수 중 하나를 수정하지 않는 표현.</target>
        </trans-unit>
        <trans-unit id="cf8e461967237e596e17c697c486009a5fe11770" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIG_DFL&lt;/code&gt; and &lt;code&gt;SIG_IGN&lt;/code&gt; macros expand into integral expressions that are not equal to an address of any function. The macros define signal handling strategies for &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;SIG_DFL&lt;/code&gt; 과 &lt;code&gt;SIG_IGN&lt;/code&gt; 매크로는 함수의 주소와 동일하지 필수적인 표현으로 확장합니다. 매크로는 &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;()&lt;/code&gt; 함수에 대한 신호 처리 전략을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="6de9aff3c7faf216d8e471183c6456f97bd54cbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Semiregular&lt;/code&gt; concept specifies that a type is both copyable and default constructible. It is satisfied by types that behave similarly to built-in types like &lt;code&gt;int&lt;/code&gt;, except that they need not support comparison with &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Semiregular&lt;/code&gt; 개념 지정하는 유형은 모두 복사 가능한 및 기본 작도는 것을. &lt;code&gt;==&lt;/code&gt; 과의 비교를 지원할 필요가 없다는 점을 제외하고 &lt;code&gt;int&lt;/code&gt; 와 같은 내장 유형과 유사하게 작동하는 유형에 의해 만족됩니다 .</target>
        </trans-unit>
        <trans-unit id="37ff8b0ffac4e36092586c172067e58bd7864950" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; may be a function type: in this case it manages a pointer to function, rather than an object pointer. This is sometimes used to keep a dynamic library or a plugin loaded as long as any of its functions are referenced:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 함수 유형이 될 수는 함수에 대한 포인터가 아닌 객체 포인터를 관리하는이 경우. 함수가 참조되는 한 동적 라이브러리 또는 플러그인을로드 된 상태로 유지하는 데 때때로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="65eaac4daf1baa4af15a6bc0e49ad6bf3b7e19d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ViewableRange&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; that describes a range that can be safely converted into a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ViewableRange&lt;/code&gt; 의 개념의 정교화하고있다 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 안전하게으로 변환 할 수있는 범위에 대해 설명 &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0be369a359e4171939ff31f6da284f95c50dd77d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alignas&lt;/code&gt; specifier may be applied to the declaration of a variable or a non-bitfield class data member, or it can be applied to the declaration or definition of a &lt;a href=&quot;classes&quot;&gt;class/struct/union&lt;/a&gt; or &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt;. It cannot be applied to a function parameter or to the exception parameter of a catch clause.</source>
          <target state="translated">&lt;code&gt;alignas&lt;/code&gt; 변수의 선언 또는 비 비트 필드 클래스의 데이터 멤버에 적용될 수 있거나, 또는이 선언 또는 정의에 적용될 수 지정 &lt;a href=&quot;classes&quot;&gt;클래스 / 구조체 / 조합&lt;/a&gt; 또는 &lt;a href=&quot;enum&quot;&gt;열거&lt;/a&gt; . catch 매개 변수의 함수 매개 변수 또는 예외 매개 변수에는 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bff8ba6726cb421edc960040f88c5cf3e47f9038" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;allocator_traits&lt;/code&gt; class template provides the standardized way to access various properties of &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocators&lt;/a&gt;. The standard containers and other standard library components access allocators through this template, which makes it possible to use any class type as an allocator, as long as the user-provided specialization of &lt;code&gt;allocator_traits&lt;/code&gt; implements all required functionality.</source>
          <target state="translated">&lt;code&gt;allocator_traits&lt;/code&gt; 의 클래스 템플릿의 액세스 다양한 속성에 표준화 된 방법을 제공 &lt;a href=&quot;../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; . 표준 컨테이너 및 기타 표준 라이브러리 구성 요소는이 템플리트를 통해 할당 자에 액세스하므로 사용자가 제공 한 &lt;code&gt;allocator_traits&lt;/code&gt; 전문화가 모든 필수 기능을 구현하는 한 모든 클래스 유형을 할당 자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04038d9c6f5ffb5436ba1d17bbcd6c392bc7d37c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; keyword may also be used in a nested-name-specifier. A nested-name-specifier of the form &lt;code&gt;auto::&lt;/code&gt; is a placeholder that is replaced by a class or enumeration type following the rules for &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;constrained type&lt;/a&gt; placeholder deduction.</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 키워드는 중첩 된 이름 지정에 사용될 수있다. &lt;code&gt;auto::&lt;/code&gt; 형식의 중첩 이름 지정자는 &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;제약 유형&lt;/a&gt; 플레이스 홀더 공제 규칙에 따라 클래스 또는 열거 유형으로 대체되는 플레이스 홀더입니다.</target>
        </trans-unit>
        <trans-unit id="f01f0aaa02136abf45c219eced918e6c249526ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; specifier may also be used in a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt; declaration.</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 지정은 또한 사용될 수있다 &lt;a href=&quot;structured_binding&quot;&gt;구성된 바인딩&lt;/a&gt; 선언문.</target>
        </trans-unit>
        <trans-unit id="eebf15af9f37cc17089284009c20c5353fc1d4ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; specifier may also be used with a function declarator that is followed by a trailing return type, in which case the declared return type is that trailing return type (which may again be a placeholder type).</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 지정은 선언 리턴 타입 (다시 틀 형태 일 수있다) 그 뒤에 리턴 타입 인 경우에 꼬리 끌림 리턴 형, 뒤에 함수 선언자 함께 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="da5417a4a1f6900885b530dcd22d3e6b960789b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; data members indicate the range - &lt;code&gt;[begin, end)&lt;/code&gt; - in which the &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;abbrev&lt;/code&gt; are in effect for the time zone associated with this &lt;code&gt;sys_info&lt;/code&gt;.</source>
          <target state="translated">는 &lt;code&gt;begin&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 데이터 멤버는 범위를 나타낸다 - &lt;code&gt;[begin, end)&lt;/code&gt; -있는 &lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;abbrev&lt;/code&gt; 이것에 관련된 시간대 적용되는 &lt;code&gt;sys_info&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08cdecbd98343fa04c3717e4b9bc77c4fd79a3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char_traits&lt;/code&gt; class is a traits class template that abstracts basic character and string operations for a given character type. The defined operation set is such that generic algorithms almost always can be implemented in terms of it. It is thus possible to use such algorithms with almost any possible character or string type, just by supplying a customized &lt;code&gt;char_traits&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;char_traits&lt;/code&gt; 의 클래스는 지정된 문자 유형에 대한 기본 문자 및 문자열 작업을 추상화하는 특성 클래스 템플릿입니다. 정의 된 연산 세트는 일반적인 알고리즘을 거의 항상 구현할 수 있도록하는 것입니다. 따라서 사용자 정의 된 &lt;code&gt;char_traits&lt;/code&gt; 클래스를 제공하는 것만으로 거의 모든 문자 또는 문자열 유형으로 이러한 알고리즘을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="177963573909d55c891e3520852061007eb9c66e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char_traits&lt;/code&gt; class template satisfies the requirements of &lt;a href=&quot;../named_req/chartraits&quot;&gt;CharTraits&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;char_traits&lt;/code&gt; 의 클래스 템플릿 만족의 요구 사항 &lt;a href=&quot;../named_req/chartraits&quot;&gt;CharTraits&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44b0b21e5f03504b17b1b60754c40fb0b2f0fa8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char_traits&lt;/code&gt; class template serves as a basis for explicit instantiations. The user can &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;provide a specialization&lt;/a&gt; for any custom character types. Several specializations are defined for the standard character types.</source>
          <target state="translated">&lt;code&gt;char_traits&lt;/code&gt; 의 클래스 템플릿 명시 적 인스턴스화위한 기초 역할을합니다. 사용자는 모든 사용자 정의 문자 유형에 대한 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;전문화&lt;/a&gt; 를 제공 할 수 있습니다. 표준 문자 유형에 대해 몇 가지 특수화가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b0ebde42f38090479a8212aa43f128f736af213" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chi_squared_distribution&lt;/code&gt; produces random numbers x&amp;gt;0 according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Chi-squared_distribution&quot;&gt;Chi-squared distribution&lt;/a&gt;:  f(x;n) =</source>
          <target state="translated">&lt;code&gt;chi_squared_distribution&lt;/code&gt; 가 받는 따른 난수 x&amp;gt; 0를 생성 &lt;a href=&quot;https://en.wikipedia.org/wiki/Chi-squared_distribution&quot;&gt;카이 제곱 분포&lt;/a&gt; : F (X, N) =</target>
        </trans-unit>
        <trans-unit id="5102ccf4e38654c4fd4d26ea6f891ab30afa39bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chrono&lt;/code&gt; library defines three main types as well as utility functions and common typedefs.</source>
          <target state="translated">&lt;code&gt;chrono&lt;/code&gt; 라이브러리뿐만 아니라 유틸리티 기능 및 일반적인 형식 정의로 세 가지 주요 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b6766d205bb5b455d579d758141a563b95b3d67c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chrono&lt;/code&gt; library, a flexible collection of types that track time with varying degrees of precision (e.g. &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;chrono&lt;/code&gt; 라이브러리 유형의 유연한 모음 그 정밀도의 학위를 변화와 트랙 시간 (예를 들어, &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0a52f6a677651b00292edc29fa2de13e4ac2f9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition_variable&lt;/code&gt; class is a synchronization primitive that can be used to block a thread, or multiple threads at the same time, until another thread both modifies a shared variable (the</source>
          <target state="translated">&lt;code&gt;condition_variable&lt;/code&gt; 클래스는 다른 스레드까지 모두 수정 동시에 스레드 또는 다중 스레드를 차단하는 데 사용할 수있는 프리미티브를 동기화하는 공유 변수 (</target>
        </trans-unit>
        <trans-unit id="b215c4b6c6a9b5c07215f55013e1367ef3ea0332" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition_variable_any&lt;/code&gt; class is a generalization of &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt;. Whereas &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; works only on &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&amp;lt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;condition_variable_any&lt;/code&gt; can operate on any lock that meets the &lt;a href=&quot;../named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; requirements.</source>
          <target state="translated">&lt;code&gt;condition_variable_any&lt;/code&gt; 의 클래스의 일반화 &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; . 반면 &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; 만에 작품 &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&amp;lt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;condition_variable_any&lt;/code&gt; 는 만족하는 모든 잠금을 작동 할 수 &lt;a href=&quot;../named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; 요구 사항을.</target>
        </trans-unit>
        <trans-unit id="1cf2d3a260a3d32021ce59105ae016547705dee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; overloads that return element sequences create a new &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; object. The non-&lt;code&gt;const&lt;/code&gt; overloads return classes holding references to the array elements.</source>
          <target state="translated">요소 시퀀스를 반환 하는 &lt;code&gt;const&lt;/code&gt; 오버로드는 새로운 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 객체를 만듭니다. &lt;code&gt;const&lt;/code&gt; 가 아닌 오버로드는 배열 요소에 대한 참조를 보유하는 클래스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd55baa6e491928bab686e3cd64f2e9dfe961be7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; qualifier used on a declaration of a non-local non-volatile non-&lt;a href=&quot;variable_template&quot;&gt;template&lt;/a&gt;(since C++14)non-&lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;(since C++17) variable that is not declared &lt;code&gt;extern&lt;/code&gt; gives it &lt;a href=&quot;storage_duration#Linkage&quot;&gt;internal linkage&lt;/a&gt;. This is different from C where const file scope variables have external linkage.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 비 로컬 비 휘발성 비 선언에 사용 규정 &lt;a href=&quot;variable_template&quot;&gt;템플릿&lt;/a&gt; 비 (C ++ 14) 이후 &lt;a href=&quot;inline&quot;&gt;인라인&lt;/a&gt; 선언되지 않은 변수 (17 ++ C 때문에) &lt;code&gt;extern&lt;/code&gt; 그것을 제공 &lt;a href=&quot;storage_duration#Linkage&quot;&gt;내부 링키지&lt;/a&gt; . const 파일 범위 변수에 외부 연결이있는 C와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9e69cf0356decd5627b692a11a1d92f42afc3d01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;consteval&lt;/code&gt; specifier declares a function or function template to be an</source>
          <target state="translated">&lt;code&gt;consteval&lt;/code&gt; 지정은 될 수있는 함수 나 함수 템플릿을 선언</target>
        </trans-unit>
        <trans-unit id="35815ab767098ba84898163f2b361dc56dd3ae30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;constexpr&lt;/code&gt; specifier declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time &lt;a href=&quot;constant_expression&quot;&gt;constant expressions&lt;/a&gt; are allowed (provided that appropriate function arguments are given). A &lt;code&gt;constexpr&lt;/code&gt; specifier used in an object declaration  or non-static member function(until C++14) implies &lt;code&gt;const&lt;/code&gt;. A &lt;code&gt;constexpr&lt;/code&gt; specifier used in a function  or &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; member variable(since C++17) declaration implies &lt;code&gt;inline&lt;/code&gt;. If any declaration of a function or function template has a &lt;code&gt;constexpr&lt;/code&gt; specifier, then every declaration must contain that specifier.</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; 의 지정은 컴파일시 함수 또는 변수의 값을 평가할 수 있음을 선언한다. 그런 다음 컴파일 시간 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현식&lt;/a&gt; 만 허용되는 경우 (적절한 함수 인수가 제공되는 경우) 이러한 변수와 함수를 사용할 수 있습니다 . &lt;code&gt;constexpr&lt;/code&gt; 의 객체 선언 또는 비 정적 멤버 함수에 사용 지정자 (C ++ 14까지)를 의미 &lt;code&gt;const&lt;/code&gt; . &lt;code&gt;constexpr&lt;/code&gt; 의 기능 또는 사용의 지정자 &lt;a href=&quot;static&quot;&gt;정적&lt;/a&gt; 멤버 변수 (C ++ 보낸 17) 선언 의미 &lt;code&gt;inline&lt;/code&gt; . 함수 또는 함수 템플릿의 선언에 &lt;code&gt;constexpr&lt;/code&gt; 지정자가 있으면 모든 선언에 해당 지정자가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="de7d028befc7b72b5d7baad4130ff394635f4af2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;continue&lt;/code&gt; statement causes a jump, as if by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; to the end of the loop body (it may only appear within the loop body of &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;, and &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loops).</source>
          <target state="translated">는 &lt;code&gt;continue&lt;/code&gt; 하여 것처럼 문, 점프의 원인 &lt;a href=&quot;goto&quot;&gt;고토&lt;/a&gt; 루프 본문의 마지막에 (그것은 단지의 루프 본문 내에서 나타날 수 &lt;a href=&quot;for&quot;&gt;에 대한&lt;/a&gt; , &lt;a href=&quot;range-for&quot;&gt;범위-을 위해&lt;/a&gt; , &lt;a href=&quot;while&quot;&gt;동안&lt;/a&gt; , 그리고 &lt;a href=&quot;do&quot;&gt;할-동안&lt;/a&gt; 루프).</target>
        </trans-unit>
        <trans-unit id="8dca88435ad03881fbd9b4dc716ca855832c1e5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;double&lt;/code&gt; version of &lt;code&gt;std::round&lt;/code&gt; behaves as if implemented as follows:</source>
          <target state="translated">&lt;code&gt;std::round&lt;/code&gt; 의 &lt;code&gt;double&lt;/code&gt; 버전은 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="05595bba0a787573762c012c73d8da365cd8a32d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_type&lt;/code&gt; is a type that describes errors that may occur during regular expression parsing.</source>
          <target state="translated">&lt;code&gt;error_type&lt;/code&gt; 정규 표현식 구문 분석하는 동안 발생할 수있는 오류를 설명하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="932d4e1dcebe4a218d1fd9f57208e42aa699239e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword can also be used to specify &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; and &lt;a href=&quot;class_template&quot;&gt;explicit template instantiation declarations&lt;/a&gt;, but it's not a storage class specifier in those cases (except when a declaration is directly contained in a language linkage specification, in which case the declaration is treated as if it contains the &lt;code&gt;extern&lt;/code&gt; specifier).</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 키워드도 지정할 수 있습니다 &lt;a href=&quot;language_linkage&quot;&gt;언어 연결&lt;/a&gt; 및 &lt;a href=&quot;class_template&quot;&gt;명시 적 템플릿 인스턴스화 선언을&lt;/a&gt; 하지만, 선언이 직접하는 경우에 선언 것처럼 처리, 언어 연결 사양에 포함되어있는 경우를 제외하고는 이러한 경우에 저장소 클래스 지정자 (아니다 &lt;code&gt;extern&lt;/code&gt; 지정자를 포함 합니다).</target>
        </trans-unit>
        <trans-unit id="52649288e6377fb98d3ed6678b3819788af177ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fill&lt;/code&gt; character is provided for those implementation-defined format specifiers and for the user-defined overrides of &lt;code&gt;do_put()&lt;/code&gt; that use padding and filling logic. Such implementations typically make use of the formatting flags from &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fill&lt;/code&gt; 문자는 그 구현 정의 형식 지정하고 상기 사용자 설정 우선 제공된다 &lt;code&gt;do_put()&lt;/code&gt; 이 사용 패딩 채우는 논리. 이러한 구현은 일반적으로 &lt;code&gt;str&lt;/code&gt; 의 형식 플래그를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ceb8fdf893c64b9bf5b9166ad2341a9ce3a4fc89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; bitmask determines which format specifiers and escape sequences are recognized.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 형식 지정 및 이스케이프 시퀀스를 인식하는 비트 마스크를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="60a0827b559dc3609b6079d5a14b629f858e635e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; method waits until the &lt;code&gt;future&lt;/code&gt; has a valid result and (depending on which template is used) retrieves it. It effectively calls &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; in order to wait for the result.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 때까지 방법을 기다리는 &lt;code&gt;future&lt;/code&gt; 유효한 결과를 가지고 그것을 검색 (템플릿 사용에 따라). 결과를 기다리기 위해 효과적으로 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fa10112d4d243c9e88153a1eadcc7cb485d5a648" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; method waits until the &lt;code&gt;shared_future&lt;/code&gt; has a valid result and (depending on which template is used) retrieves it. It effectively calls &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; in order to wait for the result.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 방법까지 대기 &lt;code&gt;shared_future&lt;/code&gt; 가 유효한 결과를 보유하고 검색 (템플릿 사용에 따라). 결과를 기다리기 위해 효과적으로 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2786a7f9bc87460e17c0440169fb55a2685fc146" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt; statement cannot transfer control into a &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt; or into a catch-clause, but can transfer control out of a try-block or a catch-clause (the rules above regarding automatic variables in scope are followed).</source>
          <target state="translated">&lt;code&gt;goto&lt;/code&gt; 문은에 제어를 전송할 수 없습니다 &lt;a href=&quot;try_catch&quot;&gt;시도 블록&lt;/a&gt; 포괄 절 또는으로하지만, 시도 블록 또는 포괄 절 (범위 자동 변수에 대한 위의 규칙 준수)의 출력을 제어 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="031e15ddd6649548e06689a0db9c2fd9bd1bf8f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initializer&lt;/code&gt; is not optional if.</source>
          <target state="translated">&lt;code&gt;initializer&lt;/code&gt; 경우 선택 사항이 아니다.</target>
        </trans-unit>
        <trans-unit id="7f965e1c24153a443cd599dc6dec3772ab145903" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; specifier, when used in a &lt;a href=&quot;declarations#Specifiers&quot;&gt;decl-specifier-seq&lt;/a&gt; of a variable with static storage duration (static class member or namespace-scope variable), declares the variable to be an</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 지시자는 사용될 때 &lt;a href=&quot;declarations#Specifiers&quot;&gt;않거나 계산 지정자-SEQ&lt;/a&gt; 정적 저장 기간 (정적 반원 또는 공간 범위 내 변수)와 변수의 수를 변수 선언</target>
        </trans-unit>
        <trans-unit id="bde3e8856747d6351599372bdacbbefb9c1e2210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; specifier, when used in a function's &lt;a href=&quot;declarations#Specifiers&quot;&gt;decl-specifier-seq&lt;/a&gt;, declares the function to be an</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 지정자는, 함수의 사용할 때 &lt;a href=&quot;declarations#Specifiers&quot;&gt;자명 한 일 입니 지정자-SEQ&lt;/a&gt; ,을 사용할 함수를 선언</target>
        </trans-unit>
        <trans-unit id="8aa05d61d78251587e3d9f7bde2b8eaec9c423a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; parameter is a dummy parameter used to differentiate between prefix and postfix versions of the operators. When the user-defined postfix operator is called, the value passed in that parameter is always zero, although it may be changed by calling the operator using function call notation (e.g., &lt;code&gt;a.operator++(2)&lt;/code&gt; or &lt;code&gt;operator++(a, 2)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 파라미터는 운영자의 접두사 및 접미사 버전을 구별하기 위해 사용되는 더미 변수이다. 사용자 정의 postfix 연산자가 호출되면 함수 호출 표기법 (예 : &lt;code&gt;a.operator++(2)&lt;/code&gt; 또는 &lt;code&gt;operator++(a, 2)&lt;/code&gt; )을 사용하여 연산자를 호출하여 변경할 수 있지만 해당 매개 변수에 전달 된 값은 항상 0입니다. .</target>
        </trans-unit>
        <trans-unit id="92968e121e7165e31286647fba30664ab9bc7316" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;local_time&lt;/code&gt; associated with &lt;code&gt;tp&lt;/code&gt; and this time zone.</source>
          <target state="translated">는 &lt;code&gt;local_time&lt;/code&gt; 과 관련된 &lt;code&gt;tp&lt;/code&gt; 이 시간대.</target>
        </trans-unit>
        <trans-unit id="f8457b952a5ed2dd70613e9c33c791fd7241a61e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;localeconv&lt;/code&gt; function obtains a pointer to a static object of type &lt;code&gt;&lt;a href=&quot;lconv&quot;&gt;std::lconv&lt;/a&gt;&lt;/code&gt;, which represents numeric and monetary formatting rules of the current C locale.</source>
          <target state="translated">&lt;code&gt;localeconv&lt;/code&gt; 에의 함수 타입의 정적 오브젝트 포인터 획득 &lt;code&gt;&lt;a href=&quot;lconv&quot;&gt;std::lconv&lt;/a&gt;&lt;/code&gt; 현재 C 로케일의 숫자 및 통화 포맷 규칙을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="871c1b9d3287d86d418a876a89b0359bd3b24165" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_guard&lt;/code&gt; class is non-copyable.</source>
          <target state="translated">&lt;code&gt;lock_guard&lt;/code&gt; 클래스가 아닌 복사 가능한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b612fa95299520ae1c9eb4dbe4d246807c386150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main()&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 함수</target>
        </trans-unit>
        <trans-unit id="7373830865d083f56e567e0e35241e9449625781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function has several special properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f74c21d245cac408b403b1479529ca4f6979ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is called at program startup after &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt; of the non-local objects with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;. It is the designated entry point to a program that is executed in</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 기능은 이후 프로그램 시작시 호출 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; 정적으로 비 로컬 객체 &lt;a href=&quot;storage_duration&quot;&gt;저장 시간&lt;/a&gt; . 실행되는 프로그램의 지정된 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="89ff7175fcc410342462f2eea4a20828de71c2e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.</source>
          <target state="translated">&lt;code&gt;mutex&lt;/code&gt; 클래스가 동시에 다수의 스레드에 의해 액세스되는 공유 된 데이터를 보호하기 위해 사용할 수있는 동기화 기본이다.</target>
        </trans-unit>
        <trans-unit id="b4bc2f666b0fcf62423756e2f92296de1749b231" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt;th predecessor of iterator &lt;code&gt;it&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 반복기의 선행 차 &lt;code&gt;it&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a315e0d4269377bcca03d5a9cce5ae4498e0c870" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt;th successor of iterator &lt;code&gt;it&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 반복기의 후속 번째 &lt;code&gt;it&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eea079380ac363ae07705954b7f4d3fea5a10329" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; expression attempts to allocate storage and then attempts to construct and initialize either a single unnamed object, or an unnamed array of objects in the allocated storage. The new-expression returns a prvalue pointer to the constructed object or, if an array of objects was constructed, a pointer to the initial element of the array.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 표현 시도는 구성 및 단일 객체 이름 또는 상기 할당 된 저장 영역에있는 오브젝트의 이름을 배열하거나 초기화 시도 스토리지를 할당한다. new-expression은 생성 된 객체에 대한 prvalue 포인터 또는 객체의 배열이 구성된 경우 배열의 초기 요소에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ead8e378038e6652b84ea0044d098289ae5652ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noexcept&lt;/code&gt; operator does not evaluate expression.</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; 연산자는 표현식을 평가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2ca9dcb6d4e088c8b11fa6caa39ac36140cdbf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noexcept&lt;/code&gt; operator performs a compile-time check that returns true if an expression is declared to not throw any exceptions.</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; 운영자 수행 true를 반환 표현이 선언 된 경우 예외가 발생하지 않도록하는 컴파일 시간 체크.</target>
        </trans-unit>
        <trans-unit id="50c513953b1f92f60c692964e4a72e25a368f1b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numeric_limits&lt;/code&gt; class template provides a standardized way to query various properties of arithmetic types (e.g. the largest possible value for type &lt;code&gt;int&lt;/code&gt; is &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;::max()&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;numeric_limits&lt;/code&gt; 의 클래스 템플릿은 산술 유형의 쿼리 다양한 속성에 표준화 된 방법을 제공합니다 (예를 들어, 형식에 대한 가능한 최대 값 &lt;code&gt;int&lt;/code&gt; 있다 &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;::max()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7fe11954ad007a4af379951d73b5527c3769ef5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;abbrev&lt;/code&gt; data member indicate the UTC offset and time zone abbreviation, respectively, in effect for the associated time zone and &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;. Note that time zone abbreviations are not unique.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;abbrev&lt;/code&gt; 데이터 부재 관련 시간대에 유효한 각각 UTC 오프셋 및 시간대 약어를 나타내는 &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; . 시간대 약어는 고유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f78f379de0f1937dfed883c08e0f94ce9e47e089" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;openmode&lt;/code&gt; argument, required by the base class function signature, is usually ignored, because &lt;code&gt;std::basic_filebuf&lt;/code&gt; maintains only one file position.</source>
          <target state="translated">&lt;code&gt;openmode&lt;/code&gt; 의 때문에 기본 클래스 함수 서명에 필요한 인수는, 보통, 무시 &lt;code&gt;std::basic_filebuf&lt;/code&gt; 하나의 파일 위치를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7134e77fbf2616c72ce53c638efa5b4083c7a3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optional&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;optional&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="7e31417a62218983d2ccade81e8afcf7ba3d979c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pointer_traits&lt;/code&gt; class template provides the standardized way to access certain properties of pointer-like types (&lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;fancy pointers&lt;/a&gt;, such as &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost::interprocess::offset_ptr&lt;/a&gt;). The standard template &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; relies on &lt;code&gt;pointer_traits&lt;/code&gt; to determine the defaults for various typedefs required by &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pointer_traits&lt;/code&gt; 의 클래스 템플릿은 포인터와 같은 종류 (의 액세스 특정 속성에 표준화 된 방법을 제공합니다 &lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;멋진 포인터&lt;/a&gt; 등, &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;부스트 :: 간 :: offset_ptr&lt;/a&gt; ). 표준 템플릿 &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;pointer_traits&lt;/code&gt; 에 의존 하여 &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator에&lt;/a&gt; 필요한 다양한 typedef의 기본값을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="aed9526a12ac6c0b94706d8d2d4fea2631766202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proj&lt;/code&gt; function helps model the Riemann sphere by mapping all infinities to one (give or take the sign of the imaginary zero), and should be used just before any operation, especially comparisons, that might give spurious results for any of the other infinities.</source>
          <target state="translated">&lt;code&gt;proj&lt;/code&gt; 기능이 하나에 모든 무한대를 매핑하여 리만 구 모델 (주고 또는 가상 제로의 부호을)하는 데 도움이, 다른 무한대의에 대한 가짜 결과를 줄 수있는 동작, 특히 비교, 전에 만 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="16a8dc17771b5740dbb0cfbe04c9fb979e594017" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive_mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.</source>
          <target state="translated">&lt;code&gt;recursive_mutex&lt;/code&gt; 의 클래스가 동시에 다수의 스레드에 의해 액세스되는 공유 된 데이터를 보호하기 위해 사용할 수있는 동기화 기본이다.</target>
        </trans-unit>
        <trans-unit id="75793db3b7c87aa4e287a2f638dfc7ae867a0afd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive_timed_mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.</source>
          <target state="translated">&lt;code&gt;recursive_timed_mutex&lt;/code&gt; 의 클래스가 동시에 다수의 스레드에 의해 액세스되는 공유 된 데이터를 보호하기 위해 사용할 수있는 동기화 기본이다.</target>
        </trans-unit>
        <trans-unit id="579b829a50621b7a0aafe11e52a8bf5b7d048cfa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive_timed_mutex&lt;/code&gt; class satisfies all requirements of &lt;a href=&quot;../named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; and &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;recursive_timed_mutex&lt;/code&gt; 의 클래스 만족의 모든 요구 사항 &lt;a href=&quot;../named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; 및 &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f502cafc006683857dcfb81fd4ded261d5ae887" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reference&lt;/code&gt; type for an input iterator that is not also a &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; does not have to be a reference type: dereferencing an input iterator may return a proxy object or &lt;code&gt;value_type&lt;/code&gt; itself by value (as in the case of &lt;a href=&quot;../iterator/istreambuf_iterator&quot;&gt;&lt;code&gt;std::istreambuf_iterator&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; 가 아닌 입력 반복기 의 &lt;code&gt;reference&lt;/code&gt; 유형 은 참조 유형일 필요는 없습니다. 입력 반복기를 역 참조하면 프록시 오브젝트 또는 &lt;code&gt;value_type&lt;/code&gt; 자체가 값으로 리턴 될 수 있습니다 ( &lt;a href=&quot;../iterator/istreambuf_iterator&quot;&gt; &lt;code&gt;std::istreambuf_iterator&lt;/code&gt; &lt;/a&gt; 의 경우와 같이 ).</target>
        </trans-unit>
        <trans-unit id="2c035e01c3dbc28696d2904643638e7f98ef9463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;save&lt;/code&gt; data member, if nonzero, indicates that the time zone is on daylight saving time at the specified time point. In this case, &lt;code&gt;offset - save&lt;/code&gt; is a suggestion of what offset this time zone might use if it were off daylight saving time. However, this information is not authoritative: the only way to ascertain the actual offset is to query the time zone with a time point that is actually off daylight savings time (i.e. returns a &lt;code&gt;sys_info&lt;/code&gt; such that &lt;code&gt;save == 0min&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; 데이터 멤버는 0이 아닌 경우, 시간대는 지정된 시점에서 일광 절약 시간에 있음을 나타냅니다. 이 경우 &lt;code&gt;offset - save&lt;/code&gt; 은 일광 절약 시간이 해제 된 경우이 시간대에서 사용할 오프셋을 제안합니다. (예를 반환 실제 오프셋을 확인하는 유일한 방법은 일광 절약 시간 떨어져 실제로 시점과 시간대를 조회하는 것입니다 그러나,이 정보는 권한이없는 &lt;code&gt;sys_info&lt;/code&gt; 그러한 &lt;code&gt;save == 0min&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7b88227d0e2029df0809a94b40cd5604a4dddbed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalbln&lt;/code&gt; function is provided because the factor required to scale from the smallest positive floating-point value to the largest finite one may be greater than 32767, the standard-guaranteed &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt;. In particular, for the 80-bit &lt;code&gt;long double&lt;/code&gt;, the factor is 32828.</source>
          <target state="translated">&lt;code&gt;scalbln&lt;/code&gt; 의 계수는 32,767 이상, 표준 보장 될 수있는 가장 큰 하나에 한정된 최소 양의 부동 소수점 값으로부터 스케일을 필요하기 때문에 기능이 제공된다 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; . 특히, 80 비트 &lt;code&gt;long double&lt;/code&gt; 의 경우 계수는 32828입니다.</target>
        </trans-unit>
        <trans-unit id="b1f9bffd993af74895ea24d6e5a6c3c209ca9f45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scoped_lock&lt;/code&gt; class is non-copyable.</source>
          <target state="translated">&lt;code&gt;scoped_lock&lt;/code&gt; 의 클래스가 아닌 복사 가능한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6b60c9e939da9755686b6ae70e02cdd28175c2b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setlocale&lt;/code&gt; function installs the specified system locale or its portion as the new C locale. The modifications remain in effect and influences the execution of all locale-sensitive C library functions until the next call to &lt;code&gt;setlocale&lt;/code&gt;. If &lt;code&gt;locale&lt;/code&gt; is a null pointer, &lt;code&gt;setlocale&lt;/code&gt; queries the current C locale without modifying it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b876cb1d68297596d892c9e79612cc1d718ee4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared_lock&lt;/code&gt; class is movable, but not copyable -- it meets the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; but not of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; or &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;shared_lock&lt;/code&gt; 의 그것의 요구 사항을 충족 - 클래스는 이동하지만, 복사 가능한하지 &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 및 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable을&lt;/a&gt; 들 수 있지만 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; 또는 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ba0072c5cc0f9ffc4d13a71fa58acfb63fc0bd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared_mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. In contrast to other mutex types which facilitate exclusive access, a shared_mutex has two levels of access:</source>
          <target state="translated">&lt;code&gt;shared_mutex&lt;/code&gt; 의 클래스가 동시에 다수의 스레드에 의해 액세스되는 공유 된 데이터를 보호하기 위해 사용할 수있는 동기화 기본이다. 독점 액세스를 용이하게하는 다른 뮤텍스 유형과 달리 shared_mutex에는 두 가지 액세스 수준이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c101aca05b9e44dae7ff87f787fe7276b486c130" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared_mutex&lt;/code&gt; class satisfies all requirements of &lt;a href=&quot;../named_req/sharedmutex&quot;&gt;SharedMutex&lt;/a&gt; and &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;shared_mutex&lt;/code&gt; 의 클래스 만족의 모든 요구 사항 &lt;a href=&quot;../named_req/sharedmutex&quot;&gt;SharedMutex&lt;/a&gt; 및 &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fd15329728ea18d0504ccf1f956107ca292faec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared_timed_mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. In contrast to other mutex types which facilitate exclusive access, a shared_timed_mutex has two levels of access:</source>
          <target state="translated">&lt;code&gt;shared_timed_mutex&lt;/code&gt; 의 클래스가 동시에 다수의 스레드에 의해 액세스되는 공유 된 데이터를 보호하기 위해 사용할 수있는 동기화 기본이다. 독점 액세스를 용이하게하는 다른 뮤텍스 유형과 달리 shared_timed_mutex에는 두 가지 액세스 수준이 있습니다.</target>
        </trans-unit>
        <trans-unit id="06999549f90a0f72f27c3eb6c97153c19f2420bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared_timed_mutex&lt;/code&gt; class satisfies all requirements of &lt;a href=&quot;../named_req/sharedtimedmutex&quot;&gt;SharedTimedMutex&lt;/a&gt; and &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;shared_timed_mutex&lt;/code&gt; 의 클래스 만족의 모든 요구 사항 &lt;a href=&quot;../named_req/sharedtimedmutex&quot;&gt;SharedTimedMutex&lt;/a&gt; 및 &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ccaf14b5121e6a6f684cf1f7b72304970279974" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;showbase&lt;/code&gt; flag affects the behavior of integer output (see &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::put&lt;/a&gt;&lt;/code&gt;), monetary input (see &lt;code&gt;&lt;a href=&quot;../../locale/money_get/get&quot;&gt;std::money_get::get&lt;/a&gt;&lt;/code&gt;) and monetary output (see &lt;code&gt;&lt;a href=&quot;../../locale/money_put/put&quot;&gt;std::money_put::put&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;showbase&lt;/code&gt; 의 플래그는 정수 출력의 행위 (볼에 영향을 미치는 &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::put&lt;/a&gt;&lt;/code&gt; ), 통화 입력 (참조 &lt;code&gt;&lt;a href=&quot;../../locale/money_get/get&quot;&gt;std::money_get::get&lt;/a&gt;&lt;/code&gt; ) 및 통화 출력 (참조 &lt;code&gt;&lt;a href=&quot;../../locale/money_put/put&quot;&gt;std::money_put::put&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3362f7e2786e23b0e207bf341b6ffbe082ce3138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size_type&lt;/code&gt; parameter type in these guides in an refers to the &lt;code&gt;size_type&lt;/code&gt; member type of the type deduced by the deduction guide.</source>
          <target state="translated">&lt;code&gt;size_type&lt;/code&gt; 에서이 가이드에서 매개 변수 유형을 의미 &lt;code&gt;size_type&lt;/code&gt; 공제 가이드에 의해 추론 유형의 멤버 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3e44e77d69bd972e28d8374914d0314649d0b42a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size_type&lt;/code&gt; parameter type in these guides refers to the &lt;code&gt;size_type&lt;/code&gt; member type of the type deduced by the deduction guide.</source>
          <target state="translated">&lt;code&gt;size_type&lt;/code&gt; 이 가이드에서 매개 변수 유형을 의미 &lt;code&gt;size_type&lt;/code&gt; 공제 가이드에 의해 추론 유형의 멤버 유형입니다.</target>
        </trans-unit>
        <trans-unit id="289689bc83eb06d23eb307703ddcdb7c999caeed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword is only used with the declaration of a static member, inside the class definition, but not with the definition of that static member:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 키워드은 클래스 정의 내부가 아닌 정적 멤버의 정의와, 정적 멤버의 선언으로 사용된다 :</target>
        </trans-unit>
        <trans-unit id="632a2ef4017c7723c54fe2b156317f31d8e22a58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::allocator&lt;/code&gt; class template is the default &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; used by all standard library containers if no user-specified allocator is provided. The default allocator is stateless, that is, all instances of the given allocator are interchangeable, compare equal and can deallocate memory allocated by any other instance of the same allocator type.</source>
          <target state="translated">&lt;code&gt;std::allocator&lt;/code&gt; 클래스 템플릿이 기본입니다 &lt;a href=&quot;../named_req/allocator&quot;&gt;할당자가&lt;/a&gt; 에는 사용자가 지정된 할당이 제공되지 않은 경우 모든 표준 라이브러리 컨테이너에 의해 사용. 기본 할당자는 상태 비 저장입니다. 즉, 주어진 할당 자의 모든 인스턴스는 상호 교환 가능하고 동일하게 비교되며 동일한 할당 자 유형의 다른 인스턴스에 의해 할당 된 메모리를 할당 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53c26f0250cd0d0e3b6ff2be656663e51a81ff93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::atomic_ref&lt;/code&gt; class template applies atomic operations to the object it references. For the lifetime of the &lt;code&gt;atomic_ref&lt;/code&gt; object, the object it references is considered an atomic object. If one thread writes to an atomic object while another thread reads from it, the behavior is well-defined (see &lt;a href=&quot;../language/memory_model&quot;&gt;memory model&lt;/a&gt; for details on data races). In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::atomic_ref&lt;/code&gt; 클래스 템플릿은 참조하는 개체에 원자 작업을 적용합니다. &lt;code&gt;atomic_ref&lt;/code&gt; 객체 의 수명 동안 참조하는 객체는 원자 객체로 간주됩니다. 한 스레드가 원자 개체에 쓰는 동안 다른 스레드가 그 스레드에서 읽는 경우 동작이 잘 정의되어 있습니다 ( 데이터 레이스에 대한 자세한 내용 은 &lt;a href=&quot;../language/memory_model&quot;&gt;메모리 모델&lt;/a&gt; 참조 ). 또한 원자 객체에 대한 액세스는 스레드 간 동기화를 설정하고 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; 지정된대로 비 원자 메모리 액세스를 정렬 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5be75dfd519b71fc03950ad1704971f2fb7ba4f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::chrono::duration_values&lt;/code&gt; type defines three common durations:</source>
          <target state="translated">&lt;code&gt;std::chrono::duration_values&lt;/code&gt; 타입을 정의 세 가지 일반적인 기간 :</target>
        </trans-unit>
        <trans-unit id="75ae7925b8d4cb8867916bcfc4f28fc16e262bc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::chrono::treat_as_floating_point&lt;/code&gt; trait helps determine if a duration can be converted to another duration with a different tick period.</source>
          <target state="translated">는 &lt;code&gt;std::chrono::treat_as_floating_point&lt;/code&gt; 특성 기간이 다른 틱 기간이 다른 기간으로 변환 할 수 있는지 결정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="fd5a1bbfb563fd5702d71a237c3bf20e52661268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::jmp_buf&lt;/code&gt; type is an array type suitable for storing information to restore a calling environment. The stored information is sufficient to restore execution at the correct block of the program and invocation of that block. The state of floating-point status flags, or open files, or any other data is not stored in an object of type &lt;code&gt;jmp_buf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::jmp_buf&lt;/code&gt; 유형 발신 환경을 복원하기위한 정보를 저장하기에 적합한 배열 형태이다. 저장된 정보는 프로그램의 올바른 블록에서의 실행 및 해당 블록의 호출을 복원하기에 충분합니다. 부동 소수점 상태 플래그, 열린 파일 또는 기타 데이터의 상태는 &lt;code&gt;jmp_buf&lt;/code&gt; 유형의 오브젝트에 저장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0af3608ab8ca3f6303dbf6dc9f92dd5c3b4f3fcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::placeholders&lt;/code&gt; namespace contains the placeholder objects &lt;code&gt;[_1, . . . _N]&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is an implementation defined maximum number.</source>
          <target state="translated">&lt;code&gt;std::placeholders&lt;/code&gt; 공간이 자리 객체 포함 &lt;code&gt;[_1, . . . _N]&lt;/code&gt; 여기서 &lt;code&gt;N&lt;/code&gt; 은 구현 정의 최대 수입니다.</target>
        </trans-unit>
        <trans-unit id="8b4aa4d2a1fe7d3edd392aab09fcc04cba814b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::puts&lt;/code&gt; function appends the newline character to the output, while &lt;code&gt;&lt;a href=&quot;fputs&quot;&gt;std::fputs&lt;/a&gt;&lt;/code&gt; function does not.</source>
          <target state="translated">&lt;code&gt;std::puts&lt;/code&gt; 동안 기능, 출력에 개행 문자를 추가 &lt;code&gt;&lt;a href=&quot;fputs&quot;&gt;std::fputs&lt;/a&gt;&lt;/code&gt; 기능을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e796f41be4761572f822b629753c5a0ac5ee7caa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::queue&lt;/code&gt; class is a container adapter that gives the programmer the functionality of a queue - specifically, a FIFO (first-in, first-out) data structure.</source>
          <target state="translated">&lt;code&gt;std::queue&lt;/code&gt; 즉, FIFO (선입 선출) 데이터 구조 - 클래스는 프로그래머 큐의 기능을 제공하는 컨테이너 어댑터이다.</target>
        </trans-unit>
        <trans-unit id="3fab3efadd5cd02efa0b0f9d2cdc38130b916876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; class template is an allocator which can be used with multilevel containers (vector of sets of lists of tuples of maps, etc). It is instantiated with one outer allocator type &lt;code&gt;OuterAlloc&lt;/code&gt; and zero or more inner allocator types &lt;code&gt;InnerAlloc...&lt;/code&gt;. A container constructed directly with a &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt; uses &lt;code&gt;OuterAlloc&lt;/code&gt; to allocate its elements, but if an element is itself a container, it uses the first inner allocator. The elements of that container, if they are themselves containers, use the second inner allocator, etc. If there are more levels to the container than there are inner allocators, the last inner allocator is reused for all further nested containers.</source>
          <target state="translated">&lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; 클래스 템플릿은 멀티 컨테이너 (지도 튜플의리스트 세트의 벡터 등)로 사용할 수있는 할당입니다. 하나의 외부 할당 자 유형 &lt;code&gt;OuterAlloc&lt;/code&gt; 과 0 개 이상의 내부 할당 자 유형 &lt;code&gt;InnerAlloc...&lt;/code&gt; 으로 인스턴스화됩니다 . &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt; 로 직접 구성된 컨테이너 는 &lt;code&gt;OuterAlloc&lt;/code&gt; 을 사용 하여 요소를 할당하지만 요소 자체가 컨테이너 인 경우 첫 번째 내부 할당자를 사용합니다. 해당 컨테이너의 요소가 컨테이너 인 경우 두 번째 내부 할당 자 등을 사용하십시오. 내부 할당자가있는 것보다 컨테이너에 레벨이 더 많으면 마지막 내부 할당자가 모든 중첩 된 컨테이너에 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d2eb610baf57f075efa3e1ba10e684713d54343a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::stack&lt;/code&gt; class is a container adapter that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.</source>
          <target state="translated">&lt;code&gt;std::stack&lt;/code&gt; 즉, LIFO (후입 선출) 데이터 구조 - 클래스는 프로그래머 스택의 기능을 제공하는 컨테이너 어댑터이다.</target>
        </trans-unit>
        <trans-unit id="b7bdef376da392b6b3c44811e911c30119a7b799" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syntax_option_type&lt;/code&gt; is a &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; that contains options that govern how regular expressions behave.</source>
          <target state="translated">&lt;code&gt;syntax_option_type&lt;/code&gt; 는 A는 &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; 표현이 어떻게 행동하는지 정기적으로 관리하는 옵션이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="000b096316dd940449688aa0c1993b2ce2c2a8aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template&lt;/code&gt; disambiguator for dependent names</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 따라 이름 disambiguator</target>
        </trans-unit>
        <trans-unit id="74943ce7057f0fa3f16bc77b4e70a8831747bccd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timed_mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.</source>
          <target state="translated">&lt;code&gt;timed_mutex&lt;/code&gt; 의 클래스가 동시에 다수의 스레드에 의해 액세스되는 공유 된 데이터를 보호하기 위해 사용할 수있는 동기화 기본이다.</target>
        </trans-unit>
        <trans-unit id="0cf84feefedec698c86998dbbdc5ed07c9f45bea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timed_mutex&lt;/code&gt; class satisfies all requirements of &lt;a href=&quot;../named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; and &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;timed_mutex&lt;/code&gt; 의 클래스 만족의 모든 요구 사항 &lt;a href=&quot;../named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; 및 &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="774795ace98b96b23eeb2920e059fbc2c4d46159" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_index&lt;/code&gt; class is a wrapper class around a &lt;code&gt;&lt;a href=&quot;type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object, that can be used as index in associative and unordered associative containers. The relationship with &lt;code&gt;type_info&lt;/code&gt; object is maintained through a pointer, therefore &lt;code&gt;type_index&lt;/code&gt; is &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;type_index&lt;/code&gt; 의 클래스는 래퍼 클래스입니다 &lt;code&gt;&lt;a href=&quot;type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 연관와 순서없는 연관 컨테이너의 인덱스로 사용할 수있는 객체. &lt;code&gt;type_info&lt;/code&gt; 객체 와의 관계 는 포인터를 통해 유지되므로 &lt;code&gt;type_index&lt;/code&gt; 는 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 및 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="952d7e2cfa91115883813c3249ff4a5bfac5cc7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_info&lt;/code&gt; class is neither &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; nor &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;type_info&lt;/code&gt; 클래스도 아닌 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; 도 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d3381fa6df6fd99efa7dd2c5d1dc236fc0ae2f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typedef&lt;/code&gt; specifier cannot be combined with any other specifier except for &lt;a href=&quot;declarations#Specifiers&quot;&gt;&lt;i&gt;type-specifier&lt;/i&gt;s&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;typedef&lt;/code&gt; 지정을 제외한 다른 지정자와 결합 할 수없는 &lt;a href=&quot;declarations#Specifiers&quot;&gt;&lt;i&gt;형식 지정자&lt;/i&gt; 의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6309085f92b28987d85457fbc7383fb4c82b825c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typedef&lt;/code&gt; specifier may not appear in a declaration that does not contain a declarator.</source>
          <target state="translated">&lt;code&gt;typedef&lt;/code&gt; 지정은 선언자를 포함하지 않는 선언에 나타나지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89830011be47b25898d7960332a69424f3dbd42f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typedef&lt;/code&gt; specifier, when used in a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;'s decl-specifier-seq, specifies that the declaration is a</source>
          <target state="translated">&lt;code&gt;typedef&lt;/code&gt; 지정하기, 사용될 때 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 의 않거나 계산 지정자-SEQ의 선언이 지정하는</target>
        </trans-unit>
        <trans-unit id="e11f7ccd1bfac664d81cc3008efb5f71e47d4090" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeid&lt;/code&gt; of the contained value if instance is non-empty, otherwise &lt;code&gt;typeid(void)&lt;/code&gt;.</source>
          <target state="translated">인스턴스가 비어 있지 않은 경우 포함 된 값 의 &lt;code&gt;typeid&lt;/code&gt; 입니다. 그렇지 않으면 &lt;code&gt;typeid(void)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c59bc69dc7ee8fe3806c4e7b187212bf3d16cc45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typename&lt;/code&gt; disambiguator for dependent names</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; 따라 이름 disambiguator</target>
        </trans-unit>
        <trans-unit id="86e34d32fc0fe693f849b744258e885d6bf62692" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_arg&lt;/code&gt; macro expands to an expression of type &lt;code&gt;T&lt;/code&gt; that corresponds to the next parameter from the &lt;code&gt;&lt;a href=&quot;va_list&quot;&gt;va_list&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va_arg&lt;/code&gt; 를 형의 식 매크로 팽창 &lt;code&gt;T&lt;/code&gt; 것을에서 다음 파라미터에 대응 &lt;code&gt;&lt;a href=&quot;va_list&quot;&gt;va_list&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d83c342cc7c3f40c89a420acc1bb2923f355ef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_copy&lt;/code&gt; macro copies &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8119763255f85100db2a7dfb429d2ce19267cc94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_end&lt;/code&gt; macro performs cleanup for an &lt;code&gt;ap&lt;/code&gt; object initialized by a call to &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;va_end&lt;/code&gt; may modify &lt;code&gt;ap&lt;/code&gt; so that it is no longer usable.</source>
          <target state="translated">&lt;code&gt;va_end&lt;/code&gt; 의 매크로 행한다 정리 &lt;code&gt;ap&lt;/code&gt; 개체를 호출하여 초기화 &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;va_end&lt;/code&gt; 는 더 이상 사용할 수 없도록 &lt;code&gt;ap&lt;/code&gt; 를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c4f81b011c317554f9f6191a3841f50837b79d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_start&lt;/code&gt; macro enables access to the variable arguments following the named argument &lt;code&gt;parm_n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va_start&lt;/code&gt; 를의 매크로는 명명 된 인수 다음 변수 인수에 액세스 할 수 있습니다 &lt;code&gt;parm_n&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f357e6fe110c67c4ec9157f567fd74f58c85b796" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;virtual&lt;/code&gt; specifier specifies that a non-static &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; is</source>
          <target state="translated">&lt;code&gt;virtual&lt;/code&gt; 비 정적 것을 지정자를 지정 &lt;a href=&quot;member_functions&quot;&gt;멤버 함수&lt;/a&gt; 인</target>
        </trans-unit>
        <trans-unit id="58b83f400e2fad2a7e14fb6d6d89f2b937c6c9ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weibull_distribution&lt;/code&gt; meets the requirements of a &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; and produces random numbers according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Weibull_distribution&quot;&gt;Weibull distribution&lt;/a&gt;:  f(x;a,b) =</source>
          <target state="translated">&lt;code&gt;weibull_distribution&lt;/code&gt; 는 (A)의 요구에 부합 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution을&lt;/a&gt; 받는 따른 난수를 생성 &lt;a href=&quot;https://en.wikipedia.org/wiki/Weibull_distribution&quot;&gt;이블 분포&lt;/a&gt; : F (X, A, B) =을</target>
        </trans-unit>
        <trans-unit id="5f38041d823902ae4cade7f500eac6fbdeba1f56" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;BasicLockable&lt;/strong&gt; requirements describe the minimal characteristics of types that provide exclusive blocking semantics for execution agents (i.e. threads).</source>
          <target state="translated">&lt;strong&gt;BasicLockable&lt;/strong&gt; 요구 실행 에이전트 전용 블로킹 시맨틱 (즉 스레드)를 제공하는 종류의 최소한의 특성을 설명한다.</target>
        </trans-unit>
        <trans-unit id="5e946edd904bb0f3af81272561d148e4ecfdc9d2" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Clock&lt;/strong&gt; requirements describe a bundle consisting of a &lt;code&gt;&lt;a href=&quot;../chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;, a &lt;code&gt;&lt;a href=&quot;../chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;, and a function &lt;code&gt;now()&lt;/code&gt; to get the current time_point. The origin of the clock's time_point is referred to as the clock's epoch.</source>
          <target state="translated">&lt;strong&gt;시계의&lt;/strong&gt; 요구 사항은 구성된 번들 기술 &lt;code&gt;&lt;a href=&quot;../chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; A, &lt;code&gt;&lt;a href=&quot;../chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; 및 기능은 &lt;code&gt;now()&lt;/code&gt; 현재 time_point을 얻을 수 있습니다. 시계의 time_point의 원점을 시계의 에포크라고합니다.</target>
        </trans-unit>
        <trans-unit id="f03c4da73b60ffd44de23eb92a1a79678e480926" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;LegacyIterator&lt;/strong&gt; requirements describe types that can be used to identify and traverse the elements of a container.</source>
          <target state="translated">&lt;strong&gt;LegacyIterator의&lt;/strong&gt; 요구 사항은 컨테이너의 요소를 식별하고 통과하는 데 사용할 수있는 유형을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a164898b395f07dac6b82d8a1bd649c3574d083b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Lockable&lt;/strong&gt; requirements extends the &lt;a href=&quot;basiclockable&quot;&gt;BasicLockable&lt;/a&gt; requirements to include attempted locking.</source>
          <target state="translated">&lt;strong&gt;잠금&lt;/strong&gt; 요구 사항은 확장 &lt;a href=&quot;basiclockable&quot;&gt;BasicLockable&lt;/a&gt; 시도 잠금을 포함하도록 요구 사항을.</target>
        </trans-unit>
        <trans-unit id="c33abb9f01c22e93c4eac57daba63323a35b7582" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Mutex&lt;/strong&gt; requirements extends the &lt;a href=&quot;lockable&quot;&gt;Lockable&lt;/a&gt; requirements to include inter-thread synchronization.</source>
          <target state="translated">&lt;strong&gt;뮤텍스&lt;/strong&gt; 요건은 연장 &lt;a href=&quot;lockable&quot;&gt;잠금&lt;/a&gt; 스레드 간 동기화를 포함하도록 요구한다.</target>
        </trans-unit>
        <trans-unit id="1662724e943d6f2753a841debdd483663607ada6" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Predicate&lt;/strong&gt; requirements describe a callable that returns a value testable as a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;술어의&lt;/strong&gt; 요구 사항은 같은 값 검증 반환 호출 가능한 설명 &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5fecdfd42fea2e321d400db45ac6548b84c2b1b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;SharedMutex&lt;/strong&gt; requirements extend the &lt;a href=&quot;mutex&quot;&gt;Mutex&lt;/a&gt; requirements to include shared lock ownership mode.</source>
          <target state="translated">&lt;strong&gt;SharedMutex의&lt;/strong&gt; 요구 사항은 확장 &lt;a href=&quot;mutex&quot;&gt;뮤텍스&lt;/a&gt; 공유 잠금 소유권 모드를 포함하는 요구 사항을.</target>
        </trans-unit>
        <trans-unit id="9e0e4c473412d479e82c7a7bf4efbde3fb2da4c0" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;SharedTimedMutex&lt;/strong&gt; requirements extend the &lt;a href=&quot;timedmutex&quot;&gt;TimedMutex&lt;/a&gt; requirements to include shared lock ownership mode.</source>
          <target state="translated">&lt;strong&gt;SharedTimedMutex의&lt;/strong&gt; 요구 사항은 확장 &lt;a href=&quot;timedmutex&quot;&gt;TimedMutex의&lt;/a&gt; 공유 잠금 소유권 모드를 포함하는 요구 사항을.</target>
        </trans-unit>
        <trans-unit id="d8658ec44f14a999da3cd2aea710a9e937c78300" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TimedLockable&lt;/strong&gt; requirements describe the characteristics of types that provide timed exclusive blocking semantics for execution agents (threads, processes, tasks).</source>
          <target state="translated">&lt;strong&gt;TimedLockable&lt;/strong&gt; 요구 실행 에이전트 (스레드, 프로세스, 작업)을 위해 타임 드 전용 블로킹 시맨틱을 제공하는 형태의 특성을 설명한다.</target>
        </trans-unit>
        <trans-unit id="0ffb357ce4e9175f2864be5cc3858dccf9117260" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TimedMutex&lt;/strong&gt; requirements extend the &lt;a href=&quot;timedlockable&quot;&gt;TimedLockable&lt;/a&gt; requirements to include inter-thread synchronization.</source>
          <target state="translated">&lt;strong&gt;TimedMutex의&lt;/strong&gt; 요건은 연장 &lt;a href=&quot;timedlockable&quot;&gt;TimedLockable&lt;/a&gt; 스레드 간 동기화를 포함하도록 요구한다.</target>
        </trans-unit>
        <trans-unit id="93769e4268d3151e381981cd69b445de4cedef94" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TrivialClock&lt;/strong&gt; requirements describe the requirements satisfied by several clocks in the &lt;a href=&quot;../chrono&quot;&gt;chrono library&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;TrivialClock의&lt;/strong&gt; 요구 사항은 여러 클럭 만족 요구 사항에 대해 설명 &lt;a href=&quot;../chrono&quot;&gt;크로노 라이브러리를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a31fec1fddc9cad437c97dc42d06961059327486" translate="yes" xml:space="preserve">
          <source>The Boolean literals are the keywords &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. They are &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt; of type &lt;a href=&quot;types#Boolean_type&quot;&gt;bool&lt;/a&gt;.</source>
          <target state="translated">부울 리터럴은 키워드 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 입니다. 이들은 &lt;a href=&quot;types#Boolean_type&quot;&gt;bool&lt;/a&gt; 유형의 &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="e489b3933471031f8c94a5f27d0516ca33d62cdd" translate="yes" xml:space="preserve">
          <source>The C I/O subset of the C++ standard library implements C-style stream input/output operations. The &lt;code&gt;&amp;lt;cstdio&amp;gt;&lt;/code&gt; header provides generic file operation support and supplies functions with narrow and multibyte character input/output capabilities, and the &lt;code&gt;&amp;lt;cwchar&amp;gt;&lt;/code&gt; header provides functions with wide character input/output capabilities.</source>
          <target state="translated">C ++ 표준 라이브러리의 CI / O 하위 세트는 C 스타일 스트림 입력 / 출력 조작을 구현합니다. &lt;code&gt;&amp;lt;cstdio&amp;gt;&lt;/code&gt; 헤더 좁고 멀티 바이트 문자 입력 / 출력 기능과 함께 일반 파일 조작 지원 및 공급 기능을 제공 &lt;code&gt;&amp;lt;cwchar&amp;gt;&lt;/code&gt; 헤더 넓은 문자 입력 / 출력 기능을 기능을 제공한다.</target>
        </trans-unit>
        <trans-unit id="b13410bf3298c9468849b7b32d1cee8a68202e13" translate="yes" xml:space="preserve">
          <source>The C headers &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; are not included in C++ and have no &lt;code&gt;cxxx&lt;/code&gt; equivalents.</source>
          <target state="translated">는 C 헤더 &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt; , 그리고 &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; 는 C ++에 포함 된 어떠한 없다되지 않습니다 &lt;code&gt;cxxx&lt;/code&gt; 의 등가물.</target>
        </trans-unit>
        <trans-unit id="062aac82d16ecfcd5a5e7ac044aa4b63a6939067" translate="yes" xml:space="preserve">
          <source>The C programming language followed a similar taxonomy, except that the role of assignment was no longer significant: C expressions are categorized between &quot;lvalue expressions&quot; and others (functions and non-object values), where &quot;lvalue&quot; means an expression that identifies an object, a &quot;locator value&quot;&lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;value_category#cite_note-4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">할당의 역할이 더 이상 중요하지 않다는 점을 제외하고 C 프로그래밍 언어는 유사한 분류법을 따랐습니다. C 표현식은 &quot;lvalue 표현식&quot;과 다른 것 (함수 및 비 객체 값)으로 분류됩니다. 여기서 &quot;lvalue&quot;는 객체, &quot;로케이터 값&quot; &lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;value_category#cite_note-4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="f9475fc59dfb6f8d18f4972f00f8061f2dab21b5" translate="yes" xml:space="preserve">
          <source>The C++ compiler is permitted to perform any changes to the program as long as the following remains true:</source>
          <target state="translated">C ++ 컴파일러는 다음 사항이 충족되는 한 프로그램을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e8929f0a5483d1e9f1e0fdc81fb09a71a502e05" translate="yes" xml:space="preserve">
          <source>The C++ implementation provides a default &lt;code&gt;std::terminate_handler&lt;/code&gt; function, which calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;()&lt;/code&gt;. If the null pointer value is installed (by means of &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt;), the implementation may restore the default handler instead.</source>
          <target state="translated">C ++ 구현은 &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;()&lt;/code&gt; () 를 호출 하는 기본 &lt;code&gt;std::terminate_handler&lt;/code&gt; 함수를 제공합니다 . 널 포인터 값이 설치되면 ( &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt; ) 대신 구현시 기본 핸들러를 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa1c34b3fa85012e15f5ad013556c2b855f951b" translate="yes" xml:space="preserve">
          <source>The C++ implementation provides a default &lt;code&gt;std::unexpected_handler&lt;/code&gt; function, which calls &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt;. If the null pointer value is installed (by means of &lt;code&gt;&lt;a href=&quot;set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt;), the implementation may restore the default handler instead.</source>
          <target state="translated">C ++ 구현은 &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; () 를 호출 하는 기본 &lt;code&gt;std::unexpected_handler&lt;/code&gt; 함수를 제공합니다 . 널 포인터 값이 설치되면 ( &lt;code&gt;&lt;a href=&quot;set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt; ) 대신 구현시 기본 핸들러를 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33090d97db5d6e6aae4e17a0b2eb1114378b6941" translate="yes" xml:space="preserve">
          <source>The C++ language grammar treats &lt;code&gt;mutable&lt;/code&gt; as a &lt;a href=&quot;storage_duration&quot;&gt;storage-class-specifier&lt;/a&gt;, rather than a type qualifier, but it does not affect storage class or linkage.</source>
          <target state="translated">C ++ 언어 문법은 유형 한정자가 아닌 &lt;code&gt;mutable&lt;/code&gt; &lt;a href=&quot;storage_duration&quot;&gt;클래스를 스토리지 클래스 지정자&lt;/a&gt; 로 취급 하지만 스토리지 클래스 또는 링크에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1ab622145b730130c1f77f830b45791e19e3ac6" translate="yes" xml:space="preserve">
          <source>The C++ library classes that manage their own resources follow RAII: &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;, and many others acquire their resources in constructors (which throw exceptions on errors), release them in their destructors (which never throw), and don't require explicit cleanup.</source>
          <target state="translated">자체 리소스를 관리하는 C ++ 라이브러리 클래스는 RAII : &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 따르며 , 다른 많은 사람들은 생성자에서 리소스를 가져오고 (오류에 예외를 발생시키는) 소멸자에서 해제합니다. 절대 던지지 말고 명시 적으로 정리할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="357bf595c9a6a420509871477ed4029ae08b6588" translate="yes" xml:space="preserve">
          <source>The C++ numerics library includes common mathematical functions and types, as well as optimized numeric arrays and support for random number generation.</source>
          <target state="translated">C ++ 숫자 라이브러리에는 일반적인 수학 함수 및 유형과 최적화 된 숫자 배열 및 난수 생성 지원이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0c724765aa82fdd5f42d875af648738888f7f085" translate="yes" xml:space="preserve">
          <source>The C++ source file is processed by the compiler as if the following phases take place, in this exact order:</source>
          <target state="translated">C ++ 소스 파일은 다음 단계가이 순서대로 발생하는 것처럼 컴파일러에서 처리합니다.</target>
        </trans-unit>
        <trans-unit id="298ffb6c4886717de7bb1fec94eac0b561d05f47" translate="yes" xml:space="preserve">
          <source>The C++ standard defers to the C standard for the semantics of this function. In C11 as published, unlike &lt;code&gt;&lt;a href=&quot;mbrtoc16&quot;&gt;std::mbrtoc16&lt;/a&gt;&lt;/code&gt;, which converts variable-width multibyte (such as UTF-8) to variable-width 16-bit (such as UTF-16) encoding, this function can only convert single-unit 16-bit encoding, meaning it cannot convert UTF-16 to UTF-8 despite that being the original intent of this function. This was corrected by the post-C11 defect report &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2059.htm#dr_488&quot;&gt;DR488&lt;/a&gt;.</source>
          <target state="translated">C ++ 표준은이 함수의 시맨틱에 대한 C 표준을 따릅니다. C11에서 게시 된대로 &lt;code&gt;&lt;a href=&quot;mbrtoc16&quot;&gt;std::mbrtoc16&lt;/a&gt;&lt;/code&gt; 과 달리 가변 너비 멀티 바이트 (예 : UTF-8)를 가변 너비 16 비트 (예 : UTF-16) 인코딩으로 변환하면이 함수는 단일 단위 16- 비트 인코딩으로,이 함수의 원래 의도에도 불구하고 UTF-16을 UTF-8로 변환 할 수 없습니다. 이는 C11 이후 결함 보고서 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2059.htm#dr_488&quot;&gt;DR488에&lt;/a&gt; 의해 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5cbca9c403363a5289791532ec4013a859dd4de1" translate="yes" xml:space="preserve">
          <source>The C++ standard library includes &lt;code&gt;&lt;a href=&quot;../utility/variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt;, which can replace many uses of unions and union-like classes. The example above can be re-written as.</source>
          <target state="translated">C ++ 표준 라이브러리에는 &lt;code&gt;&lt;a href=&quot;../utility/variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; 포함되어 있어 많은 공용체 및 공용체 클래스를 대체 할 수 있습니다. 위의 예는 다음과 같이 다시 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d586f49413d548237bec3d53a25aff6188f757f3" translate="yes" xml:space="preserve">
          <source>The C++ standard precisely defines the &lt;a href=&quot;as_if&quot;&gt;observable behavior&lt;/a&gt; of every C++ program that does not fall into one of the following classes:</source>
          <target state="translated">C ++ 표준 은 다음 클래스 중 하나에 속하지 않는 모든 C ++ 프로그램 의 &lt;a href=&quot;as_if&quot;&gt;관찰 가능한 동작&lt;/a&gt; 을 정확하게 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="bc703b3909b5ff52efc44a7626f3229d0fbc6ce1" translate="yes" xml:space="preserve">
          <source>The C++ standard recommends (but does not require) that lock-free atomic operations are also address-free, that is, suitable for communication between processes using shared memory.</source>
          <target state="translated">C ++ 표준은 잠금없는 원자 연산에도 주소가 없어야하며 공유 메모리를 사용하는 프로세스 간 통신에 적합하도록 권장하지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8f3b3f8c95e8561a2c8123a1e6142d5819b3a1ef" translate="yes" xml:space="preserve">
          <source>The C++ strings library includes support for three general types of strings:</source>
          <target state="translated">C ++ 문자열 라이브러리에는 세 가지 일반적인 유형의 문자열에 대한 지원이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0b7549dcc2f0a4c113aaccafcc4c4cbed6993461" translate="yes" xml:space="preserve">
          <source>The C++ type system consists of the following types:</source>
          <target state="translated">C ++ 유형 시스템은 다음 유형으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="119c8be7273e2b09e126a70072ca4bb2e62acf6b" translate="yes" xml:space="preserve">
          <source>The C99 standard suggests that C++ implementations should not define the above limit, constant, or format macros unless the macros &lt;code&gt;__STDC_LIMIT_MACROS&lt;/code&gt;, &lt;code&gt;__STDC_CONSTANT_MACROS&lt;/code&gt; or &lt;code&gt;__STDC_FORMAT_MACROS&lt;/code&gt; (respectively) are defined before including the relevant C header (&lt;code&gt;stdint.h&lt;/code&gt; or &lt;code&gt;inttypes.h&lt;/code&gt;). This recommendation was not adopted by any C++ standard and was removed in C11. However, some implementations (such as glibc 2.17) try to apply this rule, and it may be necessary to define the &lt;code&gt;__STDC&lt;/code&gt; macros; C++ compilers may try to work around this by automatically defining them in some circumstances.</source>
          <target state="translated">C99 표준은 매크로 &lt;code&gt;__STDC_LIMIT_MACROS&lt;/code&gt; , &lt;code&gt;__STDC_CONSTANT_MACROS&lt;/code&gt; 또는 &lt;code&gt;__STDC_FORMAT_MACROS&lt;/code&gt; (각각)가 관련 C 헤더 ( &lt;code&gt;stdint.h&lt;/code&gt; 또는 &lt;code&gt;inttypes.h&lt;/code&gt; ) 를 포함하기 전에 정의 되지 않는 한 C ++ 구현에서 위의 한계, 상수 또는 형식 매크로를 정의해서는 안된다고 제안합니다 . 이 권장 사항은 모든 C ++ 표준에서 채택되지 않았으며 C11에서 제거되었습니다. 그러나 glibc 2.17과 같은 일부 구현에서는이 규칙을 적용하려고 시도하며 &lt;code&gt;__STDC&lt;/code&gt; 매크로 를 정의해야 할 수도 있습니다 . C ++ 컴파일러는 일부 상황에서 자동으로 정의하여이 문제를 해결하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1875a6ffd723ddc8488fac7c4fd4bb1c70e58c7" translate="yes" xml:space="preserve">
          <source>The Containers library is a generic collection of class templates and algorithms that allow programmers to easily implement common data structures like queues, lists and stacks. There are three classes of containers -- sequence containers, associative containers, and unordered associative containers -- each of which is designed to support a different set of operations.</source>
          <target state="translated">컨테이너 라이브러리는 프로그래머가 대기열, 목록 및 스택과 같은 일반적인 데이터 구조를 쉽게 구현할 수 있도록하는 일반적인 클래스 템플릿 및 알고리즘 모음입니다. 컨테이너에는 시퀀스 컨테이너, 연관 컨테이너 및 정렬되지 않은 연관 컨테이너의 세 가지 클래스가 있으며 각 클래스는 서로 다른 작업 집합을 지원하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="375fce85970054ab82a9ff1b316f12d60649e4d2" translate="yes" xml:space="preserve">
          <source>The Filesystem library provides facilities for performing operations on file systems and their components, such as paths, regular files, and directories.</source>
          <target state="translated">파일 시스템 라이브러리는 파일 시스템 및 해당 구성 요소 (예 : 경로, 일반 파일 및 디렉토리)에서 작업을 수행하기위한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a686aa5105100888fccb4fa37b5d32b1bb8131e" translate="yes" xml:space="preserve">
          <source>The GCC flag &quot;-fcx-limited-range&quot; (included by &quot;-ffast-math&quot;) changes the behavior of complex multiply/division by removing checks for floating point edge cases. This impacts loop vectorization.</source>
          <target state="translated">GCC 플래그 &quot;-fcx-limited-range&quot;( &quot;-ffast-math&quot;에 포함)는 부동 소수점 에지 케이스에 대한 검사를 제거하여 복잡한 곱셈 / 나눗셈의 동작을 변경합니다. 이는 루프 벡터화에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="a8074f7033d870355bda79f918df527e49c8242e" translate="yes" xml:space="preserve">
          <source>The GNU implementation does not set &lt;code&gt;errno&lt;/code&gt; regardless of &lt;code&gt;math_errhandling&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f5bf99aae73a16cde460248e85a7f247bf09d8" translate="yes" xml:space="preserve">
          <source>The Hermite polynomials are the polynomial solutions of the equation u,,</source>
          <target state="translated">에르 미트 다항식은 방정식 u의 다항식 해입니다.</target>
        </trans-unit>
        <trans-unit id="092e83a5c399ab499607c9303ca6334373b3d256" translate="yes" xml:space="preserve">
          <source>The I/O manipulator &lt;code&gt;&lt;a href=&quot;../../io/manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; offers a simpler interface to this function.</source>
          <target state="translated">I / O 조작기 &lt;code&gt;&lt;a href=&quot;../../io/manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; 는이 기능에 대한 간단한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9281aeb716927d1d5830d84161987fd2ba2a83b8" translate="yes" xml:space="preserve">
          <source>The I/O manipulator &lt;code&gt;&lt;a href=&quot;../manip/ws&quot;&gt;std::ws&lt;/a&gt;&lt;/code&gt;, if it reaches the end of the stream while consuming whitespace (but, unlike the formatted input sentry, it does not set &lt;code&gt;failbit&lt;/code&gt; in this case)</source>
          <target state="translated">I / O 조작자 &lt;code&gt;&lt;a href=&quot;../manip/ws&quot;&gt;std::ws&lt;/a&gt;&lt;/code&gt; 는 공백을 소비하면서 스트림 끝에 도달하면 형식화 된 입력 센트리와 &lt;code&gt;failbit&lt;/code&gt; 경우 페일 비트 를 설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6cae64dc315ceedbcf629806178c5dfee8ef5b63" translate="yes" xml:space="preserve">
          <source>The I/O stream function &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt; is implemented in terms of this function.</source>
          <target state="translated">I / O 스트림 함수 &lt;a href=&quot;../basic_istream/putback&quot;&gt; &lt;code&gt;basic_istream::putback&lt;/code&gt; &lt;/a&gt; 은이 함수와 관련하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="39d7fe0b74278434911b1c661010e64ceaad4782" translate="yes" xml:space="preserve">
          <source>The I/O stream function &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; is implemented in terms of this function.</source>
          <target state="translated">I / O 스트림 기능 &lt;a href=&quot;../basic_istream/unget&quot;&gt; &lt;code&gt;basic_istream::unget&lt;/code&gt; &lt;/a&gt; 은이 기능으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="187b46348f3fb61e44d273bc8c245c052215a7b7" translate="yes" xml:space="preserve">
          <source>The I/O stream objects &lt;code&gt;&lt;a href=&quot;basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;, as well as all objects derived from them (&lt;code&gt;&lt;a href=&quot;basic_ofstream&quot;&gt;std::ofstream&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt;, etc), are implemented entirely in terms of &lt;code&gt;std::basic_streambuf&lt;/code&gt;.</source>
          <target state="translated">I / O 스트림 오브젝트 &lt;code&gt;&lt;a href=&quot;basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 및 그로부터 파생 된 모든 오브젝트 ( &lt;code&gt;&lt;a href=&quot;basic_ofstream&quot;&gt;std::ofstream&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt; 등)는 완전히 &lt;code&gt;std::basic_streambuf&lt;/code&gt; 관점에서 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="234938443728dc9d7125d6292e796aa03d968ac4" translate="yes" xml:space="preserve">
          <source>The IEEE floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt; calculated by this function is exactly the value &lt;code&gt;x - n*y&lt;/code&gt;, where the value &lt;code&gt;n&lt;/code&gt; is the integral value nearest the exact value &lt;code&gt;x/y&lt;/code&gt;. When |n-x/y| = &amp;frac12;, the value &lt;code&gt;n&lt;/code&gt; is chosen to be even.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd42feee39816a2ee87bbe7649ebf6a7a843b59" translate="yes" xml:space="preserve">
          <source>The ISO C++ language standard does not require the compilers to support any pragmas. However, several non-standard pragmas are supported by multiple implementations:</source>
          <target state="translated">ISO C ++ 언어 표준에서는 컴파일러가 pragma를 지원하지 않아도됩니다. 그러나 여러 비표준 pragma는 여러 구현에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="45d880ebb358a8cd4be3fa1496f29c34a4f3baeb" translate="yes" xml:space="preserve">
          <source>The Laguerre polynomials are the polynomial solutions of the equation xy,,</source>
          <target state="translated">Laguerre 다항식은 방정식 xy의 다항식 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="92d3f731dc95a519a499ea6ab412b29f1b0d8f74" translate="yes" xml:space="preserve">
          <source>The Mathematical Special Functions library was originally part of Library TR1 ISO/IEC TR 19768:2007, then published as an independent ISO standard, ISO/IEC 29124:2010, and finally merged to ISO C++ as of C++17.</source>
          <target state="translated">수학 특수 함수 라이브러리는 원래 라이브러리 TR1 ISO / IEC TR 19768 : 2007의 일부였으며 독립 ISO 표준 ISO / IEC 29124 : 2010으로 발행되었으며 C ++ 17에서 ISO C ++로 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="a8ec2b4252a83835e14c1e7646bcf468077a9b9f" translate="yes" xml:space="preserve">
          <source>The POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html&quot;&gt;clock_gettime(CLOCK_REALTIME, ts)&lt;/a&gt; may also be used to populate a &lt;code&gt;std::timespec&lt;/code&gt; with the time since the Epoch.</source>
          <target state="translated">POSIX 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html&quot;&gt;clock_gettime (CLOCK_REALTIME, ts)을&lt;/a&gt; 사용하여 &lt;code&gt;std::timespec&lt;/code&gt; 을 Epoch 이후의 시간 으로 채울 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a9eb1a54a47019935774d069af9e7242497fee5" translate="yes" xml:space="preserve">
          <source>The Promise type is determined by the compiler from the return type of the coroutine using &lt;code&gt;std::coroutine_traits&lt;/code&gt;.</source>
          <target state="translated">Promise 유형은 &lt;code&gt;std::coroutine_traits&lt;/code&gt; 사용하여 코 루틴의 반환 유형에서 컴파일러에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="82ffea0821c074edc08abd9ba5cab6f4451a0c94" translate="yes" xml:space="preserve">
          <source>The UTC equivalent of &lt;code&gt;tp&lt;/code&gt; according to the rules of this time zone.</source>
          <target state="translated">이 시간대 의 규칙에 따른 &lt;code&gt;tp&lt;/code&gt; 의 UTC 입니다.</target>
        </trans-unit>
        <trans-unit id="193657644c5ee833732a5b060501afa9d523bb28" translate="yes" xml:space="preserve">
          <source>The above definition requires that the result of &lt;code&gt;std::ratio_add&amp;lt;R1, R2&amp;gt;&lt;/code&gt; be already reduced to lowest terms; for example, &lt;code&gt;std::ratio_add&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 3&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">위의 정의는 &lt;code&gt;std::ratio_add&amp;lt;R1, R2&amp;gt;&lt;/code&gt; 의 결과 가 이미 가장 낮은 용어로 축소되어 있어야합니다. 예를 들어, &lt;code&gt;std::ratio_add&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 3&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 2&amp;gt;&lt;/code&gt; 와 동일한 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="23bee8585a3cc592fe0e1d9255e72f13d3dba2ab" translate="yes" xml:space="preserve">
          <source>The above definition requires that the result of &lt;code&gt;std::ratio_divide&amp;lt;R1, R2&amp;gt;&lt;/code&gt; be already reduced to lowest terms; for example, &lt;code&gt;std::ratio_divide&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 12&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">위의 정의는 &lt;code&gt;std::ratio_divide&amp;lt;R1, R2&amp;gt;&lt;/code&gt; 의 결과 가 이미 가장 낮은 항으로 축소되어 있어야합니다. 예를 들어 &lt;code&gt;std::ratio_divide&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 12&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 2&amp;gt;&lt;/code&gt; 와 동일한 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="7967282b7690ce10ae090be67d8a3935e530adf1" translate="yes" xml:space="preserve">
          <source>The above definition requires that the result of &lt;code&gt;std::ratio_multiply&amp;lt;R1, R2&amp;gt;&lt;/code&gt; be already reduced to lowest terms; for example, &lt;code&gt;std::ratio_multiply&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;4, 5&amp;gt;&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;2, 15&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">위의 정의는 &lt;code&gt;std::ratio_multiply&amp;lt;R1, R2&amp;gt;&lt;/code&gt; 의 결과 가 이미 최저 조건으로 축소되어 있어야합니다. 예를 들어, &lt;code&gt;std::ratio_multiply&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;4, 5&amp;gt;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;2, 15&amp;gt;&lt;/code&gt; 와 동일한 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="f9896527cafdbbeacf853f6f95e1e7fc464c2579" translate="yes" xml:space="preserve">
          <source>The above definition requires that the result of &lt;code&gt;std::ratio_subtract&amp;lt;R1, R2&amp;gt;&lt;/code&gt; be already reduced to lowest terms; for example, &lt;code&gt;std::ratio_subtract&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 2&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 3&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">위의 정의는 &lt;code&gt;std::ratio_subtract&amp;lt;R1, R2&amp;gt;&lt;/code&gt; 의 결과 가 이미 가장 낮은 항으로 축소되어 있어야합니다. 예를 들어, &lt;code&gt;std::ratio_subtract&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 2&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 3&amp;gt;&lt;/code&gt; 과 동일한 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="6568dd4bee0354c7a7d990d9fa61c5ac047fa7c2" translate="yes" xml:space="preserve">
          <source>The above example defines a function similar to &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;, that replace each occurrence of the character % in the format string with a value.</source>
          <target state="translated">위의 예제는 &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; 와 유사한 함수를 정의 하여 형식 문자열에서 각 문자 %를 값으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="673689d4371938b6b75dd6a80d2ed08e06191c09" translate="yes" xml:space="preserve">
          <source>The above requirements make it possible to compare &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;'s iterators and const_iterators.</source>
          <target state="translated">위의 요구 사항을 통해 &lt;a href=&quot;container&quot;&gt;컨테이너&lt;/a&gt; 의 반복자와 const_iterator 를 비교할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13d09dc3f8ca032e8d2bc9d35592ce1dc3be4e55" translate="yes" xml:space="preserve">
          <source>The above rules apply to pointers as well (binding a reference to virtual base is replaced by implicit conversion to a pointer to virtual base), with two additional rules:</source>
          <target state="translated">위의 규칙은 두 가지 추가 규칙과 함께 포인터에도 적용됩니다 (가상베이스에 대한 참조 바인딩은 가상베이스에 대한 포인터에 대한 암시 적 변환으로 대체 됨).</target>
        </trans-unit>
        <trans-unit id="f952896411170dfd5fc7f72e86070ffe524d617b" translate="yes" xml:space="preserve">
          <source>The above rules imply that LegacyRandomAccessIterator also implements &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;.</source>
          <target state="translated">위의 규칙은 LegacyRandomAccessIterator도 &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; 을 구현 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="ee13435b654a2d72d3e32f79eb5a6c87ce8ef606" translate="yes" xml:space="preserve">
          <source>The above syntax produces code equivalent to the following (&lt;b&gt;&lt;code&gt;__range&lt;/code&gt;&lt;/b&gt;, &lt;b&gt;&lt;code&gt;__begin&lt;/code&gt;&lt;/b&gt; and &lt;b&gt;&lt;code&gt;__end&lt;/code&gt;&lt;/b&gt; are for exposition only):</source>
          <target state="translated">위의 구문은 다음과 같은 코드를 생성합니다 ( &lt;b&gt; &lt;code&gt;__range&lt;/code&gt; &lt;/b&gt; , &lt;b&gt; &lt;code&gt;__begin&lt;/code&gt; &lt;/b&gt; 및 &lt;b&gt; &lt;code&gt;__end&lt;/code&gt; &lt;/b&gt; 는 박람회 전용).</target>
        </trans-unit>
        <trans-unit id="0b89b4d6624b7e332138a5ba2c5eb8e3386c894a" translate="yes" xml:space="preserve">
          <source>The above syntax produces code equivalent to:</source>
          <target state="translated">위의 구문은 다음과 같은 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1488e3e1725ba2ff4aa290f686cae3ecf80e21d5" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;n&lt;/code&gt; (i.e. &lt;code&gt;|n|&lt;/code&gt;), if it is representable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d1536a638b1783251f3fd22ff06e9dcd2eddad" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;n&lt;/code&gt; must be within the range of representable values of &lt;code&gt;difference_type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 의 절대 값은 &lt;code&gt;difference_type&lt;/code&gt; 의 표현 가능한 값 범위 내에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="68f35b30bcbca2a2334fe59e8dc3c3799211505f" translate="yes" xml:space="preserve">
          <source>The accessor &lt;code&gt;get_allocator()&lt;/code&gt; obtains a copy of the allocator that was used to construct the container or installed by the most recent allocator replacement operation.</source>
          <target state="translated">접근 자 &lt;code&gt;get_allocator()&lt;/code&gt; 는 컨테이너를 구성하는 데 사용되었거나 가장 최근의 할당 기 교체 작업으로 설치 한 할당 기의 복사본을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="248f185c6f7dd3faa7f112b79d90246cce8de025" translate="yes" xml:space="preserve">
          <source>The actual address of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">실제 주소 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba8439aff56e6d0648a49f1a69361b2accd1241" translate="yes" xml:space="preserve">
          <source>The actual catalog location is implementation-defined: for the catalog &lt;code&gt;&quot;sed&quot;&lt;/code&gt; (message catalogs installed with the Unix utility &lt;code&gt;'sed'&lt;/code&gt;) in German locale, for example, the file opened by this function call may be &lt;code&gt;/usr/lib/nls/msg/de_DE/sed.cat&lt;/code&gt;, &lt;code&gt;/usr/lib/locale/de_DE/LC_MESSAGES/sed.cat&lt;/code&gt;, or &lt;code&gt;/usr/share/locale/de/LC_MESSAGES/sed.mo&lt;/code&gt;.</source>
          <target state="translated">실제 카탈로그 위치는 구현에서 정의됩니다. 예를 들어, 독일어 로케일의 &lt;code&gt;&quot;sed&quot;&lt;/code&gt; 카탈로그 (유닉스 유틸리티 &lt;code&gt;'sed'&lt;/code&gt; 와 함께 설치된 메시지 카탈로그 )의 경우이 함수 호출로 열린 파일은 &lt;code&gt;/usr/lib/nls/msg/de_DE/sed.cat&lt;/code&gt; , &lt;code&gt;/usr/lib/locale/de_DE/LC_MESSAGES/sed.cat&lt;/code&gt; 또는 &lt;code&gt;/usr/share/locale/de/LC_MESSAGES/sed.mo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49de6cda744aa686d13f772c6d9cb13603ef64e6" translate="yes" xml:space="preserve">
          <source>The actual hash functions are implementation-dependent and are not required to fulfill any other quality criteria except those specified above. Notably, some implementations use trivial (identity) hash functions which map an integer to itself. In other words, these hash functions are designed to work with unordered associative containers, but not as cryptographic hashes, for example.</source>
          <target state="translated">실제 해시 함수는 구현에 따라 다르며 위에서 지정한 것을 제외한 다른 품질 기준을 충족 할 필요는 없습니다. 특히 일부 구현에서는 정수를 자체에 매핑하는 사소한 (식별) 해시 함수를 사용합니다. 즉, 이러한 해시 함수는 순서가 지정되지 않은 연관 컨테이너에서 작동하도록 설계되었지만 암호화 해시로는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a33d76aa419c87cdb7499801f1438c727323ce4c" translate="yes" xml:space="preserve">
          <source>The address of a static member function may be stored in a regular &lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;pointer to function&lt;/a&gt;, but not in a &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;pointer to member function&lt;/a&gt;.</source>
          <target state="translated">정적 멤버 함수의 주소는 &lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;함수&lt;/a&gt; 에 대한 &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;포인터가&lt;/a&gt; 아니라 함수 에 대한 일반 포인터에 저장 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46a1f41e08509f4ba5888588f4190bd93cace159" translate="yes" xml:space="preserve">
          <source>The address-of operator expressions have the form.</source>
          <target state="translated">주소 연산자 표현식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07473e470460f5d5bae4943e056fd9640065fcdf" translate="yes" xml:space="preserve">
          <source>The address-of operator, &lt;code&gt;operator&amp;amp;&lt;/code&gt;. If the unary &amp;amp; is applied to an lvalue of incomplete type and the complete type declares an overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt;, the behavior is undefined(until C++11) it is unspecified whether the operator has the built-in meaning or the operator function is called(since C++11). Because this operator may be overloaded, generic libraries use &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; to obtain addresses of objects of user-defined types. The best known example of a canonical overloaded operator&amp;amp; is the Microsoft class &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/31k6d0k7(v=vs.140).aspx&quot;&gt;CComPtr&lt;/a&gt;. An example of its use in EDSL can be found in &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/operator/and_predicate.html&quot;&gt;boost.spirit&lt;/a&gt;.</source>
          <target state="translated">주소 - 운영자, &lt;code&gt;operator&amp;amp;&lt;/code&gt; . 단항 &amp;amp;가 불완전한 유형의 lvalue에 적용되고 complete 유형이 오버로드 된 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 선언 하면 동작이 정의되지 않습니다 (C ++ 11까지). (C ++ 11부터). 이 연산자는 오버로드 될 수 있으므로 일반 라이브러리는 &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 유형의 오브젝트 주소를 얻습니다. 정식 오버로드 연산자의 가장 잘 알려진 예는 Microsoft 클래스 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/31k6d0k7(v=vs.140).aspx&quot;&gt;CComPtr&lt;/a&gt; 입니다. EDSL에서의 사용 예는 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/operator/and_predicate.html&quot;&gt;boost.spirit&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1e6e05504e8bf834074fc272ad4977ce0312c5b" translate="yes" xml:space="preserve">
          <source>The adjusted value of &lt;code&gt;ptr&lt;/code&gt;, or null pointer value if the space provided is too small.</source>
          <target state="translated">조정 된 &lt;code&gt;ptr&lt;/code&gt; 값 또는 제공된 공간이 너무 작은 경우 널 포인터 값</target>
        </trans-unit>
        <trans-unit id="8ba619de076192371e302cacb5d006589d46013e" translate="yes" xml:space="preserve">
          <source>The adjustment flag is obtained as if by &lt;code&gt;std::fmtflags adjustfield = (flags &amp;amp; (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;))&lt;/code&gt; and examined to identify padding location, as follows</source>
          <target state="translated">조정 플래그는 &lt;code&gt;std::fmtflags adjustfield = (flags &amp;amp; (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;))&lt;/code&gt; 의해 획득 되고 다음과 같이 패딩 위치를 식별하기 위해 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="926f65c8bd0c6d1333036efaf176755bf09a15fc" translate="yes" xml:space="preserve">
          <source>The algorithm is stable (preserves the relative order of the selected elements) only if &lt;code&gt;PopulationIterator&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PopulationIterator&lt;/code&gt; 가 &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; 의 요구 사항을 충족하는 경우에만 알고리즘이 안정적입니다 (선택한 요소의 상대적 순서 유지) .</target>
        </trans-unit>
        <trans-unit id="c1563a53b10adbf5f25802b7bd384fbe70e9e0ee" translate="yes" xml:space="preserve">
          <source>The algorithm used is typically &lt;a href=&quot;https://en.wikipedia.org/wiki/Introselect&quot;&gt;introselect&lt;/a&gt; although other &lt;a href=&quot;https://en.wikipedia.org/wiki/Selection_algorithm&quot;&gt;selection algorithms&lt;/a&gt; with suitable average-case complexity are allowed.</source>
          <target state="translated">적절한 평균 대소 문자를 가진 다른 &lt;a href=&quot;https://en.wikipedia.org/wiki/Selection_algorithm&quot;&gt;선택 알고리즘&lt;/a&gt; 이 허용 되지만 사용되는 알고리즘은 일반적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Introselect&quot;&gt;introselect&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ae39cc0aa4f0b72a9e3acc6a7ed0ccc5705bbfb5" translate="yes" xml:space="preserve">
          <source>The algorithms library defines functions for a variety of purposes (e.g. searching, sorting, counting, manipulating) that operate on ranges of elements. Note that a range is defined as &lt;code&gt;[first, last)&lt;/code&gt; where &lt;code&gt;last&lt;/code&gt; refers to the element</source>
          <target state="translated">알고리즘 라이브러리는 다양한 요소에서 작동하는 다양한 목적 (예 : 검색, 정렬, 계산, 조작)을위한 함수를 정의합니다. 범위는 &lt;code&gt;[first, last)&lt;/code&gt; 로 정의되며 여기서 &lt;code&gt;last&lt;/code&gt; 는 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="22069e3480b3c9b1c4947adb5070a312d1235611" translate="yes" xml:space="preserve">
          <source>The alias template &lt;code&gt;std::ratio_add&lt;/code&gt; denotes the result of adding two exact rational fractions represented by the &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specializations &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt;.</source>
          <target state="translated">별명 템플리트 &lt;code&gt;std::ratio_add&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 특수화 &lt;code&gt;R1&lt;/code&gt; 및 &lt;code&gt;R2&lt;/code&gt; 로 표시되는 두 개의 정확한 합리적인 분수를 추가 한 결과를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1fc9398a20f036593956ab3dbbede1771345f9e1" translate="yes" xml:space="preserve">
          <source>The alias template &lt;code&gt;std::ratio_divide&lt;/code&gt; denotes the result of dividing two exact rational fractions represented by the &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specializations &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt;.</source>
          <target state="translated">별명 템플리트 &lt;code&gt;std::ratio_divide&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 특수화 &lt;code&gt;R1&lt;/code&gt; 및 &lt;code&gt;R2&lt;/code&gt; 로 표시되는 두 개의 정확한 합리적인 분수를 나눈 결과를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="dee97ce6a58d133cf337086f34c62b2e6a147bd9" translate="yes" xml:space="preserve">
          <source>The alias template &lt;code&gt;std::ratio_multiply&lt;/code&gt; denotes the result of multiplying two exact rational fractions represented by the &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specializations &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt;.</source>
          <target state="translated">별명 템플리트 &lt;code&gt;std::ratio_multiply&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 특수화 &lt;code&gt;R1&lt;/code&gt; 및 &lt;code&gt;R2&lt;/code&gt; 로 표시되는 두 개의 정확한 합리적인 분수를 곱한 결과를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="62bf1af23a1c024978417eae0034999b5ac1bd02" translate="yes" xml:space="preserve">
          <source>The alias template &lt;code&gt;std::ratio_subtract&lt;/code&gt; denotes the result of subtracting two exact rational fractions represented by the &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specializations &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt;.</source>
          <target state="translated">별명 템플리트 &lt;code&gt;std::ratio_subtract&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 특수화 &lt;code&gt;R1&lt;/code&gt; 및 &lt;code&gt;R2&lt;/code&gt; 로 표시되는 두 개의 정확한 합리적인 분수를 뺀 결과를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="4377573b03e0c1dad62c68a8a05177fc20b8746c" translate="yes" xml:space="preserve">
          <source>The allocator to use by the copy-constructed standard containers.</source>
          <target state="translated">복사 구성 표준 컨테이너에서 사용할 할당 자입니다.</target>
        </trans-unit>
        <trans-unit id="0c4781cc2700c28248cc1a31d718fc4fde15e2a7" translate="yes" xml:space="preserve">
          <source>The alternatives to the pImpl idiom are.</source>
          <target state="translated">pImpl 관용구의 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9b7b590e1cbea82e6b155f3de6c58aad7b88034" translate="yes" xml:space="preserve">
          <source>The amount of 32-bit integers copied by &lt;code&gt;param&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;param&lt;/code&gt; 에 의해 복사 된 32 비트 정수의 양입니다 .</target>
        </trans-unit>
        <trans-unit id="29000d5dd09096c4a0e5e6f79a569175406a28de" translate="yes" xml:space="preserve">
          <source>The amount of time between this &lt;code&gt;time_point&lt;/code&gt; and the &lt;code&gt;clock&lt;/code&gt;'s epoch.</source>
          <target state="translated">이 &lt;code&gt;time_point&lt;/code&gt; 와 &lt;code&gt;clock&lt;/code&gt; 의 에포크 사이의 시간 입니다.</target>
        </trans-unit>
        <trans-unit id="781837e5b78f423a72b4bc7bbfde9fb961de52a5" translate="yes" xml:space="preserve">
          <source>The apparent size of the pushback buffer may be larger if the character that is pushed back equals the character existing at that location in the external character sequence (the implementation may simply decrement the read file position indicator and avoid maintaining a pushback buffer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755a5a48206440558fe0aeebdc09b4c90a71a37f" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;n&lt;/code&gt; must be equal to the first argument of the call to &lt;code&gt;&lt;a href=&quot;allocate&quot;&gt;allocate()&lt;/a&gt;&lt;/code&gt; that originally produced &lt;code&gt;p&lt;/code&gt;; otherwise, the behavior is undefined.</source>
          <target state="translated">인수 &lt;code&gt;n&lt;/code&gt; 은 원래 &lt;code&gt;p&lt;/code&gt; 를 생성 한 &lt;code&gt;&lt;a href=&quot;allocate&quot;&gt;allocate()&lt;/a&gt;&lt;/code&gt; 호출의 첫 번째 인수와 같아야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed300236670f94b994460867ddba4af778962013" translate="yes" xml:space="preserve">
          <source>The argument is first converted to &lt;code&gt;unsigned char&lt;/code&gt;. If the &lt;b&gt;l&lt;/b&gt; modifier is used, the argument is first converted to a character string as if by &lt;b&gt;%ls&lt;/b&gt; with a &lt;code&gt;wchar_t[2]&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e173a96999867556e8be948298df40ea6171ebef" translate="yes" xml:space="preserve">
          <source>The argument is first converted to &lt;code&gt;wchar_t&lt;/code&gt; as if by calling &lt;code&gt;btowc&lt;/code&gt;. If the &lt;b&gt;l&lt;/b&gt; modifier is used, the &lt;code&gt;wint_t&lt;/code&gt; argument is first converted to &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="translated">인수는 &lt;code&gt;btowc&lt;/code&gt; 를 호출 하여 먼저 &lt;code&gt;wchar_t&lt;/code&gt; 로 변환됩니다 . 경우] &lt;b&gt;L의&lt;/b&gt; 개질제가 사용되는 상기 &lt;code&gt;wint_t&lt;/code&gt; 의 인수로 변환되어 제 &lt;code&gt;wchar_t&lt;/code&gt; .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="21f94c3f9702cceebf7320693c46bd6df0e894dd" translate="yes" xml:space="preserve">
          <source>The argument list</source>
          <target state="translated">인수 목록</target>
        </trans-unit>
        <trans-unit id="0ff8f0382d945790b4abb92eaf3d7bab75f243ba" translate="yes" xml:space="preserve">
          <source>The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to &lt;code&gt;mbrtowc&lt;/code&gt; with zero-initialized conversion state.</source>
          <target state="translated">인수는 초기 시프트 상태에서 시작하는 멀티 바이트 문자 시퀀스를 포함하는 문자 배열의 초기 요소에 대한 포인터 여야하며, 초기화 상태가 0 인 &lt;code&gt;mbrtowc&lt;/code&gt; 를 호출하는 것처럼 와이드 문자 배열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a03b5940fa2b2b9a645f3d15e3a9855662e07fb" translate="yes" xml:space="preserve">
          <source>The argument must be a pointer to the initial element of an array of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="939cc9bc79190c70cc6b243a0d3d41e818910280" translate="yes" xml:space="preserve">
          <source>The argument-parameter implicit conversion sequences considered by overload resolution correspond to &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; used in &lt;a href=&quot;copy_initialization&quot;&gt;copy initialization&lt;/a&gt; (for non-reference parameters), except that when considering conversion to the implicit object parameter or to the left-hand side of assignment operator, conversions that create temporary objects are not considered.</source>
          <target state="translated">과부하 해결로 고려되는 인수 매개 변수 내재적 변환 시퀀스 는 &lt;a href=&quot;copy_initialization&quot;&gt;복사 초기화에&lt;/a&gt; 사용 된 &lt;a href=&quot;implicit_cast&quot;&gt;내재적 변환&lt;/a&gt; (비 참조 매개 변수의 경우)에 해당하지만 내재적 오브젝트 매개 변수 또는 할당 연산자의 왼쪽으로의 변환을 고려할 때 임시 객체 생성은 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="adaf20221647bf5f016df161d3227931e72c0e0a" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;std::bind_front&lt;/code&gt; are copied or moved, and are never passed by reference unless wrapped in &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::bind_front&lt;/code&gt; 대한 인수 는 복사되거나 이동되며 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; 래핑되지 않는 한 참조에 의해 전달되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d29b07ff6f09d0235dd01cb74baba1369ae91983" translate="yes" xml:space="preserve">
          <source>The arguments to bind are copied or moved, and are never passed by reference unless wrapped in &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">바인드 할 인수는 복사 또는 이동되며 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; 래핑되지 않는 한 참조로 전달되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="16183ca09e08051a6a498c1b8e176b39fe04556e" translate="yes" xml:space="preserve">
          <source>The arguments to the thread function are moved or copied by value. If a reference argument needs to be passed to the thread function, it has to be wrapped (e.g. with &lt;code&gt;&lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">스레드 함수에 대한 인수는 값별로 이동되거나 복사됩니다. 참조 인수를 스레드 함수에 전달해야하는 경우 랩핑해야합니다 (예 : &lt;code&gt;&lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="30dd24a9b07849107ca8c554f4f6d40ca611c92d" translate="yes" xml:space="preserve">
          <source>The array is initialized as in &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, except that narrowing conversions are allowed and any elements without an initializer are &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">배열은 축소 변환이 허용되고 이니셜 라이저가없는 요소가 &lt;a href=&quot;value_initialization&quot;&gt;값으로 초기화&lt;/a&gt; 된다는 점을 제외하면 &lt;a href=&quot;aggregate_initialization&quot;&gt;집계 초기화&lt;/a&gt; 에서와 같이 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="52bcb2ba93527988f88f98602d063b00271dc8bb" translate="yes" xml:space="preserve">
          <source>The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">배열은 겹칠 수 있습니다. 와이드 문자가 임시 와이드 문자 배열로 복사 된 다음 임시 배열에서 &lt;code&gt;dest&lt;/code&gt; 로 복사 된 것처럼 복사가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1ce22bddbd5afcd8d2b9975482c42ad2a4cf0c6" translate="yes" xml:space="preserve">
          <source>The as-if rule</source>
          <target state="translated">as-if 규칙</target>
        </trans-unit>
        <trans-unit id="d858c67cf82093a6f8fd583515b76052a6e02bc9" translate="yes" xml:space="preserve">
          <source>The assignment operator (&lt;code&gt;operator=&lt;/code&gt;) has special properties: see &lt;a href=&quot;as_operator&quot;&gt;copy assignment&lt;/a&gt; and &lt;a href=&quot;move_operator&quot;&gt;move assignment&lt;/a&gt; for details.</source>
          <target state="translated">할당 연산자 ( &lt;code&gt;operator=&lt;/code&gt; )에는 특수 속성이 있습니다. 자세한 내용은 &lt;a href=&quot;as_operator&quot;&gt;복사 할당&lt;/a&gt; 및 &lt;a href=&quot;move_operator&quot;&gt;이동 할당&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c5d518628da2787a486bdb9a3bf4a44f60ddd55" translate="yes" xml:space="preserve">
          <source>The associated Laguerre polynomials are the polynomial solutions of the equation \(x\ddot{y} + (m+1-x)\dot{y} + ny = 0\)xy,,</source>
          <target state="translated">관련된 Laguerre 다항식은 방정식 \ (x \ ddot {y} + (m + 1-x) \ dot {y} + ny = 0 \) xy의 다항식입니다.</target>
        </trans-unit>
        <trans-unit id="cc4b473d4edca4fe8545285d21ee1d98e8fe3d3e" translate="yes" xml:space="preserve">
          <source>The associated allocator.</source>
          <target state="translated">연관된 할당 자.</target>
        </trans-unit>
        <trans-unit id="9448faeee2cd31ccafe96e60d57e87c5096f2e84" translate="yes" xml:space="preserve">
          <source>The associated file stream or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if an error has occurred.</source>
          <target state="translated">연관된 파일 스트림 또는 오류가 발생한 경우 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4048a32e4d36e4b4a7b6ceb3bdafa2370c883fb3" translate="yes" xml:space="preserve">
          <source>The associated locale is the value supplied to &lt;code&gt;&lt;a href=&quot;pubimbue&quot;&gt;pubimbue()&lt;/a&gt;&lt;/code&gt; on the last call, or, if that function has not been called, the value of the global locale (&lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt;) at the time of the construction of the streambuf.</source>
          <target state="translated">연관된 로케일은 마지막 호출에서 &lt;code&gt;&lt;a href=&quot;pubimbue&quot;&gt;pubimbue()&lt;/a&gt;&lt;/code&gt; 에 제공된 값 이거나 해당 함수가 호출되지 않은 경우 streambuf 구성시 글로벌 로케일 ( &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; ) 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="02393976fc180c9b25d5d69be609960418d8ef30" translate="yes" xml:space="preserve">
          <source>The associated locale.</source>
          <target state="translated">연결된 로캘입니다.</target>
        </trans-unit>
        <trans-unit id="8552825362c8523a19e9943122503974571d213a" translate="yes" xml:space="preserve">
          <source>The associated stream buffer, or a null pointer if there was no associated stream buffer.</source>
          <target state="translated">연관된 스트림 버퍼 또는 연관된 스트림 버퍼가없는 경우 널 포인터</target>
        </trans-unit>
        <trans-unit id="0783a046d6d1ff8d52f71c9b805d9b58a80c4a97" translate="yes" xml:space="preserve">
          <source>The atomic library provides components for fine-grained atomic operations allowing for lockless concurrent programming. Each atomic operation is indivisible with regards to any other atomic operation that involves the same object. Atomic objects are &lt;a href=&quot;language/memory_model#Threads_and_data_races&quot;&gt;free of data races&lt;/a&gt;.</source>
          <target state="translated">원자 라이브러리는 세밀한 원자 작업을위한 구성 요소를 제공하여 잠금없는 동시 프로그래밍이 가능합니다. 각 원자 연산은 동일한 객체를 포함하는 다른 원자 연산과 관련하여 불가분의입니다. 원자 객체는 &lt;a href=&quot;language/memory_model#Threads_and_data_races&quot;&gt;데이터 레이스가 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4adeb68c9c4013712d2aed1000d4e09e476ea64d" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;[[&lt;a href=&quot;attributes/optimize_for_synchronized&quot;&gt;optimize_for_synchronized&lt;/a&gt;]]&lt;/code&gt; may be applied to a declarator in a function declaration and must appear on the first declaration of the function.</source>
          <target state="translated">&lt;code&gt;[[&lt;a href=&quot;attributes/optimize_for_synchronized&quot;&gt;optimize_for_synchronized&lt;/a&gt;]]&lt;/code&gt; 속성 은 함수 선언에서 선언자에 적용될 수 있으며 함수의 첫 번째 선언에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="0fd36a46bb2322c1e7d69551538bc1d5955fdf0c" translate="yes" xml:space="preserve">
          <source>The attribute-preserving overload (2) is implicitly invoked by &lt;a href=&quot;copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; when recursively copying directories. Its equivalent in boost.filesystem is &lt;a href=&quot;http://www.boost.org/doc/libs/1_57_0/libs/filesystem/doc/reference.html#copy_directory&quot;&gt;&lt;code&gt;copy_directory&lt;/code&gt;&lt;/a&gt; (with argument order reversed).</source>
          <target state="translated">디렉토리를 재귀 적으로 복사 할 때 &lt;a href=&quot;copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; 의해 속성 유지 과부하 (2)가 내재적으로 호출됩니다 . boost.filesystem에서 이에 상응하는이 &lt;a href=&quot;http://www.boost.org/doc/libs/1_57_0/libs/filesystem/doc/reference.html#copy_directory&quot;&gt; &lt;code&gt;copy_directory&lt;/code&gt; &lt;/a&gt; (와 인수의 순서가 반대로).</target>
        </trans-unit>
        <trans-unit id="d41955e8d96bded47f8643f2387d18f9f92f90a5" translate="yes" xml:space="preserve">
          <source>The badbit</source>
          <target state="translated">배드 비트</target>
        </trans-unit>
        <trans-unit id="e1b04e88b5ddc8259deb4bd09406ff0efc4d0c5e" translate="yes" xml:space="preserve">
          <source>The badbit is set by the following standard library functions:</source>
          <target state="translated">불량 비트는 다음과 같은 표준 라이브러리 함수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1951bf526d104734daee9af96f8ae5f5577df89d" translate="yes" xml:space="preserve">
          <source>The base class &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; implements character classification equivalent to the minimal &quot;C&quot; locale. The classification rules can be extended or modified if constructed with a non-default classification table argument, if constructed as &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; or as a user-defined derived facet. All &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; formatted input functions are required to use &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; for character classing during input parsing.</source>
          <target state="translated">기본 클래스 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 은 최소 &quot;C&quot;로캘에 해당하는 문자 분류를 구현합니다. &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 또는 사용자 정의 파생 패싯으로 구성된 경우 기본이 아닌 분류 테이블 인수로 구성된 경우 분류 규칙을 확장하거나 수정할 수 있습니다 . 입력 구문 분석 중 문자 분류에 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; &amp;lt;char&amp;gt; 을 사용하려면 모든 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; 형식의 입력 함수가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="23d729a8cc94f8c0414114c9a60e8acd1fc12d06" translate="yes" xml:space="preserve">
          <source>The base class version of the function calls &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; and increments &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">함수의 기본 클래스 버전은 &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 호출 하고 &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="201321ed2284d9de663a5a09379bb0e53b45a031" translate="yes" xml:space="preserve">
          <source>The base class version of the function does nothing. The derived classes may override this function to allow updates to the get area in the case of exhaustion.</source>
          <target state="translated">함수의 기본 클래스 버전은 아무 것도 수행하지 않습니다. 파생 된 클래스는이 함수를 재정 의하여 소모시 get 영역을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5380a7aca03357fb4bf7ea909e5b04af5dad0cc" translate="yes" xml:space="preserve">
          <source>The base class version of the function does nothing. The derived classes may override this function to allow updates to the put area in the case of exhaustion.</source>
          <target state="translated">함수의 기본 클래스 버전은 아무 것도 수행하지 않습니다. 파생 된 클래스는이 함수를 재정 의하여 고갈시 풋 영역을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00b20c8c1673e69db511f9701832d81f1b9b3c9b" translate="yes" xml:space="preserve">
          <source>The base class version of the function returns &lt;code&gt;Traits::eof()&lt;/code&gt;.</source>
          <target state="translated">함수의 기본 클래스 버전은 &lt;code&gt;Traits::eof()&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a068b851e69253d7268cdd6863af11c37cbd0d3a" translate="yes" xml:space="preserve">
          <source>The base class version of the function returns &lt;code&gt;traits::eof()&lt;/code&gt;.</source>
          <target state="translated">함수의 기본 클래스 버전은 &lt;code&gt;traits::eof()&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
